
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_cmds2.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/// @file ex_cmds2.c</a>
<a name="ln5">///</a>
<a name="ln6">/// Some more functions for command line commands</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;inttypes.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12">#include &lt;fcntl.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;nvim/vim.h&quot;</a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#ifdef HAVE_LOCALE_H</a>
<a name="ln17"># include &lt;locale.h&gt;</a>
<a name="ln18">#endif</a>
<a name="ln19">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln20">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln21">#include &quot;nvim/change.h&quot;</a>
<a name="ln22">#include &quot;nvim/charset.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln28">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln29">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln30">#include &quot;nvim/globals.h&quot;</a>
<a name="ln31">#include &quot;nvim/mark.h&quot;</a>
<a name="ln32">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln33">#include &quot;nvim/memline.h&quot;</a>
<a name="ln34">#include &quot;nvim/message.h&quot;</a>
<a name="ln35">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln36">#include &quot;nvim/garray.h&quot;</a>
<a name="ln37">#include &quot;nvim/memory.h&quot;</a>
<a name="ln38">#include &quot;nvim/move.h&quot;</a>
<a name="ln39">#include &quot;nvim/normal.h&quot;</a>
<a name="ln40">#include &quot;nvim/ops.h&quot;</a>
<a name="ln41">#include &quot;nvim/option.h&quot;</a>
<a name="ln42">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln43">#include &quot;nvim/path.h&quot;</a>
<a name="ln44">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln45">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln46">#include &quot;nvim/screen.h&quot;</a>
<a name="ln47">#include &quot;nvim/strings.h&quot;</a>
<a name="ln48">#include &quot;nvim/undo.h&quot;</a>
<a name="ln49">#include &quot;nvim/version.h&quot;</a>
<a name="ln50">#include &quot;nvim/window.h&quot;</a>
<a name="ln51">#include &quot;nvim/profile.h&quot;</a>
<a name="ln52">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln53">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln54">#include &quot;nvim/os/fs_defs.h&quot;</a>
<a name="ln55">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln56">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln57">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln58"> </a>
<a name="ln59"> </a>
<a name="ln60">/// Growarray to store info about already sourced scripts.</a>
<a name="ln61">/// Also store the dev/ino, so that we don't have to stat() each</a>
<a name="ln62">/// script when going through the list.</a>
<a name="ln63">typedef struct scriptitem_S {</a>
<a name="ln64">  char_u      *sn_name;</a>
<a name="ln65">  bool file_id_valid;</a>
<a name="ln66">  FileID file_id;</a>
<a name="ln67">  bool sn_prof_on;              ///&lt; true when script is/was profiled</a>
<a name="ln68">  bool sn_pr_force;             ///&lt; forceit: profile functions in this script</a>
<a name="ln69">  proftime_T sn_pr_child;       ///&lt; time set when going into first child</a>
<a name="ln70">  int sn_pr_nest;               ///&lt; nesting for sn_pr_child</a>
<a name="ln71">  // profiling the script as a whole</a>
<a name="ln72">  int sn_pr_count;              ///&lt; nr of times sourced</a>
<a name="ln73">  proftime_T sn_pr_total;       ///&lt; time spent in script + children</a>
<a name="ln74">  proftime_T sn_pr_self;        ///&lt; time spent in script itself</a>
<a name="ln75">  proftime_T sn_pr_start;       ///&lt; time at script start</a>
<a name="ln76">  proftime_T sn_pr_children;    ///&lt; time in children after script start</a>
<a name="ln77">  // profiling the script per line</a>
<a name="ln78">  garray_T sn_prl_ga;           ///&lt; things stored for every line</a>
<a name="ln79">  proftime_T sn_prl_start;      ///&lt; start time for current line</a>
<a name="ln80">  proftime_T sn_prl_children;   ///&lt; time spent in children for this line</a>
<a name="ln81">  proftime_T sn_prl_wait;       ///&lt; wait start time for current line</a>
<a name="ln82">  linenr_T sn_prl_idx;          ///&lt; index of line being timed; -1 if none</a>
<a name="ln83">  int sn_prl_execed;            ///&lt; line being timed was executed</a>
<a name="ln84">} scriptitem_T;</a>
<a name="ln85"> </a>
<a name="ln86">static garray_T script_items = { 0, 0, sizeof(scriptitem_T), 4, NULL };</a>
<a name="ln87">#define SCRIPT_ITEM(id) (((scriptitem_T *)script_items.ga_data)[(id) - 1])</a>
<a name="ln88"> </a>
<a name="ln89">// Struct used in sn_prl_ga for every line of a script.</a>
<a name="ln90">typedef struct sn_prl_S {</a>
<a name="ln91">  int snp_count;                ///&lt; nr of times line was executed</a>
<a name="ln92">  proftime_T sn_prl_total;      ///&lt; time spent in a line + children</a>
<a name="ln93">  proftime_T sn_prl_self;       ///&lt; time spent in a line itself</a>
<a name="ln94">} sn_prl_T;</a>
<a name="ln95"> </a>
<a name="ln96">/// Structure used to store info for each sourced file.</a>
<a name="ln97">/// It is shared between do_source() and getsourceline().</a>
<a name="ln98">/// This is required, because it needs to be handed to do_cmdline() and</a>
<a name="ln99">/// sourcing can be done recursively.</a>
<a name="ln100">struct source_cookie {</a>
<a name="ln101">  FILE *fp;                     ///&lt; opened file for sourcing</a>
<a name="ln102">  char_u *nextline;             ///&lt; if not NULL: line that was read ahead</a>
<a name="ln103">  linenr_T sourcing_lnum;       ///&lt; line number of the source file</a>
<a name="ln104">  int finished;                 ///&lt; &quot;:finish&quot; used</a>
<a name="ln105">#if defined(USE_CRNL)</a>
<a name="ln106">  int fileformat;               ///&lt; EOL_UNKNOWN, EOL_UNIX or EOL_DOS</a>
<a name="ln107">  bool error;                   ///&lt; true if LF found after CR-LF</a>
<a name="ln108">#endif</a>
<a name="ln109">  linenr_T breakpoint;          ///&lt; next line with breakpoint or zero</a>
<a name="ln110">  char_u *fname;                ///&lt; name of sourced file</a>
<a name="ln111">  int dbg_tick;                 ///&lt; debug_tick when breakpoint was set</a>
<a name="ln112">  int level;                    ///&lt; top nesting level of sourced file</a>
<a name="ln113">  vimconv_T conv;               ///&lt; type of conversion</a>
<a name="ln114">};</a>
<a name="ln115"> </a>
<a name="ln116">#  define PRL_ITEM(si, idx)     (((sn_prl_T *)(si)-&gt;sn_prl_ga.ga_data)[(idx)])</a>
<a name="ln117"> </a>
<a name="ln118">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln119"># include &quot;ex_cmds2.c.generated.h&quot;</a>
<a name="ln120">#endif</a>
<a name="ln121"> </a>
<a name="ln122">/// batch mode debugging: don't save and restore typeahead.</a>
<a name="ln123">static bool debug_greedy = false;</a>
<a name="ln124"> </a>
<a name="ln125">static char *debug_oldval = NULL;  // old and newval for debug expressions</a>
<a name="ln126">static char *debug_newval = NULL;</a>
<a name="ln127"> </a>
<a name="ln128">/// Debug mode. Repeatedly get Ex commands, until told to continue normal</a>
<a name="ln129">/// execution.</a>
<a name="ln130">void do_debug(char_u *cmd)</a>
<a name="ln131">{</a>
<a name="ln132">  int save_msg_scroll = msg_scroll;</a>
<a name="ln133">  int save_State = State;</a>
<a name="ln134">  int save_did_emsg = did_emsg;</a>
<a name="ln135">  const bool save_cmd_silent = cmd_silent;</a>
<a name="ln136">  int save_msg_silent = msg_silent;</a>
<a name="ln137">  int save_emsg_silent = emsg_silent;</a>
<a name="ln138">  int save_redir_off = redir_off;</a>
<a name="ln139">  tasave_T typeaheadbuf;</a>
<a name="ln140">  bool typeahead_saved = false;</a>
<a name="ln141">  int save_ignore_script = 0;</a>
<a name="ln142">  int save_ex_normal_busy;</a>
<a name="ln143">  int n;</a>
<a name="ln144">  char_u      *cmdline = NULL;</a>
<a name="ln145">  char_u      *p;</a>
<a name="ln146">  char        *tail = NULL;</a>
<a name="ln147">  static int last_cmd = 0;</a>
<a name="ln148">#define CMD_CONT        1</a>
<a name="ln149">#define CMD_NEXT        2</a>
<a name="ln150">#define CMD_STEP        3</a>
<a name="ln151">#define CMD_FINISH      4</a>
<a name="ln152">#define CMD_QUIT        5</a>
<a name="ln153">#define CMD_INTERRUPT   6</a>
<a name="ln154">#define CMD_BACKTRACE   7</a>
<a name="ln155">#define CMD_FRAME       8</a>
<a name="ln156">#define CMD_UP          9</a>
<a name="ln157">#define CMD_DOWN        10</a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160">  RedrawingDisabled++;          // don't redisplay the window</a>
<a name="ln161">  no_wait_return++;             // don't wait for return</a>
<a name="ln162">  did_emsg = false;             // don't use error from debugged stuff</a>
<a name="ln163">  cmd_silent = false;           // display commands</a>
<a name="ln164">  msg_silent = false;           // display messages</a>
<a name="ln165">  emsg_silent = false;          // display error messages</a>
<a name="ln166">  redir_off = true;             // don't redirect debug commands</a>
<a name="ln167"> </a>
<a name="ln168">  State = NORMAL;</a>
<a name="ln169">  debug_mode = true;</a>
<a name="ln170"> </a>
<a name="ln171">  if (!debug_did_msg) {</a>
<a name="ln172">    MSG(_(&quot;Entering Debug mode.  Type \&quot;cont\&quot; to continue.&quot;));</a>
<a name="ln173">  }</a>
<a name="ln174">  if (debug_oldval != NULL) {</a>
<a name="ln175">    smsg(_(&quot;Oldval = \&quot;%s\&quot;&quot;), debug_oldval);</a>
<a name="ln176">    xfree(debug_oldval);</a>
<a name="ln177">    debug_oldval = NULL;</a>
<a name="ln178">  }</a>
<a name="ln179">  if (debug_newval != NULL) {</a>
<a name="ln180">    smsg(_(&quot;Newval = \&quot;%s\&quot;&quot;), debug_newval);</a>
<a name="ln181">    xfree(debug_newval);</a>
<a name="ln182">    debug_newval = NULL;</a>
<a name="ln183">  }</a>
<a name="ln184">  if (sourcing_name != NULL) {</a>
<a name="ln185">    msg(sourcing_name);</a>
<a name="ln186">  }</a>
<a name="ln187">  if (sourcing_lnum != 0) {</a>
<a name="ln188">    smsg(_(&quot;line %&quot; PRId64 &quot;: %s&quot;), (int64_t)sourcing_lnum, cmd);</a>
<a name="ln189">  } else {</a>
<a name="ln190">    smsg(_(&quot;cmd: %s&quot;), cmd);</a>
<a name="ln191">  }</a>
<a name="ln192">  // Repeat getting a command and executing it.</a>
<a name="ln193">  for (;; ) {</a>
<a name="ln194">    msg_scroll = true;</a>
<a name="ln195">    need_wait_return = false;</a>
<a name="ln196">    // Save the current typeahead buffer and replace it with an empty one.</a>
<a name="ln197">    // This makes sure we get input from the user here and don't interfere</a>
<a name="ln198">    // with the commands being executed.  Reset &quot;ex_normal_busy&quot; to avoid</a>
<a name="ln199">    // the side effects of using &quot;:normal&quot;. Save the stuff buffer and make</a>
<a name="ln200">    // it empty. Set ignore_script to avoid reading from script input.</a>
<a name="ln201">    save_ex_normal_busy = ex_normal_busy;</a>
<a name="ln202">    ex_normal_busy = 0;</a>
<a name="ln203">    if (!debug_greedy) {</a>
<a name="ln204">      save_typeahead(&amp;typeaheadbuf);</a>
<a name="ln205">      typeahead_saved = true;</a>
<a name="ln206">      save_ignore_script = ignore_script;</a>
<a name="ln207">      ignore_script = true;</a>
<a name="ln208">    }</a>
<a name="ln209"> </a>
<a name="ln210">    xfree(cmdline);</a>
<a name="ln211">    cmdline = (char_u *)getcmdline_prompt('&gt;', NULL, 0, EXPAND_NOTHING, NULL,</a>
<a name="ln212">                                          CALLBACK_NONE);</a>
<a name="ln213"> </a>
<a name="ln214">    if (typeahead_saved) {</a>
<a name="ln215">      restore_typeahead(&amp;typeaheadbuf);</a>
<a name="ln216">      ignore_script = save_ignore_script;</a>
<a name="ln217">    }</a>
<a name="ln218">    ex_normal_busy = save_ex_normal_busy;</a>
<a name="ln219"> </a>
<a name="ln220">    cmdline_row = msg_row;</a>
<a name="ln221">    msg_starthere();</a>
<a name="ln222">    if (cmdline != NULL) {</a>
<a name="ln223">      // If this is a debug command, set &quot;last_cmd&quot;.</a>
<a name="ln224">      // If not, reset &quot;last_cmd&quot;.</a>
<a name="ln225">      // For a blank line use previous command.</a>
<a name="ln226">      p = skipwhite(cmdline);</a>
<a name="ln227">      if (*p != NUL) {</a>
<a name="ln228">        switch (*p) {</a>
<a name="ln229">        case 'c': last_cmd = CMD_CONT;</a>
<a name="ln230">          tail = &quot;ont&quot;;</a>
<a name="ln231">          break;</a>
<a name="ln232">        case 'n': last_cmd = CMD_NEXT;</a>
<a name="ln233">          tail = &quot;ext&quot;;</a>
<a name="ln234">          break;</a>
<a name="ln235">        case 's': last_cmd = CMD_STEP;</a>
<a name="ln236">          tail = &quot;tep&quot;;</a>
<a name="ln237">          break;</a>
<a name="ln238">        case 'f':</a>
<a name="ln239">          last_cmd = 0;</a>
<a name="ln240">          if (p[1] == 'r') {</a>
<a name="ln241">            last_cmd = CMD_FRAME;</a>
<a name="ln242">            tail = &quot;rame&quot;;</a>
<a name="ln243">          } else {</a>
<a name="ln244">            last_cmd = CMD_FINISH;</a>
<a name="ln245">            tail = &quot;inish&quot;;</a>
<a name="ln246">          }</a>
<a name="ln247">          break;</a>
<a name="ln248">        case 'q': last_cmd = CMD_QUIT;</a>
<a name="ln249">          tail = &quot;uit&quot;;</a>
<a name="ln250">          break;</a>
<a name="ln251">        case 'i': last_cmd = CMD_INTERRUPT;</a>
<a name="ln252">          tail = &quot;nterrupt&quot;;</a>
<a name="ln253">          break;</a>
<a name="ln254">        case 'b':</a>
<a name="ln255">          last_cmd = CMD_BACKTRACE;</a>
<a name="ln256">          if (p[1] == 't') {</a>
<a name="ln257">            tail = &quot;t&quot;;</a>
<a name="ln258">          } else {</a>
<a name="ln259">            tail = &quot;acktrace&quot;;</a>
<a name="ln260">          }</a>
<a name="ln261">          break;</a>
<a name="ln262">        case 'w':</a>
<a name="ln263">          last_cmd = CMD_BACKTRACE;</a>
<a name="ln264">          tail = &quot;here&quot;;</a>
<a name="ln265">          break;</a>
<a name="ln266">        case 'u':</a>
<a name="ln267">          last_cmd = CMD_UP;</a>
<a name="ln268">          tail = &quot;p&quot;;</a>
<a name="ln269">          break;</a>
<a name="ln270">        case 'd':</a>
<a name="ln271">          last_cmd = CMD_DOWN;</a>
<a name="ln272">          tail = &quot;own&quot;;</a>
<a name="ln273">          break;</a>
<a name="ln274">        default: last_cmd = 0;</a>
<a name="ln275">        }</a>
<a name="ln276">        if (last_cmd != 0) {</a>
<a name="ln277">          // Check that the tail matches.</a>
<a name="ln278">          p++;</a>
<a name="ln279">          while (*p != NUL &amp;&amp; *p == *tail) {</a>
<a name="ln280">            p++;</a>
<a name="ln281">            tail++;</a>
<a name="ln282">          }</a>
<a name="ln283">          if (ASCII_ISALPHA(*p) &amp;&amp; last_cmd != CMD_FRAME) {</a>
<a name="ln284">            last_cmd = 0;</a>
<a name="ln285">          }</a>
<a name="ln286">        }</a>
<a name="ln287">      }</a>
<a name="ln288"> </a>
<a name="ln289">      if (last_cmd != 0) {</a>
<a name="ln290">        // Execute debug command: decided where to break next and return.</a>
<a name="ln291">        switch (last_cmd) {</a>
<a name="ln292">        case CMD_CONT:</a>
<a name="ln293">          debug_break_level = -1;</a>
<a name="ln294">          break;</a>
<a name="ln295">        case CMD_NEXT:</a>
<a name="ln296">          debug_break_level = ex_nesting_level;</a>
<a name="ln297">          break;</a>
<a name="ln298">        case CMD_STEP:</a>
<a name="ln299">          debug_break_level = 9999;</a>
<a name="ln300">          break;</a>
<a name="ln301">        case CMD_FINISH:</a>
<a name="ln302">          debug_break_level = ex_nesting_level - 1;</a>
<a name="ln303">          break;</a>
<a name="ln304">        case CMD_QUIT:</a>
<a name="ln305">          got_int = true;</a>
<a name="ln306">          debug_break_level = -1;</a>
<a name="ln307">          break;</a>
<a name="ln308">        case CMD_INTERRUPT:</a>
<a name="ln309">          got_int = true;</a>
<a name="ln310">          debug_break_level = 9999;</a>
<a name="ln311">          // Do not repeat &quot;&gt;interrupt&quot; cmd, continue stepping.</a>
<a name="ln312">          last_cmd = CMD_STEP;</a>
<a name="ln313">          break;</a>
<a name="ln314">        case CMD_BACKTRACE:</a>
<a name="ln315">          do_showbacktrace(cmd);</a>
<a name="ln316">          continue;</a>
<a name="ln317">        case CMD_FRAME:</a>
<a name="ln318">          if (*p == NUL) {</a>
<a name="ln319">            do_showbacktrace(cmd);</a>
<a name="ln320">          } else {</a>
<a name="ln321">            p = skipwhite(p);</a>
<a name="ln322">            do_setdebugtracelevel(p);</a>
<a name="ln323">          }</a>
<a name="ln324">          continue;</a>
<a name="ln325">        case CMD_UP:</a>
<a name="ln326">          debug_backtrace_level++;</a>
<a name="ln327">          do_checkbacktracelevel();</a>
<a name="ln328">          continue;</a>
<a name="ln329">        case CMD_DOWN:</a>
<a name="ln330">          debug_backtrace_level--;</a>
<a name="ln331">          do_checkbacktracelevel();</a>
<a name="ln332">          continue;</a>
<a name="ln333">        }</a>
<a name="ln334">        // Going out reset backtrace_level</a>
<a name="ln335">        debug_backtrace_level = 0;</a>
<a name="ln336">        break;</a>
<a name="ln337">      }</a>
<a name="ln338"> </a>
<a name="ln339">      // don't debug this command</a>
<a name="ln340">      n = debug_break_level;</a>
<a name="ln341">      debug_break_level = -1;</a>
<a name="ln342">      (void)do_cmdline(cmdline, getexline, NULL,</a>
<a name="ln343">                       DOCMD_VERBOSE|DOCMD_EXCRESET);</a>
<a name="ln344">      debug_break_level = n;</a>
<a name="ln345">    }</a>
<a name="ln346">    lines_left = (int)(Rows - 1);</a>
<a name="ln347">  }</a>
<a name="ln348">  xfree(cmdline);</a>
<a name="ln349"> </a>
<a name="ln350">  RedrawingDisabled--;</a>
<a name="ln351">  no_wait_return--;</a>
<a name="ln352">  redraw_all_later(NOT_VALID);</a>
<a name="ln353">  need_wait_return = false;</a>
<a name="ln354">  msg_scroll = save_msg_scroll;</a>
<a name="ln355">  lines_left = (int)(Rows - 1);</a>
<a name="ln356">  State = save_State;</a>
<a name="ln357">  debug_mode = false;</a>
<a name="ln358">  did_emsg = save_did_emsg;</a>
<a name="ln359">  cmd_silent = save_cmd_silent;</a>
<a name="ln360">  msg_silent = save_msg_silent;</a>
<a name="ln361">  emsg_silent = save_emsg_silent;</a>
<a name="ln362">  redir_off = save_redir_off;</a>
<a name="ln363"> </a>
<a name="ln364">  // Only print the message again when typing a command before coming back here.</a>
<a name="ln365">  debug_did_msg = true;</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">static int get_maxbacktrace_level(void)</a>
<a name="ln369">{</a>
<a name="ln370">  int maxbacktrace = 0;</a>
<a name="ln371"> </a>
<a name="ln372">  if (sourcing_name != NULL) {</a>
<a name="ln373">    char *p = (char *)sourcing_name;</a>
<a name="ln374">    char *q;</a>
<a name="ln375">    while ((q = strstr(p, &quot;..&quot;)) != NULL) {</a>
<a name="ln376">      p = q + 2;</a>
<a name="ln377">      maxbacktrace++;</a>
<a name="ln378">    }</a>
<a name="ln379">  }</a>
<a name="ln380">  return maxbacktrace;</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">static void do_setdebugtracelevel(char_u *arg)</a>
<a name="ln384">{</a>
<a name="ln385">  int level = atoi((char *)arg);</a>
<a name="ln386">  if (*arg == '+' || level &lt; 0) {</a>
<a name="ln387">    debug_backtrace_level += level;</a>
<a name="ln388">  } else {</a>
<a name="ln389">    debug_backtrace_level = level;</a>
<a name="ln390">  }</a>
<a name="ln391"> </a>
<a name="ln392">  do_checkbacktracelevel();</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">static void do_checkbacktracelevel(void)</a>
<a name="ln396">{</a>
<a name="ln397">  if (debug_backtrace_level &lt; 0) {</a>
<a name="ln398">    debug_backtrace_level = 0;</a>
<a name="ln399">    MSG(_(&quot;frame is zero&quot;));</a>
<a name="ln400">  } else {</a>
<a name="ln401">    int max = get_maxbacktrace_level();</a>
<a name="ln402">    if (debug_backtrace_level &gt; max) {</a>
<a name="ln403">      debug_backtrace_level = max;</a>
<a name="ln404">      smsg(_(&quot;frame at highest level: %d&quot;), max);</a>
<a name="ln405">    }</a>
<a name="ln406">  }</a>
<a name="ln407">}</a>
<a name="ln408"> </a>
<a name="ln409">static void do_showbacktrace(char_u *cmd)</a>
<a name="ln410">{</a>
<a name="ln411">  if (sourcing_name != NULL) {</a>
<a name="ln412">    int i = 0;</a>
<a name="ln413">    int max = get_maxbacktrace_level();</a>
<a name="ln414">    char *cur = (char *)sourcing_name;</a>
<a name="ln415">    while (!got_int) {</a>
<a name="ln416">      char *next = strstr(cur, &quot;..&quot;);</a>
<a name="ln417">      if (next != NULL) {</a>
<a name="ln418">        *next = NUL;</a>
<a name="ln419">      }</a>
<a name="ln420">      if (i == max - debug_backtrace_level) {</a>
<a name="ln421">        smsg(&quot;-&gt;%d %s&quot;, max - i, cur);</a>
<a name="ln422">      } else {</a>
<a name="ln423">        smsg(&quot;  %d %s&quot;, max - i, cur);</a>
<a name="ln424">      }</a>
<a name="ln425">      i++;</a>
<a name="ln426">      if (next == NULL) {</a>
<a name="ln427">        break;</a>
<a name="ln428">      }</a>
<a name="ln429">      *next = '.';</a>
<a name="ln430">      cur = next + 2;</a>
<a name="ln431">    }</a>
<a name="ln432">  }</a>
<a name="ln433">  if (sourcing_lnum != 0) {</a>
<a name="ln434">    smsg(_(&quot;line %&quot; PRId64 &quot;: %s&quot;), (int64_t)sourcing_lnum, cmd);</a>
<a name="ln435">  } else {</a>
<a name="ln436">    smsg(_(&quot;cmd: %s&quot;), cmd);</a>
<a name="ln437">  }</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440"> </a>
<a name="ln441">/// &quot;:debug&quot;.</a>
<a name="ln442">void ex_debug(exarg_T *eap)</a>
<a name="ln443">{</a>
<a name="ln444">  int debug_break_level_save = debug_break_level;</a>
<a name="ln445"> </a>
<a name="ln446">  debug_break_level = 9999;</a>
<a name="ln447">  do_cmdline_cmd((char *)eap-&gt;arg);</a>
<a name="ln448">  debug_break_level = debug_break_level_save;</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">static char_u   *debug_breakpoint_name = NULL;</a>
<a name="ln452">static linenr_T debug_breakpoint_lnum;</a>
<a name="ln453"> </a>
<a name="ln454">/// When debugging or a breakpoint is set on a skipped command, no debug prompt</a>
<a name="ln455">/// is shown by do_one_cmd().  This situation is indicated by debug_skipped, and</a>
<a name="ln456">/// debug_skipped_name is then set to the source name in the breakpoint case. If</a>
<a name="ln457">/// a skipped command decides itself that a debug prompt should be displayed, it</a>
<a name="ln458">/// can do so by calling dbg_check_skipped().</a>
<a name="ln459">static int debug_skipped;</a>
<a name="ln460">static char_u   *debug_skipped_name;</a>
<a name="ln461"> </a>
<a name="ln462">/// Go to debug mode when a breakpoint was encountered or &quot;ex_nesting_level&quot; is</a>
<a name="ln463">/// at or below the break level.  But only when the line is actually</a>
<a name="ln464">/// executed.  Return true and set breakpoint_name for skipped commands that</a>
<a name="ln465">/// decide to execute something themselves.</a>
<a name="ln466">/// Called from do_one_cmd() before executing a command.</a>
<a name="ln467">void dbg_check_breakpoint(exarg_T *eap)</a>
<a name="ln468">{</a>
<a name="ln469">  char_u      *p;</a>
<a name="ln470"> </a>
<a name="ln471">  debug_skipped = false;</a>
<a name="ln472">  if (debug_breakpoint_name != NULL) {</a>
<a name="ln473">    if (!eap-&gt;skip) {</a>
<a name="ln474">      // replace K_SNR with &quot;&lt;SNR&gt;&quot;</a>
<a name="ln475">      if (debug_breakpoint_name[0] == K_SPECIAL</a>
<a name="ln476">          &amp;&amp; debug_breakpoint_name[1] == KS_EXTRA</a>
<a name="ln477">          &amp;&amp; debug_breakpoint_name[2] == (int)KE_SNR) {</a>
<a name="ln478">        p = (char_u *)&quot;&lt;SNR&gt;&quot;;</a>
<a name="ln479">      } else {</a>
<a name="ln480">        p = (char_u *)&quot;&quot;;</a>
<a name="ln481">      }</a>
<a name="ln482">      smsg(_(&quot;Breakpoint in \&quot;%s%s\&quot; line %&quot; PRId64),</a>
<a name="ln483">           p,</a>
<a name="ln484">           debug_breakpoint_name + (*p == NUL ? 0 : 3),</a>
<a name="ln485">           (int64_t)debug_breakpoint_lnum);</a>
<a name="ln486">      debug_breakpoint_name = NULL;</a>
<a name="ln487">      do_debug(eap-&gt;cmd);</a>
<a name="ln488">    } else {</a>
<a name="ln489">      debug_skipped = true;</a>
<a name="ln490">      debug_skipped_name = debug_breakpoint_name;</a>
<a name="ln491">      debug_breakpoint_name = NULL;</a>
<a name="ln492">    }</a>
<a name="ln493">  } else if (ex_nesting_level &lt;= debug_break_level) {</a>
<a name="ln494">    if (!eap-&gt;skip) {</a>
<a name="ln495">      do_debug(eap-&gt;cmd);</a>
<a name="ln496">    } else {</a>
<a name="ln497">      debug_skipped = true;</a>
<a name="ln498">      debug_skipped_name = NULL;</a>
<a name="ln499">    }</a>
<a name="ln500">  }</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">/// Go to debug mode if skipped by dbg_check_breakpoint() because eap-&gt;skip was</a>
<a name="ln504">/// set.</a>
<a name="ln505">///</a>
<a name="ln506">/// @return true when the debug mode is entered this time.</a>
<a name="ln507">bool dbg_check_skipped(exarg_T *eap)</a>
<a name="ln508">{</a>
<a name="ln509">  int prev_got_int;</a>
<a name="ln510"> </a>
<a name="ln511">  if (debug_skipped) {</a>
<a name="ln512">    // Save the value of got_int and reset it.  We don't want a previous</a>
<a name="ln513">    // interruption cause flushing the input buffer.</a>
<a name="ln514">    prev_got_int = got_int;</a>
<a name="ln515">    got_int = false;</a>
<a name="ln516">    debug_breakpoint_name = debug_skipped_name;</a>
<a name="ln517">    // eap-&gt;skip is true</a>
<a name="ln518">    eap-&gt;skip = false;</a>
<a name="ln519">    dbg_check_breakpoint(eap);</a>
<a name="ln520">    eap-&gt;skip = true;</a>
<a name="ln521">    got_int |= prev_got_int;</a>
<a name="ln522">    return true;</a>
<a name="ln523">  }</a>
<a name="ln524">  return false;</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">/// The list of breakpoints: dbg_breakp.</a>
<a name="ln528">/// This is a grow-array of structs.</a>
<a name="ln529">struct debuggy {</a>
<a name="ln530">  int dbg_nr;                   ///&lt; breakpoint number</a>
<a name="ln531">  int dbg_type;                 ///&lt; DBG_FUNC or DBG_FILE or DBG_EXPR</a>
<a name="ln532">  char_u *dbg_name;             ///&lt; function, expression or file name</a>
<a name="ln533">  regprog_T *dbg_prog;          ///&lt; regexp program</a>
<a name="ln534">  linenr_T dbg_lnum;            ///&lt; line number in function or file</a>
<a name="ln535">  int dbg_forceit;              ///&lt; ! used</a>
<a name="ln536">  typval_T *dbg_val;            ///&lt; last result of watchexpression</a>
<a name="ln537">  int dbg_level;                ///&lt; stored nested level for expr</a>
<a name="ln538">};</a>
<a name="ln539"> </a>
<a name="ln540">static garray_T dbg_breakp = { 0, 0, sizeof(struct debuggy), 4, NULL };</a>
<a name="ln541">#define BREAKP(idx)             (((struct debuggy *)dbg_breakp.ga_data)[idx])</a>
<a name="ln542">#define DEBUGGY(gap, idx)       (((struct debuggy *)gap-&gt;ga_data)[idx])</a>
<a name="ln543">static int last_breakp = 0;     // nr of last defined breakpoint</a>
<a name="ln544"> </a>
<a name="ln545">// Profiling uses file and func names similar to breakpoints.</a>
<a name="ln546">static garray_T prof_ga = { 0, 0, sizeof(struct debuggy), 4, NULL };</a>
<a name="ln547">#define DBG_FUNC        1</a>
<a name="ln548">#define DBG_FILE        2</a>
<a name="ln549">#define DBG_EXPR        3</a>
<a name="ln550"> </a>
<a name="ln551"> </a>
<a name="ln552">/// Parse the arguments of &quot;:profile&quot;, &quot;:breakadd&quot; or &quot;:breakdel&quot; and put them</a>
<a name="ln553">/// in the entry just after the last one in dbg_breakp.  Note that &quot;dbg_name&quot;</a>
<a name="ln554">/// is allocated.</a>
<a name="ln555">/// Returns FAIL for failure.</a>
<a name="ln556">///</a>
<a name="ln557">/// @param arg</a>
<a name="ln558">/// @param gap  either &amp;dbg_breakp or &amp;prof_ga</a>
<a name="ln559">static int dbg_parsearg(char_u *arg, garray_T *gap)</a>
<a name="ln560">{</a>
<a name="ln561">  char_u      *p = arg;</a>
<a name="ln562">  char_u      *q;</a>
<a name="ln563">  struct debuggy *bp;</a>
<a name="ln564">  bool here = false;</a>
<a name="ln565"> </a>
<a name="ln566">  ga_grow(gap, 1);</a>
<a name="ln567"> </a>
<a name="ln568">  bp = &amp;DEBUGGY(gap, gap-&gt;ga_len);</a>
<a name="ln569"> </a>
<a name="ln570">  // Find &quot;func&quot; or &quot;file&quot;.</a>
<a name="ln571">  if (STRNCMP(p, &quot;func&quot;, 4) == 0) {</a>
<a name="ln572">    bp-&gt;dbg_type = DBG_FUNC;</a>
<a name="ln573">  } else if (STRNCMP(p, &quot;file&quot;, 4) == 0) {</a>
<a name="ln574">    bp-&gt;dbg_type = DBG_FILE;</a>
<a name="ln575">  } else if (gap != &amp;prof_ga &amp;&amp; STRNCMP(p, &quot;here&quot;, 4) == 0) {</a>
<a name="ln576">    if (curbuf-&gt;b_ffname == NULL) {</a>
<a name="ln577">      EMSG(_(e_noname));</a>
<a name="ln578">      return FAIL;</a>
<a name="ln579">    }</a>
<a name="ln580">    bp-&gt;dbg_type = DBG_FILE;</a>
<a name="ln581">    here = true;</a>
<a name="ln582">  } else if (gap != &amp;prof_ga &amp;&amp; STRNCMP(p, &quot;expr&quot;, 4) == 0) {</a>
<a name="ln583">    bp-&gt;dbg_type = DBG_EXPR;</a>
<a name="ln584">  } else {</a>
<a name="ln585">    EMSG2(_(e_invarg2), p);</a>
<a name="ln586">    return FAIL;</a>
<a name="ln587">  }</a>
<a name="ln588">  p = skipwhite(p + 4);</a>
<a name="ln589"> </a>
<a name="ln590">  // Find optional line number.</a>
<a name="ln591">  if (here) {</a>
<a name="ln592">    bp-&gt;dbg_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln593">  } else if (gap != &amp;prof_ga &amp;&amp; ascii_isdigit(*p)) {</a>
<a name="ln594">    bp-&gt;dbg_lnum = getdigits_long(&amp;p, true, 0);</a>
<a name="ln595">    p = skipwhite(p);</a>
<a name="ln596">  } else {</a>
<a name="ln597">    bp-&gt;dbg_lnum = 0;</a>
<a name="ln598">  }</a>
<a name="ln599"> </a>
<a name="ln600">  // Find the function or file name.  Don't accept a function name with ().</a>
<a name="ln601">  if ((!here &amp;&amp; *p == NUL)</a>
<a name="ln602">      || (here &amp;&amp; *p != NUL)</a>
<a name="ln603">      || (bp-&gt;dbg_type == DBG_FUNC &amp;&amp; strstr((char *)p, &quot;()&quot;) != NULL)) {</a>
<a name="ln604">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln605">    return FAIL;</a>
<a name="ln606">  }</a>
<a name="ln607"> </a>
<a name="ln608">  if (bp-&gt;dbg_type == DBG_FUNC) {</a>
<a name="ln609">    bp-&gt;dbg_name = vim_strsave(p);</a>
<a name="ln610">  } else if (here) {</a>
<a name="ln611">    bp-&gt;dbg_name = vim_strsave(curbuf-&gt;b_ffname);</a>
<a name="ln612">  } else if (bp-&gt;dbg_type == DBG_EXPR) {</a>
<a name="ln613">    bp-&gt;dbg_name = vim_strsave(p);</a>
<a name="ln614">    bp-&gt;dbg_val = eval_expr(bp-&gt;dbg_name);</a>
<a name="ln615">  } else {</a>
<a name="ln616">    // Expand the file name in the same way as do_source().  This means</a>
<a name="ln617">    // doing it twice, so that $DIR/file gets expanded when $DIR is</a>
<a name="ln618">    // &quot;~/dir&quot;.</a>
<a name="ln619">    q = expand_env_save(p);</a>
<a name="ln620">    if (q == NULL) {</a>
<a name="ln621">      return FAIL;</a>
<a name="ln622">    }</a>
<a name="ln623">    p = expand_env_save(q);</a>
<a name="ln624">    xfree(q);</a>
<a name="ln625">    if (p == NULL) {</a>
<a name="ln626">      return FAIL;</a>
<a name="ln627">    }</a>
<a name="ln628">    if (*p != '*') {</a>
<a name="ln629">      bp-&gt;dbg_name = (char_u *)fix_fname((char *)p);</a>
<a name="ln630">      xfree(p);</a>
<a name="ln631">    } else {</a>
<a name="ln632">      bp-&gt;dbg_name = p;</a>
<a name="ln633">    }</a>
<a name="ln634">  }</a>
<a name="ln635"> </a>
<a name="ln636">  if (bp-&gt;dbg_name == NULL) {</a>
<a name="ln637">    return FAIL;</a>
<a name="ln638">  }</a>
<a name="ln639">  return OK;</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">/// &quot;:breakadd&quot;.  Also used for &quot;:profile&quot;.</a>
<a name="ln643">void ex_breakadd(exarg_T *eap)</a>
<a name="ln644">{</a>
<a name="ln645">  struct debuggy *bp;</a>
<a name="ln646">  garray_T    *gap;</a>
<a name="ln647"> </a>
<a name="ln648">  gap = &amp;dbg_breakp;</a>
<a name="ln649">  if (eap-&gt;cmdidx == CMD_profile) {</a>
<a name="ln650">    gap = &amp;prof_ga;</a>
<a name="ln651">  }</a>
<a name="ln652"> </a>
<a name="ln653">  if (dbg_parsearg(eap-&gt;arg, gap) == OK) {</a>
<a name="ln654">    bp = &amp;DEBUGGY(gap, gap-&gt;ga_len);</a>
<a name="ln655">    bp-&gt;dbg_forceit = eap-&gt;forceit;</a>
<a name="ln656"> </a>
<a name="ln657">    if (bp-&gt;dbg_type != DBG_EXPR) {</a>
<a name="ln658">      char_u *pat = file_pat_to_reg_pat(bp-&gt;dbg_name, NULL, NULL, false);</a>
<a name="ln659">      if (pat != NULL) {</a>
<a name="ln660">        bp-&gt;dbg_prog = vim_regcomp(pat, RE_MAGIC + RE_STRING);</a>
<a name="ln661">        xfree(pat);</a>
<a name="ln662">      }</a>
<a name="ln663">      if (pat == NULL || bp-&gt;dbg_prog == NULL) {</a>
<a name="ln664">        xfree(bp-&gt;dbg_name);</a>
<a name="ln665">      } else {</a>
<a name="ln666">        if (bp-&gt;dbg_lnum == 0) {           // default line number is 1</a>
<a name="ln667">          bp-&gt;dbg_lnum = 1;</a>
<a name="ln668">        }</a>
<a name="ln669">        if (eap-&gt;cmdidx != CMD_profile) {</a>
<a name="ln670">          DEBUGGY(gap, gap-&gt;ga_len).dbg_nr = ++last_breakp;</a>
<a name="ln671">          debug_tick++;</a>
<a name="ln672">        }</a>
<a name="ln673">        gap-&gt;ga_len++;</a>
<a name="ln674">      }</a>
<a name="ln675">    } else {</a>
<a name="ln676">      // DBG_EXPR</a>
<a name="ln677">      DEBUGGY(gap, gap-&gt;ga_len++).dbg_nr = ++last_breakp;</a>
<a name="ln678">      debug_tick++;</a>
<a name="ln679">    }</a>
<a name="ln680">  }</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">/// &quot;:debuggreedy&quot;.</a>
<a name="ln684">void ex_debuggreedy(exarg_T *eap)</a>
<a name="ln685">{</a>
<a name="ln686">  if (eap-&gt;addr_count == 0 || eap-&gt;line2 != 0) {</a>
<a name="ln687">    debug_greedy = true;</a>
<a name="ln688">  } else {</a>
<a name="ln689">    debug_greedy = false;</a>
<a name="ln690">  }</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">/// &quot;:breakdel&quot; and &quot;:profdel&quot;.</a>
<a name="ln694">void ex_breakdel(exarg_T *eap)</a>
<a name="ln695">{</a>
<a name="ln696">  struct debuggy *bp, *bpi;</a>
<a name="ln697">  int nr;</a>
<a name="ln698">  int todel = -1;</a>
<a name="ln699">  bool del_all = false;</a>
<a name="ln700">  linenr_T best_lnum = 0;</a>
<a name="ln701">  garray_T    *gap;</a>
<a name="ln702"> </a>
<a name="ln703">  gap = &amp;dbg_breakp;</a>
<a name="ln704">  if (eap-&gt;cmdidx == CMD_profdel) {</a>
<a name="ln705">    gap = &amp;prof_ga;</a>
<a name="ln706">  }</a>
<a name="ln707"> </a>
<a name="ln708">  if (ascii_isdigit(*eap-&gt;arg)) {</a>
<a name="ln709">    // &quot;:breakdel {nr}&quot;</a>
<a name="ln710">    nr = atoi((char *)eap-&gt;arg);</a>
<a name="ln711">    for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln712">      if (DEBUGGY(gap, i).dbg_nr == nr) {</a>
<a name="ln713">        todel = i;</a>
<a name="ln714">        break;</a>
<a name="ln715">      }</a>
<a name="ln716">    }</a>
<a name="ln717">  } else if (*eap-&gt;arg == '*') {</a>
<a name="ln718">    todel = 0;</a>
<a name="ln719">    del_all = true;</a>
<a name="ln720">  } else {</a>
<a name="ln721">    // &quot;:breakdel {func|file|expr} [lnum] {name}&quot;</a>
<a name="ln722">    if (dbg_parsearg(eap-&gt;arg, gap) == FAIL) {</a>
<a name="ln723">      return;</a>
<a name="ln724">    }</a>
<a name="ln725">    bp = &amp;DEBUGGY(gap, gap-&gt;ga_len);</a>
<a name="ln726">    for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln727">      bpi = &amp;DEBUGGY(gap, i);</a>
<a name="ln728">      if (bp-&gt;dbg_type == bpi-&gt;dbg_type</a>
<a name="ln729">          &amp;&amp; STRCMP(bp-&gt;dbg_name, bpi-&gt;dbg_name) == 0</a>
<a name="ln730">          &amp;&amp; (bp-&gt;dbg_lnum == bpi-&gt;dbg_lnum</a>
<a name="ln731">              || (bp-&gt;dbg_lnum == 0</a>
<a name="ln732">                  &amp;&amp; (best_lnum == 0</a>
<a name="ln733">                      || bpi-&gt;dbg_lnum &lt; best_lnum)))) {</a>
<a name="ln734">        todel = i;</a>
<a name="ln735">        best_lnum = bpi-&gt;dbg_lnum;</a>
<a name="ln736">      }</a>
<a name="ln737">    }</a>
<a name="ln738">    xfree(bp-&gt;dbg_name);</a>
<a name="ln739">  }</a>
<a name="ln740"> </a>
<a name="ln741">  if (todel &lt; 0) {</a>
<a name="ln742">    EMSG2(_(&quot;E161: Breakpoint not found: %s&quot;), eap-&gt;arg);</a>
<a name="ln743">  } else {</a>
<a name="ln744">    while (!GA_EMPTY(gap)) {</a>
<a name="ln745">      xfree(DEBUGGY(gap, todel).dbg_name);</a>
<a name="ln746">      if (DEBUGGY(gap, todel).dbg_type == DBG_EXPR</a>
<a name="ln747">          &amp;&amp; DEBUGGY(gap, todel).dbg_val != NULL) {</a>
<a name="ln748">        tv_free(DEBUGGY(gap, todel).dbg_val);</a>
<a name="ln749">      }</a>
<a name="ln750">      vim_regfree(DEBUGGY(gap, todel).dbg_prog);</a>
<a name="ln751">      gap-&gt;ga_len--;</a>
<a name="ln752">      if (todel &lt; gap-&gt;ga_len) {</a>
<a name="ln753">        memmove(&amp;DEBUGGY(gap, todel), &amp;DEBUGGY(gap, todel + 1),</a>
<a name="ln754">                (size_t)(gap-&gt;ga_len - todel) * sizeof(struct debuggy));</a>
<a name="ln755">      }</a>
<a name="ln756">      if (eap-&gt;cmdidx == CMD_breakdel) {</a>
<a name="ln757">        debug_tick++;</a>
<a name="ln758">      }</a>
<a name="ln759">      if (!del_all) {</a>
<a name="ln760">        break;</a>
<a name="ln761">      }</a>
<a name="ln762">    }</a>
<a name="ln763"> </a>
<a name="ln764">    // If all breakpoints were removed clear the array.</a>
<a name="ln765">    if (GA_EMPTY(gap)) {</a>
<a name="ln766">      ga_clear(gap);</a>
<a name="ln767">    }</a>
<a name="ln768">  }</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771">/// &quot;:breaklist&quot;.</a>
<a name="ln772">void ex_breaklist(exarg_T *eap)</a>
<a name="ln773">{</a>
<a name="ln774">  struct debuggy *bp;</a>
<a name="ln775"> </a>
<a name="ln776">  if (GA_EMPTY(&amp;dbg_breakp)) {</a>
<a name="ln777">    MSG(_(&quot;No breakpoints defined&quot;));</a>
<a name="ln778">  } else {</a>
<a name="ln779">    for (int i = 0; i &lt; dbg_breakp.ga_len; i++) {</a>
<a name="ln780">      bp = &amp;BREAKP(i);</a>
<a name="ln781">      if (bp-&gt;dbg_type == DBG_FILE) {</a>
<a name="ln782">        home_replace(NULL, bp-&gt;dbg_name, NameBuff, MAXPATHL, true);</a>
<a name="ln783">      }</a>
<a name="ln784">      if (bp-&gt;dbg_type != DBG_EXPR) {</a>
<a name="ln785">        smsg(_(&quot;%3d  %s %s  line %&quot; PRId64),</a>
<a name="ln786">             bp-&gt;dbg_nr,</a>
<a name="ln787">             bp-&gt;dbg_type == DBG_FUNC ? &quot;func&quot; : &quot;file&quot;,</a>
<a name="ln788">             bp-&gt;dbg_type == DBG_FUNC ? bp-&gt;dbg_name : NameBuff,</a>
<a name="ln789">             (int64_t)bp-&gt;dbg_lnum);</a>
<a name="ln790">      } else {</a>
<a name="ln791">        smsg(_(&quot;%3d  expr %s&quot;), bp-&gt;dbg_nr, bp-&gt;dbg_name);</a>
<a name="ln792">      }</a>
<a name="ln793">    }</a>
<a name="ln794">  }</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797">/// Find a breakpoint for a function or sourced file.</a>
<a name="ln798">/// Returns line number at which to break; zero when no matching breakpoint.</a>
<a name="ln799">linenr_T</a>
<a name="ln800">dbg_find_breakpoint(</a>
<a name="ln801">    bool file,             // true for a file, false for a function</a>
<a name="ln802">    char_u *fname,         // file or function name</a>
<a name="ln803">    linenr_T after         // after this line number</a>
<a name="ln804">)</a>
<a name="ln805">{</a>
<a name="ln806">  return debuggy_find(file, fname, after, &amp;dbg_breakp, NULL);</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809">/// @param file     true for a file, false for a function</a>
<a name="ln810">/// @param fname    file or function name</a>
<a name="ln811">/// @param fp[out]  forceit</a>
<a name="ln812">///</a>
<a name="ln813">/// @returns true if profiling is on for a function or sourced file.</a>
<a name="ln814">bool has_profiling(bool file, char_u *fname, bool *fp)</a>
<a name="ln815">{</a>
<a name="ln816">  return debuggy_find(file, fname, (linenr_T)0, &amp;prof_ga, fp)</a>
<a name="ln817">         != (linenr_T)0;</a>
<a name="ln818">}</a>
<a name="ln819"> </a>
<a name="ln820">/// Common code for dbg_find_breakpoint() and has_profiling().</a>
<a name="ln821">static linenr_T</a>
<a name="ln822">debuggy_find(</a>
<a name="ln823">    bool file,            // true for a file, false for a function</a>
<a name="ln824">    char_u *fname,        // file or function name</a>
<a name="ln825">    linenr_T after,       // after this line number</a>
<a name="ln826">    garray_T *gap,        // either &amp;dbg_breakp or &amp;prof_ga</a>
<a name="ln827">    bool *fp              // if not NULL: return forceit</a>
<a name="ln828">)</a>
<a name="ln829">{</a>
<a name="ln830">  struct debuggy *bp;</a>
<a name="ln831">  linenr_T lnum = 0;</a>
<a name="ln832">  char_u      *name = fname;</a>
<a name="ln833">  int prev_got_int;</a>
<a name="ln834"> </a>
<a name="ln835">  // Return quickly when there are no breakpoints.</a>
<a name="ln836">  if (GA_EMPTY(gap)) {</a>
<a name="ln837">    return (linenr_T)0;</a>
<a name="ln838">  }</a>
<a name="ln839"> </a>
<a name="ln840">  // Replace K_SNR in function name with &quot;&lt;SNR&gt;&quot;.</a>
<a name="ln841">  if (!file &amp;&amp; fname[0] == K_SPECIAL) {</a>
<a name="ln842">    name = xmalloc(STRLEN(fname) + 3);</a>
<a name="ln843">    STRCPY(name, &quot;&lt;SNR&gt;&quot;);</a>
<a name="ln844">    STRCPY(name + 5, fname + 3);</a>
<a name="ln845">  }</a>
<a name="ln846"> </a>
<a name="ln847">  for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln848">    // Skip entries that are not useful or are for a line that is beyond</a>
<a name="ln849">    // an already found breakpoint.</a>
<a name="ln850">    bp = &amp;DEBUGGY(gap, i);</a>
<a name="ln851">    if ((bp-&gt;dbg_type == DBG_FILE) == file</a>
<a name="ln852">        &amp;&amp; bp-&gt;dbg_type != DBG_EXPR</a>
<a name="ln853">        &amp;&amp; (gap == &amp;prof_ga</a>
<a name="ln854">            || (bp-&gt;dbg_lnum &gt; after &amp;&amp; (lnum == 0 || bp-&gt;dbg_lnum &lt; lnum)))) {</a>
<a name="ln855">      // Save the value of got_int and reset it.  We don't want a</a>
<a name="ln856">      // previous interruption cancel matching, only hitting CTRL-C</a>
<a name="ln857">      // while matching should abort it.</a>
<a name="ln858">      prev_got_int = got_int;</a>
<a name="ln859">      got_int = false;</a>
<a name="ln860">      if (vim_regexec_prog(&amp;bp-&gt;dbg_prog, false, name, (colnr_T)0)) {</a>
<a name="ln861">        lnum = bp-&gt;dbg_lnum;</a>
<a name="ln862">        if (fp != NULL) {</a>
<a name="ln863">          *fp = bp-&gt;dbg_forceit;</a>
<a name="ln864">        }</a>
<a name="ln865">      }</a>
<a name="ln866">      got_int |= prev_got_int;</a>
<a name="ln867">    } else if (bp-&gt;dbg_type == DBG_EXPR) {</a>
<a name="ln868">      bool line = false;</a>
<a name="ln869"> </a>
<a name="ln870">      prev_got_int = got_int;</a>
<a name="ln871">      got_int = false;</a>
<a name="ln872"> </a>
<a name="ln873">      typval_T *tv = eval_expr(bp-&gt;dbg_name);</a>
<a name="ln874">      if (tv != NULL) {</a>
<a name="ln875">        if (bp-&gt;dbg_val == NULL) {</a>
<a name="ln876">          debug_oldval = typval_tostring(NULL);</a>
<a name="ln877">          bp-&gt;dbg_val = tv;</a>
<a name="ln878">          debug_newval = typval_tostring(bp-&gt;dbg_val);</a>
<a name="ln879">          line = true;</a>
<a name="ln880">        } else {</a>
<a name="ln881">          if (typval_compare(tv, bp-&gt;dbg_val, EXPR_IS, false) == OK</a>
<a name="ln882">              &amp;&amp; tv-&gt;vval.v_number == false) {</a>
<a name="ln883">            line = true;</a>
<a name="ln884">            debug_oldval = typval_tostring(bp-&gt;dbg_val);</a>
<a name="ln885">            // Need to evaluate again, typval_compare() overwrites &quot;tv&quot;.</a>
<a name="ln886">            typval_T *v = eval_expr(bp-&gt;dbg_name);</a>
<a name="ln887">            debug_newval = typval_tostring(v);</a>
<a name="ln888">            tv_free(bp-&gt;dbg_val);</a>
<a name="ln889">            bp-&gt;dbg_val = v;</a>
<a name="ln890">          }</a>
<a name="ln891">          tv_free(tv);</a>
<a name="ln892">        }</a>
<a name="ln893">      } else if (bp-&gt;dbg_val != NULL) {</a>
<a name="ln894">        debug_oldval = typval_tostring(bp-&gt;dbg_val);</a>
<a name="ln895">        debug_newval = typval_tostring(NULL);</a>
<a name="ln896">        tv_free(bp-&gt;dbg_val);</a>
<a name="ln897">        bp-&gt;dbg_val = NULL;</a>
<a name="ln898">        line = true;</a>
<a name="ln899">      }</a>
<a name="ln900"> </a>
<a name="ln901">      if (line) {</a>
<a name="ln902">        lnum = after &gt; 0 ? after : 1;</a>
<a name="ln903">        break;</a>
<a name="ln904">      }</a>
<a name="ln905"> </a>
<a name="ln906">      got_int |= prev_got_int;</a>
<a name="ln907">    }</a>
<a name="ln908">  }</a>
<a name="ln909">  if (name != fname) {</a>
<a name="ln910">    xfree(name);</a>
<a name="ln911">  }</a>
<a name="ln912"> </a>
<a name="ln913">  return lnum;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916">/// Called when a breakpoint was encountered.</a>
<a name="ln917">void dbg_breakpoint(char_u *name, linenr_T lnum)</a>
<a name="ln918">{</a>
<a name="ln919">  // We need to check if this line is actually executed in do_one_cmd()</a>
<a name="ln920">  debug_breakpoint_name = name;</a>
<a name="ln921">  debug_breakpoint_lnum = lnum;</a>
<a name="ln922">}</a>
<a name="ln923"> </a>
<a name="ln924">static char_u   *profile_fname = NULL;</a>
<a name="ln925"> </a>
<a name="ln926">/// &quot;:profile cmd args&quot;</a>
<a name="ln927">void ex_profile(exarg_T *eap)</a>
<a name="ln928">{</a>
<a name="ln929">  static proftime_T pause_time;</a>
<a name="ln930"> </a>
<a name="ln931">  char_u      *e;</a>
<a name="ln932">  int len;</a>
<a name="ln933"> </a>
<a name="ln934">  e = skiptowhite(eap-&gt;arg);</a>
<a name="ln935">  len = (int)(e - eap-&gt;arg);</a>
<a name="ln936">  e = skipwhite(e);</a>
<a name="ln937"> </a>
<a name="ln938">  if (len == 5 &amp;&amp; STRNCMP(eap-&gt;arg, &quot;start&quot;, 5) == 0 &amp;&amp; *e != NUL) {</a>
<a name="ln939">    xfree(profile_fname);</a>
<a name="ln940">    profile_fname = expand_env_save_opt(e, true);</a>
<a name="ln941">    do_profiling = PROF_YES;</a>
<a name="ln942">    profile_set_wait(profile_zero());</a>
<a name="ln943">    set_vim_var_nr(VV_PROFILING, 1L);</a>
<a name="ln944">  } else if (do_profiling == PROF_NONE) {</a>
<a name="ln945">    EMSG(_(&quot;E750: First use \&quot;:profile start {fname}\&quot;&quot;));</a>
<a name="ln946">  } else if (STRCMP(eap-&gt;arg, &quot;stop&quot;) == 0) {</a>
<a name="ln947">    profile_dump();</a>
<a name="ln948">    do_profiling = PROF_NONE;</a>
<a name="ln949">    set_vim_var_nr(VV_PROFILING, 0L);</a>
<a name="ln950">    profile_reset();</a>
<a name="ln951">  } else if (STRCMP(eap-&gt;arg, &quot;pause&quot;) == 0) {</a>
<a name="ln952">    if (do_profiling == PROF_YES) {</a>
<a name="ln953">      pause_time = profile_start();</a>
<a name="ln954">    }</a>
<a name="ln955">    do_profiling = PROF_PAUSED;</a>
<a name="ln956">  } else if (STRCMP(eap-&gt;arg, &quot;continue&quot;) == 0) {</a>
<a name="ln957">    if (do_profiling == PROF_PAUSED) {</a>
<a name="ln958">      pause_time = profile_end(pause_time);</a>
<a name="ln959">      profile_set_wait(profile_add(profile_get_wait(), pause_time));</a>
<a name="ln960">    }</a>
<a name="ln961">    do_profiling = PROF_YES;</a>
<a name="ln962">  } else if (STRCMP(eap-&gt;arg, &quot;dump&quot;) == 0) {</a>
<a name="ln963">    profile_dump();</a>
<a name="ln964">  } else {</a>
<a name="ln965">    // The rest is similar to &quot;:breakadd&quot;.</a>
<a name="ln966">    ex_breakadd(eap);</a>
<a name="ln967">  }</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970">void ex_python(exarg_T *eap)</a>
<a name="ln971">{</a>
<a name="ln972">  script_host_execute(&quot;python&quot;, eap);</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">void ex_pyfile(exarg_T *eap)</a>
<a name="ln976">{</a>
<a name="ln977">  script_host_execute_file(&quot;python&quot;, eap);</a>
<a name="ln978">}</a>
<a name="ln979"> </a>
<a name="ln980">void ex_pydo(exarg_T *eap)</a>
<a name="ln981">{</a>
<a name="ln982">  script_host_do_range(&quot;python&quot;, eap);</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985">void ex_ruby(exarg_T *eap)</a>
<a name="ln986">{</a>
<a name="ln987">  script_host_execute(&quot;ruby&quot;, eap);</a>
<a name="ln988">}</a>
<a name="ln989"> </a>
<a name="ln990">void ex_rubyfile(exarg_T *eap)</a>
<a name="ln991">{</a>
<a name="ln992">  script_host_execute_file(&quot;ruby&quot;, eap);</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995">void ex_rubydo(exarg_T *eap)</a>
<a name="ln996">{</a>
<a name="ln997">  script_host_do_range(&quot;ruby&quot;, eap);</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000">void ex_python3(exarg_T *eap)</a>
<a name="ln1001">{</a>
<a name="ln1002">  script_host_execute(&quot;python3&quot;, eap);</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005">void ex_py3file(exarg_T *eap)</a>
<a name="ln1006">{</a>
<a name="ln1007">  script_host_execute_file(&quot;python3&quot;, eap);</a>
<a name="ln1008">}</a>
<a name="ln1009"> </a>
<a name="ln1010">void ex_pydo3(exarg_T *eap)</a>
<a name="ln1011">{</a>
<a name="ln1012">  script_host_do_range(&quot;python3&quot;, eap);</a>
<a name="ln1013">}</a>
<a name="ln1014"> </a>
<a name="ln1015">void ex_perl(exarg_T *eap)</a>
<a name="ln1016">{</a>
<a name="ln1017">  script_host_execute(&quot;perl&quot;, eap);</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">void ex_perlfile(exarg_T *eap)</a>
<a name="ln1021">{</a>
<a name="ln1022">  script_host_execute_file(&quot;perl&quot;, eap);</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">void ex_perldo(exarg_T *eap)</a>
<a name="ln1026">{</a>
<a name="ln1027">  script_host_do_range(&quot;perl&quot;, eap);</a>
<a name="ln1028">}</a>
<a name="ln1029"> </a>
<a name="ln1030">// Command line expansion for :profile.</a>
<a name="ln1031">static enum {</a>
<a name="ln1032">  PEXP_SUBCMD,          ///&lt; expand :profile sub-commands</a>
<a name="ln1033">  PEXP_FUNC             ///&lt; expand :profile func {funcname}</a>
<a name="ln1034">} pexpand_what;</a>
<a name="ln1035"> </a>
<a name="ln1036">static char *pexpand_cmds[] = {</a>
<a name="ln1037">  &quot;continue&quot;,</a>
<a name="ln1038">  &quot;dump&quot;,</a>
<a name="ln1039">  &quot;file&quot;,</a>
<a name="ln1040">  &quot;func&quot;,</a>
<a name="ln1041">  &quot;pause&quot;,</a>
<a name="ln1042">  &quot;start&quot;,</a>
<a name="ln1043">  &quot;stop&quot;,</a>
<a name="ln1044">  NULL</a>
<a name="ln1045">};</a>
<a name="ln1046"> </a>
<a name="ln1047">/// Function given to ExpandGeneric() to obtain the profile command</a>
<a name="ln1048">/// specific expansion.</a>
<a name="ln1049">char_u *get_profile_name(expand_T *xp, int idx)</a>
<a name="ln1050">{</a>
<a name="ln1051">  switch (pexpand_what) {</a>
<a name="ln1052">  case PEXP_SUBCMD:</a>
<a name="ln1053">    return (char_u *)pexpand_cmds[idx];</a>
<a name="ln1054">  // case PEXP_FUNC: TODO</a>
<a name="ln1055">  default:</a>
<a name="ln1056">    return NULL;</a>
<a name="ln1057">  }</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060">/// Handle command line completion for :profile command.</a>
<a name="ln1061">void set_context_in_profile_cmd(expand_T *xp, const char *arg)</a>
<a name="ln1062">{</a>
<a name="ln1063">  // Default: expand subcommands.</a>
<a name="ln1064">  xp-&gt;xp_context = EXPAND_PROFILE;</a>
<a name="ln1065">  pexpand_what = PEXP_SUBCMD;</a>
<a name="ln1066">  xp-&gt;xp_pattern = (char_u *)arg;</a>
<a name="ln1067"> </a>
<a name="ln1068">  char_u *const end_subcmd = skiptowhite((const char_u *)arg);</a>
<a name="ln1069">  if (*end_subcmd == NUL) {</a>
<a name="ln1070">    return;</a>
<a name="ln1071">  }</a>
<a name="ln1072"> </a>
<a name="ln1073">  if ((const char *)end_subcmd - arg == 5 &amp;&amp; strncmp(arg, &quot;start&quot;, 5) == 0) {</a>
<a name="ln1074">    xp-&gt;xp_context = EXPAND_FILES;</a>
<a name="ln1075">    xp-&gt;xp_pattern = skipwhite((const char_u *)end_subcmd);</a>
<a name="ln1076">    return;</a>
<a name="ln1077">  }</a>
<a name="ln1078"> </a>
<a name="ln1079">  // TODO(tarruda): expand function names after &quot;func&quot;</a>
<a name="ln1080">  xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln1081">}</a>
<a name="ln1082"> </a>
<a name="ln1083">/// Dump the profiling info.</a>
<a name="ln1084">void profile_dump(void)</a>
<a name="ln1085">{</a>
<a name="ln1086">  FILE        *fd;</a>
<a name="ln1087"> </a>
<a name="ln1088">  if (profile_fname != NULL) {</a>
<a name="ln1089">    fd = os_fopen((char *)profile_fname, &quot;w&quot;);</a>
<a name="ln1090">    if (fd == NULL) {</a>
<a name="ln1091">      EMSG2(_(e_notopen), profile_fname);</a>
<a name="ln1092">    } else {</a>
<a name="ln1093">      script_dump_profile(fd);</a>
<a name="ln1094">      func_dump_profile(fd);</a>
<a name="ln1095">      fclose(fd);</a>
<a name="ln1096">    }</a>
<a name="ln1097">  }</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100">/// Reset all profiling information.</a>
<a name="ln1101">static void profile_reset(void)</a>
<a name="ln1102">{</a>
<a name="ln1103">  // Reset sourced files.</a>
<a name="ln1104">  for (int id = 1; id &lt;= script_items.ga_len; id++) {</a>
<a name="ln1105">    scriptitem_T *si = &amp;SCRIPT_ITEM(id);</a>
<a name="ln1106">    if (si-&gt;sn_prof_on) {</a>
<a name="ln1107">      si-&gt;sn_prof_on      = false;</a>
<a name="ln1108">      si-&gt;sn_pr_force     = false;</a>
<a name="ln1109">      si-&gt;sn_pr_child     = profile_zero();</a>
<a name="ln1110">      si-&gt;sn_pr_nest      = 0;</a>
<a name="ln1111">      si-&gt;sn_pr_count     = 0;</a>
<a name="ln1112">      si-&gt;sn_pr_total     = profile_zero();</a>
<a name="ln1113">      si-&gt;sn_pr_self      = profile_zero();</a>
<a name="ln1114">      si-&gt;sn_pr_start     = profile_zero();</a>
<a name="ln1115">      si-&gt;sn_pr_children  = profile_zero();</a>
<a name="ln1116">      ga_clear(&amp;si-&gt;sn_prl_ga);</a>
<a name="ln1117">      si-&gt;sn_prl_start    = profile_zero();</a>
<a name="ln1118">      si-&gt;sn_prl_children = profile_zero();</a>
<a name="ln1119">      si-&gt;sn_prl_wait     = profile_zero();</a>
<a name="ln1120">      si-&gt;sn_prl_idx      = -1;</a>
<a name="ln1121">      si-&gt;sn_prl_execed   = 0;</a>
<a name="ln1122">    }</a>
<a name="ln1123">  }</a>
<a name="ln1124"> </a>
<a name="ln1125">  // Reset functions.</a>
<a name="ln1126">  size_t      n  = func_hashtab.ht_used;</a>
<a name="ln1127">  hashitem_T *hi = func_hashtab.ht_array;</a>
<a name="ln1128"> </a>
<a name="ln1129">  for (; n &gt; (size_t)0; hi++) {</a>
<a name="ln1130">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1131">      n--;</a>
<a name="ln1132">      ufunc_T *uf = HI2UF(hi);</a>
<a name="ln1133">      if (uf-&gt;uf_prof_initialized) {</a>
<a name="ln1134">        uf-&gt;uf_profiling    = 0;</a>
<a name="ln1135">        uf-&gt;uf_tm_count     = 0;</a>
<a name="ln1136">        uf-&gt;uf_tm_total     = profile_zero();</a>
<a name="ln1137">        uf-&gt;uf_tm_self      = profile_zero();</a>
<a name="ln1138">        uf-&gt;uf_tm_children  = profile_zero();</a>
<a name="ln1139"> </a>
<a name="ln1140">        for (int i = 0; i &lt; uf-&gt;uf_lines.ga_len; i++) {</a>
<a name="ln1141">          uf-&gt;uf_tml_count[i] = 0;</a>
<a name="ln1142">          uf-&gt;uf_tml_total[i] = uf-&gt;uf_tml_self[i] = 0;</a>
<a name="ln1143">        }</a>
<a name="ln1144"> </a>
<a name="ln1145">        uf-&gt;uf_tml_start    = profile_zero();</a>
<a name="ln1146">        uf-&gt;uf_tml_children = profile_zero();</a>
<a name="ln1147">        uf-&gt;uf_tml_wait     = profile_zero();</a>
<a name="ln1148">        uf-&gt;uf_tml_idx      = -1;</a>
<a name="ln1149">        uf-&gt;uf_tml_execed   = 0;</a>
<a name="ln1150">      }</a>
<a name="ln1151">    }</a>
<a name="ln1152">  }</a>
<a name="ln1153"> </a>
<a name="ln1154">  XFREE_CLEAR(profile_fname);</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157">/// Start profiling a script.</a>
<a name="ln1158">static void profile_init(scriptitem_T *si)</a>
<a name="ln1159">{</a>
<a name="ln1160">  si-&gt;sn_pr_count = 0;</a>
<a name="ln1161">  si-&gt;sn_pr_total = profile_zero();</a>
<a name="ln1162">  si-&gt;sn_pr_self = profile_zero();</a>
<a name="ln1163"> </a>
<a name="ln1164">  ga_init(&amp;si-&gt;sn_prl_ga, sizeof(sn_prl_T), 100);</a>
<a name="ln1165">  si-&gt;sn_prl_idx = -1;</a>
<a name="ln1166">  si-&gt;sn_prof_on = true;</a>
<a name="ln1167">  si-&gt;sn_pr_nest = 0;</a>
<a name="ln1168">}</a>
<a name="ln1169"> </a>
<a name="ln1170">/// Save time when starting to invoke another script or function.</a>
<a name="ln1171">void script_prof_save(</a>
<a name="ln1172">    proftime_T  *tm             // place to store wait time</a>
<a name="ln1173">)</a>
<a name="ln1174">{</a>
<a name="ln1175">  scriptitem_T    *si;</a>
<a name="ln1176"> </a>
<a name="ln1177">  if (current_sctx.sc_sid &gt; 0 &amp;&amp; current_sctx.sc_sid &lt;= script_items.ga_len) {</a>
<a name="ln1178">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln1179">    if (si-&gt;sn_prof_on &amp;&amp; si-&gt;sn_pr_nest++ == 0) {</a>
<a name="ln1180">      si-&gt;sn_pr_child = profile_start();</a>
<a name="ln1181">    }</a>
<a name="ln1182">  }</a>
<a name="ln1183">  *tm = profile_get_wait();</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186">/// Count time spent in children after invoking another script or function.</a>
<a name="ln1187">void script_prof_restore(proftime_T *tm)</a>
<a name="ln1188">{</a>
<a name="ln1189">  scriptitem_T    *si;</a>
<a name="ln1190"> </a>
<a name="ln1191">  if (current_sctx.sc_sid &gt; 0 &amp;&amp; current_sctx.sc_sid &lt;= script_items.ga_len) {</a>
<a name="ln1192">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln1193">    if (si-&gt;sn_prof_on &amp;&amp; --si-&gt;sn_pr_nest == 0) {</a>
<a name="ln1194">      si-&gt;sn_pr_child = profile_end(si-&gt;sn_pr_child);</a>
<a name="ln1195">      // don't count wait time</a>
<a name="ln1196">      si-&gt;sn_pr_child = profile_sub_wait(*tm, si-&gt;sn_pr_child);</a>
<a name="ln1197">      si-&gt;sn_pr_children = profile_add(si-&gt;sn_pr_children, si-&gt;sn_pr_child);</a>
<a name="ln1198">      si-&gt;sn_prl_children = profile_add(si-&gt;sn_prl_children, si-&gt;sn_pr_child);</a>
<a name="ln1199">    }</a>
<a name="ln1200">  }</a>
<a name="ln1201">}</a>
<a name="ln1202"> </a>
<a name="ln1203">static proftime_T inchar_time;</a>
<a name="ln1204"> </a>
<a name="ln1205">/// Called when starting to wait for the user to type a character.</a>
<a name="ln1206">void prof_inchar_enter(void)</a>
<a name="ln1207">{</a>
<a name="ln1208">  inchar_time = profile_start();</a>
<a name="ln1209">}</a>
<a name="ln1210"> </a>
<a name="ln1211">/// Called when finished waiting for the user to type a character.</a>
<a name="ln1212">void prof_inchar_exit(void)</a>
<a name="ln1213">{</a>
<a name="ln1214">  inchar_time = profile_end(inchar_time);</a>
<a name="ln1215">  profile_set_wait(profile_add(profile_get_wait(), inchar_time));</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">/// Dump the profiling results for all scripts in file &quot;fd&quot;.</a>
<a name="ln1219">static void script_dump_profile(FILE *fd)</a>
<a name="ln1220">{</a>
<a name="ln1221">  scriptitem_T    *si;</a>
<a name="ln1222">  FILE            *sfd;</a>
<a name="ln1223">  sn_prl_T        *pp;</a>
<a name="ln1224"> </a>
<a name="ln1225">  for (int id = 1; id &lt;= script_items.ga_len; id++) {</a>
<a name="ln1226">    si = &amp;SCRIPT_ITEM(id);</a>
<a name="ln1227">    if (si-&gt;sn_prof_on) {</a>
<a name="ln1228">      fprintf(fd, &quot;SCRIPT  %s\n&quot;, si-&gt;sn_name);</a>
<a name="ln1229">      if (si-&gt;sn_pr_count == 1) {</a>
<a name="ln1230">        fprintf(fd, &quot;Sourced 1 time\n&quot;);</a>
<a name="ln1231">      } else {</a>
<a name="ln1232">        fprintf(fd, &quot;Sourced %d times\n&quot;, si-&gt;sn_pr_count);</a>
<a name="ln1233">      }</a>
<a name="ln1234">      fprintf(fd, &quot;Total time: %s\n&quot;, profile_msg(si-&gt;sn_pr_total));</a>
<a name="ln1235">      fprintf(fd, &quot; Self time: %s\n&quot;, profile_msg(si-&gt;sn_pr_self));</a>
<a name="ln1236">      fprintf(fd, &quot;\n&quot;);</a>
<a name="ln1237">      fprintf(fd, &quot;count  total (s)   self (s)\n&quot;);</a>
<a name="ln1238"> </a>
<a name="ln1239">      sfd = os_fopen((char *)si-&gt;sn_name, &quot;r&quot;);</a>
<a name="ln1240">      if (sfd == NULL) {</a>
<a name="ln1241">        fprintf(fd, &quot;Cannot open file!\n&quot;);</a>
<a name="ln1242">      } else {</a>
<a name="ln1243">        // Keep going till the end of file, so that trailing</a>
<a name="ln1244">        // continuation lines are listed.</a>
<a name="ln1245">        for (int i = 0; ; i++) {</a>
<a name="ln1246">          if (vim_fgets(IObuff, IOSIZE, sfd)) {</a>
<a name="ln1247">            break;</a>
<a name="ln1248">          }</a>
<a name="ln1249">          // When a line has been truncated, append NL, taking care</a>
<a name="ln1250">          // of multi-byte characters .</a>
<a name="ln1251">          if (IObuff[IOSIZE - 2] != NUL &amp;&amp; IObuff[IOSIZE - 2] != NL) {</a>
<a name="ln1252">            int n = IOSIZE - 2;</a>
<a name="ln1253"> </a>
<a name="ln1254">            // Move to the first byte of this char.</a>
<a name="ln1255">            // utf_head_off() doesn't work, because it checks</a>
<a name="ln1256">            // for a truncated character.</a>
<a name="ln1257">            while (n &gt; 0 &amp;&amp; (IObuff[n] &amp; 0xc0) == 0x80) {</a>
<a name="ln1258">              n--;</a>
<a name="ln1259">            }</a>
<a name="ln1260"> </a>
<a name="ln1261">            IObuff[n] = NL;</a>
<a name="ln1262">            IObuff[n + 1] = NUL;</a>
<a name="ln1263">          }</a>
<a name="ln1264">          if (i &lt; si-&gt;sn_prl_ga.ga_len</a>
<a name="ln1265">              &amp;&amp; (pp = &amp;PRL_ITEM(si, i))-&gt;snp_count &gt; 0) {</a>
<a name="ln1266">            fprintf(fd, &quot;%5d &quot;, pp-&gt;snp_count);</a>
<a name="ln1267">            if (profile_equal(pp-&gt;sn_prl_total, pp-&gt;sn_prl_self)) {</a>
<a name="ln1268">              fprintf(fd, &quot;           &quot;);</a>
<a name="ln1269">            } else {</a>
<a name="ln1270">              fprintf(fd, &quot;%s &quot;, profile_msg(pp-&gt;sn_prl_total));</a>
<a name="ln1271">            }</a>
<a name="ln1272">            fprintf(fd, &quot;%s &quot;, profile_msg(pp-&gt;sn_prl_self));</a>
<a name="ln1273">          } else {</a>
<a name="ln1274">            fprintf(fd, &quot;                            &quot;);</a>
<a name="ln1275">          }</a>
<a name="ln1276">          fprintf(fd, &quot;%s&quot;, IObuff);</a>
<a name="ln1277">        }</a>
<a name="ln1278">        fclose(sfd);</a>
<a name="ln1279">      }</a>
<a name="ln1280">      fprintf(fd, &quot;\n&quot;);</a>
<a name="ln1281">    }</a>
<a name="ln1282">  }</a>
<a name="ln1283">}</a>
<a name="ln1284"> </a>
<a name="ln1285">/// Return true when a function defined in the current script should be</a>
<a name="ln1286">/// profiled.</a>
<a name="ln1287">bool prof_def_func(void)</a>
<a name="ln1288">{</a>
<a name="ln1289">  if (current_sctx.sc_sid &gt; 0) {</a>
<a name="ln1290">    return SCRIPT_ITEM(current_sctx.sc_sid).sn_pr_force;</a>
<a name="ln1291">  }</a>
<a name="ln1292">  return false;</a>
<a name="ln1293">}</a>
<a name="ln1294"> </a>
<a name="ln1295">/// If 'autowrite' option set, try to write the file.</a>
<a name="ln1296">/// Careful: autocommands may make &quot;buf&quot; invalid!</a>
<a name="ln1297">///</a>
<a name="ln1298">/// @return FAIL for failure, OK otherwise</a>
<a name="ln1299">int autowrite(buf_T *buf, int forceit)</a>
<a name="ln1300">{</a>
<a name="ln1301">  int r;</a>
<a name="ln1302">  bufref_T bufref;</a>
<a name="ln1303"> </a>
<a name="ln1304">  if (!(p_aw || p_awa) || !p_write</a>
<a name="ln1305">      // never autowrite a &quot;nofile&quot; or &quot;nowrite&quot; buffer</a>
<a name="ln1306">      || bt_dontwrite(buf)</a>
<a name="ln1307">      || (!forceit &amp;&amp; buf-&gt;b_p_ro) || buf-&gt;b_ffname == NULL) {</a>
<a name="ln1308">    return FAIL;</a>
<a name="ln1309">  }</a>
<a name="ln1310">  set_bufref(&amp;bufref, buf);</a>
<a name="ln1311">  r = buf_write_all(buf, forceit);</a>
<a name="ln1312"> </a>
<a name="ln1313">  // Writing may succeed but the buffer still changed, e.g., when there is a</a>
<a name="ln1314">  // conversion error.  We do want to return FAIL then.</a>
<a name="ln1315">  if (bufref_valid(&amp;bufref) &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln1316">    r = FAIL;</a>
<a name="ln1317">  }</a>
<a name="ln1318">  return r;</a>
<a name="ln1319">}</a>
<a name="ln1320"> </a>
<a name="ln1321">/// Flush all buffers, except the ones that are readonly or are never written.</a>
<a name="ln1322">void autowrite_all(void)</a>
<a name="ln1323">{</a>
<a name="ln1324">  if (!(p_aw || p_awa) || !p_write) {</a>
<a name="ln1325">    return;</a>
<a name="ln1326">  }</a>
<a name="ln1327"> </a>
<a name="ln1328">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1329">    if (bufIsChanged(buf) &amp;&amp; !buf-&gt;b_p_ro &amp;&amp; !bt_dontwrite(buf)) {</a>
<a name="ln1330">      bufref_T bufref;</a>
<a name="ln1331">      set_bufref(&amp;bufref, buf);</a>
<a name="ln1332">      (void)buf_write_all(buf, false);</a>
<a name="ln1333">      // an autocommand may have deleted the buffer</a>
<a name="ln1334">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1335">        buf = firstbuf;</a>
<a name="ln1336">      }</a>
<a name="ln1337">    }</a>
<a name="ln1338">  }</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">/// Return true if buffer was changed and cannot be abandoned.</a>
<a name="ln1342">/// For flags use the CCGD_ values.</a>
<a name="ln1343">bool check_changed(buf_T *buf, int flags)</a>
<a name="ln1344">{</a>
<a name="ln1345">  int forceit = (flags &amp; CCGD_FORCEIT);</a>
<a name="ln1346">  bufref_T bufref;</a>
<a name="ln1347">  set_bufref(&amp;bufref, buf);</a>
<a name="ln1348"> </a>
<a name="ln1349">  if (!forceit</a>
<a name="ln1350">      &amp;&amp; bufIsChanged(buf)</a>
<a name="ln1351">      &amp;&amp; ((flags &amp; CCGD_MULTWIN) || buf-&gt;b_nwindows &lt;= 1)</a>
<a name="ln1352">      &amp;&amp; (!(flags &amp; CCGD_AW) || autowrite(buf, forceit) == FAIL)) {</a>
<a name="ln1353">    if ((p_confirm || cmdmod.confirm) &amp;&amp; p_write) {</a>
<a name="ln1354">      int count = 0;</a>
<a name="ln1355"> </a>
<a name="ln1356">      if (flags &amp; CCGD_ALLBUF) {</a>
<a name="ln1357">        FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln1358">          if (bufIsChanged(buf2) &amp;&amp; (buf2-&gt;b_ffname != NULL)) {</a>
<a name="ln1359">            count++;</a>
<a name="ln1360">          }</a>
<a name="ln1361">        }</a>
<a name="ln1362">      }</a>
<a name="ln1363">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1364">        // Autocommand deleted buffer, oops!  It's not changed now.</a>
<a name="ln1365">        return false;</a>
<a name="ln1366">      }</a>
<a name="ln1367">      dialog_changed(buf, count &gt; 1);</a>
<a name="ln1368">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1369">        // Autocommand deleted buffer, oops!  It's not changed now.</a>
<a name="ln1370">        return false;</a>
<a name="ln1371">      }</a>
<a name="ln1372">      return bufIsChanged(buf);</a>
<a name="ln1373">    }</a>
<a name="ln1374">    if (flags &amp; CCGD_EXCMD) {</a>
<a name="ln1375">      no_write_message();</a>
<a name="ln1376">    } else {</a>
<a name="ln1377">      no_write_message_nobang(curbuf);</a>
<a name="ln1378">    }</a>
<a name="ln1379">    return true;</a>
<a name="ln1380">  }</a>
<a name="ln1381">  return false;</a>
<a name="ln1382">}</a>
<a name="ln1383"> </a>
<a name="ln1384"> </a>
<a name="ln1385"> </a>
<a name="ln1386">/// Ask the user what to do when abandoning a changed buffer.</a>
<a name="ln1387">/// Must check 'write' option first!</a>
<a name="ln1388">///</a>
<a name="ln1389">/// @param buf</a>
<a name="ln1390">/// @param checkall may abandon all changed buffers</a>
<a name="ln1391">void dialog_changed(buf_T *buf, bool checkall)</a>
<a name="ln1392">{</a>
<a name="ln1393">  char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln1394">  int ret;</a>
<a name="ln1395">  // Init ea pseudo-structure, this is needed for the check_overwrite()</a>
<a name="ln1396">  // function.</a>
<a name="ln1397">  exarg_T ea = {</a>
<a name="ln1398">    .append = false,</a>
<a name="ln1399">    .forceit = false,</a>
<a name="ln1400">  };</a>
<a name="ln1401"> </a>
<a name="ln1402">  dialog_msg(buff, _(&quot;Save changes to \&quot;%s\&quot;?&quot;), buf-&gt;b_fname);</a>
<a name="ln1403">  if (checkall) {</a>
<a name="ln1404">    ret = vim_dialog_yesnoallcancel(VIM_QUESTION, NULL, buff, 1);</a>
<a name="ln1405">  } else {</a>
<a name="ln1406">    ret = vim_dialog_yesnocancel(VIM_QUESTION, NULL, buff, 1);</a>
<a name="ln1407">  }</a>
<a name="ln1408"> </a>
<a name="ln1409">  if (ret == VIM_YES) {</a>
<a name="ln1410">    if (buf-&gt;b_fname != NULL</a>
<a name="ln1411">        &amp;&amp; check_overwrite(&amp;ea,</a>
<a name="ln1412">                           buf,</a>
<a name="ln1413">                           buf-&gt;b_fname,</a>
<a name="ln1414">                           buf-&gt;b_ffname,</a>
<a name="ln1415">                           false) == OK) {</a>
<a name="ln1416">      // didn't hit Cancel</a>
<a name="ln1417">      (void)buf_write_all(buf, false);</a>
<a name="ln1418">    }</a>
<a name="ln1419">  } else if (ret == VIM_NO) {</a>
<a name="ln1420">    unchanged(buf, true, false);</a>
<a name="ln1421">  } else if (ret == VIM_ALL) {</a>
<a name="ln1422">    // Write all modified files that can be written.</a>
<a name="ln1423">    // Skip readonly buffers, these need to be confirmed</a>
<a name="ln1424">    // individually.</a>
<a name="ln1425">    FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln1426">      if (bufIsChanged(buf2) &amp;&amp; (buf2-&gt;b_ffname != NULL) &amp;&amp; !buf2-&gt;b_p_ro) {</a>
<a name="ln1427">        bufref_T bufref;</a>
<a name="ln1428">        set_bufref(&amp;bufref, buf2);</a>
<a name="ln1429"> </a>
<a name="ln1430">        if (buf2-&gt;b_fname != NULL</a>
<a name="ln1431">            &amp;&amp; check_overwrite(&amp;ea, buf2, buf2-&gt;b_fname,</a>
<a name="ln1432">                               buf2-&gt;b_ffname, false) == OK) {</a>
<a name="ln1433">          // didn't hit Cancel</a>
<a name="ln1434">          (void)buf_write_all(buf2, false);</a>
<a name="ln1435">        }</a>
<a name="ln1436">        // an autocommand may have deleted the buffer</a>
<a name="ln1437">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1438">          buf2 = firstbuf;</a>
<a name="ln1439">        }</a>
<a name="ln1440">      }</a>
<a name="ln1441">    }</a>
<a name="ln1442">  } else if (ret == VIM_DISCARDALL) {</a>
<a name="ln1443">    // mark all buffers as unchanged</a>
<a name="ln1444">    FOR_ALL_BUFFERS(buf2) {</a>
<a name="ln1445">      unchanged(buf2, true, false);</a>
<a name="ln1446">    }</a>
<a name="ln1447">  }</a>
<a name="ln1448">}</a>
<a name="ln1449"> </a>
<a name="ln1450">/// Ask the user whether to close the terminal buffer or not.</a>
<a name="ln1451">///</a>
<a name="ln1452">/// @param buf The terminal buffer.</a>
<a name="ln1453">/// @return bool Whether to close the buffer or not.</a>
<a name="ln1454">bool dialog_close_terminal(buf_T *buf)</a>
<a name="ln1455">{</a>
<a name="ln1456">  char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln1457"> </a>
<a name="ln1458">  dialog_msg(buff, _(&quot;Close \&quot;%s\&quot;?&quot;),</a>
<a name="ln1459">             (buf-&gt;b_fname != NULL) ? buf-&gt;b_fname : (char_u *)&quot;?&quot;);</a>
<a name="ln1460"> </a>
<a name="ln1461">  int ret = vim_dialog_yesnocancel(VIM_QUESTION, NULL, buff, 1);</a>
<a name="ln1462"> </a>
<a name="ln1463">  return (ret == VIM_YES) ? true : false;</a>
<a name="ln1464">}</a>
<a name="ln1465"> </a>
<a name="ln1466">/// Return true if the buffer &quot;buf&quot; can be abandoned, either by making it</a>
<a name="ln1467">/// hidden, autowriting it or unloading it.</a>
<a name="ln1468">bool can_abandon(buf_T *buf, int forceit)</a>
<a name="ln1469">{</a>
<a name="ln1470">  return buf_hide(buf)</a>
<a name="ln1471">         || !bufIsChanged(buf)</a>
<a name="ln1472">         || buf-&gt;b_nwindows &gt; 1</a>
<a name="ln1473">         || autowrite(buf, forceit) == OK</a>
<a name="ln1474">         || forceit;</a>
<a name="ln1475">}</a>
<a name="ln1476"> </a>
<a name="ln1477"> </a>
<a name="ln1478">/// Add a buffer number to &quot;bufnrs&quot;, unless it's already there.</a>
<a name="ln1479">static void add_bufnum(int *bufnrs, int *bufnump, int nr)</a>
<a name="ln1480">{</a>
<a name="ln1481">  int i;</a>
<a name="ln1482"> </a>
<a name="ln1483">  for (i = 0; i &lt; *bufnump; i++) {</a>
<a name="ln1484">    if (bufnrs[i] == nr) {</a>
<a name="ln1485">      return;</a>
<a name="ln1486">    }</a>
<a name="ln1487">  }</a>
<a name="ln1488">  bufnrs[*bufnump] = nr;</a>
<a name="ln1489">  *bufnump = *bufnump + 1;</a>
<a name="ln1490">}</a>
<a name="ln1491"> </a>
<a name="ln1492">/// Check if any buffer was changed and cannot be abandoned.</a>
<a name="ln1493">/// That changed buffer becomes the current buffer.</a>
<a name="ln1494">/// When &quot;unload&quot; is true the current buffer is unloaded instead of making it</a>
<a name="ln1495">/// hidden.  This is used for &quot;:q!&quot;.</a>
<a name="ln1496">///</a>
<a name="ln1497">/// @param[in] hidden specifies whether to check only hidden buffers.</a>
<a name="ln1498">/// @param[in] unload specifies whether to unload, instead of hide, the buffer.</a>
<a name="ln1499">///</a>
<a name="ln1500">/// @returns          true if any buffer is changed and cannot be abandoned</a>
<a name="ln1501">bool check_changed_any(bool hidden, bool unload)</a>
<a name="ln1502">{</a>
<a name="ln1503">  bool ret = false;</a>
<a name="ln1504">  int save;</a>
<a name="ln1505">  int i;</a>
<a name="ln1506">  int bufnum = 0;</a>
<a name="ln1507">  size_t bufcount = 0;</a>
<a name="ln1508">  int         *bufnrs;</a>
<a name="ln1509"> </a>
<a name="ln1510">  // Make a list of all buffers, with the most important ones first.</a>
<a name="ln1511">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1512">    bufcount++;</a>
<a name="ln1513">  }</a>
<a name="ln1514"> </a>
<a name="ln1515">  if (bufcount == 0) {</a>
<a name="ln1516">    return false;</a>
<a name="ln1517">  }</a>
<a name="ln1518"> </a>
<a name="ln1519">  bufnrs = xmalloc(sizeof(*bufnrs) * bufcount);</a>
<a name="ln1520"> </a>
<a name="ln1521">  // curbuf</a>
<a name="ln1522">  bufnrs[bufnum++] = curbuf-&gt;b_fnum;</a>
<a name="ln1523"> </a>
<a name="ln1524">  // buffers in current tab</a>
<a name="ln1525">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1526">    if (wp-&gt;w_buffer != curbuf) {</a>
<a name="ln1527">      add_bufnum(bufnrs, &amp;bufnum, wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln1528">    }</a>
<a name="ln1529">  }</a>
<a name="ln1530"> </a>
<a name="ln1531">  // buffers in other tabs</a>
<a name="ln1532">  FOR_ALL_TABS(tp) {</a>
<a name="ln1533">    if (tp != curtab) {</a>
<a name="ln1534">      FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln1535">        add_bufnum(bufnrs, &amp;bufnum, wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln1536">      }</a>
<a name="ln1537">    }</a>
<a name="ln1538">  }</a>
<a name="ln1539"> </a>
<a name="ln1540">  // any other buffer</a>
<a name="ln1541">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1542">    add_bufnum(bufnrs, &amp;bufnum, buf-&gt;b_fnum);</a>
<a name="ln1543">  }</a>
<a name="ln1544"> </a>
<a name="ln1545">  buf_T *buf = NULL;</a>
<a name="ln1546">  for (i = 0; i &lt; bufnum; i++) {</a>
<a name="ln1547">    buf = buflist_findnr(bufnrs[i]);</a>
<a name="ln1548">    if (buf == NULL) {</a>
<a name="ln1549">      continue;</a>
<a name="ln1550">    }</a>
<a name="ln1551">    if ((!hidden || buf-&gt;b_nwindows == 0) &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln1552">      bufref_T bufref;</a>
<a name="ln1553">      set_bufref(&amp;bufref, buf);</a>
<a name="ln1554"> </a>
<a name="ln1555">      // Try auto-writing the buffer.  If this fails but the buffer no</a>
<a name="ln1556">      // longer exists it's not changed, that's OK.</a>
<a name="ln1557">      if (check_changed(buf, (p_awa ? CCGD_AW : 0)</a>
<a name="ln1558">                        | CCGD_MULTWIN</a>
<a name="ln1559">                        | CCGD_ALLBUF) &amp;&amp; bufref_valid(&amp;bufref)) {</a>
<a name="ln1560">        break;    // didn't save - still changes</a>
<a name="ln1561">      }</a>
<a name="ln1562">    }</a>
<a name="ln1563">  }</a>
<a name="ln1564"> </a>
<a name="ln1565">  if (i &gt;= bufnum) {</a>
<a name="ln1566">    goto theend;</a>
<a name="ln1567">  }</a>
<a name="ln1568"> </a>
<a name="ln1569">  // Get here if &quot;buf&quot; cannot be abandoned.</a>
<a name="ln1570">  ret = true;</a>
<a name="ln1571">  exiting = false;</a>
<a name="ln1572">  // When &quot;:confirm&quot; used, don't give an error message.</a>
<a name="ln1573">  if (!(p_confirm || cmdmod.confirm)) {</a>
<a name="ln1574">    // There must be a wait_return for this message, do_buffer()</a>
<a name="ln1575">    // may cause a redraw.  But wait_return() is a no-op when vgetc()</a>
<a name="ln1576">    // is busy (Quit used from window menu), then make sure we don't</a>
<a name="ln1577">    // cause a scroll up.</a>
<a name="ln1578">    if (vgetc_busy &gt; 0) {</a>
<a name="ln1579">      msg_row = cmdline_row;</a>
<a name="ln1580">      msg_col = 0;</a>
<a name="ln1581">      msg_didout = false;</a>
<a name="ln1582">    }</a>
<a name="ln1583">    if ((buf-&gt;terminal &amp;&amp; channel_job_running((uint64_t)buf-&gt;b_p_channel))</a>
<a name="ln1584">        ? EMSG2(_(&quot;E947: Job still running in buffer \&quot;%s\&quot;&quot;), buf-&gt;b_fname)</a>
<a name="ln1585">        : EMSG2(_(&quot;E162: No write since last change for buffer \&quot;%s\&quot;&quot;),</a>
<a name="ln1586">                buf_spname(buf) != NULL ? buf_spname(buf) : buf-&gt;b_fname)) {</a>
<a name="ln1587">      save = no_wait_return;</a>
<a name="ln1588">      no_wait_return = false;</a>
<a name="ln1589">      wait_return(false);</a>
<a name="ln1590">      no_wait_return = save;</a>
<a name="ln1591">    }</a>
<a name="ln1592">  }</a>
<a name="ln1593"> </a>
<a name="ln1594">  // Try to find a window that contains the buffer.</a>
<a name="ln1595">  if (buf != curbuf) {</a>
<a name="ln1596">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln1597">      if (wp-&gt;w_buffer == buf) {</a>
<a name="ln1598">        bufref_T bufref;</a>
<a name="ln1599">        set_bufref(&amp;bufref, buf);</a>
<a name="ln1600">        goto_tabpage_win(tp, wp);</a>
<a name="ln1601">        // Paranoia: did autocmds wipe out the buffer with changes?</a>
<a name="ln1602">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1603">          goto theend;</a>
<a name="ln1604">        }</a>
<a name="ln1605">        goto buf_found;</a>
<a name="ln1606">      }</a>
<a name="ln1607">    }</a>
<a name="ln1608">  }</a>
<a name="ln1609">buf_found:</a>
<a name="ln1610"> </a>
<a name="ln1611">  // Open the changed buffer in the current window.</a>
<a name="ln1612">  if (buf != curbuf) {</a>
<a name="ln1613">    set_curbuf(buf, unload ? DOBUF_UNLOAD : DOBUF_GOTO);</a>
<a name="ln1614">  }</a>
<a name="ln1615"> </a>
<a name="ln1616">theend:</a>
<a name="ln1617">  xfree(bufnrs);</a>
<a name="ln1618">  return ret;</a>
<a name="ln1619">}</a>
<a name="ln1620"> </a>
<a name="ln1621">/// Return FAIL if there is no file name, OK if there is one.</a>
<a name="ln1622">/// Give error message for FAIL.</a>
<a name="ln1623">int check_fname(void)</a>
<a name="ln1624">{</a>
<a name="ln1625">  if (curbuf-&gt;b_ffname == NULL) {</a>
<a name="ln1626">    EMSG(_(e_noname));</a>
<a name="ln1627">    return FAIL;</a>
<a name="ln1628">  }</a>
<a name="ln1629">  return OK;</a>
<a name="ln1630">}</a>
<a name="ln1631"> </a>
<a name="ln1632">/// Flush the contents of a buffer, unless it has no file name.</a>
<a name="ln1633">///</a>
<a name="ln1634">/// @return FAIL for failure, OK otherwise</a>
<a name="ln1635">int buf_write_all(buf_T *buf, int forceit)</a>
<a name="ln1636">{</a>
<a name="ln1637">  int retval;</a>
<a name="ln1638">  buf_T       *old_curbuf = curbuf;</a>
<a name="ln1639"> </a>
<a name="ln1640">  retval = (buf_write(buf, buf-&gt;b_ffname, buf-&gt;b_fname,</a>
<a name="ln1641">                      (linenr_T)1, buf-&gt;b_ml.ml_line_count, NULL,</a>
<a name="ln1642">                      false, forceit, true, false));</a>
<a name="ln1643">  if (curbuf != old_curbuf) {</a>
<a name="ln1644">    msg_source(HL_ATTR(HLF_W));</a>
<a name="ln1645">    MSG(_(&quot;Warning: Entered other buffer unexpectedly (check autocommands)&quot;));</a>
<a name="ln1646">  }</a>
<a name="ln1647">  return retval;</a>
<a name="ln1648">}</a>
<a name="ln1649"> </a>
<a name="ln1650">/// Code to handle the argument list.</a>
<a name="ln1651"> </a>
<a name="ln1652">#define AL_SET  1</a>
<a name="ln1653">#define AL_ADD  2</a>
<a name="ln1654">#define AL_DEL  3</a>
<a name="ln1655"> </a>
<a name="ln1656">/// Isolate one argument, taking backticks.</a>
<a name="ln1657">/// Changes the argument in-place, puts a NUL after it.  Backticks remain.</a>
<a name="ln1658">/// Return a pointer to the start of the next argument.</a>
<a name="ln1659">static char_u *do_one_arg(char_u *str)</a>
<a name="ln1660">{</a>
<a name="ln1661">  char_u      *p;</a>
<a name="ln1662">  bool inbacktick;</a>
<a name="ln1663"> </a>
<a name="ln1664">  inbacktick = false;</a>
<a name="ln1665">  for (p = str; *str; str++) {</a>
<a name="ln1666">    // When the backslash is used for escaping the special meaning of a</a>
<a name="ln1667">    // character we need to keep it until wildcard expansion.</a>
<a name="ln1668">    if (rem_backslash(str)) {</a>
<a name="ln1669">      *p++ = *str++;</a>
<a name="ln1670">      *p++ = *str;</a>
<a name="ln1671">    } else {</a>
<a name="ln1672">      // An item ends at a space not in backticks</a>
<a name="ln1673">      if (!inbacktick &amp;&amp; ascii_isspace(*str)) {</a>
<a name="ln1674">        break;</a>
<a name="ln1675">      }</a>
<a name="ln1676">      if (*str == '`') {</a>
<a name="ln1677">        inbacktick ^= true;</a>
<a name="ln1678">      }</a>
<a name="ln1679">      *p++ = *str;</a>
<a name="ln1680">    }</a>
<a name="ln1681">  }</a>
<a name="ln1682">  str = skipwhite(str);</a>
<a name="ln1683">  *p = NUL;</a>
<a name="ln1684"> </a>
<a name="ln1685">  return str;</a>
<a name="ln1686">}</a>
<a name="ln1687"> </a>
<a name="ln1688">/// Separate the arguments in &quot;str&quot; and return a list of pointers in the</a>
<a name="ln1689">/// growarray &quot;gap&quot;.</a>
<a name="ln1690">static void get_arglist(garray_T *gap, char_u *str, int escaped)</a>
<a name="ln1691">{</a>
<a name="ln1692">  ga_init(gap, (int)sizeof(char_u *), 20);</a>
<a name="ln1693">  while (*str != NUL) {</a>
<a name="ln1694">    GA_APPEND(char_u *, gap, str);</a>
<a name="ln1695"> </a>
<a name="ln1696">    // If str is escaped, don't handle backslashes or spaces</a>
<a name="ln1697">    if (!escaped) {</a>
<a name="ln1698">      return;</a>
<a name="ln1699">    }</a>
<a name="ln1700"> </a>
<a name="ln1701">    // Isolate one argument, change it in-place, put a NUL after it.</a>
<a name="ln1702">    str = do_one_arg(str);</a>
<a name="ln1703">  }</a>
<a name="ln1704">}</a>
<a name="ln1705"> </a>
<a name="ln1706">/// Parse a list of arguments (file names), expand them and return in</a>
<a name="ln1707">/// &quot;fnames[fcountp]&quot;.  When &quot;wig&quot; is true, removes files matching 'wildignore'.</a>
<a name="ln1708">///</a>
<a name="ln1709">/// @return FAIL or OK.</a>
<a name="ln1710">int get_arglist_exp(char_u *str, int *fcountp, char_u ***fnamesp, bool wig)</a>
<a name="ln1711">{</a>
<a name="ln1712">  garray_T ga;</a>
<a name="ln1713">  int i;</a>
<a name="ln1714"> </a>
<a name="ln1715">  get_arglist(&amp;ga, str, true);</a>
<a name="ln1716"> </a>
<a name="ln1717">  if (wig) {</a>
<a name="ln1718">    i = expand_wildcards(ga.ga_len, (char_u **)ga.ga_data,</a>
<a name="ln1719">                         fcountp, fnamesp, EW_FILE|EW_NOTFOUND|EW_NOTWILD);</a>
<a name="ln1720">  } else {</a>
<a name="ln1721">    i = gen_expand_wildcards(ga.ga_len, (char_u **)ga.ga_data,</a>
<a name="ln1722">                             fcountp, fnamesp, EW_FILE|EW_NOTFOUND|EW_NOTWILD);</a>
<a name="ln1723">  }</a>
<a name="ln1724"> </a>
<a name="ln1725">  ga_clear(&amp;ga);</a>
<a name="ln1726">  return i;</a>
<a name="ln1727">}</a>
<a name="ln1728"> </a>
<a name="ln1729"> </a>
<a name="ln1730">/// @param str</a>
<a name="ln1731">/// @param what</a>
<a name="ln1732">///         AL_SET: Redefine the argument list to 'str'.</a>
<a name="ln1733">///         AL_ADD: add files in 'str' to the argument list after &quot;after&quot;.</a>
<a name="ln1734">///         AL_DEL: remove files in 'str' from the argument list.</a>
<a name="ln1735">/// @param after</a>
<a name="ln1736">///         0 means before first one</a>
<a name="ln1737">/// @param will_edit  will edit added argument</a>
<a name="ln1738">///</a>
<a name="ln1739">/// @return FAIL for failure, OK otherwise.</a>
<a name="ln1740">static int do_arglist(char_u *str, int what, int after, bool will_edit)</a>
<a name="ln1741">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1742">{</a>
<a name="ln1743">  garray_T new_ga;</a>
<a name="ln1744">  int exp_count;</a>
<a name="ln1745">  char_u      **exp_files;</a>
<a name="ln1746">  char_u      *p;</a>
<a name="ln1747">  int match;</a>
<a name="ln1748">  int arg_escaped = true;</a>
<a name="ln1749"> </a>
<a name="ln1750">  // Set default argument for &quot;:argadd&quot; command.</a>
<a name="ln1751">  if (what == AL_ADD &amp;&amp; *str == NUL) {</a>
<a name="ln1752">    if (curbuf-&gt;b_ffname == NULL) {</a>
<a name="ln1753">      return FAIL;</a>
<a name="ln1754">    }</a>
<a name="ln1755">    str = curbuf-&gt;b_fname;</a>
<a name="ln1756">    arg_escaped = false;</a>
<a name="ln1757">  }</a>
<a name="ln1758"> </a>
<a name="ln1759">  // Collect all file name arguments in &quot;new_ga&quot;.</a>
<a name="ln1760">  get_arglist(&amp;new_ga, str, arg_escaped);</a>
<a name="ln1761"> </a>
<a name="ln1762">  if (what == AL_DEL) {</a>
<a name="ln1763">    regmatch_T regmatch;</a>
<a name="ln1764">    bool didone;</a>
<a name="ln1765"> </a>
<a name="ln1766">    // Delete the items: use each item as a regexp and find a match in the</a>
<a name="ln1767">    // argument list.</a>
<a name="ln1768">    regmatch.rm_ic = p_fic;     // ignore case when 'fileignorecase' is set</a>
<a name="ln1769">    for (int i = 0; i &lt; new_ga.ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln1770">      p = ((char_u **)new_ga.ga_data)[i];</a>
<a name="ln1771">      p = file_pat_to_reg_pat(p, NULL, NULL, false);</a>
<a name="ln1772">      if (p == NULL) {</a>
<a name="ln1773">        break;</a>
<a name="ln1774">      }</a>
<a name="ln1775">      regmatch.regprog = vim_regcomp(p, p_magic ? RE_MAGIC : 0);</a>
<a name="ln1776">      if (regmatch.regprog == NULL) {</a>
<a name="ln1777">        xfree(p);</a>
<a name="ln1778">        break;</a>
<a name="ln1779">      }</a>
<a name="ln1780"> </a>
<a name="ln1781">      didone = false;</a>
<a name="ln1782">      for (match = 0; match &lt; ARGCOUNT; match++) {</a>
<a name="ln1783">        if (vim_regexec(&amp;regmatch, alist_name(&amp;ARGLIST[match]),</a>
<a name="ln1784">                        (colnr_T)0)) {</a>
<a name="ln1785">          didone = true;</a>
<a name="ln1786">          xfree(ARGLIST[match].ae_fname);</a>
<a name="ln1787">          memmove(ARGLIST + match, ARGLIST + match + 1,</a>
<a name="ln1788">                  (size_t)(ARGCOUNT - match - 1) * sizeof(aentry_T));</a>
<a name="ln1789">          ALIST(curwin)-&gt;al_ga.ga_len--;</a>
<a name="ln1790">          if (curwin-&gt;w_arg_idx &gt; match) {</a>
<a name="ln1791">            curwin-&gt;w_arg_idx--;</a>
<a name="ln1792">          }</a>
<a name="ln1793">          match--;</a>
<a name="ln1794">        }</a>
<a name="ln1795">      }</a>
<a name="ln1796"> </a>
<a name="ln1797">      vim_regfree(regmatch.regprog);</a>
<a name="ln1798">      xfree(p);</a>
<a name="ln1799">      if (!didone) {</a>
<a name="ln1800">        EMSG2(_(e_nomatch2), ((char_u **)new_ga.ga_data)[i]);</a>
<a name="ln1801">      }</a>
<a name="ln1802">    }</a>
<a name="ln1803">    ga_clear(&amp;new_ga);</a>
<a name="ln1804">  } else {</a>
<a name="ln1805">    int i = expand_wildcards(new_ga.ga_len, (char_u **)new_ga.ga_data,</a>
<a name="ln1806">                             &amp;exp_count, &amp;exp_files,</a>
<a name="ln1807">                             EW_DIR|EW_FILE|EW_ADDSLASH|EW_NOTFOUND);</a>
<a name="ln1808">    ga_clear(&amp;new_ga);</a>
<a name="ln1809">    if (i == FAIL || exp_count == 0) {</a>
<a name="ln1810">      EMSG(_(e_nomatch));</a>
<a name="ln1811">      return FAIL;</a>
<a name="ln1812">    }</a>
<a name="ln1813"> </a>
<a name="ln1814">    if (what == AL_ADD) {</a>
<a name="ln1815">      alist_add_list(exp_count, exp_files, after, will_edit);</a>
<a name="ln1816">      xfree(exp_files);</a>
<a name="ln1817">    } else {</a>
<a name="ln1818">      assert(what == AL_SET);</a>
<a name="ln1819">      alist_set(ALIST(curwin), exp_count, exp_files, will_edit, NULL, 0);</a>
<a name="ln1820">    }</a>
<a name="ln1821">  }</a>
<a name="ln1822"> </a>
<a name="ln1823">  alist_check_arg_idx();</a>
<a name="ln1824"> </a>
<a name="ln1825">  return OK;</a>
<a name="ln1826">}</a>
<a name="ln1827"> </a>
<a name="ln1828">/// Check the validity of the arg_idx for each other window.</a>
<a name="ln1829">static void alist_check_arg_idx(void)</a>
<a name="ln1830">{</a>
<a name="ln1831">  FOR_ALL_TAB_WINDOWS(tp, win) {</a>
<a name="ln1832">    if (win-&gt;w_alist == curwin-&gt;w_alist) {</a>
<a name="ln1833">      check_arg_idx(win);</a>
<a name="ln1834">    }</a>
<a name="ln1835">  }</a>
<a name="ln1836">}</a>
<a name="ln1837"> </a>
<a name="ln1838">/// Return true if window &quot;win&quot; is editing the file at the current argument</a>
<a name="ln1839">/// index.</a>
<a name="ln1840">static bool editing_arg_idx(win_T *win)</a>
<a name="ln1841">{</a>
<a name="ln1842">  return !(win-&gt;w_arg_idx &gt;= WARGCOUNT(win)</a>
<a name="ln1843">           || (win-&gt;w_buffer-&gt;b_fnum</a>
<a name="ln1844">               != WARGLIST(win)[win-&gt;w_arg_idx].ae_fnum</a>
<a name="ln1845">               &amp;&amp; (win-&gt;w_buffer-&gt;b_ffname == NULL</a>
<a name="ln1846">                   || !(path_full_compare(</a>
<a name="ln1847">                       alist_name(&amp;WARGLIST(win)[win-&gt;w_arg_idx]),</a>
<a name="ln1848">                       win-&gt;w_buffer-&gt;b_ffname, true, true) &amp; kEqualFiles))));</a>
<a name="ln1849">}</a>
<a name="ln1850"> </a>
<a name="ln1851">/// Check if window &quot;win&quot; is editing the w_arg_idx file in its argument list.</a>
<a name="ln1852">void check_arg_idx(win_T *win)</a>
<a name="ln1853">{</a>
<a name="ln1854">  if (WARGCOUNT(win) &gt; 1 &amp;&amp; !editing_arg_idx(win)) {</a>
<a name="ln1855">    // We are not editing the current entry in the argument list.</a>
<a name="ln1856">    // Set &quot;arg_had_last&quot; if we are editing the last one.</a>
<a name="ln1857">    win-&gt;w_arg_idx_invalid = true;</a>
<a name="ln1858">    if (win-&gt;w_arg_idx != WARGCOUNT(win) - 1</a>
<a name="ln1859">        &amp;&amp; arg_had_last == false</a>
<a name="ln1860">        &amp;&amp; ALIST(win) == &amp;global_alist</a>
<a name="ln1861">        &amp;&amp; GARGCOUNT &gt; 0</a>
<a name="ln1862">        &amp;&amp; win-&gt;w_arg_idx &lt; GARGCOUNT</a>
<a name="ln1863">        &amp;&amp; (win-&gt;w_buffer-&gt;b_fnum == GARGLIST[GARGCOUNT - 1].ae_fnum</a>
<a name="ln1864">            || (win-&gt;w_buffer-&gt;b_ffname != NULL</a>
<a name="ln1865">                &amp;&amp; (path_full_compare(alist_name(&amp;GARGLIST[GARGCOUNT - 1]),</a>
<a name="ln1866">                                      win-&gt;w_buffer-&gt;b_ffname, true, true)</a>
<a name="ln1867">                    &amp; kEqualFiles)))) {</a>
<a name="ln1868">      arg_had_last = true;</a>
<a name="ln1869">    }</a>
<a name="ln1870">  } else {</a>
<a name="ln1871">    // We are editing the current entry in the argument list.</a>
<a name="ln1872">    // Set &quot;arg_had_last&quot; if it's also the last one</a>
<a name="ln1873">    win-&gt;w_arg_idx_invalid = false;</a>
<a name="ln1874">    if (win-&gt;w_arg_idx == WARGCOUNT(win) - 1</a>
<a name="ln1875">        &amp;&amp; win-&gt;w_alist == &amp;global_alist) {</a>
<a name="ln1876">      arg_had_last = true;</a>
<a name="ln1877">    }</a>
<a name="ln1878">  }</a>
<a name="ln1879">}</a>
<a name="ln1880"> </a>
<a name="ln1881">/// &quot;:args&quot;, &quot;:argslocal&quot; and &quot;:argsglobal&quot;.</a>
<a name="ln1882">void ex_args(exarg_T *eap)</a>
<a name="ln1883">{</a>
<a name="ln1884">  if (eap-&gt;cmdidx != CMD_args) {</a>
<a name="ln1885">    alist_unlink(ALIST(curwin));</a>
<a name="ln1886">    if (eap-&gt;cmdidx == CMD_argglobal) {</a>
<a name="ln1887">      ALIST(curwin) = &amp;global_alist;</a>
<a name="ln1888">    } else {     // eap-&gt;cmdidx == CMD_arglocal</a>
<a name="ln1889">      alist_new();</a>
<a name="ln1890">    }</a>
<a name="ln1891">  }</a>
<a name="ln1892"> </a>
<a name="ln1893">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln1894">    // &quot;:args file ..&quot;: define new argument list, handle like &quot;:next&quot;</a>
<a name="ln1895">    // Also for &quot;:argslocal file ..&quot; and &quot;:argsglobal file ..&quot;.</a>
<a name="ln1896">    ex_next(eap);</a>
<a name="ln1897">  } else if (eap-&gt;cmdidx == CMD_args) {</a>
<a name="ln1898">    // &quot;:args&quot;: list arguments.</a>
<a name="ln1899">    if (ARGCOUNT &gt; 0) {</a>
<a name="ln1900">      char_u **items = xmalloc(sizeof(char_u *) * (size_t)ARGCOUNT);</a>
<a name="ln1901">      // Overwrite the command, for a short list there is no scrolling</a>
<a name="ln1902">      // required and no wait_return().</a>
<a name="ln1903">      gotocmdline(true);</a>
<a name="ln1904">      for (int i = 0; i &lt; ARGCOUNT; i++) {</a>
<a name="ln1905">        items[i] = alist_name(&amp;ARGLIST[i]);</a>
<a name="ln1906">      }</a>
<a name="ln1907">      list_in_columns(items, ARGCOUNT, curwin-&gt;w_arg_idx);</a>
<a name="ln1908">      xfree(items);</a>
<a name="ln1909">    }</a>
<a name="ln1910">  } else if (eap-&gt;cmdidx == CMD_arglocal) {</a>
<a name="ln1911">    garray_T        *gap = &amp;curwin-&gt;w_alist-&gt;al_ga;</a>
<a name="ln1912"> </a>
<a name="ln1913">    // &quot;:argslocal&quot;: make a local copy of the global argument list.</a>
<a name="ln1914">    ga_grow(gap, GARGCOUNT);</a>
<a name="ln1915">    for (int i = 0; i &lt; GARGCOUNT; i++) {</a>
<a name="ln1916">      if (GARGLIST[i].ae_fname != NULL) {</a>
<a name="ln1917">        AARGLIST(curwin-&gt;w_alist)[gap-&gt;ga_len].ae_fname =</a>
<a name="ln1918">          vim_strsave(GARGLIST[i].ae_fname);</a>
<a name="ln1919">        AARGLIST(curwin-&gt;w_alist)[gap-&gt;ga_len].ae_fnum =</a>
<a name="ln1920">          GARGLIST[i].ae_fnum;</a>
<a name="ln1921">        gap-&gt;ga_len++;</a>
<a name="ln1922">      }</a>
<a name="ln1923">    }</a>
<a name="ln1924">  }</a>
<a name="ln1925">}</a>
<a name="ln1926"> </a>
<a name="ln1927">/// &quot;:previous&quot;, &quot;:sprevious&quot;, &quot;:Next&quot; and &quot;:sNext&quot;.</a>
<a name="ln1928">void ex_previous(exarg_T *eap)</a>
<a name="ln1929">{</a>
<a name="ln1930">  // If past the last one already, go to the last one.</a>
<a name="ln1931">  if (curwin-&gt;w_arg_idx - (int)eap-&gt;line2 &gt;= ARGCOUNT) {</a>
<a name="ln1932">    do_argfile(eap, ARGCOUNT - 1);</a>
<a name="ln1933">  } else {</a>
<a name="ln1934">    do_argfile(eap, curwin-&gt;w_arg_idx - (int)eap-&gt;line2);</a>
<a name="ln1935">  }</a>
<a name="ln1936">}</a>
<a name="ln1937"> </a>
<a name="ln1938">/// &quot;:rewind&quot;, &quot;:first&quot;, &quot;:sfirst&quot; and &quot;:srewind&quot;.</a>
<a name="ln1939">void ex_rewind(exarg_T *eap)</a>
<a name="ln1940">{</a>
<a name="ln1941">  do_argfile(eap, 0);</a>
<a name="ln1942">}</a>
<a name="ln1943"> </a>
<a name="ln1944">/// &quot;:last&quot; and &quot;:slast&quot;.</a>
<a name="ln1945">void ex_last(exarg_T *eap)</a>
<a name="ln1946">{</a>
<a name="ln1947">  do_argfile(eap, ARGCOUNT - 1);</a>
<a name="ln1948">}</a>
<a name="ln1949"> </a>
<a name="ln1950">/// &quot;:argument&quot; and &quot;:sargument&quot;.</a>
<a name="ln1951">void ex_argument(exarg_T *eap)</a>
<a name="ln1952">{</a>
<a name="ln1953">  int i;</a>
<a name="ln1954"> </a>
<a name="ln1955">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln1956">    i = (int)eap-&gt;line2 - 1;</a>
<a name="ln1957">  } else {</a>
<a name="ln1958">    i = curwin-&gt;w_arg_idx;</a>
<a name="ln1959">  }</a>
<a name="ln1960">  do_argfile(eap, i);</a>
<a name="ln1961">}</a>
<a name="ln1962"> </a>
<a name="ln1963">/// Edit file &quot;argn&quot; of the argument lists.</a>
<a name="ln1964">void do_argfile(exarg_T *eap, int argn)</a>
<a name="ln1965">{</a>
<a name="ln1966">  int other;</a>
<a name="ln1967">  char_u      *p;</a>
<a name="ln1968">  int old_arg_idx = curwin-&gt;w_arg_idx;</a>
<a name="ln1969"> </a>
<a name="ln1970">  if (argn &lt; 0 || argn &gt;= ARGCOUNT) {</a>
<a name="ln1971">    if (ARGCOUNT &lt;= 1) {</a>
<a name="ln1972">      EMSG(_(&quot;E163: There is only one file to edit&quot;));</a>
<a name="ln1973">    } else if (argn &lt; 0) {</a>
<a name="ln1974">      EMSG(_(&quot;E164: Cannot go before first file&quot;));</a>
<a name="ln1975">    } else {</a>
<a name="ln1976">      EMSG(_(&quot;E165: Cannot go beyond last file&quot;));</a>
<a name="ln1977">    }</a>
<a name="ln1978">  } else {</a>
<a name="ln1979">    setpcmark();</a>
<a name="ln1980"> </a>
<a name="ln1981">    // split window or create new tab page first</a>
<a name="ln1982">    if (*eap-&gt;cmd == 's' || cmdmod.tab != 0) {</a>
<a name="ln1983">      if (win_split(0, 0) == FAIL) {</a>
<a name="ln1984">        return;</a>
<a name="ln1985">      }</a>
<a name="ln1986">      RESET_BINDING(curwin);</a>
<a name="ln1987">    } else {</a>
<a name="ln1988">      // if 'hidden' set, only check for changed file when re-editing</a>
<a name="ln1989">      // the same buffer</a>
<a name="ln1990">      other = true;</a>
<a name="ln1991">      if (buf_hide(curbuf)) {</a>
<a name="ln1992">        p = (char_u *)fix_fname((char *)alist_name(&amp;ARGLIST[argn]));</a>
<a name="ln1993">        other = otherfile(p);</a>
<a name="ln1994">        xfree(p);</a>
<a name="ln1995">      }</a>
<a name="ln1996">      if ((!buf_hide(curbuf) || !other)</a>
<a name="ln1997">          &amp;&amp; check_changed(curbuf, CCGD_AW</a>
<a name="ln1998">                           | (other ? 0 : CCGD_MULTWIN)</a>
<a name="ln1999">                           | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln2000">                           | CCGD_EXCMD)) {</a>
<a name="ln2001">        return;</a>
<a name="ln2002">      }</a>
<a name="ln2003">    }</a>
<a name="ln2004"> </a>
<a name="ln2005">    curwin-&gt;w_arg_idx = argn;</a>
<a name="ln2006">    if (argn == ARGCOUNT - 1</a>
<a name="ln2007">        &amp;&amp; curwin-&gt;w_alist == &amp;global_alist) {</a>
<a name="ln2008">      arg_had_last = true;</a>
<a name="ln2009">    }</a>
<a name="ln2010"> </a>
<a name="ln2011">    // Edit the file; always use the last known line number.</a>
<a name="ln2012">    // When it fails (e.g. Abort for already edited file) restore the</a>
<a name="ln2013">    // argument index.</a>
<a name="ln2014">    if (do_ecmd(0, alist_name(&amp;ARGLIST[curwin-&gt;w_arg_idx]), NULL,</a>
<a name="ln2015">                eap, ECMD_LAST,</a>
<a name="ln2016">                (buf_hide(curwin-&gt;w_buffer) ? ECMD_HIDE : 0)</a>
<a name="ln2017">                + (eap-&gt;forceit ? ECMD_FORCEIT : 0), curwin) == FAIL) {</a>
<a name="ln2018">      curwin-&gt;w_arg_idx = old_arg_idx;</a>
<a name="ln2019">    } else if (eap-&gt;cmdidx != CMD_argdo) {</a>
<a name="ln2020">      // like Vi: set the mark where the cursor is in the file.</a>
<a name="ln2021">      setmark('\'');</a>
<a name="ln2022">    }</a>
<a name="ln2023">  }</a>
<a name="ln2024">}</a>
<a name="ln2025"> </a>
<a name="ln2026">/// &quot;:next&quot;, and commands that behave like it.</a>
<a name="ln2027">void ex_next(exarg_T *eap)</a>
<a name="ln2028">{</a>
<a name="ln2029">  int i;</a>
<a name="ln2030"> </a>
<a name="ln2031">  // check for changed buffer now, if this fails the argument list is not</a>
<a name="ln2032">  // redefined.</a>
<a name="ln2033">  if (buf_hide(curbuf)</a>
<a name="ln2034">      || eap-&gt;cmdidx == CMD_snext</a>
<a name="ln2035">      || !check_changed(curbuf, CCGD_AW</a>
<a name="ln2036">                        | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln2037">                        | CCGD_EXCMD)) {</a>
<a name="ln2038">    if (*eap-&gt;arg != NUL) {                 // redefine file list</a>
<a name="ln2039">      if (do_arglist(eap-&gt;arg, AL_SET, 0, true) == FAIL) {</a>
<a name="ln2040">        return;</a>
<a name="ln2041">      }</a>
<a name="ln2042">      i = 0;</a>
<a name="ln2043">    } else {</a>
<a name="ln2044">      i = curwin-&gt;w_arg_idx + (int)eap-&gt;line2;</a>
<a name="ln2045">    }</a>
<a name="ln2046">    do_argfile(eap, i);</a>
<a name="ln2047">  }</a>
<a name="ln2048">}</a>
<a name="ln2049"> </a>
<a name="ln2050">/// &quot;:argedit&quot;</a>
<a name="ln2051">void ex_argedit(exarg_T *eap)</a>
<a name="ln2052">{</a>
<a name="ln2053">  int i = eap-&gt;addr_count ? (int)eap-&gt;line2 : curwin-&gt;w_arg_idx + 1;</a>
<a name="ln2054">  // Whether curbuf will be reused, curbuf-&gt;b_ffname will be set.</a>
<a name="ln2055">  bool curbuf_is_reusable = curbuf_reusable();</a>
<a name="ln2056"> </a>
<a name="ln2057">  if (do_arglist(eap-&gt;arg, AL_ADD, i, true) == FAIL) {</a>
<a name="ln2058">    return;</a>
<a name="ln2059">  }</a>
<a name="ln2060">  maketitle();</a>
<a name="ln2061"> </a>
<a name="ln2062">  if (curwin-&gt;w_arg_idx == 0</a>
<a name="ln2063">      &amp;&amp; (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)</a>
<a name="ln2064">      &amp;&amp; (curbuf-&gt;b_ffname == NULL || curbuf_is_reusable)) {</a>
<a name="ln2065">    i = 0;</a>
<a name="ln2066">  }</a>
<a name="ln2067">  // Edit the argument.</a>
<a name="ln2068">  if (i &lt; ARGCOUNT) {</a>
<a name="ln2069">    do_argfile(eap, i);</a>
<a name="ln2070">  }</a>
<a name="ln2071">}</a>
<a name="ln2072"> </a>
<a name="ln2073">/// &quot;:argadd&quot;</a>
<a name="ln2074">void ex_argadd(exarg_T *eap)</a>
<a name="ln2075">{</a>
<a name="ln2076">  do_arglist(eap-&gt;arg, AL_ADD,</a>
<a name="ln2077">             eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : curwin-&gt;w_arg_idx + 1,</a>
<a name="ln2078">             false);</a>
<a name="ln2079">  maketitle();</a>
<a name="ln2080">}</a>
<a name="ln2081"> </a>
<a name="ln2082">/// &quot;:argdelete&quot;</a>
<a name="ln2083">void ex_argdelete(exarg_T *eap)</a>
<a name="ln2084">{</a>
<a name="ln2085">  if (eap-&gt;addr_count &gt; 0 || *eap-&gt;arg == NUL) {</a>
<a name="ln2086">    // &quot;:argdel&quot; works like &quot;:.argdel&quot;</a>
<a name="ln2087">    if (eap-&gt;addr_count == 0) {</a>
<a name="ln2088">      if (curwin-&gt;w_arg_idx &gt;= ARGCOUNT) {</a>
<a name="ln2089">        EMSG(_(&quot;E610: No argument to delete&quot;));</a>
<a name="ln2090">        return;</a>
<a name="ln2091">      }</a>
<a name="ln2092">      eap-&gt;line1 = eap-&gt;line2 = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln2093">    } else if (eap-&gt;line2 &gt; ARGCOUNT) {</a>
<a name="ln2094">      // &quot;:1,4argdel&quot;: Delete all arguments in the range.</a>
<a name="ln2095">      eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln2096">    }</a>
<a name="ln2097">    linenr_T n = eap-&gt;line2 - eap-&gt;line1 + 1;</a>
<a name="ln2098">    if (*eap-&gt;arg != NUL) {</a>
<a name="ln2099">      // Can't have both a range and an argument.</a>
<a name="ln2100">      EMSG(_(e_invarg));</a>
<a name="ln2101">    } else if (n &lt;= 0) {</a>
<a name="ln2102">      // Don't give an error for &quot;:%argdel&quot; if the list is empty.</a>
<a name="ln2103">      if (eap-&gt;line1 != 1 || eap-&gt;line2 != 0) {</a>
<a name="ln2104">        EMSG(_(e_invrange));</a>
<a name="ln2105">      }</a>
<a name="ln2106">    } else {</a>
<a name="ln2107">      for (linenr_T i = eap-&gt;line1; i &lt;= eap-&gt;line2; i++) {</a>
<a name="ln2108">        xfree(ARGLIST[i - 1].ae_fname);</a>
<a name="ln2109">      }</a>
<a name="ln2110">      memmove(ARGLIST + eap-&gt;line1 - 1, ARGLIST + eap-&gt;line2,</a>
<a name="ln2111">              (size_t)(ARGCOUNT - eap-&gt;line2) * sizeof(aentry_T));</a>
<a name="ln2112">      ALIST(curwin)-&gt;al_ga.ga_len -= (int)n;</a>
<a name="ln2113">      if (curwin-&gt;w_arg_idx &gt;= eap-&gt;line2) {</a>
<a name="ln2114">        curwin-&gt;w_arg_idx -= (int)n;</a>
<a name="ln2115">      } else if (curwin-&gt;w_arg_idx &gt; eap-&gt;line1) {</a>
<a name="ln2116">        curwin-&gt;w_arg_idx = (int)eap-&gt;line1;</a>
<a name="ln2117">      }</a>
<a name="ln2118">      if (ARGCOUNT == 0) {</a>
<a name="ln2119">          curwin-&gt;w_arg_idx = 0;</a>
<a name="ln2120">      } else if (curwin-&gt;w_arg_idx &gt;= ARGCOUNT) {</a>
<a name="ln2121">          curwin-&gt;w_arg_idx = ARGCOUNT - 1;</a>
<a name="ln2122">      }</a>
<a name="ln2123">    }</a>
<a name="ln2124">  } else {</a>
<a name="ln2125">    do_arglist(eap-&gt;arg, AL_DEL, 0, false);</a>
<a name="ln2126">  }</a>
<a name="ln2127">  maketitle();</a>
<a name="ln2128">}</a>
<a name="ln2129"> </a>
<a name="ln2130">/// &quot;:argdo&quot;, &quot;:windo&quot;, &quot;:bufdo&quot;, &quot;:tabdo&quot;, &quot;:cdo&quot;, &quot;:ldo&quot;, &quot;:cfdo&quot; and &quot;:lfdo&quot;</a>
<a name="ln2131">void ex_listdo(exarg_T *eap)</a>
<a name="ln2132">{</a>
<a name="ln2133">  int i;</a>
<a name="ln2134">  win_T       *wp;</a>
<a name="ln2135">  tabpage_T   *tp;</a>
<a name="ln2136">  int next_fnum = 0;</a>
<a name="ln2137">  char_u      *save_ei = NULL;</a>
<a name="ln2138">  char_u      *p_shm_save;</a>
<a name="ln2139"> </a>
<a name="ln2140">  if (eap-&gt;cmdidx != CMD_windo &amp;&amp; eap-&gt;cmdidx != CMD_tabdo) {</a>
<a name="ln2141">    // Don't do syntax HL autocommands.  Skipping the syntax file is a</a>
<a name="ln2142">    // great speed improvement.</a>
<a name="ln2143">    save_ei = au_event_disable(&quot;,Syntax&quot;);</a>
<a name="ln2144"> </a>
<a name="ln2145">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2146">      buf-&gt;b_flags &amp;= ~BF_SYN_SET;</a>
<a name="ln2147">    }</a>
<a name="ln2148">  }</a>
<a name="ln2149"> </a>
<a name="ln2150">  if (eap-&gt;cmdidx == CMD_windo</a>
<a name="ln2151">      || eap-&gt;cmdidx == CMD_tabdo</a>
<a name="ln2152">      || buf_hide(curbuf)</a>
<a name="ln2153">      || !check_changed(curbuf, CCGD_AW</a>
<a name="ln2154">                        | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln2155">                        | CCGD_EXCMD)) {</a>
<a name="ln2156">    i = 0;</a>
<a name="ln2157">    // start at the eap-&gt;line1 argument/window/buffer</a>
<a name="ln2158">    wp = firstwin;</a>
<a name="ln2159">    tp = first_tabpage;</a>
<a name="ln2160">    switch (eap-&gt;cmdidx) {</a>
<a name="ln2161">    case CMD_windo:</a>
<a name="ln2162">      for (; wp != NULL &amp;&amp; i + 1 &lt; eap-&gt;line1; wp = wp-&gt;w_next) {</a>
<a name="ln2163">        i++;</a>
<a name="ln2164">      }</a>
<a name="ln2165">      break;</a>
<a name="ln2166">    case CMD_tabdo:</a>
<a name="ln2167">      for (; tp != NULL &amp;&amp; i + 1 &lt; eap-&gt;line1; tp = tp-&gt;tp_next) {</a>
<a name="ln2168">        i++;</a>
<a name="ln2169">      }</a>
<a name="ln2170">      break;</a>
<a name="ln2171">    case CMD_argdo:</a>
<a name="ln2172">      i = (int)eap-&gt;line1 - 1;</a>
<a name="ln2173">      break;</a>
<a name="ln2174">    default:</a>
<a name="ln2175">      break;</a>
<a name="ln2176">    }</a>
<a name="ln2177"> </a>
<a name="ln2178">    buf_T *buf = curbuf;</a>
<a name="ln2179">    size_t qf_size = 0;</a>
<a name="ln2180"> </a>
<a name="ln2181">    // set pcmark now</a>
<a name="ln2182">    if (eap-&gt;cmdidx == CMD_bufdo) {</a>
<a name="ln2183">      // Advance to the first listed buffer after &quot;eap-&gt;line1&quot;.</a>
<a name="ln2184">      for (buf = firstbuf;</a>
<a name="ln2185">           buf != NULL &amp;&amp; (buf-&gt;b_fnum &lt; eap-&gt;line1 || !buf-&gt;b_p_bl);</a>
<a name="ln2186">           buf = buf-&gt;b_next) {</a>
<a name="ln2187">        if (buf-&gt;b_fnum &gt; eap-&gt;line2) {</a>
<a name="ln2188">          buf = NULL;</a>
<a name="ln2189">          break;</a>
<a name="ln2190">        }</a>
<a name="ln2191">      }</a>
<a name="ln2192">      if (buf != NULL) {</a>
<a name="ln2193">        goto_buffer(eap, DOBUF_FIRST, FORWARD, buf-&gt;b_fnum);</a>
<a name="ln2194">      }</a>
<a name="ln2195">    } else if (eap-&gt;cmdidx == CMD_cdo || eap-&gt;cmdidx == CMD_ldo</a>
<a name="ln2196">               || eap-&gt;cmdidx == CMD_cfdo || eap-&gt;cmdidx == CMD_lfdo) {</a>
<a name="ln2197">      qf_size = qf_get_valid_size(eap);</a>
<a name="ln2198">      assert(eap-&gt;line1 &gt;= 0);</a>
<a name="ln2199">      if (qf_size == 0 || (size_t)eap-&gt;line1 &gt; qf_size) {</a>
<a name="ln2200">        buf = NULL;</a>
<a name="ln2201">      } else {</a>
<a name="ln2202">        ex_cc(eap);</a>
<a name="ln2203"> </a>
<a name="ln2204">        buf = curbuf;</a>
<a name="ln2205">        i = (int)eap-&gt;line1 - 1;</a>
<a name="ln2206">        if (eap-&gt;addr_count &lt;= 0) {</a>
<a name="ln2207">          // Default to all quickfix/location list entries.</a>
<a name="ln2208">          assert(qf_size &lt; MAXLNUM);</a>
<a name="ln2209">          eap-&gt;line2 = (linenr_T)qf_size;</a>
<a name="ln2210">        }</a>
<a name="ln2211">      }</a>
<a name="ln2212">    } else {</a>
<a name="ln2213">      setpcmark();</a>
<a name="ln2214">    }</a>
<a name="ln2215">    listcmd_busy = true;            // avoids setting pcmark below</a>
<a name="ln2216"> </a>
<a name="ln2217">    while (!got_int &amp;&amp; buf != NULL) {</a>
<a name="ln2218">      if (eap-&gt;cmdidx == CMD_argdo) {</a>
<a name="ln2219">        // go to argument &quot;i&quot;</a>
<a name="ln2220">        if (i == ARGCOUNT) {</a>
<a name="ln2221">          break;</a>
<a name="ln2222">        }</a>
<a name="ln2223">        // Don't call do_argfile() when already there, it will try</a>
<a name="ln2224">        // reloading the file.</a>
<a name="ln2225">        if (curwin-&gt;w_arg_idx != i || !editing_arg_idx(curwin)) {</a>
<a name="ln2226">          // Clear 'shm' to avoid that the file message overwrites</a>
<a name="ln2227">          // any output from the command.</a>
<a name="ln2228">          p_shm_save = vim_strsave(p_shm);</a>
<a name="ln2229">          set_option_value(&quot;shm&quot;, 0L, &quot;&quot;, 0);</a>
<a name="ln2230">          do_argfile(eap, i);</a>
<a name="ln2231">          set_option_value(&quot;shm&quot;, 0L, (char *)p_shm_save, 0);</a>
<a name="ln2232">          xfree(p_shm_save);</a>
<a name="ln2233">        }</a>
<a name="ln2234">        if (curwin-&gt;w_arg_idx != i) {</a>
<a name="ln2235">          break;</a>
<a name="ln2236">        }</a>
<a name="ln2237">      } else if (eap-&gt;cmdidx == CMD_windo) {</a>
<a name="ln2238">        // go to window &quot;wp&quot;</a>
<a name="ln2239">        if (!win_valid(wp)) {</a>
<a name="ln2240">          break;</a>
<a name="ln2241">        }</a>
<a name="ln2242">        assert(wp);</a>
<a name="ln2243">        win_goto(wp);</a>
<a name="ln2244">        if (curwin != wp) {</a>
<a name="ln2245">          break;    // something must be wrong</a>
<a name="ln2246">        }</a>
<a name="ln2247">        wp = curwin-&gt;w_next;</a>
<a name="ln2248">      } else if (eap-&gt;cmdidx == CMD_tabdo) {</a>
<a name="ln2249">        // go to window &quot;tp&quot;</a>
<a name="ln2250">        if (!valid_tabpage(tp)) {</a>
<a name="ln2251">          break;</a>
<a name="ln2252">        }</a>
<a name="ln2253">        assert(tp);</a>
<a name="ln2254">        goto_tabpage_tp(tp, true, true);</a>
<a name="ln2255">        tp = tp-&gt;tp_next;</a>
<a name="ln2256">      } else if (eap-&gt;cmdidx == CMD_bufdo) {</a>
<a name="ln2257">        // Remember the number of the next listed buffer, in case</a>
<a name="ln2258">        // &quot;:bwipe&quot; is used or autocommands do something strange.</a>
<a name="ln2259">        next_fnum = -1;</a>
<a name="ln2260">        for (buf_T *bp = curbuf-&gt;b_next; bp != NULL; bp = bp-&gt;b_next) {</a>
<a name="ln2261">          if (bp-&gt;b_p_bl) {</a>
<a name="ln2262">            next_fnum = bp-&gt;b_fnum;</a>
<a name="ln2263">            break;</a>
<a name="ln2264">          }</a>
<a name="ln2265">        }</a>
<a name="ln2266">      }</a>
<a name="ln2267"> </a>
<a name="ln2268">      i++;</a>
<a name="ln2269">      // execute the command</a>
<a name="ln2270">      do_cmdline(eap-&gt;arg, eap-&gt;getline, eap-&gt;cookie,</a>
<a name="ln2271">                 DOCMD_VERBOSE + DOCMD_NOWAIT);</a>
<a name="ln2272"> </a>
<a name="ln2273">      if (eap-&gt;cmdidx == CMD_bufdo) {</a>
<a name="ln2274">        // Done?</a>
<a name="ln2275">        if (next_fnum &lt; 0 || next_fnum &gt; eap-&gt;line2) {</a>
<a name="ln2276">          break;</a>
<a name="ln2277">        }</a>
<a name="ln2278"> </a>
<a name="ln2279">        // Check if the buffer still exists.</a>
<a name="ln2280">        bool buf_still_exists = false;</a>
<a name="ln2281">        FOR_ALL_BUFFERS(bp) {</a>
<a name="ln2282">          if (bp-&gt;b_fnum == next_fnum) {</a>
<a name="ln2283">            buf_still_exists = true;</a>
<a name="ln2284">            break;</a>
<a name="ln2285">          }</a>
<a name="ln2286">        }</a>
<a name="ln2287">        if (!buf_still_exists) {</a>
<a name="ln2288">          break;</a>
<a name="ln2289">        }</a>
<a name="ln2290"> </a>
<a name="ln2291">        // Go to the next buffer.  Clear 'shm' to avoid that the file</a>
<a name="ln2292">        // message overwrites any output from the command.</a>
<a name="ln2293">        p_shm_save = vim_strsave(p_shm);</a>
<a name="ln2294">        set_option_value(&quot;shm&quot;, 0L, &quot;&quot;, 0);</a>
<a name="ln2295">        goto_buffer(eap, DOBUF_FIRST, FORWARD, next_fnum);</a>
<a name="ln2296">        set_option_value(&quot;shm&quot;, 0L, (char *)p_shm_save, 0);</a>
<a name="ln2297">        xfree(p_shm_save);</a>
<a name="ln2298"> </a>
<a name="ln2299">        // If autocommands took us elsewhere, quit here.</a>
<a name="ln2300">        if (curbuf-&gt;b_fnum != next_fnum) {</a>
<a name="ln2301">          break;</a>
<a name="ln2302">        }</a>
<a name="ln2303">      }</a>
<a name="ln2304"> </a>
<a name="ln2305">      if (eap-&gt;cmdidx == CMD_cdo || eap-&gt;cmdidx == CMD_ldo</a>
<a name="ln2306">          || eap-&gt;cmdidx == CMD_cfdo || eap-&gt;cmdidx == CMD_lfdo) {</a>
<a name="ln2307">        assert(i &gt;= 0);</a>
<a name="ln2308">        if ((size_t)i &gt;= qf_size || i &gt;= eap-&gt;line2) {</a>
<a name="ln2309">          break;</a>
<a name="ln2310">        }</a>
<a name="ln2311"> </a>
<a name="ln2312">        size_t qf_idx = qf_get_cur_idx(eap);</a>
<a name="ln2313"> </a>
<a name="ln2314">        ex_cnext(eap);</a>
<a name="ln2315"> </a>
<a name="ln2316">        // If jumping to the next quickfix entry fails, quit here.</a>
<a name="ln2317">        if (qf_get_cur_idx(eap) == qf_idx) {</a>
<a name="ln2318">          break;</a>
<a name="ln2319">        }</a>
<a name="ln2320">      }</a>
<a name="ln2321"> </a>
<a name="ln2322">      if (eap-&gt;cmdidx == CMD_windo) {</a>
<a name="ln2323">        validate_cursor();              // cursor may have moved</a>
<a name="ln2324">        // required when 'scrollbind' has been set</a>
<a name="ln2325">        if (curwin-&gt;w_p_scb) {</a>
<a name="ln2326">          do_check_scrollbind(true);</a>
<a name="ln2327">        }</a>
<a name="ln2328">      }</a>
<a name="ln2329">      if (eap-&gt;cmdidx == CMD_windo || eap-&gt;cmdidx == CMD_tabdo) {</a>
<a name="ln2330">        if (i + 1 &gt; eap-&gt;line2) {</a>
<a name="ln2331">          break;</a>
<a name="ln2332">        }</a>
<a name="ln2333">      }</a>
<a name="ln2334">      if (eap-&gt;cmdidx == CMD_argdo &amp;&amp; i &gt;= eap-&gt;line2) {</a>
<a name="ln2335">        break;</a>
<a name="ln2336">      }</a>
<a name="ln2337">    }</a>
<a name="ln2338">    listcmd_busy = false;</a>
<a name="ln2339">  }</a>
<a name="ln2340"> </a>
<a name="ln2341">  if (save_ei != NULL) {</a>
<a name="ln2342">    buf_T *bnext;</a>
<a name="ln2343">    aco_save_T aco;</a>
<a name="ln2344"> </a>
<a name="ln2345">    au_event_restore(save_ei);</a>
<a name="ln2346"> </a>
<a name="ln2347">    for (buf_T *buf = firstbuf; buf != NULL; buf = bnext) {</a>
<a name="ln2348">      bnext = buf-&gt;b_next;</a>
<a name="ln2349">      if (buf-&gt;b_nwindows &gt; 0 &amp;&amp; (buf-&gt;b_flags &amp; BF_SYN_SET)) {</a>
<a name="ln2350">        buf-&gt;b_flags &amp;= ~BF_SYN_SET;</a>
<a name="ln2351"> </a>
<a name="ln2352">        // buffer was opened while Syntax autocommands were disabled,</a>
<a name="ln2353">        // need to trigger them now.</a>
<a name="ln2354">        if (buf == curbuf) {</a>
<a name="ln2355">          apply_autocmds(EVENT_SYNTAX, curbuf-&gt;b_p_syn,</a>
<a name="ln2356">                         curbuf-&gt;b_fname, true, curbuf);</a>
<a name="ln2357">        } else {</a>
<a name="ln2358">          aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln2359">          apply_autocmds(EVENT_SYNTAX, buf-&gt;b_p_syn,</a>
<a name="ln2360">                         buf-&gt;b_fname, true, buf);</a>
<a name="ln2361">          aucmd_restbuf(&amp;aco);</a>
<a name="ln2362">        }</a>
<a name="ln2363"> </a>
<a name="ln2364">        // start over, in case autocommands messed things up.</a>
<a name="ln2365">        bnext = firstbuf;</a>
<a name="ln2366">      }</a>
<a name="ln2367">    }</a>
<a name="ln2368">  }</a>
<a name="ln2369">}</a>
<a name="ln2370"> </a>
<a name="ln2371">/// Add files[count] to the arglist of the current window after arg &quot;after&quot;.</a>
<a name="ln2372">/// The file names in files[count] must have been allocated and are taken over.</a>
<a name="ln2373">/// Files[] itself is not taken over.</a>
<a name="ln2374">///</a>
<a name="ln2375">/// @param after: where to add: 0 = before first one</a>
<a name="ln2376">/// @param will_edit  will edit adding argument</a>
<a name="ln2377">static void alist_add_list(int count, char_u **files, int after, bool will_edit)</a>
<a name="ln2378">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2379">{</a>
<a name="ln2380">  int old_argcount = ARGCOUNT;</a>
<a name="ln2381">  ga_grow(&amp;ALIST(curwin)-&gt;al_ga, count);</a>
<a name="ln2382">  {</a>
<a name="ln2383">    if (after &lt; 0) {</a>
<a name="ln2384">      after = 0;</a>
<a name="ln2385">    }</a>
<a name="ln2386">    if (after &gt; ARGCOUNT) {</a>
<a name="ln2387">      after = ARGCOUNT;</a>
<a name="ln2388">    }</a>
<a name="ln2389">    if (after &lt; ARGCOUNT) {</a>
<a name="ln2390">      memmove(&amp;(ARGLIST[after + count]), &amp;(ARGLIST[after]),</a>
<a name="ln2391">              (size_t)(ARGCOUNT - after) * sizeof(aentry_T));</a>
<a name="ln2392">    }</a>
<a name="ln2393">    for (int i = 0; i &lt; count; i++) {</a>
<a name="ln2394">      const int flags = BLN_LISTED | (will_edit ? BLN_CURBUF : 0);</a>
<a name="ln2395">      ARGLIST[after + i].ae_fname = files[i];</a>
<a name="ln2396">      ARGLIST[after + i].ae_fnum = buflist_add(files[i], flags);</a>
<a name="ln2397">    }</a>
<a name="ln2398">    ALIST(curwin)-&gt;al_ga.ga_len += count;</a>
<a name="ln2399">    if (old_argcount &gt; 0 &amp;&amp; curwin-&gt;w_arg_idx &gt;= after) {</a>
<a name="ln2400">      curwin-&gt;w_arg_idx += count;</a>
<a name="ln2401">    }</a>
<a name="ln2402">    return;</a>
<a name="ln2403">  }</a>
<a name="ln2404">}</a>
<a name="ln2405"> </a>
<a name="ln2406">// Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln2407">// argedit and argdelete commands.</a>
<a name="ln2408">char_u *get_arglist_name(expand_T *xp FUNC_ATTR_UNUSED, int idx)</a>
<a name="ln2409">{</a>
<a name="ln2410">  if (idx &gt;= ARGCOUNT) {</a>
<a name="ln2411">    return NULL;</a>
<a name="ln2412">  }</a>
<a name="ln2413">  return alist_name(&amp;ARGLIST[idx]);</a>
<a name="ln2414">}</a>
<a name="ln2415"> </a>
<a name="ln2416">/// &quot;:compiler[!] {name}&quot;</a>
<a name="ln2417">void ex_compiler(exarg_T *eap)</a>
<a name="ln2418">{</a>
<a name="ln2419">  char_u      *buf;</a>
<a name="ln2420">  char_u      *old_cur_comp = NULL;</a>
<a name="ln2421">  char_u      *p;</a>
<a name="ln2422"> </a>
<a name="ln2423">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln2424">    // List all compiler scripts.</a>
<a name="ln2425">    do_cmdline_cmd(&quot;echo globpath(&amp;rtp, 'compiler/*.vim')&quot;);  // NOLINT</a>
<a name="ln2426">    do_cmdline_cmd(&quot;echo globpath(&amp;rtp, 'compiler/*.lua')&quot;);  // NOLINT</a>
<a name="ln2427">  } else {</a>
<a name="ln2428">    size_t bufsize = STRLEN(eap-&gt;arg) + 14;</a>
<a name="ln2429">    buf = xmalloc(bufsize);</a>
<a name="ln2430">    if (eap-&gt;forceit) {</a>
<a name="ln2431">      // &quot;:compiler! {name}&quot; sets global options</a>
<a name="ln2432">      do_cmdline_cmd(&quot;command -nargs=* CompilerSet set &lt;args&gt;&quot;);</a>
<a name="ln2433">    } else {</a>
<a name="ln2434">      // &quot;:compiler! {name}&quot; sets local options.</a>
<a name="ln2435">      // To remain backwards compatible &quot;current_compiler&quot; is always</a>
<a name="ln2436">      // used.  A user's compiler plugin may set it, the distributed</a>
<a name="ln2437">      // plugin will then skip the settings.  Afterwards set</a>
<a name="ln2438">      // &quot;b:current_compiler&quot; and restore &quot;current_compiler&quot;.</a>
<a name="ln2439">      // Explicitly prepend &quot;g:&quot; to make it work in a function.</a>
<a name="ln2440">      old_cur_comp = get_var_value(&quot;g:current_compiler&quot;);</a>
<a name="ln2441">      if (old_cur_comp != NULL) {</a>
<a name="ln2442">        old_cur_comp = vim_strsave(old_cur_comp);</a>
<a name="ln2443">      }</a>
<a name="ln2444">      do_cmdline_cmd(&quot;command -nargs=* CompilerSet setlocal &lt;args&gt;&quot;);</a>
<a name="ln2445">    }</a>
<a name="ln2446">    do_unlet(S_LEN(&quot;g:current_compiler&quot;), true);</a>
<a name="ln2447">    do_unlet(S_LEN(&quot;b:current_compiler&quot;), true);</a>
<a name="ln2448"> </a>
<a name="ln2449">    snprintf((char *)buf, bufsize, &quot;compiler/%s.vim&quot;, eap-&gt;arg);</a>
<a name="ln2450">    if (source_in_path(p_rtp, buf, DIP_ALL) == FAIL) {</a>
<a name="ln2451">      // Try lua compiler</a>
<a name="ln2452">      snprintf((char *)buf, bufsize, &quot;compiler/%s.lua&quot;, eap-&gt;arg);</a>
<a name="ln2453">      if (source_in_path(p_rtp, buf, DIP_ALL) == FAIL) {</a>
<a name="ln2454">        EMSG2(_(&quot;E666: compiler not supported: %s&quot;), eap-&gt;arg);</a>
<a name="ln2455">      }</a>
<a name="ln2456">    }</a>
<a name="ln2457">    xfree(buf);</a>
<a name="ln2458"> </a>
<a name="ln2459">    do_cmdline_cmd(&quot;:delcommand CompilerSet&quot;);</a>
<a name="ln2460"> </a>
<a name="ln2461">    // Set &quot;b:current_compiler&quot; from &quot;current_compiler&quot;.</a>
<a name="ln2462">    p = get_var_value(&quot;g:current_compiler&quot;);</a>
<a name="ln2463">    if (p != NULL) {</a>
<a name="ln2464">      set_internal_string_var(&quot;b:current_compiler&quot;, p);</a>
<a name="ln2465">    }</a>
<a name="ln2466"> </a>
<a name="ln2467">    // Restore &quot;current_compiler&quot; for &quot;:compiler {name}&quot;.</a>
<a name="ln2468">    if (!eap-&gt;forceit) {</a>
<a name="ln2469">      if (old_cur_comp != NULL) {</a>
<a name="ln2470">        set_internal_string_var(&quot;g:current_compiler&quot;,</a>
<a name="ln2471">                                old_cur_comp);</a>
<a name="ln2472">        xfree(old_cur_comp);</a>
<a name="ln2473">      } else {</a>
<a name="ln2474">        do_unlet(S_LEN(&quot;g:current_compiler&quot;), true);</a>
<a name="ln2475">      }</a>
<a name="ln2476">    }</a>
<a name="ln2477">  }</a>
<a name="ln2478">}</a>
<a name="ln2479"> </a>
<a name="ln2480"> </a>
<a name="ln2481">/// &quot;:options&quot;</a>
<a name="ln2482">void ex_options(exarg_T *eap)</a>
<a name="ln2483">{</a>
<a name="ln2484">  os_setenv(&quot;OPTWIN_CMD&quot;, cmdmod.tab ? &quot;tab&quot; : &quot;&quot;, 1);</a>
<a name="ln2485">  os_setenv(&quot;OPTWIN_CMD&quot;,</a>
<a name="ln2486">            cmdmod.tab ? &quot;tab&quot; :</a>
<a name="ln2487">            (cmdmod.split &amp; WSP_VERT) ? &quot;vert&quot; : &quot;&quot;, 1);</a>
<a name="ln2488">  cmd_source((char_u *)SYS_OPTWIN_FILE, NULL);</a>
<a name="ln2489">}</a>
<a name="ln2490"> </a>
<a name="ln2491">// Detect Python 3 or 2, and initialize 'pyxversion'.</a>
<a name="ln2492">void init_pyxversion(void)</a>
<a name="ln2493">{</a>
<a name="ln2494">  if (p_pyx == 0) {</a>
<a name="ln2495">    if (eval_has_provider(&quot;python3&quot;)) {</a>
<a name="ln2496">      p_pyx = 3;</a>
<a name="ln2497">    } else if (eval_has_provider(&quot;python&quot;)) {</a>
<a name="ln2498">      p_pyx = 2;</a>
<a name="ln2499">    }</a>
<a name="ln2500">  }</a>
<a name="ln2501">}</a>
<a name="ln2502"> </a>
<a name="ln2503">// Does a file contain one of the following strings at the beginning of any</a>
<a name="ln2504">// line?</a>
<a name="ln2505">// &quot;#!(any string)python2&quot;  =&gt; returns 2</a>
<a name="ln2506">// &quot;#!(any string)python3&quot;  =&gt; returns 3</a>
<a name="ln2507">// &quot;# requires python 2.x&quot;  =&gt; returns 2</a>
<a name="ln2508">// &quot;# requires python 3.x&quot;  =&gt; returns 3</a>
<a name="ln2509">// otherwise return 0.</a>
<a name="ln2510">static int requires_py_version(char_u *filename)</a>
<a name="ln2511">{</a>
<a name="ln2512">  FILE      *file;</a>
<a name="ln2513">  int       requires_py_version = 0;</a>
<a name="ln2514">  int       i, lines;</a>
<a name="ln2515"> </a>
<a name="ln2516">  lines = (int)p_mls;</a>
<a name="ln2517">  if (lines &lt; 0) {</a>
<a name="ln2518">    lines = 5;</a>
<a name="ln2519">  }</a>
<a name="ln2520"> </a>
<a name="ln2521">  file = os_fopen((char *)filename, &quot;r&quot;);</a>
<a name="ln2522">  if (file != NULL) {</a>
<a name="ln2523">    for (i = 0; i &lt; lines; i++) {</a>
<a name="ln2524">      if (vim_fgets(IObuff, IOSIZE, file)) {</a>
<a name="ln2525">        break;</a>
<a name="ln2526">      }</a>
<a name="ln2527">      if (i == 0 &amp;&amp; IObuff[0] == '#' &amp;&amp; IObuff[1] == '!') {</a>
<a name="ln2528">        // Check shebang.</a>
<a name="ln2529">        if (strstr((char *)IObuff + 2, &quot;python2&quot;) != NULL) {</a>
<a name="ln2530">          requires_py_version = 2;</a>
<a name="ln2531">          break;</a>
<a name="ln2532">        }</a>
<a name="ln2533">        if (strstr((char *)IObuff + 2, &quot;python3&quot;) != NULL) {</a>
<a name="ln2534">          requires_py_version = 3;</a>
<a name="ln2535">          break;</a>
<a name="ln2536">        }</a>
<a name="ln2537">      }</a>
<a name="ln2538">      IObuff[21] = '\0';</a>
<a name="ln2539">      if (STRCMP(&quot;# requires python 2.x&quot;, IObuff) == 0) {</a>
<a name="ln2540">        requires_py_version = 2;</a>
<a name="ln2541">        break;</a>
<a name="ln2542">      }</a>
<a name="ln2543">      if (STRCMP(&quot;# requires python 3.x&quot;, IObuff) == 0) {</a>
<a name="ln2544">        requires_py_version = 3;</a>
<a name="ln2545">        break;</a>
<a name="ln2546">      }</a>
<a name="ln2547">    }</a>
<a name="ln2548">    fclose(file);</a>
<a name="ln2549">  }</a>
<a name="ln2550">  return requires_py_version;</a>
<a name="ln2551">}</a>
<a name="ln2552"> </a>
<a name="ln2553"> </a>
<a name="ln2554">// Source a python file using the requested python version.</a>
<a name="ln2555">static void source_pyx_file(exarg_T *eap, char_u *fname)</a>
<a name="ln2556">{</a>
<a name="ln2557">  exarg_T ex;</a>
<a name="ln2558">  long int v = requires_py_version(fname);</a>
<a name="ln2559"> </a>
<a name="ln2560">  init_pyxversion();</a>
<a name="ln2561">  if (v == 0) {</a>
<a name="ln2562">    // user didn't choose a preference, 'pyx' is used</a>
<a name="ln2563">    v = p_pyx;</a>
<a name="ln2564">  }</a>
<a name="ln2565"> </a>
<a name="ln2566">  // now source, if required python version is not supported show</a>
<a name="ln2567">  // unobtrusive message.</a>
<a name="ln2568">  if (eap == NULL) {</a>
<a name="ln2569">    memset(&amp;ex, 0, sizeof(ex));</a>
<a name="ln2570">  } else {</a>
<a name="ln2571">    ex = *eap;</a>
<a name="ln2572">  }</a>
<a name="ln2573">  ex.arg = fname;</a>
<a name="ln2574">  ex.cmd = (char_u *)(v == 2 ? &quot;pyfile&quot; : &quot;pyfile3&quot;);</a>
<a name="ln2575"> </a>
<a name="ln2576">  if (v == 2) {</a>
<a name="ln2577">    ex_pyfile(&amp;ex);</a>
<a name="ln2578">  } else {</a>
<a name="ln2579">    ex_py3file(&amp;ex);</a>
<a name="ln2580">  }</a>
<a name="ln2581">}</a>
<a name="ln2582"> </a>
<a name="ln2583">// &quot;:pyxfile {fname}&quot;</a>
<a name="ln2584">void ex_pyxfile(exarg_T *eap)</a>
<a name="ln2585">{</a>
<a name="ln2586">  source_pyx_file(eap, eap-&gt;arg);</a>
<a name="ln2587">}</a>
<a name="ln2588"> </a>
<a name="ln2589">// &quot;:pyx&quot;</a>
<a name="ln2590">void ex_pyx(exarg_T *eap)</a>
<a name="ln2591">{</a>
<a name="ln2592">  init_pyxversion();</a>
<a name="ln2593">  if (p_pyx == 2) {</a>
<a name="ln2594">    ex_python(eap);</a>
<a name="ln2595">  } else {</a>
<a name="ln2596">    ex_python3(eap);</a>
<a name="ln2597">  }</a>
<a name="ln2598">}</a>
<a name="ln2599"> </a>
<a name="ln2600">// &quot;:pyxdo&quot;</a>
<a name="ln2601">void ex_pyxdo(exarg_T *eap)</a>
<a name="ln2602">{</a>
<a name="ln2603">  init_pyxversion();</a>
<a name="ln2604">  if (p_pyx == 2) {</a>
<a name="ln2605">    ex_pydo(eap);</a>
<a name="ln2606">  } else {</a>
<a name="ln2607">    ex_pydo3(eap);</a>
<a name="ln2608">  }</a>
<a name="ln2609">}</a>
<a name="ln2610"> </a>
<a name="ln2611">/// &quot;:source [{fname}]&quot;</a>
<a name="ln2612">void ex_source(exarg_T *eap)</a>
<a name="ln2613">{</a>
<a name="ln2614">  cmd_source(eap-&gt;arg, eap);</a>
<a name="ln2615">}</a>
<a name="ln2616"> </a>
<a name="ln2617">static void cmd_source(char_u *fname, exarg_T *eap)</a>
<a name="ln2618">{</a>
<a name="ln2619">  if (eap != NULL &amp;&amp; *fname == NUL) {</a>
<a name="ln2620">    cmd_source_buffer(eap);</a>
<a name="ln2621">  } else if (eap != NULL &amp;&amp; eap-&gt;forceit) {</a>
<a name="ln2622">    // &quot;:source!&quot;: read Normal mode commands</a>
<a name="ln2623">    // Need to execute the commands directly.  This is required at least</a>
<a name="ln2624">    // for:</a>
<a name="ln2625">    // - &quot;:g&quot; command busy</a>
<a name="ln2626">    // - after &quot;:argdo&quot;, &quot;:windo&quot; or &quot;:bufdo&quot;</a>
<a name="ln2627">    // - another command follows</a>
<a name="ln2628">    // - inside a loop</a>
<a name="ln2629">    openscript(fname, global_busy || listcmd_busy || eap-&gt;nextcmd != NULL</a>
<a name="ln2630">               || eap-&gt;cstack-&gt;cs_idx &gt;= 0);</a>
<a name="ln2631"> </a>
<a name="ln2632">    // &quot;:source&quot; read ex commands</a>
<a name="ln2633">  } else if (do_source(fname, false, DOSO_NONE) == FAIL) {</a>
<a name="ln2634">    EMSG2(_(e_notopen), fname);</a>
<a name="ln2635">  }</a>
<a name="ln2636">}</a>
<a name="ln2637"> </a>
<a name="ln2638">typedef struct {</a>
<a name="ln2639">  linenr_T curr_lnum;</a>
<a name="ln2640">  const linenr_T final_lnum;</a>
<a name="ln2641">} GetBufferLineCookie;</a>
<a name="ln2642"> </a>
<a name="ln2643">/// Get one line from the current selection in the buffer.</a>
<a name="ln2644">/// Called by do_cmdline() when it's called from cmd_source_buffer().</a>
<a name="ln2645">///</a>
<a name="ln2646">/// @return pointer to allocated line, or NULL for end-of-file or</a>
<a name="ln2647">///         some error.</a>
<a name="ln2648">static char_u *get_buffer_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln2649">{</a>
<a name="ln2650">  GetBufferLineCookie *p = cookie;</a>
<a name="ln2651">  if (p-&gt;curr_lnum &gt; p-&gt;final_lnum) {</a>
<a name="ln2652">    return NULL;</a>
<a name="ln2653">  }</a>
<a name="ln2654">  char_u *curr_line = ml_get(p-&gt;curr_lnum);</a>
<a name="ln2655">  p-&gt;curr_lnum++;</a>
<a name="ln2656">  return (char_u *)xstrdup((const char *)curr_line);</a>
<a name="ln2657">}</a>
<a name="ln2658"> </a>
<a name="ln2659">static void cmd_source_buffer(const exarg_T *eap)</a>
<a name="ln2660">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2661">{</a>
<a name="ln2662">  GetBufferLineCookie cookie = {</a>
<a name="ln2663">      .curr_lnum = eap-&gt;line1,</a>
<a name="ln2664">      .final_lnum = eap-&gt;line2,</a>
<a name="ln2665">  };</a>
<a name="ln2666">  if (curbuf != NULL &amp;&amp; curbuf-&gt;b_fname</a>
<a name="ln2667">      &amp;&amp; path_with_extension((const char *)curbuf-&gt;b_fname, &quot;lua&quot;)) {</a>
<a name="ln2668">    nlua_source_using_linegetter(get_buffer_line, (void *)&amp;cookie,</a>
<a name="ln2669">                                 &quot;:source (no file)&quot;);</a>
<a name="ln2670">  } else {</a>
<a name="ln2671">    source_using_linegetter((void *)&amp;cookie, get_buffer_line,</a>
<a name="ln2672">                            &quot;:source (no file)&quot;);</a>
<a name="ln2673">  }</a>
<a name="ln2674">}</a>
<a name="ln2675"> </a>
<a name="ln2676">/// &quot;:source&quot; and associated commands.</a>
<a name="ln2677">///</a>
<a name="ln2678">/// @return address holding the next breakpoint line for a source cookie</a>
<a name="ln2679">linenr_T *source_breakpoint(void *cookie)</a>
<a name="ln2680">{</a>
<a name="ln2681">  return &amp;((struct source_cookie *)cookie)-&gt;breakpoint;</a>
<a name="ln2682">}</a>
<a name="ln2683"> </a>
<a name="ln2684">/// Return the address holding the debug tick for a source cookie.</a>
<a name="ln2685">int *source_dbg_tick(void *cookie)</a>
<a name="ln2686">{</a>
<a name="ln2687">  return &amp;((struct source_cookie *)cookie)-&gt;dbg_tick;</a>
<a name="ln2688">}</a>
<a name="ln2689"> </a>
<a name="ln2690">/// Return the nesting level for a source cookie.</a>
<a name="ln2691">int source_level(void *cookie)</a>
<a name="ln2692">{</a>
<a name="ln2693">  return ((struct source_cookie *)cookie)-&gt;level;</a>
<a name="ln2694">}</a>
<a name="ln2695"> </a>
<a name="ln2696">/// Special function to open a file without handle inheritance.</a>
<a name="ln2697">/// If possible the handle is closed on exec().</a>
<a name="ln2698">static FILE *fopen_noinh_readbin(char *filename)</a>
<a name="ln2699">{</a>
<a name="ln2700">#ifdef WIN32</a>
<a name="ln2701">  int fd_tmp = os_open(filename, O_RDONLY | O_BINARY | O_NOINHERIT, 0);</a>
<a name="ln2702">#else</a>
<a name="ln2703">  int fd_tmp = os_open(filename, O_RDONLY, 0);</a>
<a name="ln2704">#endif</a>
<a name="ln2705"> </a>
<a name="ln2706">  if (fd_tmp &lt; 0) {</a>
<a name="ln2707">    return NULL;</a>
<a name="ln2708">  }</a>
<a name="ln2709"> </a>
<a name="ln2710">  (void)os_set_cloexec(fd_tmp);</a>
<a name="ln2711"> </a>
<a name="ln2712">  return fdopen(fd_tmp, READBIN);</a>
<a name="ln2713">}</a>
<a name="ln2714"> </a>
<a name="ln2715">typedef struct {</a>
<a name="ln2716">  char_u *buf;</a>
<a name="ln2717">  size_t offset;</a>
<a name="ln2718">} GetStrLineCookie;</a>
<a name="ln2719"> </a>
<a name="ln2720">/// Get one full line from a sourced string (in-memory, no file).</a>
<a name="ln2721">/// Called by do_cmdline() when it's called from do_source_str().</a>
<a name="ln2722">///</a>
<a name="ln2723">/// @return pointer to allocated line, or NULL for end-of-file or</a>
<a name="ln2724">///         some error.</a>
<a name="ln2725">static char_u *get_str_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln2726">{</a>
<a name="ln2727">  GetStrLineCookie *p = cookie;</a>
<a name="ln2728">  size_t i = p-&gt;offset;</a>
<a name="ln2729">  if (strlen((char *)p-&gt;buf) &lt;= p-&gt;offset) {</a>
<a name="ln2730">    return NULL;</a>
<a name="ln2731">  }</a>
<a name="ln2732">  while (!(p-&gt;buf[i] == '\n' || p-&gt;buf[i] == '\0')) {</a>
<a name="ln2733">    i++;</a>
<a name="ln2734">  }</a>
<a name="ln2735">  size_t line_length = i - p-&gt;offset;</a>
<a name="ln2736">  char_u *buf = xmemdupz(p-&gt;buf + p-&gt;offset, line_length);</a>
<a name="ln2737">  p-&gt;offset = i + 1;</a>
<a name="ln2738">  return buf;</a>
<a name="ln2739">}</a>
<a name="ln2740"> </a>
<a name="ln2741">static int source_using_linegetter(void *cookie,</a>
<a name="ln2742">                                   LineGetter fgetline,</a>
<a name="ln2743">                                   const char *traceback_name)</a>
<a name="ln2744">{</a>
<a name="ln2745">  char_u *save_sourcing_name = sourcing_name;</a>
<a name="ln2746">  linenr_T save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln2747">  char_u sourcing_name_buf[256];</a>
<a name="ln2748">  if (save_sourcing_name == NULL) {</a>
<a name="ln2749">    sourcing_name = (char_u *)traceback_name;</a>
<a name="ln2750">  } else {</a>
<a name="ln2751">    snprintf((char *)sourcing_name_buf, sizeof(sourcing_name_buf),</a>
<a name="ln2752">             &quot;%s called at %s:%&quot;PRIdLINENR, traceback_name, save_sourcing_name,</a>
<a name="ln2753">             save_sourcing_lnum);</a>
<a name="ln2754">    sourcing_name = sourcing_name_buf;</a>
<a name="ln2755">  }</a>
<a name="ln2756">  sourcing_lnum = 0;</a>
<a name="ln2757"> </a>
<a name="ln2758">  const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln2759">  current_sctx.sc_sid = SID_STR;</a>
<a name="ln2760">  current_sctx.sc_seq = 0;</a>
<a name="ln2761">  current_sctx.sc_lnum = save_sourcing_lnum;</a>
<a name="ln2762">  funccal_entry_T entry;</a>
<a name="ln2763">  save_funccal(&amp;entry);</a>
<a name="ln2764">  int retval = do_cmdline(NULL, fgetline, cookie,</a>
<a name="ln2765">                          DOCMD_VERBOSE | DOCMD_NOWAIT | DOCMD_REPEAT);</a>
<a name="ln2766">  sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln2767">  sourcing_name = save_sourcing_name;</a>
<a name="ln2768">  current_sctx = save_current_sctx;</a>
<a name="ln2769">  restore_funccal();</a>
<a name="ln2770">  return retval;</a>
<a name="ln2771">}</a>
<a name="ln2772"> </a>
<a name="ln2773">/// Executes lines in `src` as Ex commands.</a>
<a name="ln2774">///</a>
<a name="ln2775">/// @see do_source()</a>
<a name="ln2776">int do_source_str(const char *cmd, const char *traceback_name)</a>
<a name="ln2777">{</a>
<a name="ln2778">  GetStrLineCookie cookie = {</a>
<a name="ln2779">      .buf = (char_u *)cmd,</a>
<a name="ln2780">      .offset = 0,</a>
<a name="ln2781">  };</a>
<a name="ln2782">  return source_using_linegetter((void *)&amp;cookie, get_str_line, traceback_name);</a>
<a name="ln2783">}</a>
<a name="ln2784"> </a>
<a name="ln2785">/// When fname is a 'lua' file nlua_exec_file() is invoked to source it.</a>
<a name="ln2786">/// Otherwise reads the file `fname` and executes its lines as Ex commands.</a>
<a name="ln2787">///</a>
<a name="ln2788">/// This function may be called recursively!</a>
<a name="ln2789">///</a>
<a name="ln2790">/// @see do_source_str</a>
<a name="ln2791">///</a>
<a name="ln2792">/// @param fname</a>
<a name="ln2793">/// @param check_other  check for .vimrc and _vimrc</a>
<a name="ln2794">/// @param is_vimrc     DOSO_ value</a>
<a name="ln2795">///</a>
<a name="ln2796">/// @return FAIL if file could not be opened, OK otherwise</a>
<a name="ln2797">int do_source(char_u *fname, int check_other, int is_vimrc)</a>
<a name="ln2798">{</a>
<a name="ln2799">  struct source_cookie cookie;</a>
<a name="ln2800">  char_u                  *save_sourcing_name;</a>
<a name="ln2801">  linenr_T save_sourcing_lnum;</a>
<a name="ln2802">  char_u                  *p;</a>
<a name="ln2803">  char_u                  *fname_exp;</a>
<a name="ln2804">  char_u                  *firstline = NULL;</a>
<a name="ln2805">  int retval = FAIL;</a>
<a name="ln2806">  static scid_T last_current_SID = 0;</a>
<a name="ln2807">  static int last_current_SID_seq = 0;</a>
<a name="ln2808">  int save_debug_break_level = debug_break_level;</a>
<a name="ln2809">  scriptitem_T            *si = NULL;</a>
<a name="ln2810">  proftime_T wait_start;</a>
<a name="ln2811">  bool trigger_source_post = false;</a>
<a name="ln2812"> </a>
<a name="ln2813">  p = expand_env_save(fname);</a>
<a name="ln2814">  if (p == NULL) {</a>
<a name="ln2815">    return retval;</a>
<a name="ln2816">  }</a>
<a name="ln2817">  fname_exp = (char_u *)fix_fname((char *)p);</a>
<a name="ln2818">  xfree(p);</a>
<a name="ln2819">  if (fname_exp == NULL) {</a>
<a name="ln2820">    return retval;</a>
<a name="ln2821">  }</a>
<a name="ln2822">  if (os_isdir(fname_exp)) {</a>
<a name="ln2823">    smsg(_(&quot;Cannot source a directory: \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln2824">    goto theend;</a>
<a name="ln2825">  }</a>
<a name="ln2826"> </a>
<a name="ln2827">  // Apply SourceCmd autocommands, they should get the file and source it.</a>
<a name="ln2828">  if (has_autocmd(EVENT_SOURCECMD, fname_exp, NULL)</a>
<a name="ln2829">      &amp;&amp; apply_autocmds(EVENT_SOURCECMD, fname_exp, fname_exp,</a>
<a name="ln2830">                        false, curbuf)) {</a>
<a name="ln2831">    retval = aborting() ? FAIL : OK;</a>
<a name="ln2832">    if (retval == OK) {</a>
<a name="ln2833">      // Apply SourcePost autocommands.</a>
<a name="ln2834">      apply_autocmds(EVENT_SOURCEPOST, fname_exp, fname_exp, false, curbuf);</a>
<a name="ln2835">    }</a>
<a name="ln2836">    goto theend;</a>
<a name="ln2837">  }</a>
<a name="ln2838"> </a>
<a name="ln2839">  // Apply SourcePre autocommands, they may get the file.</a>
<a name="ln2840">  apply_autocmds(EVENT_SOURCEPRE, fname_exp, fname_exp, false, curbuf);</a>
<a name="ln2841"> </a>
<a name="ln2842">  cookie.fp = fopen_noinh_readbin((char *)fname_exp);</a>
<a name="ln2843">  if (cookie.fp == NULL &amp;&amp; check_other) {</a>
<a name="ln2844">    // Try again, replacing file name &quot;.vimrc&quot; by &quot;_vimrc&quot; or vice versa,</a>
<a name="ln2845">    // and &quot;.exrc&quot; by &quot;_exrc&quot; or vice versa.</a>
<a name="ln2846">    p = path_tail(fname_exp);</a>
<a name="ln2847">    if ((*p == '.' || *p == '_')</a>
<a name="ln2848">        &amp;&amp; (STRICMP(p + 1, &quot;nvimrc&quot;) == 0 || STRICMP(p + 1, &quot;exrc&quot;) == 0)) {</a>
<a name="ln2849">      *p = (*p == '_') ? '.' : '_';</a>
<a name="ln2850">      cookie.fp = fopen_noinh_readbin((char *)fname_exp);</a>
<a name="ln2851">    }</a>
<a name="ln2852">  }</a>
<a name="ln2853"> </a>
<a name="ln2854">  if (cookie.fp == NULL) {</a>
<a name="ln2855">    if (p_verbose &gt; 0) {</a>
<a name="ln2856">      verbose_enter();</a>
<a name="ln2857">      if (sourcing_name == NULL) {</a>
<a name="ln2858">        smsg(_(&quot;could not source \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln2859">      } else {</a>
<a name="ln2860">        smsg(_(&quot;line %&quot; PRId64 &quot;: could not source \&quot;%s\&quot;&quot;),</a>
<a name="ln2861">             (int64_t)sourcing_lnum, fname);</a>
<a name="ln2862">      }</a>
<a name="ln2863">      verbose_leave();</a>
<a name="ln2864">    }</a>
<a name="ln2865">    goto theend;</a>
<a name="ln2866">  }</a>
<a name="ln2867"> </a>
<a name="ln2868">  // The file exists.</a>
<a name="ln2869">  // - In verbose mode, give a message.</a>
<a name="ln2870">  // - For a vimrc file, may want to call vimrc_found().</a>
<a name="ln2871">  if (p_verbose &gt; 1) {</a>
<a name="ln2872">    verbose_enter();</a>
<a name="ln2873">    if (sourcing_name == NULL) {</a>
<a name="ln2874">      smsg(_(&quot;sourcing \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln2875">    } else {</a>
<a name="ln2876">      smsg(_(&quot;line %&quot; PRId64 &quot;: sourcing \&quot;%s\&quot;&quot;),</a>
<a name="ln2877">           (int64_t)sourcing_lnum, fname);</a>
<a name="ln2878">    }</a>
<a name="ln2879">    verbose_leave();</a>
<a name="ln2880">  }</a>
<a name="ln2881">  if (is_vimrc == DOSO_VIMRC) {</a>
<a name="ln2882">    vimrc_found(fname_exp, (char_u *)&quot;MYVIMRC&quot;);</a>
<a name="ln2883">  }</a>
<a name="ln2884"> </a>
<a name="ln2885">#ifdef USE_CRNL</a>
<a name="ln2886">  // If no automatic file format: Set default to CR-NL.</a>
<a name="ln2887">  if (*p_ffs == NUL) {</a>
<a name="ln2888">    cookie.fileformat = EOL_DOS;</a>
<a name="ln2889">  } else {</a>
<a name="ln2890">    cookie.fileformat = EOL_UNKNOWN;</a>
<a name="ln2891">  }</a>
<a name="ln2892">  cookie.error = false;</a>
<a name="ln2893">#endif</a>
<a name="ln2894"> </a>
<a name="ln2895">  cookie.nextline = NULL;</a>
<a name="ln2896">  cookie.sourcing_lnum = 0;</a>
<a name="ln2897">  cookie.finished = false;</a>
<a name="ln2898"> </a>
<a name="ln2899">  // Check if this script has a breakpoint.</a>
<a name="ln2900">  cookie.breakpoint = dbg_find_breakpoint(true, fname_exp, (linenr_T)0);</a>
<a name="ln2901">  cookie.fname = fname_exp;</a>
<a name="ln2902">  cookie.dbg_tick = debug_tick;</a>
<a name="ln2903"> </a>
<a name="ln2904">  cookie.level = ex_nesting_level;</a>
<a name="ln2905"> </a>
<a name="ln2906">  // Keep the sourcing name/lnum, for recursive calls.</a>
<a name="ln2907">  save_sourcing_name = sourcing_name;</a>
<a name="ln2908">  sourcing_name = fname_exp;</a>
<a name="ln2909">  save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln2910">  sourcing_lnum = 0;</a>
<a name="ln2911"> </a>
<a name="ln2912">  // start measuring script load time if --startuptime was passed and</a>
<a name="ln2913">  // time_fd was successfully opened afterwards.</a>
<a name="ln2914">  proftime_T rel_time;</a>
<a name="ln2915">  proftime_T start_time;</a>
<a name="ln2916">  FILE * const l_time_fd = time_fd;</a>
<a name="ln2917">  if (l_time_fd != NULL) {</a>
<a name="ln2918">    time_push(&amp;rel_time, &amp;start_time);</a>
<a name="ln2919">  }</a>
<a name="ln2920"> </a>
<a name="ln2921">  const int l_do_profiling = do_profiling;</a>
<a name="ln2922">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln2923">    prof_child_enter(&amp;wait_start);    // entering a child now</a>
<a name="ln2924">  }</a>
<a name="ln2925"> </a>
<a name="ln2926">  // Don't use local function variables, if called from a function.</a>
<a name="ln2927">  // Also starts profiling timer for nested script.</a>
<a name="ln2928">  funccal_entry_T funccalp_entry;</a>
<a name="ln2929">  save_funccal(&amp;funccalp_entry);</a>
<a name="ln2930"> </a>
<a name="ln2931">  // Check if this script was sourced before to finds its SID.</a>
<a name="ln2932">  // If it's new, generate a new SID.</a>
<a name="ln2933">  // Always use a new sequence number.</a>
<a name="ln2934">  const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln2935">  current_sctx.sc_seq = ++last_current_SID_seq;</a>
<a name="ln2936">  current_sctx.sc_lnum = 0;</a>
<a name="ln2937">  FileID file_id;</a>
<a name="ln2938">  bool file_id_ok = os_fileid((char *)fname_exp, &amp;file_id);</a>
<a name="ln2939">  assert(script_items.ga_len &gt;= 0);</a>
<a name="ln2940">  for (current_sctx.sc_sid = script_items.ga_len; current_sctx.sc_sid &gt; 0;</a>
<a name="ln2941">       current_sctx.sc_sid--) {</a>
<a name="ln2942">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln2943">    // Compare dev/ino when possible, it catches symbolic links.</a>
<a name="ln2944">    // Also compare file names, the inode may change when the file was edited.</a>
<a name="ln2945">    bool file_id_equal = file_id_ok &amp;&amp; si-&gt;file_id_valid</a>
<a name="ln2946">                         &amp;&amp; os_fileid_equal(&amp;(si-&gt;file_id), &amp;file_id);</a>
<a name="ln2947">    if (si-&gt;sn_name != NULL</a>
<a name="ln2948">        &amp;&amp; (file_id_equal || fnamecmp(si-&gt;sn_name, fname_exp) == 0)) {</a>
<a name="ln2949">      break;</a>
<a name="ln2950">    }</a>
<a name="ln2951">  }</a>
<a name="ln2952">  if (current_sctx.sc_sid == 0) {</a>
<a name="ln2953">    current_sctx.sc_sid = ++last_current_SID;</a>
<a name="ln2954">    ga_grow(&amp;script_items, (int)(current_sctx.sc_sid - script_items.ga_len));</a>
<a name="ln2955">    while (script_items.ga_len &lt; current_sctx.sc_sid) {</a>
<a name="ln2956">      script_items.ga_len++;</a>
<a name="ln2957">      SCRIPT_ITEM(script_items.ga_len).sn_name = NULL;</a>
<a name="ln2958">      SCRIPT_ITEM(script_items.ga_len).sn_prof_on = false;</a>
<a name="ln2959">    }</a>
<a name="ln2960">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln2961">    si-&gt;sn_name = fname_exp;</a>
<a name="ln2962">    fname_exp = vim_strsave(si-&gt;sn_name);  // used for autocmd</a>
<a name="ln2963">    if (file_id_ok) {</a>
<a name="ln2964">      si-&gt;file_id_valid = true;</a>
<a name="ln2965">      si-&gt;file_id = file_id;</a>
<a name="ln2966">    } else {</a>
<a name="ln2967">      si-&gt;file_id_valid = false;</a>
<a name="ln2968">    }</a>
<a name="ln2969"> </a>
<a name="ln2970">    // Allocate the local script variables to use for this script.</a>
<a name="ln2971">    new_script_vars(current_sctx.sc_sid);</a>
<a name="ln2972">  }</a>
<a name="ln2973"> </a>
<a name="ln2974">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln2975">    bool forceit = false;</a>
<a name="ln2976"> </a>
<a name="ln2977">    // Check if we do profiling for this script.</a>
<a name="ln2978">    if (!si-&gt;sn_prof_on &amp;&amp; has_profiling(true, si-&gt;sn_name, &amp;forceit)) {</a>
<a name="ln2979">      profile_init(si);</a>
<a name="ln2980">      si-&gt;sn_pr_force = forceit;</a>
<a name="ln2981">    }</a>
<a name="ln2982">    if (si-&gt;sn_prof_on) {</a>
<a name="ln2983">      si-&gt;sn_pr_count++;</a>
<a name="ln2984">      si-&gt;sn_pr_start = profile_start();</a>
<a name="ln2985">      si-&gt;sn_pr_children = profile_zero();</a>
<a name="ln2986">    }</a>
<a name="ln2987">  }</a>
<a name="ln2988"> </a>
<a name="ln2989">  cookie.conv.vc_type = CONV_NONE;              // no conversion</a>
<a name="ln2990"> </a>
<a name="ln2991">  // Read the first line so we can check for a UTF-8 BOM.</a>
<a name="ln2992">  firstline = getsourceline(0, (void *)&amp;cookie, 0, true);</a>
<a name="ln2993">  if (firstline != NULL &amp;&amp; STRLEN(firstline) &gt;= 3 &amp;&amp; firstline[0] == 0xef</a>
<a name="ln2994">      &amp;&amp; firstline[1] == 0xbb &amp;&amp; firstline[2] == 0xbf) {</a>
<a name="ln2995">    // Found BOM; setup conversion, skip over BOM and recode the line.</a>
<a name="ln2996">    convert_setup(&amp;cookie.conv, (char_u *)&quot;utf-8&quot;, p_enc);</a>
<a name="ln2997">    p = string_convert(&amp;cookie.conv, firstline + 3, NULL);</a>
<a name="ln2998">    if (p == NULL) {</a>
<a name="ln2999">      p = vim_strsave(firstline + 3);</a>
<a name="ln3000">    }</a>
<a name="ln3001">    xfree(firstline);</a>
<a name="ln3002">    firstline = p;</a>
<a name="ln3003">  }</a>
<a name="ln3004"> </a>
<a name="ln3005">  if (path_with_extension((const char *)fname, &quot;lua&quot;)) {</a>
<a name="ln3006">    // TODO(shadmansaleh): Properly handle :verbose for lua</a>
<a name="ln3007">    // For now change currennt_sctx before sourcing lua files</a>
<a name="ln3008">    // So verbose doesn't say everything was done in line 1 since we don't know</a>
<a name="ln3009">    const sctx_T current_sctx_backup = current_sctx;</a>
<a name="ln3010">    const linenr_T sourcing_lnum_backup = sourcing_lnum;</a>
<a name="ln3011">    current_sctx.sc_lnum = 0;</a>
<a name="ln3012">    sourcing_lnum = 0;</a>
<a name="ln3013">    // Source the file as lua</a>
<a name="ln3014">    nlua_exec_file((const char *)fname);</a>
<a name="ln3015">    current_sctx = current_sctx_backup;</a>
<a name="ln3016">    sourcing_lnum = sourcing_lnum_backup;</a>
<a name="ln3017">  } else {</a>
<a name="ln3018">    // Call do_cmdline, which will call getsourceline() to get the lines.</a>
<a name="ln3019">    do_cmdline(firstline, getsourceline, (void *)&amp;cookie,</a>
<a name="ln3020">               DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_REPEAT);</a>
<a name="ln3021">  }</a>
<a name="ln3022">  retval = OK;</a>
<a name="ln3023"> </a>
<a name="ln3024">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln3025">    // Get &quot;si&quot; again, &quot;script_items&quot; may have been reallocated.</a>
<a name="ln3026">    si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3027">    if (si-&gt;sn_prof_on) {</a>
<a name="ln3028">      si-&gt;sn_pr_start = profile_end(si-&gt;sn_pr_start);</a>
<a name="ln3029">      si-&gt;sn_pr_start = profile_sub_wait(wait_start, si-&gt;sn_pr_start);</a>
<a name="ln3030">      si-&gt;sn_pr_total = profile_add(si-&gt;sn_pr_total, si-&gt;sn_pr_start);</a>
<a name="ln3031">      si-&gt;sn_pr_self = profile_self(si-&gt;sn_pr_self, si-&gt;sn_pr_start,</a>
<a name="ln3032">                                    si-&gt;sn_pr_children);</a>
<a name="ln3033">    }</a>
<a name="ln3034">  }</a>
<a name="ln3035"> </a>
<a name="ln3036">  if (got_int) {</a>
<a name="ln3037">    EMSG(_(e_interr));</a>
<a name="ln3038">  }</a>
<a name="ln3039">  sourcing_name = save_sourcing_name;</a>
<a name="ln3040">  sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln3041">  if (p_verbose &gt; 1) {</a>
<a name="ln3042">    verbose_enter();</a>
<a name="ln3043">    smsg(_(&quot;finished sourcing %s&quot;), fname);</a>
<a name="ln3044">    if (sourcing_name != NULL) {</a>
<a name="ln3045">      smsg(_(&quot;continuing in %s&quot;), sourcing_name);</a>
<a name="ln3046">    }</a>
<a name="ln3047">    verbose_leave();</a>
<a name="ln3048">  }</a>
<a name="ln3049"> </a>
<a name="ln3050">  if (l_time_fd != NULL) {</a>
<a name="ln3051">    vim_snprintf((char *)IObuff, IOSIZE, &quot;sourcing %s&quot;, fname);</a>
<a name="ln3052">    time_msg((char *)IObuff, &amp;start_time);</a>
<a name="ln3053">    time_pop(rel_time);</a>
<a name="ln3054">  }</a>
<a name="ln3055"> </a>
<a name="ln3056">  if (!got_int) {</a>
<a name="ln3057">    trigger_source_post = true;</a>
<a name="ln3058">  }</a>
<a name="ln3059"> </a>
<a name="ln3060">  // After a &quot;finish&quot; in debug mode, need to break at first command of next</a>
<a name="ln3061">  // sourced file.</a>
<a name="ln3062">  if (save_debug_break_level &gt; ex_nesting_level</a>
<a name="ln3063">      &amp;&amp; debug_break_level == ex_nesting_level) {</a>
<a name="ln3064">    debug_break_level++;</a>
<a name="ln3065">  }</a>
<a name="ln3066"> </a>
<a name="ln3067">  current_sctx = save_current_sctx;</a>
<a name="ln3068">  restore_funccal();</a>
<a name="ln3069">  if (l_do_profiling == PROF_YES) {</a>
<a name="ln3070">    prof_child_exit(&amp;wait_start);    // leaving a child now</a>
<a name="ln3071">  }</a>
<a name="ln3072">  fclose(cookie.fp);</a>
<a name="ln3073">  xfree(cookie.nextline);</a>
<a name="ln3074">  xfree(firstline);</a>
<a name="ln3075">  convert_setup(&amp;cookie.conv, NULL, NULL);</a>
<a name="ln3076"> </a>
<a name="ln3077">  if (trigger_source_post) {</a>
<a name="ln3078">    apply_autocmds(EVENT_SOURCEPOST, fname_exp, fname_exp, false, curbuf);</a>
<a name="ln3079">  }</a>
<a name="ln3080"> </a>
<a name="ln3081">theend:</a>
<a name="ln3082">  xfree(fname_exp);</a>
<a name="ln3083">  return retval;</a>
<a name="ln3084">}</a>
<a name="ln3085"> </a>
<a name="ln3086"> </a>
<a name="ln3087">/// &quot;:scriptnames&quot;</a>
<a name="ln3088">void ex_scriptnames(exarg_T *eap)</a>
<a name="ln3089">{</a>
<a name="ln3090">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln3091">    // :script {scriptId}: edit the script</a>
<a name="ln3092">    if (eap-&gt;line2 &lt; 1 || eap-&gt;line2 &gt; script_items.ga_len) {</a>
<a name="ln3093">      EMSG(_(e_invarg));</a>
<a name="ln3094">    } else {</a>
<a name="ln3095">      eap-&gt;arg = SCRIPT_ITEM(eap-&gt;line2).sn_name;</a>
<a name="ln3096">      do_exedit(eap, NULL);</a>
<a name="ln3097">    }</a>
<a name="ln3098">    return;</a>
<a name="ln3099">  }</a>
<a name="ln3100"> </a>
<a name="ln3101">  for (int i = 1; i &lt;= script_items.ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln3102">    if (SCRIPT_ITEM(i).sn_name != NULL) {</a>
<a name="ln3103">      home_replace(NULL, SCRIPT_ITEM(i).sn_name,</a>
<a name="ln3104">                   NameBuff, MAXPATHL, true);</a>
<a name="ln3105">      smsg(&quot;%3d: %s&quot;, i, NameBuff);</a>
<a name="ln3106">    }</a>
<a name="ln3107">  }</a>
<a name="ln3108">}</a>
<a name="ln3109"> </a>
<a name="ln3110"># if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln3111">/// Fix slashes in the list of script names for 'shellslash'.</a>
<a name="ln3112">void scriptnames_slash_adjust(void)</a>
<a name="ln3113">{</a>
<a name="ln3114">  for (int i = 1; i &lt;= script_items.ga_len; i++) {</a>
<a name="ln3115">    if (SCRIPT_ITEM(i).sn_name != NULL) {</a>
<a name="ln3116">      slash_adjust(SCRIPT_ITEM(i).sn_name);</a>
<a name="ln3117">    }</a>
<a name="ln3118">  }</a>
<a name="ln3119">}</a>
<a name="ln3120"> </a>
<a name="ln3121"># endif</a>
<a name="ln3122"> </a>
<a name="ln3123">/// Get a pointer to a script name.  Used for &quot;:verbose set&quot;.</a>
<a name="ln3124">/// Message appended to &quot;Last set from &quot;</a>
<a name="ln3125">char_u *get_scriptname(LastSet last_set, bool *should_free)</a>
<a name="ln3126">{</a>
<a name="ln3127">  *should_free = false;</a>
<a name="ln3128"> </a>
<a name="ln3129">  switch (last_set.script_ctx.sc_sid) {</a>
<a name="ln3130">    case SID_MODELINE:</a>
<a name="ln3131">      return (char_u *)_(&quot;modeline&quot;);</a>
<a name="ln3132">    case SID_CMDARG:</a>
<a name="ln3133">      return (char_u *)_(&quot;--cmd argument&quot;);</a>
<a name="ln3134">    case SID_CARG:</a>
<a name="ln3135">      return (char_u *)_(&quot;-c argument&quot;);</a>
<a name="ln3136">    case SID_ENV:</a>
<a name="ln3137">      return (char_u *)_(&quot;environment variable&quot;);</a>
<a name="ln3138">    case SID_ERROR:</a>
<a name="ln3139">      return (char_u *)_(&quot;error handler&quot;);</a>
<a name="ln3140">    case SID_WINLAYOUT:</a>
<a name="ln3141">      return (char_u *)_(&quot;changed window size&quot;);</a>
<a name="ln3142">    case SID_LUA:</a>
<a name="ln3143">      return (char_u *)_(&quot;Lua&quot;);</a>
<a name="ln3144">    case SID_API_CLIENT:</a>
<a name="ln3145">      vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln3146">                   _(&quot;API client (channel id %&quot; PRIu64 &quot;)&quot;),</a>
<a name="ln3147">                   last_set.channel_id);</a>
<a name="ln3148">      return IObuff;</a>
<a name="ln3149">    case SID_STR:</a>
<a name="ln3150">      return (char_u *)_(&quot;anonymous :source&quot;);</a>
<a name="ln3151">    default:</a>
<a name="ln3152">      *should_free = true;</a>
<a name="ln3153">      return home_replace_save(NULL,</a>
<a name="ln3154">                               SCRIPT_ITEM(last_set.script_ctx.sc_sid).sn_name);</a>
<a name="ln3155">  }</a>
<a name="ln3156">}</a>
<a name="ln3157"> </a>
<a name="ln3158"># if defined(EXITFREE)</a>
<a name="ln3159">void free_scriptnames(void)</a>
<a name="ln3160">{</a>
<a name="ln3161">  profile_reset();</a>
<a name="ln3162"> </a>
<a name="ln3163"># define FREE_SCRIPTNAME(item) xfree((item)-&gt;sn_name)</a>
<a name="ln3164">  GA_DEEP_CLEAR(&amp;script_items, scriptitem_T, FREE_SCRIPTNAME);</a>
<a name="ln3165">}</a>
<a name="ln3166"># endif</a>
<a name="ln3167"> </a>
<a name="ln3168">linenr_T get_sourced_lnum(LineGetter fgetline, void *cookie)</a>
<a name="ln3169">{</a>
<a name="ln3170">    return fgetline == getsourceline</a>
<a name="ln3171">        ? ((struct source_cookie *)cookie)-&gt;sourcing_lnum</a>
<a name="ln3172">        : sourcing_lnum;</a>
<a name="ln3173">}</a>
<a name="ln3174"> </a>
<a name="ln3175"> </a>
<a name="ln3176">/// Get one full line from a sourced file.</a>
<a name="ln3177">/// Called by do_cmdline() when it's called from do_source().</a>
<a name="ln3178">///</a>
<a name="ln3179">/// @return pointer to the line in allocated memory, or NULL for end-of-file or</a>
<a name="ln3180">///         some error.</a>
<a name="ln3181">char_u *getsourceline(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln3182">{</a>
<a name="ln3183">  struct source_cookie *sp = (struct source_cookie *)cookie;</a>
<a name="ln3184">  char_u *line;</a>
<a name="ln3185">  char_u *p;</a>
<a name="ln3186"> </a>
<a name="ln3187">  // If breakpoints have been added/deleted need to check for it.</a>
<a name="ln3188">  if (sp-&gt;dbg_tick &lt; debug_tick) {</a>
<a name="ln3189">    sp-&gt;breakpoint = dbg_find_breakpoint(true, sp-&gt;fname, sourcing_lnum);</a>
<a name="ln3190">    sp-&gt;dbg_tick = debug_tick;</a>
<a name="ln3191">  }</a>
<a name="ln3192">  if (do_profiling == PROF_YES) {</a>
<a name="ln3193">    script_line_end();</a>
<a name="ln3194">  }</a>
<a name="ln3195">  // Set the current sourcing line number.</a>
<a name="ln3196">  sourcing_lnum = sp-&gt;sourcing_lnum + 1;</a>
<a name="ln3197">  // Get current line.  If there is a read-ahead line, use it, otherwise get</a>
<a name="ln3198">  // one now.</a>
<a name="ln3199">  if (sp-&gt;finished) {</a>
<a name="ln3200">    line = NULL;</a>
<a name="ln3201">  } else if (sp-&gt;nextline == NULL) {</a>
<a name="ln3202">    line = get_one_sourceline(sp);</a>
<a name="ln3203">  } else {</a>
<a name="ln3204">    line = sp-&gt;nextline;</a>
<a name="ln3205">    sp-&gt;nextline = NULL;</a>
<a name="ln3206">    sp-&gt;sourcing_lnum++;</a>
<a name="ln3207">  }</a>
<a name="ln3208">  if (line != NULL &amp;&amp; do_profiling == PROF_YES) {</a>
<a name="ln3209">    script_line_start();</a>
<a name="ln3210">  }</a>
<a name="ln3211"> </a>
<a name="ln3212">  // Only concatenate lines starting with a \ when 'cpoptions' doesn't</a>
<a name="ln3213">  // contain the 'C' flag.</a>
<a name="ln3214">  if (line != NULL &amp;&amp; do_concat &amp;&amp; (vim_strchr(p_cpo, CPO_CONCAT) == NULL)) {</a>
<a name="ln3215">    // compensate for the one line read-ahead</a>
<a name="ln3216">    sp-&gt;sourcing_lnum--;</a>
<a name="ln3217"> </a>
<a name="ln3218">    // Get the next line and concatenate it when it starts with a</a>
<a name="ln3219">    // backslash. We always need to read the next line, keep it in</a>
<a name="ln3220">    // sp-&gt;nextline.</a>
<a name="ln3221">    // Also check for a comment in between continuation lines: &quot;\ .</a>
<a name="ln3222">    sp-&gt;nextline = get_one_sourceline(sp);</a>
<a name="ln3223">    if (sp-&gt;nextline != NULL</a>
<a name="ln3224">        &amp;&amp; (*(p = skipwhite(sp-&gt;nextline)) == '\\'</a>
<a name="ln3225">            || (p[0] == '&quot;' &amp;&amp; p[1] == '\\' &amp;&amp; p[2] == ' '))) {</a>
<a name="ln3226">      garray_T ga;</a>
<a name="ln3227"> </a>
<a name="ln3228">      ga_init(&amp;ga, (int)sizeof(char_u), 400);</a>
<a name="ln3229">      ga_concat(&amp;ga, line);</a>
<a name="ln3230">      if (*p == '\\') {</a>
<a name="ln3231">        ga_concat(&amp;ga, p + 1);</a>
<a name="ln3232">      }</a>
<a name="ln3233">      for (;; ) {</a>
<a name="ln3234">        xfree(sp-&gt;nextline);</a>
<a name="ln3235">        sp-&gt;nextline = get_one_sourceline(sp);</a>
<a name="ln3236">        if (sp-&gt;nextline == NULL) {</a>
<a name="ln3237">          break;</a>
<a name="ln3238">        }</a>
<a name="ln3239">        p = skipwhite(sp-&gt;nextline);</a>
<a name="ln3240">        if (*p == '\\') {</a>
<a name="ln3241">          // Adjust the growsize to the current length to speed up</a>
<a name="ln3242">          // concatenating many lines.</a>
<a name="ln3243">          if (ga.ga_len &gt; 400) {</a>
<a name="ln3244">            ga_set_growsize(&amp;ga, (ga.ga_len &gt; 8000) ? 8000 : ga.ga_len);</a>
<a name="ln3245">          }</a>
<a name="ln3246">          ga_concat(&amp;ga, p + 1);</a>
<a name="ln3247">        } else if (p[0] != '&quot;' || p[1] != '\\' || p[2] != ' ') {</a>
<a name="ln3248">          break;</a>
<a name="ln3249">        }</a>
<a name="ln3250">      }</a>
<a name="ln3251">      ga_append(&amp;ga, NUL);</a>
<a name="ln3252">      xfree(line);</a>
<a name="ln3253">      line = ga.ga_data;</a>
<a name="ln3254">    }</a>
<a name="ln3255">  }</a>
<a name="ln3256"> </a>
<a name="ln3257">  if (line != NULL &amp;&amp; sp-&gt;conv.vc_type != CONV_NONE) {</a>
<a name="ln3258">    char_u  *s;</a>
<a name="ln3259"> </a>
<a name="ln3260">    // Convert the encoding of the script line.</a>
<a name="ln3261">    s = string_convert(&amp;sp-&gt;conv, line, NULL);</a>
<a name="ln3262">    if (s != NULL) {</a>
<a name="ln3263">      xfree(line);</a>
<a name="ln3264">      line = s;</a>
<a name="ln3265">    }</a>
<a name="ln3266">  }</a>
<a name="ln3267"> </a>
<a name="ln3268">  // Did we encounter a breakpoint?</a>
<a name="ln3269">  if (sp-&gt;breakpoint != 0 &amp;&amp; sp-&gt;breakpoint &lt;= sourcing_lnum) {</a>
<a name="ln3270">    dbg_breakpoint(sp-&gt;fname, sourcing_lnum);</a>
<a name="ln3271">    // Find next breakpoint.</a>
<a name="ln3272">    sp-&gt;breakpoint = dbg_find_breakpoint(true, sp-&gt;fname, sourcing_lnum);</a>
<a name="ln3273">    sp-&gt;dbg_tick = debug_tick;</a>
<a name="ln3274">  }</a>
<a name="ln3275"> </a>
<a name="ln3276">  return line;</a>
<a name="ln3277">}</a>
<a name="ln3278"> </a>
<a name="ln3279">static char_u *get_one_sourceline(struct source_cookie *sp)</a>
<a name="ln3280">{</a>
<a name="ln3281">  garray_T ga;</a>
<a name="ln3282">  int len;</a>
<a name="ln3283">  int c;</a>
<a name="ln3284">  char_u              *buf;</a>
<a name="ln3285">#ifdef USE_CRNL</a>
<a name="ln3286">  int has_cr;                           // CR-LF found</a>
<a name="ln3287">#endif</a>
<a name="ln3288">  bool have_read = false;</a>
<a name="ln3289"> </a>
<a name="ln3290">  // use a growarray to store the sourced line</a>
<a name="ln3291">  ga_init(&amp;ga, 1, 250);</a>
<a name="ln3292"> </a>
<a name="ln3293">  // Loop until there is a finished line (or end-of-file).</a>
<a name="ln3294">  sp-&gt;sourcing_lnum++;</a>
<a name="ln3295">  for (;; ) {</a>
<a name="ln3296">    // make room to read at least 120 (more) characters</a>
<a name="ln3297">    ga_grow(&amp;ga, 120);</a>
<a name="ln3298">    buf = (char_u *)ga.ga_data;</a>
<a name="ln3299"> </a>
<a name="ln3300">retry:</a>
<a name="ln3301">    errno = 0;</a>
<a name="ln3302">    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,</a>
<a name="ln3303">              sp-&gt;fp) == NULL) {</a>
<a name="ln3304">      if (errno == EINTR) {</a>
<a name="ln3305">        goto retry;</a>
<a name="ln3306">      }</a>
<a name="ln3307"> </a>
<a name="ln3308">      break;</a>
<a name="ln3309">    }</a>
<a name="ln3310">    len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);</a>
<a name="ln3311">#ifdef USE_CRNL</a>
<a name="ln3312">    // Ignore a trailing CTRL-Z, when in Dos mode. Only recognize the</a>
<a name="ln3313">    // CTRL-Z by its own, or after a NL.</a>
<a name="ln3314">    if ((len == 1 || (len &gt;= 2 &amp;&amp; buf[len - 2] == '\n'))</a>
<a name="ln3315">        &amp;&amp; sp-&gt;fileformat == EOL_DOS</a>
<a name="ln3316">        &amp;&amp; buf[len - 1] == Ctrl_Z) {</a>
<a name="ln3317">      buf[len - 1] = NUL;</a>
<a name="ln3318">      break;</a>
<a name="ln3319">    }</a>
<a name="ln3320">#endif</a>
<a name="ln3321"> </a>
<a name="ln3322">    have_read = true;</a>
<a name="ln3323">    ga.ga_len = len;</a>
<a name="ln3324"> </a>
<a name="ln3325">    // If the line was longer than the buffer, read more.</a>
<a name="ln3326">    if (ga.ga_maxlen - ga.ga_len == 1 &amp;&amp; buf[len - 1] != '\n') {</a>
<a name="ln3327">      continue;</a>
<a name="ln3328">    }</a>
<a name="ln3329"> </a>
<a name="ln3330">    if (len &gt;= 1 &amp;&amp; buf[len - 1] == '\n') {     // remove trailing NL</a>
<a name="ln3331">#ifdef USE_CRNL</a>
<a name="ln3332">      has_cr = (len &gt;= 2 &amp;&amp; buf[len - 2] == '\r');</a>
<a name="ln3333">      if (sp-&gt;fileformat == EOL_UNKNOWN) {</a>
<a name="ln3334">        if (has_cr) {</a>
<a name="ln3335">          sp-&gt;fileformat = EOL_DOS;</a>
<a name="ln3336">        } else {</a>
<a name="ln3337">          sp-&gt;fileformat = EOL_UNIX;</a>
<a name="ln3338">        }</a>
<a name="ln3339">      }</a>
<a name="ln3340"> </a>
<a name="ln3341">      if (sp-&gt;fileformat == EOL_DOS) {</a>
<a name="ln3342">        if (has_cr) {               // replace trailing CR</a>
<a name="ln3343">          buf[len - 2] = '\n';</a>
<a name="ln3344">          len--;</a>
<a name="ln3345">          ga.ga_len--;</a>
<a name="ln3346">        } else {          // lines like &quot;:map xx yy^M&quot; will have failed</a>
<a name="ln3347">          if (!sp-&gt;error) {</a>
<a name="ln3348">            msg_source(HL_ATTR(HLF_W));</a>
<a name="ln3349">            EMSG(_(&quot;W15: Warning: Wrong line separator, ^M may be missing&quot;));</a>
<a name="ln3350">          }</a>
<a name="ln3351">          sp-&gt;error = true;</a>
<a name="ln3352">          sp-&gt;fileformat = EOL_UNIX;</a>
<a name="ln3353">        }</a>
<a name="ln3354">      }</a>
<a name="ln3355">#endif</a>
<a name="ln3356">      // The '\n' is escaped if there is an odd number of ^V's just</a>
<a name="ln3357">      // before it, first set &quot;c&quot; just before the 'V's and then check</a>
<a name="ln3358">      // len&amp;c parities (is faster than ((len-c)%2 == 0)) -- Acevedo</a>
<a name="ln3359">      for (c = len - 2; c &gt;= 0 &amp;&amp; buf[c] == Ctrl_V; c--) {}</a>
<a name="ln3360">      if ((len &amp; 1) != (c &amp; 1)) {       // escaped NL, read more</a>
<a name="ln3361">        sp-&gt;sourcing_lnum++;</a>
<a name="ln3362">        continue;</a>
<a name="ln3363">      }</a>
<a name="ln3364"> </a>
<a name="ln3365">      buf[len - 1] = NUL;               // remove the NL</a>
<a name="ln3366">    }</a>
<a name="ln3367"> </a>
<a name="ln3368">    // Check for ^C here now and then, so recursive :so can be broken.</a>
<a name="ln3369">    line_breakcheck();</a>
<a name="ln3370">    break;</a>
<a name="ln3371">  }</a>
<a name="ln3372"> </a>
<a name="ln3373">  if (have_read) {</a>
<a name="ln3374">    return (char_u *)ga.ga_data;</a>
<a name="ln3375">  }</a>
<a name="ln3376"> </a>
<a name="ln3377">  xfree(ga.ga_data);</a>
<a name="ln3378">  return NULL;</a>
<a name="ln3379">}</a>
<a name="ln3380"> </a>
<a name="ln3381">/// Called when starting to read a script line.</a>
<a name="ln3382">/// &quot;sourcing_lnum&quot; must be correct!</a>
<a name="ln3383">/// When skipping lines it may not actually be executed, but we won't find out</a>
<a name="ln3384">/// until later and we need to store the time now.</a>
<a name="ln3385">void script_line_start(void)</a>
<a name="ln3386">{</a>
<a name="ln3387">  scriptitem_T    *si;</a>
<a name="ln3388">  sn_prl_T        *pp;</a>
<a name="ln3389"> </a>
<a name="ln3390">  if (current_sctx.sc_sid &lt;= 0 || current_sctx.sc_sid &gt; script_items.ga_len) {</a>
<a name="ln3391">    return;</a>
<a name="ln3392">  }</a>
<a name="ln3393">  si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3394">  if (si-&gt;sn_prof_on &amp;&amp; sourcing_lnum &gt;= 1) {</a>
<a name="ln3395">    // Grow the array before starting the timer, so that the time spent</a>
<a name="ln3396">    // here isn't counted.</a>
<a name="ln3397">    (void)ga_grow(&amp;si-&gt;sn_prl_ga,</a>
<a name="ln3398">                  (int)(sourcing_lnum - si-&gt;sn_prl_ga.ga_len));</a>
<a name="ln3399">    si-&gt;sn_prl_idx = sourcing_lnum - 1;</a>
<a name="ln3400">    while (si-&gt;sn_prl_ga.ga_len &lt;= si-&gt;sn_prl_idx</a>
<a name="ln3401">           &amp;&amp; si-&gt;sn_prl_ga.ga_len &lt; si-&gt;sn_prl_ga.ga_maxlen) {</a>
<a name="ln3402">      // Zero counters for a line that was not used before.</a>
<a name="ln3403">      pp = &amp;PRL_ITEM(si, si-&gt;sn_prl_ga.ga_len);</a>
<a name="ln3404">      pp-&gt;snp_count = 0;</a>
<a name="ln3405">      pp-&gt;sn_prl_total = profile_zero();</a>
<a name="ln3406">      pp-&gt;sn_prl_self = profile_zero();</a>
<a name="ln3407">      si-&gt;sn_prl_ga.ga_len++;</a>
<a name="ln3408">    }</a>
<a name="ln3409">    si-&gt;sn_prl_execed = false;</a>
<a name="ln3410">    si-&gt;sn_prl_start = profile_start();</a>
<a name="ln3411">    si-&gt;sn_prl_children = profile_zero();</a>
<a name="ln3412">    si-&gt;sn_prl_wait = profile_get_wait();</a>
<a name="ln3413">  }</a>
<a name="ln3414">}</a>
<a name="ln3415"> </a>
<a name="ln3416">/// Called when actually executing a function line.</a>
<a name="ln3417">void script_line_exec(void)</a>
<a name="ln3418">{</a>
<a name="ln3419">  scriptitem_T    *si;</a>
<a name="ln3420"> </a>
<a name="ln3421">  if (current_sctx.sc_sid &lt;= 0 || current_sctx.sc_sid &gt; script_items.ga_len) {</a>
<a name="ln3422">    return;</a>
<a name="ln3423">  }</a>
<a name="ln3424">  si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3425">  if (si-&gt;sn_prof_on &amp;&amp; si-&gt;sn_prl_idx &gt;= 0) {</a>
<a name="ln3426">    si-&gt;sn_prl_execed = true;</a>
<a name="ln3427">  }</a>
<a name="ln3428">}</a>
<a name="ln3429"> </a>
<a name="ln3430">/// Called when done with a function line.</a>
<a name="ln3431">void script_line_end(void)</a>
<a name="ln3432">{</a>
<a name="ln3433">  scriptitem_T    *si;</a>
<a name="ln3434">  sn_prl_T        *pp;</a>
<a name="ln3435"> </a>
<a name="ln3436">  if (current_sctx.sc_sid &lt;= 0 || current_sctx.sc_sid &gt; script_items.ga_len) {</a>
<a name="ln3437">    return;</a>
<a name="ln3438">  }</a>
<a name="ln3439">  si = &amp;SCRIPT_ITEM(current_sctx.sc_sid);</a>
<a name="ln3440">  if (si-&gt;sn_prof_on &amp;&amp; si-&gt;sn_prl_idx &gt;= 0</a>
<a name="ln3441">      &amp;&amp; si-&gt;sn_prl_idx &lt; si-&gt;sn_prl_ga.ga_len) {</a>
<a name="ln3442">    if (si-&gt;sn_prl_execed) {</a>
<a name="ln3443">      pp = &amp;PRL_ITEM(si, si-&gt;sn_prl_idx);</a>
<a name="ln3444">      pp-&gt;snp_count++;</a>
<a name="ln3445">      si-&gt;sn_prl_start = profile_end(si-&gt;sn_prl_start);</a>
<a name="ln3446">      si-&gt;sn_prl_start = profile_sub_wait(si-&gt;sn_prl_wait, si-&gt;sn_prl_start);</a>
<a name="ln3447">      pp-&gt;sn_prl_total = profile_add(pp-&gt;sn_prl_total, si-&gt;sn_prl_start);</a>
<a name="ln3448">      pp-&gt;sn_prl_self = profile_self(pp-&gt;sn_prl_self, si-&gt;sn_prl_start,</a>
<a name="ln3449">                                     si-&gt;sn_prl_children);</a>
<a name="ln3450">    }</a>
<a name="ln3451">    si-&gt;sn_prl_idx = -1;</a>
<a name="ln3452">  }</a>
<a name="ln3453">}</a>
<a name="ln3454"> </a>
<a name="ln3455">/// &quot;:scriptencoding&quot;: Set encoding conversion for a sourced script.</a>
<a name="ln3456">/// Without the multi-byte feature it's simply ignored.</a>
<a name="ln3457">void ex_scriptencoding(exarg_T *eap)</a>
<a name="ln3458">{</a>
<a name="ln3459">  struct source_cookie        *sp;</a>
<a name="ln3460">  char_u                      *name;</a>
<a name="ln3461"> </a>
<a name="ln3462">  if (!getline_equal(eap-&gt;getline, eap-&gt;cookie, getsourceline)) {</a>
<a name="ln3463">    EMSG(_(&quot;E167: :scriptencoding used outside of a sourced file&quot;));</a>
<a name="ln3464">    return;</a>
<a name="ln3465">  }</a>
<a name="ln3466"> </a>
<a name="ln3467">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln3468">    name = enc_canonize(eap-&gt;arg);</a>
<a name="ln3469">  } else {</a>
<a name="ln3470">    name = eap-&gt;arg;</a>
<a name="ln3471">  }</a>
<a name="ln3472"> </a>
<a name="ln3473">  // Setup for conversion from the specified encoding to 'encoding'.</a>
<a name="ln3474">  sp = (struct source_cookie *)getline_cookie(eap-&gt;getline, eap-&gt;cookie);</a>
<a name="ln3475">  convert_setup(&amp;sp-&gt;conv, name, p_enc);</a>
<a name="ln3476"> </a>
<a name="ln3477">  if (name != eap-&gt;arg) {</a>
<a name="ln3478">    xfree(name);</a>
<a name="ln3479">  }</a>
<a name="ln3480">}</a>
<a name="ln3481"> </a>
<a name="ln3482">/// &quot;:finish&quot;: Mark a sourced file as finished.</a>
<a name="ln3483">void ex_finish(exarg_T *eap)</a>
<a name="ln3484">{</a>
<a name="ln3485">  if (getline_equal(eap-&gt;getline, eap-&gt;cookie, getsourceline)) {</a>
<a name="ln3486">    do_finish(eap, false);</a>
<a name="ln3487">  } else {</a>
<a name="ln3488">    EMSG(_(&quot;E168: :finish used outside of a sourced file&quot;));</a>
<a name="ln3489">  }</a>
<a name="ln3490">}</a>
<a name="ln3491"> </a>
<a name="ln3492">/// Mark a sourced file as finished.  Possibly makes the &quot;:finish&quot; pending.</a>
<a name="ln3493">/// Also called for a pending finish at the &quot;:endtry&quot; or after returning from</a>
<a name="ln3494">/// an extra do_cmdline().  &quot;reanimate&quot; is used in the latter case.</a>
<a name="ln3495">void do_finish(exarg_T *eap, int reanimate)</a>
<a name="ln3496">{</a>
<a name="ln3497">  int idx;</a>
<a name="ln3498"> </a>
<a name="ln3499">  if (reanimate) {</a>
<a name="ln3500">    ((struct source_cookie *)getline_cookie(eap-&gt;getline,</a>
<a name="ln3501">                                            eap-&gt;cookie))-&gt;finished = false;</a>
<a name="ln3502">  }</a>
<a name="ln3503"> </a>
<a name="ln3504">  // Cleanup (and inactivate) conditionals, but stop when a try conditional</a>
<a name="ln3505">  // not in its finally clause (which then is to be executed next) is found.</a>
<a name="ln3506">  // In this case, make the &quot;:finish&quot; pending for execution at the &quot;:endtry&quot;.</a>
<a name="ln3507">  // Otherwise, finish normally.</a>
<a name="ln3508">  idx = cleanup_conditionals(eap-&gt;cstack, 0, true);</a>
<a name="ln3509">  if (idx &gt;= 0) {</a>
<a name="ln3510">    eap-&gt;cstack-&gt;cs_pending[idx] = CSTP_FINISH;</a>
<a name="ln3511">    report_make_pending(CSTP_FINISH, NULL);</a>
<a name="ln3512">  } else {</a>
<a name="ln3513">    ((struct source_cookie *)getline_cookie(eap-&gt;getline,</a>
<a name="ln3514">                                            eap-&gt;cookie))-&gt;finished = true;</a>
<a name="ln3515">  }</a>
<a name="ln3516">}</a>
<a name="ln3517"> </a>
<a name="ln3518"> </a>
<a name="ln3519">/// Return true when a sourced file had the &quot;:finish&quot; command: Don't give error</a>
<a name="ln3520">/// message for missing &quot;:endif&quot;.</a>
<a name="ln3521">/// Return false when not sourcing a file.</a>
<a name="ln3522">bool source_finished(LineGetter fgetline, void *cookie)</a>
<a name="ln3523">{</a>
<a name="ln3524">  return getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln3525">         &amp;&amp; ((struct source_cookie *)getline_cookie(</a>
<a name="ln3526">             fgetline, cookie))-&gt;finished;</a>
<a name="ln3527">}</a>
<a name="ln3528"> </a>
<a name="ln3529">/// &quot;:checktime [buffer]&quot;</a>
<a name="ln3530">void ex_checktime(exarg_T *eap)</a>
<a name="ln3531">{</a>
<a name="ln3532">  buf_T       *buf;</a>
<a name="ln3533">  int save_no_check_timestamps = no_check_timestamps;</a>
<a name="ln3534"> </a>
<a name="ln3535">  no_check_timestamps = 0;</a>
<a name="ln3536">  if (eap-&gt;addr_count == 0) {    // default is all buffers</a>
<a name="ln3537">    check_timestamps(false);</a>
<a name="ln3538">  } else {</a>
<a name="ln3539">    buf = buflist_findnr((int)eap-&gt;line2);</a>
<a name="ln3540">    if (buf != NULL) {           // cannot happen?</a>
<a name="ln3541">      (void)buf_check_timestamp(buf);</a>
<a name="ln3542">    }</a>
<a name="ln3543">  }</a>
<a name="ln3544">  no_check_timestamps = save_no_check_timestamps;</a>
<a name="ln3545">}</a>
<a name="ln3546"> </a>
<a name="ln3547">#if defined(HAVE_LOCALE_H)</a>
<a name="ln3548"># define HAVE_GET_LOCALE_VAL</a>
<a name="ln3549"> </a>
<a name="ln3550">static char *get_locale_val(int what)</a>
<a name="ln3551">{</a>
<a name="ln3552">  // Obtain the locale value from the libraries.</a>
<a name="ln3553">  char *loc = setlocale(what, NULL);</a>
<a name="ln3554"> </a>
<a name="ln3555">  return loc;</a>
<a name="ln3556">}</a>
<a name="ln3557">#endif</a>
<a name="ln3558"> </a>
<a name="ln3559">// Return true when &quot;lang&quot; starts with a valid language name.</a>
<a name="ln3560">// Rejects NULL, empty string, &quot;C&quot;, &quot;C.UTF-8&quot; and others.</a>
<a name="ln3561">static bool is_valid_mess_lang(char *lang)</a>
<a name="ln3562">{</a>
<a name="ln3563">  return lang != NULL &amp;&amp; ASCII_ISALPHA(lang[0]) &amp;&amp; ASCII_ISALPHA(lang[1]);</a>
<a name="ln3564">}</a>
<a name="ln3565"> </a>
<a name="ln3566">/// Obtain the current messages language.  Used to set the default for</a>
<a name="ln3567">/// 'helplang'.  May return NULL or an empty string.</a>
<a name="ln3568">char *get_mess_lang(void)</a>
<a name="ln3569">{</a>
<a name="ln3570">  char *p;</a>
<a name="ln3571"> </a>
<a name="ln3572"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3573">#  if defined(LC_MESSAGES)</a>
<a name="ln3574">  p = get_locale_val(LC_MESSAGES);</a>
<a name="ln3575">#  else</a>
<a name="ln3576">  // This is necessary for Win32, where LC_MESSAGES is not defined and $LANG</a>
<a name="ln3577">  // may be set to the LCID number.  LC_COLLATE is the best guess, LC_TIME</a>
<a name="ln3578">  // and LC_MONETARY may be set differently for a Japanese working in the</a>
<a name="ln3579">  // US.</a>
<a name="ln3580">  p = get_locale_val(LC_COLLATE);</a>
<a name="ln3581">#  endif</a>
<a name="ln3582"># else</a>
<a name="ln3583">  p = os_getenv(&quot;LC_ALL&quot;);</a>
<a name="ln3584">  if (!is_valid_mess_lang(p)) {</a>
<a name="ln3585">    p = os_getenv(&quot;LC_MESSAGES&quot;);</a>
<a name="ln3586">    if (!is_valid_mess_lang(p)) {</a>
<a name="ln3587">      p = os_getenv(&quot;LANG&quot;);</a>
<a name="ln3588">    }</a>
<a name="ln3589">  }</a>
<a name="ln3590"># endif</a>
<a name="ln3591">  return is_valid_mess_lang(p) ? p : NULL;</a>
<a name="ln3592">}</a>
<a name="ln3593"> </a>
<a name="ln3594">// Complicated #if; matches with where get_mess_env() is used below.</a>
<a name="ln3595">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3596">/// Get the language used for messages from the environment.</a>
<a name="ln3597">static char_u *get_mess_env(void)</a>
<a name="ln3598">{</a>
<a name="ln3599">  char_u      *p;</a>
<a name="ln3600"> </a>
<a name="ln3601">  p = (char_u *)os_getenv(&quot;LC_ALL&quot;);</a>
<a name="ln3602">  if (p == NULL) {</a>
<a name="ln3603">    p = (char_u *)os_getenv(&quot;LC_MESSAGES&quot;);</a>
<a name="ln3604">    if (p == NULL) {</a>
<a name="ln3605">      p = (char_u *)os_getenv(&quot;LANG&quot;);</a>
<a name="ln3606">      if (p != NULL &amp;&amp; ascii_isdigit(*p)) {</a>
<a name="ln3607">        p = NULL;                       // ignore something like &quot;1043&quot;</a>
<a name="ln3608">      }</a>
<a name="ln3609"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3610">      if (p == NULL) {</a>
<a name="ln3611">        p = (char_u *)get_locale_val(LC_CTYPE);</a>
<a name="ln3612">      }</a>
<a name="ln3613"># endif</a>
<a name="ln3614">    }</a>
<a name="ln3615">  }</a>
<a name="ln3616">  return p;</a>
<a name="ln3617">}</a>
<a name="ln3618"> </a>
<a name="ln3619">#endif</a>
<a name="ln3620"> </a>
<a name="ln3621"> </a>
<a name="ln3622">/// Set the &quot;v:lang&quot; variable according to the current locale setting.</a>
<a name="ln3623">/// Also do &quot;v:lc_time&quot;and &quot;v:ctype&quot;.</a>
<a name="ln3624">void set_lang_var(void)</a>
<a name="ln3625">{</a>
<a name="ln3626">  const char *loc;</a>
<a name="ln3627"> </a>
<a name="ln3628"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3629">  loc = get_locale_val(LC_CTYPE);</a>
<a name="ln3630"># else</a>
<a name="ln3631">  // setlocale() not supported: use the default value</a>
<a name="ln3632">  loc = &quot;C&quot;;</a>
<a name="ln3633"># endif</a>
<a name="ln3634">  set_vim_var_string(VV_CTYPE, loc, -1);</a>
<a name="ln3635"> </a>
<a name="ln3636">  // When LC_MESSAGES isn't defined use the value from $LC_MESSAGES, fall</a>
<a name="ln3637">  // back to LC_CTYPE if it's empty.</a>
<a name="ln3638"># ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3639">  loc = (char *)get_mess_env();</a>
<a name="ln3640"># elif defined(LC_MESSAGES)</a>
<a name="ln3641">  loc = get_locale_val(LC_MESSAGES);</a>
<a name="ln3642"># else</a>
<a name="ln3643">  // In Windows LC_MESSAGES is not defined fallback to LC_CTYPE</a>
<a name="ln3644">  loc = get_locale_val(LC_CTYPE);</a>
<a name="ln3645"># endif</a>
<a name="ln3646">  set_vim_var_string(VV_LANG, loc, -1);</a>
<a name="ln3647"> </a>
<a name="ln3648"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3649">  loc = get_locale_val(LC_TIME);</a>
<a name="ln3650"># endif</a>
<a name="ln3651">  set_vim_var_string(VV_LC_TIME, loc, -1);</a>
<a name="ln3652"> </a>
<a name="ln3653"># ifdef HAVE_GET_LOCALE_VAL</a>
<a name="ln3654">  loc = get_locale_val(LC_COLLATE);</a>
<a name="ln3655"># else</a>
<a name="ln3656">  // setlocale() not supported: use the default value</a>
<a name="ln3657">  loc = &quot;C&quot;;</a>
<a name="ln3658"># endif</a>
<a name="ln3659">  set_vim_var_string(VV_COLLATE, loc, -1);</a>
<a name="ln3660">}</a>
<a name="ln3661"> </a>
<a name="ln3662">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3663">///</a>
<a name="ln3664">/// &quot;:language&quot;:  Set the language (locale).</a>
<a name="ln3665">///</a>
<a name="ln3666">/// @param eap</a>
<a name="ln3667">///</a>
<a name="ln3668">void ex_language(exarg_T *eap)</a>
<a name="ln3669">{</a>
<a name="ln3670">  char        *loc;</a>
<a name="ln3671">  char_u      *p;</a>
<a name="ln3672">  char_u      *name;</a>
<a name="ln3673">  int what = LC_ALL;</a>
<a name="ln3674">  char        *whatstr = &quot;&quot;;</a>
<a name="ln3675">#ifdef LC_MESSAGES</a>
<a name="ln3676"># define VIM_LC_MESSAGES LC_MESSAGES</a>
<a name="ln3677">#else</a>
<a name="ln3678"># define VIM_LC_MESSAGES 6789</a>
<a name="ln3679">#endif</a>
<a name="ln3680"> </a>
<a name="ln3681">  name = eap-&gt;arg;</a>
<a name="ln3682"> </a>
<a name="ln3683">  // Check for &quot;messages {name}&quot;, &quot;ctype {name}&quot; or &quot;time {name}&quot; argument.</a>
<a name="ln3684">  // Allow abbreviation, but require at least 3 characters to avoid</a>
<a name="ln3685">  // confusion with a two letter language name &quot;me&quot; or &quot;ct&quot;.</a>
<a name="ln3686">  p = skiptowhite(eap-&gt;arg);</a>
<a name="ln3687">  if ((*p == NUL || ascii_iswhite(*p)) &amp;&amp; p - eap-&gt;arg &gt;= 3) {</a>
<a name="ln3688">    if (STRNICMP(eap-&gt;arg, &quot;messages&quot;, p - eap-&gt;arg) == 0) {</a>
<a name="ln3689">      what = VIM_LC_MESSAGES;</a>
<a name="ln3690">      name = skipwhite(p);</a>
<a name="ln3691">      whatstr = &quot;messages &quot;;</a>
<a name="ln3692">    } else if (STRNICMP(eap-&gt;arg, &quot;ctype&quot;, p - eap-&gt;arg) == 0) {</a>
<a name="ln3693">      what = LC_CTYPE;</a>
<a name="ln3694">      name = skipwhite(p);</a>
<a name="ln3695">      whatstr = &quot;ctype &quot;;</a>
<a name="ln3696">    } else if (STRNICMP(eap-&gt;arg, &quot;time&quot;, p - eap-&gt;arg) == 0) {</a>
<a name="ln3697">      what = LC_TIME;</a>
<a name="ln3698">      name = skipwhite(p);</a>
<a name="ln3699">      whatstr = &quot;time &quot;;</a>
<a name="ln3700">    } else if (STRNICMP(eap-&gt;arg, &quot;collate&quot;, p - eap-&gt;arg) == 0) {</a>
<a name="ln3701">      what = LC_COLLATE;</a>
<a name="ln3702">      name = skipwhite(p);</a>
<a name="ln3703">      whatstr = &quot;collate &quot;;</a>
<a name="ln3704">    }</a>
<a name="ln3705">  }</a>
<a name="ln3706"> </a>
<a name="ln3707">  if (*name == NUL) {</a>
<a name="ln3708">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3709">    if (what == VIM_LC_MESSAGES) {</a>
<a name="ln3710">      p = get_mess_env();</a>
<a name="ln3711">    } else {</a>
<a name="ln3712">#endif</a>
<a name="ln3713">      p = (char_u *)setlocale(what, NULL);</a>
<a name="ln3714">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln3715">    }</a>
<a name="ln3716">#endif</a>
<a name="ln3717">    if (p == NULL || *p == NUL) {</a>
<a name="ln3718">      p = (char_u *)&quot;Unknown&quot;;</a>
<a name="ln3719">    }</a>
<a name="ln3720">    smsg(_(&quot;Current %slanguage: \&quot;%s\&quot;&quot;), whatstr, p);</a>
<a name="ln3721">  } else {</a>
<a name="ln3722">#ifndef LC_MESSAGES</a>
<a name="ln3723">    if (what == VIM_LC_MESSAGES) {</a>
<a name="ln3724">      loc = &quot;&quot;;</a>
<a name="ln3725">    } else {</a>
<a name="ln3726">#endif</a>
<a name="ln3727">      loc = setlocale(what, (char *)name);</a>
<a name="ln3728">#ifdef LC_NUMERIC</a>
<a name="ln3729">      // Make sure strtod() uses a decimal point, not a comma.</a>
<a name="ln3730">      setlocale(LC_NUMERIC, &quot;C&quot;);</a>
<a name="ln3731">#endif</a>
<a name="ln3732">#ifndef LC_MESSAGES</a>
<a name="ln3733">    }</a>
<a name="ln3734">#endif</a>
<a name="ln3735">    if (loc == NULL) {</a>
<a name="ln3736">      EMSG2(_(&quot;E197: Cannot set language to \&quot;%s\&quot;&quot;), name);</a>
<a name="ln3737">    } else {</a>
<a name="ln3738">#ifdef HAVE_NL_MSG_CAT_CNTR</a>
<a name="ln3739">      // Need to do this for GNU gettext, otherwise cached translations</a>
<a name="ln3740">      // will be used again.</a>
<a name="ln3741">      extern int _nl_msg_cat_cntr;</a>
<a name="ln3742"> </a>
<a name="ln3743">      _nl_msg_cat_cntr++;</a>
<a name="ln3744">#endif</a>
<a name="ln3745">      // Reset $LC_ALL, otherwise it would overrule everything.</a>
<a name="ln3746">      os_setenv(&quot;LC_ALL&quot;, &quot;&quot;, 1);</a>
<a name="ln3747"> </a>
<a name="ln3748">      if (what != LC_TIME &amp;&amp; what != LC_COLLATE) {</a>
<a name="ln3749">        // Tell gettext() what to translate to.  It apparently doesn't</a>
<a name="ln3750">        // use the currently effective locale.</a>
<a name="ln3751">        if (what == LC_ALL) {</a>
<a name="ln3752">          os_setenv(&quot;LANG&quot;, (char *)name, 1);</a>
<a name="ln3753"> </a>
<a name="ln3754">          // Clear $LANGUAGE because GNU gettext uses it.</a>
<a name="ln3755">          os_setenv(&quot;LANGUAGE&quot;, &quot;&quot;, 1);</a>
<a name="ln3756">        }</a>
<a name="ln3757">        if (what != LC_CTYPE) {</a>
<a name="ln3758">          os_setenv(&quot;LC_MESSAGES&quot;, (char *)name, 1);</a>
<a name="ln3759">          set_helplang_default((char *)name);</a>
<a name="ln3760">        }</a>
<a name="ln3761">      }</a>
<a name="ln3762"> </a>
<a name="ln3763">      // Set v:lang, v:lc_time, v:collate and v:ctype to the final result.</a>
<a name="ln3764">      set_lang_var();</a>
<a name="ln3765">      maketitle();</a>
<a name="ln3766">    }</a>
<a name="ln3767">  }</a>
<a name="ln3768">}</a>
<a name="ln3769"> </a>
<a name="ln3770"> </a>
<a name="ln3771">static char_u **locales = NULL;       // Array of all available locales</a>
<a name="ln3772"> </a>
<a name="ln3773">#ifndef WIN32</a>
<a name="ln3774">static bool did_init_locales = false;</a>
<a name="ln3775"> </a>
<a name="ln3776">/// Return an array of strings for all available locales + NULL for the</a>
<a name="ln3777">/// last element.  Return NULL in case of error.</a>
<a name="ln3778">static char_u **find_locales(void)</a>
<a name="ln3779">{</a>
<a name="ln3780">  garray_T locales_ga;</a>
<a name="ln3781">  char_u      *loc;</a>
<a name="ln3782">  char *saveptr = NULL;</a>
<a name="ln3783"> </a>
<a name="ln3784">  // Find all available locales by running command &quot;locale -a&quot;.  If this</a>
<a name="ln3785">  // doesn't work we won't have completion.</a>
<a name="ln3786">  char_u *locale_a = get_cmd_output((char_u *)&quot;locale -a&quot;, NULL,</a>
<a name="ln3787">                                    kShellOptSilent, NULL);</a>
<a name="ln3788">  if (locale_a == NULL) {</a>
<a name="ln3789">    return NULL;</a>
<a name="ln3790">  }</a>
<a name="ln3791">  ga_init(&amp;locales_ga, sizeof(char_u *), 20);</a>
<a name="ln3792"> </a>
<a name="ln3793">  // Transform locale_a string where each locale is separated by &quot;\n&quot;</a>
<a name="ln3794">  // into an array of locale strings.</a>
<a name="ln3795">  loc = (char_u *)os_strtok((char *)locale_a, &quot;\n&quot;, &amp;saveptr);</a>
<a name="ln3796"> </a>
<a name="ln3797">  while (loc != NULL) {</a>
<a name="ln3798">    loc = vim_strsave(loc);</a>
<a name="ln3799">    GA_APPEND(char_u *, &amp;locales_ga, loc);</a>
<a name="ln3800">    loc = (char_u *)os_strtok(NULL, &quot;\n&quot;, &amp;saveptr);</a>
<a name="ln3801">  }</a>
<a name="ln3802">  xfree(locale_a);</a>
<a name="ln3803">  // Guarantee that .ga_data is NULL terminated</a>
<a name="ln3804">  ga_grow(&amp;locales_ga, 1);</a>
<a name="ln3805">  ((char_u **)locales_ga.ga_data)[locales_ga.ga_len] = NULL;</a>
<a name="ln3806">  return (char_u **)locales_ga.ga_data;</a>
<a name="ln3807">}</a>
<a name="ln3808">#endif</a>
<a name="ln3809"> </a>
<a name="ln3810">/// Lazy initialization of all available locales.</a>
<a name="ln3811">static void init_locales(void)</a>
<a name="ln3812">{</a>
<a name="ln3813">#ifndef WIN32</a>
<a name="ln3814">  if (!did_init_locales) {</a>
<a name="ln3815">    did_init_locales = true;</a>
<a name="ln3816">    locales = find_locales();</a>
<a name="ln3817">  }</a>
<a name="ln3818">#endif</a>
<a name="ln3819">}</a>
<a name="ln3820"> </a>
<a name="ln3821">#  if defined(EXITFREE)</a>
<a name="ln3822">void free_locales(void)</a>
<a name="ln3823">{</a>
<a name="ln3824">  int i;</a>
<a name="ln3825">  if (locales != NULL) {</a>
<a name="ln3826">    for (i = 0; locales[i] != NULL; i++) {</a>
<a name="ln3827">      xfree(locales[i]);</a>
<a name="ln3828">    }</a>
<a name="ln3829">    XFREE_CLEAR(locales);</a>
<a name="ln3830">  }</a>
<a name="ln3831">}</a>
<a name="ln3832"> </a>
<a name="ln3833">#  endif</a>
<a name="ln3834"> </a>
<a name="ln3835">/// Function given to ExpandGeneric() to obtain the possible arguments of the</a>
<a name="ln3836">/// &quot;:language&quot; command.</a>
<a name="ln3837">char_u *get_lang_arg(expand_T *xp, int idx)</a>
<a name="ln3838">{</a>
<a name="ln3839">  if (idx == 0) {</a>
<a name="ln3840">    return (char_u *)&quot;messages&quot;;</a>
<a name="ln3841">  }</a>
<a name="ln3842">  if (idx == 1) {</a>
<a name="ln3843">    return (char_u *)&quot;ctype&quot;;</a>
<a name="ln3844">  }</a>
<a name="ln3845">  if (idx == 2) {</a>
<a name="ln3846">    return (char_u *)&quot;time&quot;;</a>
<a name="ln3847">  }</a>
<a name="ln3848">  if (idx == 3) {</a>
<a name="ln3849">    return (char_u *)&quot;collate&quot;;</a>
<a name="ln3850">  }</a>
<a name="ln3851"> </a>
<a name="ln3852">  init_locales();</a>
<a name="ln3853">  if (locales == NULL) {</a>
<a name="ln3854">    return NULL;</a>
<a name="ln3855">  }</a>
<a name="ln3856">  return locales[idx - 4];</a>
<a name="ln3857">}</a>
<a name="ln3858"> </a>
<a name="ln3859">/// Function given to ExpandGeneric() to obtain the available locales.</a>
<a name="ln3860">char_u *get_locales(expand_T *xp, int idx)</a>
<a name="ln3861">{</a>
<a name="ln3862">  init_locales();</a>
<a name="ln3863">  if (locales == NULL) {</a>
<a name="ln3864">    return NULL;</a>
<a name="ln3865">  }</a>
<a name="ln3866">  return locales[idx];</a>
<a name="ln3867">}</a>
<a name="ln3868"> </a>
<a name="ln3869">#endif</a>
<a name="ln3870"> </a>
<a name="ln3871"> </a>
<a name="ln3872">static void script_host_execute(char *name, exarg_T *eap)</a>
<a name="ln3873">{</a>
<a name="ln3874">  size_t len;</a>
<a name="ln3875">  char *const script = script_get(eap, &amp;len);</a>
<a name="ln3876"> </a>
<a name="ln3877">  if (script != NULL) {</a>
<a name="ln3878">    list_T *const args = tv_list_alloc(3);</a>
<a name="ln3879">    // script</a>
<a name="ln3880">    tv_list_append_allocated_string(args, script);</a>
<a name="ln3881">    // current range</a>
<a name="ln3882">    tv_list_append_number(args, (int)eap-&gt;line1);</a>
<a name="ln3883">    tv_list_append_number(args, (int)eap-&gt;line2);</a>
<a name="ln3884"> </a>
<a name="ln3885">    (void)eval_call_provider(name, &quot;execute&quot;, args, true);</a>
<a name="ln3886">  }</a>
<a name="ln3887">}</a>
<a name="ln3888"> </a>
<a name="ln3889">static void script_host_execute_file(char *name, exarg_T *eap)</a>
<a name="ln3890">{</a>
<a name="ln3891">  if (!eap-&gt;skip) {</a>
<a name="ln3892">    uint8_t buffer[MAXPATHL];</a>
<a name="ln3893">    vim_FullName((char *)eap-&gt;arg, (char *)buffer, sizeof(buffer), false);</a>
<a name="ln3894"> </a>
<a name="ln3895">    list_T *args = tv_list_alloc(3);</a>
<a name="ln3896">    // filename</a>
<a name="ln3897">    tv_list_append_string(args, (const char *)buffer, -1);</a>
<a name="ln3898">    // current range</a>
<a name="ln3899">    tv_list_append_number(args, (int)eap-&gt;line1);</a>
<a name="ln3900">    tv_list_append_number(args, (int)eap-&gt;line2);</a>
<a name="ln3901">    (void)eval_call_provider(name, &quot;execute_file&quot;, args, true);</a>
<a name="ln3902">  }</a>
<a name="ln3903">}</a>
<a name="ln3904"> </a>
<a name="ln3905">static void script_host_do_range(char *name, exarg_T *eap)</a>
<a name="ln3906">{</a>
<a name="ln3907">  if (!eap-&gt;skip) {</a>
<a name="ln3908">    list_T *args = tv_list_alloc(3);</a>
<a name="ln3909">    tv_list_append_number(args, (int)eap-&gt;line1);</a>
<a name="ln3910">    tv_list_append_number(args, (int)eap-&gt;line2);</a>
<a name="ln3911">    tv_list_append_string(args, (const char *)eap-&gt;arg, -1);</a>
<a name="ln3912">    (void)eval_call_provider(name, &quot;do_range&quot;, args, true);</a>
<a name="ln3913">  }</a>
<a name="ln3914">}</a>
<a name="ln3915"> </a>
<a name="ln3916">/// &quot;:drop&quot;</a>
<a name="ln3917">/// Opens the first argument in a window.  When there are two or more arguments</a>
<a name="ln3918">/// the argument list is redefined.</a>
<a name="ln3919">void ex_drop(exarg_T   *eap)</a>
<a name="ln3920">{</a>
<a name="ln3921">  bool split = false;</a>
<a name="ln3922">  buf_T *buf;</a>
<a name="ln3923"> </a>
<a name="ln3924">  // Check if the first argument is already being edited in a window.  If</a>
<a name="ln3925">  // so, jump to that window.</a>
<a name="ln3926">  // We would actually need to check all arguments, but that's complicated</a>
<a name="ln3927">  // and mostly only one file is dropped.</a>
<a name="ln3928">  // This also ignores wildcards, since it is very unlikely the user is</a>
<a name="ln3929">  // editing a file name with a wildcard character.</a>
<a name="ln3930">  do_arglist(eap-&gt;arg, AL_SET, 0, false);</a>
<a name="ln3931"> </a>
<a name="ln3932">  // Expanding wildcards may result in an empty argument list.  E.g. when</a>
<a name="ln3933">  // editing &quot;foo.pyc&quot; and &quot;.pyc&quot; is in 'wildignore'.  Assume that we</a>
<a name="ln3934">  // already did an error message for this.</a>
<a name="ln3935">  if (ARGCOUNT == 0) {</a>
<a name="ln3936">    return;</a>
<a name="ln3937">  }</a>
<a name="ln3938"> </a>
<a name="ln3939">  if (cmdmod.tab) {</a>
<a name="ln3940">    // &quot;:tab drop file ...&quot;: open a tab for each argument that isn't</a>
<a name="ln3941">    // edited in a window yet.  It's like &quot;:tab all&quot; but without closing</a>
<a name="ln3942">    // windows or tabs.</a>
<a name="ln3943">    ex_all(eap);</a>
<a name="ln3944">  } else {</a>
<a name="ln3945">    // &quot;:drop file ...&quot;: Edit the first argument.  Jump to an existing</a>
<a name="ln3946">    // window if possible, edit in current window if the current buffer</a>
<a name="ln3947">    // can be abandoned, otherwise open a new window.</a>
<a name="ln3948">    buf = buflist_findnr(ARGLIST[0].ae_fnum);</a>
<a name="ln3949"> </a>
<a name="ln3950">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln3951">      if (wp-&gt;w_buffer == buf) {</a>
<a name="ln3952">        goto_tabpage_win(tp, wp);</a>
<a name="ln3953">        curwin-&gt;w_arg_idx = 0;</a>
<a name="ln3954">        if (!bufIsChanged(curbuf)) {</a>
<a name="ln3955">          const int save_ar = curbuf-&gt;b_p_ar;</a>
<a name="ln3956"> </a>
<a name="ln3957">          // reload the file if it is newer</a>
<a name="ln3958">          curbuf-&gt;b_p_ar = 1;</a>
<a name="ln3959">          buf_check_timestamp(curbuf);</a>
<a name="ln3960">          curbuf-&gt;b_p_ar = save_ar;</a>
<a name="ln3961">        }</a>
<a name="ln3962">        return;</a>
<a name="ln3963">      }</a>
<a name="ln3964">    }</a>
<a name="ln3965"> </a>
<a name="ln3966">    // Check whether the current buffer is changed. If so, we will need</a>
<a name="ln3967">    // to split the current window or data could be lost.</a>
<a name="ln3968">    // Skip the check if the 'hidden' option is set, as in this case the</a>
<a name="ln3969">    // buffer won't be lost.</a>
<a name="ln3970">    if (!buf_hide(curbuf)) {</a>
<a name="ln3971">      emsg_off++;</a>
<a name="ln3972">      split = check_changed(curbuf, CCGD_AW | CCGD_EXCMD);</a>
<a name="ln3973">      emsg_off--;</a>
<a name="ln3974">    }</a>
<a name="ln3975"> </a>
<a name="ln3976">    // Fake a &quot;:sfirst&quot; or &quot;:first&quot; command edit the first argument.</a>
<a name="ln3977">    if (split) {</a>
<a name="ln3978">      eap-&gt;cmdidx = CMD_sfirst;</a>
<a name="ln3979">      eap-&gt;cmd[0] = 's';</a>
<a name="ln3980">    } else {</a>
<a name="ln3981">      eap-&gt;cmdidx = CMD_first;</a>
<a name="ln3982">    }</a>
<a name="ln3983">    ex_rewind(eap);</a>
<a name="ln3984">  }</a>
<a name="ln3985">}</a>

</code></pre>
<div class="balloon" rel="2754"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v507/" target="_blank">V507</a> Pointer to local array 'sourcing_name_buf' is stored outside the scope of this array. Such a pointer will become invalid.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
