
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>option.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// User-settable options. Checklist for adding a new option:</a>
<a name="ln5">// - Put it in options.lua</a>
<a name="ln6">// - For a global option: Add a variable for it in option_defs.h.</a>
<a name="ln7">// - For a buffer or window local option:</a>
<a name="ln8">//   - Add a BV_XX or WV_XX entry to option_defs.h</a>
<a name="ln9">//   - Add a variable to the window or buffer struct in buffer_defs.h.</a>
<a name="ln10">//   - For a window option, add some code to copy_winopt().</a>
<a name="ln11">//   - For a window string option, add code to check_winopt()</a>
<a name="ln12">//     and clear_winopt(). If setting the option needs parsing,</a>
<a name="ln13">//     add some code to didset_window_options().</a>
<a name="ln14">//   - For a buffer option, add some code to buf_copy_options().</a>
<a name="ln15">//   - For a buffer string option, add code to check_buf_options().</a>
<a name="ln16">// - If it's a numeric option, add any necessary bounds checks to</a>
<a name="ln17">//   set_num_option().</a>
<a name="ln18">// - If it's a list of flags, add some code in do_set(), search for WW_ALL.</a>
<a name="ln19">// - When adding an option with expansion (P_EXPAND), but with a different</a>
<a name="ln20">//   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.</a>
<a name="ln21">// - Add documentation! doc/options.txt, and any other related places.</a>
<a name="ln22">// - Add an entry in runtime/optwin.vim.</a>
<a name="ln23"> </a>
<a name="ln24">#define IN_OPTION_C</a>
<a name="ln25">#include &lt;assert.h&gt;</a>
<a name="ln26">#include &lt;inttypes.h&gt;</a>
<a name="ln27">#include &lt;stdbool.h&gt;</a>
<a name="ln28">#include &lt;string.h&gt;</a>
<a name="ln29">#include &lt;stdlib.h&gt;</a>
<a name="ln30">#include &lt;limits.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;nvim/vim.h&quot;</a>
<a name="ln33">#include &quot;nvim/macros.h&quot;</a>
<a name="ln34">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln35">#include &quot;nvim/edit.h&quot;</a>
<a name="ln36">#include &quot;nvim/option.h&quot;</a>
<a name="ln37">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln38">#include &quot;nvim/charset.h&quot;</a>
<a name="ln39">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln40">#include &quot;nvim/diff.h&quot;</a>
<a name="ln41">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln42">#include &quot;nvim/eval.h&quot;</a>
<a name="ln43">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln44">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln45">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln46">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln47">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln48">#include &quot;nvim/fold.h&quot;</a>
<a name="ln49">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln50">#include &quot;nvim/hardcopy.h&quot;</a>
<a name="ln51">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln52">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln53">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln54">#include &quot;nvim/memfile.h&quot;</a>
<a name="ln55">#include &quot;nvim/memline.h&quot;</a>
<a name="ln56">#include &quot;nvim/memory.h&quot;</a>
<a name="ln57">#include &quot;nvim/message.h&quot;</a>
<a name="ln58">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln59">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln60">#include &quot;nvim/keymap.h&quot;</a>
<a name="ln61">#include &quot;nvim/garray.h&quot;</a>
<a name="ln62">#include &quot;nvim/cursor_shape.h&quot;</a>
<a name="ln63">#include &quot;nvim/move.h&quot;</a>
<a name="ln64">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln65">#include &quot;nvim/normal.h&quot;</a>
<a name="ln66">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln67">#include &quot;nvim/path.h&quot;</a>
<a name="ln68">#include &quot;nvim/popupmnu.h&quot;</a>
<a name="ln69">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln70">#include &quot;nvim/ex_session.h&quot;</a>
<a name="ln71">#include &quot;nvim/screen.h&quot;</a>
<a name="ln72">#include &quot;nvim/spell.h&quot;</a>
<a name="ln73">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln74">#include &quot;nvim/strings.h&quot;</a>
<a name="ln75">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln76">#include &quot;nvim/ui.h&quot;</a>
<a name="ln77">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln78">#include &quot;nvim/undo.h&quot;</a>
<a name="ln79">#include &quot;nvim/window.h&quot;</a>
<a name="ln80">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln81">#ifdef WIN32</a>
<a name="ln82"># include &quot;nvim/os/pty_conpty_win.h&quot;</a>
<a name="ln83">#endif</a>
<a name="ln84">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln85">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln86">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln87">#include &quot;nvim/os/lang.h&quot;</a>
<a name="ln88">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln89"> </a>
<a name="ln90">/*</a>
<a name="ln91"> * The options that are local to a window or buffer have &quot;indir&quot; set to one of</a>
<a name="ln92"> * these values.  Special values:</a>
<a name="ln93"> * PV_NONE: global option.</a>
<a name="ln94"> * PV_WIN is added: window-local option</a>
<a name="ln95"> * PV_BUF is added: buffer-local option</a>
<a name="ln96"> * PV_BOTH is added: global option which also has a local value.</a>
<a name="ln97"> */</a>
<a name="ln98">#define PV_BOTH 0x1000</a>
<a name="ln99">#define PV_WIN  0x2000</a>
<a name="ln100">#define PV_BUF  0x4000</a>
<a name="ln101">#define PV_MASK 0x0fff</a>
<a name="ln102">#define OPT_WIN(x)  (idopt_T)(PV_WIN + (int)(x))</a>
<a name="ln103">#define OPT_BUF(x)  (idopt_T)(PV_BUF + (int)(x))</a>
<a name="ln104">#define OPT_BOTH(x) (idopt_T)(PV_BOTH + (int)(x))</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">// WV_ and BV_ values get typecasted to this for the &quot;indir&quot; field</a>
<a name="ln108">typedef enum {</a>
<a name="ln109">  PV_NONE = 0,</a>
<a name="ln110">  PV_MAXVAL = 0xffff      // to avoid warnings for value out of range</a>
<a name="ln111">} idopt_T;</a>
<a name="ln112"> </a>
<a name="ln113">/*</a>
<a name="ln114"> * Options local to a window have a value local to a buffer and global to all</a>
<a name="ln115"> * buffers.  Indicate this by setting &quot;var&quot; to VAR_WIN.</a>
<a name="ln116"> */</a>
<a name="ln117">#define VAR_WIN ((char_u *)-1)</a>
<a name="ln118"> </a>
<a name="ln119">static char *p_term = NULL;</a>
<a name="ln120">static char *p_ttytype = NULL;</a>
<a name="ln121"> </a>
<a name="ln122">/*</a>
<a name="ln123"> * These are the global values for options which are also local to a buffer.</a>
<a name="ln124"> * Only to be used in option.c!</a>
<a name="ln125"> */</a>
<a name="ln126">static int p_ai;</a>
<a name="ln127">static int p_bin;</a>
<a name="ln128">static int p_bomb;</a>
<a name="ln129">static char_u   *p_bh;</a>
<a name="ln130">static char_u   *p_bt;</a>
<a name="ln131">static int p_bl;</a>
<a name="ln132">static long p_channel;</a>
<a name="ln133">static int p_ci;</a>
<a name="ln134">static int p_cin;</a>
<a name="ln135">static char_u   *p_cink;</a>
<a name="ln136">static char_u   *p_cino;</a>
<a name="ln137">static char_u   *p_cinw;</a>
<a name="ln138">static char_u   *p_com;</a>
<a name="ln139">static char_u   *p_cms;</a>
<a name="ln140">static char_u   *p_cpt;</a>
<a name="ln141">static char_u   *p_cfu;</a>
<a name="ln142">static char_u   *p_ofu;</a>
<a name="ln143">static char_u   *p_tfu;</a>
<a name="ln144">static int p_eol;</a>
<a name="ln145">static int p_fixeol;</a>
<a name="ln146">static int p_et;</a>
<a name="ln147">static char_u   *p_fenc;</a>
<a name="ln148">static char_u   *p_ff;</a>
<a name="ln149">static char_u   *p_fo;</a>
<a name="ln150">static char_u   *p_flp;</a>
<a name="ln151">static char_u   *p_ft;</a>
<a name="ln152">static long p_iminsert;</a>
<a name="ln153">static long p_imsearch;</a>
<a name="ln154">static char_u   *p_inex;</a>
<a name="ln155">static char_u   *p_inde;</a>
<a name="ln156">static char_u   *p_indk;</a>
<a name="ln157">static char_u   *p_fex;</a>
<a name="ln158">static int p_inf;</a>
<a name="ln159">static char_u   *p_isk;</a>
<a name="ln160">static int p_lisp;</a>
<a name="ln161">static int p_ml;</a>
<a name="ln162">static int p_ma;</a>
<a name="ln163">static int p_mod;</a>
<a name="ln164">static char_u   *p_mps;</a>
<a name="ln165">static char_u   *p_nf;</a>
<a name="ln166">static int p_pi;</a>
<a name="ln167">static char_u   *p_qe;</a>
<a name="ln168">static int p_ro;</a>
<a name="ln169">static int p_si;</a>
<a name="ln170">static long p_sts;</a>
<a name="ln171">static char_u   *p_sua;</a>
<a name="ln172">static long p_sw;</a>
<a name="ln173">static int p_swf;</a>
<a name="ln174">static long p_smc;</a>
<a name="ln175">static char_u   *p_syn;</a>
<a name="ln176">static char_u   *p_spc;</a>
<a name="ln177">static char_u   *p_spf;</a>
<a name="ln178">static char_u   *p_spl;</a>
<a name="ln179">static char_u   *p_spo;</a>
<a name="ln180">static long p_ts;</a>
<a name="ln181">static long p_tw;</a>
<a name="ln182">static int p_udf;</a>
<a name="ln183">static long p_wm;</a>
<a name="ln184">static char_u *p_vsts;</a>
<a name="ln185">static char_u *p_vts;</a>
<a name="ln186">static char_u   *p_keymap;</a>
<a name="ln187"> </a>
<a name="ln188">// Saved values for when 'bin' is set.</a>
<a name="ln189">static int p_et_nobin;</a>
<a name="ln190">static int p_ml_nobin;</a>
<a name="ln191">static long p_tw_nobin;</a>
<a name="ln192">static long p_wm_nobin;</a>
<a name="ln193"> </a>
<a name="ln194">// Saved values for when 'paste' is set.</a>
<a name="ln195">static int p_ai_nopaste;</a>
<a name="ln196">static int p_et_nopaste;</a>
<a name="ln197">static long p_sts_nopaste;</a>
<a name="ln198">static long p_tw_nopaste;</a>
<a name="ln199">static long p_wm_nopaste;</a>
<a name="ln200">static char_u *p_vsts_nopaste;</a>
<a name="ln201"> </a>
<a name="ln202">typedef struct vimoption {</a>
<a name="ln203">  char        *fullname;        // full option name</a>
<a name="ln204">  char        *shortname;       // permissible abbreviation</a>
<a name="ln205">  uint32_t flags;               // see below</a>
<a name="ln206">  char_u      *var;             // global option: pointer to variable;</a>
<a name="ln207">                                // window-local option: VAR_WIN;</a>
<a name="ln208">                                // buffer-local option: global value</a>
<a name="ln209">  idopt_T indir;                // global option: PV_NONE;</a>
<a name="ln210">                                // local option: indirect option index</a>
<a name="ln211">  char_u      *def_val[2];      // default values for variable (vi and vim)</a>
<a name="ln212">  LastSet last_set;             // script in which the option was last set</a>
<a name="ln213">} vimoption_T;</a>
<a name="ln214"> </a>
<a name="ln215">#define VI_DEFAULT  0       // def_val[VI_DEFAULT] is Vi default value</a>
<a name="ln216">#define VIM_DEFAULT 1       // def_val[VIM_DEFAULT] is Vim default value</a>
<a name="ln217"> </a>
<a name="ln218">/*</a>
<a name="ln219"> * Flags</a>
<a name="ln220"> */</a>
<a name="ln221">#define P_BOOL          0x01U    // the option is boolean</a>
<a name="ln222">#define P_NUM           0x02U    // the option is numeric</a>
<a name="ln223">#define P_STRING        0x04U    // the option is a string</a>
<a name="ln224">#define P_ALLOCED       0x08U    // the string option is in allocated memory,</a>
<a name="ln225">                                 // must use free_string_option() when</a>
<a name="ln226">                                 // assigning new value. Not set if default is</a>
<a name="ln227">                                 // the same.</a>
<a name="ln228">#define P_EXPAND        0x10U    // environment expansion.  NOTE: P_EXPAND can</a>
<a name="ln229">                                 // never be used for local or hidden options</a>
<a name="ln230">#define P_NODEFAULT     0x40U    // don't set to default value</a>
<a name="ln231">#define P_DEF_ALLOCED   0x80U    // default value is in allocated memory, must</a>
<a name="ln232">                                 // use free() when assigning new value</a>
<a name="ln233">#define P_WAS_SET       0x100U   // option has been set/reset</a>
<a name="ln234">#define P_NO_MKRC       0x200U   // don't include in :mkvimrc output</a>
<a name="ln235">#define P_VI_DEF        0x400U   // Use Vi default for Vim</a>
<a name="ln236">#define P_VIM           0x800U   // Vim option</a>
<a name="ln237"> </a>
<a name="ln238">// when option changed, what to display:</a>
<a name="ln239">#define P_RSTAT         0x1000U  ///&lt; redraw status lines</a>
<a name="ln240">#define P_RWIN          0x2000U  ///&lt; redraw current window and recompute text</a>
<a name="ln241">#define P_RBUF          0x4000U  ///&lt; redraw current buffer and recompute text</a>
<a name="ln242">#define P_RALL          0x6000U  ///&lt; redraw all windows</a>
<a name="ln243">#define P_RCLR          0x7000U  ///&lt; clear and redraw all</a>
<a name="ln244"> </a>
<a name="ln245">#define P_COMMA         0x8000U    ///&lt; comma separated list</a>
<a name="ln246">#define P_ONECOMMA      0x18000U   ///&lt; P_COMMA and cannot have two consecutive</a>
<a name="ln247">                                   ///&lt; commas</a>
<a name="ln248">#define P_NODUP         0x20000U   ///&lt; don't allow duplicate strings</a>
<a name="ln249">#define P_FLAGLIST      0x40000U   ///&lt; list of single-char flags</a>
<a name="ln250"> </a>
<a name="ln251">#define P_SECURE        0x80000U   ///&lt; cannot change in modeline or secure mode</a>
<a name="ln252">#define P_GETTEXT       0x100000U  ///&lt; expand default value with _()</a>
<a name="ln253">#define P_NOGLOB        0x200000U  ///&lt; do not use local value for global vimrc</a>
<a name="ln254">#define P_NFNAME        0x400000U  ///&lt; only normal file name chars allowed</a>
<a name="ln255">#define P_INSECURE      0x800000U  ///&lt; option was set from a modeline</a>
<a name="ln256">#define P_PRI_MKRC     0x1000000U  ///&lt; priority for :mkvimrc (setting option</a>
<a name="ln257">                                   ///&lt; has side effects)</a>
<a name="ln258">#define P_NO_ML        0x2000000U  ///&lt; not allowed in modeline</a>
<a name="ln259">#define P_CURSWANT     0x4000000U  ///&lt; update curswant required; not needed</a>
<a name="ln260">                                   ///&lt; when there is a redraw flag</a>
<a name="ln261">#define P_NO_DEF_EXP   0x8000000U  ///&lt; Do not expand default value.</a>
<a name="ln262"> </a>
<a name="ln263">#define P_RWINONLY     0x10000000U  ///&lt; only redraw current window</a>
<a name="ln264">#define P_NDNAME       0x20000000U  ///&lt; only normal dir name chars allowed</a>
<a name="ln265">#define P_UI_OPTION    0x40000000U  ///&lt; send option to remote ui</a>
<a name="ln266">#define P_MLE          0x80000000U  ///&lt; under control of 'modelineexpr'</a>
<a name="ln267"> </a>
<a name="ln268">#define HIGHLIGHT_INIT \</a>
<a name="ln269">  &quot;8:SpecialKey,~:EndOfBuffer,z:TermCursor,Z:TermCursorNC,@:NonText,&quot; \</a>
<a name="ln270">  &quot;d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,&quot; \</a>
<a name="ln271">  &quot;N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,&quot; \</a>
<a name="ln272">  &quot;v:Visual,V:VisualNOS,w:WarningMsg,W:WildMenu,f:Folded,F:FoldColumn,&quot; \</a>
<a name="ln273">  &quot;A:DiffAdd,C:DiffChange,D:DiffDelete,T:DiffText,&gt;:SignColumn,-:Conceal,&quot; \</a>
<a name="ln274">  &quot;B:SpellBad,P:SpellCap,R:SpellRare,L:SpellLocal,+:Pmenu,=:PmenuSel,&quot; \</a>
<a name="ln275">  &quot;x:PmenuSbar,X:PmenuThumb,*:TabLine,#:TabLineSel,_:TabLineFill,&quot; \</a>
<a name="ln276">  &quot;!:CursorColumn,.:CursorLine,o:ColorColumn,q:QuickFixLine,&quot; \</a>
<a name="ln277">  &quot;0:Whitespace,I:NormalNC&quot;</a>
<a name="ln278"> </a>
<a name="ln279">/*</a>
<a name="ln280"> * options[] is initialized here.</a>
<a name="ln281"> * The order of the options MUST be alphabetic for &quot;:set all&quot; and findoption().</a>
<a name="ln282"> * All option names MUST start with a lowercase letter (for findoption()).</a>
<a name="ln283"> * Exception: &quot;t_&quot; options are at the end.</a>
<a name="ln284"> * The options with a NULL variable are 'hidden': a set command for them is</a>
<a name="ln285"> * ignored and they are not printed.</a>
<a name="ln286"> */</a>
<a name="ln287"> </a>
<a name="ln288">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln289"># include &quot;options.generated.h&quot;</a>
<a name="ln290">#endif</a>
<a name="ln291"> </a>
<a name="ln292">#define PARAM_COUNT ARRAY_SIZE(options)</a>
<a name="ln293"> </a>
<a name="ln294">static char *(p_ambw_values[]) =      { &quot;single&quot;, &quot;double&quot;, NULL };</a>
<a name="ln295">static char *(p_bg_values[]) =        { &quot;light&quot;, &quot;dark&quot;, NULL };</a>
<a name="ln296">static char *(p_nf_values[]) =        { &quot;bin&quot;, &quot;octal&quot;, &quot;hex&quot;, &quot;alpha&quot;,</a>
<a name="ln297">                                        &quot;unsigned&quot;, NULL };</a>
<a name="ln298">static char *(p_ff_values[]) =        { FF_UNIX, FF_DOS, FF_MAC, NULL };</a>
<a name="ln299">static char *(p_wak_values[]) =       { &quot;yes&quot;, &quot;menu&quot;, &quot;no&quot;, NULL };</a>
<a name="ln300">static char *(p_mousem_values[]) =    { &quot;extend&quot;, &quot;popup&quot;, &quot;popup_setpos&quot;,</a>
<a name="ln301">                                        &quot;mac&quot;, NULL };</a>
<a name="ln302">static char *(p_sel_values[]) =       { &quot;inclusive&quot;, &quot;exclusive&quot;, &quot;old&quot;, NULL };</a>
<a name="ln303">static char *(p_slm_values[]) =       { &quot;mouse&quot;, &quot;key&quot;, &quot;cmd&quot;, NULL };</a>
<a name="ln304">static char *(p_km_values[]) =        { &quot;startsel&quot;, &quot;stopsel&quot;, NULL };</a>
<a name="ln305">static char *(p_scbopt_values[]) =    { &quot;ver&quot;, &quot;hor&quot;, &quot;jump&quot;, NULL };</a>
<a name="ln306">static char *(p_debug_values[]) =     { &quot;msg&quot;, &quot;throw&quot;, &quot;beep&quot;, NULL };</a>
<a name="ln307">static char *(p_ead_values[]) =       { &quot;both&quot;, &quot;ver&quot;, &quot;hor&quot;, NULL };</a>
<a name="ln308">static char *(p_buftype_values[]) =   { &quot;nofile&quot;, &quot;nowrite&quot;, &quot;quickfix&quot;,</a>
<a name="ln309">                                        &quot;help&quot;, &quot;acwrite&quot;, &quot;terminal&quot;,</a>
<a name="ln310">                                        &quot;prompt&quot;, NULL };</a>
<a name="ln311"> </a>
<a name="ln312">static char *(p_bufhidden_values[]) = { &quot;hide&quot;, &quot;unload&quot;, &quot;delete&quot;,</a>
<a name="ln313">                                        &quot;wipe&quot;, NULL };</a>
<a name="ln314">static char *(p_bs_values[]) = { &quot;indent&quot;, &quot;eol&quot;, &quot;start&quot;, &quot;nostop&quot;, NULL };</a>
<a name="ln315">static char *(p_fdm_values[]) =       { &quot;manual&quot;, &quot;expr&quot;, &quot;marker&quot;, &quot;indent&quot;,</a>
<a name="ln316">                                        &quot;syntax&quot;,  &quot;diff&quot;, NULL };</a>
<a name="ln317">static char *(p_fcl_values[]) =       { &quot;all&quot;, NULL };</a>
<a name="ln318">static char *(p_cot_values[]) =       { &quot;menu&quot;, &quot;menuone&quot;, &quot;longest&quot;, &quot;preview&quot;,</a>
<a name="ln319">                                        &quot;noinsert&quot;, &quot;noselect&quot;, NULL };</a>
<a name="ln320">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln321">static char *(p_csl_values[]) =       { &quot;slash&quot;, &quot;backslash&quot;, NULL };</a>
<a name="ln322">#endif</a>
<a name="ln323">static char *(p_icm_values[]) =       { &quot;nosplit&quot;, &quot;split&quot;, NULL };</a>
<a name="ln324">static char *(p_scl_values[]) =       { &quot;yes&quot;, &quot;no&quot;, &quot;auto&quot;, &quot;auto:1&quot;, &quot;auto:2&quot;,</a>
<a name="ln325">  &quot;auto:3&quot;, &quot;auto:4&quot;, &quot;auto:5&quot;, &quot;auto:6&quot;, &quot;auto:7&quot;, &quot;auto:8&quot;, &quot;auto:9&quot;,</a>
<a name="ln326">  &quot;yes:1&quot;, &quot;yes:2&quot;, &quot;yes:3&quot;, &quot;yes:4&quot;, &quot;yes:5&quot;, &quot;yes:6&quot;, &quot;yes:7&quot;, &quot;yes:8&quot;,</a>
<a name="ln327">  &quot;yes:9&quot;, &quot;number&quot;, NULL };</a>
<a name="ln328">static char *(p_fdc_values[]) =       { &quot;auto&quot;, &quot;auto:1&quot;, &quot;auto:2&quot;,</a>
<a name="ln329">  &quot;auto:3&quot;, &quot;auto:4&quot;, &quot;auto:5&quot;, &quot;auto:6&quot;, &quot;auto:7&quot;, &quot;auto:8&quot;, &quot;auto:9&quot;,</a>
<a name="ln330">  &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, NULL };</a>
<a name="ln331"> </a>
<a name="ln332">/// All possible flags for 'shm'.</a>
<a name="ln333">static char_u SHM_ALL[] = {</a>
<a name="ln334">  SHM_RO, SHM_MOD, SHM_FILE, SHM_LAST, SHM_TEXT, SHM_LINES, SHM_NEW, SHM_WRI,</a>
<a name="ln335">  SHM_ABBREVIATIONS, SHM_WRITE, SHM_TRUNC, SHM_TRUNCALL, SHM_OVER,</a>
<a name="ln336">  SHM_OVERALL, SHM_SEARCH, SHM_ATTENTION, SHM_INTRO, SHM_COMPLETIONMENU,</a>
<a name="ln337">  SHM_RECORDING, SHM_FILEINFO, SHM_SEARCHCOUNT,</a>
<a name="ln338">  0,</a>
<a name="ln339">};</a>
<a name="ln340"> </a>
<a name="ln341">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln342"># include &quot;option.c.generated.h&quot;</a>
<a name="ln343">#endif</a>
<a name="ln344"> </a>
<a name="ln345">/// Initialize the options, first part.</a>
<a name="ln346">///</a>
<a name="ln347">/// Called only once from main(), just after creating the first buffer.</a>
<a name="ln348">/// If &quot;clean_arg&quot; is true, Nvim was started with --clean.</a>
<a name="ln349">///</a>
<a name="ln350">/// NOTE: ELOG() etc calls are not allowed here, as log location depends on</a>
<a name="ln351">/// env var expansion which depends on expression evaluation and other</a>
<a name="ln352">/// editor state initialized here. Do logging in set_init_2 or later.</a>
<a name="ln353">void set_init_1(bool clean_arg)</a>
<a name="ln354">{</a>
<a name="ln355">  int opt_idx;</a>
<a name="ln356"> </a>
<a name="ln357">  langmap_init();</a>
<a name="ln358"> </a>
<a name="ln359">  /*</a>
<a name="ln360">   * Find default value for 'shell' option.</a>
<a name="ln361">   * Don't use it if it is empty.</a>
<a name="ln362">   */</a>
<a name="ln363">  {</a>
<a name="ln364">    const char *shell = os_getenv(&quot;SHELL&quot;);</a>
<a name="ln365">    if (shell != NULL) {</a>
<a name="ln366">      if (vim_strchr((const char_u *)shell, ' ') != NULL) {</a>
<a name="ln367">        const size_t len = strlen(shell) + 3;  // two quotes and a trailing NUL</a>
<a name="ln368">        char *const cmd = xmalloc(len);</a>
<a name="ln369">        snprintf(cmd, len, &quot;\&quot;%s\&quot;&quot;, shell);</a>
<a name="ln370">        set_string_default(&quot;sh&quot;, cmd, true);</a>
<a name="ln371">      } else {</a>
<a name="ln372">        set_string_default(&quot;sh&quot;, (char *)shell, false);</a>
<a name="ln373">      }</a>
<a name="ln374">    }</a>
<a name="ln375">  }</a>
<a name="ln376"> </a>
<a name="ln377">  /*</a>
<a name="ln378">   * Set the default for 'backupskip' to include environment variables for</a>
<a name="ln379">   * temp files.</a>
<a name="ln380">   */</a>
<a name="ln381">  {</a>
<a name="ln382"># ifdef UNIX</a>
<a name="ln383">    static char     *(names[4]) = {&quot;&quot;, &quot;TMPDIR&quot;, &quot;TEMP&quot;, &quot;TMP&quot;};</a>
<a name="ln384"># else</a>
<a name="ln385">    static char     *(names[3]) = {&quot;TMPDIR&quot;, &quot;TEMP&quot;, &quot;TMP&quot;};</a>
<a name="ln386"># endif</a>
<a name="ln387">    garray_T ga;</a>
<a name="ln388">    opt_idx = findoption(&quot;backupskip&quot;);</a>
<a name="ln389"> </a>
<a name="ln390">    ga_init(&amp;ga, 1, 100);</a>
<a name="ln391">    for (size_t n = 0; n &lt; ARRAY_SIZE(names); n++) {</a>
<a name="ln392">      bool mustfree = true;</a>
<a name="ln393">      char *p;</a>
<a name="ln394"># ifdef UNIX</a>
<a name="ln395">      if (*names[n] == NUL) {</a>
<a name="ln396">#  ifdef __APPLE__</a>
<a name="ln397">        p = &quot;/private/tmp&quot;;</a>
<a name="ln398">#  else</a>
<a name="ln399">        p = &quot;/tmp&quot;;</a>
<a name="ln400">#  endif</a>
<a name="ln401">        mustfree = false;</a>
<a name="ln402">      } else</a>
<a name="ln403"># endif</a>
<a name="ln404">      {</a>
<a name="ln405">        p = vim_getenv(names[n]);</a>
<a name="ln406">      }</a>
<a name="ln407">      if (p != NULL &amp;&amp; *p != NUL) {</a>
<a name="ln408">        // First time count the NUL, otherwise count the ','.</a>
<a name="ln409">        const size_t len = strlen(p) + 3;</a>
<a name="ln410">        char *item = xmalloc(len);</a>
<a name="ln411">        xstrlcpy(item, p, len);</a>
<a name="ln412">        add_pathsep(item);</a>
<a name="ln413">        xstrlcat(item, &quot;*&quot;, len);</a>
<a name="ln414">        if (find_dup_item(ga.ga_data, (char_u *)item, options[opt_idx].flags)</a>
<a name="ln415">            == NULL) {</a>
<a name="ln416">          ga_grow(&amp;ga, (int)len);</a>
<a name="ln417">          if (!GA_EMPTY(&amp;ga)) {</a>
<a name="ln418">            STRCAT(ga.ga_data, &quot;,&quot;);</a>
<a name="ln419">          }</a>
<a name="ln420">          STRCAT(ga.ga_data, p);</a>
<a name="ln421">          add_pathsep(ga.ga_data);</a>
<a name="ln422">          STRCAT(ga.ga_data, &quot;*&quot;);</a>
<a name="ln423">          ga.ga_len += (int)len;</a>
<a name="ln424">        }</a>
<a name="ln425">        xfree(item);</a>
<a name="ln426">      }</a>
<a name="ln427">      if(mustfree) {</a>
<a name="ln428">        xfree(p);</a>
<a name="ln429">      }</a>
<a name="ln430">    }</a>
<a name="ln431">    if (ga.ga_data != NULL) {</a>
<a name="ln432">      set_string_default(&quot;bsk&quot;, ga.ga_data, true);</a>
<a name="ln433">    }</a>
<a name="ln434">  }</a>
<a name="ln435"> </a>
<a name="ln436">  {</a>
<a name="ln437">    char_u  *cdpath;</a>
<a name="ln438">    char_u  *buf;</a>
<a name="ln439">    int i;</a>
<a name="ln440">    int j;</a>
<a name="ln441"> </a>
<a name="ln442">    // Initialize the 'cdpath' option's default value.</a>
<a name="ln443">    cdpath = (char_u *)vim_getenv(&quot;CDPATH&quot;);</a>
<a name="ln444">    if (cdpath != NULL) {</a>
<a name="ln445">      buf = xmalloc(2 * STRLEN(cdpath) + 2);</a>
<a name="ln446">      {</a>
<a name="ln447">        buf[0] = ',';               // start with &quot;,&quot;, current dir first</a>
<a name="ln448">        j = 1;</a>
<a name="ln449">        for (i = 0; cdpath[i] != NUL; i++) {</a>
<a name="ln450">          if (vim_ispathlistsep(cdpath[i])) {</a>
<a name="ln451">            buf[j++] = ',';</a>
<a name="ln452">          } else {</a>
<a name="ln453">            if (cdpath[i] == ' ' || cdpath[i] == ',') {</a>
<a name="ln454">              buf[j++] = '\\';</a>
<a name="ln455">            }</a>
<a name="ln456">            buf[j++] = cdpath[i];</a>
<a name="ln457">          }</a>
<a name="ln458">        }</a>
<a name="ln459">        buf[j] = NUL;</a>
<a name="ln460">        opt_idx = findoption(&quot;cdpath&quot;);</a>
<a name="ln461">        if (opt_idx &gt;= 0) {</a>
<a name="ln462">          options[opt_idx].def_val[VI_DEFAULT] = buf;</a>
<a name="ln463">          options[opt_idx].flags |= P_DEF_ALLOCED;</a>
<a name="ln464">        } else {</a>
<a name="ln465">          xfree(buf);           // cannot happen</a>
<a name="ln466">        }</a>
<a name="ln467">      }</a>
<a name="ln468">      xfree(cdpath);</a>
<a name="ln469">    }</a>
<a name="ln470">  }</a>
<a name="ln471"> </a>
<a name="ln472">#if defined(MSWIN) || defined(MAC)</a>
<a name="ln473">  // Set print encoding on platforms that don't default to latin1</a>
<a name="ln474">  set_string_default(&quot;printencoding&quot;, &quot;hp-roman8&quot;, false);</a>
<a name="ln475">#endif</a>
<a name="ln476"> </a>
<a name="ln477">  // 'printexpr' must be allocated to be able to evaluate it.</a>
<a name="ln478">  set_string_default(&quot;printexpr&quot;,</a>
<a name="ln479">#ifdef UNIX</a>
<a name="ln480">                     &quot;system(['lpr'] &quot;</a>
<a name="ln481">                            &quot;+ (empty(&amp;printdevice)?[]:['-P', &amp;printdevice]) &quot;</a>
<a name="ln482">                            &quot;+ [v:fname_in])&quot;</a>
<a name="ln483">                     &quot;. delete(v:fname_in)&quot;</a>
<a name="ln484">                     &quot;+ v:shell_error&quot;,</a>
<a name="ln485">#elif defined(MSWIN)</a>
<a name="ln486">                     &quot;system(['copy', v:fname_in, &quot;</a>
<a name="ln487">                             &quot;empty(&amp;printdevice)?'LPT1':&amp;printdevice])&quot;</a>
<a name="ln488">                     &quot;. delete(v:fname_in)&quot;,</a>
<a name="ln489">#else</a>
<a name="ln490">                     &quot;&quot;,</a>
<a name="ln491">#endif</a>
<a name="ln492">                     false);</a>
<a name="ln493"> </a>
<a name="ln494">  char *backupdir = stdpaths_user_data_subpath(&quot;backup&quot;, 0, true);</a>
<a name="ln495">  const size_t backupdir_len = strlen(backupdir);</a>
<a name="ln496">  backupdir = xrealloc(backupdir, backupdir_len + 3);</a>
<a name="ln497">  memmove(backupdir + 2, backupdir, backupdir_len + 1);</a>
<a name="ln498">  memmove(backupdir, &quot;.,&quot;, 2);</a>
<a name="ln499">  set_string_default(&quot;viewdir&quot;, stdpaths_user_data_subpath(&quot;view&quot;, 0, true),</a>
<a name="ln500">                     true);</a>
<a name="ln501">  set_string_default(&quot;backupdir&quot;, backupdir, true);</a>
<a name="ln502">  set_string_default(&quot;directory&quot;, stdpaths_user_data_subpath(&quot;swap&quot;, 2, true),</a>
<a name="ln503">                     true);</a>
<a name="ln504">  set_string_default(&quot;undodir&quot;, stdpaths_user_data_subpath(&quot;undo&quot;, 0, true),</a>
<a name="ln505">                     true);</a>
<a name="ln506">  // Set default for &amp;runtimepath. All necessary expansions are performed in</a>
<a name="ln507">  // this function.</a>
<a name="ln508">  char *rtp = runtimepath_default(clean_arg);</a>
<a name="ln509">  if (rtp) {</a>
<a name="ln510">    set_string_default(&quot;runtimepath&quot;, rtp, true);</a>
<a name="ln511">    // Make a copy of 'rtp' for 'packpath'</a>
<a name="ln512">    set_string_default(&quot;packpath&quot;, rtp, false);</a>
<a name="ln513">    rtp = NULL;  // ownership taken</a>
<a name="ln514">  }</a>
<a name="ln515"> </a>
<a name="ln516">  /*</a>
<a name="ln517">   * Set all the options (except the terminal options) to their default</a>
<a name="ln518">   * value.  Also set the global value for local options.</a>
<a name="ln519">   */</a>
<a name="ln520">  set_options_default(0);</a>
<a name="ln521"> </a>
<a name="ln522"> </a>
<a name="ln523">  curbuf-&gt;b_p_initialized = true;</a>
<a name="ln524">  curbuf-&gt;b_p_ar = -1;          // no local 'autoread' value</a>
<a name="ln525">  curbuf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln526">  check_buf_options(curbuf);</a>
<a name="ln527">  check_win_options(curwin);</a>
<a name="ln528">  check_options();</a>
<a name="ln529"> </a>
<a name="ln530">  // Set all options to their Vim default</a>
<a name="ln531">  set_options_default(OPT_FREE);</a>
<a name="ln532"> </a>
<a name="ln533">  // set 'laststatus'</a>
<a name="ln534">  last_status(false);</a>
<a name="ln535"> </a>
<a name="ln536">  // Must be before option_expand(), because that one needs vim_isIDc()</a>
<a name="ln537">  didset_options();</a>
<a name="ln538"> </a>
<a name="ln539">  // Use the current chartab for the generic chartab. This is not in</a>
<a name="ln540">  // didset_options() because it only depends on 'encoding'.</a>
<a name="ln541">  init_spell_chartab();</a>
<a name="ln542"> </a>
<a name="ln543">  /*</a>
<a name="ln544">   * Expand environment variables and things like &quot;~&quot; for the defaults.</a>
<a name="ln545">   * If option_expand() returns non-NULL the variable is expanded.  This can</a>
<a name="ln546">   * only happen for non-indirect options.</a>
<a name="ln547">   * Also set the default to the expanded value, so &quot;:set&quot; does not list</a>
<a name="ln548">   * them.</a>
<a name="ln549">   * Don't set the P_ALLOCED flag, because we don't want to free the</a>
<a name="ln550">   * default.</a>
<a name="ln551">   */</a>
<a name="ln552">  for (opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln553">    if (options[opt_idx].flags &amp; P_NO_DEF_EXP) {</a>
<a name="ln554">      continue;</a>
<a name="ln555">    }</a>
<a name="ln556">    char *p;</a>
<a name="ln557">    if ((options[opt_idx].flags &amp; P_GETTEXT)</a>
<a name="ln558">        &amp;&amp; options[opt_idx].var != NULL) {</a>
<a name="ln559">      p = _(*(char **)options[opt_idx].var);</a>
<a name="ln560">    } else {</a>
<a name="ln561">      p = (char *) option_expand(opt_idx, NULL);</a>
<a name="ln562">    }</a>
<a name="ln563">    if (p != NULL) {</a>
<a name="ln564">      p = xstrdup(p);</a>
<a name="ln565">      *(char **)options[opt_idx].var = p;</a>
<a name="ln566">      /* VIMEXP</a>
<a name="ln567">       * Defaults for all expanded options are currently the same for Vi</a>
<a name="ln568">       * and Vim.  When this changes, add some code here!  Also need to</a>
<a name="ln569">       * split P_DEF_ALLOCED in two.</a>
<a name="ln570">       */</a>
<a name="ln571">      if (options[opt_idx].flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln572">        xfree(options[opt_idx].def_val[VI_DEFAULT]);</a>
<a name="ln573">      }</a>
<a name="ln574">      options[opt_idx].def_val[VI_DEFAULT] = (char_u *)p;</a>
<a name="ln575">      options[opt_idx].flags |= P_DEF_ALLOCED;</a>
<a name="ln576">    }</a>
<a name="ln577">  }</a>
<a name="ln578"> </a>
<a name="ln579">  save_file_ff(curbuf);         // Buffer is unchanged</a>
<a name="ln580"> </a>
<a name="ln581">  /* Detect use of mlterm.</a>
<a name="ln582">   * Mlterm is a terminal emulator akin to xterm that has some special</a>
<a name="ln583">   * abilities (bidi namely).</a>
<a name="ln584">   * NOTE: mlterm's author is being asked to 'set' a variable</a>
<a name="ln585">   *       instead of an environment variable due to inheritance.</a>
<a name="ln586">   */</a>
<a name="ln587">  if (os_env_exists(&quot;MLTERM&quot;)) {</a>
<a name="ln588">    set_option_value(&quot;tbidi&quot;, 1L, NULL, 0);</a>
<a name="ln589">  }</a>
<a name="ln590"> </a>
<a name="ln591">  didset_options2();</a>
<a name="ln592"> </a>
<a name="ln593">  lang_init();</a>
<a name="ln594"> </a>
<a name="ln595">  // enc_locale() will try to find the encoding of the current locale.</a>
<a name="ln596">  // This will be used when 'default' is used as encoding specifier</a>
<a name="ln597">  // in 'fileencodings'</a>
<a name="ln598">  char_u *p = enc_locale();</a>
<a name="ln599">  if (p == NULL) {</a>
<a name="ln600">      // use utf-8 as 'default' if locale encoding can't be detected.</a>
<a name="ln601">      p = (char_u *)xmemdupz(S_LEN(&quot;utf-8&quot;));</a>
<a name="ln602">  }</a>
<a name="ln603">  fenc_default = p;</a>
<a name="ln604"> </a>
<a name="ln605">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln606">  // GNU gettext 0.10.37 supports this feature: set the codeset used for</a>
<a name="ln607">  // translated messages independently from the current locale.</a>
<a name="ln608">  (void)bind_textdomain_codeset(PROJECT_NAME, (char *)p_enc);</a>
<a name="ln609">#endif</a>
<a name="ln610"> </a>
<a name="ln611">  // Set the default for 'helplang'.</a>
<a name="ln612">  set_helplang_default(get_mess_lang());</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615">/// Set an option to its default value.</a>
<a name="ln616">/// This does not take care of side effects!</a>
<a name="ln617">static void</a>
<a name="ln618">set_option_default(</a>
<a name="ln619">    int opt_idx,</a>
<a name="ln620">    int opt_flags,              // OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln621">    int compatible              // use Vi default value</a>
<a name="ln622">)</a>
<a name="ln623">{</a>
<a name="ln624">  char_u      *varp;            // pointer to variable for current option</a>
<a name="ln625">  int dvi;                      // index in def_val[]</a>
<a name="ln626">  int both = (opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0;</a>
<a name="ln627"> </a>
<a name="ln628">  varp = get_varp_scope(&amp;(options[opt_idx]), both ? OPT_LOCAL : opt_flags);</a>
<a name="ln629">  uint32_t flags = options[opt_idx].flags;</a>
<a name="ln630">  if (varp != NULL) {       // skip hidden option, nothing to do for it</a>
<a name="ln631">    dvi = ((flags &amp; P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;</a>
<a name="ln632">    if (flags &amp; P_STRING) {</a>
<a name="ln633">      /* Use set_string_option_direct() for local options to handle</a>
<a name="ln634">       * freeing and allocating the value. */</a>
<a name="ln635">      if (options[opt_idx].indir != PV_NONE) {</a>
<a name="ln636">        set_string_option_direct(NULL, opt_idx,</a>
<a name="ln637">                                 options[opt_idx].def_val[dvi], opt_flags, 0);</a>
<a name="ln638">      } else {</a>
<a name="ln639">        if ((opt_flags &amp; OPT_FREE) &amp;&amp; (flags &amp; P_ALLOCED)) {</a>
<a name="ln640">          free_string_option(*(char_u **)(varp));</a>
<a name="ln641">        }</a>
<a name="ln642">        *(char_u **)varp = options[opt_idx].def_val[dvi];</a>
<a name="ln643">        options[opt_idx].flags &amp;= ~P_ALLOCED;</a>
<a name="ln644">      }</a>
<a name="ln645">    } else if (flags &amp; P_NUM)   {</a>
<a name="ln646">      if (options[opt_idx].indir == PV_SCROLL) {</a>
<a name="ln647">        win_comp_scroll(curwin);</a>
<a name="ln648">      } else {</a>
<a name="ln649">        long def_val = (long)options[opt_idx].def_val[dvi];</a>
<a name="ln650">        if ((long *)varp == &amp;curwin-&gt;w_p_so</a>
<a name="ln651">            || (long *)varp == &amp;curwin-&gt;w_p_siso) {</a>
<a name="ln652">          // 'scrolloff' and 'sidescrolloff' local values have a</a>
<a name="ln653">          // different default value than the global default.</a>
<a name="ln654">          *(long *)varp = -1;</a>
<a name="ln655">        } else {</a>
<a name="ln656">          *(long *)varp = def_val;</a>
<a name="ln657">        }</a>
<a name="ln658">        // May also set global value for local option.</a>
<a name="ln659">        if (both) {</a>
<a name="ln660">          *(long *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) =</a>
<a name="ln661">            def_val;</a>
<a name="ln662">        }</a>
<a name="ln663">      }</a>
<a name="ln664">    } else {  // P_BOOL</a>
<a name="ln665">      *(int *)varp = (int)(intptr_t)options[opt_idx].def_val[dvi];</a>
<a name="ln666">#ifdef UNIX</a>
<a name="ln667">      // 'modeline' defaults to off for root</a>
<a name="ln668">      if (options[opt_idx].indir == PV_ML &amp;&amp; getuid() == ROOT_UID) {</a>
<a name="ln669">        *(int *)varp = false;</a>
<a name="ln670">      }</a>
<a name="ln671">#endif</a>
<a name="ln672">      // May also set global value for local option.</a>
<a name="ln673">      if (both) {</a>
<a name="ln674">        *(int *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) =</a>
<a name="ln675">          *(int *)varp;</a>
<a name="ln676">      }</a>
<a name="ln677">    }</a>
<a name="ln678"> </a>
<a name="ln679">    // The default value is not insecure.</a>
<a name="ln680">    uint32_t *flagsp = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln681">    *flagsp = *flagsp &amp; ~P_INSECURE;</a>
<a name="ln682">  }</a>
<a name="ln683"> </a>
<a name="ln684">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687">/// Set all options (except terminal options) to their default value.</a>
<a name="ln688">static void</a>
<a name="ln689">set_options_default(</a>
<a name="ln690">    int opt_flags               // OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln691">)</a>
<a name="ln692">{</a>
<a name="ln693">  for (int i = 0; options[i].fullname; i++) {</a>
<a name="ln694">    if (!(options[i].flags &amp; P_NODEFAULT)) {</a>
<a name="ln695">      set_option_default(i, opt_flags, false);</a>
<a name="ln696">    }</a>
<a name="ln697">  }</a>
<a name="ln698"> </a>
<a name="ln699">  // The 'scroll' option must be computed for all windows.</a>
<a name="ln700">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln701">    win_comp_scroll(wp);</a>
<a name="ln702">  }</a>
<a name="ln703"> </a>
<a name="ln704">  parse_cino(curbuf);</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707">/// Set the Vi-default value of a string option.</a>
<a name="ln708">/// Used for 'sh', 'backupskip' and 'term'.</a>
<a name="ln709">///</a>
<a name="ln710">/// @param name The name of the option</a>
<a name="ln711">/// @param val The value of the option</a>
<a name="ln712">/// @param allocated If true, do not copy default as it was already allocated.</a>
<a name="ln713">static void set_string_default(const char *name, char *val, bool allocated)</a>
<a name="ln714">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln715">{</a>
<a name="ln716">  int opt_idx = findoption(name);</a>
<a name="ln717">  if (opt_idx &gt;= 0) {</a>
<a name="ln718">    if (options[opt_idx].flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln719">      xfree(options[opt_idx].def_val[VI_DEFAULT]);</a>
<a name="ln720">    }</a>
<a name="ln721"> </a>
<a name="ln722">    options[opt_idx].def_val[VI_DEFAULT] = allocated</a>
<a name="ln723">        ? (char_u *)val</a>
<a name="ln724">        : (char_u *)xstrdup(val);</a>
<a name="ln725">    options[opt_idx].flags |= P_DEF_ALLOCED;</a>
<a name="ln726">  }</a>
<a name="ln727">}</a>
<a name="ln728"> </a>
<a name="ln729">// For an option value that contains comma separated items, find &quot;newval&quot; in</a>
<a name="ln730">// &quot;origval&quot;.  Return NULL if not found.</a>
<a name="ln731">static char_u *find_dup_item(char_u *origval, const char_u *newval,</a>
<a name="ln732">                             uint32_t flags)</a>
<a name="ln733">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln734">{</a>
<a name="ln735">  int bs = 0;</a>
<a name="ln736"> </a>
<a name="ln737">  if (origval == NULL) {</a>
<a name="ln738">    return NULL;</a>
<a name="ln739">  }</a>
<a name="ln740"> </a>
<a name="ln741">  const size_t newlen = STRLEN(newval);</a>
<a name="ln742">  for (char_u *s = origval; *s != NUL; s++) {</a>
<a name="ln743">    if ((!(flags &amp; P_COMMA) || s == origval || (s[-1] == ',' &amp;&amp; !(bs &amp; 1)))</a>
<a name="ln744">        &amp;&amp; STRNCMP(s, newval, newlen) == 0</a>
<a name="ln745">        &amp;&amp; (!(flags &amp; P_COMMA) || s[newlen] == ',' || s[newlen] == NUL)) {</a>
<a name="ln746">      return s;</a>
<a name="ln747">    }</a>
<a name="ln748">    // Count backslashes.  Only a comma with an even number of backslashes</a>
<a name="ln749">    // or a single backslash preceded by a comma before it is recognized as</a>
<a name="ln750">    // a separator.</a>
<a name="ln751">    if ((s &gt; origval + 1 &amp;&amp; s[-1] == '\\' &amp;&amp; s[-2] != ',')</a>
<a name="ln752">        || (s == origval + 1 &amp;&amp; s[-1] == '\\')) {</a>
<a name="ln753">      bs++;</a>
<a name="ln754">    } else {</a>
<a name="ln755">      bs = 0;</a>
<a name="ln756">    }</a>
<a name="ln757">  }</a>
<a name="ln758">  return NULL;</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">/// Set the Vi-default value of a number option.</a>
<a name="ln762">/// Used for 'lines' and 'columns'.</a>
<a name="ln763">void set_number_default(char *name, long val)</a>
<a name="ln764">{</a>
<a name="ln765">  int opt_idx;</a>
<a name="ln766"> </a>
<a name="ln767">  opt_idx = findoption(name);</a>
<a name="ln768">  if (opt_idx &gt;= 0) {</a>
<a name="ln769">    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)(intptr_t)val;</a>
<a name="ln770">  }</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">#if defined(EXITFREE)</a>
<a name="ln774">/// Free all options.</a>
<a name="ln775">void free_all_options(void)</a>
<a name="ln776">{</a>
<a name="ln777">  for (int i = 0; options[i].fullname; i++) {</a>
<a name="ln778">    if (options[i].indir == PV_NONE) {</a>
<a name="ln779">      // global option: free value and default value.</a>
<a name="ln780">      if ((options[i].flags &amp; P_ALLOCED) &amp;&amp; options[i].var != NULL) {</a>
<a name="ln781">        free_string_option(*(char_u **)options[i].var);</a>
<a name="ln782">      }</a>
<a name="ln783">      if (options[i].flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln784">        free_string_option(options[i].def_val[VI_DEFAULT]);</a>
<a name="ln785">      }</a>
<a name="ln786">    } else if (options[i].var != VAR_WIN &amp;&amp; (options[i].flags &amp; P_STRING)) {</a>
<a name="ln787">      // buffer-local option: free global value</a>
<a name="ln788">      free_string_option(*(char_u **)options[i].var);</a>
<a name="ln789">    }</a>
<a name="ln790">  }</a>
<a name="ln791">}</a>
<a name="ln792">#endif</a>
<a name="ln793"> </a>
<a name="ln794"> </a>
<a name="ln795">/// Initialize the options, part two: After getting Rows and Columns.</a>
<a name="ln796">void set_init_2(bool headless)</a>
<a name="ln797">{</a>
<a name="ln798">  // set in set_init_1 but logging is not allowed there</a>
<a name="ln799">  ILOG(&quot;startup runtimepath/packpath value: %s&quot;, p_rtp);</a>
<a name="ln800"> </a>
<a name="ln801">  int idx;</a>
<a name="ln802"> </a>
<a name="ln803">  // 'scroll' defaults to half the window height. The stored default is zero,</a>
<a name="ln804">  // which results in the actual value computed from the window height.</a>
<a name="ln805">  idx = findoption(&quot;scroll&quot;);</a>
<a name="ln806">  if (idx &gt;= 0 &amp;&amp; !(options[idx].flags &amp; P_WAS_SET)) {</a>
<a name="ln807">    set_option_default(idx, OPT_LOCAL, false);</a>
<a name="ln808">  }</a>
<a name="ln809">  comp_col();</a>
<a name="ln810"> </a>
<a name="ln811">  /*</a>
<a name="ln812">   * 'window' is only for backwards compatibility with Vi.</a>
<a name="ln813">   * Default is Rows - 1.</a>
<a name="ln814">   */</a>
<a name="ln815">  if (!option_was_set(&quot;window&quot;)) {</a>
<a name="ln816">    p_window = Rows - 1;</a>
<a name="ln817">  }</a>
<a name="ln818">  set_number_default(&quot;window&quot;, Rows - 1);</a>
<a name="ln819">  (void)parse_printoptions();      // parse 'printoptions' default value</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">/// Initialize the options, part three: After reading the .vimrc</a>
<a name="ln823">void set_init_3(void)</a>
<a name="ln824">{</a>
<a name="ln825">  parse_shape_opt(SHAPE_CURSOR);   // set cursor shapes from 'guicursor'</a>
<a name="ln826"> </a>
<a name="ln827">  // Set 'shellpipe' and 'shellredir', depending on the 'shell' option.</a>
<a name="ln828">  // This is done after other initializations, where 'shell' might have been</a>
<a name="ln829">  // set, but only if they have not been set before.</a>
<a name="ln830">  int idx_srr = findoption(&quot;srr&quot;);</a>
<a name="ln831">  int do_srr = (idx_srr &lt; 0)</a>
<a name="ln832">    ? false</a>
<a name="ln833">    : !(options[idx_srr].flags &amp; P_WAS_SET);</a>
<a name="ln834">  int idx_sp = findoption(&quot;sp&quot;);</a>
<a name="ln835">  int do_sp = (idx_sp &lt; 0)</a>
<a name="ln836">    ? false</a>
<a name="ln837">    : !(options[idx_sp].flags &amp; P_WAS_SET);</a>
<a name="ln838"> </a>
<a name="ln839">  size_t len = 0;</a>
<a name="ln840">  char_u *p = (char_u *)invocation_path_tail(p_sh, &amp;len);</a>
<a name="ln841">  p = vim_strnsave(p, len);</a>
<a name="ln842"> </a>
<a name="ln843">  {</a>
<a name="ln844">    //</a>
<a name="ln845">    // Default for p_sp is &quot;| tee&quot;, for p_srr is &quot;&gt;&quot;.</a>
<a name="ln846">    // For known shells it is changed here to include stderr.</a>
<a name="ln847">    //</a>
<a name="ln848">    if (       fnamecmp(p, &quot;csh&quot;) == 0</a>
<a name="ln849">               || fnamecmp(p, &quot;tcsh&quot;) == 0</a>
<a name="ln850">               ) {</a>
<a name="ln851">      if (do_sp) {</a>
<a name="ln852">        p_sp = (char_u *)&quot;|&amp; tee&quot;;</a>
<a name="ln853">        options[idx_sp].def_val[VI_DEFAULT] = p_sp;</a>
<a name="ln854">      }</a>
<a name="ln855">      if (do_srr) {</a>
<a name="ln856">        p_srr = (char_u *)&quot;&gt;&amp;&quot;;</a>
<a name="ln857">        options[idx_srr].def_val[VI_DEFAULT] = p_srr;</a>
<a name="ln858">      }</a>
<a name="ln859">    } else if (fnamecmp(p, &quot;sh&quot;) == 0</a>
<a name="ln860">               || fnamecmp(p, &quot;ksh&quot;) == 0</a>
<a name="ln861">               || fnamecmp(p, &quot;mksh&quot;) == 0</a>
<a name="ln862">               || fnamecmp(p, &quot;pdksh&quot;) == 0</a>
<a name="ln863">               || fnamecmp(p, &quot;zsh&quot;) == 0</a>
<a name="ln864">               || fnamecmp(p, &quot;zsh-beta&quot;) == 0</a>
<a name="ln865">               || fnamecmp(p, &quot;bash&quot;) == 0</a>
<a name="ln866">               || fnamecmp(p, &quot;fish&quot;) == 0</a>
<a name="ln867">               || fnamecmp(p, &quot;ash&quot;) == 0</a>
<a name="ln868">               || fnamecmp(p, &quot;dash&quot;) == 0</a>
<a name="ln869">               ) {</a>
<a name="ln870">      // Always use POSIX shell style redirection if we reach this</a>
<a name="ln871">      if (do_sp) {</a>
<a name="ln872">        p_sp = (char_u *)&quot;2&gt;&amp;1| tee&quot;;</a>
<a name="ln873">        options[idx_sp].def_val[VI_DEFAULT] = p_sp;</a>
<a name="ln874">      }</a>
<a name="ln875">      if (do_srr) {</a>
<a name="ln876">        p_srr = (char_u *)&quot;&gt;%s 2&gt;&amp;1&quot;;</a>
<a name="ln877">        options[idx_srr].def_val[VI_DEFAULT] = p_srr;</a>
<a name="ln878">      }</a>
<a name="ln879">    }</a>
<a name="ln880">    xfree(p);</a>
<a name="ln881">  }</a>
<a name="ln882"> </a>
<a name="ln883">  if (BUFEMPTY()) {</a>
<a name="ln884">    int idx_ffs = findoption_len(S_LEN(&quot;ffs&quot;));</a>
<a name="ln885"> </a>
<a name="ln886">    // Apply the first entry of 'fileformats' to the initial buffer.</a>
<a name="ln887">    if (idx_ffs &gt;= 0 &amp;&amp; (options[idx_ffs].flags &amp; P_WAS_SET)) {</a>
<a name="ln888">      set_fileformat(default_fileformat(), OPT_LOCAL);</a>
<a name="ln889">    }</a>
<a name="ln890">  }</a>
<a name="ln891"> </a>
<a name="ln892">  set_title_defaults();  // 'title', 'icon'</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895">/// When 'helplang' is still at its default value, set it to &quot;lang&quot;.</a>
<a name="ln896">/// Only the first two characters of &quot;lang&quot; are used.</a>
<a name="ln897">void set_helplang_default(const char *lang)</a>
<a name="ln898">{</a>
<a name="ln899">  if (lang == NULL) {</a>
<a name="ln900">    return;</a>
<a name="ln901">  }</a>
<a name="ln902"> </a>
<a name="ln903">  const size_t lang_len = strlen(lang);</a>
<a name="ln904">  if (lang_len &lt; 2) {  // safety check</a>
<a name="ln905">    return;</a>
<a name="ln906">  }</a>
<a name="ln907">  int idx = findoption(&quot;hlg&quot;);</a>
<a name="ln908">  if (idx &gt;= 0 &amp;&amp; !(options[idx].flags &amp; P_WAS_SET)) {</a>
<a name="ln909">    if (options[idx].flags &amp; P_ALLOCED) {</a>
<a name="ln910">      free_string_option(p_hlg);</a>
<a name="ln911">    }</a>
<a name="ln912">    p_hlg = (char_u *)xmemdupz(lang, lang_len);</a>
<a name="ln913">    // zh_CN becomes &quot;cn&quot;, zh_TW becomes &quot;tw&quot;.</a>
<a name="ln914">    if (STRNICMP(p_hlg, &quot;zh_&quot;, 3) == 0 &amp;&amp; STRLEN(p_hlg) &gt;= 5) {</a>
<a name="ln915">      p_hlg[0] = (char_u)TOLOWER_ASC(p_hlg[3]);</a>
<a name="ln916">      p_hlg[1] = (char_u)TOLOWER_ASC(p_hlg[4]);</a>
<a name="ln917">    } else if (STRLEN(p_hlg) &gt;= 1 &amp;&amp; *p_hlg == 'C') {</a>
<a name="ln918">      // any C like setting, such as C.UTF-8, becomes &quot;en&quot;</a>
<a name="ln919">      p_hlg[0] = 'e';</a>
<a name="ln920">      p_hlg[1] = 'n';</a>
<a name="ln921">    }</a>
<a name="ln922">    p_hlg[2] = NUL;</a>
<a name="ln923">    options[idx].flags |= P_ALLOCED;</a>
<a name="ln924">  }</a>
<a name="ln925">}</a>
<a name="ln926"> </a>
<a name="ln927"> </a>
<a name="ln928">/// 'title' and 'icon' only default to true if they have not been set or reset</a>
<a name="ln929">/// in .vimrc and we can read the old value.</a>
<a name="ln930">/// When 'title' and 'icon' have been reset in .vimrc, we won't even check if</a>
<a name="ln931">/// they can be reset.  This reduces startup time when using X on a remote</a>
<a name="ln932">/// machine.</a>
<a name="ln933">void set_title_defaults(void)</a>
<a name="ln934">{</a>
<a name="ln935">  int idx1;</a>
<a name="ln936"> </a>
<a name="ln937">  /*</a>
<a name="ln938">   * If GUI is (going to be) used, we can always set the window title and</a>
<a name="ln939">   * icon name.  Saves a bit of time, because the X11 display server does</a>
<a name="ln940">   * not need to be contacted.</a>
<a name="ln941">   */</a>
<a name="ln942">  idx1 = findoption(&quot;title&quot;);</a>
<a name="ln943">  if (idx1 &gt;= 0 &amp;&amp; !(options[idx1].flags &amp; P_WAS_SET)) {</a>
<a name="ln944">    options[idx1].def_val[VI_DEFAULT] = (char_u *)(intptr_t)0;</a>
<a name="ln945">    p_title = 0;</a>
<a name="ln946">  }</a>
<a name="ln947">  idx1 = findoption(&quot;icon&quot;);</a>
<a name="ln948">  if (idx1 &gt;= 0 &amp;&amp; !(options[idx1].flags &amp; P_WAS_SET)) {</a>
<a name="ln949">    options[idx1].def_val[VI_DEFAULT] = (char_u *)(intptr_t)0;</a>
<a name="ln950">    p_icon = 0;</a>
<a name="ln951">  }</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954">// Parse 'arg' for option settings.</a>
<a name="ln955">//</a>
<a name="ln956">// 'arg' may be IObuff, but only when no errors can be present and option</a>
<a name="ln957">// does not need to be expanded with option_expand().</a>
<a name="ln958">// &quot;opt_flags&quot;:</a>
<a name="ln959">// 0 for &quot;:set&quot;</a>
<a name="ln960">// OPT_GLOBAL   for &quot;:setglobal&quot;</a>
<a name="ln961">// OPT_LOCAL    for &quot;:setlocal&quot; and a modeline</a>
<a name="ln962">// OPT_MODELINE for a modeline</a>
<a name="ln963">// OPT_WINONLY  to only set window-local options</a>
<a name="ln964">// OPT_NOWIN    to skip setting window-local options</a>
<a name="ln965">//</a>
<a name="ln966">// returns FAIL if an error is detected, OK otherwise</a>
<a name="ln967">int do_set(</a>
<a name="ln968">    char_u *arg,               // option string (may be written to!)</a>
<a name="ln969">    int opt_flags</a>
<a name="ln970">)</a>
<a name="ln971">{</a>
<a name="ln972">  int opt_idx;</a>
<a name="ln973">  char_u      *errmsg;</a>
<a name="ln974">  char_u errbuf[80];</a>
<a name="ln975">  char_u      *startarg;</a>
<a name="ln976">  int prefix;           // 1: nothing, 0: &quot;no&quot;, 2: &quot;inv&quot; in front of name</a>
<a name="ln977">  char_u nextchar;                  // next non-white char after option name</a>
<a name="ln978">  int afterchar;                    // character just after option name</a>
<a name="ln979">  int len;</a>
<a name="ln980">  int i;</a>
<a name="ln981">  varnumber_T value;</a>
<a name="ln982">  int key;</a>
<a name="ln983">  uint32_t flags;                   // flags for current option</a>
<a name="ln984">  char_u      *varp = NULL;         // pointer to variable for current option</a>
<a name="ln985">  int did_show = false;             // already showed one value</a>
<a name="ln986">  int adding;                       // &quot;opt+=arg&quot;</a>
<a name="ln987">  int prepending;                   // &quot;opt^=arg&quot;</a>
<a name="ln988">  int removing;                     // &quot;opt-=arg&quot;</a>
<a name="ln989">  int cp_val = 0;</a>
<a name="ln990"> </a>
<a name="ln991">  if (*arg == NUL) {</a>
<a name="ln992">    showoptions(0, opt_flags);</a>
<a name="ln993">    did_show = true;</a>
<a name="ln994">    goto theend;</a>
<a name="ln995">  }</a>
<a name="ln996"> </a>
<a name="ln997">  while (*arg != NUL) {         // loop to process all options</a>
<a name="ln998">    errmsg = NULL;</a>
<a name="ln999">    startarg = arg;             // remember for error message</a>
<a name="ln1000"> </a>
<a name="ln1001">    if (STRNCMP(arg, &quot;all&quot;, 3) == 0 &amp;&amp; !isalpha(arg[3])</a>
<a name="ln1002">        &amp;&amp; !(opt_flags &amp; OPT_MODELINE)) {</a>
<a name="ln1003">      /*</a>
<a name="ln1004">       * &quot;:set all&quot;  show all options.</a>
<a name="ln1005">       * &quot;:set all&amp;&quot; set all options to their default value.</a>
<a name="ln1006">       */</a>
<a name="ln1007">      arg += 3;</a>
<a name="ln1008">      if (*arg == '&amp;') {</a>
<a name="ln1009">        arg++;</a>
<a name="ln1010">        // Only for :set command set global value of local options.</a>
<a name="ln1011">        set_options_default(OPT_FREE | opt_flags);</a>
<a name="ln1012">        didset_options();</a>
<a name="ln1013">        didset_options2();</a>
<a name="ln1014">        ui_refresh_options();</a>
<a name="ln1015">        redraw_all_later(CLEAR);</a>
<a name="ln1016">      } else {</a>
<a name="ln1017">        showoptions(1, opt_flags);</a>
<a name="ln1018">        did_show = true;</a>
<a name="ln1019">      }</a>
<a name="ln1020">    } else {</a>
<a name="ln1021">      prefix = 1;</a>
<a name="ln1022">      if (STRNCMP(arg, &quot;no&quot;, 2) == 0) {</a>
<a name="ln1023">        prefix = 0;</a>
<a name="ln1024">        arg += 2;</a>
<a name="ln1025">      } else if (STRNCMP(arg, &quot;inv&quot;, 3) == 0) {</a>
<a name="ln1026">        prefix = 2;</a>
<a name="ln1027">        arg += 3;</a>
<a name="ln1028">      }</a>
<a name="ln1029"> </a>
<a name="ln1030">      // find end of name</a>
<a name="ln1031">      key = 0;</a>
<a name="ln1032">      if (*arg == '&lt;') {</a>
<a name="ln1033">        opt_idx = -1;</a>
<a name="ln1034">        // look out for &lt;t_&gt;;&gt;</a>
<a name="ln1035">        if (arg[1] == 't' &amp;&amp; arg[2] == '_' &amp;&amp; arg[3] &amp;&amp; arg[4]) {</a>
<a name="ln1036">          len = 5;</a>
<a name="ln1037">        } else {</a>
<a name="ln1038">          len = 1;</a>
<a name="ln1039">          while (arg[len] != NUL &amp;&amp; arg[len] != '&gt;') {</a>
<a name="ln1040">            len++;</a>
<a name="ln1041">          }</a>
<a name="ln1042">        }</a>
<a name="ln1043">        if (arg[len] != '&gt;') {</a>
<a name="ln1044">          errmsg = e_invarg;</a>
<a name="ln1045">          goto skip;</a>
<a name="ln1046">        }</a>
<a name="ln1047">        if (arg[1] == 't' &amp;&amp; arg[2] == '_') {  // could be term code</a>
<a name="ln1048">          opt_idx = findoption_len((const char *)arg + 1, (size_t)(len - 1));</a>
<a name="ln1049">        }</a>
<a name="ln1050">        len++;</a>
<a name="ln1051">        if (opt_idx == -1) {</a>
<a name="ln1052">          key = find_key_option(arg + 1, true);</a>
<a name="ln1053">        }</a>
<a name="ln1054">      } else {</a>
<a name="ln1055">        len = 0;</a>
<a name="ln1056">        // The two characters after &quot;t_&quot; may not be alphanumeric.</a>
<a name="ln1057">        if (arg[0] == 't' &amp;&amp; arg[1] == '_' &amp;&amp; arg[2] &amp;&amp; arg[3]) {</a>
<a name="ln1058">          len = 4;</a>
<a name="ln1059">        } else {</a>
<a name="ln1060">          while (ASCII_ISALNUM(arg[len]) || arg[len] == '_') {</a>
<a name="ln1061">            len++;</a>
<a name="ln1062">          }</a>
<a name="ln1063">        }</a>
<a name="ln1064">        opt_idx = findoption_len((const char *)arg, (size_t)len);</a>
<a name="ln1065">        if (opt_idx == -1) {</a>
<a name="ln1066">          key = find_key_option(arg, false);</a>
<a name="ln1067">        }</a>
<a name="ln1068">      }</a>
<a name="ln1069"> </a>
<a name="ln1070">      // remember character after option name</a>
<a name="ln1071">      afterchar = arg[len];</a>
<a name="ln1072"> </a>
<a name="ln1073">      // skip white space, allow &quot;:set ai  ?&quot;</a>
<a name="ln1074">      while (ascii_iswhite(arg[len])) {</a>
<a name="ln1075">        len++;</a>
<a name="ln1076">      }</a>
<a name="ln1077"> </a>
<a name="ln1078">      adding = false;</a>
<a name="ln1079">      prepending = false;</a>
<a name="ln1080">      removing = false;</a>
<a name="ln1081">      if (arg[len] != NUL &amp;&amp; arg[len + 1] == '=') {</a>
<a name="ln1082">        if (arg[len] == '+') {</a>
<a name="ln1083">          adding = true;                        // &quot;+=&quot;</a>
<a name="ln1084">          len++;</a>
<a name="ln1085">        } else if (arg[len] == '^') {</a>
<a name="ln1086">          prepending = true;                    // &quot;^=&quot;</a>
<a name="ln1087">          len++;</a>
<a name="ln1088">        } else if (arg[len] == '-') {</a>
<a name="ln1089">          removing = true;                      // &quot;-=&quot;</a>
<a name="ln1090">          len++;</a>
<a name="ln1091">        }</a>
<a name="ln1092">      }</a>
<a name="ln1093">      nextchar = arg[len];</a>
<a name="ln1094"> </a>
<a name="ln1095">      if (opt_idx == -1 &amp;&amp; key == 0) {          // found a mismatch: skip</a>
<a name="ln1096">        errmsg = (char_u *)N_(&quot;E518: Unknown option&quot;);</a>
<a name="ln1097">        goto skip;</a>
<a name="ln1098">      }</a>
<a name="ln1099"> </a>
<a name="ln1100">      if (opt_idx &gt;= 0) {</a>
<a name="ln1101">        if (options[opt_idx].var == NULL) {         // hidden option: skip</a>
<a name="ln1102">          // Only give an error message when requesting the value of</a>
<a name="ln1103">          // a hidden option, ignore setting it.</a>
<a name="ln1104">          if (vim_strchr((char_u *)&quot;=:!&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1105">              &amp;&amp; (!(options[opt_idx].flags &amp; P_BOOL)</a>
<a name="ln1106">                  || nextchar == '?')) {</a>
<a name="ln1107">            errmsg = (char_u *)_(e_unsupportedoption);</a>
<a name="ln1108">          }</a>
<a name="ln1109">          goto skip;</a>
<a name="ln1110">        }</a>
<a name="ln1111"> </a>
<a name="ln1112">        flags = options[opt_idx].flags;</a>
<a name="ln1113">        varp = get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln1114">      } else {</a>
<a name="ln1115">        flags = P_STRING;</a>
<a name="ln1116">      }</a>
<a name="ln1117"> </a>
<a name="ln1118">      /* Skip all options that are not window-local (used when showing</a>
<a name="ln1119">       * an already loaded buffer in a window). */</a>
<a name="ln1120">      if ((opt_flags &amp; OPT_WINONLY)</a>
<a name="ln1121">          &amp;&amp; (opt_idx &lt; 0 || options[opt_idx].var != VAR_WIN))</a>
<a name="ln1122">        goto skip;</a>
<a name="ln1123"> </a>
<a name="ln1124">      // Skip all options that are window-local (used for :vimgrep).</a>
<a name="ln1125">      if ((opt_flags &amp; OPT_NOWIN) &amp;&amp; opt_idx &gt;= 0</a>
<a name="ln1126">          &amp;&amp; options[opt_idx].var == VAR_WIN) {</a>
<a name="ln1127">        goto skip;</a>
<a name="ln1128">      }</a>
<a name="ln1129"> </a>
<a name="ln1130">      // Disallow changing some options from modelines.</a>
<a name="ln1131">      if (opt_flags &amp; OPT_MODELINE) {</a>
<a name="ln1132">        if (flags &amp; (P_SECURE | P_NO_ML)) {</a>
<a name="ln1133">          errmsg = (char_u *)N_(&quot;E520: Not allowed in a modeline&quot;);</a>
<a name="ln1134">          goto skip;</a>
<a name="ln1135">        }</a>
<a name="ln1136">        if ((flags &amp; P_MLE) &amp;&amp; !p_mle) {</a>
<a name="ln1137">          errmsg = (char_u *)N_(</a>
<a name="ln1138">              &quot;E992: Not allowed in a modeline when 'modelineexpr' is off&quot;);</a>
<a name="ln1139">          goto skip;</a>
<a name="ln1140">        }</a>
<a name="ln1141">        // In diff mode some options are overruled.  This avoids that</a>
<a name="ln1142">        // 'foldmethod' becomes &quot;marker&quot; instead of &quot;diff&quot; and that</a>
<a name="ln1143">        // &quot;wrap&quot; gets set.</a>
<a name="ln1144">        if (curwin-&gt;w_p_diff</a>
<a name="ln1145">            &amp;&amp; opt_idx &gt;= 0              // shut up coverity warning</a>
<a name="ln1146">            &amp;&amp; (options[opt_idx].indir == PV_FDM</a>
<a name="ln1147">                || options[opt_idx].indir == PV_WRAP)) {</a>
<a name="ln1148">          goto skip;</a>
<a name="ln1149">        }</a>
<a name="ln1150">      }</a>
<a name="ln1151"> </a>
<a name="ln1152">      // Disallow changing some options in the sandbox</a>
<a name="ln1153">      if (sandbox != 0 &amp;&amp; (flags &amp; P_SECURE)) {</a>
<a name="ln1154">        errmsg = e_sandbox;</a>
<a name="ln1155">        goto skip;</a>
<a name="ln1156">      }</a>
<a name="ln1157"> </a>
<a name="ln1158">      if (vim_strchr((char_u *)&quot;?=:!&amp;&lt;&quot;, nextchar) != NULL) {</a>
<a name="ln1159">        arg += len;</a>
<a name="ln1160">        cp_val = false;</a>
<a name="ln1161">        if (nextchar == '&amp;' &amp;&amp; arg[1] == 'v' &amp;&amp; arg[2] == 'i') {</a>
<a name="ln1162">          if (arg[3] == 'm') {          // &quot;opt&amp;vim&quot;: set to Vim default</a>
<a name="ln1163">            cp_val = false;</a>
<a name="ln1164">            arg += 3;</a>
<a name="ln1165">          } else {                    // &quot;opt&amp;vi&quot;: set to Vi default</a>
<a name="ln1166">            cp_val = true;</a>
<a name="ln1167">            arg += 2;</a>
<a name="ln1168">          }</a>
<a name="ln1169">        }</a>
<a name="ln1170">        if (vim_strchr((char_u *)&quot;?!&amp;&lt;&quot;, nextchar) != NULL</a>
<a name="ln1171">            &amp;&amp; arg[1] != NUL &amp;&amp; !ascii_iswhite(arg[1])) {</a>
<a name="ln1172">          errmsg = e_trailing;</a>
<a name="ln1173">          goto skip;</a>
<a name="ln1174">        }</a>
<a name="ln1175">      }</a>
<a name="ln1176"> </a>
<a name="ln1177">      /*</a>
<a name="ln1178">       * allow '=' and ':' as MSDOS command.com allows only one</a>
<a name="ln1179">       * '=' character per &quot;set&quot; command line. grrr. (jw)</a>
<a name="ln1180">       */</a>
<a name="ln1181">      if (nextchar == '?'</a>
<a name="ln1182">          || (prefix == 1</a>
<a name="ln1183">              &amp;&amp; vim_strchr((char_u *)&quot;=:&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1184">              &amp;&amp; !(flags &amp; P_BOOL))) {</a>
<a name="ln1185">        /*</a>
<a name="ln1186">         * print value</a>
<a name="ln1187">         */</a>
<a name="ln1188">        if (did_show) {</a>
<a name="ln1189">          msg_putchar('\n');                // cursor below last one</a>
<a name="ln1190">        } else {</a>
<a name="ln1191">          gotocmdline(true);                // cursor at status line</a>
<a name="ln1192">          did_show = true;                  // remember that we did a line</a>
<a name="ln1193">        }</a>
<a name="ln1194">        if (opt_idx &gt;= 0) {</a>
<a name="ln1195">          showoneopt(&amp;options[opt_idx], opt_flags);</a>
<a name="ln1196">          if (p_verbose &gt; 0) {</a>
<a name="ln1197">            // Mention where the option was last set.</a>
<a name="ln1198">            if (varp == options[opt_idx].var) {</a>
<a name="ln1199">              option_last_set_msg(options[opt_idx].last_set);</a>
<a name="ln1200">            } else if ((int)options[opt_idx].indir &amp; PV_WIN) {</a>
<a name="ln1201">              option_last_set_msg(curwin-&gt;w_p_script_ctx[</a>
<a name="ln1202">                  (int)options[opt_idx].indir &amp; PV_MASK]);</a>
<a name="ln1203">            } else if ((int)options[opt_idx].indir &amp; PV_BUF) {</a>
<a name="ln1204">              option_last_set_msg(curbuf-&gt;b_p_script_ctx[</a>
<a name="ln1205">                  (int)options[opt_idx].indir &amp; PV_MASK]);</a>
<a name="ln1206">            }</a>
<a name="ln1207">          }</a>
<a name="ln1208">        } else {</a>
<a name="ln1209">          errmsg = (char_u *)N_(&quot;E846: Key code not set&quot;);</a>
<a name="ln1210">          goto skip;</a>
<a name="ln1211">        }</a>
<a name="ln1212">        if (nextchar != '?'</a>
<a name="ln1213">            &amp;&amp; nextchar != NUL &amp;&amp; !ascii_iswhite(afterchar))</a>
<a name="ln1214">          errmsg = e_trailing;</a>
<a name="ln1215">      } else {</a>
<a name="ln1216">        int value_is_replaced = !prepending &amp;&amp; !adding &amp;&amp; !removing;</a>
<a name="ln1217">        int value_checked = false;</a>
<a name="ln1218"> </a>
<a name="ln1219">        if (flags &amp; P_BOOL) {                       // boolean</a>
<a name="ln1220">          if (nextchar == '=' || nextchar == ':') {</a>
<a name="ln1221">            errmsg = e_invarg;</a>
<a name="ln1222">            goto skip;</a>
<a name="ln1223">          }</a>
<a name="ln1224"> </a>
<a name="ln1225">          /*</a>
<a name="ln1226">           * &quot;:set opt!&quot;: invert</a>
<a name="ln1227">           * &quot;:set opt&amp;&quot;: reset to default value</a>
<a name="ln1228">           * &quot;:set opt&lt;&quot;: reset to global value</a>
<a name="ln1229">           */</a>
<a name="ln1230">          if (nextchar == '!') {</a>
<a name="ln1231">            value = *(int *)(varp) ^ 1;</a>
<a name="ln1232">          } else if (nextchar == '&amp;') {</a>
<a name="ln1233">            value = (int)(intptr_t)options[opt_idx].def_val[</a>
<a name="ln1234">                ((flags &amp; P_VI_DEF) || cp_val)</a>
<a name="ln1235">                ?  VI_DEFAULT : VIM_DEFAULT];</a>
<a name="ln1236">          } else if (nextchar == '&lt;') {</a>
<a name="ln1237">            // For 'autoread' -1 means to use global value.</a>
<a name="ln1238">            if ((int *)varp == &amp;curbuf-&gt;b_p_ar</a>
<a name="ln1239">                &amp;&amp; opt_flags == OPT_LOCAL) {</a>
<a name="ln1240">              value = -1;</a>
<a name="ln1241">            } else {</a>
<a name="ln1242">              value = *(int *)get_varp_scope(&amp;(options[opt_idx]),</a>
<a name="ln1243">                                             OPT_GLOBAL);</a>
<a name="ln1244">            }</a>
<a name="ln1245">          } else {</a>
<a name="ln1246">            /*</a>
<a name="ln1247">             * &quot;:set invopt&quot;: invert</a>
<a name="ln1248">             * &quot;:set opt&quot; or &quot;:set noopt&quot;: set or reset</a>
<a name="ln1249">             */</a>
<a name="ln1250">            if (nextchar != NUL &amp;&amp; !ascii_iswhite(afterchar)) {</a>
<a name="ln1251">              errmsg = e_trailing;</a>
<a name="ln1252">              goto skip;</a>
<a name="ln1253">            }</a>
<a name="ln1254">            if (prefix == 2) {                  // inv</a>
<a name="ln1255">              value = *(int *)(varp) ^ 1;</a>
<a name="ln1256">            } else {</a>
<a name="ln1257">              value = prefix;</a>
<a name="ln1258">            }</a>
<a name="ln1259">          }</a>
<a name="ln1260"> </a>
<a name="ln1261">          errmsg = (char_u *)set_bool_option(opt_idx, varp, (int)value,</a>
<a name="ln1262">                                             opt_flags);</a>
<a name="ln1263">        } else {  // Numeric or string.</a>
<a name="ln1264">          if (vim_strchr((const char_u *)&quot;=:&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1265">              || prefix != 1) {</a>
<a name="ln1266">            errmsg = e_invarg;</a>
<a name="ln1267">            goto skip;</a>
<a name="ln1268">          }</a>
<a name="ln1269"> </a>
<a name="ln1270">          if (flags &amp; P_NUM) {                      // numeric</a>
<a name="ln1271">            // Different ways to set a number option:</a>
<a name="ln1272">            // &amp;            set to default value</a>
<a name="ln1273">            // &lt;            set to global value</a>
<a name="ln1274">            // &lt;xx&gt;         accept special key codes for 'wildchar'</a>
<a name="ln1275">            // c            accept any non-digit for 'wildchar'</a>
<a name="ln1276">            // [-]0-9       set number</a>
<a name="ln1277">            // other        error</a>
<a name="ln1278">            arg++;</a>
<a name="ln1279">            if (nextchar == '&amp;') {</a>
<a name="ln1280">              value = (long)(intptr_t)options[opt_idx].def_val[</a>
<a name="ln1281">                  ((flags &amp; P_VI_DEF) || cp_val) ? VI_DEFAULT : VIM_DEFAULT];</a>
<a name="ln1282">            } else if (nextchar == '&lt;') {</a>
<a name="ln1283">              // For 'undolevels' NO_LOCAL_UNDOLEVEL means to</a>
<a name="ln1284">              // use the global value.</a>
<a name="ln1285">              if ((long *)varp == &amp;curbuf-&gt;b_p_ul &amp;&amp; opt_flags == OPT_LOCAL) {</a>
<a name="ln1286">                value = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln1287">              } else {</a>
<a name="ln1288">                value = *(long *)get_varp_scope(</a>
<a name="ln1289">                    &amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln1290">              }</a>
<a name="ln1291">            } else if (((long *)varp == &amp;p_wc</a>
<a name="ln1292">                        || (long *)varp == &amp;p_wcm)</a>
<a name="ln1293">                       &amp;&amp; (*arg == '&lt;'</a>
<a name="ln1294">                           || *arg == '^'</a>
<a name="ln1295">                           || (*arg != NUL &amp;&amp; (!arg[1] || ascii_iswhite(arg[1]))</a>
<a name="ln1296">                               &amp;&amp; !ascii_isdigit(*arg)))) {</a>
<a name="ln1297">              value = string_to_key(arg);</a>
<a name="ln1298">              if (value == 0 &amp;&amp; (long *)varp != &amp;p_wcm) {</a>
<a name="ln1299">                errmsg = e_invarg;</a>
<a name="ln1300">                goto skip;</a>
<a name="ln1301">              }</a>
<a name="ln1302">            } else if (*arg == '-' || ascii_isdigit(*arg)) {</a>
<a name="ln1303">              // Allow negative, octal and hex numbers.</a>
<a name="ln1304">              vim_str2nr(arg, NULL, &amp;i, STR2NR_ALL, &amp;value, NULL, 0);</a>
<a name="ln1305">              if (arg[i] != NUL &amp;&amp; !ascii_iswhite(arg[i])) {</a>
<a name="ln1306">                errmsg = e_invarg;</a>
<a name="ln1307">                goto skip;</a>
<a name="ln1308">              }</a>
<a name="ln1309">            } else {</a>
<a name="ln1310">              errmsg = (char_u *)N_(&quot;E521: Number required after =&quot;);</a>
<a name="ln1311">              goto skip;</a>
<a name="ln1312">            }</a>
<a name="ln1313"> </a>
<a name="ln1314">            if (adding) {</a>
<a name="ln1315">              value = *(long *)varp + value;</a>
<a name="ln1316">            }</a>
<a name="ln1317">            if (prepending) {</a>
<a name="ln1318">              value = *(long *)varp * value;</a>
<a name="ln1319">            }</a>
<a name="ln1320">            if (removing) {</a>
<a name="ln1321">              value = *(long *)varp - value;</a>
<a name="ln1322">            }</a>
<a name="ln1323">            errmsg = (char_u *)set_num_option(opt_idx, varp, (long)value,</a>
<a name="ln1324">                                              errbuf, sizeof(errbuf),</a>
<a name="ln1325">                                              opt_flags);</a>
<a name="ln1326">          } else if (opt_idx &gt;= 0) {  // String.</a>
<a name="ln1327">            char_u      *save_arg = NULL;</a>
<a name="ln1328">            char_u      *s = NULL;</a>
<a name="ln1329">            char_u      *oldval = NULL;         // previous value if *varp</a>
<a name="ln1330">            char_u      *newval;</a>
<a name="ln1331">            char_u      *origval = NULL;</a>
<a name="ln1332">            char *saved_origval = NULL;</a>
<a name="ln1333">            char *saved_newval = NULL;</a>
<a name="ln1334">            unsigned newlen;</a>
<a name="ln1335">            int comma;</a>
<a name="ln1336">            bool new_value_alloced = false;  // new string option was allocated</a>
<a name="ln1337"> </a>
<a name="ln1338">            /* When using &quot;:set opt=val&quot; for a global option</a>
<a name="ln1339">             * with a local value the local value will be</a>
<a name="ln1340">             * reset, use the global value here. */</a>
<a name="ln1341">            if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0</a>
<a name="ln1342">                &amp;&amp; ((int)options[opt_idx].indir &amp; PV_BOTH))</a>
<a name="ln1343">              varp = options[opt_idx].var;</a>
<a name="ln1344"> </a>
<a name="ln1345">            /* The old value is kept until we are sure that the</a>
<a name="ln1346">             * new value is valid. */</a>
<a name="ln1347">            oldval = *(char_u **)varp;</a>
<a name="ln1348"> </a>
<a name="ln1349">            // When setting the local value of a global</a>
<a name="ln1350">            // option, the old value may be the global value.</a>
<a name="ln1351">            if (((int)options[opt_idx].indir &amp; PV_BOTH) &amp;&amp; (opt_flags</a>
<a name="ln1352">                                                            &amp; OPT_LOCAL)) {</a>
<a name="ln1353">              origval = *(char_u **)get_varp(&amp;options[opt_idx]);</a>
<a name="ln1354">            } else {</a>
<a name="ln1355">              origval = oldval;</a>
<a name="ln1356">            }</a>
<a name="ln1357"> </a>
<a name="ln1358">            if (nextchar == '&amp;') {              // set to default val</a>
<a name="ln1359">              newval = options[opt_idx].def_val[</a>
<a name="ln1360">                ((flags &amp; P_VI_DEF) || cp_val)</a>
<a name="ln1361">                ?  VI_DEFAULT : VIM_DEFAULT];</a>
<a name="ln1362">              /* expand environment variables and ~ (since the</a>
<a name="ln1363">               * default value was already expanded, only</a>
<a name="ln1364">               * required when an environment variable was set</a>
<a name="ln1365">               * later */</a>
<a name="ln1366">              new_value_alloced = true;</a>
<a name="ln1367">              if (newval == NULL) {</a>
<a name="ln1368">                newval = empty_option;</a>
<a name="ln1369">              } else if (!(options[opt_idx].flags &amp; P_NO_DEF_EXP)) {</a>
<a name="ln1370">                s = option_expand(opt_idx, newval);</a>
<a name="ln1371">                if (s == NULL) {</a>
<a name="ln1372">                  s = newval;</a>
<a name="ln1373">                }</a>
<a name="ln1374">                newval = vim_strsave(s);</a>
<a name="ln1375">              } else {</a>
<a name="ln1376">                newval = (char_u *)xstrdup((char *)newval);</a>
<a name="ln1377">              }</a>
<a name="ln1378">            } else if (nextchar == '&lt;') {  // set to global val</a>
<a name="ln1379">              newval = vim_strsave(*(char_u **)get_varp_scope(</a>
<a name="ln1380">                  &amp;(options[opt_idx]), OPT_GLOBAL));</a>
<a name="ln1381">              new_value_alloced = true;</a>
<a name="ln1382">            } else {</a>
<a name="ln1383">              arg++;                    // jump to after the '=' or ':'</a>
<a name="ln1384"> </a>
<a name="ln1385">              /*</a>
<a name="ln1386">               * Set 'keywordprg' to &quot;:help&quot; if an empty</a>
<a name="ln1387">               * value was passed to :set by the user.</a>
<a name="ln1388">               * Misuse errbuf[] for the resulting string.</a>
<a name="ln1389">               */</a>
<a name="ln1390">              if (varp == (char_u *)&amp;p_kp</a>
<a name="ln1391">                  &amp;&amp; (*arg == NUL || *arg == ' ')) {</a>
<a name="ln1392">                STRCPY(errbuf, &quot;:help&quot;);</a>
<a name="ln1393">                save_arg = arg;</a>
<a name="ln1394">                arg = errbuf;</a>
<a name="ln1395">              }</a>
<a name="ln1396">              /*</a>
<a name="ln1397">               * Convert 'backspace' number to string, for</a>
<a name="ln1398">               * adding, prepending and removing string.</a>
<a name="ln1399">               */</a>
<a name="ln1400">              else if (varp == (char_u *)&amp;p_bs</a>
<a name="ln1401">                       &amp;&amp; ascii_isdigit(**(char_u **)varp)) {</a>
<a name="ln1402">                i = getdigits_int((char_u **)varp, true, 0);</a>
<a name="ln1403">                switch (i) {</a>
<a name="ln1404">                case 0:</a>
<a name="ln1405">                  *(char_u **)varp = empty_option;</a>
<a name="ln1406">                  break;</a>
<a name="ln1407">                case 1:</a>
<a name="ln1408">                  *(char_u **)varp = vim_strsave(</a>
<a name="ln1409">                      (char_u *)&quot;indent,eol&quot;);</a>
<a name="ln1410">                  break;</a>
<a name="ln1411">                case 2:</a>
<a name="ln1412">                  *(char_u **)varp = vim_strsave(</a>
<a name="ln1413">                      (char_u *)&quot;indent,eol,start&quot;);</a>
<a name="ln1414">                  break;</a>
<a name="ln1415">                case 3:</a>
<a name="ln1416">                  *(char_u **)varp = vim_strsave(</a>
<a name="ln1417">                      (char_u *)&quot;indent,eol,nostop&quot;);</a>
<a name="ln1418">                  break;</a>
<a name="ln1419">                }</a>
<a name="ln1420">                xfree(oldval);</a>
<a name="ln1421">                if (origval == oldval) {</a>
<a name="ln1422">                  origval = *(char_u **)varp;</a>
<a name="ln1423">                }</a>
<a name="ln1424">                oldval = *(char_u **)varp;</a>
<a name="ln1425">              }</a>
<a name="ln1426">              /*</a>
<a name="ln1427">               * Convert 'whichwrap' number to string, for</a>
<a name="ln1428">               * backwards compatibility with Vim 3.0.</a>
<a name="ln1429">               * Misuse errbuf[] for the resulting string.</a>
<a name="ln1430">               */</a>
<a name="ln1431">              else if (varp == (char_u *)&amp;p_ww</a>
<a name="ln1432">                       &amp;&amp; ascii_isdigit(*arg)) {</a>
<a name="ln1433">                *errbuf = NUL;</a>
<a name="ln1434">                i = getdigits_int(&amp;arg, true, 0);</a>
<a name="ln1435">                if (i &amp; 1) {</a>
<a name="ln1436">                  STRCAT(errbuf, &quot;b,&quot;);</a>
<a name="ln1437">                }</a>
<a name="ln1438">                if (i &amp; 2) {</a>
<a name="ln1439">                  STRCAT(errbuf, &quot;s,&quot;);</a>
<a name="ln1440">                }</a>
<a name="ln1441">                if (i &amp; 4) {</a>
<a name="ln1442">                  STRCAT(errbuf, &quot;h,l,&quot;);</a>
<a name="ln1443">                }</a>
<a name="ln1444">                if (i &amp; 8) {</a>
<a name="ln1445">                  STRCAT(errbuf, &quot;&lt;,&gt;,&quot;);</a>
<a name="ln1446">                }</a>
<a name="ln1447">                if (i &amp; 16) {</a>
<a name="ln1448">                  STRCAT(errbuf, &quot;[,],&quot;);</a>
<a name="ln1449">                }</a>
<a name="ln1450">                if (*errbuf != NUL) {                   // remove trailing ,</a>
<a name="ln1451">                  errbuf[STRLEN(errbuf) - 1] = NUL;</a>
<a name="ln1452">                }</a>
<a name="ln1453">                save_arg = arg;</a>
<a name="ln1454">                arg = errbuf;</a>
<a name="ln1455">              }</a>
<a name="ln1456">              /*</a>
<a name="ln1457">               * Remove '&gt;' before 'dir' and 'bdir', for</a>
<a name="ln1458">               * backwards compatibility with version 3.0</a>
<a name="ln1459">               */</a>
<a name="ln1460">              else if (  *arg == '&gt;'</a>
<a name="ln1461">                         &amp;&amp; (varp == (char_u *)&amp;p_dir</a>
<a name="ln1462">                             || varp == (char_u *)&amp;p_bdir)) {</a>
<a name="ln1463">                arg++;</a>
<a name="ln1464">              }</a>
<a name="ln1465"> </a>
<a name="ln1466">              /*</a>
<a name="ln1467">               * Copy the new string into allocated memory.</a>
<a name="ln1468">               * Can't use set_string_option_direct(), because</a>
<a name="ln1469">               * we need to remove the backslashes.</a>
<a name="ln1470">               */</a>
<a name="ln1471">              // get a bit too much</a>
<a name="ln1472">              newlen = (unsigned)STRLEN(arg) + 1;</a>
<a name="ln1473">              if (adding || prepending || removing) {</a>
<a name="ln1474">                newlen += (unsigned)STRLEN(origval) + 1;</a>
<a name="ln1475">              }</a>
<a name="ln1476">              newval = xmalloc(newlen);</a>
<a name="ln1477">              s = newval;</a>
<a name="ln1478"> </a>
<a name="ln1479">              /*</a>
<a name="ln1480">               * Copy the string, skip over escaped chars.</a>
<a name="ln1481">               * For WIN32 backslashes before normal</a>
<a name="ln1482">               * file name characters are not removed, and keep</a>
<a name="ln1483">               * backslash at start, for &quot;\\machine\path&quot;, but</a>
<a name="ln1484">               * do remove it for &quot;\\\\machine\\path&quot;.</a>
<a name="ln1485">               * The reverse is found in ExpandOldSetting().</a>
<a name="ln1486">               */</a>
<a name="ln1487">              while (*arg &amp;&amp; !ascii_iswhite(*arg)) {</a>
<a name="ln1488">                if (*arg == '\\' &amp;&amp; arg[1] != NUL</a>
<a name="ln1489">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln1490">                    &amp;&amp; !((flags &amp; P_EXPAND)</a>
<a name="ln1491">                         &amp;&amp; vim_isfilec(arg[1])</a>
<a name="ln1492">                         &amp;&amp; !ascii_iswhite(arg[1])</a>
<a name="ln1493">                         &amp;&amp; (arg[1] != '\\'</a>
<a name="ln1494">                             || (s == newval</a>
<a name="ln1495">                                 &amp;&amp; arg[2] != '\\')))</a>
<a name="ln1496">#endif</a>
<a name="ln1497">                    )</a>
<a name="ln1498">                  arg++;                        // remove backslash</a>
<a name="ln1499">                i = utfc_ptr2len(arg);</a>
<a name="ln1500">                if (i &gt; 1) {</a>
<a name="ln1501">                  // copy multibyte char</a>
<a name="ln1502">                  memmove(s, arg, (size_t)i);</a>
<a name="ln1503">                  arg += i;</a>
<a name="ln1504">                  s += i;</a>
<a name="ln1505">                } else {</a>
<a name="ln1506">                  *s++ = *arg++;</a>
<a name="ln1507">                }</a>
<a name="ln1508">              }</a>
<a name="ln1509">              *s = NUL;</a>
<a name="ln1510"> </a>
<a name="ln1511">              /*</a>
<a name="ln1512">               * Expand environment variables and ~.</a>
<a name="ln1513">               * Don't do it when adding without inserting a</a>
<a name="ln1514">               * comma.</a>
<a name="ln1515">               */</a>
<a name="ln1516">              if (!(adding || prepending || removing)</a>
<a name="ln1517">                  || (flags &amp; P_COMMA)) {</a>
<a name="ln1518">                s = option_expand(opt_idx, newval);</a>
<a name="ln1519">                if (s != NULL) {</a>
<a name="ln1520">                  xfree(newval);</a>
<a name="ln1521">                  newlen = (unsigned)STRLEN(s) + 1;</a>
<a name="ln1522">                  if (adding || prepending || removing) {</a>
<a name="ln1523">                    newlen += (unsigned)STRLEN(origval) + 1;</a>
<a name="ln1524">                  }</a>
<a name="ln1525">                  newval = xmalloc(newlen);</a>
<a name="ln1526">                  STRCPY(newval, s);</a>
<a name="ln1527">                }</a>
<a name="ln1528">              }</a>
<a name="ln1529"> </a>
<a name="ln1530">              /* locate newval[] in origval[] when removing it</a>
<a name="ln1531">               * and when adding to avoid duplicates */</a>
<a name="ln1532">              i = 0;                    // init for GCC</a>
<a name="ln1533">              if (removing || (flags &amp; P_NODUP)) {</a>
<a name="ln1534">                i = (int)STRLEN(newval);</a>
<a name="ln1535">                s = find_dup_item(origval, newval, flags);</a>
<a name="ln1536"> </a>
<a name="ln1537">                // do not add if already there</a>
<a name="ln1538">                if ((adding || prepending) &amp;&amp; s != NULL) {</a>
<a name="ln1539">                  prepending = false;</a>
<a name="ln1540">                  adding = false;</a>
<a name="ln1541">                  STRCPY(newval, origval);</a>
<a name="ln1542">                }</a>
<a name="ln1543"> </a>
<a name="ln1544">                // if no duplicate, move pointer to end of</a>
<a name="ln1545">                // original value</a>
<a name="ln1546">                if (s == NULL) {</a>
<a name="ln1547">                  s = origval + (int)STRLEN(origval);</a>
<a name="ln1548">                }</a>
<a name="ln1549">              }</a>
<a name="ln1550"> </a>
<a name="ln1551">              /* concatenate the two strings; add a ',' if</a>
<a name="ln1552">               * needed */</a>
<a name="ln1553">              if (adding || prepending) {</a>
<a name="ln1554">                comma = ((flags &amp; P_COMMA) &amp;&amp; *origval != NUL</a>
<a name="ln1555">                         &amp;&amp; *newval != NUL);</a>
<a name="ln1556">                if (adding) {</a>
<a name="ln1557">                  i = (int)STRLEN(origval);</a>
<a name="ln1558">                  // Strip a trailing comma, would get 2.</a>
<a name="ln1559">                  if (comma &amp;&amp; i &gt; 1</a>
<a name="ln1560">                      &amp;&amp; (flags &amp; P_ONECOMMA) == P_ONECOMMA</a>
<a name="ln1561">                      &amp;&amp; origval[i - 1] == ','</a>
<a name="ln1562">                      &amp;&amp; origval[i - 2] != '\\') {</a>
<a name="ln1563">                    i--;</a>
<a name="ln1564">                  }</a>
<a name="ln1565">                  memmove(newval + i + comma, newval,</a>
<a name="ln1566">                      STRLEN(newval) + 1);</a>
<a name="ln1567">                  memmove(newval, origval, (size_t)i);</a>
<a name="ln1568">                } else {</a>
<a name="ln1569">                  i = (int)STRLEN(newval);</a>
<a name="ln1570">                  STRMOVE(newval + i + comma, origval);</a>
<a name="ln1571">                }</a>
<a name="ln1572">                if (comma) {</a>
<a name="ln1573">                  newval[i] = ',';</a>
<a name="ln1574">                }</a>
<a name="ln1575">              }</a>
<a name="ln1576"> </a>
<a name="ln1577">              /* Remove newval[] from origval[]. (Note: &quot;i&quot; has</a>
<a name="ln1578">               * been set above and is used here). */</a>
<a name="ln1579">              if (removing) {</a>
<a name="ln1580">                STRCPY(newval, origval);</a>
<a name="ln1581">                if (*s) {</a>
<a name="ln1582">                  // may need to remove a comma</a>
<a name="ln1583">                  if (flags &amp; P_COMMA) {</a>
<a name="ln1584">                    if (s == origval) {</a>
<a name="ln1585">                      // include comma after string</a>
<a name="ln1586">                      if (s[i] == ',') {</a>
<a name="ln1587">                        i++;</a>
<a name="ln1588">                      }</a>
<a name="ln1589">                    } else {</a>
<a name="ln1590">                      // include comma before string</a>
<a name="ln1591">                      s--;</a>
<a name="ln1592">                      i++;</a>
<a name="ln1593">                    }</a>
<a name="ln1594">                  }</a>
<a name="ln1595">                  STRMOVE(newval + (s - origval), s + i);</a>
<a name="ln1596">                }</a>
<a name="ln1597">              }</a>
<a name="ln1598"> </a>
<a name="ln1599">              if (flags &amp; P_FLAGLIST) {</a>
<a name="ln1600">                // Remove flags that appear twice.</a>
<a name="ln1601">                for (s = newval; *s;) {</a>
<a name="ln1602">                  // if options have P_FLAGLIST and P_ONECOMMA such as</a>
<a name="ln1603">                  // 'whichwrap'</a>
<a name="ln1604">                  if (flags &amp; P_ONECOMMA) {</a>
<a name="ln1605">                    if (*s != ',' &amp;&amp; *(s + 1) == ','</a>
<a name="ln1606">                        &amp;&amp; vim_strchr(s + 2, *s) != NULL) {</a>
<a name="ln1607">                      // Remove the duplicated value and the next comma.</a>
<a name="ln1608">                      STRMOVE(s, s + 2);</a>
<a name="ln1609">                      continue;</a>
<a name="ln1610">                    }</a>
<a name="ln1611">                  } else {</a>
<a name="ln1612">                    if ((!(flags &amp; P_COMMA) || *s != ',')</a>
<a name="ln1613">                        &amp;&amp; vim_strchr(s + 1, *s) != NULL) {</a>
<a name="ln1614">                      STRMOVE(s, s + 1);</a>
<a name="ln1615">                      continue;</a>
<a name="ln1616">                    }</a>
<a name="ln1617">                  }</a>
<a name="ln1618">                  s++;</a>
<a name="ln1619">                }</a>
<a name="ln1620">              }</a>
<a name="ln1621"> </a>
<a name="ln1622">              if (save_arg != NULL) {               // number for 'whichwrap'</a>
<a name="ln1623">                arg = save_arg;</a>
<a name="ln1624">              }</a>
<a name="ln1625">              new_value_alloced = true;</a>
<a name="ln1626">            }</a>
<a name="ln1627"> </a>
<a name="ln1628">            // Set the new value.</a>
<a name="ln1629">            *(char_u **)(varp) = newval;</a>
<a name="ln1630"> </a>
<a name="ln1631">            // origval may be freed by</a>
<a name="ln1632">            // did_set_string_option(), make a copy.</a>
<a name="ln1633">            saved_origval = (origval != NULL) ? xstrdup((char *)origval) : 0;</a>
<a name="ln1634"> </a>
<a name="ln1635">            // newval (and varp) may become invalid if the</a>
<a name="ln1636">            // buffer is closed by autocommands.</a>
<a name="ln1637">            saved_newval = (newval != NULL) ? xstrdup((char *)newval) : 0;</a>
<a name="ln1638"> </a>
<a name="ln1639">            {</a>
<a name="ln1640">              uint32_t *p = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln1641">              const int secure_saved = secure;</a>
<a name="ln1642"> </a>
<a name="ln1643">              // When an option is set in the sandbox, from a</a>
<a name="ln1644">              // modeline or in secure mode, then deal with side</a>
<a name="ln1645">              // effects in secure mode.  Also when the value was</a>
<a name="ln1646">              // set with the P_INSECURE flag and is not</a>
<a name="ln1647">              // completely replaced.</a>
<a name="ln1648">              if ((opt_flags &amp; OPT_MODELINE)</a>
<a name="ln1649">                  || sandbox != 0</a>
<a name="ln1650">                  || (!value_is_replaced &amp;&amp; (*p &amp; P_INSECURE))) {</a>
<a name="ln1651">                secure = 1;</a>
<a name="ln1652">              }</a>
<a name="ln1653"> </a>
<a name="ln1654">              // Handle side effects, and set the global value</a>
<a name="ln1655">              // for &quot;:set&quot; on local options. Note: when setting</a>
<a name="ln1656">              // 'syntax' or 'filetype' autocommands may be</a>
<a name="ln1657">              // triggered that can cause havoc.</a>
<a name="ln1658">              errmsg = did_set_string_option(opt_idx, (char_u **)varp,</a>
<a name="ln1659">                                             new_value_alloced, oldval,</a>
<a name="ln1660">                                             errbuf, sizeof(errbuf),</a>
<a name="ln1661">                                             opt_flags, &amp;value_checked);</a>
<a name="ln1662"> </a>
<a name="ln1663">              secure = secure_saved;</a>
<a name="ln1664">            }</a>
<a name="ln1665"> </a>
<a name="ln1666">            if (errmsg == NULL) {</a>
<a name="ln1667">              if (!starting) {</a>
<a name="ln1668">                trigger_optionsset_string(opt_idx, opt_flags, saved_origval,</a>
<a name="ln1669">                                          saved_newval);</a>
<a name="ln1670">              }</a>
<a name="ln1671">              if (options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln1672">                ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln1673">                                   STRING_OBJ(cstr_as_string(saved_newval)));</a>
<a name="ln1674">              }</a>
<a name="ln1675">            }</a>
<a name="ln1676">            xfree(saved_origval);</a>
<a name="ln1677">            xfree(saved_newval);</a>
<a name="ln1678"> </a>
<a name="ln1679">            // If error detected, print the error message.</a>
<a name="ln1680">            if (errmsg != NULL) {</a>
<a name="ln1681">              goto skip;</a>
<a name="ln1682">            }</a>
<a name="ln1683"> </a>
<a name="ln1684">          } else {</a>
<a name="ln1685">            // key code option(FIXME(tarruda): Show a warning or something</a>
<a name="ln1686">            // similar)</a>
<a name="ln1687">          }</a>
<a name="ln1688">        }</a>
<a name="ln1689"> </a>
<a name="ln1690">        if (opt_idx &gt;= 0) {</a>
<a name="ln1691">          did_set_option(opt_idx, opt_flags, value_is_replaced, value_checked);</a>
<a name="ln1692">        }</a>
<a name="ln1693">      }</a>
<a name="ln1694"> </a>
<a name="ln1695">skip:</a>
<a name="ln1696">      /*</a>
<a name="ln1697">       * Advance to next argument.</a>
<a name="ln1698">       * - skip until a blank found, taking care of backslashes</a>
<a name="ln1699">       * - skip blanks</a>
<a name="ln1700">       * - skip one &quot;=val&quot; argument (for hidden options &quot;:set gfn =xx&quot;)</a>
<a name="ln1701">       */</a>
<a name="ln1702">      for (i = 0; i &lt; 2; i++) {</a>
<a name="ln1703">        while (*arg != NUL &amp;&amp; !ascii_iswhite(*arg)) {</a>
<a name="ln1704">          if (*arg++ == '\\' &amp;&amp; *arg != NUL) {</a>
<a name="ln1705">            arg++;</a>
<a name="ln1706">          }</a>
<a name="ln1707">        }</a>
<a name="ln1708">        arg = skipwhite(arg);</a>
<a name="ln1709">        if (*arg != '=') {</a>
<a name="ln1710">          break;</a>
<a name="ln1711">        }</a>
<a name="ln1712">      }</a>
<a name="ln1713">    }</a>
<a name="ln1714"> </a>
<a name="ln1715">    if (errmsg != NULL) {</a>
<a name="ln1716">      STRLCPY(IObuff, _(errmsg), IOSIZE);</a>
<a name="ln1717">      i = (int)STRLEN(IObuff) + 2;</a>
<a name="ln1718">      if (i + (arg - startarg) &lt; IOSIZE) {</a>
<a name="ln1719">        // append the argument with the error</a>
<a name="ln1720">        STRCAT(IObuff, &quot;: &quot;);</a>
<a name="ln1721">        assert(arg &gt;= startarg);</a>
<a name="ln1722">        memmove(IObuff + i, startarg, (size_t)(arg - startarg));</a>
<a name="ln1723">        IObuff[i + (arg - startarg)] = NUL;</a>
<a name="ln1724">      }</a>
<a name="ln1725">      // make sure all characters are printable</a>
<a name="ln1726">      trans_characters(IObuff, IOSIZE);</a>
<a name="ln1727"> </a>
<a name="ln1728">      no_wait_return++;         // wait_return done later</a>
<a name="ln1729">      emsg(IObuff);             // show error highlighted</a>
<a name="ln1730">      no_wait_return--;</a>
<a name="ln1731"> </a>
<a name="ln1732">      return FAIL;</a>
<a name="ln1733">    }</a>
<a name="ln1734"> </a>
<a name="ln1735">    arg = skipwhite(arg);</a>
<a name="ln1736">  }</a>
<a name="ln1737"> </a>
<a name="ln1738">theend:</a>
<a name="ln1739">  if (silent_mode &amp;&amp; did_show) {</a>
<a name="ln1740">    // After displaying option values in silent mode.</a>
<a name="ln1741">    silent_mode = false;</a>
<a name="ln1742">    info_message = true;        // use mch_msg(), not mch_errmsg()</a>
<a name="ln1743">    msg_putchar('\n');</a>
<a name="ln1744">    ui_flush();</a>
<a name="ln1745">    silent_mode = true;</a>
<a name="ln1746">    info_message = false;       // use mch_msg(), not mch_errmsg()</a>
<a name="ln1747">  }</a>
<a name="ln1748"> </a>
<a name="ln1749">  return OK;</a>
<a name="ln1750">}</a>
<a name="ln1751"> </a>
<a name="ln1752">// Call this when an option has been given a new value through a user command.</a>
<a name="ln1753">// Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.</a>
<a name="ln1754">static void did_set_option(</a>
<a name="ln1755">    int opt_idx,</a>
<a name="ln1756">    int opt_flags,              // possibly with OPT_MODELINE</a>
<a name="ln1757">    int new_value,              // value was replaced completely</a>
<a name="ln1758">    int value_checked           // value was checked to be safe, no need to</a>
<a name="ln1759">                                // set P_INSECURE</a>
<a name="ln1760">)</a>
<a name="ln1761">{</a>
<a name="ln1762">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln1763"> </a>
<a name="ln1764">  /* When an option is set in the sandbox, from a modeline or in secure mode</a>
<a name="ln1765">   * set the P_INSECURE flag.  Otherwise, if a new value is stored reset the</a>
<a name="ln1766">   * flag. */</a>
<a name="ln1767">  uint32_t *p = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln1768">  if (!value_checked &amp;&amp; (secure</a>
<a name="ln1769">                         || sandbox != 0</a>
<a name="ln1770">                         || (opt_flags &amp; OPT_MODELINE))) {</a>
<a name="ln1771">    *p = *p | P_INSECURE;</a>
<a name="ln1772">  } else if (new_value) {</a>
<a name="ln1773">    *p = *p &amp; ~P_INSECURE;</a>
<a name="ln1774">  }</a>
<a name="ln1775">}</a>
<a name="ln1776"> </a>
<a name="ln1777">static char_u *illegal_char(char_u *errbuf, size_t errbuflen, int c)</a>
<a name="ln1778">{</a>
<a name="ln1779">  if (errbuf == NULL) {</a>
<a name="ln1780">    return (char_u *)&quot;&quot;;</a>
<a name="ln1781">  }</a>
<a name="ln1782">  vim_snprintf((char *)errbuf, errbuflen, _(&quot;E539: Illegal character &lt;%s&gt;&quot;),</a>
<a name="ln1783">               (char *)transchar(c));</a>
<a name="ln1784">  return errbuf;</a>
<a name="ln1785">}</a>
<a name="ln1786"> </a>
<a name="ln1787">/// Convert a key name or string into a key value.</a>
<a name="ln1788">/// Used for 'wildchar' and 'cedit' options.</a>
<a name="ln1789">static int string_to_key(char_u *arg)</a>
<a name="ln1790">{</a>
<a name="ln1791">  if (*arg == '&lt;') {</a>
<a name="ln1792">    return find_key_option(arg + 1, true);</a>
<a name="ln1793">  }</a>
<a name="ln1794">  if (*arg == '^') {</a>
<a name="ln1795">    return Ctrl_chr(arg[1]);</a>
<a name="ln1796">  }</a>
<a name="ln1797">  return *arg;</a>
<a name="ln1798">}</a>
<a name="ln1799"> </a>
<a name="ln1800">/// Check value of 'cedit' and set cedit_key.</a>
<a name="ln1801">/// Returns NULL if value is OK, error message otherwise.</a>
<a name="ln1802">static char_u *check_cedit(void)</a>
<a name="ln1803">{</a>
<a name="ln1804">  int n;</a>
<a name="ln1805"> </a>
<a name="ln1806">  if (*p_cedit == NUL) {</a>
<a name="ln1807">    cedit_key = -1;</a>
<a name="ln1808">  } else {</a>
<a name="ln1809">    n = string_to_key(p_cedit);</a>
<a name="ln1810">    if (vim_isprintc(n)) {</a>
<a name="ln1811">      return e_invarg;</a>
<a name="ln1812">    }</a>
<a name="ln1813">    cedit_key = n;</a>
<a name="ln1814">  }</a>
<a name="ln1815">  return NULL;</a>
<a name="ln1816">}</a>
<a name="ln1817"> </a>
<a name="ln1818">// When changing 'title', 'titlestring', 'icon' or 'iconstring', call</a>
<a name="ln1819">// maketitle() to create and display it.</a>
<a name="ln1820">// When switching the title or icon off, call ui_set_{icon,title}(NULL) to get</a>
<a name="ln1821">// the old value back.</a>
<a name="ln1822">static void did_set_title(void)</a>
<a name="ln1823">{</a>
<a name="ln1824">  if (starting != NO_SCREEN) {</a>
<a name="ln1825">    maketitle();</a>
<a name="ln1826">  }</a>
<a name="ln1827">}</a>
<a name="ln1828"> </a>
<a name="ln1829">// set_options_bin -  called when 'bin' changes value.</a>
<a name="ln1830">void set_options_bin(</a>
<a name="ln1831">    int oldval,</a>
<a name="ln1832">    int newval,</a>
<a name="ln1833">    int opt_flags                  // OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln1834">)</a>
<a name="ln1835">{</a>
<a name="ln1836">  /*</a>
<a name="ln1837">   * The option values that are changed when 'bin' changes are</a>
<a name="ln1838">   * copied when 'bin is set and restored when 'bin' is reset.</a>
<a name="ln1839">   */</a>
<a name="ln1840">  if (newval) {</a>
<a name="ln1841">    if (!oldval) {              // switched on</a>
<a name="ln1842">      if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1843">        curbuf-&gt;b_p_tw_nobin = curbuf-&gt;b_p_tw;</a>
<a name="ln1844">        curbuf-&gt;b_p_wm_nobin = curbuf-&gt;b_p_wm;</a>
<a name="ln1845">        curbuf-&gt;b_p_ml_nobin = curbuf-&gt;b_p_ml;</a>
<a name="ln1846">        curbuf-&gt;b_p_et_nobin = curbuf-&gt;b_p_et;</a>
<a name="ln1847">      }</a>
<a name="ln1848">      if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1849">        p_tw_nobin = p_tw;</a>
<a name="ln1850">        p_wm_nobin = p_wm;</a>
<a name="ln1851">        p_ml_nobin = p_ml;</a>
<a name="ln1852">        p_et_nobin = p_et;</a>
<a name="ln1853">      }</a>
<a name="ln1854">    }</a>
<a name="ln1855"> </a>
<a name="ln1856">    if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1857">      curbuf-&gt;b_p_tw = 0;       // no automatic line wrap</a>
<a name="ln1858">      curbuf-&gt;b_p_wm = 0;       // no automatic line wrap</a>
<a name="ln1859">      curbuf-&gt;b_p_ml = 0;       // no modelines</a>
<a name="ln1860">      curbuf-&gt;b_p_et = 0;       // no expandtab</a>
<a name="ln1861">    }</a>
<a name="ln1862">    if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1863">      p_tw = 0;</a>
<a name="ln1864">      p_wm = 0;</a>
<a name="ln1865">      p_ml = false;</a>
<a name="ln1866">      p_et = false;</a>
<a name="ln1867">      p_bin = true;             // needed when called for the &quot;-b&quot; argument</a>
<a name="ln1868">    }</a>
<a name="ln1869">  } else if (oldval) {        // switched off</a>
<a name="ln1870">    if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1871">      curbuf-&gt;b_p_tw = curbuf-&gt;b_p_tw_nobin;</a>
<a name="ln1872">      curbuf-&gt;b_p_wm = curbuf-&gt;b_p_wm_nobin;</a>
<a name="ln1873">      curbuf-&gt;b_p_ml = curbuf-&gt;b_p_ml_nobin;</a>
<a name="ln1874">      curbuf-&gt;b_p_et = curbuf-&gt;b_p_et_nobin;</a>
<a name="ln1875">    }</a>
<a name="ln1876">    if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1877">      p_tw = p_tw_nobin;</a>
<a name="ln1878">      p_wm = p_wm_nobin;</a>
<a name="ln1879">      p_ml = p_ml_nobin;</a>
<a name="ln1880">      p_et = p_et_nobin;</a>
<a name="ln1881">    }</a>
<a name="ln1882">  }</a>
<a name="ln1883">}</a>
<a name="ln1884"> </a>
<a name="ln1885">/// Find the parameter represented by the given character (eg ', :, &quot;, or /),</a>
<a name="ln1886">/// and return its associated value in the 'shada' string.</a>
<a name="ln1887">/// Only works for number parameters, not for 'r' or 'n'.</a>
<a name="ln1888">/// If the parameter is not specified in the string or there is no following</a>
<a name="ln1889">/// number, return -1.</a>
<a name="ln1890">int get_shada_parameter(int type)</a>
<a name="ln1891">{</a>
<a name="ln1892">  char_u  *p;</a>
<a name="ln1893"> </a>
<a name="ln1894">  p = find_shada_parameter(type);</a>
<a name="ln1895">  if (p != NULL &amp;&amp; ascii_isdigit(*p)) {</a>
<a name="ln1896">    return atoi((char *)p);</a>
<a name="ln1897">  }</a>
<a name="ln1898">  return -1;</a>
<a name="ln1899">}</a>
<a name="ln1900"> </a>
<a name="ln1901">/// Find the parameter represented by the given character (eg ''', ':', '&quot;', or</a>
<a name="ln1902">/// '/') in the 'shada' option and return a pointer to the string after it.</a>
<a name="ln1903">/// Return NULL if the parameter is not specified in the string.</a>
<a name="ln1904">char_u *find_shada_parameter(int type)</a>
<a name="ln1905">{</a>
<a name="ln1906">  char_u  *p;</a>
<a name="ln1907"> </a>
<a name="ln1908">  for (p = p_shada; *p; p++) {</a>
<a name="ln1909">    if (*p == type) {</a>
<a name="ln1910">      return p + 1;</a>
<a name="ln1911">    }</a>
<a name="ln1912">    if (*p == 'n') {                // 'n' is always the last one</a>
<a name="ln1913">      break;</a>
<a name="ln1914">    }</a>
<a name="ln1915">    p = vim_strchr(p, ',');         // skip until next ','</a>
<a name="ln1916">    if (p == NULL) {                // hit the end without finding parameter</a>
<a name="ln1917">      break;</a>
<a name="ln1918">    }</a>
<a name="ln1919">  }</a>
<a name="ln1920">  return NULL;</a>
<a name="ln1921">}</a>
<a name="ln1922"> </a>
<a name="ln1923">/// Expand environment variables for some string options.</a>
<a name="ln1924">/// These string options cannot be indirect!</a>
<a name="ln1925">/// If &quot;val&quot; is NULL expand the current value of the option.</a>
<a name="ln1926">/// Return pointer to NameBuff, or NULL when not expanded.</a>
<a name="ln1927">static char_u *option_expand(int opt_idx, char_u *val)</a>
<a name="ln1928">{</a>
<a name="ln1929">  // if option doesn't need expansion nothing to do</a>
<a name="ln1930">  if (!(options[opt_idx].flags &amp; P_EXPAND) || options[opt_idx].var == NULL) {</a>
<a name="ln1931">    return NULL;</a>
<a name="ln1932">  }</a>
<a name="ln1933"> </a>
<a name="ln1934">  if (val == NULL) {</a>
<a name="ln1935">    val = *(char_u **)options[opt_idx].var;</a>
<a name="ln1936">  }</a>
<a name="ln1937"> </a>
<a name="ln1938">  // If val is longer than MAXPATHL no meaningful expansion can be done,</a>
<a name="ln1939">  // expand_env() would truncate the string.</a>
<a name="ln1940">  if (val == NULL || STRLEN(val) &gt; MAXPATHL) {</a>
<a name="ln1941">    return NULL;</a>
<a name="ln1942">  }</a>
<a name="ln1943"> </a>
<a name="ln1944">  /*</a>
<a name="ln1945">   * Expanding this with NameBuff, expand_env() must not be passed IObuff.</a>
<a name="ln1946">   * Escape spaces when expanding 'tags', they are used to separate file</a>
<a name="ln1947">   * names.</a>
<a name="ln1948">   * For 'spellsuggest' expand after &quot;file:&quot;.</a>
<a name="ln1949">   */</a>
<a name="ln1950">  expand_env_esc(val, NameBuff, MAXPATHL,</a>
<a name="ln1951">                 (char_u **)options[opt_idx].var == &amp;p_tags, false,</a>
<a name="ln1952">                 (char_u **)options[opt_idx].var == &amp;p_sps ? (char_u *)&quot;file:&quot; :</a>
<a name="ln1953">                 NULL);</a>
<a name="ln1954">  if (STRCMP(NameBuff, val) == 0) {   // they are the same</a>
<a name="ln1955">    return NULL;</a>
<a name="ln1956">  }</a>
<a name="ln1957"> </a>
<a name="ln1958">  return NameBuff;</a>
<a name="ln1959">}</a>
<a name="ln1960"> </a>
<a name="ln1961">// After setting various option values: recompute variables that depend on</a>
<a name="ln1962">// option values.</a>
<a name="ln1963">static void didset_options(void)</a>
<a name="ln1964">{</a>
<a name="ln1965">  // initialize the table for 'iskeyword' et.al.</a>
<a name="ln1966">  (void)init_chartab();</a>
<a name="ln1967"> </a>
<a name="ln1968">  (void)opt_strings_flags(p_cmp, p_cmp_values, &amp;cmp_flags, true);</a>
<a name="ln1969">  (void)opt_strings_flags(p_bkc, p_bkc_values, &amp;bkc_flags, true);</a>
<a name="ln1970">  (void)opt_strings_flags(p_bo, p_bo_values, &amp;bo_flags, true);</a>
<a name="ln1971">  (void)opt_strings_flags(p_ssop, p_ssop_values, &amp;ssop_flags, true);</a>
<a name="ln1972">  (void)opt_strings_flags(p_vop, p_ssop_values, &amp;vop_flags, true);</a>
<a name="ln1973">  (void)opt_strings_flags(p_fdo, p_fdo_values, &amp;fdo_flags, true);</a>
<a name="ln1974">  (void)opt_strings_flags(p_dy, p_dy_values, &amp;dy_flags, true);</a>
<a name="ln1975">  (void)opt_strings_flags(p_rdb, p_rdb_values, &amp;rdb_flags, true);</a>
<a name="ln1976">  (void)opt_strings_flags(p_tc, p_tc_values, &amp;tc_flags, false);</a>
<a name="ln1977">  (void)opt_strings_flags(p_tpf, p_tpf_values, &amp;tpf_flags, true);</a>
<a name="ln1978">  (void)opt_strings_flags(p_ve, p_ve_values, &amp;ve_flags, true);</a>
<a name="ln1979">  (void)opt_strings_flags(p_wop, p_wop_values, &amp;wop_flags, true);</a>
<a name="ln1980">  (void)opt_strings_flags(p_jop, p_jop_values, &amp;jop_flags, true);</a>
<a name="ln1981">  (void)spell_check_msm();</a>
<a name="ln1982">  (void)spell_check_sps();</a>
<a name="ln1983">  (void)compile_cap_prog(curwin-&gt;w_s);</a>
<a name="ln1984">  (void)did_set_spell_option(true);</a>
<a name="ln1985">  // set cedit_key</a>
<a name="ln1986">  (void)check_cedit();</a>
<a name="ln1987">  briopt_check(curwin);</a>
<a name="ln1988">  // initialize the table for 'breakat'.</a>
<a name="ln1989">  fill_breakat_flags();</a>
<a name="ln1990">}</a>
<a name="ln1991"> </a>
<a name="ln1992">// More side effects of setting options.</a>
<a name="ln1993">static void didset_options2(void)</a>
<a name="ln1994">{</a>
<a name="ln1995">  // Initialize the highlight_attr[] table.</a>
<a name="ln1996">  highlight_changed();</a>
<a name="ln1997"> </a>
<a name="ln1998">  // Parse default for 'clipboard'.</a>
<a name="ln1999">  (void)opt_strings_flags(p_cb, p_cb_values, &amp;cb_flags, true);</a>
<a name="ln2000"> </a>
<a name="ln2001">  // Parse default for 'fillchars'.</a>
<a name="ln2002">  (void)set_chars_option(curwin, &amp;curwin-&gt;w_p_fcs, true);</a>
<a name="ln2003"> </a>
<a name="ln2004">  // Parse default for 'listchars'.</a>
<a name="ln2005">  (void)set_chars_option(curwin, &amp;curwin-&gt;w_p_lcs, true);</a>
<a name="ln2006"> </a>
<a name="ln2007">  // Parse default for 'wildmode'.</a>
<a name="ln2008">  check_opt_wim();</a>
<a name="ln2009">  xfree(curbuf-&gt;b_p_vsts_array);</a>
<a name="ln2010">  tabstop_set(curbuf-&gt;b_p_vsts, &amp;curbuf-&gt;b_p_vsts_array);</a>
<a name="ln2011">  xfree(curbuf-&gt;b_p_vts_array);</a>
<a name="ln2012">  tabstop_set(curbuf-&gt;b_p_vts,  &amp;curbuf-&gt;b_p_vts_array);</a>
<a name="ln2013">}</a>
<a name="ln2014"> </a>
<a name="ln2015">/// Check for string options that are NULL (normally only termcap options).</a>
<a name="ln2016">void check_options(void)</a>
<a name="ln2017">{</a>
<a name="ln2018">  int opt_idx;</a>
<a name="ln2019"> </a>
<a name="ln2020">  for (opt_idx = 0; options[opt_idx].fullname != NULL; opt_idx++) {</a>
<a name="ln2021">    if ((options[opt_idx].flags &amp; P_STRING) &amp;&amp; options[opt_idx].var != NULL) {</a>
<a name="ln2022">      check_string_option((char_u **)get_varp(&amp;(options[opt_idx])));</a>
<a name="ln2023">    }</a>
<a name="ln2024">  }</a>
<a name="ln2025">}</a>
<a name="ln2026"> </a>
<a name="ln2027">/// Check string options in a buffer for NULL value.</a>
<a name="ln2028">void check_buf_options(buf_T *buf)</a>
<a name="ln2029">{</a>
<a name="ln2030">  check_string_option(&amp;buf-&gt;b_p_bh);</a>
<a name="ln2031">  check_string_option(&amp;buf-&gt;b_p_bt);</a>
<a name="ln2032">  check_string_option(&amp;buf-&gt;b_p_fenc);</a>
<a name="ln2033">  check_string_option(&amp;buf-&gt;b_p_ff);</a>
<a name="ln2034">  check_string_option(&amp;buf-&gt;b_p_def);</a>
<a name="ln2035">  check_string_option(&amp;buf-&gt;b_p_inc);</a>
<a name="ln2036">  check_string_option(&amp;buf-&gt;b_p_inex);</a>
<a name="ln2037">  check_string_option(&amp;buf-&gt;b_p_inde);</a>
<a name="ln2038">  check_string_option(&amp;buf-&gt;b_p_indk);</a>
<a name="ln2039">  check_string_option(&amp;buf-&gt;b_p_fp);</a>
<a name="ln2040">  check_string_option(&amp;buf-&gt;b_p_fex);</a>
<a name="ln2041">  check_string_option(&amp;buf-&gt;b_p_kp);</a>
<a name="ln2042">  check_string_option(&amp;buf-&gt;b_p_mps);</a>
<a name="ln2043">  check_string_option(&amp;buf-&gt;b_p_fo);</a>
<a name="ln2044">  check_string_option(&amp;buf-&gt;b_p_flp);</a>
<a name="ln2045">  check_string_option(&amp;buf-&gt;b_p_isk);</a>
<a name="ln2046">  check_string_option(&amp;buf-&gt;b_p_com);</a>
<a name="ln2047">  check_string_option(&amp;buf-&gt;b_p_cms);</a>
<a name="ln2048">  check_string_option(&amp;buf-&gt;b_p_nf);</a>
<a name="ln2049">  check_string_option(&amp;buf-&gt;b_p_qe);</a>
<a name="ln2050">  check_string_option(&amp;buf-&gt;b_p_syn);</a>
<a name="ln2051">  check_string_option(&amp;buf-&gt;b_s.b_syn_isk);</a>
<a name="ln2052">  check_string_option(&amp;buf-&gt;b_s.b_p_spc);</a>
<a name="ln2053">  check_string_option(&amp;buf-&gt;b_s.b_p_spf);</a>
<a name="ln2054">  check_string_option(&amp;buf-&gt;b_s.b_p_spl);</a>
<a name="ln2055">  check_string_option(&amp;buf-&gt;b_s.b_p_spo);</a>
<a name="ln2056">  check_string_option(&amp;buf-&gt;b_p_sua);</a>
<a name="ln2057">  check_string_option(&amp;buf-&gt;b_p_cink);</a>
<a name="ln2058">  check_string_option(&amp;buf-&gt;b_p_cino);</a>
<a name="ln2059">  parse_cino(buf);</a>
<a name="ln2060">  check_string_option(&amp;buf-&gt;b_p_ft);</a>
<a name="ln2061">  check_string_option(&amp;buf-&gt;b_p_cinw);</a>
<a name="ln2062">  check_string_option(&amp;buf-&gt;b_p_cpt);</a>
<a name="ln2063">  check_string_option(&amp;buf-&gt;b_p_cfu);</a>
<a name="ln2064">  check_string_option(&amp;buf-&gt;b_p_ofu);</a>
<a name="ln2065">  check_string_option(&amp;buf-&gt;b_p_keymap);</a>
<a name="ln2066">  check_string_option(&amp;buf-&gt;b_p_gp);</a>
<a name="ln2067">  check_string_option(&amp;buf-&gt;b_p_mp);</a>
<a name="ln2068">  check_string_option(&amp;buf-&gt;b_p_efm);</a>
<a name="ln2069">  check_string_option(&amp;buf-&gt;b_p_ep);</a>
<a name="ln2070">  check_string_option(&amp;buf-&gt;b_p_path);</a>
<a name="ln2071">  check_string_option(&amp;buf-&gt;b_p_tags);</a>
<a name="ln2072">  check_string_option(&amp;buf-&gt;b_p_tfu);</a>
<a name="ln2073">  check_string_option(&amp;buf-&gt;b_p_tc);</a>
<a name="ln2074">  check_string_option(&amp;buf-&gt;b_p_dict);</a>
<a name="ln2075">  check_string_option(&amp;buf-&gt;b_p_tsr);</a>
<a name="ln2076">  check_string_option(&amp;buf-&gt;b_p_lw);</a>
<a name="ln2077">  check_string_option(&amp;buf-&gt;b_p_bkc);</a>
<a name="ln2078">  check_string_option(&amp;buf-&gt;b_p_menc);</a>
<a name="ln2079">  check_string_option(&amp;buf-&gt;b_p_vsts);</a>
<a name="ln2080">  check_string_option(&amp;buf-&gt;b_p_vts);</a>
<a name="ln2081">}</a>
<a name="ln2082"> </a>
<a name="ln2083">/// Free the string allocated for an option.</a>
<a name="ln2084">/// Checks for the string being empty_option. This may happen if we're out of</a>
<a name="ln2085">/// memory, vim_strsave() returned NULL, which was replaced by empty_option by</a>
<a name="ln2086">/// check_options().</a>
<a name="ln2087">/// Does NOT check for P_ALLOCED flag!</a>
<a name="ln2088">void free_string_option(char_u *p)</a>
<a name="ln2089">{</a>
<a name="ln2090">  if (p != empty_option) {</a>
<a name="ln2091">    xfree(p);</a>
<a name="ln2092">  }</a>
<a name="ln2093">}</a>
<a name="ln2094"> </a>
<a name="ln2095">void clear_string_option(char_u **pp)</a>
<a name="ln2096">{</a>
<a name="ln2097">  if (*pp != empty_option) {</a>
<a name="ln2098">    xfree(*pp);</a>
<a name="ln2099">  }</a>
<a name="ln2100">  *pp = empty_option;</a>
<a name="ln2101">}</a>
<a name="ln2102"> </a>
<a name="ln2103">static void check_string_option(char_u **pp)</a>
<a name="ln2104">{</a>
<a name="ln2105">  if (*pp == NULL) {</a>
<a name="ln2106">    *pp = empty_option;</a>
<a name="ln2107">  }</a>
<a name="ln2108">}</a>
<a name="ln2109"> </a>
<a name="ln2110">/// Return true when option &quot;opt&quot; was set from a modeline or in secure mode.</a>
<a name="ln2111">/// Return false when it wasn't.</a>
<a name="ln2112">/// Return -1 for an unknown option.</a>
<a name="ln2113">int was_set_insecurely(win_T *const wp, char_u *opt, int opt_flags)</a>
<a name="ln2114">{</a>
<a name="ln2115">  int idx = findoption((const char *)opt);</a>
<a name="ln2116"> </a>
<a name="ln2117">  if (idx &gt;= 0) {</a>
<a name="ln2118">    uint32_t *flagp = insecure_flag(wp, idx, opt_flags);</a>
<a name="ln2119">    return (*flagp &amp; P_INSECURE) != 0;</a>
<a name="ln2120">  }</a>
<a name="ln2121">  internal_error(&quot;was_set_insecurely()&quot;);</a>
<a name="ln2122">  return -1;</a>
<a name="ln2123">}</a>
<a name="ln2124"> </a>
<a name="ln2125">/// Get a pointer to the flags used for the P_INSECURE flag of option</a>
<a name="ln2126">/// &quot;opt_idx&quot;.  For some local options a local flags field is used.</a>
<a name="ln2127">/// NOTE: Caller must make sure that &quot;wp&quot; is set to the window from which</a>
<a name="ln2128">/// the option is used.</a>
<a name="ln2129">static uint32_t *insecure_flag(win_T *const wp, int opt_idx, int opt_flags)</a>
<a name="ln2130">{</a>
<a name="ln2131">  if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln2132">    assert(wp != NULL);</a>
<a name="ln2133">    switch ((int)options[opt_idx].indir) {</a>
<a name="ln2134">    case PV_STL:        return &amp;wp-&gt;w_p_stl_flags;</a>
<a name="ln2135">    case PV_FDE:        return &amp;wp-&gt;w_p_fde_flags;</a>
<a name="ln2136">    case PV_FDT:        return &amp;wp-&gt;w_p_fdt_flags;</a>
<a name="ln2137">    case PV_INDE:       return &amp;wp-&gt;w_buffer-&gt;b_p_inde_flags;</a>
<a name="ln2138">    case PV_FEX:        return &amp;wp-&gt;w_buffer-&gt;b_p_fex_flags;</a>
<a name="ln2139">    case PV_INEX:       return &amp;wp-&gt;w_buffer-&gt;b_p_inex_flags;</a>
<a name="ln2140">    }</a>
<a name="ln2141">  }</a>
<a name="ln2142"> </a>
<a name="ln2143">  // Nothing special, return global flags field.</a>
<a name="ln2144">  return &amp;options[opt_idx].flags;</a>
<a name="ln2145">}</a>
<a name="ln2146"> </a>
<a name="ln2147"> </a>
<a name="ln2148">/// Redraw the window title and/or tab page text later.</a>
<a name="ln2149">static void redraw_titles(void)</a>
<a name="ln2150">{</a>
<a name="ln2151">  need_maketitle = true;</a>
<a name="ln2152">  redraw_tabline = true;</a>
<a name="ln2153">}</a>
<a name="ln2154"> </a>
<a name="ln2155">static int shada_idx = -1;</a>
<a name="ln2156"> </a>
<a name="ln2157">// Set a string option to a new value (without checking the effect).</a>
<a name="ln2158">// The string is copied into allocated memory.</a>
<a name="ln2159">// if (&quot;opt_idx&quot; == -1) &quot;name&quot; is used, otherwise &quot;opt_idx&quot; is used.</a>
<a name="ln2160">// When &quot;set_sid&quot; is zero set the scriptID to current_sctx.sc_sid.  When</a>
<a name="ln2161">// &quot;set_sid&quot; is SID_NONE don't set the scriptID.  Otherwise set the scriptID to</a>
<a name="ln2162">// &quot;set_sid&quot;.</a>
<a name="ln2163">void</a>
<a name="ln2164">set_string_option_direct(</a>
<a name="ln2165">    const char *name,</a>
<a name="ln2166">    int opt_idx,</a>
<a name="ln2167">    const char_u *val,</a>
<a name="ln2168">    int opt_flags,                  // OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln2169">    int set_sid</a>
<a name="ln2170">)</a>
<a name="ln2171">{</a>
<a name="ln2172">  char_u      *s;</a>
<a name="ln2173">  char_u      **varp;</a>
<a name="ln2174">  int both = (opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0;</a>
<a name="ln2175">  int idx = opt_idx;</a>
<a name="ln2176"> </a>
<a name="ln2177">  if (idx == -1) {  // Use name.</a>
<a name="ln2178">    idx = findoption(name);</a>
<a name="ln2179">    if (idx &lt; 0) {  // Not found (should not happen).</a>
<a name="ln2180">      internal_error(&quot;set_string_option_direct()&quot;);</a>
<a name="ln2181">      IEMSG2(_(&quot;For option %s&quot;), name);</a>
<a name="ln2182">      return;</a>
<a name="ln2183">    }</a>
<a name="ln2184">  }</a>
<a name="ln2185"> </a>
<a name="ln2186">  if (options[idx].var == NULL) {       // can't set hidden option</a>
<a name="ln2187">    return;</a>
<a name="ln2188">  }</a>
<a name="ln2189"> </a>
<a name="ln2190">  assert((void *) options[idx].var != (void *) &amp;p_shada);</a>
<a name="ln2191"> </a>
<a name="ln2192">  s = vim_strsave(val);</a>
<a name="ln2193">  {</a>
<a name="ln2194">    varp = (char_u **)get_varp_scope(&amp;(options[idx]),</a>
<a name="ln2195">                                     both ? OPT_LOCAL : opt_flags);</a>
<a name="ln2196">    if ((opt_flags &amp; OPT_FREE) &amp;&amp; (options[idx].flags &amp; P_ALLOCED)) {</a>
<a name="ln2197">      free_string_option(*varp);</a>
<a name="ln2198">    }</a>
<a name="ln2199">    *varp = s;</a>
<a name="ln2200"> </a>
<a name="ln2201">    // For buffer/window local option may also set the global value.</a>
<a name="ln2202">    if (both) {</a>
<a name="ln2203">      set_string_option_global(idx, varp);</a>
<a name="ln2204">    }</a>
<a name="ln2205"> </a>
<a name="ln2206">    options[idx].flags |= P_ALLOCED;</a>
<a name="ln2207"> </a>
<a name="ln2208">    /* When setting both values of a global option with a local value,</a>
<a name="ln2209">    * make the local value empty, so that the global value is used. */</a>
<a name="ln2210">    if (((int)options[idx].indir &amp; PV_BOTH) &amp;&amp; both) {</a>
<a name="ln2211">      free_string_option(*varp);</a>
<a name="ln2212">      *varp = empty_option;</a>
<a name="ln2213">    }</a>
<a name="ln2214">    if (set_sid != SID_NONE) {</a>
<a name="ln2215">      sctx_T script_ctx;</a>
<a name="ln2216"> </a>
<a name="ln2217">      if (set_sid == 0) {</a>
<a name="ln2218">        script_ctx = current_sctx;</a>
<a name="ln2219">      } else {</a>
<a name="ln2220">        script_ctx.sc_sid = set_sid;</a>
<a name="ln2221">        script_ctx.sc_seq = 0;</a>
<a name="ln2222">        script_ctx.sc_lnum = 0;</a>
<a name="ln2223">      }</a>
<a name="ln2224">      set_option_sctx_idx(idx, opt_flags, script_ctx);</a>
<a name="ln2225">    }</a>
<a name="ln2226">  }</a>
<a name="ln2227">}</a>
<a name="ln2228"> </a>
<a name="ln2229">/// Set global value for string option when it's a local option.</a>
<a name="ln2230">static void</a>
<a name="ln2231">set_string_option_global(</a>
<a name="ln2232">    int opt_idx,                    // option index</a>
<a name="ln2233">    char_u **varp             // pointer to option variable</a>
<a name="ln2234">)</a>
<a name="ln2235">{</a>
<a name="ln2236">  char_u      **p, *s;</a>
<a name="ln2237"> </a>
<a name="ln2238">  // the global value is always allocated</a>
<a name="ln2239">  if (options[opt_idx].var == VAR_WIN) {</a>
<a name="ln2240">    p = (char_u **)GLOBAL_WO(varp);</a>
<a name="ln2241">  } else {</a>
<a name="ln2242">    p = (char_u **)options[opt_idx].var;</a>
<a name="ln2243">  }</a>
<a name="ln2244">  if (options[opt_idx].indir != PV_NONE &amp;&amp; p != varp) {</a>
<a name="ln2245">    s = vim_strsave(*varp);</a>
<a name="ln2246">    free_string_option(*p);</a>
<a name="ln2247">    *p = s;</a>
<a name="ln2248">  }</a>
<a name="ln2249">}</a>
<a name="ln2250"> </a>
<a name="ln2251">/// Set a string option to a new value, handling the effects</a>
<a name="ln2252">///</a>
<a name="ln2253">/// @param[in]  opt_idx  Option to set.</a>
<a name="ln2254">/// @param[in]  value  New value.</a>
<a name="ln2255">/// @param[in]  opt_flags  Option flags: expected to contain #OPT_LOCAL and/or</a>
<a name="ln2256">///                        #OPT_GLOBAL.</a>
<a name="ln2257">///</a>
<a name="ln2258">/// @return NULL on success, error message on error.</a>
<a name="ln2259">static char *set_string_option(const int opt_idx, const char *const value,</a>
<a name="ln2260">                               const int opt_flags)</a>
<a name="ln2261">  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2262">{</a>
<a name="ln2263">  if (options[opt_idx].var == NULL) {  // don't set hidden option</a>
<a name="ln2264">    return NULL;</a>
<a name="ln2265">  }</a>
<a name="ln2266"> </a>
<a name="ln2267">  char *const s = xstrdup(value);</a>
<a name="ln2268">  char **const varp = (char **)get_varp_scope(</a>
<a name="ln2269">      &amp;(options[opt_idx]),</a>
<a name="ln2270">      ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0</a>
<a name="ln2271">       ? (((int)options[opt_idx].indir &amp; PV_BOTH)</a>
<a name="ln2272">          ? OPT_GLOBAL : OPT_LOCAL)</a>
<a name="ln2273">       : opt_flags));</a>
<a name="ln2274">  char *const oldval = *varp;</a>
<a name="ln2275">  *varp = s;</a>
<a name="ln2276"> </a>
<a name="ln2277">  char *const saved_oldval = xstrdup(oldval);</a>
<a name="ln2278">  char *const saved_newval = xstrdup(s);</a>
<a name="ln2279"> </a>
<a name="ln2280">  int value_checked = false;</a>
<a name="ln2281">  char *const r = (char *)did_set_string_option(</a>
<a name="ln2282">      opt_idx, (char_u **)varp, (int)true, (char_u *)oldval,</a>
<a name="ln2283">      NULL, 0, opt_flags, &amp;value_checked);</a>
<a name="ln2284">  if (r == NULL) {</a>
<a name="ln2285">    did_set_option(opt_idx, opt_flags, true, value_checked);</a>
<a name="ln2286">  }</a>
<a name="ln2287"> </a>
<a name="ln2288">  // call autocommand after handling side effects</a>
<a name="ln2289">  if (r == NULL) {</a>
<a name="ln2290">    if (!starting) {</a>
<a name="ln2291">      trigger_optionsset_string(opt_idx, opt_flags, saved_oldval, saved_newval);</a>
<a name="ln2292">    }</a>
<a name="ln2293">    if (options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln2294">      ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln2295">                         STRING_OBJ(cstr_as_string(saved_newval)));</a>
<a name="ln2296">    }</a>
<a name="ln2297">  }</a>
<a name="ln2298">  xfree(saved_oldval);</a>
<a name="ln2299">  xfree(saved_newval);</a>
<a name="ln2300"> </a>
<a name="ln2301">  return r;</a>
<a name="ln2302">}</a>
<a name="ln2303"> </a>
<a name="ln2304">/// Return true if &quot;val&quot; is a valid name: only consists of alphanumeric ASCII</a>
<a name="ln2305">/// characters or characters in &quot;allowed&quot;.</a>
<a name="ln2306">static bool valid_name(const char_u *val, const char *allowed)</a>
<a name="ln2307">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2308">{</a>
<a name="ln2309">  for (const char_u *s = val; *s != NUL; s++) {</a>
<a name="ln2310">    if (!ASCII_ISALNUM(*s)</a>
<a name="ln2311">        &amp;&amp; vim_strchr((const char_u *)allowed, *s) == NULL) {</a>
<a name="ln2312">      return false;</a>
<a name="ln2313">    }</a>
<a name="ln2314">  }</a>
<a name="ln2315">  return true;</a>
<a name="ln2316">}</a>
<a name="ln2317"> </a>
<a name="ln2318">/// Return true if &quot;val&quot; is a valid 'filetype' name.</a>
<a name="ln2319">/// Also used for 'syntax' and 'keymap'.</a>
<a name="ln2320">static bool valid_filetype(const char_u *val)</a>
<a name="ln2321">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2322">{</a>
<a name="ln2323">  return valid_name(val, &quot;.-_&quot;);</a>
<a name="ln2324">}</a>
<a name="ln2325"> </a>
<a name="ln2326">/// Return true if &quot;val&quot; is a valid 'spelllang' value.</a>
<a name="ln2327">bool valid_spelllang(const char_u *val)</a>
<a name="ln2328">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2329">{</a>
<a name="ln2330">  return valid_name(val, &quot;.-_,@&quot;);</a>
<a name="ln2331">}</a>
<a name="ln2332"> </a>
<a name="ln2333">/// Return true if &quot;val&quot; is a valid 'spellfile' value.</a>
<a name="ln2334">static bool valid_spellfile(const char_u *val)</a>
<a name="ln2335">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2336">{</a>
<a name="ln2337">  for (const char_u *s = val; *s != NUL; s++) {</a>
<a name="ln2338">    if (!vim_isfilec(*s) &amp;&amp; *s != ',' &amp;&amp; *s != ' ') {</a>
<a name="ln2339">      return false;</a>
<a name="ln2340">    }</a>
<a name="ln2341">  }</a>
<a name="ln2342">  return true;</a>
<a name="ln2343">}</a>
<a name="ln2344"> </a>
<a name="ln2345">/// Handle string options that need some action to perform when changed.</a>
<a name="ln2346">/// Returns NULL for success, or an error message for an error.</a>
<a name="ln2347">static char_u *</a>
<a name="ln2348">did_set_string_option(</a>
<a name="ln2349">    int opt_idx,                       // index in options[] table</a>
<a name="ln2350">    char_u **varp,                     // pointer to the option variable</a>
<a name="ln2351">    bool new_value_alloced,            // new value was allocated</a>
<a name="ln2352">    char_u *oldval,                    // previous value of the option</a>
<a name="ln2353">    char_u *errbuf,                    // buffer for errors, or NULL</a>
<a name="ln2354">    size_t errbuflen,                  // length of errors buffer</a>
<a name="ln2355">    int opt_flags,                     // OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln2356">    int *value_checked                 // value was checked to be safe, no</a>
<a name="ln2357">                                       // need to set P_INSECURE</a>
<a name="ln2358">)</a>
<a name="ln2359">{</a>
<a name="ln2360">  char_u      *errmsg = NULL;</a>
<a name="ln2361">  char_u      *s, *p;</a>
<a name="ln2362">  int did_chartab = false;</a>
<a name="ln2363">  char_u      **gvarp;</a>
<a name="ln2364">  bool free_oldval = (options[opt_idx].flags &amp; P_ALLOCED);</a>
<a name="ln2365">  bool value_changed = false;</a>
<a name="ln2366"> </a>
<a name="ln2367">  /* Get the global option to compare with, otherwise we would have to check</a>
<a name="ln2368">   * two values for all local options. */</a>
<a name="ln2369">  gvarp = (char_u **)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln2370"> </a>
<a name="ln2371">  // Disallow changing some options from secure mode</a>
<a name="ln2372">  if ((secure || sandbox != 0)</a>
<a name="ln2373">      &amp;&amp; (options[opt_idx].flags &amp; P_SECURE)) {</a>
<a name="ln2374">    errmsg = e_secure;</a>
<a name="ln2375">  } else if (((options[opt_idx].flags &amp; P_NFNAME)</a>
<a name="ln2376">              &amp;&amp; vim_strpbrk(*varp, (char_u *)(secure ? &quot;/\\*?[|;&amp;&lt;&gt;\r\n&quot;</a>
<a name="ln2377">                                               : &quot;/\\*?[&lt;&gt;\r\n&quot;)) != NULL)</a>
<a name="ln2378">             || ((options[opt_idx].flags &amp; P_NDNAME)</a>
<a name="ln2379">                 &amp;&amp; vim_strpbrk(*varp, (char_u *)&quot;*?[|;&amp;&lt;&gt;\r\n&quot;) != NULL)) {</a>
<a name="ln2380">    // Check for a &quot;normal&quot; directory or file name in some options.  Disallow a</a>
<a name="ln2381">    // path separator (slash and/or backslash), wildcards and characters that</a>
<a name="ln2382">    // are often illegal in a file name. Be more permissive if &quot;secure&quot; is off.</a>
<a name="ln2383">    errmsg = e_invarg;</a>
<a name="ln2384">  } else if (gvarp == &amp;p_bkc) {  // 'backupcopy'</a>
<a name="ln2385">    char_u       *bkc   = p_bkc;</a>
<a name="ln2386">    unsigned int *flags = &amp;bkc_flags;</a>
<a name="ln2387"> </a>
<a name="ln2388">    if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln2389">      bkc   = curbuf-&gt;b_p_bkc;</a>
<a name="ln2390">      flags = &amp;curbuf-&gt;b_bkc_flags;</a>
<a name="ln2391">    }</a>
<a name="ln2392"> </a>
<a name="ln2393">    if ((opt_flags &amp; OPT_LOCAL) &amp;&amp; *bkc == NUL) {</a>
<a name="ln2394">      // make the local value empty: use the global value</a>
<a name="ln2395">      *flags = 0;</a>
<a name="ln2396">    } else {</a>
<a name="ln2397">      if (opt_strings_flags(bkc, p_bkc_values, flags, true) != OK) {</a>
<a name="ln2398">        errmsg = e_invarg;</a>
<a name="ln2399">      }</a>
<a name="ln2400"> </a>
<a name="ln2401">      if (((*flags &amp; BKC_AUTO) != 0)</a>
<a name="ln2402">          + ((*flags &amp; BKC_YES) != 0)</a>
<a name="ln2403">          + ((*flags &amp; BKC_NO) != 0) != 1) {</a>
<a name="ln2404">        // Must have exactly one of &quot;auto&quot;, &quot;yes&quot;  and &quot;no&quot;.</a>
<a name="ln2405">        (void)opt_strings_flags(oldval, p_bkc_values, flags, true);</a>
<a name="ln2406">        errmsg = e_invarg;</a>
<a name="ln2407">      }</a>
<a name="ln2408">    }</a>
<a name="ln2409">  } else if (varp == &amp;p_bex || varp == &amp;p_pm) {  // 'backupext' and 'patchmode'</a>
<a name="ln2410">    if (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,</a>
<a name="ln2411">               *p_pm == '.' ? p_pm + 1 : p_pm) == 0) {</a>
<a name="ln2412">      errmsg = (char_u *)N_(&quot;E589: 'backupext' and 'patchmode' are equal&quot;);</a>
<a name="ln2413">    }</a>
<a name="ln2414">  } else if (varp == &amp;curwin-&gt;w_p_briopt) {  // 'breakindentopt'</a>
<a name="ln2415">    if (briopt_check(curwin) == FAIL) {</a>
<a name="ln2416">      errmsg = e_invarg;</a>
<a name="ln2417">    }</a>
<a name="ln2418">  } else if (varp == &amp;p_isi</a>
<a name="ln2419">             || varp == &amp;(curbuf-&gt;b_p_isk)</a>
<a name="ln2420">             || varp == &amp;p_isp</a>
<a name="ln2421">             || varp == &amp;p_isf) {</a>
<a name="ln2422">    // 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]</a>
<a name="ln2423">    // If the new option is invalid, use old value.  'lisp' option: refill</a>
<a name="ln2424">    // g_chartab[] for '-' char</a>
<a name="ln2425">    if (init_chartab() == FAIL) {</a>
<a name="ln2426">      did_chartab = true;           // need to restore it below</a>
<a name="ln2427">      errmsg = e_invarg;            // error in value</a>
<a name="ln2428">    }</a>
<a name="ln2429">  } else if (varp == &amp;p_hf) {  // 'helpfile'</a>
<a name="ln2430">    // May compute new values for $VIM and $VIMRUNTIME</a>
<a name="ln2431">    if (didset_vim) {</a>
<a name="ln2432">      os_setenv(&quot;VIM&quot;, &quot;&quot;, 1);</a>
<a name="ln2433">      didset_vim = false;</a>
<a name="ln2434">    }</a>
<a name="ln2435">    if (didset_vimruntime) {</a>
<a name="ln2436">      os_setenv(&quot;VIMRUNTIME&quot;, &quot;&quot;, 1);</a>
<a name="ln2437">      didset_vimruntime = false;</a>
<a name="ln2438">    }</a>
<a name="ln2439">  } else if (varp == &amp;curwin-&gt;w_p_cc) {  // 'colorcolumn'</a>
<a name="ln2440">    errmsg = check_colorcolumn(curwin);</a>
<a name="ln2441">  } else if (varp == &amp;p_hlg) {  // 'helplang'</a>
<a name="ln2442">    // Check for &quot;&quot;, &quot;ab&quot;, &quot;ab,cd&quot;, etc.</a>
<a name="ln2443">    for (s = p_hlg; *s != NUL; s += 3) {</a>
<a name="ln2444">      if (s[1] == NUL || ((s[2] != ',' || s[3] == NUL) &amp;&amp; s[2] != NUL)) {</a>
<a name="ln2445">        errmsg = e_invarg;</a>
<a name="ln2446">        break;</a>
<a name="ln2447">      }</a>
<a name="ln2448">      if (s[2] == NUL) {</a>
<a name="ln2449">        break;</a>
<a name="ln2450">      }</a>
<a name="ln2451">    }</a>
<a name="ln2452">  } else if (varp == &amp;p_hl) {</a>
<a name="ln2453">    // 'highlight'</a>
<a name="ln2454">    if (strcmp((char *)(*varp), HIGHLIGHT_INIT) != 0) {</a>
<a name="ln2455">      errmsg = e_unsupportedoption;</a>
<a name="ln2456">    }</a>
<a name="ln2457">  } else if (varp == &amp;p_jop) {  // 'jumpoptions'</a>
<a name="ln2458">    if (opt_strings_flags(p_jop, p_jop_values, &amp;jop_flags, true) != OK) {</a>
<a name="ln2459">      errmsg = e_invarg;</a>
<a name="ln2460">    }</a>
<a name="ln2461">  } else if (gvarp == &amp;p_nf) {  // 'nrformats'</a>
<a name="ln2462">    if (check_opt_strings(*varp, p_nf_values, true) != OK) {</a>
<a name="ln2463">      errmsg = e_invarg;</a>
<a name="ln2464">    }</a>
<a name="ln2465">  } else if (varp == &amp;p_ssop) {  // 'sessionoptions'</a>
<a name="ln2466">    if (opt_strings_flags(p_ssop, p_ssop_values, &amp;ssop_flags, true) != OK) {</a>
<a name="ln2467">      errmsg = e_invarg;</a>
<a name="ln2468">    }</a>
<a name="ln2469">    if ((ssop_flags &amp; SSOP_CURDIR) &amp;&amp; (ssop_flags &amp; SSOP_SESDIR)) {</a>
<a name="ln2470">      // Don't allow both &quot;sesdir&quot; and &quot;curdir&quot;.</a>
<a name="ln2471">      (void)opt_strings_flags(oldval, p_ssop_values, &amp;ssop_flags, true);</a>
<a name="ln2472">      errmsg = e_invarg;</a>
<a name="ln2473">    }</a>
<a name="ln2474">  } else if (varp == &amp;p_vop) {  // 'viewoptions'</a>
<a name="ln2475">    if (opt_strings_flags(p_vop, p_ssop_values, &amp;vop_flags, true) != OK) {</a>
<a name="ln2476">      errmsg = e_invarg;</a>
<a name="ln2477">    }</a>
<a name="ln2478">  } else if (varp == &amp;p_rdb) {  // 'redrawdebug'</a>
<a name="ln2479">    if (opt_strings_flags(p_rdb, p_rdb_values, &amp;rdb_flags, true) != OK) {</a>
<a name="ln2480">      errmsg = e_invarg;</a>
<a name="ln2481">    }</a>
<a name="ln2482">  } else if (varp == &amp;p_sbo) {  // 'scrollopt'</a>
<a name="ln2483">    if (check_opt_strings(p_sbo, p_scbopt_values, true) != OK) {</a>
<a name="ln2484">      errmsg = e_invarg;</a>
<a name="ln2485">    }</a>
<a name="ln2486">  } else if (varp == &amp;p_ambw || (int *)varp == &amp;p_emoji) {</a>
<a name="ln2487">    // 'ambiwidth'</a>
<a name="ln2488">    if (check_opt_strings(p_ambw, p_ambw_values, false) != OK) {</a>
<a name="ln2489">      errmsg = e_invarg;</a>
<a name="ln2490">    } else {</a>
<a name="ln2491">      FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln2492">        if (set_chars_option(wp, &amp;wp-&gt;w_p_lcs, true) != NULL) {</a>
<a name="ln2493">          errmsg = (char_u *)_(&quot;E834: Conflicts with value of 'listchars'&quot;);</a>
<a name="ln2494">          goto ambw_end;</a>
<a name="ln2495">        }</a>
<a name="ln2496">        if (set_chars_option(wp, &amp;wp-&gt;w_p_fcs, true) != NULL) {</a>
<a name="ln2497">          errmsg = (char_u *)_(&quot;E835: Conflicts with value of 'fillchars'&quot;);</a>
<a name="ln2498">          goto ambw_end;</a>
<a name="ln2499">        }</a>
<a name="ln2500">      }</a>
<a name="ln2501">ambw_end:</a>
<a name="ln2502">      {}  // clint prefers {} over ; as an empty statement</a>
<a name="ln2503">    }</a>
<a name="ln2504">  } else if (varp == &amp;p_bg) {  // 'background'</a>
<a name="ln2505">    if (check_opt_strings(p_bg, p_bg_values, false) == OK) {</a>
<a name="ln2506">      int dark = (*p_bg == 'd');</a>
<a name="ln2507"> </a>
<a name="ln2508">      init_highlight(false, false);</a>
<a name="ln2509"> </a>
<a name="ln2510">      if (dark != (*p_bg == 'd') &amp;&amp; get_var_value(&quot;g:colors_name&quot;) != NULL) {</a>
<a name="ln2511">        // The color scheme must have set 'background' back to another</a>
<a name="ln2512">        // value, that's not what we want here.  Disable the color</a>
<a name="ln2513">        // scheme and set the colors again.</a>
<a name="ln2514">        do_unlet(S_LEN(&quot;g:colors_name&quot;), true);</a>
<a name="ln2515">        free_string_option(p_bg);</a>
<a name="ln2516">        p_bg = vim_strsave((char_u *)(dark ? &quot;dark&quot; : &quot;light&quot;));</a>
<a name="ln2517">        check_string_option(&amp;p_bg);</a>
<a name="ln2518">        init_highlight(false, false);</a>
<a name="ln2519">      }</a>
<a name="ln2520">    } else</a>
<a name="ln2521">      errmsg = e_invarg;</a>
<a name="ln2522">  } else if (varp == &amp;p_wim) {  // 'wildmode'</a>
<a name="ln2523">    if (check_opt_wim() == FAIL) {</a>
<a name="ln2524">      errmsg = e_invarg;</a>
<a name="ln2525">    }</a>
<a name="ln2526">  // 'wildoptions'</a>
<a name="ln2527">  } else if (varp == &amp;p_wop) {</a>
<a name="ln2528">    if (opt_strings_flags(p_wop, p_wop_values, &amp;wop_flags, true) != OK) {</a>
<a name="ln2529">      errmsg = e_invarg;</a>
<a name="ln2530">    }</a>
<a name="ln2531">  } else if (varp == &amp;p_wak) {  // 'winaltkeys'</a>
<a name="ln2532">    if (*p_wak == NUL</a>
<a name="ln2533">        || check_opt_strings(p_wak, p_wak_values, false) != OK) {</a>
<a name="ln2534">      errmsg = e_invarg;</a>
<a name="ln2535">    }</a>
<a name="ln2536">  } else if (varp == &amp;p_ei) {  // 'eventignore'</a>
<a name="ln2537">    if (check_ei() == FAIL) {</a>
<a name="ln2538">      errmsg = e_invarg;</a>
<a name="ln2539">    }</a>
<a name="ln2540">  // 'encoding', 'fileencoding' and 'makeencoding'</a>
<a name="ln2541">  } else if (varp == &amp;p_enc || gvarp == &amp;p_fenc || gvarp == &amp;p_menc) {</a>
<a name="ln2542">    if (gvarp == &amp;p_fenc) {</a>
<a name="ln2543">      if (!MODIFIABLE(curbuf) &amp;&amp; opt_flags != OPT_GLOBAL) {</a>
<a name="ln2544">        errmsg = e_modifiable;</a>
<a name="ln2545">      } else if (vim_strchr(*varp, ',') != NULL) {</a>
<a name="ln2546">        // No comma allowed in 'fileencoding'; catches confusing it</a>
<a name="ln2547">        // with 'fileencodings'.</a>
<a name="ln2548">        errmsg = e_invarg;</a>
<a name="ln2549">      } else {</a>
<a name="ln2550">        // May show a &quot;+&quot; in the title now.</a>
<a name="ln2551">        redraw_titles();</a>
<a name="ln2552">        // Add 'fileencoding' to the swap file.</a>
<a name="ln2553">        ml_setflags(curbuf);</a>
<a name="ln2554">      }</a>
<a name="ln2555">    }</a>
<a name="ln2556"> </a>
<a name="ln2557">    if (errmsg == NULL) {</a>
<a name="ln2558">      // canonize the value, so that STRCMP() can be used on it</a>
<a name="ln2559">      p = enc_canonize(*varp);</a>
<a name="ln2560">      xfree(*varp);</a>
<a name="ln2561">      *varp = p;</a>
<a name="ln2562">      if (varp == &amp;p_enc) {</a>
<a name="ln2563">        // only encoding=utf-8 allowed</a>
<a name="ln2564">        if (STRCMP(p_enc, &quot;utf-8&quot;) != 0) {</a>
<a name="ln2565">          errmsg = e_unsupportedoption;</a>
<a name="ln2566">        }</a>
<a name="ln2567">      }</a>
<a name="ln2568">    }</a>
<a name="ln2569">  } else if (varp == &amp;p_penc) {</a>
<a name="ln2570">    // Canonize printencoding if VIM standard one</a>
<a name="ln2571">    p = enc_canonize(p_penc);</a>
<a name="ln2572">    xfree(p_penc);</a>
<a name="ln2573">    p_penc = p;</a>
<a name="ln2574">  } else if (varp == &amp;curbuf-&gt;b_p_keymap) {</a>
<a name="ln2575">    if (!valid_filetype(*varp)) {</a>
<a name="ln2576">      errmsg = e_invarg;</a>
<a name="ln2577">    } else {</a>
<a name="ln2578">      int secure_save = secure;</a>
<a name="ln2579"> </a>
<a name="ln2580">      // Reset the secure flag, since the value of 'keymap' has</a>
<a name="ln2581">      // been checked to be safe.</a>
<a name="ln2582">      secure = 0;</a>
<a name="ln2583"> </a>
<a name="ln2584">      // load or unload key mapping tables</a>
<a name="ln2585">      errmsg = keymap_init();</a>
<a name="ln2586"> </a>
<a name="ln2587">      secure = secure_save;</a>
<a name="ln2588"> </a>
<a name="ln2589">      // Since we check the value, there is no need to set P_INSECURE,</a>
<a name="ln2590">      // even when the value comes from a modeline.</a>
<a name="ln2591">      *value_checked = true;</a>
<a name="ln2592">    }</a>
<a name="ln2593"> </a>
<a name="ln2594">    if (errmsg == NULL) {</a>
<a name="ln2595">      if (*curbuf-&gt;b_p_keymap != NUL) {</a>
<a name="ln2596">        // Installed a new keymap, switch on using it.</a>
<a name="ln2597">        curbuf-&gt;b_p_iminsert = B_IMODE_LMAP;</a>
<a name="ln2598">        if (curbuf-&gt;b_p_imsearch != B_IMODE_USE_INSERT) {</a>
<a name="ln2599">          curbuf-&gt;b_p_imsearch = B_IMODE_LMAP;</a>
<a name="ln2600">        }</a>
<a name="ln2601">      } else {</a>
<a name="ln2602">        // Cleared the keymap, may reset 'iminsert' and 'imsearch'.</a>
<a name="ln2603">        if (curbuf-&gt;b_p_iminsert == B_IMODE_LMAP) {</a>
<a name="ln2604">          curbuf-&gt;b_p_iminsert = B_IMODE_NONE;</a>
<a name="ln2605">        }</a>
<a name="ln2606">        if (curbuf-&gt;b_p_imsearch == B_IMODE_LMAP) {</a>
<a name="ln2607">          curbuf-&gt;b_p_imsearch = B_IMODE_USE_INSERT;</a>
<a name="ln2608">        }</a>
<a name="ln2609">      }</a>
<a name="ln2610">      if ((opt_flags &amp; OPT_LOCAL) == 0) {</a>
<a name="ln2611">        set_iminsert_global();</a>
<a name="ln2612">        set_imsearch_global();</a>
<a name="ln2613">      }</a>
<a name="ln2614">      status_redraw_curbuf();</a>
<a name="ln2615">    }</a>
<a name="ln2616">  } else if (gvarp == &amp;p_ff) {  // 'fileformat'</a>
<a name="ln2617">    if (!MODIFIABLE(curbuf) &amp;&amp; !(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln2618">      errmsg = e_modifiable;</a>
<a name="ln2619">    } else if (check_opt_strings(*varp, p_ff_values, false) != OK) {</a>
<a name="ln2620">      errmsg = e_invarg;</a>
<a name="ln2621">    } else {</a>
<a name="ln2622">      redraw_titles();</a>
<a name="ln2623">      // update flag in swap file</a>
<a name="ln2624">      ml_setflags(curbuf);</a>
<a name="ln2625">      /* Redraw needed when switching to/from &quot;mac&quot;: a CR in the text</a>
<a name="ln2626">       * will be displayed differently. */</a>
<a name="ln2627">      if (get_fileformat(curbuf) == EOL_MAC || *oldval == 'm') {</a>
<a name="ln2628">        redraw_curbuf_later(NOT_VALID);</a>
<a name="ln2629">      }</a>
<a name="ln2630">    }</a>
<a name="ln2631">  } else if (varp == &amp;p_ffs) {  // 'fileformats'</a>
<a name="ln2632">    if (check_opt_strings(p_ffs, p_ff_values, true) != OK) {</a>
<a name="ln2633">      errmsg = e_invarg;</a>
<a name="ln2634">    }</a>
<a name="ln2635">  } else if (gvarp == &amp;p_mps) {  // 'matchpairs'</a>
<a name="ln2636">    for (p = *varp; *p != NUL; p++) {</a>
<a name="ln2637">      int x2 = -1;</a>
<a name="ln2638">      int x3 = -1;</a>
<a name="ln2639"> </a>
<a name="ln2640">      if (*p != NUL) {</a>
<a name="ln2641">        p += utfc_ptr2len(p);</a>
<a name="ln2642">      }</a>
<a name="ln2643">      if (*p != NUL) {</a>
<a name="ln2644">        x2 = *p++;</a>
<a name="ln2645">      }</a>
<a name="ln2646">      if (*p != NUL) {</a>
<a name="ln2647">        x3 = utf_ptr2char(p);</a>
<a name="ln2648">        p += utfc_ptr2len(p);</a>
<a name="ln2649">      }</a>
<a name="ln2650">      if (x2 != ':' || x3 == -1 || (*p != NUL &amp;&amp; *p != ',')) {</a>
<a name="ln2651">        errmsg = e_invarg;</a>
<a name="ln2652">        break;</a>
<a name="ln2653">      }</a>
<a name="ln2654">      if (*p == NUL) {</a>
<a name="ln2655">        break;</a>
<a name="ln2656">      }</a>
<a name="ln2657">    }</a>
<a name="ln2658">  } else if (gvarp == &amp;p_com) {  // 'comments'</a>
<a name="ln2659">    for (s = *varp; *s; ) {</a>
<a name="ln2660">      while (*s &amp;&amp; *s != ':') {</a>
<a name="ln2661">        if (vim_strchr((char_u *)COM_ALL, *s) == NULL</a>
<a name="ln2662">            &amp;&amp; !ascii_isdigit(*s) &amp;&amp; *s != '-') {</a>
<a name="ln2663">          errmsg = illegal_char(errbuf, errbuflen, *s);</a>
<a name="ln2664">          break;</a>
<a name="ln2665">        }</a>
<a name="ln2666">        s++;</a>
<a name="ln2667">      }</a>
<a name="ln2668">      if (*s++ == NUL) {</a>
<a name="ln2669">        errmsg = (char_u *)N_(&quot;E524: Missing colon&quot;);</a>
<a name="ln2670">      } else if (*s == ',' || *s == NUL) {</a>
<a name="ln2671">        errmsg = (char_u *)N_(&quot;E525: Zero length string&quot;);</a>
<a name="ln2672">      }</a>
<a name="ln2673">      if (errmsg != NULL) {</a>
<a name="ln2674">        break;</a>
<a name="ln2675">      }</a>
<a name="ln2676">      while (*s &amp;&amp; *s != ',') {</a>
<a name="ln2677">        if (*s == '\\' &amp;&amp; s[1] != NUL) {</a>
<a name="ln2678">          s++;</a>
<a name="ln2679">        }</a>
<a name="ln2680">        s++;</a>
<a name="ln2681">      }</a>
<a name="ln2682">      s = skip_to_option_part(s);</a>
<a name="ln2683">    }</a>
<a name="ln2684">  } else if (varp == &amp;p_lcs) {  // 'listchars'</a>
<a name="ln2685">    errmsg = set_chars_option(curwin, varp, false);</a>
<a name="ln2686">    if (!errmsg) {</a>
<a name="ln2687">      FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln2688">        set_chars_option(wp, &amp;wp-&gt;w_p_lcs, true);</a>
<a name="ln2689">      }</a>
<a name="ln2690">    }</a>
<a name="ln2691">    redraw_all_later(NOT_VALID);</a>
<a name="ln2692">  } else if (varp == &amp;curwin-&gt;w_p_lcs) {  // local 'listchars'</a>
<a name="ln2693">    errmsg = set_chars_option(curwin, varp, true);</a>
<a name="ln2694">  } else if (varp == &amp;p_fcs) {  // 'fillchars'</a>
<a name="ln2695">    errmsg = set_chars_option(curwin, varp, false);</a>
<a name="ln2696">    if (!errmsg) {</a>
<a name="ln2697">      FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln2698">        set_chars_option(wp, &amp;wp-&gt;w_p_fcs, true);</a>
<a name="ln2699">      }</a>
<a name="ln2700">    }</a>
<a name="ln2701">    redraw_all_later(NOT_VALID);</a>
<a name="ln2702">  } else if (varp == &amp;curwin-&gt;w_p_fcs) {  // local 'fillchars'</a>
<a name="ln2703">    errmsg = set_chars_option(curwin, varp, true);</a>
<a name="ln2704">  } else if (varp == &amp;p_cedit) {  // 'cedit'</a>
<a name="ln2705">    errmsg = check_cedit();</a>
<a name="ln2706">  } else if (varp == &amp;p_vfile) {  // 'verbosefile'</a>
<a name="ln2707">    verbose_stop();</a>
<a name="ln2708">    if (*p_vfile != NUL &amp;&amp; verbose_open() == FAIL) {</a>
<a name="ln2709">      errmsg = e_invarg;</a>
<a name="ln2710">    }</a>
<a name="ln2711">  // 'shada'</a>
<a name="ln2712">  } else if (varp == &amp;p_shada) {</a>
<a name="ln2713">    // TODO(ZyX-I): Remove this code in the future, alongside with &amp;viminfo</a>
<a name="ln2714">    //              option.</a>
<a name="ln2715">    opt_idx = ((options[opt_idx].fullname[0] == 'v')</a>
<a name="ln2716">               ? (shada_idx == -1</a>
<a name="ln2717">                  ? ((shada_idx = findoption(&quot;shada&quot;)))</a>
<a name="ln2718">                  : shada_idx)</a>
<a name="ln2719">               : opt_idx);</a>
<a name="ln2720">    // Update free_oldval now that we have the opt_idx for 'shada', otherwise</a>
<a name="ln2721">    // there would be a disconnect between the check for P_ALLOCED at the start</a>
<a name="ln2722">    // of the function and the set of P_ALLOCED at the end of the fuction.</a>
<a name="ln2723">    free_oldval = (options[opt_idx].flags &amp; P_ALLOCED);</a>
<a name="ln2724">    for (s = p_shada; *s; ) {</a>
<a name="ln2725">      // Check it's a valid character</a>
<a name="ln2726">      if (vim_strchr((char_u *)&quot;!\&quot;%'/:&lt;@cfhnrs&quot;, *s) == NULL) {</a>
<a name="ln2727">        errmsg = illegal_char(errbuf, errbuflen, *s);</a>
<a name="ln2728">        break;</a>
<a name="ln2729">      }</a>
<a name="ln2730">      if (*s == 'n') {          // name is always last one</a>
<a name="ln2731">        break;</a>
<a name="ln2732">      } else if (*s == 'r') {  // skip until next ','</a>
<a name="ln2733">        while (*++s &amp;&amp; *s != ',') {}</a>
<a name="ln2734">      } else if (*s == '%') {</a>
<a name="ln2735">        // optional number</a>
<a name="ln2736">        while (ascii_isdigit(*++s)) {}</a>
<a name="ln2737">      } else if (*s == '!' || *s == 'h' || *s == 'c') {</a>
<a name="ln2738">        s++;                    // no extra chars</a>
<a name="ln2739">      } else {                    // must have a number</a>
<a name="ln2740">        while (ascii_isdigit(*++s)) {}</a>
<a name="ln2741"> </a>
<a name="ln2742">        if (!ascii_isdigit(*(s - 1))) {</a>
<a name="ln2743">          if (errbuf != NULL) {</a>
<a name="ln2744">            vim_snprintf((char *)errbuf, errbuflen,</a>
<a name="ln2745">                         _(&quot;E526: Missing number after &lt;%s&gt;&quot;),</a>
<a name="ln2746">                         transchar_byte(*(s - 1)));</a>
<a name="ln2747">            errmsg = errbuf;</a>
<a name="ln2748">          } else</a>
<a name="ln2749">            errmsg = (char_u *)&quot;&quot;;</a>
<a name="ln2750">          break;</a>
<a name="ln2751">        }</a>
<a name="ln2752">      }</a>
<a name="ln2753">      if (*s == ',') {</a>
<a name="ln2754">        s++;</a>
<a name="ln2755">      } else if (*s) {</a>
<a name="ln2756">        if (errbuf != NULL) {</a>
<a name="ln2757">          errmsg = (char_u *)N_(&quot;E527: Missing comma&quot;);</a>
<a name="ln2758">        } else {</a>
<a name="ln2759">          errmsg = (char_u *)&quot;&quot;;</a>
<a name="ln2760">        }</a>
<a name="ln2761">        break;</a>
<a name="ln2762">      }</a>
<a name="ln2763">    }</a>
<a name="ln2764">    if (*p_shada &amp;&amp; errmsg == NULL &amp;&amp; get_shada_parameter('\'') &lt; 0) {</a>
<a name="ln2765">      errmsg = (char_u *)N_(&quot;E528: Must specify a ' value&quot;);</a>
<a name="ln2766">    }</a>
<a name="ln2767">  } else if (varp == &amp;p_sbr) {  // 'showbreak'</a>
<a name="ln2768">    for (s = p_sbr; *s; ) {</a>
<a name="ln2769">      if (ptr2cells(s) != 1) {</a>
<a name="ln2770">        errmsg = (char_u *)N_(&quot;E595: contains unprintable or wide character&quot;);</a>
<a name="ln2771">      }</a>
<a name="ln2772">      MB_PTR_ADV(s);</a>
<a name="ln2773">    }</a>
<a name="ln2774">  } else if (varp == &amp;p_guicursor) {  // 'guicursor'</a>
<a name="ln2775">    errmsg = parse_shape_opt(SHAPE_CURSOR);</a>
<a name="ln2776">  } else if (varp == &amp;p_popt) {</a>
<a name="ln2777">    errmsg = parse_printoptions();</a>
<a name="ln2778">  } else if (varp == &amp;p_pmfn) {</a>
<a name="ln2779">    errmsg = parse_printmbfont();</a>
<a name="ln2780">  } else if (varp == &amp;p_langmap) {  // 'langmap'</a>
<a name="ln2781">    langmap_set();</a>
<a name="ln2782">  } else if (varp == &amp;p_breakat) {  // 'breakat'</a>
<a name="ln2783">    fill_breakat_flags();</a>
<a name="ln2784">  } else if (varp == &amp;p_titlestring || varp == &amp;p_iconstring) {</a>
<a name="ln2785">    // 'titlestring' and 'iconstring'</a>
<a name="ln2786">    int flagval = (varp == &amp;p_titlestring) ? STL_IN_TITLE : STL_IN_ICON;</a>
<a name="ln2787"> </a>
<a name="ln2788">    // NULL =&gt; statusline syntax</a>
<a name="ln2789">    if (vim_strchr(*varp, '%') &amp;&amp; check_stl_option(*varp) == NULL) {</a>
<a name="ln2790">      stl_syntax |= flagval;</a>
<a name="ln2791">    } else {</a>
<a name="ln2792">      stl_syntax &amp;= ~flagval;</a>
<a name="ln2793">    }</a>
<a name="ln2794">    did_set_title();</a>
<a name="ln2795"> </a>
<a name="ln2796">  } else if (varp == &amp;p_sel) {  // 'selection'</a>
<a name="ln2797">    if (*p_sel == NUL</a>
<a name="ln2798">        || check_opt_strings(p_sel, p_sel_values, false) != OK) {</a>
<a name="ln2799">      errmsg = e_invarg;</a>
<a name="ln2800">    }</a>
<a name="ln2801">  } else if (varp == &amp;p_slm) {  // 'selectmode'</a>
<a name="ln2802">    if (check_opt_strings(p_slm, p_slm_values, true) != OK) {</a>
<a name="ln2803">      errmsg = e_invarg;</a>
<a name="ln2804">    }</a>
<a name="ln2805">  } else if (varp == &amp;p_km) {  // 'keymodel'</a>
<a name="ln2806">    if (check_opt_strings(p_km, p_km_values, true) != OK) {</a>
<a name="ln2807">      errmsg = e_invarg;</a>
<a name="ln2808">    } else {</a>
<a name="ln2809">      km_stopsel = (vim_strchr(p_km, 'o') != NULL);</a>
<a name="ln2810">      km_startsel = (vim_strchr(p_km, 'a') != NULL);</a>
<a name="ln2811">    }</a>
<a name="ln2812">  } else if (varp == &amp;p_mousem) {  // 'mousemodel'</a>
<a name="ln2813">    if (check_opt_strings(p_mousem, p_mousem_values, false) != OK) {</a>
<a name="ln2814">      errmsg = e_invarg;</a>
<a name="ln2815">    }</a>
<a name="ln2816">  } else if (varp == &amp;p_swb) {  // 'switchbuf'</a>
<a name="ln2817">    if (opt_strings_flags(p_swb, p_swb_values, &amp;swb_flags, true) != OK) {</a>
<a name="ln2818">      errmsg = e_invarg;</a>
<a name="ln2819">    }</a>
<a name="ln2820">  } else if (varp == &amp;p_debug) {  // 'debug'</a>
<a name="ln2821">    if (check_opt_strings(p_debug, p_debug_values, true) != OK) {</a>
<a name="ln2822">      errmsg = e_invarg;</a>
<a name="ln2823">    }</a>
<a name="ln2824">  } else if (varp == &amp;p_dy) {  // 'display'</a>
<a name="ln2825">    if (opt_strings_flags(p_dy, p_dy_values, &amp;dy_flags, true) != OK) {</a>
<a name="ln2826">      errmsg = e_invarg;</a>
<a name="ln2827">    } else {</a>
<a name="ln2828">      (void)init_chartab();</a>
<a name="ln2829">      msg_grid_validate();</a>
<a name="ln2830">    }</a>
<a name="ln2831">  } else if (varp == &amp;p_ead) {  // 'eadirection'</a>
<a name="ln2832">    if (check_opt_strings(p_ead, p_ead_values, false) != OK) {</a>
<a name="ln2833">      errmsg = e_invarg;</a>
<a name="ln2834">    }</a>
<a name="ln2835">  } else if (varp == &amp;p_cb) {  // 'clipboard'</a>
<a name="ln2836">    if (opt_strings_flags(p_cb, p_cb_values, &amp;cb_flags, true) != OK) {</a>
<a name="ln2837">      errmsg = e_invarg;</a>
<a name="ln2838">    }</a>
<a name="ln2839">  } else if (varp == &amp;(curwin-&gt;w_s-&gt;b_p_spl)  // 'spell'</a>
<a name="ln2840">             || varp == &amp;(curwin-&gt;w_s-&gt;b_p_spf)) {</a>
<a name="ln2841">    // When 'spelllang' or 'spellfile' is set and there is a window for this</a>
<a name="ln2842">    // buffer in which 'spell' is set load the wordlists.</a>
<a name="ln2843">    const bool is_spellfile = varp == &amp;(curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln2844"> </a>
<a name="ln2845">    if ((is_spellfile &amp;&amp; !valid_spellfile(*varp))</a>
<a name="ln2846">        || (!is_spellfile &amp;&amp; !valid_spelllang(*varp))) {</a>
<a name="ln2847">      errmsg = e_invarg;</a>
<a name="ln2848">    } else {</a>
<a name="ln2849">      errmsg = did_set_spell_option(is_spellfile);</a>
<a name="ln2850">    }</a>
<a name="ln2851">  } else if (varp == &amp;(curwin-&gt;w_s-&gt;b_p_spc)) {</a>
<a name="ln2852">    // When 'spellcapcheck' is set compile the regexp program.</a>
<a name="ln2853">    errmsg = compile_cap_prog(curwin-&gt;w_s);</a>
<a name="ln2854">  } else if (varp == &amp;(curwin-&gt;w_s-&gt;b_p_spo)) {  // 'spelloptions'</a>
<a name="ln2855">    if (**varp != NUL &amp;&amp; STRCMP(&quot;camel&quot;, *varp) != 0) {</a>
<a name="ln2856">      errmsg = e_invarg;</a>
<a name="ln2857">    }</a>
<a name="ln2858">  } else if (varp == &amp;p_sps) {  // 'spellsuggest'</a>
<a name="ln2859">    if (spell_check_sps() != OK) {</a>
<a name="ln2860">      errmsg = e_invarg;</a>
<a name="ln2861">    }</a>
<a name="ln2862">  } else if (varp == &amp;p_msm) {  // 'mkspellmem'</a>
<a name="ln2863">    if (spell_check_msm() != OK) {</a>
<a name="ln2864">      errmsg = e_invarg;</a>
<a name="ln2865">    }</a>
<a name="ln2866">  } else if (gvarp == &amp;p_bh) {</a>
<a name="ln2867">    // When 'bufhidden' is set, check for valid value.</a>
<a name="ln2868">    if (check_opt_strings(curbuf-&gt;b_p_bh, p_bufhidden_values, false) != OK) {</a>
<a name="ln2869">      errmsg = e_invarg;</a>
<a name="ln2870">    }</a>
<a name="ln2871">  } else if (gvarp == &amp;p_bt) {</a>
<a name="ln2872">    // When 'buftype' is set, check for valid value.</a>
<a name="ln2873">    if ((curbuf-&gt;terminal &amp;&amp; curbuf-&gt;b_p_bt[0] != 't')</a>
<a name="ln2874">        || (!curbuf-&gt;terminal &amp;&amp; curbuf-&gt;b_p_bt[0] == 't')</a>
<a name="ln2875">        || check_opt_strings(curbuf-&gt;b_p_bt, p_buftype_values, false) != OK) {</a>
<a name="ln2876">      errmsg = e_invarg;</a>
<a name="ln2877">    } else {</a>
<a name="ln2878">      if (curwin-&gt;w_status_height) {</a>
<a name="ln2879">        curwin-&gt;w_redr_status = true;</a>
<a name="ln2880">        redraw_later(curwin, VALID);</a>
<a name="ln2881">      }</a>
<a name="ln2882">      curbuf-&gt;b_help = (curbuf-&gt;b_p_bt[0] == 'h');</a>
<a name="ln2883">      redraw_titles();</a>
<a name="ln2884">    }</a>
<a name="ln2885">  } else if (gvarp == &amp;p_stl || varp == &amp;p_ruf) {</a>
<a name="ln2886">    // 'statusline' or 'rulerformat'</a>
<a name="ln2887">    int wid;</a>
<a name="ln2888"> </a>
<a name="ln2889">    if (varp == &amp;p_ruf) {       // reset ru_wid first</a>
<a name="ln2890">      ru_wid = 0;</a>
<a name="ln2891">    }</a>
<a name="ln2892">    s = *varp;</a>
<a name="ln2893">    if (varp == &amp;p_ruf &amp;&amp; *s == '%') {</a>
<a name="ln2894">      // set ru_wid if 'ruf' starts with &quot;%99(&quot;</a>
<a name="ln2895">      if (*++s == '-') {        // ignore a '-'</a>
<a name="ln2896">        s++;</a>
<a name="ln2897">      }</a>
<a name="ln2898">      wid = getdigits_int(&amp;s, true, 0);</a>
<a name="ln2899">      if (wid &amp;&amp; *s == '(' &amp;&amp; (errmsg = check_stl_option(p_ruf)) == NULL) {</a>
<a name="ln2900">        ru_wid = wid;</a>
<a name="ln2901">      } else {</a>
<a name="ln2902">        errmsg = check_stl_option(p_ruf);</a>
<a name="ln2903">      }</a>
<a name="ln2904">    } else if (varp == &amp;p_ruf || s[0] != '%' || s[1] != '!') {</a>
<a name="ln2905">      // check 'statusline' only if it doesn't start with &quot;%!&quot;</a>
<a name="ln2906">      errmsg = check_stl_option(s);</a>
<a name="ln2907">    }</a>
<a name="ln2908">    if (varp == &amp;p_ruf &amp;&amp; errmsg == NULL) {</a>
<a name="ln2909">      comp_col();</a>
<a name="ln2910">    }</a>
<a name="ln2911">  } else if (gvarp == &amp;p_cpt) {</a>
<a name="ln2912">    // check if it is a valid value for 'complete' -- Acevedo</a>
<a name="ln2913">    for (s = *varp; *s; ) {</a>
<a name="ln2914">      while (*s == ',' || *s == ' ')</a>
<a name="ln2915">        s++;</a>
<a name="ln2916">      if (!*s) {</a>
<a name="ln2917">        break;</a>
<a name="ln2918">      }</a>
<a name="ln2919">      if (vim_strchr((char_u *)&quot;.wbuksid]tU&quot;, *s) == NULL) {</a>
<a name="ln2920">        errmsg = illegal_char(errbuf, errbuflen, *s);</a>
<a name="ln2921">        break;</a>
<a name="ln2922">      }</a>
<a name="ln2923">      if (*++s != NUL &amp;&amp; *s != ',' &amp;&amp; *s != ' ') {</a>
<a name="ln2924">        if (s[-1] == 'k' || s[-1] == 's') {</a>
<a name="ln2925">          // skip optional filename after 'k' and 's'</a>
<a name="ln2926">          while (*s &amp;&amp; *s != ',' &amp;&amp; *s != ' ') {</a>
<a name="ln2927">            if (*s == '\\' &amp;&amp; s[1] != NUL) {</a>
<a name="ln2928">              s++;</a>
<a name="ln2929">            }</a>
<a name="ln2930">            s++;</a>
<a name="ln2931">          }</a>
<a name="ln2932">        } else {</a>
<a name="ln2933">          if (errbuf != NULL) {</a>
<a name="ln2934">            vim_snprintf((char *)errbuf, errbuflen,</a>
<a name="ln2935">                         _(&quot;E535: Illegal character after &lt;%c&gt;&quot;),</a>
<a name="ln2936">                         *--s);</a>
<a name="ln2937">            errmsg = errbuf;</a>
<a name="ln2938">          } else</a>
<a name="ln2939">            errmsg = (char_u *)&quot;&quot;;</a>
<a name="ln2940">          break;</a>
<a name="ln2941">        }</a>
<a name="ln2942">      }</a>
<a name="ln2943">    }</a>
<a name="ln2944">  } else if (varp == &amp;p_cot) {  // 'completeopt'</a>
<a name="ln2945">    if (check_opt_strings(p_cot, p_cot_values, true) != OK) {</a>
<a name="ln2946">      errmsg = e_invarg;</a>
<a name="ln2947">    } else {</a>
<a name="ln2948">      completeopt_was_set();</a>
<a name="ln2949">    }</a>
<a name="ln2950">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2951">  } else if (gvarp == &amp;p_csl) {  // 'completeslash'</a>
<a name="ln2952">    if (check_opt_strings(p_csl, p_csl_values, false) != OK</a>
<a name="ln2953">        || check_opt_strings(curbuf-&gt;b_p_csl, p_csl_values, false) != OK) {</a>
<a name="ln2954">      errmsg = e_invarg;</a>
<a name="ln2955">    }</a>
<a name="ln2956">#endif</a>
<a name="ln2957">  } else if (varp == &amp;curwin-&gt;w_p_scl) {</a>
<a name="ln2958">    // 'signcolumn'</a>
<a name="ln2959">    if (check_signcolumn(*varp) != OK) {</a>
<a name="ln2960">      errmsg = e_invarg;</a>
<a name="ln2961">    }</a>
<a name="ln2962">    // When changing the 'signcolumn' to or from 'number', recompute the</a>
<a name="ln2963">    // width of the number column if 'number' or 'relativenumber' is set.</a>
<a name="ln2964">    if (((*oldval == 'n' &amp;&amp; *(oldval + 1) == 'u')</a>
<a name="ln2965">         || (*curwin-&gt;w_p_scl == 'n' &amp;&amp; *(curwin-&gt;w_p_scl + 1) =='u'))</a>
<a name="ln2966">        &amp;&amp; (curwin-&gt;w_p_nu || curwin-&gt;w_p_rnu)) {</a>
<a name="ln2967">      curwin-&gt;w_nrwidth_line_count = 0;</a>
<a name="ln2968">    }</a>
<a name="ln2969">  } else if (varp == &amp;curwin-&gt;w_p_fdc || varp == &amp;curwin-&gt;w_allbuf_opt.wo_fdc) {</a>
<a name="ln2970">    // 'foldcolumn'</a>
<a name="ln2971">    if (check_opt_strings(*varp, p_fdc_values, false) != OK) {</a>
<a name="ln2972">      errmsg = e_invarg;</a>
<a name="ln2973">    }</a>
<a name="ln2974">  } else if (varp == &amp;p_pt) {</a>
<a name="ln2975">    // 'pastetoggle': translate key codes like in a mapping</a>
<a name="ln2976">    if (*p_pt) {</a>
<a name="ln2977">      (void)replace_termcodes(p_pt, STRLEN(p_pt), &amp;p, true, true, true,</a>
<a name="ln2978">                              CPO_TO_CPO_FLAGS);</a>
<a name="ln2979">      if (p != NULL) {</a>
<a name="ln2980">        if (new_value_alloced) {</a>
<a name="ln2981">          free_string_option(p_pt);</a>
<a name="ln2982">        }</a>
<a name="ln2983">        p_pt = p;</a>
<a name="ln2984">        new_value_alloced = true;</a>
<a name="ln2985">      }</a>
<a name="ln2986">    }</a>
<a name="ln2987">  } else if (varp == &amp;p_bs) {  // 'backspace'</a>
<a name="ln2988">    if (ascii_isdigit(*p_bs)) {</a>
<a name="ln2989">      if (*p_bs &gt; '3' || p_bs[1] != NUL) {</a>
<a name="ln2990">        errmsg = e_invarg;</a>
<a name="ln2991">      }</a>
<a name="ln2992">    } else if (check_opt_strings(p_bs, p_bs_values, true) != OK) {</a>
<a name="ln2993">      errmsg = e_invarg;</a>
<a name="ln2994">    }</a>
<a name="ln2995">  } else if (varp == &amp;p_bo) {</a>
<a name="ln2996">    if (opt_strings_flags(p_bo, p_bo_values, &amp;bo_flags, true) != OK) {</a>
<a name="ln2997">      errmsg = e_invarg;</a>
<a name="ln2998">    }</a>
<a name="ln2999">  } else if (gvarp == &amp;p_tc) {  // 'tagcase'</a>
<a name="ln3000">    unsigned int *flags;</a>
<a name="ln3001"> </a>
<a name="ln3002">    if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln3003">      p = curbuf-&gt;b_p_tc;</a>
<a name="ln3004">      flags = &amp;curbuf-&gt;b_tc_flags;</a>
<a name="ln3005">    } else {</a>
<a name="ln3006">      p = p_tc;</a>
<a name="ln3007">      flags = &amp;tc_flags;</a>
<a name="ln3008">    }</a>
<a name="ln3009"> </a>
<a name="ln3010">    if ((opt_flags &amp; OPT_LOCAL) &amp;&amp; *p == NUL) {</a>
<a name="ln3011">      // make the local value empty: use the global value</a>
<a name="ln3012">      *flags = 0;</a>
<a name="ln3013">    } else if (*p == NUL</a>
<a name="ln3014">               || opt_strings_flags(p, p_tc_values, flags, false) != OK) {</a>
<a name="ln3015">      errmsg = e_invarg;</a>
<a name="ln3016">    }</a>
<a name="ln3017">  } else if (varp == &amp;p_cmp) {  // 'casemap'</a>
<a name="ln3018">    if (opt_strings_flags(p_cmp, p_cmp_values, &amp;cmp_flags, true) != OK) {</a>
<a name="ln3019">      errmsg = e_invarg;</a>
<a name="ln3020">    }</a>
<a name="ln3021">  } else if (varp == &amp;p_dip) {  // 'diffopt'</a>
<a name="ln3022">    if (diffopt_changed() == FAIL) {</a>
<a name="ln3023">      errmsg = e_invarg;</a>
<a name="ln3024">    }</a>
<a name="ln3025">  } else if (gvarp == &amp;curwin-&gt;w_allbuf_opt.wo_fdm) {  // 'foldmethod'</a>
<a name="ln3026">    if (check_opt_strings(*varp, p_fdm_values, false) != OK</a>
<a name="ln3027">        || *curwin-&gt;w_p_fdm == NUL) {</a>
<a name="ln3028">      errmsg = e_invarg;</a>
<a name="ln3029">    } else {</a>
<a name="ln3030">      foldUpdateAll(curwin);</a>
<a name="ln3031">      if (foldmethodIsDiff(curwin)) {</a>
<a name="ln3032">        newFoldLevel();</a>
<a name="ln3033">      }</a>
<a name="ln3034">    }</a>
<a name="ln3035">  } else if (varp == &amp;curwin-&gt;w_p_fde) {  // 'foldexpr'</a>
<a name="ln3036">    if (foldmethodIsExpr(curwin)) {</a>
<a name="ln3037">      foldUpdateAll(curwin);</a>
<a name="ln3038">    }</a>
<a name="ln3039">  } else if (gvarp == &amp;curwin-&gt;w_allbuf_opt.wo_fmr) {  // 'foldmarker'</a>
<a name="ln3040">    p = vim_strchr(*varp, ',');</a>
<a name="ln3041">    if (p == NULL) {</a>
<a name="ln3042">      errmsg = (char_u *)N_(&quot;E536: comma required&quot;);</a>
<a name="ln3043">    } else if (p == *varp || p[1] == NUL) {</a>
<a name="ln3044">      errmsg = e_invarg;</a>
<a name="ln3045">    } else if (foldmethodIsMarker(curwin)) {</a>
<a name="ln3046">      foldUpdateAll(curwin);</a>
<a name="ln3047">    }</a>
<a name="ln3048">  } else if (gvarp == &amp;p_cms) {  // 'commentstring'</a>
<a name="ln3049">    if (**varp != NUL &amp;&amp; strstr((char *)(*varp), &quot;%s&quot;) == NULL) {</a>
<a name="ln3050">      errmsg = (char_u *)N_(</a>
<a name="ln3051">          &quot;E537: 'commentstring' must be empty or contain %s&quot;);</a>
<a name="ln3052">    }</a>
<a name="ln3053">  } else if (varp == &amp;p_fdo) {  // 'foldopen'</a>
<a name="ln3054">    if (opt_strings_flags(p_fdo, p_fdo_values, &amp;fdo_flags, true) != OK) {</a>
<a name="ln3055">      errmsg = e_invarg;</a>
<a name="ln3056">    }</a>
<a name="ln3057">  } else if (varp == &amp;p_fcl) {  // 'foldclose'</a>
<a name="ln3058">    if (check_opt_strings(p_fcl, p_fcl_values, true) != OK) {</a>
<a name="ln3059">      errmsg = e_invarg;</a>
<a name="ln3060">    }</a>
<a name="ln3061">  } else if (gvarp == &amp;curwin-&gt;w_allbuf_opt.wo_fdi) {  // 'foldignore'</a>
<a name="ln3062">    if (foldmethodIsIndent(curwin)) {</a>
<a name="ln3063">      foldUpdateAll(curwin);</a>
<a name="ln3064">    }</a>
<a name="ln3065">  } else if (varp == &amp;p_ve) {  // 'virtualedit'</a>
<a name="ln3066">    if (opt_strings_flags(p_ve, p_ve_values, &amp;ve_flags, true) != OK) {</a>
<a name="ln3067">      errmsg = e_invarg;</a>
<a name="ln3068">    } else if (STRCMP(p_ve, oldval) != 0) {</a>
<a name="ln3069">      // Recompute cursor position in case the new 've' setting</a>
<a name="ln3070">      // changes something.</a>
<a name="ln3071">      validate_virtcol();</a>
<a name="ln3072">      coladvance(curwin-&gt;w_virtcol);</a>
<a name="ln3073">    }</a>
<a name="ln3074">  } else if (varp == &amp;p_csqf) {</a>
<a name="ln3075">    if (p_csqf != NULL) {</a>
<a name="ln3076">      p = p_csqf;</a>
<a name="ln3077">      while (*p != NUL) {</a>
<a name="ln3078">        if (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL</a>
<a name="ln3079">            || p[1] == NUL</a>
<a name="ln3080">            || vim_strchr((char_u *)CSQF_FLAGS, p[1]) == NULL</a>
<a name="ln3081">            || (p[2] != NUL &amp;&amp; p[2] != ',')) {</a>
<a name="ln3082">          errmsg = e_invarg;</a>
<a name="ln3083">          break;</a>
<a name="ln3084">        } else if (p[2] == NUL) {</a>
<a name="ln3085">          break;</a>
<a name="ln3086">        } else {</a>
<a name="ln3087">          p += 3;</a>
<a name="ln3088">        }</a>
<a name="ln3089">      }</a>
<a name="ln3090">    }</a>
<a name="ln3091">  } else if (gvarp == &amp;p_cino) {  // 'cinoptions'</a>
<a name="ln3092">    // TODO(vim): recognize errors</a>
<a name="ln3093">    parse_cino(curbuf);</a>
<a name="ln3094">  // inccommand</a>
<a name="ln3095">  } else if (varp == &amp;p_icm) {</a>
<a name="ln3096">      if (check_opt_strings(p_icm, p_icm_values, false) != OK) {</a>
<a name="ln3097">        errmsg = e_invarg;</a>
<a name="ln3098">      }</a>
<a name="ln3099">  } else if (gvarp == &amp;p_ft) {</a>
<a name="ln3100">    if (!valid_filetype(*varp)) {</a>
<a name="ln3101">      errmsg = e_invarg;</a>
<a name="ln3102">    } else {</a>
<a name="ln3103">      value_changed = STRCMP(oldval, *varp) != 0;</a>
<a name="ln3104"> </a>
<a name="ln3105">      // Since we check the value, there is no need to set P_INSECURE,</a>
<a name="ln3106">      // even when the value comes from a modeline.</a>
<a name="ln3107">      *value_checked = true;</a>
<a name="ln3108">    }</a>
<a name="ln3109">  } else if (gvarp == &amp;p_syn) {</a>
<a name="ln3110">    if (!valid_filetype(*varp)) {</a>
<a name="ln3111">      errmsg = e_invarg;</a>
<a name="ln3112">    } else {</a>
<a name="ln3113">      value_changed = STRCMP(oldval, *varp) != 0;</a>
<a name="ln3114"> </a>
<a name="ln3115">      // Since we check the value, there is no need to set P_INSECURE,</a>
<a name="ln3116">      // even when the value comes from a modeline.</a>
<a name="ln3117">      *value_checked = true;</a>
<a name="ln3118">    }</a>
<a name="ln3119">  } else if (varp == &amp;curwin-&gt;w_p_winhl) {</a>
<a name="ln3120">    if (!parse_winhl_opt(curwin)) {</a>
<a name="ln3121">      errmsg = e_invarg;</a>
<a name="ln3122">    }</a>
<a name="ln3123">  } else if (varp == &amp;p_tpf) {</a>
<a name="ln3124">    if (opt_strings_flags(p_tpf, p_tpf_values, &amp;tpf_flags, true) != OK) {</a>
<a name="ln3125">      errmsg = e_invarg;</a>
<a name="ln3126">    }</a>
<a name="ln3127">  } else if (varp == &amp;(curbuf-&gt;b_p_vsts)) {  // 'varsofttabstop'</a>
<a name="ln3128">    char_u *cp;</a>
<a name="ln3129"> </a>
<a name="ln3130">    if (!(*varp)[0] || ((*varp)[0] == '0' &amp;&amp; !(*varp)[1])) {</a>
<a name="ln3131">      if (curbuf-&gt;b_p_vsts_array) {</a>
<a name="ln3132">        xfree(curbuf-&gt;b_p_vsts_array);</a>
<a name="ln3133">        curbuf-&gt;b_p_vsts_array = 0;</a>
<a name="ln3134">      }</a>
<a name="ln3135">    } else {</a>
<a name="ln3136">      for (cp = *varp; *cp; cp++) {</a>
<a name="ln3137">        if (ascii_isdigit(*cp)) {</a>
<a name="ln3138">          continue;</a>
<a name="ln3139">        }</a>
<a name="ln3140">        if (*cp == ',' &amp;&amp; cp &gt; *varp &amp;&amp; *(cp - 1) != ',') {</a>
<a name="ln3141">          continue;</a>
<a name="ln3142">        }</a>
<a name="ln3143">        errmsg = e_invarg;</a>
<a name="ln3144">        break;</a>
<a name="ln3145">      }</a>
<a name="ln3146">      if (errmsg == NULL) {</a>
<a name="ln3147">        long *oldarray = curbuf-&gt;b_p_vsts_array;</a>
<a name="ln3148">        if (tabstop_set(*varp, &amp;(curbuf-&gt;b_p_vsts_array))) {</a>
<a name="ln3149">          xfree(oldarray);</a>
<a name="ln3150">        } else {</a>
<a name="ln3151">          errmsg = e_invarg;</a>
<a name="ln3152">        }</a>
<a name="ln3153">      }</a>
<a name="ln3154">    }</a>
<a name="ln3155">  } else if (varp == &amp;(curbuf-&gt;b_p_vts)) {  // 'vartabstop'</a>
<a name="ln3156">    char_u *cp;</a>
<a name="ln3157"> </a>
<a name="ln3158">    if (!(*varp)[0] || ((*varp)[0] == '0' &amp;&amp; !(*varp)[1])) {</a>
<a name="ln3159">      if (curbuf-&gt;b_p_vts_array) {</a>
<a name="ln3160">        xfree(curbuf-&gt;b_p_vts_array);</a>
<a name="ln3161">        curbuf-&gt;b_p_vts_array = NULL;</a>
<a name="ln3162">      }</a>
<a name="ln3163">    } else {</a>
<a name="ln3164">      for (cp = *varp; *cp; cp++) {</a>
<a name="ln3165">        if (ascii_isdigit(*cp)) {</a>
<a name="ln3166">          continue;</a>
<a name="ln3167">        }</a>
<a name="ln3168">        if (*cp == ',' &amp;&amp; cp &gt; *varp &amp;&amp; *(cp - 1) != ',') {</a>
<a name="ln3169">          continue;</a>
<a name="ln3170">        }</a>
<a name="ln3171">        errmsg = e_invarg;</a>
<a name="ln3172">        break;</a>
<a name="ln3173">      }</a>
<a name="ln3174">      if (errmsg == NULL) {</a>
<a name="ln3175">        long *oldarray = curbuf-&gt;b_p_vts_array;</a>
<a name="ln3176">        if (tabstop_set(*varp, &amp;(curbuf-&gt;b_p_vts_array))) {</a>
<a name="ln3177">          xfree(oldarray);</a>
<a name="ln3178">          if (foldmethodIsIndent(curwin)) {</a>
<a name="ln3179">            foldUpdateAll(curwin);</a>
<a name="ln3180">          }</a>
<a name="ln3181">        } else {</a>
<a name="ln3182">          errmsg = e_invarg;</a>
<a name="ln3183">        }</a>
<a name="ln3184">      }</a>
<a name="ln3185">    }</a>
<a name="ln3186">  } else if (varp == &amp;p_qftf) {</a>
<a name="ln3187">    if (!qf_process_qftf_option()) {</a>
<a name="ln3188">      errmsg = e_invarg;</a>
<a name="ln3189">    }</a>
<a name="ln3190">  } else {</a>
<a name="ln3191">    // Options that are a list of flags.</a>
<a name="ln3192">    p = NULL;</a>
<a name="ln3193">    if (varp == &amp;p_ww) {  // 'whichwrap'</a>
<a name="ln3194">      p = (char_u *)WW_ALL;</a>
<a name="ln3195">    }</a>
<a name="ln3196">    if (varp == &amp;p_shm) {  // 'shortmess'</a>
<a name="ln3197">      p = (char_u *)SHM_ALL;</a>
<a name="ln3198">    } else if (varp == &amp;(p_cpo)) {  // 'cpoptions'</a>
<a name="ln3199">      p = (char_u *)CPO_VI;</a>
<a name="ln3200">    } else if (varp == &amp;(curbuf-&gt;b_p_fo)) {  // 'formatoptions'</a>
<a name="ln3201">      p = (char_u *)FO_ALL;</a>
<a name="ln3202">    } else if (varp == &amp;curwin-&gt;w_p_cocu) {  // 'concealcursor'</a>
<a name="ln3203">      p = (char_u *)COCU_ALL;</a>
<a name="ln3204">    } else if (varp == &amp;p_mouse) {  // 'mouse'</a>
<a name="ln3205">      p = (char_u *)MOUSE_ALL;</a>
<a name="ln3206">    }</a>
<a name="ln3207">    if (p != NULL) {</a>
<a name="ln3208">      for (s = *varp; *s; s++) {</a>
<a name="ln3209">        if (vim_strchr(p, *s) == NULL) {</a>
<a name="ln3210">          errmsg = illegal_char(errbuf, errbuflen, *s);</a>
<a name="ln3211">          break;</a>
<a name="ln3212">        }</a>
<a name="ln3213">      }</a>
<a name="ln3214">    }</a>
<a name="ln3215">  }</a>
<a name="ln3216"> </a>
<a name="ln3217">  /*</a>
<a name="ln3218">   * If error detected, restore the previous value.</a>
<a name="ln3219">   */</a>
<a name="ln3220">  if (errmsg != NULL) {</a>
<a name="ln3221">    if (new_value_alloced) {</a>
<a name="ln3222">      free_string_option(*varp);</a>
<a name="ln3223">    }</a>
<a name="ln3224">    *varp = oldval;</a>
<a name="ln3225">    /*</a>
<a name="ln3226">     * When resetting some values, need to act on it.</a>
<a name="ln3227">     */</a>
<a name="ln3228">    if (did_chartab) {</a>
<a name="ln3229">      (void)init_chartab();</a>
<a name="ln3230">    }</a>
<a name="ln3231">  } else {</a>
<a name="ln3232">    // Remember where the option was set.</a>
<a name="ln3233">    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln3234">    // Free string options that are in allocated memory.</a>
<a name="ln3235">    // Use &quot;free_oldval&quot;, because recursiveness may change the flags under</a>
<a name="ln3236">    // our fingers (esp. init_highlight()).</a>
<a name="ln3237">    if (free_oldval) {</a>
<a name="ln3238">      free_string_option(oldval);</a>
<a name="ln3239">    }</a>
<a name="ln3240">    if (new_value_alloced) {</a>
<a name="ln3241">      options[opt_idx].flags |= P_ALLOCED;</a>
<a name="ln3242">    } else {</a>
<a name="ln3243">      options[opt_idx].flags &amp;= ~P_ALLOCED;</a>
<a name="ln3244">    }</a>
<a name="ln3245"> </a>
<a name="ln3246">    if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0</a>
<a name="ln3247">        &amp;&amp; ((int)options[opt_idx].indir &amp; PV_BOTH)) {</a>
<a name="ln3248">      /* global option with local value set to use global value; free</a>
<a name="ln3249">       * the local value and make it empty */</a>
<a name="ln3250">      p = get_varp_scope(&amp;(options[opt_idx]), OPT_LOCAL);</a>
<a name="ln3251">      free_string_option(*(char_u **)p);</a>
<a name="ln3252">      *(char_u **)p = empty_option;</a>
<a name="ln3253">    } else if (!(opt_flags &amp; OPT_LOCAL) &amp;&amp; opt_flags != OPT_GLOBAL) {</a>
<a name="ln3254">      // May set global value for local option.</a>
<a name="ln3255">      set_string_option_global(opt_idx, varp);</a>
<a name="ln3256">    }</a>
<a name="ln3257"> </a>
<a name="ln3258">    /*</a>
<a name="ln3259">     * Trigger the autocommand only after setting the flags.</a>
<a name="ln3260">     */</a>
<a name="ln3261">    // When 'syntax' is set, load the syntax of that name</a>
<a name="ln3262">    if (varp == &amp;(curbuf-&gt;b_p_syn)) {</a>
<a name="ln3263">      static int syn_recursive = 0;</a>
<a name="ln3264"> </a>
<a name="ln3265">      syn_recursive++;</a>
<a name="ln3266">      // Only pass true for &quot;force&quot; when the value changed or not used</a>
<a name="ln3267">      // recursively, to avoid endless recurrence.</a>
<a name="ln3268">      apply_autocmds(EVENT_SYNTAX, curbuf-&gt;b_p_syn, curbuf-&gt;b_fname,</a>
<a name="ln3269">                     value_changed || syn_recursive == 1, curbuf);</a>
<a name="ln3270">      curbuf-&gt;b_flags |= BF_SYN_SET;</a>
<a name="ln3271">      syn_recursive--;</a>
<a name="ln3272">    } else if (varp == &amp;(curbuf-&gt;b_p_ft)) {</a>
<a name="ln3273">      // 'filetype' is set, trigger the FileType autocommand</a>
<a name="ln3274">      // Skip this when called from a modeline and the filetype was</a>
<a name="ln3275">      // already set to this value.</a>
<a name="ln3276">      if (!(opt_flags &amp; OPT_MODELINE) || value_changed) {</a>
<a name="ln3277">        static int ft_recursive = 0;</a>
<a name="ln3278">        int secure_save = secure;</a>
<a name="ln3279"> </a>
<a name="ln3280">        // Reset the secure flag, since the value of 'filetype' has</a>
<a name="ln3281">        // been checked to be safe.</a>
<a name="ln3282">        secure = 0;</a>
<a name="ln3283"> </a>
<a name="ln3284">        ft_recursive++;</a>
<a name="ln3285">        did_filetype = true;</a>
<a name="ln3286">        // Only pass true for &quot;force&quot; when the value changed or not</a>
<a name="ln3287">        // used recursively, to avoid endless recurrence.</a>
<a name="ln3288">        apply_autocmds(EVENT_FILETYPE, curbuf-&gt;b_p_ft, curbuf-&gt;b_fname,</a>
<a name="ln3289">                       value_changed || ft_recursive == 1, curbuf);</a>
<a name="ln3290">        ft_recursive--;</a>
<a name="ln3291">        // Just in case the old &quot;curbuf&quot; is now invalid</a>
<a name="ln3292">        if (varp != &amp;(curbuf-&gt;b_p_ft)) {</a>
<a name="ln3293">          varp = NULL;</a>
<a name="ln3294">        }</a>
<a name="ln3295">        secure = secure_save;</a>
<a name="ln3296">      }</a>
<a name="ln3297">    }</a>
<a name="ln3298">    if (varp == &amp;(curwin-&gt;w_s-&gt;b_p_spl)) {</a>
<a name="ln3299">      char_u fname[200];</a>
<a name="ln3300">      char_u      *q = curwin-&gt;w_s-&gt;b_p_spl;</a>
<a name="ln3301"> </a>
<a name="ln3302">      // Skip the first name if it is &quot;cjk&quot;.</a>
<a name="ln3303">      if (STRNCMP(q, &quot;cjk,&quot;, 4) == 0) {</a>
<a name="ln3304">        q += 4;</a>
<a name="ln3305">      }</a>
<a name="ln3306"> </a>
<a name="ln3307">      /*</a>
<a name="ln3308">       * Source the spell/LANG.vim in 'runtimepath'.</a>
<a name="ln3309">       * They could set 'spellcapcheck' depending on the language.</a>
<a name="ln3310">       * Use the first name in 'spelllang' up to '_region' or</a>
<a name="ln3311">       * '.encoding'.</a>
<a name="ln3312">       */</a>
<a name="ln3313">      for (p = q; *p != NUL; p++) {</a>
<a name="ln3314">        if (!ASCII_ISALNUM(*p) &amp;&amp; *p != '-') {</a>
<a name="ln3315">          break;</a>
<a name="ln3316">        }</a>
<a name="ln3317">      }</a>
<a name="ln3318">      if (p &gt; q) {</a>
<a name="ln3319">        vim_snprintf((char *)fname, sizeof(fname), &quot;spell/%.*s.vim&quot;,</a>
<a name="ln3320">                     (int)(p - q), q);</a>
<a name="ln3321">        source_runtime(fname, DIP_ALL);</a>
<a name="ln3322">      }</a>
<a name="ln3323">    }</a>
<a name="ln3324">  }</a>
<a name="ln3325"> </a>
<a name="ln3326">  if (varp == &amp;p_mouse) {</a>
<a name="ln3327">    setmouse();  // in case 'mouse' changed</a>
<a name="ln3328">  }</a>
<a name="ln3329"> </a>
<a name="ln3330">  if (curwin-&gt;w_curswant != MAXCOL</a>
<a name="ln3331">      &amp;&amp; (options[opt_idx].flags &amp; (P_CURSWANT | P_RALL)) != 0)</a>
<a name="ln3332">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln3333"> </a>
<a name="ln3334">  check_redraw(options[opt_idx].flags);</a>
<a name="ln3335"> </a>
<a name="ln3336">  return errmsg;</a>
<a name="ln3337">}  // NOLINT(readability/fn_size)</a>
<a name="ln3338"> </a>
<a name="ln3339">/// Simple int comparison function for use with qsort()</a>
<a name="ln3340">static int int_cmp(const void *a, const void *b)</a>
<a name="ln3341">{</a>
<a name="ln3342">  return *(const int *)a - *(const int *)b;</a>
<a name="ln3343">}</a>
<a name="ln3344"> </a>
<a name="ln3345">/// Handle setting 'signcolumn' for value 'val'</a>
<a name="ln3346">///</a>
<a name="ln3347">/// @return OK when the value is valid, FAIL otherwise</a>
<a name="ln3348">int check_signcolumn(char_u *val)</a>
<a name="ln3349">{</a>
<a name="ln3350">  // check for basic match</a>
<a name="ln3351">  if (check_opt_strings(val, p_scl_values, false) == OK) {</a>
<a name="ln3352">    return OK;</a>
<a name="ln3353">  }</a>
<a name="ln3354"> </a>
<a name="ln3355">  // check for 'auto:&lt;NUMBER&gt;-&lt;NUMBER&gt;'</a>
<a name="ln3356">  if (STRLEN(val) == 8</a>
<a name="ln3357">      &amp;&amp; !STRNCMP(val, &quot;auto:&quot;, 5)</a>
<a name="ln3358">      &amp;&amp; ascii_isdigit(val[5])</a>
<a name="ln3359">      &amp;&amp; val[6] == '-'</a>
<a name="ln3360">      &amp;&amp; ascii_isdigit(val[7])</a>
<a name="ln3361">      ) {</a>
<a name="ln3362">    int min = val[5] - '0';</a>
<a name="ln3363">    int max = val[7] - '0';</a>
<a name="ln3364">    if (min &lt; 1 || max &lt; 2 || min &gt; 8 || max &gt; 9 || min &gt;= max) {</a>
<a name="ln3365">      return FAIL;</a>
<a name="ln3366">    }</a>
<a name="ln3367">    return OK;</a>
<a name="ln3368">  }</a>
<a name="ln3369"> </a>
<a name="ln3370">  return FAIL;</a>
<a name="ln3371">}</a>
<a name="ln3372"> </a>
<a name="ln3373">/// Handle setting 'colorcolumn' or 'textwidth' in window &quot;wp&quot;.</a>
<a name="ln3374">///</a>
<a name="ln3375">/// @return error message, NULL if it's OK.</a>
<a name="ln3376">char_u *check_colorcolumn(win_T *wp)</a>
<a name="ln3377">{</a>
<a name="ln3378">  char_u      *s;</a>
<a name="ln3379">  int col;</a>
<a name="ln3380">  unsigned int count = 0;</a>
<a name="ln3381">  int color_cols[256];</a>
<a name="ln3382">  int j = 0;</a>
<a name="ln3383"> </a>
<a name="ln3384">  if (wp-&gt;w_buffer == NULL) {</a>
<a name="ln3385">    return NULL;      // buffer was closed</a>
<a name="ln3386">  }</a>
<a name="ln3387"> </a>
<a name="ln3388">  for (s = wp-&gt;w_p_cc; *s != NUL &amp;&amp; count &lt; 255; ) {</a>
<a name="ln3389">    if (*s == '-' || *s == '+') {</a>
<a name="ln3390">      // -N and +N: add to 'textwidth'</a>
<a name="ln3391">      col = (*s == '-') ? -1 : 1;</a>
<a name="ln3392">      s++;</a>
<a name="ln3393">      if (!ascii_isdigit(*s)) {</a>
<a name="ln3394">        return e_invarg;</a>
<a name="ln3395">      }</a>
<a name="ln3396">      col = col * getdigits_int(&amp;s, true, 0);</a>
<a name="ln3397">      if (wp-&gt;w_buffer-&gt;b_p_tw == 0) {</a>
<a name="ln3398">        goto skip;          // 'textwidth' not set, skip this item</a>
<a name="ln3399">      }</a>
<a name="ln3400">      assert((col &gt;= 0</a>
<a name="ln3401">              &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw &lt;= INT_MAX - col</a>
<a name="ln3402">              &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw + col &gt;= INT_MIN)</a>
<a name="ln3403">             || (col &lt; 0</a>
<a name="ln3404">                 &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw &gt;= INT_MIN - col</a>
<a name="ln3405">                 &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw + col &lt;= INT_MAX));</a>
<a name="ln3406">      col += (int)wp-&gt;w_buffer-&gt;b_p_tw;</a>
<a name="ln3407">      if (col &lt; 0) {</a>
<a name="ln3408">        goto skip;</a>
<a name="ln3409">      }</a>
<a name="ln3410">    } else if (ascii_isdigit(*s)) {</a>
<a name="ln3411">      col = getdigits_int(&amp;s, true, 0);</a>
<a name="ln3412">    } else {</a>
<a name="ln3413">      return e_invarg;</a>
<a name="ln3414">    }</a>
<a name="ln3415">    color_cols[count++] = col - 1;      // 1-based to 0-based</a>
<a name="ln3416">skip:</a>
<a name="ln3417">    if (*s == NUL) {</a>
<a name="ln3418">      break;</a>
<a name="ln3419">    }</a>
<a name="ln3420">    if (*s != ',') {</a>
<a name="ln3421">      return e_invarg;</a>
<a name="ln3422">    }</a>
<a name="ln3423">    if (*++s == NUL) {</a>
<a name="ln3424">      return e_invarg;        // illegal trailing comma as in &quot;set cc=80,&quot;</a>
<a name="ln3425">    }</a>
<a name="ln3426">  }</a>
<a name="ln3427"> </a>
<a name="ln3428">  xfree(wp-&gt;w_p_cc_cols);</a>
<a name="ln3429">  if (count == 0) {</a>
<a name="ln3430">    wp-&gt;w_p_cc_cols = NULL;</a>
<a name="ln3431">  } else {</a>
<a name="ln3432">    wp-&gt;w_p_cc_cols = xmalloc(sizeof(int) * (count + 1));</a>
<a name="ln3433">    /* sort the columns for faster usage on screen redraw inside</a>
<a name="ln3434">     * win_line() */</a>
<a name="ln3435">    qsort(color_cols, count, sizeof(int), int_cmp);</a>
<a name="ln3436"> </a>
<a name="ln3437">    for (unsigned int i = 0; i &lt; count; i++) {</a>
<a name="ln3438">      // skip duplicates</a>
<a name="ln3439">      if (j == 0 || wp-&gt;w_p_cc_cols[j - 1] != color_cols[i]) {</a>
<a name="ln3440">        wp-&gt;w_p_cc_cols[j++] = color_cols[i];</a>
<a name="ln3441">      }</a>
<a name="ln3442">    }</a>
<a name="ln3443">    wp-&gt;w_p_cc_cols[j] = -1;        // end marker</a>
<a name="ln3444">  }</a>
<a name="ln3445"> </a>
<a name="ln3446">  return NULL;    // no error</a>
<a name="ln3447">}</a>
<a name="ln3448"> </a>
<a name="ln3449">void check_blending(win_T *wp)</a>
<a name="ln3450">{</a>
<a name="ln3451">  wp-&gt;w_grid_alloc.blending =</a>
<a name="ln3452">    wp-&gt;w_p_winbl &gt; 0 || (wp-&gt;w_floating &amp;&amp; wp-&gt;w_float_config.shadow);</a>
<a name="ln3453">}</a>
<a name="ln3454"> </a>
<a name="ln3455"> </a>
<a name="ln3456">/// Handle setting 'listchars' or 'fillchars'.</a>
<a name="ln3457">/// Assume monocell characters</a>
<a name="ln3458">///</a>
<a name="ln3459">/// @param varp either &amp;curwin-&gt;w_p_lcs or &amp;curwin-&gt;w_p_fcs</a>
<a name="ln3460">/// @return error message, NULL if it's OK.</a>
<a name="ln3461">static char_u *set_chars_option(win_T *wp, char_u **varp, bool set)</a>
<a name="ln3462">{</a>
<a name="ln3463">  int round, i, len, entries;</a>
<a name="ln3464">  char_u *p, *s;</a>
<a name="ln3465">  int c1;</a>
<a name="ln3466">  int c2 = 0;</a>
<a name="ln3467">  int c3 = 0;</a>
<a name="ln3468"> </a>
<a name="ln3469">  struct chars_tab {</a>
<a name="ln3470">    int     *cp;    ///&lt; char value</a>
<a name="ln3471">    char    *name;  ///&lt; char id</a>
<a name="ln3472">    int     def;    ///&lt; default value</a>
<a name="ln3473">  };</a>
<a name="ln3474">  struct chars_tab *tab;</a>
<a name="ln3475"> </a>
<a name="ln3476">  struct chars_tab fcs_tab[] = {</a>
<a name="ln3477">    { &amp;wp-&gt;w_p_fcs_chars.stl,     &quot;stl&quot;,      ' '  },</a>
<a name="ln3478">    { &amp;wp-&gt;w_p_fcs_chars.stlnc,   &quot;stlnc&quot;,    ' '  },</a>
<a name="ln3479">    { &amp;wp-&gt;w_p_fcs_chars.vert,    &quot;vert&quot;,     9474 },  // </a>
<a name="ln3480">    { &amp;wp-&gt;w_p_fcs_chars.fold,    &quot;fold&quot;,     183  },  // </a>
<a name="ln3481">    { &amp;wp-&gt;w_p_fcs_chars.foldopen,   &quot;foldopen&quot;,  '-'  },</a>
<a name="ln3482">    { &amp;wp-&gt;w_p_fcs_chars.foldclosed, &quot;foldclose&quot;, '+'  },</a>
<a name="ln3483">    { &amp;wp-&gt;w_p_fcs_chars.foldsep,    &quot;foldsep&quot;,   9474 },  // </a>
<a name="ln3484">    { &amp;wp-&gt;w_p_fcs_chars.diff,    &quot;diff&quot;,     '-'  },</a>
<a name="ln3485">    { &amp;wp-&gt;w_p_fcs_chars.msgsep,  &quot;msgsep&quot;,   ' '  },</a>
<a name="ln3486">    { &amp;wp-&gt;w_p_fcs_chars.eob,     &quot;eob&quot;,      '~'  },</a>
<a name="ln3487">  };</a>
<a name="ln3488">  struct chars_tab lcs_tab[] = {</a>
<a name="ln3489">    { &amp;wp-&gt;w_p_lcs_chars.eol,     &quot;eol&quot;,      NUL  },</a>
<a name="ln3490">    { &amp;wp-&gt;w_p_lcs_chars.ext,     &quot;extends&quot;,  NUL  },</a>
<a name="ln3491">    { &amp;wp-&gt;w_p_lcs_chars.nbsp,    &quot;nbsp&quot;,     NUL  },</a>
<a name="ln3492">    { &amp;wp-&gt;w_p_lcs_chars.prec,    &quot;precedes&quot;, NUL  },</a>
<a name="ln3493">    { &amp;wp-&gt;w_p_lcs_chars.space,   &quot;space&quot;,    NUL  },</a>
<a name="ln3494">    { &amp;wp-&gt;w_p_lcs_chars.tab2,    &quot;tab&quot;,      NUL  },</a>
<a name="ln3495">    { &amp;wp-&gt;w_p_lcs_chars.lead,    &quot;lead&quot;,     NUL  },</a>
<a name="ln3496">    { &amp;wp-&gt;w_p_lcs_chars.trail,   &quot;trail&quot;,    NUL  },</a>
<a name="ln3497">    { &amp;wp-&gt;w_p_lcs_chars.conceal, &quot;conceal&quot;,  NUL  },</a>
<a name="ln3498">  };</a>
<a name="ln3499"> </a>
<a name="ln3500">  if (varp == &amp;p_lcs || varp == &amp;wp-&gt;w_p_lcs) {</a>
<a name="ln3501">    tab = lcs_tab;</a>
<a name="ln3502">    entries = ARRAY_SIZE(lcs_tab);</a>
<a name="ln3503">    if (varp == &amp;wp-&gt;w_p_lcs &amp;&amp; wp-&gt;w_p_lcs[0] == NUL) {</a>
<a name="ln3504">      varp = &amp;p_lcs;</a>
<a name="ln3505">    }</a>
<a name="ln3506">  } else {</a>
<a name="ln3507">    tab = fcs_tab;</a>
<a name="ln3508">    entries = ARRAY_SIZE(fcs_tab);</a>
<a name="ln3509">    if (varp == &amp;wp-&gt;w_p_fcs &amp;&amp; wp-&gt;w_p_fcs[0] == NUL) {</a>
<a name="ln3510">      varp = &amp;p_fcs;</a>
<a name="ln3511">    }</a>
<a name="ln3512">    if (*p_ambw == 'd') {</a>
<a name="ln3513">      // XXX: If ambiwidth=double then &quot;|&quot; and &quot;&quot; take 2 columns, which is</a>
<a name="ln3514">      // forbidden (TUI limitation?). Set old defaults.</a>
<a name="ln3515">      fcs_tab[2].def = '|';</a>
<a name="ln3516">      fcs_tab[6].def = '|';</a>
<a name="ln3517">      fcs_tab[3].def = '-';</a>
<a name="ln3518">    } else {</a>
<a name="ln3519">      fcs_tab[2].def = 9474;  // </a>
<a name="ln3520">      fcs_tab[6].def = 9474;  // </a>
<a name="ln3521">      fcs_tab[3].def = 183;   // </a>
<a name="ln3522">    }</a>
<a name="ln3523">  }</a>
<a name="ln3524"> </a>
<a name="ln3525">  // first round: check for valid value, second round: assign values</a>
<a name="ln3526">  for (round = 0; round &lt;= (set ? 1 : 0); round++) {</a>
<a name="ln3527">    if (round &gt; 0) {</a>
<a name="ln3528">      // After checking that the value is valid: set defaults</a>
<a name="ln3529">      for (i = 0; i &lt; entries; i++) {</a>
<a name="ln3530">        if (tab[i].cp != NULL) {</a>
<a name="ln3531">          *(tab[i].cp) = tab[i].def;</a>
<a name="ln3532">        }</a>
<a name="ln3533">      }</a>
<a name="ln3534">      if (varp == &amp;p_lcs || varp == &amp;wp-&gt;w_p_lcs) {</a>
<a name="ln3535">        wp-&gt;w_p_lcs_chars.tab1 = NUL;</a>
<a name="ln3536">        wp-&gt;w_p_lcs_chars.tab3 = NUL;</a>
<a name="ln3537">      }</a>
<a name="ln3538">    }</a>
<a name="ln3539">    p = *varp;</a>
<a name="ln3540">    while (*p) {</a>
<a name="ln3541">      for (i = 0; i &lt; entries; i++) {</a>
<a name="ln3542">        len = (int)STRLEN(tab[i].name);</a>
<a name="ln3543">        if (STRNCMP(p, tab[i].name, len) == 0</a>
<a name="ln3544">            &amp;&amp; p[len] == ':'</a>
<a name="ln3545">            &amp;&amp; p[len + 1] != NUL) {</a>
<a name="ln3546">          c2 = c3 = 0;</a>
<a name="ln3547">          s = p + len + 1;</a>
<a name="ln3548"> </a>
<a name="ln3549">          // TODO(bfredl): use schar_T representation and utfc_ptr2len</a>
<a name="ln3550">          int c1len = utf_ptr2len(s);</a>
<a name="ln3551">          c1 = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln3552">          if (mb_char2cells(c1) &gt; 1 || (c1len == 1 &amp;&amp; c1 &gt; 127)) {</a>
<a name="ln3553">            continue;</a>
<a name="ln3554">          }</a>
<a name="ln3555">          if (tab[i].cp == &amp;wp-&gt;w_p_lcs_chars.tab2) {</a>
<a name="ln3556">            if (*s == NUL) {</a>
<a name="ln3557">              continue;</a>
<a name="ln3558">            }</a>
<a name="ln3559">            int c2len = utf_ptr2len(s);</a>
<a name="ln3560">            c2 = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln3561">            if (mb_char2cells(c2) &gt; 1 || (c2len == 1 &amp;&amp; c2 &gt; 127)) {</a>
<a name="ln3562">              continue;</a>
<a name="ln3563">            }</a>
<a name="ln3564">            if (!(*s == ',' || *s == NUL)) {</a>
<a name="ln3565">              int c3len = utf_ptr2len(s);</a>
<a name="ln3566">              c3 = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln3567">              if (mb_char2cells(c3) &gt; 1 || (c3len == 1 &amp;&amp; c3 &gt; 127)) {</a>
<a name="ln3568">                continue;</a>
<a name="ln3569">              }</a>
<a name="ln3570">            }</a>
<a name="ln3571">          }</a>
<a name="ln3572">          if (*s == ',' || *s == NUL) {</a>
<a name="ln3573">            if (round) {</a>
<a name="ln3574">              if (tab[i].cp == &amp;wp-&gt;w_p_lcs_chars.tab2) {</a>
<a name="ln3575">                wp-&gt;w_p_lcs_chars.tab1 = c1;</a>
<a name="ln3576">                wp-&gt;w_p_lcs_chars.tab2 = c2;</a>
<a name="ln3577">                wp-&gt;w_p_lcs_chars.tab3 = c3;</a>
<a name="ln3578">              } else if (tab[i].cp != NULL) {</a>
<a name="ln3579">                *(tab[i].cp) = c1;</a>
<a name="ln3580">              }</a>
<a name="ln3581">            }</a>
<a name="ln3582">            p = s;</a>
<a name="ln3583">            break;</a>
<a name="ln3584">          }</a>
<a name="ln3585">        }</a>
<a name="ln3586">      }</a>
<a name="ln3587"> </a>
<a name="ln3588">      if (i == entries) {</a>
<a name="ln3589">        return e_invarg;</a>
<a name="ln3590">      }</a>
<a name="ln3591">      if (*p == ',') {</a>
<a name="ln3592">        p++;</a>
<a name="ln3593">      }</a>
<a name="ln3594">    }</a>
<a name="ln3595">  }</a>
<a name="ln3596"> </a>
<a name="ln3597">  return NULL;          // no error</a>
<a name="ln3598">}</a>
<a name="ln3599"> </a>
<a name="ln3600">/// Check validity of options with the 'statusline' format.</a>
<a name="ln3601">/// Return error message or NULL.</a>
<a name="ln3602">char_u *check_stl_option(char_u *s)</a>
<a name="ln3603">{</a>
<a name="ln3604">  int groupdepth = 0;</a>
<a name="ln3605">  static char_u errbuf[80];</a>
<a name="ln3606"> </a>
<a name="ln3607">  while (*s) {</a>
<a name="ln3608">    // Check for valid keys after % sequences</a>
<a name="ln3609">    while (*s &amp;&amp; *s != '%') {</a>
<a name="ln3610">      s++;</a>
<a name="ln3611">    }</a>
<a name="ln3612">    if (!*s) {</a>
<a name="ln3613">      break;</a>
<a name="ln3614">    }</a>
<a name="ln3615">    s++;</a>
<a name="ln3616">    if (*s == '%' || *s == STL_TRUNCMARK || *s == STL_SEPARATE) {</a>
<a name="ln3617">      s++;</a>
<a name="ln3618">      continue;</a>
<a name="ln3619">    }</a>
<a name="ln3620">    if (*s == ')') {</a>
<a name="ln3621">      s++;</a>
<a name="ln3622">      if (--groupdepth &lt; 0) {</a>
<a name="ln3623">        break;</a>
<a name="ln3624">      }</a>
<a name="ln3625">      continue;</a>
<a name="ln3626">    }</a>
<a name="ln3627">    if (*s == '-') {</a>
<a name="ln3628">      s++;</a>
<a name="ln3629">    }</a>
<a name="ln3630">    while (ascii_isdigit(*s)) {</a>
<a name="ln3631">      s++;</a>
<a name="ln3632">    }</a>
<a name="ln3633">    if (*s == STL_USER_HL) {</a>
<a name="ln3634">      continue;</a>
<a name="ln3635">    }</a>
<a name="ln3636">    if (*s == '.') {</a>
<a name="ln3637">      s++;</a>
<a name="ln3638">      while (*s &amp;&amp; ascii_isdigit(*s))</a>
<a name="ln3639">        s++;</a>
<a name="ln3640">    }</a>
<a name="ln3641">    if (*s == '(') {</a>
<a name="ln3642">      groupdepth++;</a>
<a name="ln3643">      continue;</a>
<a name="ln3644">    }</a>
<a name="ln3645">    if (vim_strchr(STL_ALL, *s) == NULL) {</a>
<a name="ln3646">      return illegal_char(errbuf, sizeof(errbuf), *s);</a>
<a name="ln3647">    }</a>
<a name="ln3648">    if (*s == '{') {</a>
<a name="ln3649">      int reevaluate = (*s == '%');</a>
<a name="ln3650">      s++;</a>
<a name="ln3651">      while ((*s != '}' || (reevaluate &amp;&amp; s[-1] != '%')) &amp;&amp; *s) {</a>
<a name="ln3652">        s++;</a>
<a name="ln3653">      }</a>
<a name="ln3654">      if (*s != '}') {</a>
<a name="ln3655">        return (char_u *)N_(&quot;E540: Unclosed expression sequence&quot;);</a>
<a name="ln3656">      }</a>
<a name="ln3657">    }</a>
<a name="ln3658">  }</a>
<a name="ln3659">  if (groupdepth != 0) {</a>
<a name="ln3660">    return (char_u *)N_(&quot;E542: unbalanced groups&quot;);</a>
<a name="ln3661">  }</a>
<a name="ln3662">  return NULL;</a>
<a name="ln3663">}</a>
<a name="ln3664"> </a>
<a name="ln3665">static char_u *did_set_spell_option(bool is_spellfile)</a>
<a name="ln3666">{</a>
<a name="ln3667">  char_u  *errmsg = NULL;</a>
<a name="ln3668"> </a>
<a name="ln3669">  if (is_spellfile) {</a>
<a name="ln3670">    int l = (int)STRLEN(curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln3671">    if (l &gt; 0</a>
<a name="ln3672">        &amp;&amp; (l &lt; 4 || STRCMP(curwin-&gt;w_s-&gt;b_p_spf + l - 4, &quot;.add&quot;) != 0)) {</a>
<a name="ln3673">      errmsg = e_invarg;</a>
<a name="ln3674">    }</a>
<a name="ln3675">  }</a>
<a name="ln3676"> </a>
<a name="ln3677">  if (errmsg == NULL) {</a>
<a name="ln3678">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln3679">      if (wp-&gt;w_buffer == curbuf &amp;&amp; wp-&gt;w_p_spell) {</a>
<a name="ln3680">        errmsg = did_set_spelllang(wp);</a>
<a name="ln3681">        break;</a>
<a name="ln3682">      }</a>
<a name="ln3683">    }</a>
<a name="ln3684">  }</a>
<a name="ln3685"> </a>
<a name="ln3686">  return errmsg;</a>
<a name="ln3687">}</a>
<a name="ln3688"> </a>
<a name="ln3689">/// Set curbuf-&gt;b_cap_prog to the regexp program for 'spellcapcheck'.</a>
<a name="ln3690">/// Return error message when failed, NULL when OK.</a>
<a name="ln3691">static char_u *compile_cap_prog(synblock_T *synblock)</a>
<a name="ln3692">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3693">{</a>
<a name="ln3694">  regprog_T   *rp = synblock-&gt;b_cap_prog;</a>
<a name="ln3695">  char_u      *re;</a>
<a name="ln3696"> </a>
<a name="ln3697">  if (synblock-&gt;b_p_spc == NULL || *synblock-&gt;b_p_spc == NUL) {</a>
<a name="ln3698">    synblock-&gt;b_cap_prog = NULL;</a>
<a name="ln3699">  } else {</a>
<a name="ln3700">    // Prepend a ^ so that we only match at one column</a>
<a name="ln3701">    re = concat_str((char_u *)&quot;^&quot;, synblock-&gt;b_p_spc);</a>
<a name="ln3702">    synblock-&gt;b_cap_prog = vim_regcomp(re, RE_MAGIC);</a>
<a name="ln3703">    xfree(re);</a>
<a name="ln3704">    if (synblock-&gt;b_cap_prog == NULL) {</a>
<a name="ln3705">      synblock-&gt;b_cap_prog = rp;         // restore the previous program</a>
<a name="ln3706">      return e_invarg;</a>
<a name="ln3707">    }</a>
<a name="ln3708">  }</a>
<a name="ln3709"> </a>
<a name="ln3710">  vim_regfree(rp);</a>
<a name="ln3711">  return NULL;</a>
<a name="ln3712">}</a>
<a name="ln3713"> </a>
<a name="ln3714">/// Handle setting `winhighlight' in window &quot;wp&quot;</a>
<a name="ln3715">static bool parse_winhl_opt(win_T *wp)</a>
<a name="ln3716">{</a>
<a name="ln3717">  int w_hl_id_normal = 0;</a>
<a name="ln3718">  int w_hl_ids[HLF_COUNT] = { 0 };</a>
<a name="ln3719">  int hlf;</a>
<a name="ln3720"> </a>
<a name="ln3721">  const char *p = (const char *)wp-&gt;w_p_winhl;</a>
<a name="ln3722">  while (*p) {</a>
<a name="ln3723">    char *colon = strchr(p, ':');</a>
<a name="ln3724">    if (!colon) {</a>
<a name="ln3725">      return false;</a>
<a name="ln3726">    }</a>
<a name="ln3727">    size_t nlen = (size_t)(colon-p);</a>
<a name="ln3728">    char *hi = colon+1;</a>
<a name="ln3729">    char *commap = xstrchrnul(hi, ',');</a>
<a name="ln3730">    int len = (int)(commap-hi);</a>
<a name="ln3731">    int hl_id = len ? syn_check_group((char_u *)hi, len) : -1;</a>
<a name="ln3732"> </a>
<a name="ln3733">    if (strncmp(&quot;Normal&quot;, p, nlen) == 0) {</a>
<a name="ln3734">      w_hl_id_normal = hl_id;</a>
<a name="ln3735">    } else {</a>
<a name="ln3736">      for (hlf = 0; hlf &lt; (int)HLF_COUNT; hlf++) {</a>
<a name="ln3737">        if (strlen(hlf_names[hlf]) == nlen</a>
<a name="ln3738">            &amp;&amp; strncmp(hlf_names[hlf], p, nlen) == 0) {</a>
<a name="ln3739">          w_hl_ids[hlf] = hl_id;</a>
<a name="ln3740">          break;</a>
<a name="ln3741">        }</a>
<a name="ln3742">      }</a>
<a name="ln3743">      if (hlf == HLF_COUNT) {</a>
<a name="ln3744">        return false;</a>
<a name="ln3745">      }</a>
<a name="ln3746">    }</a>
<a name="ln3747"> </a>
<a name="ln3748">    p = *commap ? commap+1 : &quot;&quot;;</a>
<a name="ln3749">  }</a>
<a name="ln3750"> </a>
<a name="ln3751">  wp-&gt;w_hl_id_normal = w_hl_id_normal;</a>
<a name="ln3752">  memcpy(wp-&gt;w_hl_ids, w_hl_ids, sizeof(w_hl_ids));</a>
<a name="ln3753">  wp-&gt;w_hl_needs_update = true;</a>
<a name="ln3754">  return true;</a>
<a name="ln3755">}</a>
<a name="ln3756"> </a>
<a name="ln3757">// Set the script_ctx for an option, taking care of setting the buffer- or</a>
<a name="ln3758">// window-local value.</a>
<a name="ln3759">static void set_option_sctx_idx(int opt_idx, int opt_flags, sctx_T script_ctx)</a>
<a name="ln3760">{</a>
<a name="ln3761">  int both = (opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0;</a>
<a name="ln3762">  int indir = (int)options[opt_idx].indir;</a>
<a name="ln3763">  const LastSet last_set = {</a>
<a name="ln3764">    .script_ctx = {</a>
<a name="ln3765">      script_ctx.sc_sid,</a>
<a name="ln3766">      script_ctx.sc_seq,</a>
<a name="ln3767">      script_ctx.sc_lnum + sourcing_lnum</a>
<a name="ln3768">    },</a>
<a name="ln3769">    current_channel_id</a>
<a name="ln3770">  };</a>
<a name="ln3771"> </a>
<a name="ln3772">  // Remember where the option was set.  For local options need to do that</a>
<a name="ln3773">  // in the buffer or window structure.</a>
<a name="ln3774">  if (both || (opt_flags &amp; OPT_GLOBAL) || (indir &amp; (PV_BUF|PV_WIN)) == 0) {</a>
<a name="ln3775">    options[opt_idx].last_set = last_set;</a>
<a name="ln3776">  }</a>
<a name="ln3777">  if (both || (opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln3778">    if (indir &amp; PV_BUF) {</a>
<a name="ln3779">      curbuf-&gt;b_p_script_ctx[indir &amp; PV_MASK] = last_set;</a>
<a name="ln3780">    } else if (indir &amp; PV_WIN) {</a>
<a name="ln3781">      curwin-&gt;w_p_script_ctx[indir &amp; PV_MASK] = last_set;</a>
<a name="ln3782">    }</a>
<a name="ln3783">  }</a>
<a name="ln3784">}</a>
<a name="ln3785"> </a>
<a name="ln3786">/// Set the value of a boolean option, taking care of side effects</a>
<a name="ln3787">///</a>
<a name="ln3788">/// @param[in]  opt_idx  Option index in options[] table.</a>
<a name="ln3789">/// @param[out]  varp  Pointer to the option variable.</a>
<a name="ln3790">/// @param[in]  value  New value.</a>
<a name="ln3791">/// @param[in]  opt_flags  OPT_LOCAL and/or OPT_GLOBAL.</a>
<a name="ln3792">///</a>
<a name="ln3793">/// @return NULL on success, error message on error.</a>
<a name="ln3794">static char *set_bool_option(const int opt_idx, char_u *const varp,</a>
<a name="ln3795">                             const int value,</a>
<a name="ln3796">                             const int opt_flags)</a>
<a name="ln3797">{</a>
<a name="ln3798">  int old_value = *(int *)varp;</a>
<a name="ln3799"> </a>
<a name="ln3800">  // Disallow changing some options from secure mode</a>
<a name="ln3801">  if ((secure || sandbox != 0)</a>
<a name="ln3802">      &amp;&amp; (options[opt_idx].flags &amp; P_SECURE)) {</a>
<a name="ln3803">    return (char *)e_secure;</a>
<a name="ln3804">  }</a>
<a name="ln3805"> </a>
<a name="ln3806">  *(int *)varp = value;             // set the new value</a>
<a name="ln3807">  // Remember where the option was set.</a>
<a name="ln3808">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln3809"> </a>
<a name="ln3810"> </a>
<a name="ln3811">  // May set global value for local option.</a>
<a name="ln3812">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln3813">    *(int *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) = value;</a>
<a name="ln3814">  }</a>
<a name="ln3815"> </a>
<a name="ln3816">  // Ensure that options set to p_force_on cannot be disabled.</a>
<a name="ln3817">  if ((int *)varp == &amp;p_force_on &amp;&amp; p_force_on == false) {</a>
<a name="ln3818">    p_force_on = true;</a>
<a name="ln3819">    return (char *)e_unsupportedoption;</a>
<a name="ln3820">  // Ensure that options set to p_force_off cannot be enabled.</a>
<a name="ln3821">  } else if ((int *)varp == &amp;p_force_off &amp;&amp; p_force_off == true) {</a>
<a name="ln3822">    p_force_off = false;</a>
<a name="ln3823">    return (char *)e_unsupportedoption;</a>
<a name="ln3824">  } else if ((int *)varp == &amp;p_lrm) {</a>
<a name="ln3825">    // 'langremap' -&gt; !'langnoremap'</a>
<a name="ln3826">    p_lnr = !p_lrm;</a>
<a name="ln3827">  } else if ((int *)varp == &amp;p_lnr) {</a>
<a name="ln3828">    // 'langnoremap' -&gt; !'langremap'</a>
<a name="ln3829">    p_lrm = !p_lnr;</a>
<a name="ln3830">  } else if ((int *)varp == &amp;curwin-&gt;w_p_cul &amp;&amp; !value &amp;&amp; old_value) {</a>
<a name="ln3831">    // 'cursorline'</a>
<a name="ln3832">    reset_cursorline();</a>
<a name="ln3833">  // 'undofile'</a>
<a name="ln3834">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_udf || (int *)varp == &amp;p_udf) {</a>
<a name="ln3835">    // Only take action when the option was set. When reset we do not</a>
<a name="ln3836">    // delete the undo file, the option may be set again without making</a>
<a name="ln3837">    // any changes in between.</a>
<a name="ln3838">    if (curbuf-&gt;b_p_udf || p_udf) {</a>
<a name="ln3839">      char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln3840">      buf_T       *save_curbuf = curbuf;</a>
<a name="ln3841"> </a>
<a name="ln3842">      FOR_ALL_BUFFERS(bp) {</a>
<a name="ln3843">        curbuf = bp;</a>
<a name="ln3844">        // When 'undofile' is set globally: for every buffer, otherwise</a>
<a name="ln3845">        // only for the current buffer: Try to read in the undofile,</a>
<a name="ln3846">        // if one exists, the buffer wasn't changed and the buffer was</a>
<a name="ln3847">        // loaded</a>
<a name="ln3848">        if ((curbuf == save_curbuf</a>
<a name="ln3849">             || (opt_flags &amp; OPT_GLOBAL) || opt_flags == 0)</a>
<a name="ln3850">            &amp;&amp; !curbufIsChanged() &amp;&amp; curbuf-&gt;b_ml.ml_mfp != NULL) {</a>
<a name="ln3851">          u_compute_hash(hash);</a>
<a name="ln3852">          u_read_undo(NULL, hash, curbuf-&gt;b_fname);</a>
<a name="ln3853">        }</a>
<a name="ln3854">      }</a>
<a name="ln3855">      curbuf = save_curbuf;</a>
<a name="ln3856">    }</a>
<a name="ln3857">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_ro) {</a>
<a name="ln3858">    // when 'readonly' is reset globally, also reset readonlymode</a>
<a name="ln3859">    if (!curbuf-&gt;b_p_ro &amp;&amp; (opt_flags &amp; OPT_LOCAL) == 0) {</a>
<a name="ln3860">      readonlymode = false;</a>
<a name="ln3861">    }</a>
<a name="ln3862"> </a>
<a name="ln3863">    // when 'readonly' is set may give W10 again</a>
<a name="ln3864">    if (curbuf-&gt;b_p_ro) {</a>
<a name="ln3865">      curbuf-&gt;b_did_warn = false;</a>
<a name="ln3866">    }</a>
<a name="ln3867"> </a>
<a name="ln3868">    redraw_titles();</a>
<a name="ln3869">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_ma) {</a>
<a name="ln3870">    // when 'modifiable' is changed, redraw the window title</a>
<a name="ln3871">    redraw_titles();</a>
<a name="ln3872">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_eol) {</a>
<a name="ln3873">    // when 'endofline' is changed, redraw the window title</a>
<a name="ln3874">    redraw_titles();</a>
<a name="ln3875">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_fixeol) {</a>
<a name="ln3876">    // when 'fixeol' is changed, redraw the window title</a>
<a name="ln3877">    redraw_titles();</a>
<a name="ln3878">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_bomb) {</a>
<a name="ln3879">    // when 'bomb' is changed, redraw the window title and tab page text</a>
<a name="ln3880">    redraw_titles();</a>
<a name="ln3881">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_bin) {</a>
<a name="ln3882">    // when 'bin' is set also set some other options</a>
<a name="ln3883">    set_options_bin(old_value, curbuf-&gt;b_p_bin, opt_flags);</a>
<a name="ln3884">    redraw_titles();</a>
<a name="ln3885">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_bl &amp;&amp; old_value != curbuf-&gt;b_p_bl) {</a>
<a name="ln3886">    // when 'buflisted' changes, trigger autocommands</a>
<a name="ln3887">    apply_autocmds(curbuf-&gt;b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,</a>
<a name="ln3888">                   NULL, NULL, true, curbuf);</a>
<a name="ln3889">  } else if ((int *)varp == (int *)&amp;curbuf-&gt;b_p_swf) {</a>
<a name="ln3890">    // when 'swf' is set, create swapfile, when reset remove swapfile</a>
<a name="ln3891">    if (curbuf-&gt;b_p_swf &amp;&amp; p_uc) {</a>
<a name="ln3892">      ml_open_file(curbuf);                     // create the swap file</a>
<a name="ln3893">    } else {</a>
<a name="ln3894">      // no need to reset curbuf-&gt;b_may_swap, ml_open_file() will check</a>
<a name="ln3895">      // buf-&gt;b_p_swf</a>
<a name="ln3896">      mf_close_file(curbuf, true);              // remove the swap file</a>
<a name="ln3897">    }</a>
<a name="ln3898">  } else if ((int *)varp == &amp;p_terse) {</a>
<a name="ln3899">    // when 'terse' is set change 'shortmess'</a>
<a name="ln3900">    char_u  *p;</a>
<a name="ln3901"> </a>
<a name="ln3902">    p = vim_strchr(p_shm, SHM_SEARCH);</a>
<a name="ln3903"> </a>
<a name="ln3904">    // insert 's' in p_shm</a>
<a name="ln3905">    if (p_terse &amp;&amp; p == NULL) {</a>
<a name="ln3906">      STRCPY(IObuff, p_shm);</a>
<a name="ln3907">      STRCAT(IObuff, &quot;s&quot;);</a>
<a name="ln3908">      set_string_option_direct(&quot;shm&quot;, -1, IObuff, OPT_FREE, 0);</a>
<a name="ln3909">    } else if (!p_terse &amp;&amp; p != NULL) {  // remove 's' from p_shm</a>
<a name="ln3910">      STRMOVE(p, p + 1);</a>
<a name="ln3911">    }</a>
<a name="ln3912">  } else if ((int *)varp == &amp;p_paste) {</a>
<a name="ln3913">    // when 'paste' is set or reset also change other options</a>
<a name="ln3914">    paste_option_changed();</a>
<a name="ln3915">  } else if ((int *)varp == &amp;p_im) {</a>
<a name="ln3916">    // when 'insertmode' is set from an autocommand need to do work here</a>
<a name="ln3917">    if (p_im) {</a>
<a name="ln3918">      if ((State &amp; INSERT) == 0) {</a>
<a name="ln3919">        need_start_insertmode = true;</a>
<a name="ln3920">      }</a>
<a name="ln3921">      stop_insert_mode = false;</a>
<a name="ln3922">    } else if (old_value) {  // only reset if it was set previously</a>
<a name="ln3923">      need_start_insertmode = false;</a>
<a name="ln3924">      stop_insert_mode = true;</a>
<a name="ln3925">      if (restart_edit != 0 &amp;&amp; mode_displayed) {</a>
<a name="ln3926">        clear_cmdline = true;  // remove &quot;(insert)&quot;</a>
<a name="ln3927">      }</a>
<a name="ln3928">      restart_edit = 0;</a>
<a name="ln3929">    }</a>
<a name="ln3930">  } else if ((int *)varp == &amp;p_ic &amp;&amp; p_hls) {</a>
<a name="ln3931">    // when 'ignorecase' is set or reset and 'hlsearch' is set, redraw</a>
<a name="ln3932">    redraw_all_later(SOME_VALID);</a>
<a name="ln3933">  } else if ((int *)varp == &amp;p_hls) {</a>
<a name="ln3934">    // when 'hlsearch' is set or reset: reset no_hlsearch</a>
<a name="ln3935">    set_no_hlsearch(false);</a>
<a name="ln3936">  } else if ((int *)varp == &amp;curwin-&gt;w_p_scb) {</a>
<a name="ln3937">  // when 'scrollbind' is set: snapshot the current position to avoid a jump</a>
<a name="ln3938">  // at the end of normal_cmd()</a>
<a name="ln3939">    if (curwin-&gt;w_p_scb) {</a>
<a name="ln3940">      do_check_scrollbind(false);</a>
<a name="ln3941">      curwin-&gt;w_scbind_pos = curwin-&gt;w_topline;</a>
<a name="ln3942">    }</a>
<a name="ln3943">  } else if ((int *)varp == &amp;curwin-&gt;w_p_pvw) {</a>
<a name="ln3944">    // There can be only one window with 'previewwindow' set.</a>
<a name="ln3945">    if (curwin-&gt;w_p_pvw) {</a>
<a name="ln3946">      FOR_ALL_WINDOWS_IN_TAB(win, curtab) {</a>
<a name="ln3947">        if (win-&gt;w_p_pvw &amp;&amp; win != curwin) {</a>
<a name="ln3948">          curwin-&gt;w_p_pvw = false;</a>
<a name="ln3949">          return N_(&quot;E590: A preview window already exists&quot;);</a>
<a name="ln3950">        }</a>
<a name="ln3951">      }</a>
<a name="ln3952">    }</a>
<a name="ln3953">  } else if (varp == (char_u *)&amp;(curbuf-&gt;b_p_lisp)) {</a>
<a name="ln3954">    // When 'lisp' option changes include/exclude '-' in</a>
<a name="ln3955">    // keyword characters.</a>
<a name="ln3956">    (void)buf_init_chartab(curbuf, false);          // ignore errors</a>
<a name="ln3957">  } else if ((int *)varp == &amp;p_title) {</a>
<a name="ln3958">    // when 'title' changed, may need to change the title; same for 'icon'</a>
<a name="ln3959">    did_set_title();</a>
<a name="ln3960">  } else if ((int *)varp == &amp;p_icon) {</a>
<a name="ln3961">    did_set_title();</a>
<a name="ln3962">  } else if ((int *)varp == &amp;curbuf-&gt;b_changed) {</a>
<a name="ln3963">    if (!value) {</a>
<a name="ln3964">      save_file_ff(curbuf);             // Buffer is unchanged</a>
<a name="ln3965">    }</a>
<a name="ln3966">    redraw_titles();</a>
<a name="ln3967">    modified_was_set = value;</a>
<a name="ln3968">  }</a>
<a name="ln3969"> </a>
<a name="ln3970">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3971">  else if ((int *)varp == &amp;p_ssl) {</a>
<a name="ln3972">    if (p_ssl) {</a>
<a name="ln3973">      psepc = '/';</a>
<a name="ln3974">      psepcN = '\\';</a>
<a name="ln3975">      pseps[0] = '/';</a>
<a name="ln3976">    } else {</a>
<a name="ln3977">      psepc = '\\';</a>
<a name="ln3978">      psepcN = '/';</a>
<a name="ln3979">      pseps[0] = '\\';</a>
<a name="ln3980">    }</a>
<a name="ln3981"> </a>
<a name="ln3982">    // need to adjust the file name arguments and buffer names.</a>
<a name="ln3983">    buflist_slash_adjust();</a>
<a name="ln3984">    alist_slash_adjust();</a>
<a name="ln3985">    scriptnames_slash_adjust();</a>
<a name="ln3986">  }</a>
<a name="ln3987">#endif</a>
<a name="ln3988">  else if ((int *)varp == &amp;curwin-&gt;w_p_wrap) {</a>
<a name="ln3989">    // If 'wrap' is set, set w_leftcol to zero.</a>
<a name="ln3990">    if (curwin-&gt;w_p_wrap) {</a>
<a name="ln3991">      curwin-&gt;w_leftcol = 0;</a>
<a name="ln3992">    }</a>
<a name="ln3993">  } else if ((int *)varp == &amp;p_ea) {</a>
<a name="ln3994">    if (p_ea &amp;&amp; !old_value) {</a>
<a name="ln3995">      win_equal(curwin, false, 0);</a>
<a name="ln3996">    }</a>
<a name="ln3997">  } else if ((int *)varp == &amp;p_acd) {</a>
<a name="ln3998">    // Change directories when the 'acd' option is set now.</a>
<a name="ln3999">    do_autochdir();</a>
<a name="ln4000">  } else if ((int *)varp == &amp;curwin-&gt;w_p_diff) {  // 'diff'</a>
<a name="ln4001">    // May add or remove the buffer from the list of diff buffers.</a>
<a name="ln4002">    diff_buf_adjust(curwin);</a>
<a name="ln4003">    if (foldmethodIsDiff(curwin)) {</a>
<a name="ln4004">      foldUpdateAll(curwin);</a>
<a name="ln4005">    }</a>
<a name="ln4006">  } else if ((int *)varp == &amp;curwin-&gt;w_p_spell) {  // 'spell'</a>
<a name="ln4007">    if (curwin-&gt;w_p_spell) {</a>
<a name="ln4008">      char_u      *errmsg = did_set_spelllang(curwin);</a>
<a name="ln4009">      if (errmsg != NULL) {</a>
<a name="ln4010">        EMSG(_(errmsg));</a>
<a name="ln4011">      }</a>
<a name="ln4012">    }</a>
<a name="ln4013">  }</a>
<a name="ln4014"> </a>
<a name="ln4015">  if ((int *)varp == &amp;curwin-&gt;w_p_arab) {</a>
<a name="ln4016">    if (curwin-&gt;w_p_arab) {</a>
<a name="ln4017">      /*</a>
<a name="ln4018">       * 'arabic' is set, handle various sub-settings.</a>
<a name="ln4019">       */</a>
<a name="ln4020">      if (!p_tbidi) {</a>
<a name="ln4021">        // set rightleft mode</a>
<a name="ln4022">        if (!curwin-&gt;w_p_rl) {</a>
<a name="ln4023">          curwin-&gt;w_p_rl = true;</a>
<a name="ln4024">          changed_window_setting();</a>
<a name="ln4025">        }</a>
<a name="ln4026"> </a>
<a name="ln4027">        // Enable Arabic shaping (major part of what Arabic requires)</a>
<a name="ln4028">        if (!p_arshape) {</a>
<a name="ln4029">          p_arshape = true;</a>
<a name="ln4030">          redraw_all_later(NOT_VALID);</a>
<a name="ln4031">        }</a>
<a name="ln4032">      }</a>
<a name="ln4033"> </a>
<a name="ln4034">      /* Arabic requires a utf-8 encoding, inform the user if its not</a>
<a name="ln4035">       * set. */</a>
<a name="ln4036">      if (STRCMP(p_enc, &quot;utf-8&quot;) != 0) {</a>
<a name="ln4037">        static char *w_arabic = N_(</a>
<a name="ln4038">            &quot;W17: Arabic requires UTF-8, do ':set encoding=utf-8'&quot;);</a>
<a name="ln4039"> </a>
<a name="ln4040">        msg_source(HL_ATTR(HLF_W));</a>
<a name="ln4041">        msg_attr(_(w_arabic), HL_ATTR(HLF_W));</a>
<a name="ln4042">        set_vim_var_string(VV_WARNINGMSG, _(w_arabic), -1);</a>
<a name="ln4043">      }</a>
<a name="ln4044"> </a>
<a name="ln4045">      // set 'delcombine'</a>
<a name="ln4046">      p_deco = true;</a>
<a name="ln4047"> </a>
<a name="ln4048">      // Force-set the necessary keymap for arabic.</a>
<a name="ln4049">      set_option_value(&quot;keymap&quot;, 0L, &quot;arabic&quot;, OPT_LOCAL);</a>
<a name="ln4050">    } else {</a>
<a name="ln4051">      /*</a>
<a name="ln4052">       * 'arabic' is reset, handle various sub-settings.</a>
<a name="ln4053">       */</a>
<a name="ln4054">      if (!p_tbidi) {</a>
<a name="ln4055">        // reset rightleft mode</a>
<a name="ln4056">        if (curwin-&gt;w_p_rl) {</a>
<a name="ln4057">          curwin-&gt;w_p_rl = false;</a>
<a name="ln4058">          changed_window_setting();</a>
<a name="ln4059">        }</a>
<a name="ln4060"> </a>
<a name="ln4061">        /* 'arabicshape' isn't reset, it is a global option and</a>
<a name="ln4062">         * another window may still need it &quot;on&quot;. */</a>
<a name="ln4063">      }</a>
<a name="ln4064"> </a>
<a name="ln4065">      /* 'delcombine' isn't reset, it is a global option and another</a>
<a name="ln4066">       * window may still want it &quot;on&quot;. */</a>
<a name="ln4067"> </a>
<a name="ln4068">      // Revert to the default keymap</a>
<a name="ln4069">      curbuf-&gt;b_p_iminsert = B_IMODE_NONE;</a>
<a name="ln4070">      curbuf-&gt;b_p_imsearch = B_IMODE_USE_INSERT;</a>
<a name="ln4071">    }</a>
<a name="ln4072">  }</a>
<a name="ln4073"> </a>
<a name="ln4074"> </a>
<a name="ln4075">  /*</a>
<a name="ln4076">   * End of handling side effects for bool options.</a>
<a name="ln4077">   */</a>
<a name="ln4078"> </a>
<a name="ln4079">  // after handling side effects, call autocommand</a>
<a name="ln4080"> </a>
<a name="ln4081">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln4082"> </a>
<a name="ln4083">  // Don't do this while starting up or recursively.</a>
<a name="ln4084">  if (!starting &amp;&amp; *get_vim_var_str(VV_OPTION_TYPE) == NUL) {</a>
<a name="ln4085">    char buf_old[2];</a>
<a name="ln4086">    char buf_new[2];</a>
<a name="ln4087">    char buf_type[7];</a>
<a name="ln4088">    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), &quot;%d&quot;,</a>
<a name="ln4089">                 old_value ? true: false);</a>
<a name="ln4090">    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), &quot;%d&quot;,</a>
<a name="ln4091">                 value ? true: false);</a>
<a name="ln4092">    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), &quot;%s&quot;,</a>
<a name="ln4093">                 (opt_flags &amp; OPT_LOCAL) ? &quot;local&quot; : &quot;global&quot;);</a>
<a name="ln4094">    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);</a>
<a name="ln4095">    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);</a>
<a name="ln4096">    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);</a>
<a name="ln4097">    apply_autocmds(EVENT_OPTIONSET,</a>
<a name="ln4098">                   (char_u *) options[opt_idx].fullname,</a>
<a name="ln4099">                   NULL, false, NULL);</a>
<a name="ln4100">    reset_v_option_vars();</a>
<a name="ln4101">  }</a>
<a name="ln4102"> </a>
<a name="ln4103">  if (options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln4104">    ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln4105">                       BOOLEAN_OBJ(value));</a>
<a name="ln4106">  }</a>
<a name="ln4107"> </a>
<a name="ln4108">  comp_col();                       // in case 'ruler' or 'showcmd' changed</a>
<a name="ln4109">  if (curwin-&gt;w_curswant != MAXCOL</a>
<a name="ln4110">      &amp;&amp; (options[opt_idx].flags &amp; (P_CURSWANT | P_RALL)) != 0) {</a>
<a name="ln4111">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln4112">  }</a>
<a name="ln4113">  check_redraw(options[opt_idx].flags);</a>
<a name="ln4114"> </a>
<a name="ln4115">  return NULL;</a>
<a name="ln4116">}</a>
<a name="ln4117"> </a>
<a name="ln4118">/// Set the value of a number option, taking care of side effects</a>
<a name="ln4119">///</a>
<a name="ln4120">/// @param[in]  opt_idx  Option index in options[] table.</a>
<a name="ln4121">/// @param[out]  varp  Pointer to the option variable.</a>
<a name="ln4122">/// @param[in]  value  New value.</a>
<a name="ln4123">/// @param  errbuf  Buffer for error messages.</a>
<a name="ln4124">/// @param[in]  errbuflen  Length of `errbuf`.</a>
<a name="ln4125">/// @param[in]  opt_flags  OPT_LOCAL, OPT_GLOBAL or OPT_MODELINE.</a>
<a name="ln4126">///</a>
<a name="ln4127">/// @return NULL on success, error message on error.</a>
<a name="ln4128">static char *set_num_option(int opt_idx, char_u *varp, long value,</a>
<a name="ln4129">                            char_u *errbuf, size_t errbuflen, int opt_flags)</a>
<a name="ln4130">{</a>
<a name="ln4131">  char_u      *errmsg = NULL;</a>
<a name="ln4132">  long old_value = *(long *)varp;</a>
<a name="ln4133">  long old_Rows = Rows;                 // remember old Rows</a>
<a name="ln4134">  long        *pp = (long *)varp;</a>
<a name="ln4135"> </a>
<a name="ln4136">  // Disallow changing some options from secure mode.</a>
<a name="ln4137">  if ((secure || sandbox != 0)</a>
<a name="ln4138">      &amp;&amp; (options[opt_idx].flags &amp; P_SECURE)) {</a>
<a name="ln4139">    return (char *)e_secure;</a>
<a name="ln4140">  }</a>
<a name="ln4141"> </a>
<a name="ln4142">  // Many number options assume their value is in the signed int range.</a>
<a name="ln4143">  if (value &lt; INT_MIN || value &gt; INT_MAX) {</a>
<a name="ln4144">      return (char *)e_invarg;</a>
<a name="ln4145">  }</a>
<a name="ln4146"> </a>
<a name="ln4147">  // Options that need some validation.</a>
<a name="ln4148">  if (pp == &amp;p_wh) {</a>
<a name="ln4149">    if (value &lt; 1) {</a>
<a name="ln4150">      errmsg = e_positive;</a>
<a name="ln4151">    } else if (p_wmh &gt; value) {</a>
<a name="ln4152">      errmsg = e_winheight;</a>
<a name="ln4153">    }</a>
<a name="ln4154">  } else if (pp == &amp;p_hh) {</a>
<a name="ln4155">    if (value &lt; 0) {</a>
<a name="ln4156">      errmsg = e_positive;</a>
<a name="ln4157">    }</a>
<a name="ln4158">  } else if (pp == &amp;p_wmh) {</a>
<a name="ln4159">    if (value &lt; 0) {</a>
<a name="ln4160">      errmsg = e_positive;</a>
<a name="ln4161">    } else if (value &gt; p_wh) {</a>
<a name="ln4162">      errmsg = e_winheight;</a>
<a name="ln4163">    }</a>
<a name="ln4164">  } else if (pp == &amp;p_wiw) {</a>
<a name="ln4165">    if (value &lt; 1) {</a>
<a name="ln4166">      errmsg = e_positive;</a>
<a name="ln4167">    } else if (p_wmw &gt; value) {</a>
<a name="ln4168">      errmsg = e_winwidth;</a>
<a name="ln4169">    }</a>
<a name="ln4170">  } else if (pp == &amp;p_wmw) {</a>
<a name="ln4171">    if (value &lt; 0) {</a>
<a name="ln4172">      errmsg = e_positive;</a>
<a name="ln4173">    } else if (value &gt; p_wiw) {</a>
<a name="ln4174">      errmsg = e_winwidth;</a>
<a name="ln4175">    }</a>
<a name="ln4176">  } else if (pp == &amp;p_mco) {</a>
<a name="ln4177">    value = MAX_MCO;</a>
<a name="ln4178">  } else if (pp == &amp;p_titlelen) {</a>
<a name="ln4179">    if (value &lt; 0) {</a>
<a name="ln4180">      errmsg = e_positive;</a>
<a name="ln4181">    }</a>
<a name="ln4182">  } else if (pp == &amp;p_uc) {</a>
<a name="ln4183">    if (value &lt; 0) {</a>
<a name="ln4184">      errmsg = e_positive;</a>
<a name="ln4185">    }</a>
<a name="ln4186">  } else if (pp == &amp;p_ch) {</a>
<a name="ln4187">    int minval = ui_has(kUIMessages) ? 0 : 1;</a>
<a name="ln4188">    if (value &lt; minval) {</a>
<a name="ln4189">      errmsg = e_positive;</a>
<a name="ln4190">    }</a>
<a name="ln4191">  } else if (pp == &amp;p_tm) {</a>
<a name="ln4192">    if (value &lt; 0) {</a>
<a name="ln4193">      errmsg = e_positive;</a>
<a name="ln4194">    }</a>
<a name="ln4195">  } else if (pp == &amp;p_hi) {</a>
<a name="ln4196">    if (value &lt; 0) {</a>
<a name="ln4197">      errmsg = e_positive;</a>
<a name="ln4198">    } else if (value &gt; 10000) {</a>
<a name="ln4199">      errmsg = e_invarg;</a>
<a name="ln4200">    }</a>
<a name="ln4201">  } else if (pp == &amp;p_re) {</a>
<a name="ln4202">    if (value &lt; 0 || value &gt; 2) {</a>
<a name="ln4203">      errmsg = e_invarg;</a>
<a name="ln4204">    }</a>
<a name="ln4205">  } else if (pp == &amp;p_report) {</a>
<a name="ln4206">    if (value &lt; 0) {</a>
<a name="ln4207">      errmsg = e_positive;</a>
<a name="ln4208">    }</a>
<a name="ln4209">  } else if (pp == &amp;p_so) {</a>
<a name="ln4210">    if (value &lt; 0 &amp;&amp; full_screen) {</a>
<a name="ln4211">      errmsg = e_positive;</a>
<a name="ln4212">    }</a>
<a name="ln4213">  } else if (pp == &amp;p_siso) {</a>
<a name="ln4214">    if (value &lt; 0 &amp;&amp; full_screen) {</a>
<a name="ln4215">      errmsg = e_positive;</a>
<a name="ln4216">    }</a>
<a name="ln4217">  } else if (pp == &amp;p_cwh) {</a>
<a name="ln4218">    if (value &lt; 1) {</a>
<a name="ln4219">      errmsg = e_positive;</a>
<a name="ln4220">    }</a>
<a name="ln4221">  } else if (pp == &amp;p_ut) {</a>
<a name="ln4222">    if (value &lt; 0) {</a>
<a name="ln4223">      errmsg = e_positive;</a>
<a name="ln4224">    }</a>
<a name="ln4225">  } else if (pp == &amp;p_ss) {</a>
<a name="ln4226">    if (value &lt; 0) {</a>
<a name="ln4227">      errmsg = e_positive;</a>
<a name="ln4228">    }</a>
<a name="ln4229">  } else if (pp == &amp;curwin-&gt;w_p_fdl || pp == &amp;curwin-&gt;w_allbuf_opt.wo_fdl) {</a>
<a name="ln4230">    if (value &lt; 0) {</a>
<a name="ln4231">      errmsg = e_positive;</a>
<a name="ln4232">    }</a>
<a name="ln4233">  } else if (pp == &amp;curwin-&gt;w_p_cole || pp == &amp;curwin-&gt;w_allbuf_opt.wo_cole) {</a>
<a name="ln4234">    if (value &lt; 0) {</a>
<a name="ln4235">      errmsg = e_positive;</a>
<a name="ln4236">    } else if (value &gt; 3) {</a>
<a name="ln4237">      errmsg = e_invarg;</a>
<a name="ln4238">    }</a>
<a name="ln4239">  } else if (pp == &amp;curwin-&gt;w_p_nuw || pp == &amp;curwin-&gt;w_allbuf_opt.wo_nuw) {</a>
<a name="ln4240">    if (value &lt; 1) {</a>
<a name="ln4241">      errmsg = e_positive;</a>
<a name="ln4242">    } else if (value &gt; 20) {</a>
<a name="ln4243">      errmsg = e_invarg;</a>
<a name="ln4244">    }</a>
<a name="ln4245">  } else if (pp == &amp;curbuf-&gt;b_p_iminsert || pp == &amp;p_iminsert) {</a>
<a name="ln4246">    if (value &lt; 0 || value &gt; B_IMODE_LAST) {</a>
<a name="ln4247">      errmsg = e_invarg;</a>
<a name="ln4248">    }</a>
<a name="ln4249">  } else if (pp == &amp;curbuf-&gt;b_p_imsearch || pp == &amp;p_imsearch) {</a>
<a name="ln4250">    if (value &lt; -1 || value &gt; B_IMODE_LAST) {</a>
<a name="ln4251">      errmsg = e_invarg;</a>
<a name="ln4252">    }</a>
<a name="ln4253">  } else if (pp == &amp;curbuf-&gt;b_p_channel || pp == &amp;p_channel) {</a>
<a name="ln4254">    errmsg = e_invarg;</a>
<a name="ln4255">  } else if (pp == &amp;curbuf-&gt;b_p_scbk || pp == &amp;p_scbk) {</a>
<a name="ln4256">    if (value &lt; -1 || value &gt; SB_MAX) {</a>
<a name="ln4257">      errmsg = e_invarg;</a>
<a name="ln4258">    }</a>
<a name="ln4259">  } else if (pp == &amp;curbuf-&gt;b_p_sw || pp == &amp;p_sw) {</a>
<a name="ln4260">    if (value &lt; 0) {</a>
<a name="ln4261">      errmsg = e_positive;</a>
<a name="ln4262">    }</a>
<a name="ln4263">  } else if (pp == &amp;curbuf-&gt;b_p_ts || pp == &amp;p_ts) {</a>
<a name="ln4264">    if (value &lt; 1) {</a>
<a name="ln4265">      errmsg = e_positive;</a>
<a name="ln4266">    }</a>
<a name="ln4267">  } else if (pp == &amp;curbuf-&gt;b_p_tw || pp == &amp;p_tw) {</a>
<a name="ln4268">    if (value &lt; 0) {</a>
<a name="ln4269">      errmsg = e_positive;</a>
<a name="ln4270">    }</a>
<a name="ln4271">  } else if (pp == &amp;p_wd) {</a>
<a name="ln4272">    if (value &lt; 0) {</a>
<a name="ln4273">      errmsg = e_positive;</a>
<a name="ln4274">    }</a>
<a name="ln4275">  }</a>
<a name="ln4276"> </a>
<a name="ln4277">  // Don't change the value and return early if validation failed.</a>
<a name="ln4278">  if (errmsg != NULL) {</a>
<a name="ln4279">    return (char *)errmsg;</a>
<a name="ln4280">  }</a>
<a name="ln4281"> </a>
<a name="ln4282">  *pp = value;</a>
<a name="ln4283">  // Remember where the option was set.</a>
<a name="ln4284">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln4285"> </a>
<a name="ln4286">  // For these options we want to fix some invalid values.</a>
<a name="ln4287">  if (pp == &amp;p_window) {</a>
<a name="ln4288">    if (p_window &lt; 1) {</a>
<a name="ln4289">      p_window = Rows - 1;</a>
<a name="ln4290">    } else if (p_window &gt;= Rows) {</a>
<a name="ln4291">      p_window = Rows - 1;</a>
<a name="ln4292">    }</a>
<a name="ln4293">  } else if (pp == &amp;p_ch) {</a>
<a name="ln4294">    if (ui_has(kUIMessages)) {</a>
<a name="ln4295">      p_ch = 0;</a>
<a name="ln4296">    }</a>
<a name="ln4297">    if (p_ch &gt; Rows - min_rows() + 1) {</a>
<a name="ln4298">      p_ch = Rows - min_rows() + 1;</a>
<a name="ln4299">    }</a>
<a name="ln4300">  }</a>
<a name="ln4301"> </a>
<a name="ln4302">  // Number options that need some action when changed</a>
<a name="ln4303">  if (pp == &amp;p_wh) {</a>
<a name="ln4304">    // 'winheight'</a>
<a name="ln4305">    if (!ONE_WINDOW &amp;&amp; curwin-&gt;w_height &lt; p_wh) {</a>
<a name="ln4306">      win_setheight((int)p_wh);</a>
<a name="ln4307">    }</a>
<a name="ln4308">  } else if (pp == &amp;p_hh) {</a>
<a name="ln4309">    // 'helpheight'</a>
<a name="ln4310">    if (!ONE_WINDOW &amp;&amp; curbuf-&gt;b_help &amp;&amp; curwin-&gt;w_height &lt; p_hh) {</a>
<a name="ln4311">      win_setheight((int)p_hh);</a>
<a name="ln4312">    }</a>
<a name="ln4313">  } else if (pp == &amp;p_wmh) {</a>
<a name="ln4314">    // 'winminheight'</a>
<a name="ln4315">    win_setminheight();</a>
<a name="ln4316">  } else if (pp == &amp;p_wiw) {</a>
<a name="ln4317">    // 'winwidth'</a>
<a name="ln4318">    if (!ONE_WINDOW &amp;&amp; curwin-&gt;w_width &lt; p_wiw) {</a>
<a name="ln4319">      win_setwidth((int)p_wiw);</a>
<a name="ln4320">    }</a>
<a name="ln4321">  } else if (pp == &amp;p_wmw) {</a>
<a name="ln4322">    // 'winminwidth'</a>
<a name="ln4323">    win_setminwidth();</a>
<a name="ln4324">  } else if (pp == &amp;p_ls) {</a>
<a name="ln4325">    last_status(false);  // (re)set last window status line.</a>
<a name="ln4326">  } else if (pp == &amp;p_stal) {</a>
<a name="ln4327">    // (re)set tab page line</a>
<a name="ln4328">    shell_new_rows();   // recompute window positions and heights</a>
<a name="ln4329">  } else if (pp == &amp;curwin-&gt;w_p_fdl) {</a>
<a name="ln4330">    newFoldLevel();</a>
<a name="ln4331">  } else if (pp == &amp;curwin-&gt;w_p_fml) {</a>
<a name="ln4332">    foldUpdateAll(curwin);</a>
<a name="ln4333">  } else if (pp == &amp;curwin-&gt;w_p_fdn) {</a>
<a name="ln4334">    if (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin)) {</a>
<a name="ln4335">      foldUpdateAll(curwin);</a>
<a name="ln4336">    }</a>
<a name="ln4337">  } else if (pp == &amp;curbuf-&gt;b_p_sw || pp == &amp;curbuf-&gt;b_p_ts) {</a>
<a name="ln4338">    // 'shiftwidth' or 'tabstop'</a>
<a name="ln4339">    if (foldmethodIsIndent(curwin)) {</a>
<a name="ln4340">      foldUpdateAll(curwin);</a>
<a name="ln4341">    }</a>
<a name="ln4342">    // When 'shiftwidth' changes, or it's zero and 'tabstop' changes:</a>
<a name="ln4343">    // parse 'cinoptions'.</a>
<a name="ln4344">    if (pp == &amp;curbuf-&gt;b_p_sw || curbuf-&gt;b_p_sw == 0) {</a>
<a name="ln4345">      parse_cino(curbuf);</a>
<a name="ln4346">    }</a>
<a name="ln4347">  } else if (pp == &amp;curbuf-&gt;b_p_iminsert) {</a>
<a name="ln4348">    showmode();</a>
<a name="ln4349">    // Show/unshow value of 'keymap' in status lines.</a>
<a name="ln4350">    status_redraw_curbuf();</a>
<a name="ln4351">  } else if (pp == &amp;p_titlelen) {</a>
<a name="ln4352">    // if 'titlelen' has changed, redraw the title</a>
<a name="ln4353">    if (starting != NO_SCREEN &amp;&amp; old_value != p_titlelen) {</a>
<a name="ln4354">      need_maketitle = true;</a>
<a name="ln4355">    }</a>
<a name="ln4356">  } else if (pp == &amp;p_ch) {</a>
<a name="ln4357">    // if p_ch changed value, change the command line height</a>
<a name="ln4358">    // Only compute the new window layout when startup has been</a>
<a name="ln4359">    // completed. Otherwise the frame sizes may be wrong.</a>
<a name="ln4360">    if (p_ch != old_value &amp;&amp; full_screen) {</a>
<a name="ln4361">      command_height();</a>
<a name="ln4362">    }</a>
<a name="ln4363">  } else if (pp == &amp;p_uc) {</a>
<a name="ln4364">    // when 'updatecount' changes from zero to non-zero, open swap files</a>
<a name="ln4365">    if (p_uc &amp;&amp; !old_value) {</a>
<a name="ln4366">      ml_open_files();</a>
<a name="ln4367">    }</a>
<a name="ln4368">  } else if (pp == &amp;p_pb) {</a>
<a name="ln4369">    p_pb = MAX(MIN(p_pb, 100), 0);</a>
<a name="ln4370">    hl_invalidate_blends();</a>
<a name="ln4371">    pum_grid.blending = (p_pb &gt; 0);</a>
<a name="ln4372">    if (pum_drawn()) {</a>
<a name="ln4373">      pum_redraw();</a>
<a name="ln4374">    }</a>
<a name="ln4375">  } else if (pp == &amp;p_pyx) {</a>
<a name="ln4376">    if (p_pyx != 0 &amp;&amp; p_pyx != 2 &amp;&amp; p_pyx != 3) {</a>
<a name="ln4377">      errmsg = e_invarg;</a>
<a name="ln4378">    }</a>
<a name="ln4379">  } else if (pp == &amp;p_ul || pp == &amp;curbuf-&gt;b_p_ul) {</a>
<a name="ln4380">    // sync undo before 'undolevels' changes</a>
<a name="ln4381">    // use the old value, otherwise u_sync() may not work properly</a>
<a name="ln4382">    *pp = old_value;</a>
<a name="ln4383">    u_sync(true);</a>
<a name="ln4384">    *pp = value;</a>
<a name="ln4385">  } else if (pp == &amp;curbuf-&gt;b_p_tw) {</a>
<a name="ln4386">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln4387">      check_colorcolumn(wp);</a>
<a name="ln4388">    }</a>
<a name="ln4389">  } else if (pp == &amp;curbuf-&gt;b_p_scbk || pp == &amp;p_scbk) {</a>
<a name="ln4390">    if (curbuf-&gt;terminal) {</a>
<a name="ln4391">      // Force the scrollback to take effect.</a>
<a name="ln4392">      terminal_check_size(curbuf-&gt;terminal);</a>
<a name="ln4393">    }</a>
<a name="ln4394">  } else if (pp == &amp;curwin-&gt;w_p_nuw) {</a>
<a name="ln4395">    curwin-&gt;w_nrwidth_line_count = 0;</a>
<a name="ln4396">  } else if (pp == &amp;curwin-&gt;w_p_winbl &amp;&amp; value != old_value) {</a>
<a name="ln4397">    // 'floatblend'</a>
<a name="ln4398">    curwin-&gt;w_p_winbl = MAX(MIN(curwin-&gt;w_p_winbl, 100), 0);</a>
<a name="ln4399">    curwin-&gt;w_hl_needs_update = true;</a>
<a name="ln4400">    check_blending(curwin);</a>
<a name="ln4401">  }</a>
<a name="ln4402"> </a>
<a name="ln4403"> </a>
<a name="ln4404">  // Check the (new) bounds for Rows and Columns here.</a>
<a name="ln4405">  if (p_lines &lt; min_rows() &amp;&amp; full_screen) {</a>
<a name="ln4406">    if (errbuf != NULL) {</a>
<a name="ln4407">      vim_snprintf((char *)errbuf, errbuflen,</a>
<a name="ln4408">          _(&quot;E593: Need at least %d lines&quot;), min_rows());</a>
<a name="ln4409">      errmsg = errbuf;</a>
<a name="ln4410">    }</a>
<a name="ln4411">    p_lines = min_rows();</a>
<a name="ln4412">  }</a>
<a name="ln4413">  if (p_columns &lt; MIN_COLUMNS &amp;&amp; full_screen) {</a>
<a name="ln4414">    if (errbuf != NULL) {</a>
<a name="ln4415">      vim_snprintf((char *)errbuf, errbuflen,</a>
<a name="ln4416">          _(&quot;E594: Need at least %d columns&quot;), MIN_COLUMNS);</a>
<a name="ln4417">      errmsg = errbuf;</a>
<a name="ln4418">    }</a>
<a name="ln4419">    p_columns = MIN_COLUMNS;</a>
<a name="ln4420">  }</a>
<a name="ln4421"> </a>
<a name="ln4422">  // True max size is defined by check_shellsize()</a>
<a name="ln4423">  p_lines = MIN(p_lines, INT_MAX);</a>
<a name="ln4424">  p_columns = MIN(p_columns, INT_MAX);</a>
<a name="ln4425"> </a>
<a name="ln4426">  // If the screen (shell) height has been changed, assume it is the</a>
<a name="ln4427">  // physical screenheight.</a>
<a name="ln4428">  if (p_lines != Rows || p_columns != Columns) {</a>
<a name="ln4429">    // Changing the screen size is not allowed while updating the screen.</a>
<a name="ln4430">    if (updating_screen) {</a>
<a name="ln4431">      *pp = old_value;</a>
<a name="ln4432">    } else if (full_screen) {</a>
<a name="ln4433">      screen_resize((int)p_columns, (int)p_lines);</a>
<a name="ln4434">    } else {</a>
<a name="ln4435">      // TODO(bfredl): is this branch ever needed?</a>
<a name="ln4436">      // Postpone the resizing; check the size and cmdline position for</a>
<a name="ln4437">      // messages.</a>
<a name="ln4438">      Rows = (int)p_lines;</a>
<a name="ln4439">      Columns = (int)p_columns;</a>
<a name="ln4440">      check_shellsize();</a>
<a name="ln4441">      if (cmdline_row &gt; Rows - p_ch &amp;&amp; Rows &gt; p_ch) {</a>
<a name="ln4442">        assert(p_ch &gt;= 0 &amp;&amp; Rows - p_ch &lt;= INT_MAX);</a>
<a name="ln4443">        cmdline_row = (int)(Rows - p_ch);</a>
<a name="ln4444">      }</a>
<a name="ln4445">    }</a>
<a name="ln4446">    if (p_window &gt;= Rows || !option_was_set(&quot;window&quot;)) {</a>
<a name="ln4447">      p_window = Rows - 1;</a>
<a name="ln4448">    }</a>
<a name="ln4449">  }</a>
<a name="ln4450"> </a>
<a name="ln4451">  if ((curwin-&gt;w_p_scr &lt;= 0</a>
<a name="ln4452">       || (curwin-&gt;w_p_scr &gt; curwin-&gt;w_height</a>
<a name="ln4453">           &amp;&amp; curwin-&gt;w_height &gt; 0))</a>
<a name="ln4454">      &amp;&amp; full_screen) {</a>
<a name="ln4455">    if (pp == &amp;(curwin-&gt;w_p_scr)) {</a>
<a name="ln4456">      if (curwin-&gt;w_p_scr != 0) {</a>
<a name="ln4457">        errmsg = e_scroll;</a>
<a name="ln4458">      }</a>
<a name="ln4459">      win_comp_scroll(curwin);</a>
<a name="ln4460">    } else if (curwin-&gt;w_p_scr &lt;= 0) {</a>
<a name="ln4461">    // If 'scroll' became invalid because of a side effect silently adjust it.</a>
<a name="ln4462">      curwin-&gt;w_p_scr = 1;</a>
<a name="ln4463">    } else {  // curwin-&gt;w_p_scr &gt; curwin-&gt;w_height</a>
<a name="ln4464">      curwin-&gt;w_p_scr = curwin-&gt;w_height;</a>
<a name="ln4465">    }</a>
<a name="ln4466">  }</a>
<a name="ln4467">  if ((p_sj &lt; -100 || p_sj &gt;= Rows) &amp;&amp; full_screen) {</a>
<a name="ln4468">    if (Rows != old_Rows) {     // Rows changed, just adjust p_sj</a>
<a name="ln4469">      p_sj = Rows / 2;</a>
<a name="ln4470">    } else {</a>
<a name="ln4471">      errmsg = e_scroll;</a>
<a name="ln4472">      p_sj = 1;</a>
<a name="ln4473">    }</a>
<a name="ln4474">  }</a>
<a name="ln4475"> </a>
<a name="ln4476">  // May set global value for local option.</a>
<a name="ln4477">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln4478">    *(long *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) = *pp;</a>
<a name="ln4479">  }</a>
<a name="ln4480"> </a>
<a name="ln4481">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln4482"> </a>
<a name="ln4483">  // Don't do this while starting up, failure or recursively.</a>
<a name="ln4484">  if (!starting &amp;&amp; errmsg == NULL &amp;&amp; *get_vim_var_str(VV_OPTION_TYPE) == NUL) {</a>
<a name="ln4485">    char buf_old[NUMBUFLEN];</a>
<a name="ln4486">    char buf_new[NUMBUFLEN];</a>
<a name="ln4487">    char buf_type[7];</a>
<a name="ln4488"> </a>
<a name="ln4489">    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), &quot;%ld&quot;, old_value);</a>
<a name="ln4490">    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), &quot;%ld&quot;, value);</a>
<a name="ln4491">    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), &quot;%s&quot;,</a>
<a name="ln4492">                 (opt_flags &amp; OPT_LOCAL) ? &quot;local&quot; : &quot;global&quot;);</a>
<a name="ln4493">    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);</a>
<a name="ln4494">    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);</a>
<a name="ln4495">    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);</a>
<a name="ln4496">    apply_autocmds(EVENT_OPTIONSET,</a>
<a name="ln4497">                   (char_u *) options[opt_idx].fullname,</a>
<a name="ln4498">                   NULL, false, NULL);</a>
<a name="ln4499">    reset_v_option_vars();</a>
<a name="ln4500">  }</a>
<a name="ln4501"> </a>
<a name="ln4502">  if (errmsg == NULL &amp;&amp; options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln4503">    ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln4504">                       INTEGER_OBJ(value));</a>
<a name="ln4505">  }</a>
<a name="ln4506"> </a>
<a name="ln4507">  comp_col();                       // in case 'columns' or 'ls' changed</a>
<a name="ln4508">  if (curwin-&gt;w_curswant != MAXCOL</a>
<a name="ln4509">      &amp;&amp; (options[opt_idx].flags &amp; (P_CURSWANT | P_RALL)) != 0) {</a>
<a name="ln4510">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln4511">  }</a>
<a name="ln4512">  check_redraw(options[opt_idx].flags);</a>
<a name="ln4513"> </a>
<a name="ln4514">  return (char *)errmsg;</a>
<a name="ln4515">}</a>
<a name="ln4516"> </a>
<a name="ln4517">static void trigger_optionsset_string(int opt_idx, int opt_flags,</a>
<a name="ln4518">                                      char *oldval, char *newval)</a>
<a name="ln4519">{</a>
<a name="ln4520">  // Don't do this recursively.</a>
<a name="ln4521">  if (oldval != NULL</a>
<a name="ln4522">      &amp;&amp; newval != NULL</a>
<a name="ln4523">      &amp;&amp; *get_vim_var_str(VV_OPTION_TYPE) == NUL) {</a>
<a name="ln4524">    char buf_type[7];</a>
<a name="ln4525"> </a>
<a name="ln4526">    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), &quot;%s&quot;,</a>
<a name="ln4527">                 (opt_flags &amp; OPT_LOCAL) ? &quot;local&quot; : &quot;global&quot;);</a>
<a name="ln4528">    set_vim_var_string(VV_OPTION_OLD, oldval, -1);</a>
<a name="ln4529">    set_vim_var_string(VV_OPTION_NEW, newval, -1);</a>
<a name="ln4530">    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);</a>
<a name="ln4531">    apply_autocmds(EVENT_OPTIONSET,</a>
<a name="ln4532">                   (char_u *)options[opt_idx].fullname, NULL, false, NULL);</a>
<a name="ln4533">    reset_v_option_vars();</a>
<a name="ln4534">  }</a>
<a name="ln4535">}</a>
<a name="ln4536"> </a>
<a name="ln4537">/// Called after an option changed: check if something needs to be redrawn.</a>
<a name="ln4538">static void check_redraw(uint32_t flags)</a>
<a name="ln4539">{</a>
<a name="ln4540">  // Careful: P_RCLR and P_RALL are a combination of other P_ flags</a>
<a name="ln4541">  bool doclear = (flags &amp; P_RCLR) == P_RCLR;</a>
<a name="ln4542">  bool all = ((flags &amp; P_RALL) == P_RALL || doclear);</a>
<a name="ln4543"> </a>
<a name="ln4544">  if ((flags &amp; P_RSTAT) || all) {  // mark all status lines dirty</a>
<a name="ln4545">    status_redraw_all();</a>
<a name="ln4546">  }</a>
<a name="ln4547"> </a>
<a name="ln4548">  if ((flags &amp; P_RBUF) || (flags &amp; P_RWIN) || all) {</a>
<a name="ln4549">    changed_window_setting();</a>
<a name="ln4550">  }</a>
<a name="ln4551">  if (flags &amp; P_RBUF) {</a>
<a name="ln4552">    redraw_curbuf_later(NOT_VALID);</a>
<a name="ln4553">  }</a>
<a name="ln4554">  if (flags &amp; P_RWINONLY) {</a>
<a name="ln4555">    redraw_later(curwin, NOT_VALID);</a>
<a name="ln4556">  }</a>
<a name="ln4557">  if (doclear) {</a>
<a name="ln4558">    redraw_all_later(CLEAR);</a>
<a name="ln4559">  } else if (all) {</a>
<a name="ln4560">    redraw_all_later(NOT_VALID);</a>
<a name="ln4561">  }</a>
<a name="ln4562">}</a>
<a name="ln4563"> </a>
<a name="ln4564">/// Find index for named option</a>
<a name="ln4565">///</a>
<a name="ln4566">/// @param[in]  arg  Option to find index for.</a>
<a name="ln4567">/// @param[in]  len  Length of the option.</a>
<a name="ln4568">///</a>
<a name="ln4569">/// @return Index of the option or -1 if option was not found.</a>
<a name="ln4570">int findoption_len(const char *const arg, const size_t len)</a>
<a name="ln4571">{</a>
<a name="ln4572">  const char *s;</a>
<a name="ln4573">  const char *p;</a>
<a name="ln4574">  static int quick_tab[27] = { 0, 0 };  // quick access table</a>
<a name="ln4575"> </a>
<a name="ln4576">  // For first call: Initialize the quick-access table.</a>
<a name="ln4577">  // It contains the index for the first option that starts with a certain</a>
<a name="ln4578">  // letter.  There are 26 letters, plus the first &quot;t_&quot; option.</a>
<a name="ln4579">  if (quick_tab[1] == 0) {</a>
<a name="ln4580">    p = options[0].fullname;</a>
<a name="ln4581">    for (short int i = 1; (s = options[i].fullname) != NULL; i++) {</a>
<a name="ln4582">      if (s[0] != p[0]) {</a>
<a name="ln4583">        if (s[0] == 't' &amp;&amp; s[1] == '_') {</a>
<a name="ln4584">          quick_tab[26] = i;</a>
<a name="ln4585">        } else {</a>
<a name="ln4586">          quick_tab[CharOrdLow(s[0])] = i;</a>
<a name="ln4587">        }</a>
<a name="ln4588">      }</a>
<a name="ln4589">      p = s;</a>
<a name="ln4590">    }</a>
<a name="ln4591">  }</a>
<a name="ln4592"> </a>
<a name="ln4593">  // Check for name starting with an illegal character.</a>
<a name="ln4594">  if (len == 0 || arg[0] &lt; 'a' || arg[0] &gt; 'z') {</a>
<a name="ln4595">    return -1;</a>
<a name="ln4596">  }</a>
<a name="ln4597"> </a>
<a name="ln4598">  int opt_idx;</a>
<a name="ln4599">  const bool is_term_opt = (len &gt; 2 &amp;&amp; arg[0] == 't' &amp;&amp; arg[1] == '_');</a>
<a name="ln4600">  if (is_term_opt) {</a>
<a name="ln4601">    opt_idx = quick_tab[26];</a>
<a name="ln4602">  } else {</a>
<a name="ln4603">    opt_idx = quick_tab[CharOrdLow(arg[0])];</a>
<a name="ln4604">  }</a>
<a name="ln4605">  // Match full name</a>
<a name="ln4606">  for (; (s = options[opt_idx].fullname) != NULL; opt_idx++) {</a>
<a name="ln4607">    if (strncmp(arg, s, len) == 0 &amp;&amp; s[len] == NUL) {</a>
<a name="ln4608">      break;</a>
<a name="ln4609">    }</a>
<a name="ln4610">  }</a>
<a name="ln4611">  if (s == NULL &amp;&amp; !is_term_opt) {</a>
<a name="ln4612">    opt_idx = quick_tab[CharOrdLow(arg[0])];</a>
<a name="ln4613">    // Match short name</a>
<a name="ln4614">    for (; options[opt_idx].fullname != NULL; opt_idx++) {</a>
<a name="ln4615">      s = options[opt_idx].shortname;</a>
<a name="ln4616">      if (s != NULL &amp;&amp; strncmp(arg, s, len) == 0 &amp;&amp; s[len] == NUL) {</a>
<a name="ln4617">        break;</a>
<a name="ln4618">      }</a>
<a name="ln4619">      s = NULL;</a>
<a name="ln4620">    }</a>
<a name="ln4621">  }</a>
<a name="ln4622">  if (s == NULL) {</a>
<a name="ln4623">    opt_idx = -1;</a>
<a name="ln4624">  } else {</a>
<a name="ln4625">    // Nvim: handle option aliases.</a>
<a name="ln4626">    if (STRNCMP(options[opt_idx].fullname, &quot;viminfo&quot;, 7) == 0) {</a>
<a name="ln4627">      if (STRLEN(options[opt_idx].fullname) == 7) {</a>
<a name="ln4628">        return findoption_len(&quot;shada&quot;, 5);</a>
<a name="ln4629">      }</a>
<a name="ln4630">      assert(STRCMP(options[opt_idx].fullname, &quot;viminfofile&quot;) == 0);</a>
<a name="ln4631">      return findoption_len(&quot;shadafile&quot;, 9);</a>
<a name="ln4632">    }</a>
<a name="ln4633">  }</a>
<a name="ln4634">  return opt_idx;</a>
<a name="ln4635">}</a>
<a name="ln4636"> </a>
<a name="ln4637">bool is_tty_option(const char *name)</a>
<a name="ln4638">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4639">{</a>
<a name="ln4640">  return (name[0] == 't' &amp;&amp; name[1] == '_')</a>
<a name="ln4641">    || strequal(name, &quot;term&quot;)</a>
<a name="ln4642">    || strequal(name, &quot;ttytype&quot;);</a>
<a name="ln4643">}</a>
<a name="ln4644"> </a>
<a name="ln4645">#define TCO_BUFFER_SIZE 8</a>
<a name="ln4646">/// @param name TUI-related option</a>
<a name="ln4647">/// @param[out,allocated] value option string value</a>
<a name="ln4648">bool get_tty_option(const char *name, char **value)</a>
<a name="ln4649">{</a>
<a name="ln4650">  if (strequal(name, &quot;t_Co&quot;)) {</a>
<a name="ln4651">    if (value) {</a>
<a name="ln4652">      if (t_colors &lt;= 1) {</a>
<a name="ln4653">        *value = xstrdup(&quot;&quot;);</a>
<a name="ln4654">      } else {</a>
<a name="ln4655">        *value = xmalloc(TCO_BUFFER_SIZE);</a>
<a name="ln4656">        snprintf(*value, TCO_BUFFER_SIZE, &quot;%d&quot;, t_colors);</a>
<a name="ln4657">      }</a>
<a name="ln4658">    }</a>
<a name="ln4659">    return true;</a>
<a name="ln4660">  }</a>
<a name="ln4661"> </a>
<a name="ln4662">  if (strequal(name, &quot;term&quot;)) {</a>
<a name="ln4663">    if (value) {</a>
<a name="ln4664">      *value = p_term ? xstrdup(p_term) : xstrdup(&quot;nvim&quot;);</a>
<a name="ln4665">    }</a>
<a name="ln4666">    return true;</a>
<a name="ln4667">  }</a>
<a name="ln4668"> </a>
<a name="ln4669">  if (strequal(name, &quot;ttytype&quot;)) {</a>
<a name="ln4670">    if (value) {</a>
<a name="ln4671">      *value = p_ttytype ? xstrdup(p_ttytype) : xstrdup(&quot;nvim&quot;);</a>
<a name="ln4672">    }</a>
<a name="ln4673">    return true;</a>
<a name="ln4674">  }</a>
<a name="ln4675"> </a>
<a name="ln4676">  if (is_tty_option(name)) {</a>
<a name="ln4677">    if (value) {</a>
<a name="ln4678">      // XXX: All other t_* options were removed in 3baba1e7.</a>
<a name="ln4679">      *value = xstrdup(&quot;&quot;);</a>
<a name="ln4680">    }</a>
<a name="ln4681">    return true;</a>
<a name="ln4682">  }</a>
<a name="ln4683"> </a>
<a name="ln4684">  return false;</a>
<a name="ln4685">}</a>
<a name="ln4686"> </a>
<a name="ln4687">bool set_tty_option(const char *name, char *value)</a>
<a name="ln4688">{</a>
<a name="ln4689">  if (strequal(name, &quot;term&quot;)) {</a>
<a name="ln4690">    if (p_term) {</a>
<a name="ln4691">      xfree(p_term);</a>
<a name="ln4692">    }</a>
<a name="ln4693">    p_term = value;</a>
<a name="ln4694">    return true;</a>
<a name="ln4695">  }</a>
<a name="ln4696"> </a>
<a name="ln4697">  if (strequal(name, &quot;ttytype&quot;)) {</a>
<a name="ln4698">    if (p_ttytype) {</a>
<a name="ln4699">      xfree(p_ttytype);</a>
<a name="ln4700">    }</a>
<a name="ln4701">    p_ttytype = value;</a>
<a name="ln4702">    return true;</a>
<a name="ln4703">  }</a>
<a name="ln4704"> </a>
<a name="ln4705">  return false;</a>
<a name="ln4706">}</a>
<a name="ln4707"> </a>
<a name="ln4708">/// Find index for an option</a>
<a name="ln4709">///</a>
<a name="ln4710">/// @param[in]  arg  Option name.</a>
<a name="ln4711">///</a>
<a name="ln4712">/// @return Option index or -1 if option was not found.</a>
<a name="ln4713">static int findoption(const char *const arg)</a>
<a name="ln4714">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4715">{</a>
<a name="ln4716">  return findoption_len(arg, strlen(arg));</a>
<a name="ln4717">}</a>
<a name="ln4718"> </a>
<a name="ln4719">/// Gets the value for an option.</a>
<a name="ln4720">///</a>
<a name="ln4721">/// @returns:</a>
<a name="ln4722">/// Number or Toggle option: 1, *numval gets value.</a>
<a name="ln4723">///           String option: 0, *stringval gets allocated string.</a>
<a name="ln4724">/// Hidden Number or Toggle option: -1.</a>
<a name="ln4725">///           hidden String option: -2.</a>
<a name="ln4726">///                 unknown option: -3.</a>
<a name="ln4727">int get_option_value(</a>
<a name="ln4728">    const char *name,</a>
<a name="ln4729">    long *numval,</a>
<a name="ln4730">    char_u **stringval,            ///&lt; NULL when only checking existence</a>
<a name="ln4731">    int opt_flags</a>
<a name="ln4732">)</a>
<a name="ln4733">{</a>
<a name="ln4734">  if (get_tty_option(name, (char **)stringval)) {</a>
<a name="ln4735">    return 0;</a>
<a name="ln4736">  }</a>
<a name="ln4737"> </a>
<a name="ln4738">  int opt_idx = findoption(name);</a>
<a name="ln4739">  if (opt_idx &lt; 0) {  // Unknown option.</a>
<a name="ln4740">    return -3;</a>
<a name="ln4741">  }</a>
<a name="ln4742"> </a>
<a name="ln4743">  char_u *varp = get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln4744"> </a>
<a name="ln4745">  if (options[opt_idx].flags &amp; P_STRING) {</a>
<a name="ln4746">    if (varp == NULL) {  // hidden option</a>
<a name="ln4747">      return -2;</a>
<a name="ln4748">    }</a>
<a name="ln4749">    if (stringval != NULL) {</a>
<a name="ln4750">      *stringval = vim_strsave(*(char_u **)(varp));</a>
<a name="ln4751">    }</a>
<a name="ln4752">    return 0;</a>
<a name="ln4753">  }</a>
<a name="ln4754"> </a>
<a name="ln4755">  if (varp == NULL) {  // hidden option</a>
<a name="ln4756">    return -1;</a>
<a name="ln4757">  }</a>
<a name="ln4758">  if (options[opt_idx].flags &amp; P_NUM) {</a>
<a name="ln4759">    *numval = *(long *)varp;</a>
<a name="ln4760">  } else {</a>
<a name="ln4761">    // Special case: 'modified' is b_changed, but we also want to consider</a>
<a name="ln4762">    // it set when 'ff' or 'fenc' changed.</a>
<a name="ln4763">    if ((int *)varp == &amp;curbuf-&gt;b_changed) {</a>
<a name="ln4764">      *numval = curbufIsChanged();</a>
<a name="ln4765">    } else {</a>
<a name="ln4766">      *numval = (long) *(int *)varp;  // NOLINT(whitespace/cast)</a>
<a name="ln4767">    }</a>
<a name="ln4768">  }</a>
<a name="ln4769">  return 1;</a>
<a name="ln4770">}</a>
<a name="ln4771"> </a>
<a name="ln4772">// Returns the option attributes and its value. Unlike the above function it</a>
<a name="ln4773">// will return either global value or local value of the option depending on</a>
<a name="ln4774">// what was requested, but it will never return global value if it was</a>
<a name="ln4775">// requested to return local one and vice versa. Neither it will return</a>
<a name="ln4776">// buffer-local value if it was requested to return window-local one.</a>
<a name="ln4777">//</a>
<a name="ln4778">// Pretends that option is absent if it is not present in the requested scope</a>
<a name="ln4779">// (i.e. has no global, window-local or buffer-local value depending on</a>
<a name="ln4780">// opt_type).</a>
<a name="ln4781">//</a>
<a name="ln4782">// Returned flags:</a>
<a name="ln4783">//       0 hidden or unknown option, also option that does not have requested</a>
<a name="ln4784">//         type (see SREQ_* in option_defs.h)</a>
<a name="ln4785">//  see SOPT_* in option_defs.h for other flags</a>
<a name="ln4786">//</a>
<a name="ln4787">// Possible opt_type values: see SREQ_* in option_defs.h</a>
<a name="ln4788">int get_option_value_strict(char *name,</a>
<a name="ln4789">                            int64_t *numval,</a>
<a name="ln4790">                            char **stringval,</a>
<a name="ln4791">                            int opt_type,</a>
<a name="ln4792">                            void *from)</a>
<a name="ln4793">{</a>
<a name="ln4794">  if (get_tty_option(name, stringval)) {</a>
<a name="ln4795">    return SOPT_STRING | SOPT_GLOBAL;</a>
<a name="ln4796">  }</a>
<a name="ln4797"> </a>
<a name="ln4798">  char_u *varp = NULL;</a>
<a name="ln4799">  int rv = 0;</a>
<a name="ln4800">  int opt_idx = findoption(name);</a>
<a name="ln4801">  if (opt_idx &lt; 0) {</a>
<a name="ln4802">    return 0;</a>
<a name="ln4803">  }</a>
<a name="ln4804"> </a>
<a name="ln4805">  vimoption_T *p = &amp;options[opt_idx];</a>
<a name="ln4806"> </a>
<a name="ln4807">  // Hidden option</a>
<a name="ln4808">  if (p-&gt;var == NULL) {</a>
<a name="ln4809">    return 0;</a>
<a name="ln4810">  }</a>
<a name="ln4811"> </a>
<a name="ln4812">  if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln4813">    rv |= SOPT_BOOL;</a>
<a name="ln4814">  } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln4815">    rv |= SOPT_NUM;</a>
<a name="ln4816">  } else if (p-&gt;flags &amp; P_STRING) {</a>
<a name="ln4817">    rv |= SOPT_STRING;</a>
<a name="ln4818">  }</a>
<a name="ln4819"> </a>
<a name="ln4820">  if (p-&gt;indir == PV_NONE) {</a>
<a name="ln4821">    if (opt_type == SREQ_GLOBAL) {</a>
<a name="ln4822">      rv |= SOPT_GLOBAL;</a>
<a name="ln4823">    } else {</a>
<a name="ln4824">      return 0;  // Did not request global-only option</a>
<a name="ln4825">    }</a>
<a name="ln4826">  } else {</a>
<a name="ln4827">    if (p-&gt;indir &amp; PV_BOTH) {</a>
<a name="ln4828">      rv |= SOPT_GLOBAL;</a>
<a name="ln4829">    }</a>
<a name="ln4830"> </a>
<a name="ln4831">    if (p-&gt;indir &amp; PV_WIN) {</a>
<a name="ln4832">      if (opt_type == SREQ_BUF) {</a>
<a name="ln4833">        return 0;  // Requested buffer-local, not window-local option</a>
<a name="ln4834">      } else {</a>
<a name="ln4835">        rv |= SOPT_WIN;</a>
<a name="ln4836">      }</a>
<a name="ln4837">    } else if (p-&gt;indir &amp; PV_BUF) {</a>
<a name="ln4838">      if (opt_type == SREQ_WIN) {</a>
<a name="ln4839">        return 0;  // Requested window-local, not buffer-local option</a>
<a name="ln4840">      } else {</a>
<a name="ln4841">        rv |= SOPT_BUF;</a>
<a name="ln4842">      }</a>
<a name="ln4843">    }</a>
<a name="ln4844">  }</a>
<a name="ln4845"> </a>
<a name="ln4846">  if (stringval == NULL) {</a>
<a name="ln4847">    return rv;</a>
<a name="ln4848">  }</a>
<a name="ln4849"> </a>
<a name="ln4850">  if (opt_type == SREQ_GLOBAL) {</a>
<a name="ln4851">    if (p-&gt;var == VAR_WIN) {</a>
<a name="ln4852">      return 0;</a>
<a name="ln4853">    } else {</a>
<a name="ln4854">      varp = p-&gt;var;</a>
<a name="ln4855">    }</a>
<a name="ln4856">  } else {</a>
<a name="ln4857">    if (opt_type == SREQ_BUF) {</a>
<a name="ln4858">      // Special case: 'modified' is b_changed, but we also want to</a>
<a name="ln4859">      // consider it set when 'ff' or 'fenc' changed.</a>
<a name="ln4860">      if (p-&gt;indir == PV_MOD) {</a>
<a name="ln4861">        *numval = bufIsChanged((buf_T *)from);</a>
<a name="ln4862">        varp = NULL;</a>
<a name="ln4863">      } else {</a>
<a name="ln4864">        buf_T *save_curbuf = curbuf;</a>
<a name="ln4865"> </a>
<a name="ln4866">        // only getting a pointer, no need to use aucmd_prepbuf()</a>
<a name="ln4867">        curbuf = (buf_T *)from;</a>
<a name="ln4868">        curwin-&gt;w_buffer = curbuf;</a>
<a name="ln4869">        varp = get_varp(p);</a>
<a name="ln4870">        curbuf = save_curbuf;</a>
<a name="ln4871">        curwin-&gt;w_buffer = curbuf;</a>
<a name="ln4872">      }</a>
<a name="ln4873">    } else if (opt_type == SREQ_WIN) {</a>
<a name="ln4874">      win_T *save_curwin = curwin;</a>
<a name="ln4875">      curwin = (win_T *)from;</a>
<a name="ln4876">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln4877">      varp = get_varp(p);</a>
<a name="ln4878">      curwin = save_curwin;</a>
<a name="ln4879">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln4880">    }</a>
<a name="ln4881"> </a>
<a name="ln4882">    if (varp == p-&gt;var) {</a>
<a name="ln4883">      return (rv | SOPT_UNSET);</a>
<a name="ln4884">    }</a>
<a name="ln4885">  }</a>
<a name="ln4886"> </a>
<a name="ln4887">  if (varp != NULL) {</a>
<a name="ln4888">    if (p-&gt;flags &amp; P_STRING) {</a>
<a name="ln4889">      *stringval = xstrdup(*(char **)(varp));</a>
<a name="ln4890">    } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln4891">      *numval = *(long *)varp;</a>
<a name="ln4892">    } else {</a>
<a name="ln4893">      *numval = *(int *)varp;</a>
<a name="ln4894">    }</a>
<a name="ln4895">  }</a>
<a name="ln4896"> </a>
<a name="ln4897">  return rv;</a>
<a name="ln4898">}</a>
<a name="ln4899"> </a>
<a name="ln4900">/// Set the value of an option</a>
<a name="ln4901">///</a>
<a name="ln4902">/// @param[in]  name  Option name.</a>
<a name="ln4903">/// @param[in]  number  New value for the number or boolean option.</a>
<a name="ln4904">/// @param[in]  string  New value for string option.</a>
<a name="ln4905">/// @param[in]  opt_flags  Flags: OPT_LOCAL, OPT_GLOBAL, or 0 (both).</a>
<a name="ln4906">///</a>
<a name="ln4907">/// @return NULL on success, error message on error.</a>
<a name="ln4908">char *set_option_value(const char *const name, const long number,</a>
<a name="ln4909">                       const char *const string, const int opt_flags)</a>
<a name="ln4910">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln4911">{</a>
<a name="ln4912">  if (is_tty_option(name)) {</a>
<a name="ln4913">    return NULL;  // Fail silently; many old vimrcs set t_xx options.</a>
<a name="ln4914">  }</a>
<a name="ln4915"> </a>
<a name="ln4916">  int opt_idx;</a>
<a name="ln4917">  char_u      *varp;</a>
<a name="ln4918"> </a>
<a name="ln4919">  opt_idx = findoption(name);</a>
<a name="ln4920">  if (opt_idx &lt; 0) {</a>
<a name="ln4921">    EMSG2(_(&quot;E355: Unknown option: %s&quot;), name);</a>
<a name="ln4922">  } else {</a>
<a name="ln4923">    uint32_t flags = options[opt_idx].flags;</a>
<a name="ln4924">    // Disallow changing some options in the sandbox</a>
<a name="ln4925">    if (sandbox &gt; 0 &amp;&amp; (flags &amp; P_SECURE)) {</a>
<a name="ln4926">      EMSG(_(e_sandbox));</a>
<a name="ln4927">      return NULL;</a>
<a name="ln4928">    }</a>
<a name="ln4929">    if (flags &amp; P_STRING) {</a>
<a name="ln4930">      const char *s = string;</a>
<a name="ln4931">      if (s == NULL) {</a>
<a name="ln4932">        s = &quot;&quot;;</a>
<a name="ln4933">      }</a>
<a name="ln4934">      return set_string_option(opt_idx, s, opt_flags);</a>
<a name="ln4935">    } else {</a>
<a name="ln4936">      varp = get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln4937">      if (varp != NULL) {       // hidden option is not changed</a>
<a name="ln4938">        if (number == 0 &amp;&amp; string != NULL) {</a>
<a name="ln4939">          int idx;</a>
<a name="ln4940"> </a>
<a name="ln4941">          // Either we are given a string or we are setting option</a>
<a name="ln4942">          // to zero.</a>
<a name="ln4943">          for (idx = 0; string[idx] == '0'; idx++) {}</a>
<a name="ln4944">          if (string[idx] != NUL || idx == 0) {</a>
<a name="ln4945">            // There's another character after zeros or the string</a>
<a name="ln4946">            // is empty.  In both cases, we are trying to set a</a>
<a name="ln4947">            // num option using a string.</a>
<a name="ln4948">            EMSG3(_(&quot;E521: Number required: &amp;%s = '%s'&quot;),</a>
<a name="ln4949">                  name, string);</a>
<a name="ln4950">            return NULL;  // do nothing as we hit an error</a>
<a name="ln4951">          }</a>
<a name="ln4952">        }</a>
<a name="ln4953">        if (flags &amp; P_NUM) {</a>
<a name="ln4954">          return set_num_option(opt_idx, varp, number, NULL, 0, opt_flags);</a>
<a name="ln4955">        } else {</a>
<a name="ln4956">          return set_bool_option(opt_idx, varp, (int)number, opt_flags);</a>
<a name="ln4957">        }</a>
<a name="ln4958">      }</a>
<a name="ln4959">    }</a>
<a name="ln4960">  }</a>
<a name="ln4961">  return NULL;</a>
<a name="ln4962">}</a>
<a name="ln4963"> </a>
<a name="ln4964">// Translate a string like &quot;t_xx&quot;, &quot;&lt;t_xx&gt;&quot; or &quot;&lt;S-Tab&gt;&quot; to a key number.</a>
<a name="ln4965">// When &quot;has_lt&quot; is true there is a '&lt;' before &quot;*arg_arg&quot;.</a>
<a name="ln4966">// Returns 0 when the key is not recognized.</a>
<a name="ln4967">int find_key_option_len(const char_u *arg_arg, size_t len, bool has_lt)</a>
<a name="ln4968">{</a>
<a name="ln4969">  int key = 0;</a>
<a name="ln4970">  int modifiers;</a>
<a name="ln4971">  const char_u *arg = arg_arg;</a>
<a name="ln4972"> </a>
<a name="ln4973">  // Don't use get_special_key_code() for t_xx, we don't want it to call</a>
<a name="ln4974">  // add_termcap_entry().</a>
<a name="ln4975">  if (len &gt;= 4 &amp;&amp; arg[0] == 't' &amp;&amp; arg[1] == '_') {</a>
<a name="ln4976">    key = TERMCAP2KEY(arg[2], arg[3]);</a>
<a name="ln4977">  } else if (has_lt)  {</a>
<a name="ln4978">    arg--;  // put arg at the '&lt;'</a>
<a name="ln4979">    modifiers = 0;</a>
<a name="ln4980">    key = find_special_key(&amp;arg, len + 1, &amp;modifiers, true, true, false);</a>
<a name="ln4981">    if (modifiers) {  // can't handle modifiers here</a>
<a name="ln4982">      key = 0;</a>
<a name="ln4983">    }</a>
<a name="ln4984">  }</a>
<a name="ln4985">  return key;</a>
<a name="ln4986">}</a>
<a name="ln4987"> </a>
<a name="ln4988">static int find_key_option(const char_u *arg, bool has_lt)</a>
<a name="ln4989">{</a>
<a name="ln4990">  return find_key_option_len(arg, STRLEN(arg), has_lt);</a>
<a name="ln4991">}</a>
<a name="ln4992"> </a>
<a name="ln4993">/// if 'all' == 0: show changed options</a>
<a name="ln4994">/// if 'all' == 1: show all normal options</a>
<a name="ln4995">static void</a>
<a name="ln4996">showoptions(</a>
<a name="ln4997">    int all,</a>
<a name="ln4998">    int opt_flags                  // OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln4999">)</a>
<a name="ln5000">{</a>
<a name="ln5001">  vimoption_T    *p;</a>
<a name="ln5002">  int col;</a>
<a name="ln5003">  char_u              *varp;</a>
<a name="ln5004">  int item_count;</a>
<a name="ln5005">  int run;</a>
<a name="ln5006">  int row, rows;</a>
<a name="ln5007">  int cols;</a>
<a name="ln5008">  int i;</a>
<a name="ln5009">  int len;</a>
<a name="ln5010"> </a>
<a name="ln5011">#define INC 20</a>
<a name="ln5012">#define GAP 3</a>
<a name="ln5013"> </a>
<a name="ln5014">  vimoption_T **items = xmalloc(sizeof(vimoption_T *) * PARAM_COUNT);</a>
<a name="ln5015"> </a>
<a name="ln5016">  // Highlight title</a>
<a name="ln5017">  if (opt_flags &amp; OPT_GLOBAL) {</a>
<a name="ln5018">    MSG_PUTS_TITLE(_(&quot;\n--- Global option values ---&quot;));</a>
<a name="ln5019">  } else if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln5020">    MSG_PUTS_TITLE(_(&quot;\n--- Local option values ---&quot;));</a>
<a name="ln5021">  } else {</a>
<a name="ln5022">    MSG_PUTS_TITLE(_(&quot;\n--- Options ---&quot;));</a>
<a name="ln5023">  }</a>
<a name="ln5024"> </a>
<a name="ln5025">  // Do the loop two times:</a>
<a name="ln5026">  // 1. display the short items</a>
<a name="ln5027">  // 2. display the long items (only strings and numbers)</a>
<a name="ln5028">  for (run = 1; run &lt;= 2 &amp;&amp; !got_int; run++) {</a>
<a name="ln5029">    // collect the items in items[]</a>
<a name="ln5030">    item_count = 0;</a>
<a name="ln5031">    for (p = &amp;options[0]; p-&gt;fullname != NULL; p++) {</a>
<a name="ln5032">      // apply :filter /pat/</a>
<a name="ln5033">      if (message_filtered((char_u *)p-&gt;fullname)) {</a>
<a name="ln5034">        continue;</a>
<a name="ln5035">      }</a>
<a name="ln5036"> </a>
<a name="ln5037">      varp = NULL;</a>
<a name="ln5038">      if (opt_flags != 0) {</a>
<a name="ln5039">        if (p-&gt;indir != PV_NONE) {</a>
<a name="ln5040">          varp = get_varp_scope(p, opt_flags);</a>
<a name="ln5041">        }</a>
<a name="ln5042">      } else {</a>
<a name="ln5043">        varp = get_varp(p);</a>
<a name="ln5044">      }</a>
<a name="ln5045">      if (varp != NULL</a>
<a name="ln5046">          &amp;&amp; (all == 1 || (all == 0 &amp;&amp; !optval_default(p, varp)))) {</a>
<a name="ln5047">        if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln5048">          len = 1;                      //  a toggle option fits always</a>
<a name="ln5049">        } else {</a>
<a name="ln5050">          option_value2string(p, opt_flags);</a>
<a name="ln5051">          len = (int)STRLEN(p-&gt;fullname) + vim_strsize(NameBuff) + 1;</a>
<a name="ln5052">        }</a>
<a name="ln5053">        if ((len &lt;= INC - GAP &amp;&amp; run == 1)</a>
<a name="ln5054">            || (len &gt; INC - GAP &amp;&amp; run == 2)) {</a>
<a name="ln5055">          items[item_count++] = p;</a>
<a name="ln5056">        }</a>
<a name="ln5057">      }</a>
<a name="ln5058">    }</a>
<a name="ln5059"> </a>
<a name="ln5060">    /*</a>
<a name="ln5061">     * display the items</a>
<a name="ln5062">     */</a>
<a name="ln5063">    if (run == 1) {</a>
<a name="ln5064">      assert(Columns &lt;= INT_MAX - GAP</a>
<a name="ln5065">             &amp;&amp; Columns + GAP &gt;= INT_MIN + 3</a>
<a name="ln5066">             &amp;&amp; (Columns + GAP - 3) / INC &gt;= INT_MIN</a>
<a name="ln5067">             &amp;&amp; (Columns + GAP - 3) / INC &lt;= INT_MAX);</a>
<a name="ln5068">      cols = (int)((Columns + GAP - 3) / INC);</a>
<a name="ln5069">      if (cols == 0) {</a>
<a name="ln5070">        cols = 1;</a>
<a name="ln5071">      }</a>
<a name="ln5072">      rows = (item_count + cols - 1) / cols;</a>
<a name="ln5073">    } else {    // run == 2</a>
<a name="ln5074">      rows = item_count;</a>
<a name="ln5075">    }</a>
<a name="ln5076">    for (row = 0; row &lt; rows &amp;&amp; !got_int; row++) {</a>
<a name="ln5077">      msg_putchar('\n');                        // go to next line</a>
<a name="ln5078">      if (got_int) {                            // 'q' typed in more</a>
<a name="ln5079">        break;</a>
<a name="ln5080">      }</a>
<a name="ln5081">      col = 0;</a>
<a name="ln5082">      for (i = row; i &lt; item_count; i += rows) {</a>
<a name="ln5083">        msg_col = col;                          // make columns</a>
<a name="ln5084">        showoneopt(items[i], opt_flags);</a>
<a name="ln5085">        col += INC;</a>
<a name="ln5086">      }</a>
<a name="ln5087">      ui_flush();</a>
<a name="ln5088">      os_breakcheck();</a>
<a name="ln5089">    }</a>
<a name="ln5090">  }</a>
<a name="ln5091">  xfree(items);</a>
<a name="ln5092">}</a>
<a name="ln5093"> </a>
<a name="ln5094">/// Return true if option &quot;p&quot; has its default value.</a>
<a name="ln5095">static int optval_default(vimoption_T *p, char_u *varp)</a>
<a name="ln5096">{</a>
<a name="ln5097">  int dvi;</a>
<a name="ln5098"> </a>
<a name="ln5099">  if (varp == NULL) {</a>
<a name="ln5100">    return true;            // hidden option is always at default</a>
<a name="ln5101">  }</a>
<a name="ln5102">  dvi = (p-&gt;flags &amp; P_VI_DEF) ? VI_DEFAULT : VIM_DEFAULT;</a>
<a name="ln5103">  if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln5104">    return *(long *)varp == (long)(intptr_t)p-&gt;def_val[dvi];</a>
<a name="ln5105">  }</a>
<a name="ln5106">  if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln5107">    return *(int *)varp == (int)(intptr_t)p-&gt;def_val[dvi];</a>
<a name="ln5108">  }</a>
<a name="ln5109">  // P_STRING</a>
<a name="ln5110">  return STRCMP(*(char_u **)varp, p-&gt;def_val[dvi]) == 0;</a>
<a name="ln5111">}</a>
<a name="ln5112"> </a>
<a name="ln5113">/// Send update to UIs with values of UI relevant options</a>
<a name="ln5114">void ui_refresh_options(void)</a>
<a name="ln5115">{</a>
<a name="ln5116">  for (int opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln5117">    uint32_t flags = options[opt_idx].flags;</a>
<a name="ln5118">    if (!(flags &amp; P_UI_OPTION)) {</a>
<a name="ln5119">      continue;</a>
<a name="ln5120">    }</a>
<a name="ln5121">    String name = cstr_as_string(options[opt_idx].fullname);</a>
<a name="ln5122">    void *varp = options[opt_idx].var;</a>
<a name="ln5123">    Object value = OBJECT_INIT;</a>
<a name="ln5124">    if (flags &amp; P_BOOL) {</a>
<a name="ln5125">      value = BOOLEAN_OBJ(*(int *)varp);</a>
<a name="ln5126">    } else if (flags &amp; P_NUM) {</a>
<a name="ln5127">      value = INTEGER_OBJ(*(long *)varp);</a>
<a name="ln5128">    } else if (flags &amp; P_STRING) {</a>
<a name="ln5129">      // cstr_as_string handles NULL string</a>
<a name="ln5130">      value = STRING_OBJ(cstr_as_string(*(char **)varp));</a>
<a name="ln5131">    }</a>
<a name="ln5132">    ui_call_option_set(name, value);</a>
<a name="ln5133">  }</a>
<a name="ln5134">  if (p_mouse != NULL) {</a>
<a name="ln5135">    setmouse();</a>
<a name="ln5136">  }</a>
<a name="ln5137">}</a>
<a name="ln5138"> </a>
<a name="ln5139">/// showoneopt: show the value of one option</a>
<a name="ln5140">/// must not be called with a hidden option!</a>
<a name="ln5141">static void</a>
<a name="ln5142">showoneopt(</a>
<a name="ln5143">    vimoption_T *p,</a>
<a name="ln5144">    int opt_flags                          // OPT_LOCAL or OPT_GLOBAL</a>
<a name="ln5145">)</a>
<a name="ln5146">{</a>
<a name="ln5147">  char_u      *varp;</a>
<a name="ln5148">  int save_silent = silent_mode;</a>
<a name="ln5149"> </a>
<a name="ln5150">  silent_mode = false;</a>
<a name="ln5151">  info_message = true;          // use mch_msg(), not mch_errmsg()</a>
<a name="ln5152"> </a>
<a name="ln5153">  varp = get_varp_scope(p, opt_flags);</a>
<a name="ln5154"> </a>
<a name="ln5155">  // for 'modified' we also need to check if 'ff' or 'fenc' changed.</a>
<a name="ln5156">  if ((p-&gt;flags &amp; P_BOOL) &amp;&amp; ((int *)varp == &amp;curbuf-&gt;b_changed</a>
<a name="ln5157">                              ? !curbufIsChanged() : !*(int *)varp)) {</a>
<a name="ln5158">    MSG_PUTS(&quot;no&quot;);</a>
<a name="ln5159">  } else if ((p-&gt;flags &amp; P_BOOL) &amp;&amp; *(int *)varp &lt; 0) {</a>
<a name="ln5160">    MSG_PUTS(&quot;--&quot;);</a>
<a name="ln5161">  } else {</a>
<a name="ln5162">    MSG_PUTS(&quot;  &quot;);</a>
<a name="ln5163">  }</a>
<a name="ln5164">  MSG_PUTS(p-&gt;fullname);</a>
<a name="ln5165">  if (!(p-&gt;flags &amp; P_BOOL)) {</a>
<a name="ln5166">    msg_putchar('=');</a>
<a name="ln5167">    // put value string in NameBuff</a>
<a name="ln5168">    option_value2string(p, opt_flags);</a>
<a name="ln5169">    msg_outtrans(NameBuff);</a>
<a name="ln5170">  }</a>
<a name="ln5171"> </a>
<a name="ln5172">  silent_mode = save_silent;</a>
<a name="ln5173">  info_message = false;</a>
<a name="ln5174">}</a>
<a name="ln5175"> </a>
<a name="ln5176">/// Write modified options as &quot;:set&quot; commands to a file.</a>
<a name="ln5177">///</a>
<a name="ln5178">/// There are three values for &quot;opt_flags&quot;:</a>
<a name="ln5179">/// OPT_GLOBAL:         Write global option values and fresh values of</a>
<a name="ln5180">///             buffer-local options (used for start of a session</a>
<a name="ln5181">///             file).</a>
<a name="ln5182">/// OPT_GLOBAL + OPT_LOCAL: Idem, add fresh values of window-local options for</a>
<a name="ln5183">///             curwin (used for a vimrc file).</a>
<a name="ln5184">/// OPT_LOCAL:          Write buffer-local option values for curbuf, fresh</a>
<a name="ln5185">///             and local values for window-local options of</a>
<a name="ln5186">///             curwin.  Local values are also written when at the</a>
<a name="ln5187">///             default value, because a modeline or autocommand</a>
<a name="ln5188">///             may have set them when doing &quot;:edit file&quot; and the</a>
<a name="ln5189">///             user has set them back at the default or fresh</a>
<a name="ln5190">///             value.</a>
<a name="ln5191">///             When &quot;local_only&quot; is true, don't write fresh</a>
<a name="ln5192">///             values, only local values (for &quot;:mkview&quot;).</a>
<a name="ln5193">/// (fresh value = value used for a new buffer or window for a local option).</a>
<a name="ln5194">///</a>
<a name="ln5195">/// Return FAIL on error, OK otherwise.</a>
<a name="ln5196">int makeset(FILE *fd, int opt_flags, int local_only)</a>
<a name="ln5197">{</a>
<a name="ln5198">  vimoption_T    *p;</a>
<a name="ln5199">  char_u              *varp;                    // currently used value</a>
<a name="ln5200">  char_u              *varp_fresh;              // local value</a>
<a name="ln5201">  char_u              *varp_local = NULL;       // fresh value</a>
<a name="ln5202">  char                *cmd;</a>
<a name="ln5203">  int round;</a>
<a name="ln5204">  int pri;</a>
<a name="ln5205"> </a>
<a name="ln5206">  /*</a>
<a name="ln5207">   * Some options are never written:</a>
<a name="ln5208">   * - Options that don't have a default (terminal name, columns, lines).</a>
<a name="ln5209">   * - Terminal options.</a>
<a name="ln5210">   * - Hidden options.</a>
<a name="ln5211">   *</a>
<a name="ln5212">   * Do the loop over &quot;options[]&quot; twice: once for options with the</a>
<a name="ln5213">   * P_PRI_MKRC flag and once without.</a>
<a name="ln5214">   */</a>
<a name="ln5215">  for (pri = 1; pri &gt;= 0; pri--) {</a>
<a name="ln5216">    for (p = &amp;options[0]; p-&gt;fullname; p++) {</a>
<a name="ln5217">      if (!(p-&gt;flags &amp; P_NO_MKRC)</a>
<a name="ln5218">          &amp;&amp; ((pri == 1) == ((p-&gt;flags &amp; P_PRI_MKRC) != 0))) {</a>
<a name="ln5219">        // skip global option when only doing locals</a>
<a name="ln5220">        if (p-&gt;indir == PV_NONE &amp;&amp; !(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln5221">          continue;</a>
<a name="ln5222">        }</a>
<a name="ln5223"> </a>
<a name="ln5224">        /* Do not store options like 'bufhidden' and 'syntax' in a vimrc</a>
<a name="ln5225">         * file, they are always buffer-specific. */</a>
<a name="ln5226">        if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; (p-&gt;flags &amp; P_NOGLOB)) {</a>
<a name="ln5227">          continue;</a>
<a name="ln5228">        }</a>
<a name="ln5229"> </a>
<a name="ln5230">        varp = get_varp_scope(p, opt_flags);</a>
<a name="ln5231">        // Hidden options are never written.</a>
<a name="ln5232">        if (!varp) {</a>
<a name="ln5233">          continue;</a>
<a name="ln5234">        }</a>
<a name="ln5235">        // Global values are only written when not at the default value.</a>
<a name="ln5236">        if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; optval_default(p, varp)) {</a>
<a name="ln5237">          continue;</a>
<a name="ln5238">        }</a>
<a name="ln5239"> </a>
<a name="ln5240">        if ((opt_flags &amp; OPT_SKIPRTP)</a>
<a name="ln5241">            &amp;&amp; (p-&gt;var == (char_u *)&amp;p_rtp || p-&gt;var == (char_u *)&amp;p_pp)) {</a>
<a name="ln5242">          continue;</a>
<a name="ln5243">        }</a>
<a name="ln5244"> </a>
<a name="ln5245">        round = 2;</a>
<a name="ln5246">        if (p-&gt;indir != PV_NONE) {</a>
<a name="ln5247">          if (p-&gt;var == VAR_WIN) {</a>
<a name="ln5248">            // skip window-local option when only doing globals</a>
<a name="ln5249">            if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln5250">              continue;</a>
<a name="ln5251">            }</a>
<a name="ln5252">            // When fresh value of window-local option is not at the</a>
<a name="ln5253">            // default, need to write it too.</a>
<a name="ln5254">            if (!(opt_flags &amp; OPT_GLOBAL) &amp;&amp; !local_only) {</a>
<a name="ln5255">              varp_fresh = get_varp_scope(p, OPT_GLOBAL);</a>
<a name="ln5256">              if (!optval_default(p, varp_fresh)) {</a>
<a name="ln5257">                round = 1;</a>
<a name="ln5258">                varp_local = varp;</a>
<a name="ln5259">                varp = varp_fresh;</a>
<a name="ln5260">              }</a>
<a name="ln5261">            }</a>
<a name="ln5262">          }</a>
<a name="ln5263">        }</a>
<a name="ln5264"> </a>
<a name="ln5265">        /* Round 1: fresh value for window-local options.</a>
<a name="ln5266">         * Round 2: other values */</a>
<a name="ln5267">        for (; round &lt;= 2; varp = varp_local, round++) {</a>
<a name="ln5268">          if (round == 1 || (opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln5269">            cmd = &quot;set&quot;;</a>
<a name="ln5270">          } else {</a>
<a name="ln5271">            cmd = &quot;setlocal&quot;;</a>
<a name="ln5272">          }</a>
<a name="ln5273"> </a>
<a name="ln5274">          if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln5275">            if (put_setbool(fd, cmd, p-&gt;fullname, *(int *)varp) == FAIL) {</a>
<a name="ln5276">              return FAIL;</a>
<a name="ln5277">            }</a>
<a name="ln5278">          } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln5279">            if (put_setnum(fd, cmd, p-&gt;fullname, (long *)varp) == FAIL) {</a>
<a name="ln5280">              return FAIL;</a>
<a name="ln5281">            }</a>
<a name="ln5282">          } else {    // P_STRING</a>
<a name="ln5283">            int do_endif = false;</a>
<a name="ln5284"> </a>
<a name="ln5285">            // Don't set 'syntax' and 'filetype' again if the value is</a>
<a name="ln5286">            // already right, avoids reloading the syntax file.</a>
<a name="ln5287">            if (p-&gt;indir == PV_SYN || p-&gt;indir == PV_FT) {</a>
<a name="ln5288">              if (fprintf(fd, &quot;if &amp;%s != '%s'&quot;, p-&gt;fullname,</a>
<a name="ln5289">                          *(char_u **)(varp)) &lt; 0</a>
<a name="ln5290">                  || put_eol(fd) &lt; 0) {</a>
<a name="ln5291">                return FAIL;</a>
<a name="ln5292">              }</a>
<a name="ln5293">              do_endif = true;</a>
<a name="ln5294">            }</a>
<a name="ln5295">            if (put_setstring(fd, cmd, p-&gt;fullname, (char_u **)varp,</a>
<a name="ln5296">                              p-&gt;flags) == FAIL) {</a>
<a name="ln5297">              return FAIL;</a>
<a name="ln5298">            }</a>
<a name="ln5299">            if (do_endif) {</a>
<a name="ln5300">              if (put_line(fd, &quot;endif&quot;) == FAIL) {</a>
<a name="ln5301">                return FAIL;</a>
<a name="ln5302">              }</a>
<a name="ln5303">            }</a>
<a name="ln5304">          }</a>
<a name="ln5305">        }</a>
<a name="ln5306">      }</a>
<a name="ln5307">    }</a>
<a name="ln5308">  }</a>
<a name="ln5309">  return OK;</a>
<a name="ln5310">}</a>
<a name="ln5311"> </a>
<a name="ln5312">/// Generate set commands for the local fold options only.  Used when</a>
<a name="ln5313">/// 'sessionoptions' or 'viewoptions' contains &quot;folds&quot; but not &quot;options&quot;.</a>
<a name="ln5314">int makefoldset(FILE *fd)</a>
<a name="ln5315">{</a>
<a name="ln5316">  if (put_setstring(fd, &quot;setlocal&quot;, &quot;fdm&quot;, &amp;curwin-&gt;w_p_fdm, 0) == FAIL</a>
<a name="ln5317">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fde&quot;, &amp;curwin-&gt;w_p_fde, 0)</a>
<a name="ln5318">      == FAIL</a>
<a name="ln5319">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fmr&quot;, &amp;curwin-&gt;w_p_fmr, 0)</a>
<a name="ln5320">      == FAIL</a>
<a name="ln5321">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fdi&quot;, &amp;curwin-&gt;w_p_fdi, 0)</a>
<a name="ln5322">      == FAIL</a>
<a name="ln5323">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fdl&quot;, &amp;curwin-&gt;w_p_fdl) == FAIL</a>
<a name="ln5324">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fml&quot;, &amp;curwin-&gt;w_p_fml) == FAIL</a>
<a name="ln5325">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fdn&quot;, &amp;curwin-&gt;w_p_fdn) == FAIL</a>
<a name="ln5326">      || put_setbool(fd, &quot;setlocal&quot;, &quot;fen&quot;, curwin-&gt;w_p_fen) == FAIL</a>
<a name="ln5327">      ) {</a>
<a name="ln5328">    return FAIL;</a>
<a name="ln5329">  }</a>
<a name="ln5330"> </a>
<a name="ln5331">  return OK;</a>
<a name="ln5332">}</a>
<a name="ln5333"> </a>
<a name="ln5334">static int put_setstring(FILE *fd, char *cmd, char *name,</a>
<a name="ln5335">                         char_u **valuep, uint64_t flags)</a>
<a name="ln5336">{</a>
<a name="ln5337">  char_u      *s;</a>
<a name="ln5338">  char_u      *buf = NULL;</a>
<a name="ln5339">  char_u      *part = NULL;</a>
<a name="ln5340">  char_u      *p;</a>
<a name="ln5341"> </a>
<a name="ln5342">  if (fprintf(fd, &quot;%s %s=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln5343">    return FAIL;</a>
<a name="ln5344">  }</a>
<a name="ln5345">  if (*valuep != NULL) {</a>
<a name="ln5346">    /* Output 'pastetoggle' as key names.  For other</a>
<a name="ln5347">     * options some characters have to be escaped with</a>
<a name="ln5348">     * CTRL-V or backslash */</a>
<a name="ln5349">    if (valuep == &amp;p_pt) {</a>
<a name="ln5350">      s = *valuep;</a>
<a name="ln5351">      while (*s != NUL) {</a>
<a name="ln5352">        if (put_escstr(fd, (char_u *)str2special((const char **)&amp;s, false,</a>
<a name="ln5353">                                                 false), 2)</a>
<a name="ln5354">            == FAIL) {</a>
<a name="ln5355">          return FAIL;</a>
<a name="ln5356">        }</a>
<a name="ln5357">      }</a>
<a name="ln5358">    } else if ((flags &amp; P_EXPAND) != 0) {</a>
<a name="ln5359">      size_t size = (size_t)STRLEN(*valuep) + 1;</a>
<a name="ln5360"> </a>
<a name="ln5361">      // replace home directory in the whole option value into &quot;buf&quot;</a>
<a name="ln5362">      buf = xmalloc(size);</a>
<a name="ln5363">      home_replace(NULL, *valuep, buf, size, false);</a>
<a name="ln5364"> </a>
<a name="ln5365">      // If the option value is longer than MAXPATHL, we need to append</a>
<a name="ln5366">      // earch comma separated part of the option sperately, so that it</a>
<a name="ln5367">      // can be expanded when read back.</a>
<a name="ln5368">      if (size &gt;= MAXPATHL &amp;&amp; (flags &amp; P_COMMA) != 0</a>
<a name="ln5369">          &amp;&amp; vim_strchr(*valuep, ',') != NULL) {</a>
<a name="ln5370">        part = xmalloc(size);</a>
<a name="ln5371"> </a>
<a name="ln5372">        // write line break to clear the option, e.g. ':set rtp='</a>
<a name="ln5373">        if (put_eol(fd) == FAIL) {</a>
<a name="ln5374">          goto fail;</a>
<a name="ln5375">        }</a>
<a name="ln5376">        p = buf;</a>
<a name="ln5377">        while (*p != NUL) {</a>
<a name="ln5378">            // for each comma separated option part, append value to</a>
<a name="ln5379">            // the option, :set rtp+=value</a>
<a name="ln5380">            if (fprintf(fd, &quot;%s %s+=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln5381">              goto fail;</a>
<a name="ln5382">            }</a>
<a name="ln5383">            (void)copy_option_part(&amp;p, part, size, &quot;,&quot;);</a>
<a name="ln5384">            if (put_escstr(fd, part, 2) == FAIL || put_eol(fd) == FAIL) {</a>
<a name="ln5385">              goto fail;</a>
<a name="ln5386">            }</a>
<a name="ln5387">        }</a>
<a name="ln5388">        xfree(buf);</a>
<a name="ln5389">        xfree(part);</a>
<a name="ln5390">        return OK;</a>
<a name="ln5391">      }</a>
<a name="ln5392">      if (put_escstr(fd, buf, 2) == FAIL) {</a>
<a name="ln5393">        xfree(buf);</a>
<a name="ln5394">        return FAIL;</a>
<a name="ln5395">      }</a>
<a name="ln5396">      xfree(buf);</a>
<a name="ln5397">    } else if (put_escstr(fd, *valuep, 2) == FAIL) {</a>
<a name="ln5398">      return FAIL;</a>
<a name="ln5399">    }</a>
<a name="ln5400">  }</a>
<a name="ln5401">  if (put_eol(fd) &lt; 0) {</a>
<a name="ln5402">    return FAIL;</a>
<a name="ln5403">  }</a>
<a name="ln5404">  return OK;</a>
<a name="ln5405">fail:</a>
<a name="ln5406">  xfree(buf);</a>
<a name="ln5407">  xfree(part);</a>
<a name="ln5408">  return FAIL;</a>
<a name="ln5409">}</a>
<a name="ln5410"> </a>
<a name="ln5411">static int put_setnum(FILE *fd, char *cmd, char *name, long *valuep)</a>
<a name="ln5412">{</a>
<a name="ln5413">  long wc;</a>
<a name="ln5414"> </a>
<a name="ln5415">  if (fprintf(fd, &quot;%s %s=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln5416">    return FAIL;</a>
<a name="ln5417">  }</a>
<a name="ln5418">  if (wc_use_keyname((char_u *)valuep, &amp;wc)) {</a>
<a name="ln5419">    // print 'wildchar' and 'wildcharm' as a key name</a>
<a name="ln5420">    if (fputs((char *)get_special_key_name((int)wc, 0), fd) &lt; 0) {</a>
<a name="ln5421">      return FAIL;</a>
<a name="ln5422">    }</a>
<a name="ln5423">  } else if (fprintf(fd, &quot;%&quot; PRId64, (int64_t)(*valuep)) &lt; 0) {</a>
<a name="ln5424">    return FAIL;</a>
<a name="ln5425">  }</a>
<a name="ln5426">  if (put_eol(fd) &lt; 0) {</a>
<a name="ln5427">    return FAIL;</a>
<a name="ln5428">  }</a>
<a name="ln5429">  return OK;</a>
<a name="ln5430">}</a>
<a name="ln5431"> </a>
<a name="ln5432">static int put_setbool(FILE *fd, char *cmd, char *name, int value)</a>
<a name="ln5433">{</a>
<a name="ln5434">  if (value &lt; 0) {      // global/local option using global value</a>
<a name="ln5435">    return OK;</a>
<a name="ln5436">  }</a>
<a name="ln5437">  if (fprintf(fd, &quot;%s %s%s&quot;, cmd, value ? &quot;&quot; : &quot;no&quot;, name) &lt; 0</a>
<a name="ln5438">      || put_eol(fd) &lt; 0) {</a>
<a name="ln5439">    return FAIL;</a>
<a name="ln5440">  }</a>
<a name="ln5441">  return OK;</a>
<a name="ln5442">}</a>
<a name="ln5443"> </a>
<a name="ln5444">/// Compute columns for ruler and shown command. 'sc_col' is also used to</a>
<a name="ln5445">/// decide what the maximum length of a message on the status line can be.</a>
<a name="ln5446">/// If there is a status line for the last window, 'sc_col' is independent</a>
<a name="ln5447">/// of 'ru_col'.</a>
<a name="ln5448"> </a>
<a name="ln5449">#define COL_RULER 17        // columns needed by standard ruler</a>
<a name="ln5450"> </a>
<a name="ln5451">void comp_col(void)</a>
<a name="ln5452">{</a>
<a name="ln5453">  int last_has_status = (p_ls == 2 || (p_ls == 1 &amp;&amp; !ONE_WINDOW));</a>
<a name="ln5454"> </a>
<a name="ln5455">  sc_col = 0;</a>
<a name="ln5456">  ru_col = 0;</a>
<a name="ln5457">  if (p_ru) {</a>
<a name="ln5458">    ru_col = (ru_wid ? ru_wid : COL_RULER) + 1;</a>
<a name="ln5459">    // no last status line, adjust sc_col</a>
<a name="ln5460">    if (!last_has_status) {</a>
<a name="ln5461">      sc_col = ru_col;</a>
<a name="ln5462">    }</a>
<a name="ln5463">  }</a>
<a name="ln5464">  if (p_sc) {</a>
<a name="ln5465">    sc_col += SHOWCMD_COLS;</a>
<a name="ln5466">    if (!p_ru || last_has_status) {         // no need for separating space</a>
<a name="ln5467">      sc_col++;</a>
<a name="ln5468">    }</a>
<a name="ln5469">  }</a>
<a name="ln5470">  assert(sc_col &gt;= 0</a>
<a name="ln5471">         &amp;&amp; INT_MIN + sc_col &lt;= Columns</a>
<a name="ln5472">         &amp;&amp; Columns - sc_col &lt;= INT_MAX);</a>
<a name="ln5473">  sc_col = (int)(Columns - sc_col);</a>
<a name="ln5474">  assert(ru_col &gt;= 0</a>
<a name="ln5475">         &amp;&amp; INT_MIN + ru_col &lt;= Columns</a>
<a name="ln5476">         &amp;&amp; Columns - ru_col &lt;= INT_MAX);</a>
<a name="ln5477">  ru_col = (int)(Columns - ru_col);</a>
<a name="ln5478">  if (sc_col &lt;= 0) {            // screen too narrow, will become a mess</a>
<a name="ln5479">    sc_col = 1;</a>
<a name="ln5480">  }</a>
<a name="ln5481">  if (ru_col &lt;= 0) {</a>
<a name="ln5482">    ru_col = 1;</a>
<a name="ln5483">  }</a>
<a name="ln5484">  set_vim_var_nr(VV_ECHOSPACE, sc_col - 1);</a>
<a name="ln5485">}</a>
<a name="ln5486"> </a>
<a name="ln5487">// Unset local option value, similar to &quot;:set opt&lt;&quot;.</a>
<a name="ln5488">void unset_global_local_option(char *name, void *from)</a>
<a name="ln5489">{</a>
<a name="ln5490">  vimoption_T *p;</a>
<a name="ln5491">  buf_T *buf = (buf_T *)from;</a>
<a name="ln5492"> </a>
<a name="ln5493">  int opt_idx = findoption(name);</a>
<a name="ln5494">  if (opt_idx &lt; 0) {</a>
<a name="ln5495">    EMSG2(_(&quot;E355: Unknown option: %s&quot;), name);</a>
<a name="ln5496">    return;</a>
<a name="ln5497">  }</a>
<a name="ln5498">  p = &amp;(options[opt_idx]);</a>
<a name="ln5499"> </a>
<a name="ln5500">  switch ((int)p-&gt;indir)</a>
<a name="ln5501">  {</a>
<a name="ln5502">    // global option with local value: use local value if it's been set</a>
<a name="ln5503">    case PV_EP:</a>
<a name="ln5504">      clear_string_option(&amp;buf-&gt;b_p_ep);</a>
<a name="ln5505">      break;</a>
<a name="ln5506">    case PV_KP:</a>
<a name="ln5507">      clear_string_option(&amp;buf-&gt;b_p_kp);</a>
<a name="ln5508">      break;</a>
<a name="ln5509">    case PV_PATH:</a>
<a name="ln5510">      clear_string_option(&amp;buf-&gt;b_p_path);</a>
<a name="ln5511">      break;</a>
<a name="ln5512">    case PV_AR:</a>
<a name="ln5513">      buf-&gt;b_p_ar = -1;</a>
<a name="ln5514">      break;</a>
<a name="ln5515">    case PV_BKC:</a>
<a name="ln5516">      clear_string_option(&amp;buf-&gt;b_p_bkc);</a>
<a name="ln5517">      buf-&gt;b_bkc_flags = 0;</a>
<a name="ln5518">      break;</a>
<a name="ln5519">    case PV_TAGS:</a>
<a name="ln5520">      clear_string_option(&amp;buf-&gt;b_p_tags);</a>
<a name="ln5521">      break;</a>
<a name="ln5522">    case PV_TC:</a>
<a name="ln5523">      clear_string_option(&amp;buf-&gt;b_p_tc);</a>
<a name="ln5524">      buf-&gt;b_tc_flags = 0;</a>
<a name="ln5525">      break;</a>
<a name="ln5526">    case PV_SISO:</a>
<a name="ln5527">      curwin-&gt;w_p_siso = -1;</a>
<a name="ln5528">      break;</a>
<a name="ln5529">    case PV_SO:</a>
<a name="ln5530">      curwin-&gt;w_p_so = -1;</a>
<a name="ln5531">      break;</a>
<a name="ln5532">    case PV_DEF:</a>
<a name="ln5533">      clear_string_option(&amp;buf-&gt;b_p_def);</a>
<a name="ln5534">      break;</a>
<a name="ln5535">    case PV_INC:</a>
<a name="ln5536">      clear_string_option(&amp;buf-&gt;b_p_inc);</a>
<a name="ln5537">      break;</a>
<a name="ln5538">    case PV_DICT:</a>
<a name="ln5539">      clear_string_option(&amp;buf-&gt;b_p_dict);</a>
<a name="ln5540">      break;</a>
<a name="ln5541">    case PV_TSR:</a>
<a name="ln5542">      clear_string_option(&amp;buf-&gt;b_p_tsr);</a>
<a name="ln5543">      break;</a>
<a name="ln5544">    case PV_FP:</a>
<a name="ln5545">      clear_string_option(&amp;buf-&gt;b_p_fp);</a>
<a name="ln5546">      break;</a>
<a name="ln5547">    case PV_EFM:</a>
<a name="ln5548">      clear_string_option(&amp;buf-&gt;b_p_efm);</a>
<a name="ln5549">      break;</a>
<a name="ln5550">    case PV_GP:</a>
<a name="ln5551">      clear_string_option(&amp;buf-&gt;b_p_gp);</a>
<a name="ln5552">      break;</a>
<a name="ln5553">    case PV_MP:</a>
<a name="ln5554">      clear_string_option(&amp;buf-&gt;b_p_mp);</a>
<a name="ln5555">      break;</a>
<a name="ln5556">    case PV_STL:</a>
<a name="ln5557">      clear_string_option(&amp;((win_T *)from)-&gt;w_p_stl);</a>
<a name="ln5558">      break;</a>
<a name="ln5559">    case PV_UL:</a>
<a name="ln5560">      buf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln5561">      break;</a>
<a name="ln5562">    case PV_LW:</a>
<a name="ln5563">      clear_string_option(&amp;buf-&gt;b_p_lw);</a>
<a name="ln5564">      break;</a>
<a name="ln5565">    case PV_MENC:</a>
<a name="ln5566">      clear_string_option(&amp;buf-&gt;b_p_menc);</a>
<a name="ln5567">      break;</a>
<a name="ln5568">    case PV_LCS:</a>
<a name="ln5569">      clear_string_option(&amp;((win_T *)from)-&gt;w_p_lcs);</a>
<a name="ln5570">      set_chars_option((win_T *)from, &amp;((win_T *)from)-&gt;w_p_lcs, true);</a>
<a name="ln5571">      redraw_later((win_T *)from, NOT_VALID);</a>
<a name="ln5572">      break;</a>
<a name="ln5573">    case PV_FCS:</a>
<a name="ln5574">      clear_string_option(&amp;((win_T *)from)-&gt;w_p_fcs);</a>
<a name="ln5575">      set_chars_option((win_T *)from, &amp;((win_T *)from)-&gt;w_p_fcs, true);</a>
<a name="ln5576">      redraw_later((win_T *)from, NOT_VALID);</a>
<a name="ln5577">      break;</a>
<a name="ln5578">  }</a>
<a name="ln5579">}</a>
<a name="ln5580"> </a>
<a name="ln5581">/// Get pointer to option variable, depending on local or global scope.</a>
<a name="ln5582">static char_u *get_varp_scope(vimoption_T *p, int opt_flags)</a>
<a name="ln5583">{</a>
<a name="ln5584">  if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; p-&gt;indir != PV_NONE) {</a>
<a name="ln5585">    if (p-&gt;var == VAR_WIN) {</a>
<a name="ln5586">      return (char_u *)GLOBAL_WO(get_varp(p));</a>
<a name="ln5587">    }</a>
<a name="ln5588">    return p-&gt;var;</a>
<a name="ln5589">  }</a>
<a name="ln5590">  if ((opt_flags &amp; OPT_LOCAL) &amp;&amp; ((int)p-&gt;indir &amp; PV_BOTH)) {</a>
<a name="ln5591">    switch ((int)p-&gt;indir) {</a>
<a name="ln5592">    case PV_FP:   return (char_u *)&amp;(curbuf-&gt;b_p_fp);</a>
<a name="ln5593">    case PV_EFM:  return (char_u *)&amp;(curbuf-&gt;b_p_efm);</a>
<a name="ln5594">    case PV_GP:   return (char_u *)&amp;(curbuf-&gt;b_p_gp);</a>
<a name="ln5595">    case PV_MP:   return (char_u *)&amp;(curbuf-&gt;b_p_mp);</a>
<a name="ln5596">    case PV_EP:   return (char_u *)&amp;(curbuf-&gt;b_p_ep);</a>
<a name="ln5597">    case PV_KP:   return (char_u *)&amp;(curbuf-&gt;b_p_kp);</a>
<a name="ln5598">    case PV_PATH: return (char_u *)&amp;(curbuf-&gt;b_p_path);</a>
<a name="ln5599">    case PV_AR:   return (char_u *)&amp;(curbuf-&gt;b_p_ar);</a>
<a name="ln5600">    case PV_TAGS: return (char_u *)&amp;(curbuf-&gt;b_p_tags);</a>
<a name="ln5601">    case PV_TC:   return (char_u *)&amp;(curbuf-&gt;b_p_tc);</a>
<a name="ln5602">    case PV_SISO: return (char_u *)&amp;(curwin-&gt;w_p_siso);</a>
<a name="ln5603">    case PV_SO:   return (char_u *)&amp;(curwin-&gt;w_p_so);</a>
<a name="ln5604">    case PV_DEF:  return (char_u *)&amp;(curbuf-&gt;b_p_def);</a>
<a name="ln5605">    case PV_INC:  return (char_u *)&amp;(curbuf-&gt;b_p_inc);</a>
<a name="ln5606">    case PV_DICT: return (char_u *)&amp;(curbuf-&gt;b_p_dict);</a>
<a name="ln5607">    case PV_TSR:  return (char_u *)&amp;(curbuf-&gt;b_p_tsr);</a>
<a name="ln5608">    case PV_TFU:  return (char_u *)&amp;(curbuf-&gt;b_p_tfu);</a>
<a name="ln5609">    case PV_STL:  return (char_u *)&amp;(curwin-&gt;w_p_stl);</a>
<a name="ln5610">    case PV_UL:   return (char_u *)&amp;(curbuf-&gt;b_p_ul);</a>
<a name="ln5611">    case PV_LW:   return (char_u *)&amp;(curbuf-&gt;b_p_lw);</a>
<a name="ln5612">    case PV_BKC:  return (char_u *)&amp;(curbuf-&gt;b_p_bkc);</a>
<a name="ln5613">    case PV_MENC: return (char_u *)&amp;(curbuf-&gt;b_p_menc);</a>
<a name="ln5614">    case PV_FCS:  return (char_u *)&amp;(curwin-&gt;w_p_fcs);</a>
<a name="ln5615">    case PV_LCS:  return (char_u *)&amp;(curwin-&gt;w_p_lcs);</a>
<a name="ln5616">    }</a>
<a name="ln5617">    return NULL;     // &quot;cannot happen&quot;</a>
<a name="ln5618">  }</a>
<a name="ln5619">  return get_varp(p);</a>
<a name="ln5620">}</a>
<a name="ln5621"> </a>
<a name="ln5622">/// Get pointer to option variable.</a>
<a name="ln5623">static char_u *get_varp(vimoption_T *p)</a>
<a name="ln5624">{</a>
<a name="ln5625">  // hidden option, always return NULL</a>
<a name="ln5626">  if (p-&gt;var == NULL) {</a>
<a name="ln5627">    return NULL;</a>
<a name="ln5628">  }</a>
<a name="ln5629"> </a>
<a name="ln5630">  switch ((int)p-&gt;indir) {</a>
<a name="ln5631">  case PV_NONE:   return p-&gt;var;</a>
<a name="ln5632"> </a>
<a name="ln5633">  // global option with local value: use local value if it's been set</a>
<a name="ln5634">  case PV_EP:     return *curbuf-&gt;b_p_ep != NUL</a>
<a name="ln5635">           ? (char_u *)&amp;curbuf-&gt;b_p_ep : p-&gt;var;</a>
<a name="ln5636">  case PV_KP:     return *curbuf-&gt;b_p_kp != NUL</a>
<a name="ln5637">           ? (char_u *)&amp;curbuf-&gt;b_p_kp : p-&gt;var;</a>
<a name="ln5638">  case PV_PATH:   return *curbuf-&gt;b_p_path != NUL</a>
<a name="ln5639">           ? (char_u *)&amp;(curbuf-&gt;b_p_path) : p-&gt;var;</a>
<a name="ln5640">  case PV_AR:     return curbuf-&gt;b_p_ar &gt;= 0</a>
<a name="ln5641">           ? (char_u *)&amp;(curbuf-&gt;b_p_ar) : p-&gt;var;</a>
<a name="ln5642">  case PV_TAGS:   return *curbuf-&gt;b_p_tags != NUL</a>
<a name="ln5643">           ? (char_u *)&amp;(curbuf-&gt;b_p_tags) : p-&gt;var;</a>
<a name="ln5644">  case PV_TC:     return *curbuf-&gt;b_p_tc != NUL</a>
<a name="ln5645">           ? (char_u *)&amp;(curbuf-&gt;b_p_tc) : p-&gt;var;</a>
<a name="ln5646">  case PV_SISO:   return curwin-&gt;w_p_siso &gt;= 0</a>
<a name="ln5647">           ? (char_u *)&amp;(curwin-&gt;w_p_siso) : p-&gt;var;</a>
<a name="ln5648">  case PV_SO:     return curwin-&gt;w_p_so &gt;= 0</a>
<a name="ln5649">           ? (char_u *)&amp;(curwin-&gt;w_p_so) : p-&gt;var;</a>
<a name="ln5650">  case PV_BKC:    return *curbuf-&gt;b_p_bkc != NUL</a>
<a name="ln5651">           ? (char_u *)&amp;(curbuf-&gt;b_p_bkc) : p-&gt;var;</a>
<a name="ln5652">  case PV_DEF:    return *curbuf-&gt;b_p_def != NUL</a>
<a name="ln5653">           ? (char_u *)&amp;(curbuf-&gt;b_p_def) : p-&gt;var;</a>
<a name="ln5654">  case PV_INC:    return *curbuf-&gt;b_p_inc != NUL</a>
<a name="ln5655">           ? (char_u *)&amp;(curbuf-&gt;b_p_inc) : p-&gt;var;</a>
<a name="ln5656">  case PV_DICT:   return *curbuf-&gt;b_p_dict != NUL</a>
<a name="ln5657">           ? (char_u *)&amp;(curbuf-&gt;b_p_dict) : p-&gt;var;</a>
<a name="ln5658">  case PV_TSR:    return *curbuf-&gt;b_p_tsr != NUL</a>
<a name="ln5659">           ? (char_u *)&amp;(curbuf-&gt;b_p_tsr) : p-&gt;var;</a>
<a name="ln5660">  case PV_FP: return *curbuf-&gt;b_p_fp != NUL</a>
<a name="ln5661">           ? (char_u *)&amp;(curbuf-&gt;b_p_fp) : p-&gt;var;</a>
<a name="ln5662">  case PV_EFM:    return *curbuf-&gt;b_p_efm != NUL</a>
<a name="ln5663">           ? (char_u *)&amp;(curbuf-&gt;b_p_efm) : p-&gt;var;</a>
<a name="ln5664">  case PV_GP:     return *curbuf-&gt;b_p_gp != NUL</a>
<a name="ln5665">           ? (char_u *)&amp;(curbuf-&gt;b_p_gp) : p-&gt;var;</a>
<a name="ln5666">  case PV_MP:     return *curbuf-&gt;b_p_mp != NUL</a>
<a name="ln5667">           ? (char_u *)&amp;(curbuf-&gt;b_p_mp) : p-&gt;var;</a>
<a name="ln5668">  case PV_STL:    return *curwin-&gt;w_p_stl != NUL</a>
<a name="ln5669">           ? (char_u *)&amp;(curwin-&gt;w_p_stl) : p-&gt;var;</a>
<a name="ln5670">  case PV_UL:     return curbuf-&gt;b_p_ul != NO_LOCAL_UNDOLEVEL</a>
<a name="ln5671">           ? (char_u *)&amp;(curbuf-&gt;b_p_ul) : p-&gt;var;</a>
<a name="ln5672">  case PV_LW:   return *curbuf-&gt;b_p_lw != NUL</a>
<a name="ln5673">           ? (char_u *)&amp;(curbuf-&gt;b_p_lw) : p-&gt;var;</a>
<a name="ln5674">  case PV_MENC: return *curbuf-&gt;b_p_menc != NUL</a>
<a name="ln5675">           ? (char_u *)&amp;(curbuf-&gt;b_p_menc) : p-&gt;var;</a>
<a name="ln5676">  case PV_FCS:    return *curwin-&gt;w_p_fcs != NUL</a>
<a name="ln5677">           ? (char_u *)&amp;(curwin-&gt;w_p_fcs) : p-&gt;var;</a>
<a name="ln5678">  case PV_LCS:    return *curwin-&gt;w_p_lcs != NUL</a>
<a name="ln5679">           ? (char_u *)&amp;(curwin-&gt;w_p_lcs) : p-&gt;var;</a>
<a name="ln5680"> </a>
<a name="ln5681">  case PV_ARAB:   return (char_u *)&amp;(curwin-&gt;w_p_arab);</a>
<a name="ln5682">  case PV_LIST:   return (char_u *)&amp;(curwin-&gt;w_p_list);</a>
<a name="ln5683">  case PV_SPELL:  return (char_u *)&amp;(curwin-&gt;w_p_spell);</a>
<a name="ln5684">  case PV_CUC:    return (char_u *)&amp;(curwin-&gt;w_p_cuc);</a>
<a name="ln5685">  case PV_CUL:    return (char_u *)&amp;(curwin-&gt;w_p_cul);</a>
<a name="ln5686">  case PV_CC:     return (char_u *)&amp;(curwin-&gt;w_p_cc);</a>
<a name="ln5687">  case PV_DIFF:   return (char_u *)&amp;(curwin-&gt;w_p_diff);</a>
<a name="ln5688">  case PV_FDC:    return (char_u *)&amp;(curwin-&gt;w_p_fdc);</a>
<a name="ln5689">  case PV_FEN:    return (char_u *)&amp;(curwin-&gt;w_p_fen);</a>
<a name="ln5690">  case PV_FDI:    return (char_u *)&amp;(curwin-&gt;w_p_fdi);</a>
<a name="ln5691">  case PV_FDL:    return (char_u *)&amp;(curwin-&gt;w_p_fdl);</a>
<a name="ln5692">  case PV_FDM:    return (char_u *)&amp;(curwin-&gt;w_p_fdm);</a>
<a name="ln5693">  case PV_FML:    return (char_u *)&amp;(curwin-&gt;w_p_fml);</a>
<a name="ln5694">  case PV_FDN:    return (char_u *)&amp;(curwin-&gt;w_p_fdn);</a>
<a name="ln5695">  case PV_FDE:    return (char_u *)&amp;(curwin-&gt;w_p_fde);</a>
<a name="ln5696">  case PV_FDT:    return (char_u *)&amp;(curwin-&gt;w_p_fdt);</a>
<a name="ln5697">  case PV_FMR:    return (char_u *)&amp;(curwin-&gt;w_p_fmr);</a>
<a name="ln5698">  case PV_NU:     return (char_u *)&amp;(curwin-&gt;w_p_nu);</a>
<a name="ln5699">  case PV_RNU:    return (char_u *)&amp;(curwin-&gt;w_p_rnu);</a>
<a name="ln5700">  case PV_NUW:    return (char_u *)&amp;(curwin-&gt;w_p_nuw);</a>
<a name="ln5701">  case PV_WFH:    return (char_u *)&amp;(curwin-&gt;w_p_wfh);</a>
<a name="ln5702">  case PV_WFW:    return (char_u *)&amp;(curwin-&gt;w_p_wfw);</a>
<a name="ln5703">  case PV_PVW:    return (char_u *)&amp;(curwin-&gt;w_p_pvw);</a>
<a name="ln5704">  case PV_RL:     return (char_u *)&amp;(curwin-&gt;w_p_rl);</a>
<a name="ln5705">  case PV_RLC:    return (char_u *)&amp;(curwin-&gt;w_p_rlc);</a>
<a name="ln5706">  case PV_SCROLL: return (char_u *)&amp;(curwin-&gt;w_p_scr);</a>
<a name="ln5707">  case PV_WRAP:   return (char_u *)&amp;(curwin-&gt;w_p_wrap);</a>
<a name="ln5708">  case PV_LBR:    return (char_u *)&amp;(curwin-&gt;w_p_lbr);</a>
<a name="ln5709">  case PV_BRI:    return (char_u *)&amp;(curwin-&gt;w_p_bri);</a>
<a name="ln5710">  case PV_BRIOPT: return (char_u *)&amp;(curwin-&gt;w_p_briopt);</a>
<a name="ln5711">  case PV_SCBIND: return (char_u *)&amp;(curwin-&gt;w_p_scb);</a>
<a name="ln5712">  case PV_CRBIND: return (char_u *)&amp;(curwin-&gt;w_p_crb);</a>
<a name="ln5713">  case PV_COCU:    return (char_u *)&amp;(curwin-&gt;w_p_cocu);</a>
<a name="ln5714">  case PV_COLE:    return (char_u *)&amp;(curwin-&gt;w_p_cole);</a>
<a name="ln5715"> </a>
<a name="ln5716">  case PV_AI:     return (char_u *)&amp;(curbuf-&gt;b_p_ai);</a>
<a name="ln5717">  case PV_BIN:    return (char_u *)&amp;(curbuf-&gt;b_p_bin);</a>
<a name="ln5718">  case PV_BOMB:   return (char_u *)&amp;(curbuf-&gt;b_p_bomb);</a>
<a name="ln5719">  case PV_BH:     return (char_u *)&amp;(curbuf-&gt;b_p_bh);</a>
<a name="ln5720">  case PV_BT:     return (char_u *)&amp;(curbuf-&gt;b_p_bt);</a>
<a name="ln5721">  case PV_BL:     return (char_u *)&amp;(curbuf-&gt;b_p_bl);</a>
<a name="ln5722">  case PV_CHANNEL:return (char_u *)&amp;(curbuf-&gt;b_p_channel);</a>
<a name="ln5723">  case PV_CI:     return (char_u *)&amp;(curbuf-&gt;b_p_ci);</a>
<a name="ln5724">  case PV_CIN:    return (char_u *)&amp;(curbuf-&gt;b_p_cin);</a>
<a name="ln5725">  case PV_CINK:   return (char_u *)&amp;(curbuf-&gt;b_p_cink);</a>
<a name="ln5726">  case PV_CINO:   return (char_u *)&amp;(curbuf-&gt;b_p_cino);</a>
<a name="ln5727">  case PV_CINW:   return (char_u *)&amp;(curbuf-&gt;b_p_cinw);</a>
<a name="ln5728">  case PV_COM:    return (char_u *)&amp;(curbuf-&gt;b_p_com);</a>
<a name="ln5729">  case PV_CMS:    return (char_u *)&amp;(curbuf-&gt;b_p_cms);</a>
<a name="ln5730">  case PV_CPT:    return (char_u *)&amp;(curbuf-&gt;b_p_cpt);</a>
<a name="ln5731"># ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5732">  case PV_CSL:    return (char_u *)&amp;(curbuf-&gt;b_p_csl);</a>
<a name="ln5733"># endif</a>
<a name="ln5734">  case PV_CFU:    return (char_u *)&amp;(curbuf-&gt;b_p_cfu);</a>
<a name="ln5735">  case PV_OFU:    return (char_u *)&amp;(curbuf-&gt;b_p_ofu);</a>
<a name="ln5736">  case PV_EOL:    return (char_u *)&amp;(curbuf-&gt;b_p_eol);</a>
<a name="ln5737">  case PV_FIXEOL: return (char_u *)&amp;(curbuf-&gt;b_p_fixeol);</a>
<a name="ln5738">  case PV_ET:     return (char_u *)&amp;(curbuf-&gt;b_p_et);</a>
<a name="ln5739">  case PV_FENC:   return (char_u *)&amp;(curbuf-&gt;b_p_fenc);</a>
<a name="ln5740">  case PV_FF:     return (char_u *)&amp;(curbuf-&gt;b_p_ff);</a>
<a name="ln5741">  case PV_FT:     return (char_u *)&amp;(curbuf-&gt;b_p_ft);</a>
<a name="ln5742">  case PV_FO:     return (char_u *)&amp;(curbuf-&gt;b_p_fo);</a>
<a name="ln5743">  case PV_FLP:    return (char_u *)&amp;(curbuf-&gt;b_p_flp);</a>
<a name="ln5744">  case PV_IMI:    return (char_u *)&amp;(curbuf-&gt;b_p_iminsert);</a>
<a name="ln5745">  case PV_IMS:    return (char_u *)&amp;(curbuf-&gt;b_p_imsearch);</a>
<a name="ln5746">  case PV_INF:    return (char_u *)&amp;(curbuf-&gt;b_p_inf);</a>
<a name="ln5747">  case PV_ISK:    return (char_u *)&amp;(curbuf-&gt;b_p_isk);</a>
<a name="ln5748">  case PV_INEX:   return (char_u *)&amp;(curbuf-&gt;b_p_inex);</a>
<a name="ln5749">  case PV_INDE:   return (char_u *)&amp;(curbuf-&gt;b_p_inde);</a>
<a name="ln5750">  case PV_INDK:   return (char_u *)&amp;(curbuf-&gt;b_p_indk);</a>
<a name="ln5751">  case PV_FEX:    return (char_u *)&amp;(curbuf-&gt;b_p_fex);</a>
<a name="ln5752">  case PV_LISP:   return (char_u *)&amp;(curbuf-&gt;b_p_lisp);</a>
<a name="ln5753">  case PV_ML:     return (char_u *)&amp;(curbuf-&gt;b_p_ml);</a>
<a name="ln5754">  case PV_MPS:    return (char_u *)&amp;(curbuf-&gt;b_p_mps);</a>
<a name="ln5755">  case PV_MA:     return (char_u *)&amp;(curbuf-&gt;b_p_ma);</a>
<a name="ln5756">  case PV_MOD:    return (char_u *)&amp;(curbuf-&gt;b_changed);</a>
<a name="ln5757">  case PV_NF:     return (char_u *)&amp;(curbuf-&gt;b_p_nf);</a>
<a name="ln5758">  case PV_PI:     return (char_u *)&amp;(curbuf-&gt;b_p_pi);</a>
<a name="ln5759">  case PV_QE:     return (char_u *)&amp;(curbuf-&gt;b_p_qe);</a>
<a name="ln5760">  case PV_RO:     return (char_u *)&amp;(curbuf-&gt;b_p_ro);</a>
<a name="ln5761">  case PV_SCBK:   return (char_u *)&amp;(curbuf-&gt;b_p_scbk);</a>
<a name="ln5762">  case PV_SI:     return (char_u *)&amp;(curbuf-&gt;b_p_si);</a>
<a name="ln5763">  case PV_STS:    return (char_u *)&amp;(curbuf-&gt;b_p_sts);</a>
<a name="ln5764">  case PV_SUA:    return (char_u *)&amp;(curbuf-&gt;b_p_sua);</a>
<a name="ln5765">  case PV_SWF:    return (char_u *)&amp;(curbuf-&gt;b_p_swf);</a>
<a name="ln5766">  case PV_SMC:    return (char_u *)&amp;(curbuf-&gt;b_p_smc);</a>
<a name="ln5767">  case PV_SYN:    return (char_u *)&amp;(curbuf-&gt;b_p_syn);</a>
<a name="ln5768">  case PV_SPC:    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spc);</a>
<a name="ln5769">  case PV_SPF:    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln5770">  case PV_SPL:    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spl);</a>
<a name="ln5771">  case PV_SPO:    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spo);</a>
<a name="ln5772">  case PV_SW:     return (char_u *)&amp;(curbuf-&gt;b_p_sw);</a>
<a name="ln5773">  case PV_TFU:    return (char_u *)&amp;(curbuf-&gt;b_p_tfu);</a>
<a name="ln5774">  case PV_TS:     return (char_u *)&amp;(curbuf-&gt;b_p_ts);</a>
<a name="ln5775">  case PV_TW:     return (char_u *)&amp;(curbuf-&gt;b_p_tw);</a>
<a name="ln5776">  case PV_UDF:    return (char_u *)&amp;(curbuf-&gt;b_p_udf);</a>
<a name="ln5777">  case PV_WM:     return (char_u *)&amp;(curbuf-&gt;b_p_wm);</a>
<a name="ln5778">  case PV_VSTS:   return (char_u *)&amp;(curbuf-&gt;b_p_vsts);</a>
<a name="ln5779">  case PV_VTS:    return (char_u *)&amp;(curbuf-&gt;b_p_vts);</a>
<a name="ln5780">  case PV_KMAP:   return (char_u *)&amp;(curbuf-&gt;b_p_keymap);</a>
<a name="ln5781">  case PV_SCL:    return (char_u *)&amp;(curwin-&gt;w_p_scl);</a>
<a name="ln5782">  case PV_WINHL:  return (char_u *)&amp;(curwin-&gt;w_p_winhl);</a>
<a name="ln5783">  case PV_WINBL:  return (char_u *)&amp;(curwin-&gt;w_p_winbl);</a>
<a name="ln5784">  default:        IEMSG(_(&quot;E356: get_varp ERROR&quot;));</a>
<a name="ln5785">  }</a>
<a name="ln5786">  // always return a valid pointer to avoid a crash!</a>
<a name="ln5787">  return (char_u *)&amp;(curbuf-&gt;b_p_wm);</a>
<a name="ln5788">}</a>
<a name="ln5789"> </a>
<a name="ln5790">/// Get the value of 'equalprg', either the buffer-local one or the global one.</a>
<a name="ln5791">char_u *get_equalprg(void)</a>
<a name="ln5792">{</a>
<a name="ln5793">  if (*curbuf-&gt;b_p_ep == NUL) {</a>
<a name="ln5794">    return p_ep;</a>
<a name="ln5795">  }</a>
<a name="ln5796">  return curbuf-&gt;b_p_ep;</a>
<a name="ln5797">}</a>
<a name="ln5798"> </a>
<a name="ln5799">/// Copy options from one window to another.</a>
<a name="ln5800">/// Used when splitting a window.</a>
<a name="ln5801">void win_copy_options(win_T *wp_from, win_T *wp_to)</a>
<a name="ln5802">{</a>
<a name="ln5803">  copy_winopt(&amp;wp_from-&gt;w_onebuf_opt, &amp;wp_to-&gt;w_onebuf_opt);</a>
<a name="ln5804">  copy_winopt(&amp;wp_from-&gt;w_allbuf_opt, &amp;wp_to-&gt;w_allbuf_opt);</a>
<a name="ln5805">}</a>
<a name="ln5806"> </a>
<a name="ln5807">/// Copy the options from one winopt_T to another.</a>
<a name="ln5808">/// Doesn't free the old option values in &quot;to&quot;, use clear_winopt() for that.</a>
<a name="ln5809">/// The 'scroll' option is not copied, because it depends on the window height.</a>
<a name="ln5810">/// The 'previewwindow' option is reset, there can be only one preview window.</a>
<a name="ln5811">void copy_winopt(winopt_T *from, winopt_T *to)</a>
<a name="ln5812">{</a>
<a name="ln5813">  to-&gt;wo_arab = from-&gt;wo_arab;</a>
<a name="ln5814">  to-&gt;wo_list = from-&gt;wo_list;</a>
<a name="ln5815">  to-&gt;wo_nu = from-&gt;wo_nu;</a>
<a name="ln5816">  to-&gt;wo_rnu = from-&gt;wo_rnu;</a>
<a name="ln5817">  to-&gt;wo_nuw = from-&gt;wo_nuw;</a>
<a name="ln5818">  to-&gt;wo_rl  = from-&gt;wo_rl;</a>
<a name="ln5819">  to-&gt;wo_rlc = vim_strsave(from-&gt;wo_rlc);</a>
<a name="ln5820">  to-&gt;wo_stl = vim_strsave(from-&gt;wo_stl);</a>
<a name="ln5821">  to-&gt;wo_wrap = from-&gt;wo_wrap;</a>
<a name="ln5822">  to-&gt;wo_wrap_save = from-&gt;wo_wrap_save;</a>
<a name="ln5823">  to-&gt;wo_lbr = from-&gt;wo_lbr;</a>
<a name="ln5824">  to-&gt;wo_bri = from-&gt;wo_bri;</a>
<a name="ln5825">  to-&gt;wo_briopt = vim_strsave(from-&gt;wo_briopt);</a>
<a name="ln5826">  to-&gt;wo_scb = from-&gt;wo_scb;</a>
<a name="ln5827">  to-&gt;wo_scb_save = from-&gt;wo_scb_save;</a>
<a name="ln5828">  to-&gt;wo_crb = from-&gt;wo_crb;</a>
<a name="ln5829">  to-&gt;wo_crb_save = from-&gt;wo_crb_save;</a>
<a name="ln5830">  to-&gt;wo_spell = from-&gt;wo_spell;</a>
<a name="ln5831">  to-&gt;wo_cuc = from-&gt;wo_cuc;</a>
<a name="ln5832">  to-&gt;wo_cul = from-&gt;wo_cul;</a>
<a name="ln5833">  to-&gt;wo_cc = vim_strsave(from-&gt;wo_cc);</a>
<a name="ln5834">  to-&gt;wo_diff = from-&gt;wo_diff;</a>
<a name="ln5835">  to-&gt;wo_diff_saved = from-&gt;wo_diff_saved;</a>
<a name="ln5836">  to-&gt;wo_cocu = vim_strsave(from-&gt;wo_cocu);</a>
<a name="ln5837">  to-&gt;wo_cole = from-&gt;wo_cole;</a>
<a name="ln5838">  to-&gt;wo_fdc = vim_strsave(from-&gt;wo_fdc);</a>
<a name="ln5839">  to-&gt;wo_fdc_save = from-&gt;wo_diff_saved</a>
<a name="ln5840">                    ? vim_strsave(from-&gt;wo_fdc_save) : empty_option;</a>
<a name="ln5841">  to-&gt;wo_fen = from-&gt;wo_fen;</a>
<a name="ln5842">  to-&gt;wo_fen_save = from-&gt;wo_fen_save;</a>
<a name="ln5843">  to-&gt;wo_fdi = vim_strsave(from-&gt;wo_fdi);</a>
<a name="ln5844">  to-&gt;wo_fml = from-&gt;wo_fml;</a>
<a name="ln5845">  to-&gt;wo_fdl = from-&gt;wo_fdl;</a>
<a name="ln5846">  to-&gt;wo_fdl_save = from-&gt;wo_fdl_save;</a>
<a name="ln5847">  to-&gt;wo_fdm = vim_strsave(from-&gt;wo_fdm);</a>
<a name="ln5848">  to-&gt;wo_fdm_save = from-&gt;wo_diff_saved</a>
<a name="ln5849">                    ? vim_strsave(from-&gt;wo_fdm_save) : empty_option;</a>
<a name="ln5850">  to-&gt;wo_fdn = from-&gt;wo_fdn;</a>
<a name="ln5851">  to-&gt;wo_fde = vim_strsave(from-&gt;wo_fde);</a>
<a name="ln5852">  to-&gt;wo_fdt = vim_strsave(from-&gt;wo_fdt);</a>
<a name="ln5853">  to-&gt;wo_fmr = vim_strsave(from-&gt;wo_fmr);</a>
<a name="ln5854">  to-&gt;wo_scl = vim_strsave(from-&gt;wo_scl);</a>
<a name="ln5855">  to-&gt;wo_winhl = vim_strsave(from-&gt;wo_winhl);</a>
<a name="ln5856">  to-&gt;wo_fcs = vim_strsave(from-&gt;wo_fcs);</a>
<a name="ln5857">  to-&gt;wo_lcs = vim_strsave(from-&gt;wo_lcs);</a>
<a name="ln5858">  to-&gt;wo_winbl = from-&gt;wo_winbl;</a>
<a name="ln5859">  check_winopt(to);             // don't want NULL pointers</a>
<a name="ln5860">}</a>
<a name="ln5861"> </a>
<a name="ln5862">/// Check string options in a window for a NULL value.</a>
<a name="ln5863">void check_win_options(win_T *win)</a>
<a name="ln5864">{</a>
<a name="ln5865">  check_winopt(&amp;win-&gt;w_onebuf_opt);</a>
<a name="ln5866">  check_winopt(&amp;win-&gt;w_allbuf_opt);</a>
<a name="ln5867">}</a>
<a name="ln5868"> </a>
<a name="ln5869">/// Check for NULL pointers in a winopt_T and replace them with empty_option.</a>
<a name="ln5870">static void check_winopt(winopt_T *wop)</a>
<a name="ln5871">{</a>
<a name="ln5872">  check_string_option(&amp;wop-&gt;wo_fdc);</a>
<a name="ln5873">  check_string_option(&amp;wop-&gt;wo_fdc_save);</a>
<a name="ln5874">  check_string_option(&amp;wop-&gt;wo_fdi);</a>
<a name="ln5875">  check_string_option(&amp;wop-&gt;wo_fdm);</a>
<a name="ln5876">  check_string_option(&amp;wop-&gt;wo_fdm_save);</a>
<a name="ln5877">  check_string_option(&amp;wop-&gt;wo_fde);</a>
<a name="ln5878">  check_string_option(&amp;wop-&gt;wo_fdt);</a>
<a name="ln5879">  check_string_option(&amp;wop-&gt;wo_fmr);</a>
<a name="ln5880">  check_string_option(&amp;wop-&gt;wo_scl);</a>
<a name="ln5881">  check_string_option(&amp;wop-&gt;wo_rlc);</a>
<a name="ln5882">  check_string_option(&amp;wop-&gt;wo_stl);</a>
<a name="ln5883">  check_string_option(&amp;wop-&gt;wo_cc);</a>
<a name="ln5884">  check_string_option(&amp;wop-&gt;wo_cocu);</a>
<a name="ln5885">  check_string_option(&amp;wop-&gt;wo_briopt);</a>
<a name="ln5886">  check_string_option(&amp;wop-&gt;wo_winhl);</a>
<a name="ln5887">  check_string_option(&amp;wop-&gt;wo_fcs);</a>
<a name="ln5888">  check_string_option(&amp;wop-&gt;wo_lcs);</a>
<a name="ln5889">}</a>
<a name="ln5890"> </a>
<a name="ln5891">/// Free the allocated memory inside a winopt_T.</a>
<a name="ln5892">void clear_winopt(winopt_T *wop)</a>
<a name="ln5893">{</a>
<a name="ln5894">  clear_string_option(&amp;wop-&gt;wo_fdc);</a>
<a name="ln5895">  clear_string_option(&amp;wop-&gt;wo_fdc_save);</a>
<a name="ln5896">  clear_string_option(&amp;wop-&gt;wo_fdi);</a>
<a name="ln5897">  clear_string_option(&amp;wop-&gt;wo_fdm);</a>
<a name="ln5898">  clear_string_option(&amp;wop-&gt;wo_fdm_save);</a>
<a name="ln5899">  clear_string_option(&amp;wop-&gt;wo_fde);</a>
<a name="ln5900">  clear_string_option(&amp;wop-&gt;wo_fdt);</a>
<a name="ln5901">  clear_string_option(&amp;wop-&gt;wo_fmr);</a>
<a name="ln5902">  clear_string_option(&amp;wop-&gt;wo_scl);</a>
<a name="ln5903">  clear_string_option(&amp;wop-&gt;wo_rlc);</a>
<a name="ln5904">  clear_string_option(&amp;wop-&gt;wo_stl);</a>
<a name="ln5905">  clear_string_option(&amp;wop-&gt;wo_cc);</a>
<a name="ln5906">  clear_string_option(&amp;wop-&gt;wo_cocu);</a>
<a name="ln5907">  clear_string_option(&amp;wop-&gt;wo_briopt);</a>
<a name="ln5908">  clear_string_option(&amp;wop-&gt;wo_winhl);</a>
<a name="ln5909">  clear_string_option(&amp;wop-&gt;wo_fcs);</a>
<a name="ln5910">  clear_string_option(&amp;wop-&gt;wo_lcs);</a>
<a name="ln5911">}</a>
<a name="ln5912"> </a>
<a name="ln5913">void didset_window_options(win_T *wp)</a>
<a name="ln5914">{</a>
<a name="ln5915">  check_colorcolumn(wp);</a>
<a name="ln5916">  briopt_check(wp);</a>
<a name="ln5917">  set_chars_option(wp, &amp;wp-&gt;w_p_fcs, true);</a>
<a name="ln5918">  set_chars_option(wp, &amp;wp-&gt;w_p_lcs, true);</a>
<a name="ln5919">  parse_winhl_opt(wp);  // sets w_hl_needs_update also for w_p_winbl</a>
<a name="ln5920">  check_blending(wp);</a>
<a name="ln5921">  wp-&gt;w_grid_alloc.blending = wp-&gt;w_p_winbl &gt; 0;</a>
<a name="ln5922">}</a>
<a name="ln5923"> </a>
<a name="ln5924"> </a>
<a name="ln5925">/// Copy global option values to local options for one buffer.</a>
<a name="ln5926">/// Used when creating a new buffer and sometimes when entering a buffer.</a>
<a name="ln5927">/// flags:</a>
<a name="ln5928">/// BCO_ENTER    We will enter the buf buffer.</a>
<a name="ln5929">/// BCO_ALWAYS   Always copy the options, but only set b_p_initialized when</a>
<a name="ln5930">///      appropriate.</a>
<a name="ln5931">/// BCO_NOHELP   Don't copy the values to a help buffer.</a>
<a name="ln5932">void buf_copy_options(buf_T *buf, int flags)</a>
<a name="ln5933">{</a>
<a name="ln5934">  int should_copy = true;</a>
<a name="ln5935">  char_u      *save_p_isk = NULL;           // init for GCC</a>
<a name="ln5936">  int dont_do_help;</a>
<a name="ln5937">  int did_isk = false;</a>
<a name="ln5938"> </a>
<a name="ln5939">  /*</a>
<a name="ln5940">   * Skip this when the option defaults have not been set yet.  Happens when</a>
<a name="ln5941">   * main() allocates the first buffer.</a>
<a name="ln5942">   */</a>
<a name="ln5943">  if (p_cpo != NULL) {</a>
<a name="ln5944">    //</a>
<a name="ln5945">    // Always copy when entering and 'cpo' contains 'S'.</a>
<a name="ln5946">    // Don't copy when already initialized.</a>
<a name="ln5947">    // Don't copy when 'cpo' contains 's' and not entering.</a>
<a name="ln5948">    //    'S'      BCO_ENTER  initialized  's'  should_copy</a>
<a name="ln5949">    //    yes        yes          X         X      true</a>
<a name="ln5950">    //    yes        no          yes        X      false</a>
<a name="ln5951">    //    no          X          yes        X      false</a>
<a name="ln5952">    //     X         no          no        yes     false</a>
<a name="ln5953">    //     X         no          no        no      true</a>
<a name="ln5954">    //    no         yes         no         X      true</a>
<a name="ln5955">    ///</a>
<a name="ln5956">    if ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags &amp; BCO_ENTER))</a>
<a name="ln5957">        &amp;&amp; (buf-&gt;b_p_initialized</a>
<a name="ln5958">            || (!(flags &amp; BCO_ENTER)</a>
<a name="ln5959">                &amp;&amp; vim_strchr(p_cpo, CPO_BUFOPT) != NULL))) {</a>
<a name="ln5960">      should_copy = false;</a>
<a name="ln5961">    }</a>
<a name="ln5962"> </a>
<a name="ln5963">    if (should_copy || (flags &amp; BCO_ALWAYS)) {</a>
<a name="ln5964">      /* Don't copy the options specific to a help buffer when</a>
<a name="ln5965">      * BCO_NOHELP is given or the options were initialized already</a>
<a name="ln5966">      * (jumping back to a help file with CTRL-T or CTRL-O) */</a>
<a name="ln5967">      dont_do_help = ((flags &amp; BCO_NOHELP) &amp;&amp; buf-&gt;b_help)</a>
<a name="ln5968">                     || buf-&gt;b_p_initialized;</a>
<a name="ln5969">      if (dont_do_help) {               // don't free b_p_isk</a>
<a name="ln5970">        save_p_isk = buf-&gt;b_p_isk;</a>
<a name="ln5971">        buf-&gt;b_p_isk = NULL;</a>
<a name="ln5972">      }</a>
<a name="ln5973">      // Always free the allocated strings.  If not already initialized,</a>
<a name="ln5974">      // reset 'readonly' and copy 'fileformat'.</a>
<a name="ln5975">      if (!buf-&gt;b_p_initialized) {</a>
<a name="ln5976">        free_buf_options(buf, true);</a>
<a name="ln5977">        buf-&gt;b_p_ro = false;                    // don't copy readonly</a>
<a name="ln5978">        buf-&gt;b_p_fenc = vim_strsave(p_fenc);</a>
<a name="ln5979">        switch (*p_ffs) {</a>
<a name="ln5980">          case 'm': {</a>
<a name="ln5981">            buf-&gt;b_p_ff = vim_strsave((char_u *)FF_MAC);</a>
<a name="ln5982">            break;</a>
<a name="ln5983">          }</a>
<a name="ln5984">          case 'd': {</a>
<a name="ln5985">            buf-&gt;b_p_ff = vim_strsave((char_u *)FF_DOS);</a>
<a name="ln5986">            break;</a>
<a name="ln5987">          }</a>
<a name="ln5988">          case 'u': {</a>
<a name="ln5989">            buf-&gt;b_p_ff = vim_strsave((char_u *)FF_UNIX);</a>
<a name="ln5990">            break;</a>
<a name="ln5991">          }</a>
<a name="ln5992">          default: {</a>
<a name="ln5993">            buf-&gt;b_p_ff = vim_strsave(p_ff);</a>
<a name="ln5994">            break;</a>
<a name="ln5995">          }</a>
<a name="ln5996">        }</a>
<a name="ln5997">        buf-&gt;b_p_bh = empty_option;</a>
<a name="ln5998">        buf-&gt;b_p_bt = empty_option;</a>
<a name="ln5999">      } else {</a>
<a name="ln6000">        free_buf_options(buf, false);</a>
<a name="ln6001">      }</a>
<a name="ln6002"> </a>
<a name="ln6003">      buf-&gt;b_p_ai = p_ai;</a>
<a name="ln6004">      buf-&gt;b_p_ai_nopaste = p_ai_nopaste;</a>
<a name="ln6005">      buf-&gt;b_p_sw = p_sw;</a>
<a name="ln6006">      buf-&gt;b_p_scbk = p_scbk;</a>
<a name="ln6007">      buf-&gt;b_p_tw = p_tw;</a>
<a name="ln6008">      buf-&gt;b_p_tw_nopaste = p_tw_nopaste;</a>
<a name="ln6009">      buf-&gt;b_p_tw_nobin = p_tw_nobin;</a>
<a name="ln6010">      buf-&gt;b_p_wm = p_wm;</a>
<a name="ln6011">      buf-&gt;b_p_wm_nopaste = p_wm_nopaste;</a>
<a name="ln6012">      buf-&gt;b_p_wm_nobin = p_wm_nobin;</a>
<a name="ln6013">      buf-&gt;b_p_bin = p_bin;</a>
<a name="ln6014">      buf-&gt;b_p_bomb = p_bomb;</a>
<a name="ln6015">      buf-&gt;b_p_et = p_et;</a>
<a name="ln6016">      buf-&gt;b_p_fixeol = p_fixeol;</a>
<a name="ln6017">      buf-&gt;b_p_et_nobin = p_et_nobin;</a>
<a name="ln6018">      buf-&gt;b_p_et_nopaste = p_et_nopaste;</a>
<a name="ln6019">      buf-&gt;b_p_ml = p_ml;</a>
<a name="ln6020">      buf-&gt;b_p_ml_nobin = p_ml_nobin;</a>
<a name="ln6021">      buf-&gt;b_p_inf = p_inf;</a>
<a name="ln6022">      buf-&gt;b_p_swf = cmdmod.noswapfile ? false : p_swf;</a>
<a name="ln6023">      buf-&gt;b_p_cpt = vim_strsave(p_cpt);</a>
<a name="ln6024"># ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln6025">      buf-&gt;b_p_csl = vim_strsave(p_csl);</a>
<a name="ln6026"># endif</a>
<a name="ln6027">      buf-&gt;b_p_cfu = vim_strsave(p_cfu);</a>
<a name="ln6028">      buf-&gt;b_p_ofu = vim_strsave(p_ofu);</a>
<a name="ln6029">      buf-&gt;b_p_tfu = vim_strsave(p_tfu);</a>
<a name="ln6030">      buf-&gt;b_p_sts = p_sts;</a>
<a name="ln6031">      buf-&gt;b_p_sts_nopaste = p_sts_nopaste;</a>
<a name="ln6032">      buf-&gt;b_p_vsts = vim_strsave(p_vsts);</a>
<a name="ln6033">      if (p_vsts &amp;&amp; p_vsts != empty_option) {</a>
<a name="ln6034">        tabstop_set(p_vsts, &amp;buf-&gt;b_p_vsts_array);</a>
<a name="ln6035">      } else {</a>
<a name="ln6036">        buf-&gt;b_p_vsts_array = 0;</a>
<a name="ln6037">      }</a>
<a name="ln6038">      buf-&gt;b_p_vsts_nopaste = p_vsts_nopaste</a>
<a name="ln6039">                                ? vim_strsave(p_vsts_nopaste)</a>
<a name="ln6040">                                : NULL;</a>
<a name="ln6041">      buf-&gt;b_p_com = vim_strsave(p_com);</a>
<a name="ln6042">      buf-&gt;b_p_cms = vim_strsave(p_cms);</a>
<a name="ln6043">      buf-&gt;b_p_fo = vim_strsave(p_fo);</a>
<a name="ln6044">      buf-&gt;b_p_flp = vim_strsave(p_flp);</a>
<a name="ln6045">      buf-&gt;b_p_nf = vim_strsave(p_nf);</a>
<a name="ln6046">      buf-&gt;b_p_mps = vim_strsave(p_mps);</a>
<a name="ln6047">      buf-&gt;b_p_si = p_si;</a>
<a name="ln6048">      buf-&gt;b_p_channel = 0;</a>
<a name="ln6049">      buf-&gt;b_p_ci = p_ci;</a>
<a name="ln6050">      buf-&gt;b_p_cin = p_cin;</a>
<a name="ln6051">      buf-&gt;b_p_cink = vim_strsave(p_cink);</a>
<a name="ln6052">      buf-&gt;b_p_cino = vim_strsave(p_cino);</a>
<a name="ln6053">      // Don't copy 'filetype', it must be detected</a>
<a name="ln6054">      buf-&gt;b_p_ft = empty_option;</a>
<a name="ln6055">      buf-&gt;b_p_pi = p_pi;</a>
<a name="ln6056">      buf-&gt;b_p_cinw = vim_strsave(p_cinw);</a>
<a name="ln6057">      buf-&gt;b_p_lisp = p_lisp;</a>
<a name="ln6058">      // Don't copy 'syntax', it must be set</a>
<a name="ln6059">      buf-&gt;b_p_syn = empty_option;</a>
<a name="ln6060">      buf-&gt;b_p_smc = p_smc;</a>
<a name="ln6061">      buf-&gt;b_s.b_syn_isk = empty_option;</a>
<a name="ln6062">      buf-&gt;b_s.b_p_spc = vim_strsave(p_spc);</a>
<a name="ln6063">      (void)compile_cap_prog(&amp;buf-&gt;b_s);</a>
<a name="ln6064">      buf-&gt;b_s.b_p_spf = vim_strsave(p_spf);</a>
<a name="ln6065">      buf-&gt;b_s.b_p_spl = vim_strsave(p_spl);</a>
<a name="ln6066">      buf-&gt;b_s.b_p_spo = vim_strsave(p_spo);</a>
<a name="ln6067">      buf-&gt;b_p_inde = vim_strsave(p_inde);</a>
<a name="ln6068">      buf-&gt;b_p_indk = vim_strsave(p_indk);</a>
<a name="ln6069">      buf-&gt;b_p_fp = empty_option;</a>
<a name="ln6070">      buf-&gt;b_p_fex = vim_strsave(p_fex);</a>
<a name="ln6071">      buf-&gt;b_p_sua = vim_strsave(p_sua);</a>
<a name="ln6072">      buf-&gt;b_p_keymap = vim_strsave(p_keymap);</a>
<a name="ln6073">      buf-&gt;b_kmap_state |= KEYMAP_INIT;</a>
<a name="ln6074">      /* This isn't really an option, but copying the langmap and IME</a>
<a name="ln6075">      * state from the current buffer is better than resetting it. */</a>
<a name="ln6076">      buf-&gt;b_p_iminsert = p_iminsert;</a>
<a name="ln6077">      buf-&gt;b_p_imsearch = p_imsearch;</a>
<a name="ln6078"> </a>
<a name="ln6079">      /* options that are normally global but also have a local value</a>
<a name="ln6080">       * are not copied, start using the global value */</a>
<a name="ln6081">      buf-&gt;b_p_ar = -1;</a>
<a name="ln6082">      buf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln6083">      buf-&gt;b_p_bkc = empty_option;</a>
<a name="ln6084">      buf-&gt;b_bkc_flags = 0;</a>
<a name="ln6085">      buf-&gt;b_p_gp = empty_option;</a>
<a name="ln6086">      buf-&gt;b_p_mp = empty_option;</a>
<a name="ln6087">      buf-&gt;b_p_efm = empty_option;</a>
<a name="ln6088">      buf-&gt;b_p_ep = empty_option;</a>
<a name="ln6089">      buf-&gt;b_p_kp = empty_option;</a>
<a name="ln6090">      buf-&gt;b_p_path = empty_option;</a>
<a name="ln6091">      buf-&gt;b_p_tags = empty_option;</a>
<a name="ln6092">      buf-&gt;b_p_tc = empty_option;</a>
<a name="ln6093">      buf-&gt;b_tc_flags = 0;</a>
<a name="ln6094">      buf-&gt;b_p_def = empty_option;</a>
<a name="ln6095">      buf-&gt;b_p_inc = empty_option;</a>
<a name="ln6096">      buf-&gt;b_p_inex = vim_strsave(p_inex);</a>
<a name="ln6097">      buf-&gt;b_p_dict = empty_option;</a>
<a name="ln6098">      buf-&gt;b_p_tsr = empty_option;</a>
<a name="ln6099">      buf-&gt;b_p_qe = vim_strsave(p_qe);</a>
<a name="ln6100">      buf-&gt;b_p_udf = p_udf;</a>
<a name="ln6101">      buf-&gt;b_p_lw = empty_option;</a>
<a name="ln6102">      buf-&gt;b_p_menc = empty_option;</a>
<a name="ln6103"> </a>
<a name="ln6104">      /*</a>
<a name="ln6105">       * Don't copy the options set by ex_help(), use the saved values,</a>
<a name="ln6106">       * when going from a help buffer to a non-help buffer.</a>
<a name="ln6107">       * Don't touch these at all when BCO_NOHELP is used and going from</a>
<a name="ln6108">       * or to a help buffer.</a>
<a name="ln6109">       */</a>
<a name="ln6110">      if (dont_do_help) {</a>
<a name="ln6111">        buf-&gt;b_p_isk = save_p_isk;</a>
<a name="ln6112">        if (p_vts &amp;&amp; p_vts != empty_option &amp;&amp; !buf-&gt;b_p_vts_array) {</a>
<a name="ln6113">          tabstop_set(p_vts, &amp;buf-&gt;b_p_vts_array);</a>
<a name="ln6114">        } else {</a>
<a name="ln6115">          buf-&gt;b_p_vts_array = NULL;</a>
<a name="ln6116">        }</a>
<a name="ln6117">      } else {</a>
<a name="ln6118">        buf-&gt;b_p_isk = vim_strsave(p_isk);</a>
<a name="ln6119">        did_isk = true;</a>
<a name="ln6120">        buf-&gt;b_p_ts = p_ts;</a>
<a name="ln6121">        buf-&gt;b_p_vts = vim_strsave(p_vts);</a>
<a name="ln6122">        if (p_vts &amp;&amp; p_vts != empty_option &amp;&amp; !buf-&gt;b_p_vts_array) {</a>
<a name="ln6123">          tabstop_set(p_vts, &amp;buf-&gt;b_p_vts_array);</a>
<a name="ln6124">        } else {</a>
<a name="ln6125">          buf-&gt;b_p_vts_array = NULL;</a>
<a name="ln6126">        }</a>
<a name="ln6127">        buf-&gt;b_help = false;</a>
<a name="ln6128">        if (buf-&gt;b_p_bt[0] == 'h') {</a>
<a name="ln6129">          clear_string_option(&amp;buf-&gt;b_p_bt);</a>
<a name="ln6130">        }</a>
<a name="ln6131">        buf-&gt;b_p_ma = p_ma;</a>
<a name="ln6132">      }</a>
<a name="ln6133">    }</a>
<a name="ln6134"> </a>
<a name="ln6135">    /*</a>
<a name="ln6136">     * When the options should be copied (ignoring BCO_ALWAYS), set the</a>
<a name="ln6137">     * flag that indicates that the options have been initialized.</a>
<a name="ln6138">     */</a>
<a name="ln6139">    if (should_copy) {</a>
<a name="ln6140">      buf-&gt;b_p_initialized = true;</a>
<a name="ln6141">    }</a>
<a name="ln6142">  }</a>
<a name="ln6143"> </a>
<a name="ln6144">  check_buf_options(buf);           // make sure we don't have NULLs</a>
<a name="ln6145">  if (did_isk) {</a>
<a name="ln6146">    (void)buf_init_chartab(buf, false);</a>
<a name="ln6147">  }</a>
<a name="ln6148">}</a>
<a name="ln6149"> </a>
<a name="ln6150">/// Reset the 'modifiable' option and its default value.</a>
<a name="ln6151">void reset_modifiable(void)</a>
<a name="ln6152">{</a>
<a name="ln6153">  int opt_idx;</a>
<a name="ln6154"> </a>
<a name="ln6155">  curbuf-&gt;b_p_ma = false;</a>
<a name="ln6156">  p_ma = false;</a>
<a name="ln6157">  opt_idx = findoption(&quot;ma&quot;);</a>
<a name="ln6158">  if (opt_idx &gt;= 0) {</a>
<a name="ln6159">    options[opt_idx].def_val[VI_DEFAULT] = false;</a>
<a name="ln6160">  }</a>
<a name="ln6161">}</a>
<a name="ln6162"> </a>
<a name="ln6163">/// Set the global value for 'iminsert' to the local value.</a>
<a name="ln6164">void set_iminsert_global(void)</a>
<a name="ln6165">{</a>
<a name="ln6166">  p_iminsert = curbuf-&gt;b_p_iminsert;</a>
<a name="ln6167">}</a>
<a name="ln6168"> </a>
<a name="ln6169">/// Set the global value for 'imsearch' to the local value.</a>
<a name="ln6170">void set_imsearch_global(void)</a>
<a name="ln6171">{</a>
<a name="ln6172">  p_imsearch = curbuf-&gt;b_p_imsearch;</a>
<a name="ln6173">}</a>
<a name="ln6174"> </a>
<a name="ln6175">static int expand_option_idx = -1;</a>
<a name="ln6176">static char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};</a>
<a name="ln6177">static int expand_option_flags = 0;</a>
<a name="ln6178"> </a>
<a name="ln6179">void</a>
<a name="ln6180">set_context_in_set_cmd(</a>
<a name="ln6181">    expand_T *xp,</a>
<a name="ln6182">    char_u *arg,</a>
<a name="ln6183">    int opt_flags                  // OPT_GLOBAL and/or OPT_LOCAL</a>
<a name="ln6184">)</a>
<a name="ln6185">{</a>
<a name="ln6186">  char_u nextchar;</a>
<a name="ln6187">  uint32_t flags = 0;           // init for GCC</a>
<a name="ln6188">  int opt_idx = 0;              // init for GCC</a>
<a name="ln6189">  char_u      *p;</a>
<a name="ln6190">  char_u      *s;</a>
<a name="ln6191">  int is_term_option = false;</a>
<a name="ln6192">  int key;</a>
<a name="ln6193"> </a>
<a name="ln6194">  expand_option_flags = opt_flags;</a>
<a name="ln6195"> </a>
<a name="ln6196">  xp-&gt;xp_context = EXPAND_SETTINGS;</a>
<a name="ln6197">  if (*arg == NUL) {</a>
<a name="ln6198">    xp-&gt;xp_pattern = arg;</a>
<a name="ln6199">    return;</a>
<a name="ln6200">  }</a>
<a name="ln6201">  p = arg + STRLEN(arg) - 1;</a>
<a name="ln6202">  if (*p == ' ' &amp;&amp; *(p - 1) != '\\') {</a>
<a name="ln6203">    xp-&gt;xp_pattern = p + 1;</a>
<a name="ln6204">    return;</a>
<a name="ln6205">  }</a>
<a name="ln6206">  while (p &gt; arg) {</a>
<a name="ln6207">    s = p;</a>
<a name="ln6208">    // count number of backslashes before ' ' or ','</a>
<a name="ln6209">    if (*p == ' ' || *p == ',') {</a>
<a name="ln6210">      while (s &gt; arg &amp;&amp; *(s - 1) == '\\') {</a>
<a name="ln6211">        s--;</a>
<a name="ln6212">      }</a>
<a name="ln6213">    }</a>
<a name="ln6214">    // break at a space with an even number of backslashes</a>
<a name="ln6215">    if (*p == ' ' &amp;&amp; ((p - s) &amp; 1) == 0) {</a>
<a name="ln6216">      p++;</a>
<a name="ln6217">      break;</a>
<a name="ln6218">    }</a>
<a name="ln6219">    p--;</a>
<a name="ln6220">  }</a>
<a name="ln6221">  if (STRNCMP(p, &quot;no&quot;, 2) == 0) {</a>
<a name="ln6222">    xp-&gt;xp_context = EXPAND_BOOL_SETTINGS;</a>
<a name="ln6223">    p += 2;</a>
<a name="ln6224">  }</a>
<a name="ln6225">  if (STRNCMP(p, &quot;inv&quot;, 3) == 0) {</a>
<a name="ln6226">    xp-&gt;xp_context = EXPAND_BOOL_SETTINGS;</a>
<a name="ln6227">    p += 3;</a>
<a name="ln6228">  }</a>
<a name="ln6229">  xp-&gt;xp_pattern = arg = p;</a>
<a name="ln6230">  if (*arg == '&lt;') {</a>
<a name="ln6231">    while (*p != '&gt;') {</a>
<a name="ln6232">      if (*p++ == NUL) {            // expand terminal option name</a>
<a name="ln6233">        return;</a>
<a name="ln6234">      }</a>
<a name="ln6235">    }</a>
<a name="ln6236">    key = get_special_key_code(arg + 1);</a>
<a name="ln6237">    if (key == 0) {                 // unknown name</a>
<a name="ln6238">      xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln6239">      return;</a>
<a name="ln6240">    }</a>
<a name="ln6241">    nextchar = *++p;</a>
<a name="ln6242">    is_term_option = true;</a>
<a name="ln6243">    expand_option_name[2] = (char_u)KEY2TERMCAP0(key);</a>
<a name="ln6244">    expand_option_name[3] = KEY2TERMCAP1(key);</a>
<a name="ln6245">  } else {</a>
<a name="ln6246">    if (p[0] == 't' &amp;&amp; p[1] == '_') {</a>
<a name="ln6247">      p += 2;</a>
<a name="ln6248">      if (*p != NUL) {</a>
<a name="ln6249">        p++;</a>
<a name="ln6250">      }</a>
<a name="ln6251">      if (*p == NUL) {</a>
<a name="ln6252">        return;                 // expand option name</a>
<a name="ln6253">      }</a>
<a name="ln6254">      nextchar = *++p;</a>
<a name="ln6255">      is_term_option = true;</a>
<a name="ln6256">      expand_option_name[2] = p[-2];</a>
<a name="ln6257">      expand_option_name[3] = p[-1];</a>
<a name="ln6258">    } else {</a>
<a name="ln6259">      // Allow * wildcard.</a>
<a name="ln6260">      while (ASCII_ISALNUM(*p) || *p == '_' || *p == '*') {</a>
<a name="ln6261">        p++;</a>
<a name="ln6262">      }</a>
<a name="ln6263">      if (*p == NUL) {</a>
<a name="ln6264">        return;</a>
<a name="ln6265">      }</a>
<a name="ln6266">      nextchar = *p;</a>
<a name="ln6267">      opt_idx = findoption_len((const char *)arg, (size_t)(p - arg));</a>
<a name="ln6268">      if (opt_idx == -1 || options[opt_idx].var == NULL) {</a>
<a name="ln6269">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln6270">        return;</a>
<a name="ln6271">      }</a>
<a name="ln6272">      flags = options[opt_idx].flags;</a>
<a name="ln6273">      if (flags &amp; P_BOOL) {</a>
<a name="ln6274">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln6275">        return;</a>
<a name="ln6276">      }</a>
<a name="ln6277">    }</a>
<a name="ln6278">  }</a>
<a name="ln6279">  // handle &quot;-=&quot; and &quot;+=&quot;</a>
<a name="ln6280">  if ((nextchar == '-' || nextchar == '+' || nextchar == '^') &amp;&amp; p[1] == '=') {</a>
<a name="ln6281">    p++;</a>
<a name="ln6282">    nextchar = '=';</a>
<a name="ln6283">  }</a>
<a name="ln6284">  if ((nextchar != '=' &amp;&amp; nextchar != ':')</a>
<a name="ln6285">      || xp-&gt;xp_context == EXPAND_BOOL_SETTINGS) {</a>
<a name="ln6286">    xp-&gt;xp_context = EXPAND_UNSUCCESSFUL;</a>
<a name="ln6287">    return;</a>
<a name="ln6288">  }</a>
<a name="ln6289">  if (p[1] == NUL) {</a>
<a name="ln6290">    xp-&gt;xp_context = EXPAND_OLD_SETTING;</a>
<a name="ln6291">    if (is_term_option) {</a>
<a name="ln6292">      expand_option_idx = -1;</a>
<a name="ln6293">    } else {</a>
<a name="ln6294">      expand_option_idx = opt_idx;</a>
<a name="ln6295">    }</a>
<a name="ln6296">    xp-&gt;xp_pattern = p + 1;</a>
<a name="ln6297">    return;</a>
<a name="ln6298">  }</a>
<a name="ln6299">  xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln6300">  if (is_term_option || (flags &amp; P_NUM)) {</a>
<a name="ln6301">    return;</a>
<a name="ln6302">  }</a>
<a name="ln6303"> </a>
<a name="ln6304">  xp-&gt;xp_pattern = p + 1;</a>
<a name="ln6305"> </a>
<a name="ln6306">  if (flags &amp; P_EXPAND) {</a>
<a name="ln6307">    p = options[opt_idx].var;</a>
<a name="ln6308">    if (p == (char_u *)&amp;p_bdir</a>
<a name="ln6309">        || p == (char_u *)&amp;p_dir</a>
<a name="ln6310">        || p == (char_u *)&amp;p_path</a>
<a name="ln6311">        || p == (char_u *)&amp;p_pp</a>
<a name="ln6312">        || p == (char_u *)&amp;p_rtp</a>
<a name="ln6313">        || p == (char_u *)&amp;p_cdpath</a>
<a name="ln6314">        || p == (char_u *)&amp;p_vdir</a>
<a name="ln6315">        ) {</a>
<a name="ln6316">      xp-&gt;xp_context = EXPAND_DIRECTORIES;</a>
<a name="ln6317">      if (p == (char_u *)&amp;p_path</a>
<a name="ln6318">          || p == (char_u *)&amp;p_cdpath</a>
<a name="ln6319">          )</a>
<a name="ln6320">        xp-&gt;xp_backslash = XP_BS_THREE;</a>
<a name="ln6321">      else</a>
<a name="ln6322">        xp-&gt;xp_backslash = XP_BS_ONE;</a>
<a name="ln6323">    } else if (p == (char_u *)&amp;p_ft) {</a>
<a name="ln6324">      xp-&gt;xp_context = EXPAND_FILETYPE;</a>
<a name="ln6325">    } else {</a>
<a name="ln6326">      xp-&gt;xp_context = EXPAND_FILES;</a>
<a name="ln6327">      // for 'tags' need three backslashes for a space</a>
<a name="ln6328">      if (p == (char_u *)&amp;p_tags) {</a>
<a name="ln6329">        xp-&gt;xp_backslash = XP_BS_THREE;</a>
<a name="ln6330">      } else {</a>
<a name="ln6331">        xp-&gt;xp_backslash = XP_BS_ONE;</a>
<a name="ln6332">      }</a>
<a name="ln6333">    }</a>
<a name="ln6334">  }</a>
<a name="ln6335"> </a>
<a name="ln6336">  /* For an option that is a list of file names, find the start of the</a>
<a name="ln6337">   * last file name. */</a>
<a name="ln6338">  for (p = arg + STRLEN(arg) - 1; p &gt; xp-&gt;xp_pattern; p--) {</a>
<a name="ln6339">    // count number of backslashes before ' ' or ','</a>
<a name="ln6340">    if (*p == ' ' || *p == ',') {</a>
<a name="ln6341">      s = p;</a>
<a name="ln6342">      while (s &gt; xp-&gt;xp_pattern &amp;&amp; *(s - 1) == '\\') {</a>
<a name="ln6343">        s--;</a>
<a name="ln6344">      }</a>
<a name="ln6345">      if ((*p == ' ' &amp;&amp; (xp-&gt;xp_backslash == XP_BS_THREE &amp;&amp; (p - s) &lt; 3))</a>
<a name="ln6346">          || (*p == ',' &amp;&amp; (flags &amp; P_COMMA) &amp;&amp; ((p - s) &amp; 1) == 0)) {</a>
<a name="ln6347">        xp-&gt;xp_pattern = p + 1;</a>
<a name="ln6348">        break;</a>
<a name="ln6349">      }</a>
<a name="ln6350">    }</a>
<a name="ln6351"> </a>
<a name="ln6352">    // for 'spellsuggest' start at &quot;file:&quot;</a>
<a name="ln6353">    if (options[opt_idx].var == (char_u *)&amp;p_sps</a>
<a name="ln6354">        &amp;&amp; STRNCMP(p, &quot;file:&quot;, 5) == 0) {</a>
<a name="ln6355">      xp-&gt;xp_pattern = p + 5;</a>
<a name="ln6356">      break;</a>
<a name="ln6357">    }</a>
<a name="ln6358">  }</a>
<a name="ln6359"> </a>
<a name="ln6360">  return;</a>
<a name="ln6361">}</a>
<a name="ln6362"> </a>
<a name="ln6363">int ExpandSettings(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file)</a>
<a name="ln6364">{</a>
<a name="ln6365">  int num_normal = 0;  // Nr of matching non-term-code settings</a>
<a name="ln6366">  int match;</a>
<a name="ln6367">  int count = 0;</a>
<a name="ln6368">  char_u      *str;</a>
<a name="ln6369">  int loop;</a>
<a name="ln6370">  static char *(names[]) = { &quot;all&quot; };</a>
<a name="ln6371">  int ic = regmatch-&gt;rm_ic;  // remember the ignore-case flag</a>
<a name="ln6372"> </a>
<a name="ln6373">  /* do this loop twice:</a>
<a name="ln6374">   * loop == 0: count the number of matching options</a>
<a name="ln6375">   * loop == 1: copy the matching options into allocated memory</a>
<a name="ln6376">   */</a>
<a name="ln6377">  for (loop = 0; loop &lt;= 1; loop++) {</a>
<a name="ln6378">    regmatch-&gt;rm_ic = ic;</a>
<a name="ln6379">    if (xp-&gt;xp_context != EXPAND_BOOL_SETTINGS) {</a>
<a name="ln6380">      for (match = 0; match &lt; (int)ARRAY_SIZE(names);</a>
<a name="ln6381">           match++) {</a>
<a name="ln6382">        if (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0)) {</a>
<a name="ln6383">          if (loop == 0) {</a>
<a name="ln6384">            num_normal++;</a>
<a name="ln6385">          } else {</a>
<a name="ln6386">            (*file)[count++] = vim_strsave((char_u *)names[match]);</a>
<a name="ln6387">          }</a>
<a name="ln6388">        }</a>
<a name="ln6389">      }</a>
<a name="ln6390">    }</a>
<a name="ln6391">    for (size_t opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;</a>
<a name="ln6392">         opt_idx++) {</a>
<a name="ln6393">      if (options[opt_idx].var == NULL) {</a>
<a name="ln6394">        continue;</a>
<a name="ln6395">      }</a>
<a name="ln6396">      if (xp-&gt;xp_context == EXPAND_BOOL_SETTINGS</a>
<a name="ln6397">          &amp;&amp; !(options[opt_idx].flags &amp; P_BOOL)) {</a>
<a name="ln6398">        continue;</a>
<a name="ln6399">      }</a>
<a name="ln6400">      match = false;</a>
<a name="ln6401">      if (vim_regexec(regmatch, str, (colnr_T)0)</a>
<a name="ln6402">          || (options[opt_idx].shortname != NULL</a>
<a name="ln6403">              &amp;&amp; vim_regexec(regmatch,</a>
<a name="ln6404">                             (char_u *)options[opt_idx].shortname,</a>
<a name="ln6405">                             (colnr_T)0))) {</a>
<a name="ln6406">        match = true;</a>
<a name="ln6407">      }</a>
<a name="ln6408"> </a>
<a name="ln6409">      if (match) {</a>
<a name="ln6410">        if (loop == 0) {</a>
<a name="ln6411">          num_normal++;</a>
<a name="ln6412">        } else</a>
<a name="ln6413">          (*file)[count++] = vim_strsave(str);</a>
<a name="ln6414">      }</a>
<a name="ln6415">    }</a>
<a name="ln6416"> </a>
<a name="ln6417">    if (loop == 0) {</a>
<a name="ln6418">      if (num_normal &gt; 0) {</a>
<a name="ln6419">        *num_file = num_normal;</a>
<a name="ln6420">      } else {</a>
<a name="ln6421">        return OK;</a>
<a name="ln6422">      }</a>
<a name="ln6423">      *file = (char_u **)xmalloc((size_t)(*num_file) * sizeof(char_u *));</a>
<a name="ln6424">    }</a>
<a name="ln6425">  }</a>
<a name="ln6426">  return OK;</a>
<a name="ln6427">}</a>
<a name="ln6428"> </a>
<a name="ln6429">void ExpandOldSetting(int *num_file, char_u ***file)</a>
<a name="ln6430">{</a>
<a name="ln6431">  char_u *var = NULL;</a>
<a name="ln6432"> </a>
<a name="ln6433">  *num_file = 0;</a>
<a name="ln6434">  *file = (char_u **)xmalloc(sizeof(char_u *));</a>
<a name="ln6435"> </a>
<a name="ln6436">  /*</a>
<a name="ln6437">   * For a terminal key code expand_option_idx is &lt; 0.</a>
<a name="ln6438">   */</a>
<a name="ln6439">  if (expand_option_idx &lt; 0) {</a>
<a name="ln6440">    expand_option_idx = findoption((const char *)expand_option_name);</a>
<a name="ln6441">  }</a>
<a name="ln6442"> </a>
<a name="ln6443">  if (expand_option_idx &gt;= 0) {</a>
<a name="ln6444">    // Put string of option value in NameBuff.</a>
<a name="ln6445">    option_value2string(&amp;options[expand_option_idx], expand_option_flags);</a>
<a name="ln6446">    var = NameBuff;</a>
<a name="ln6447">  } else {</a>
<a name="ln6448">    var = (char_u *)&quot;&quot;;</a>
<a name="ln6449">  }</a>
<a name="ln6450"> </a>
<a name="ln6451">  // A backslash is required before some characters.  This is the reverse of</a>
<a name="ln6452">  // what happens in do_set().</a>
<a name="ln6453">  char_u *buf = vim_strsave_escaped(var, escape_chars);</a>
<a name="ln6454"> </a>
<a name="ln6455">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln6456">  /* For MS-Windows et al. we don't double backslashes at the start and</a>
<a name="ln6457">   * before a file name character. */</a>
<a name="ln6458">  for (var = buf; *var != NUL; MB_PTR_ADV(var)) {</a>
<a name="ln6459">    if (var[0] == '\\' &amp;&amp; var[1] == '\\'</a>
<a name="ln6460">        &amp;&amp; expand_option_idx &gt;= 0</a>
<a name="ln6461">        &amp;&amp; (options[expand_option_idx].flags &amp; P_EXPAND)</a>
<a name="ln6462">        &amp;&amp; vim_isfilec(var[2])</a>
<a name="ln6463">        &amp;&amp; (var[2] != '\\' || (var == buf &amp;&amp; var[4] != '\\'))) {</a>
<a name="ln6464">      STRMOVE(var, var + 1);</a>
<a name="ln6465">    }</a>
<a name="ln6466">  }</a>
<a name="ln6467">#endif</a>
<a name="ln6468"> </a>
<a name="ln6469">  *file[0] = buf;</a>
<a name="ln6470">  *num_file = 1;</a>
<a name="ln6471">}</a>
<a name="ln6472"> </a>
<a name="ln6473">/// Get the value for the numeric or string option///opp in a nice format into</a>
<a name="ln6474">/// NameBuff[].  Must not be called with a hidden option!</a>
<a name="ln6475">static void</a>
<a name="ln6476">option_value2string(</a>
<a name="ln6477">    vimoption_T *opp,</a>
<a name="ln6478">    int opt_flags                          // OPT_GLOBAL and/or OPT_LOCAL</a>
<a name="ln6479">)</a>
<a name="ln6480">{</a>
<a name="ln6481">  char_u      *varp;</a>
<a name="ln6482"> </a>
<a name="ln6483">  varp = get_varp_scope(opp, opt_flags);</a>
<a name="ln6484"> </a>
<a name="ln6485">  if (opp-&gt;flags &amp; P_NUM) {</a>
<a name="ln6486">    long wc = 0;</a>
<a name="ln6487"> </a>
<a name="ln6488">    if (wc_use_keyname(varp, &amp;wc)) {</a>
<a name="ln6489">      STRLCPY(NameBuff, get_special_key_name((int)wc, 0), sizeof(NameBuff));</a>
<a name="ln6490">    } else if (wc != 0) {</a>
<a name="ln6491">      STRLCPY(NameBuff, transchar((int)wc), sizeof(NameBuff));</a>
<a name="ln6492">    } else {</a>
<a name="ln6493">      snprintf((char *)NameBuff,</a>
<a name="ln6494">               sizeof(NameBuff),</a>
<a name="ln6495">               &quot;%&quot; PRId64,</a>
<a name="ln6496">               (int64_t)*(long *)varp);</a>
<a name="ln6497">    }</a>
<a name="ln6498">  } else {  // P_STRING</a>
<a name="ln6499">    varp = *(char_u **)(varp);</a>
<a name="ln6500">    if (varp == NULL) {  // Just in case.</a>
<a name="ln6501">      NameBuff[0] = NUL;</a>
<a name="ln6502">    } else if (opp-&gt;flags &amp; P_EXPAND) {</a>
<a name="ln6503">      home_replace(NULL, varp, NameBuff, MAXPATHL, false);</a>
<a name="ln6504">    // Translate 'pastetoggle' into special key names.</a>
<a name="ln6505">    } else if ((char_u **)opp-&gt;var == &amp;p_pt) {</a>
<a name="ln6506">      str2specialbuf((const char *)p_pt, (char *)NameBuff, MAXPATHL);</a>
<a name="ln6507">    } else {</a>
<a name="ln6508">      STRLCPY(NameBuff, varp, MAXPATHL);</a>
<a name="ln6509">    }</a>
<a name="ln6510">  }</a>
<a name="ln6511">}</a>
<a name="ln6512"> </a>
<a name="ln6513">/// Return true if &quot;varp&quot; points to 'wildchar' or 'wildcharm' and it can be</a>
<a name="ln6514">/// printed as a keyname.</a>
<a name="ln6515">/// &quot;*wcp&quot; is set to the value of the option if it's 'wildchar' or 'wildcharm'.</a>
<a name="ln6516">static int wc_use_keyname(char_u *varp, long *wcp)</a>
<a name="ln6517">{</a>
<a name="ln6518">  if (((long *)varp == &amp;p_wc) || ((long *)varp == &amp;p_wcm)) {</a>
<a name="ln6519">    *wcp = *(long *)varp;</a>
<a name="ln6520">    if (IS_SPECIAL(*wcp) || find_special_key_in_table((int)(*wcp)) &gt;= 0) {</a>
<a name="ln6521">      return true;</a>
<a name="ln6522">    }</a>
<a name="ln6523">  }</a>
<a name="ln6524">  return false;</a>
<a name="ln6525">}</a>
<a name="ln6526"> </a>
<a name="ln6527">/// Any character has an equivalent 'langmap' character.  This is used for</a>
<a name="ln6528">/// keyboards that have a special language mode that sends characters above</a>
<a name="ln6529">/// 128 (although other characters can be translated too).  The &quot;to&quot; field is a</a>
<a name="ln6530">/// Vim command character.  This avoids having to switch the keyboard back to</a>
<a name="ln6531">/// ASCII mode when leaving Insert mode.</a>
<a name="ln6532">///</a>
<a name="ln6533">/// langmap_mapchar[] maps any of 256 chars to an ASCII char used for Vim</a>
<a name="ln6534">/// commands.</a>
<a name="ln6535">/// langmap_mapga.ga_data is a sorted table of langmap_entry_T.</a>
<a name="ln6536">/// This does the same as langmap_mapchar[] for characters &gt;= 256.</a>
<a name="ln6537">///</a>
<a name="ln6538">/// With multi-byte support use growarray for 'langmap' chars &gt;= 256</a>
<a name="ln6539">typedef struct {</a>
<a name="ln6540">  int from;</a>
<a name="ln6541">  int to;</a>
<a name="ln6542">} langmap_entry_T;</a>
<a name="ln6543"> </a>
<a name="ln6544">static garray_T langmap_mapga = GA_EMPTY_INIT_VALUE;</a>
<a name="ln6545"> </a>
<a name="ln6546">/// Search for an entry in &quot;langmap_mapga&quot; for &quot;from&quot;.  If found set the &quot;to&quot;</a>
<a name="ln6547">/// field.  If not found insert a new entry at the appropriate location.</a>
<a name="ln6548">static void langmap_set_entry(int from, int to)</a>
<a name="ln6549">{</a>
<a name="ln6550">  langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);</a>
<a name="ln6551">  unsigned int a = 0;</a>
<a name="ln6552">  assert(langmap_mapga.ga_len &gt;= 0);</a>
<a name="ln6553">  unsigned int b = (unsigned int)langmap_mapga.ga_len;</a>
<a name="ln6554"> </a>
<a name="ln6555">  // Do a binary search for an existing entry.</a>
<a name="ln6556">  while (a != b) {</a>
<a name="ln6557">    unsigned int i = (a + b) / 2;</a>
<a name="ln6558">    int d = entries[i].from - from;</a>
<a name="ln6559"> </a>
<a name="ln6560">    if (d == 0) {</a>
<a name="ln6561">      entries[i].to = to;</a>
<a name="ln6562">      return;</a>
<a name="ln6563">    }</a>
<a name="ln6564">    if (d &lt; 0) {</a>
<a name="ln6565">      a = i + 1;</a>
<a name="ln6566">    } else {</a>
<a name="ln6567">      b = i;</a>
<a name="ln6568">    }</a>
<a name="ln6569">  }</a>
<a name="ln6570"> </a>
<a name="ln6571">  ga_grow(&amp;langmap_mapga, 1);</a>
<a name="ln6572"> </a>
<a name="ln6573">  // insert new entry at position &quot;a&quot;</a>
<a name="ln6574">  entries = (langmap_entry_T *)(langmap_mapga.ga_data) + a;</a>
<a name="ln6575">  memmove(entries + 1, entries,</a>
<a name="ln6576">          ((unsigned int)langmap_mapga.ga_len - a) * sizeof(langmap_entry_T));</a>
<a name="ln6577">  langmap_mapga.ga_len++;</a>
<a name="ln6578">  entries[0].from = from;</a>
<a name="ln6579">  entries[0].to = to;</a>
<a name="ln6580">}</a>
<a name="ln6581"> </a>
<a name="ln6582">/// Apply 'langmap' to multi-byte character &quot;c&quot; and return the result.</a>
<a name="ln6583">int langmap_adjust_mb(int c)</a>
<a name="ln6584">{</a>
<a name="ln6585">  langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);</a>
<a name="ln6586">  int a = 0;</a>
<a name="ln6587">  int b = langmap_mapga.ga_len;</a>
<a name="ln6588"> </a>
<a name="ln6589">  while (a != b) {</a>
<a name="ln6590">    int i = (a + b) / 2;</a>
<a name="ln6591">    int d = entries[i].from - c;</a>
<a name="ln6592"> </a>
<a name="ln6593">    if (d == 0) {</a>
<a name="ln6594">      return entries[i].to;        // found matching entry</a>
<a name="ln6595">    }</a>
<a name="ln6596">    if (d &lt; 0) {</a>
<a name="ln6597">      a = i + 1;</a>
<a name="ln6598">    } else {</a>
<a name="ln6599">      b = i;</a>
<a name="ln6600">    }</a>
<a name="ln6601">  }</a>
<a name="ln6602">  return c;    // no entry found, return &quot;c&quot; unmodified</a>
<a name="ln6603">}</a>
<a name="ln6604"> </a>
<a name="ln6605">static void langmap_init(void)</a>
<a name="ln6606">{</a>
<a name="ln6607">  for (int i = 0; i &lt; 256; i++) {</a>
<a name="ln6608">    langmap_mapchar[i] = (char_u)i;      // we init with a one-to-one map</a>
<a name="ln6609">  }</a>
<a name="ln6610">  ga_init(&amp;langmap_mapga, sizeof(langmap_entry_T), 8);</a>
<a name="ln6611">}</a>
<a name="ln6612"> </a>
<a name="ln6613">/// Called when langmap option is set; the language map can be</a>
<a name="ln6614">/// changed at any time!</a>
<a name="ln6615">static void langmap_set(void)</a>
<a name="ln6616">{</a>
<a name="ln6617">  char_u  *p;</a>
<a name="ln6618">  char_u  *p2;</a>
<a name="ln6619">  int from, to;</a>
<a name="ln6620"> </a>
<a name="ln6621">  ga_clear(&amp;langmap_mapga);                 // clear the previous map first</a>
<a name="ln6622">  langmap_init();                           // back to one-to-one map</a>
<a name="ln6623"> </a>
<a name="ln6624">  for (p = p_langmap; p[0] != NUL; ) {</a>
<a name="ln6625">    for (p2 = p; p2[0] != NUL &amp;&amp; p2[0] != ',' &amp;&amp; p2[0] != ';';</a>
<a name="ln6626">         MB_PTR_ADV(p2)) {</a>
<a name="ln6627">      if (p2[0] == '\\' &amp;&amp; p2[1] != NUL) {</a>
<a name="ln6628">        p2++;</a>
<a name="ln6629">      }</a>
<a name="ln6630">    }</a>
<a name="ln6631">    if (p2[0] == ';') {</a>
<a name="ln6632">      p2++;                 // abcd;ABCD form, p2 points to A</a>
<a name="ln6633">    } else {</a>
<a name="ln6634">      p2 = NULL;            // aAbBcCdD form, p2 is NULL</a>
<a name="ln6635">    }</a>
<a name="ln6636">    while (p[0]) {</a>
<a name="ln6637">      if (p[0] == ',') {</a>
<a name="ln6638">        p++;</a>
<a name="ln6639">        break;</a>
<a name="ln6640">      }</a>
<a name="ln6641">      if (p[0] == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln6642">        p++;</a>
<a name="ln6643">      }</a>
<a name="ln6644">      from = utf_ptr2char(p);</a>
<a name="ln6645">      to = NUL;</a>
<a name="ln6646">      if (p2 == NULL) {</a>
<a name="ln6647">        MB_PTR_ADV(p);</a>
<a name="ln6648">        if (p[0] != ',') {</a>
<a name="ln6649">          if (p[0] == '\\') {</a>
<a name="ln6650">            p++;</a>
<a name="ln6651">          }</a>
<a name="ln6652">          to = utf_ptr2char(p);</a>
<a name="ln6653">        }</a>
<a name="ln6654">      } else {</a>
<a name="ln6655">        if (p2[0] != ',') {</a>
<a name="ln6656">          if (p2[0] == '\\') {</a>
<a name="ln6657">            p2++;</a>
<a name="ln6658">          }</a>
<a name="ln6659">          to = utf_ptr2char(p2);</a>
<a name="ln6660">        }</a>
<a name="ln6661">      }</a>
<a name="ln6662">      if (to == NUL) {</a>
<a name="ln6663">        EMSG2(_(&quot;E357: 'langmap': Matching character missing for %s&quot;),</a>
<a name="ln6664">            transchar(from));</a>
<a name="ln6665">        return;</a>
<a name="ln6666">      }</a>
<a name="ln6667"> </a>
<a name="ln6668">      if (from &gt;= 256) {</a>
<a name="ln6669">        langmap_set_entry(from, to);</a>
<a name="ln6670">      } else {</a>
<a name="ln6671">        assert(to &lt;= UCHAR_MAX);</a>
<a name="ln6672">        langmap_mapchar[from &amp; 255] = (char_u)to;</a>
<a name="ln6673">      }</a>
<a name="ln6674"> </a>
<a name="ln6675">      // Advance to next pair</a>
<a name="ln6676">      MB_PTR_ADV(p);</a>
<a name="ln6677">      if (p2 != NULL) {</a>
<a name="ln6678">        MB_PTR_ADV(p2);</a>
<a name="ln6679">        if (*p == ';') {</a>
<a name="ln6680">          p = p2;</a>
<a name="ln6681">          if (p[0] != NUL) {</a>
<a name="ln6682">            if (p[0] != ',') {</a>
<a name="ln6683">              EMSG2(_(</a>
<a name="ln6684">                      &quot;E358: 'langmap': Extra characters after semicolon: %s&quot;),</a>
<a name="ln6685">                  p);</a>
<a name="ln6686">              return;</a>
<a name="ln6687">            }</a>
<a name="ln6688">            p++;</a>
<a name="ln6689">          }</a>
<a name="ln6690">          break;</a>
<a name="ln6691">        }</a>
<a name="ln6692">      }</a>
<a name="ln6693">    }</a>
<a name="ln6694">  }</a>
<a name="ln6695">}</a>
<a name="ln6696"> </a>
<a name="ln6697">/// Return true if format option 'x' is in effect.</a>
<a name="ln6698">/// Take care of no formatting when 'paste' is set.</a>
<a name="ln6699">bool has_format_option(int x)</a>
<a name="ln6700">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6701">{</a>
<a name="ln6702">  if (p_paste) {</a>
<a name="ln6703">    return false;</a>
<a name="ln6704">  }</a>
<a name="ln6705">  return vim_strchr(curbuf-&gt;b_p_fo, x) != NULL;</a>
<a name="ln6706">}</a>
<a name="ln6707"> </a>
<a name="ln6708">/// @returns true if &quot;x&quot; is present in 'shortmess' option, or</a>
<a name="ln6709">/// 'shortmess' contains 'a' and &quot;x&quot; is present in SHM_ALL_ABBREVIATIONS.</a>
<a name="ln6710">bool shortmess(int x)</a>
<a name="ln6711">{</a>
<a name="ln6712">  return (p_shm != NULL</a>
<a name="ln6713">          &amp;&amp; (vim_strchr(p_shm, x) != NULL</a>
<a name="ln6714">              || (vim_strchr(p_shm, 'a') != NULL</a>
<a name="ln6715">                  &amp;&amp; vim_strchr((char_u *)SHM_ALL_ABBREVIATIONS, x) != NULL)));</a>
<a name="ln6716">}</a>
<a name="ln6717"> </a>
<a name="ln6718">/// paste_option_changed() - Called after p_paste was set or reset.</a>
<a name="ln6719">static void paste_option_changed(void)</a>
<a name="ln6720">{</a>
<a name="ln6721">  static int old_p_paste = false;</a>
<a name="ln6722">  static int save_sm = 0;</a>
<a name="ln6723">  static int save_sta = 0;</a>
<a name="ln6724">  static int save_ru = 0;</a>
<a name="ln6725">  static int save_ri = 0;</a>
<a name="ln6726">  static int save_hkmap = 0;</a>
<a name="ln6727"> </a>
<a name="ln6728">  if (p_paste) {</a>
<a name="ln6729">    /*</a>
<a name="ln6730">     * Paste switched from off to on.</a>
<a name="ln6731">     * Save the current values, so they can be restored later.</a>
<a name="ln6732">     */</a>
<a name="ln6733">    if (!old_p_paste) {</a>
<a name="ln6734">      // save options for each buffer</a>
<a name="ln6735">      FOR_ALL_BUFFERS(buf) {</a>
<a name="ln6736">        buf-&gt;b_p_tw_nopaste = buf-&gt;b_p_tw;</a>
<a name="ln6737">        buf-&gt;b_p_wm_nopaste = buf-&gt;b_p_wm;</a>
<a name="ln6738">        buf-&gt;b_p_sts_nopaste = buf-&gt;b_p_sts;</a>
<a name="ln6739">        buf-&gt;b_p_ai_nopaste = buf-&gt;b_p_ai;</a>
<a name="ln6740">        buf-&gt;b_p_et_nopaste = buf-&gt;b_p_et;</a>
<a name="ln6741">        if (buf-&gt;b_p_vsts_nopaste) {</a>
<a name="ln6742">          xfree(buf-&gt;b_p_vsts_nopaste);</a>
<a name="ln6743">        }</a>
<a name="ln6744">        buf-&gt;b_p_vsts_nopaste = buf-&gt;b_p_vsts &amp;&amp; buf-&gt;b_p_vsts != empty_option</a>
<a name="ln6745">                                    ? vim_strsave(buf-&gt;b_p_vsts)</a>
<a name="ln6746">                                    : NULL;</a>
<a name="ln6747">      }</a>
<a name="ln6748"> </a>
<a name="ln6749">      // save global options</a>
<a name="ln6750">      save_sm = p_sm;</a>
<a name="ln6751">      save_sta = p_sta;</a>
<a name="ln6752">      save_ru = p_ru;</a>
<a name="ln6753">      save_ri = p_ri;</a>
<a name="ln6754">      save_hkmap = p_hkmap;</a>
<a name="ln6755">      // save global values for local buffer options</a>
<a name="ln6756">      p_ai_nopaste = p_ai;</a>
<a name="ln6757">      p_et_nopaste = p_et;</a>
<a name="ln6758">      p_sts_nopaste = p_sts;</a>
<a name="ln6759">      p_tw_nopaste = p_tw;</a>
<a name="ln6760">      p_wm_nopaste = p_wm;</a>
<a name="ln6761">      if (p_vsts_nopaste) {</a>
<a name="ln6762">        xfree(p_vsts_nopaste);</a>
<a name="ln6763">      }</a>
<a name="ln6764">      p_vsts_nopaste = p_vsts &amp;&amp; p_vsts != empty_option</a>
<a name="ln6765">                          ? vim_strsave(p_vsts)</a>
<a name="ln6766">                          : NULL;</a>
<a name="ln6767">    }</a>
<a name="ln6768"> </a>
<a name="ln6769">    // Always set the option values, also when 'paste' is set when it is</a>
<a name="ln6770">    // already on.</a>
<a name="ln6771">    // set options for each buffer</a>
<a name="ln6772">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln6773">      buf-&gt;b_p_tw = 0;              // textwidth is 0</a>
<a name="ln6774">      buf-&gt;b_p_wm = 0;              // wrapmargin is 0</a>
<a name="ln6775">      buf-&gt;b_p_sts = 0;             // softtabstop is 0</a>
<a name="ln6776">      buf-&gt;b_p_ai = 0;              // no auto-indent</a>
<a name="ln6777">      buf-&gt;b_p_et = 0;              // no expandtab</a>
<a name="ln6778">      if (buf-&gt;b_p_vsts) {</a>
<a name="ln6779">        free_string_option(buf-&gt;b_p_vsts);</a>
<a name="ln6780">      }</a>
<a name="ln6781">      buf-&gt;b_p_vsts = empty_option;</a>
<a name="ln6782">      if (buf-&gt;b_p_vsts_array) {</a>
<a name="ln6783">        xfree(buf-&gt;b_p_vsts_array);</a>
<a name="ln6784">      }</a>
<a name="ln6785">      buf-&gt;b_p_vsts_array = 0;</a>
<a name="ln6786">    }</a>
<a name="ln6787"> </a>
<a name="ln6788">    // set global options</a>
<a name="ln6789">    p_sm = 0;                       // no showmatch</a>
<a name="ln6790">    p_sta = 0;                      // no smarttab</a>
<a name="ln6791">    if (p_ru) {</a>
<a name="ln6792">      status_redraw_all();          // redraw to remove the ruler</a>
<a name="ln6793">    }</a>
<a name="ln6794">    p_ru = 0;                       // no ruler</a>
<a name="ln6795">    p_ri = 0;                       // no reverse insert</a>
<a name="ln6796">    p_hkmap = 0;                    // no Hebrew keyboard</a>
<a name="ln6797">    // set global values for local buffer options</a>
<a name="ln6798">    p_tw = 0;</a>
<a name="ln6799">    p_wm = 0;</a>
<a name="ln6800">    p_sts = 0;</a>
<a name="ln6801">    p_ai = 0;</a>
<a name="ln6802">    if (p_vsts) {</a>
<a name="ln6803">      free_string_option(p_vsts);</a>
<a name="ln6804">    }</a>
<a name="ln6805">    p_vsts = empty_option;</a>
<a name="ln6806">  } else if (old_p_paste) {</a>
<a name="ln6807">    // Paste switched from on to off: Restore saved values.</a>
<a name="ln6808"> </a>
<a name="ln6809">    // restore options for each buffer</a>
<a name="ln6810">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln6811">      buf-&gt;b_p_tw = buf-&gt;b_p_tw_nopaste;</a>
<a name="ln6812">      buf-&gt;b_p_wm = buf-&gt;b_p_wm_nopaste;</a>
<a name="ln6813">      buf-&gt;b_p_sts = buf-&gt;b_p_sts_nopaste;</a>
<a name="ln6814">      buf-&gt;b_p_ai = buf-&gt;b_p_ai_nopaste;</a>
<a name="ln6815">      buf-&gt;b_p_et = buf-&gt;b_p_et_nopaste;</a>
<a name="ln6816">      if (buf-&gt;b_p_vsts) {</a>
<a name="ln6817">        free_string_option(buf-&gt;b_p_vsts);</a>
<a name="ln6818">      }</a>
<a name="ln6819">      buf-&gt;b_p_vsts = buf-&gt;b_p_vsts_nopaste</a>
<a name="ln6820">                        ? vim_strsave(buf-&gt;b_p_vsts_nopaste)</a>
<a name="ln6821">                        : empty_option;</a>
<a name="ln6822">      if (buf-&gt;b_p_vsts_array) {</a>
<a name="ln6823">        xfree(buf-&gt;b_p_vsts_array);</a>
<a name="ln6824">      }</a>
<a name="ln6825">      if (buf-&gt;b_p_vsts &amp;&amp; buf-&gt;b_p_vsts != empty_option) {</a>
<a name="ln6826">        tabstop_set(buf-&gt;b_p_vsts, &amp;buf-&gt;b_p_vsts_array);</a>
<a name="ln6827">      } else {</a>
<a name="ln6828">        buf-&gt;b_p_vsts_array = 0;</a>
<a name="ln6829">      }</a>
<a name="ln6830">    }</a>
<a name="ln6831"> </a>
<a name="ln6832">    // restore global options</a>
<a name="ln6833">    p_sm = save_sm;</a>
<a name="ln6834">    p_sta = save_sta;</a>
<a name="ln6835">    if (p_ru != save_ru) {</a>
<a name="ln6836">      status_redraw_all();          // redraw to draw the ruler</a>
<a name="ln6837">    }</a>
<a name="ln6838">    p_ru = save_ru;</a>
<a name="ln6839">    p_ri = save_ri;</a>
<a name="ln6840">    p_hkmap = save_hkmap;</a>
<a name="ln6841">    // set global values for local buffer options</a>
<a name="ln6842">    p_ai = p_ai_nopaste;</a>
<a name="ln6843">    p_et = p_et_nopaste;</a>
<a name="ln6844">    p_sts = p_sts_nopaste;</a>
<a name="ln6845">    p_tw = p_tw_nopaste;</a>
<a name="ln6846">    p_wm = p_wm_nopaste;</a>
<a name="ln6847">    if (p_vsts) {</a>
<a name="ln6848">      free_string_option(p_vsts);</a>
<a name="ln6849">    }</a>
<a name="ln6850">    p_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option;</a>
<a name="ln6851">  }</a>
<a name="ln6852"> </a>
<a name="ln6853">  old_p_paste = p_paste;</a>
<a name="ln6854">}</a>
<a name="ln6855"> </a>
<a name="ln6856">/// vimrc_found() - Called when a vimrc or &quot;VIMINIT&quot; has been found.</a>
<a name="ln6857">///</a>
<a name="ln6858">/// Set the values for options that didn't get set yet to the Vim defaults.</a>
<a name="ln6859">/// When &quot;fname&quot; is not NULL, use it to set $&quot;envname&quot; when it wasn't set yet.</a>
<a name="ln6860">void vimrc_found(char_u *fname, char_u *envname)</a>
<a name="ln6861">{</a>
<a name="ln6862">  if (fname != NULL &amp;&amp; envname != NULL) {</a>
<a name="ln6863">    char *p = vim_getenv((char *)envname);</a>
<a name="ln6864">    if (p == NULL) {</a>
<a name="ln6865">      // Set $MYVIMRC to the first vimrc file found.</a>
<a name="ln6866">      p = FullName_save((char *)fname, false);</a>
<a name="ln6867">      if (p != NULL) {</a>
<a name="ln6868">        os_setenv((char *)envname, p, 1);</a>
<a name="ln6869">        xfree(p);</a>
<a name="ln6870">      }</a>
<a name="ln6871">    } else {</a>
<a name="ln6872">      xfree(p);</a>
<a name="ln6873">    }</a>
<a name="ln6874">  }</a>
<a name="ln6875">}</a>
<a name="ln6876"> </a>
<a name="ln6877">/// Check whether global option has been set</a>
<a name="ln6878">///</a>
<a name="ln6879">/// @param[in]  name  Option name.</a>
<a name="ln6880">///</a>
<a name="ln6881">/// @return True if it was set.</a>
<a name="ln6882">bool option_was_set(const char *name)</a>
<a name="ln6883">{</a>
<a name="ln6884">  int idx;</a>
<a name="ln6885"> </a>
<a name="ln6886">  idx = findoption(name);</a>
<a name="ln6887">  if (idx &lt; 0) {  // Unknown option.</a>
<a name="ln6888">    return false;</a>
<a name="ln6889">  } else if (options[idx].flags &amp; P_WAS_SET) {</a>
<a name="ln6890">    return true;</a>
<a name="ln6891">  }</a>
<a name="ln6892">  return false;</a>
<a name="ln6893">}</a>
<a name="ln6894"> </a>
<a name="ln6895">/// Reset the flag indicating option &quot;name&quot; was set.</a>
<a name="ln6896">///</a>
<a name="ln6897">/// @param[in]  name  Option name.</a>
<a name="ln6898">void reset_option_was_set(const char *name)</a>
<a name="ln6899">{</a>
<a name="ln6900">  const int idx = findoption(name);</a>
<a name="ln6901"> </a>
<a name="ln6902">  if (idx &gt;= 0) {</a>
<a name="ln6903">    options[idx].flags &amp;= ~P_WAS_SET;</a>
<a name="ln6904">  }</a>
<a name="ln6905">}</a>
<a name="ln6906"> </a>
<a name="ln6907">/// fill_breakat_flags() -- called when 'breakat' changes value.</a>
<a name="ln6908">static void fill_breakat_flags(void)</a>
<a name="ln6909">{</a>
<a name="ln6910">  char_u      *p;</a>
<a name="ln6911">  int i;</a>
<a name="ln6912"> </a>
<a name="ln6913">  for (i = 0; i &lt; 256; i++) {</a>
<a name="ln6914">    breakat_flags[i] = false;</a>
<a name="ln6915">  }</a>
<a name="ln6916"> </a>
<a name="ln6917">  if (p_breakat != NULL) {</a>
<a name="ln6918">    for (p = p_breakat; *p; p++) {</a>
<a name="ln6919">      breakat_flags[*p] = true;</a>
<a name="ln6920">    }</a>
<a name="ln6921">  }</a>
<a name="ln6922">}</a>
<a name="ln6923"> </a>
<a name="ln6924">/// Check an option that can be a range of string values.</a>
<a name="ln6925">///</a>
<a name="ln6926">/// Return OK for correct value, FAIL otherwise.</a>
<a name="ln6927">/// Empty is always OK.</a>
<a name="ln6928">static int check_opt_strings(</a>
<a name="ln6929">    char_u *val,</a>
<a name="ln6930">    char **values,</a>
<a name="ln6931">    int list                   // when true: accept a list of values</a>
<a name="ln6932">)</a>
<a name="ln6933">{</a>
<a name="ln6934">  return opt_strings_flags(val, values, NULL, list);</a>
<a name="ln6935">}</a>
<a name="ln6936"> </a>
<a name="ln6937">/// Handle an option that can be a range of string values.</a>
<a name="ln6938">/// Set a flag in &quot;*flagp&quot; for each string present.</a>
<a name="ln6939">///</a>
<a name="ln6940">/// Return OK for correct value, FAIL otherwise.</a>
<a name="ln6941">/// Empty is always OK.</a>
<a name="ln6942">static int opt_strings_flags(</a>
<a name="ln6943">    char_u *val,             // new value</a>
<a name="ln6944">    char **values,           // array of valid string values</a>
<a name="ln6945">    unsigned *flagp,</a>
<a name="ln6946">    bool list                // when true: accept a list of values</a>
<a name="ln6947">)</a>
<a name="ln6948">{</a>
<a name="ln6949">  unsigned int new_flags = 0;</a>
<a name="ln6950"> </a>
<a name="ln6951">  while (*val) {</a>
<a name="ln6952">    for (unsigned int i = 0;; i++) {</a>
<a name="ln6953">      if (values[i] == NULL) {          // val not found in values[]</a>
<a name="ln6954">        return FAIL;</a>
<a name="ln6955">      }</a>
<a name="ln6956"> </a>
<a name="ln6957">      size_t len = STRLEN(values[i]);</a>
<a name="ln6958">      if (STRNCMP(values[i], val, len) == 0</a>
<a name="ln6959">          &amp;&amp; ((list &amp;&amp; val[len] == ',') || val[len] == NUL)) {</a>
<a name="ln6960">        val += len + (val[len] == ',');</a>
<a name="ln6961">        assert(i &lt; sizeof(1U) * 8);</a>
<a name="ln6962">        new_flags |= (1U &lt;&lt; i);</a>
<a name="ln6963">        break;                  // check next item in val list</a>
<a name="ln6964">      }</a>
<a name="ln6965">    }</a>
<a name="ln6966">  }</a>
<a name="ln6967">  if (flagp != NULL) {</a>
<a name="ln6968">    *flagp = new_flags;</a>
<a name="ln6969">  }</a>
<a name="ln6970"> </a>
<a name="ln6971">  return OK;</a>
<a name="ln6972">}</a>
<a name="ln6973"> </a>
<a name="ln6974">/// Read the 'wildmode' option, fill wim_flags[].</a>
<a name="ln6975">static int check_opt_wim(void)</a>
<a name="ln6976">{</a>
<a name="ln6977">  char_u new_wim_flags[4];</a>
<a name="ln6978">  char_u      *p;</a>
<a name="ln6979">  int i;</a>
<a name="ln6980">  int idx = 0;</a>
<a name="ln6981"> </a>
<a name="ln6982">  for (i = 0; i &lt; 4; i++) {</a>
<a name="ln6983">    new_wim_flags[i] = 0;</a>
<a name="ln6984">  }</a>
<a name="ln6985"> </a>
<a name="ln6986">  for (p = p_wim; *p; p++) {</a>
<a name="ln6987">    for (i = 0; ASCII_ISALPHA(p[i]); i++) {}</a>
<a name="ln6988">    if (p[i] != NUL &amp;&amp; p[i] != ',' &amp;&amp; p[i] != ':') {</a>
<a name="ln6989">      return FAIL;</a>
<a name="ln6990">    }</a>
<a name="ln6991">    if (i == 7 &amp;&amp; STRNCMP(p, &quot;longest&quot;, 7) == 0) {</a>
<a name="ln6992">      new_wim_flags[idx] |= WIM_LONGEST;</a>
<a name="ln6993">    } else if (i == 4 &amp;&amp; STRNCMP(p, &quot;full&quot;, 4) == 0) {</a>
<a name="ln6994">      new_wim_flags[idx] |= WIM_FULL;</a>
<a name="ln6995">    } else if (i == 4 &amp;&amp; STRNCMP(p, &quot;list&quot;, 4) == 0) {</a>
<a name="ln6996">      new_wim_flags[idx] |= WIM_LIST;</a>
<a name="ln6997">    } else if (i == 8 &amp;&amp; STRNCMP(p, &quot;lastused&quot;, 8) == 0) {</a>
<a name="ln6998">      new_wim_flags[idx] |= WIM_BUFLASTUSED;</a>
<a name="ln6999">    } else {</a>
<a name="ln7000">      return FAIL;</a>
<a name="ln7001">    }</a>
<a name="ln7002">    p += i;</a>
<a name="ln7003">    if (*p == NUL) {</a>
<a name="ln7004">      break;</a>
<a name="ln7005">    }</a>
<a name="ln7006">    if (*p == ',') {</a>
<a name="ln7007">      if (idx == 3) {</a>
<a name="ln7008">        return FAIL;</a>
<a name="ln7009">      }</a>
<a name="ln7010">      idx++;</a>
<a name="ln7011">    }</a>
<a name="ln7012">  }</a>
<a name="ln7013"> </a>
<a name="ln7014">  // fill remaining entries with last flag</a>
<a name="ln7015">  while (idx &lt; 3) {</a>
<a name="ln7016">    new_wim_flags[idx + 1] = new_wim_flags[idx];</a>
<a name="ln7017">    idx++;</a>
<a name="ln7018">  }</a>
<a name="ln7019"> </a>
<a name="ln7020">  // only when there are no errors, wim_flags[] is changed</a>
<a name="ln7021">  for (i = 0; i &lt; 4; i++) {</a>
<a name="ln7022">    wim_flags[i] = new_wim_flags[i];</a>
<a name="ln7023">  }</a>
<a name="ln7024">  return OK;</a>
<a name="ln7025">}</a>
<a name="ln7026"> </a>
<a name="ln7027">/// Check if backspacing over something is allowed.</a>
<a name="ln7028">/// @param  what  BS_INDENT, BS_EOL, BS_START, or BS_NOSTOP</a>
<a name="ln7029">bool can_bs(int what)</a>
<a name="ln7030">{</a>
<a name="ln7031">  if (what == BS_START &amp;&amp; bt_prompt(curbuf)) {</a>
<a name="ln7032">    return false;</a>
<a name="ln7033">  }</a>
<a name="ln7034">  switch (*p_bs) {</a>
<a name="ln7035">    case '3':       return true;</a>
<a name="ln7036">    case '2':       return what != BS_NOSTOP;</a>
<a name="ln7037">    case '1':       return what != BS_START;</a>
<a name="ln7038">    case '0':       return false;</a>
<a name="ln7039">  }</a>
<a name="ln7040">  return vim_strchr(p_bs, what) != NULL;</a>
<a name="ln7041">}</a>
<a name="ln7042"> </a>
<a name="ln7043">/// Save the current values of 'fileformat' and 'fileencoding', so that we know</a>
<a name="ln7044">/// the file must be considered changed when the value is different.</a>
<a name="ln7045">void save_file_ff(buf_T *buf)</a>
<a name="ln7046">{</a>
<a name="ln7047">  buf-&gt;b_start_ffc = *buf-&gt;b_p_ff;</a>
<a name="ln7048">  buf-&gt;b_start_eol = buf-&gt;b_p_eol;</a>
<a name="ln7049">  buf-&gt;b_start_bomb = buf-&gt;b_p_bomb;</a>
<a name="ln7050"> </a>
<a name="ln7051">  // Only use free/alloc when necessary, they take time.</a>
<a name="ln7052">  if (buf-&gt;b_start_fenc == NULL</a>
<a name="ln7053">      || STRCMP(buf-&gt;b_start_fenc, buf-&gt;b_p_fenc) != 0) {</a>
<a name="ln7054">    xfree(buf-&gt;b_start_fenc);</a>
<a name="ln7055">    buf-&gt;b_start_fenc = vim_strsave(buf-&gt;b_p_fenc);</a>
<a name="ln7056">  }</a>
<a name="ln7057">}</a>
<a name="ln7058"> </a>
<a name="ln7059">/// Return true if 'fileformat' and/or 'fileencoding' has a different value</a>
<a name="ln7060">/// from when editing started (save_file_ff() called).</a>
<a name="ln7061">/// Also when 'endofline' was changed and 'binary' is set, or when 'bomb' was</a>
<a name="ln7062">/// changed and 'binary' is not set.</a>
<a name="ln7063">/// Also when 'endofline' was changed and 'fixeol' is not set.</a>
<a name="ln7064">/// When &quot;ignore_empty&quot; is true don't consider a new, empty buffer to be</a>
<a name="ln7065">/// changed.</a>
<a name="ln7066">bool file_ff_differs(buf_T *buf, bool ignore_empty)</a>
<a name="ln7067">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7068">{</a>
<a name="ln7069">  // In a buffer that was never loaded the options are not valid.</a>
<a name="ln7070">  if (buf-&gt;b_flags &amp; BF_NEVERLOADED) {</a>
<a name="ln7071">    return false;</a>
<a name="ln7072">  }</a>
<a name="ln7073">  if (ignore_empty</a>
<a name="ln7074">      &amp;&amp; (buf-&gt;b_flags &amp; BF_NEW)</a>
<a name="ln7075">      &amp;&amp; buf-&gt;b_ml.ml_line_count == 1</a>
<a name="ln7076">      &amp;&amp; *ml_get_buf(buf, (linenr_T)1, false) == NUL) {</a>
<a name="ln7077">    return false;</a>
<a name="ln7078">  }</a>
<a name="ln7079">  if (buf-&gt;b_start_ffc != *buf-&gt;b_p_ff) {</a>
<a name="ln7080">    return true;</a>
<a name="ln7081">  }</a>
<a name="ln7082">  if ((buf-&gt;b_p_bin || !buf-&gt;b_p_fixeol) &amp;&amp; buf-&gt;b_start_eol != buf-&gt;b_p_eol) {</a>
<a name="ln7083">    return true;</a>
<a name="ln7084">  }</a>
<a name="ln7085">  if (!buf-&gt;b_p_bin &amp;&amp; buf-&gt;b_start_bomb != buf-&gt;b_p_bomb) {</a>
<a name="ln7086">    return true;</a>
<a name="ln7087">  }</a>
<a name="ln7088">  if (buf-&gt;b_start_fenc == NULL) {</a>
<a name="ln7089">    return *buf-&gt;b_p_fenc != NUL;</a>
<a name="ln7090">  }</a>
<a name="ln7091">  return STRCMP(buf-&gt;b_start_fenc, buf-&gt;b_p_fenc) != 0;</a>
<a name="ln7092">}</a>
<a name="ln7093"> </a>
<a name="ln7094">/// return OK if &quot;p&quot; is a valid fileformat name, FAIL otherwise.</a>
<a name="ln7095">int check_ff_value(char_u *p)</a>
<a name="ln7096">{</a>
<a name="ln7097">  return check_opt_strings(p, p_ff_values, false);</a>
<a name="ln7098">}</a>
<a name="ln7099"> </a>
<a name="ln7100">// Set the integer values corresponding to the string setting of 'vartabstop'.</a>
<a name="ln7101">// &quot;array&quot; will be set, caller must free it if needed.</a>
<a name="ln7102">bool tabstop_set(char_u *var, long **array)</a>
<a name="ln7103">{</a>
<a name="ln7104">  long valcount = 1;</a>
<a name="ln7105">  int t;</a>
<a name="ln7106">  char_u *cp;</a>
<a name="ln7107"> </a>
<a name="ln7108">  if (var[0] == NUL || (var[0] == '0' &amp;&amp; var[1] == NUL)) {</a>
<a name="ln7109">    *array = NULL;</a>
<a name="ln7110">    return true;</a>
<a name="ln7111">  }</a>
<a name="ln7112"> </a>
<a name="ln7113">  for (cp = var; *cp != NUL; cp++) {</a>
<a name="ln7114">    if (cp == var || cp[-1] == ',') {</a>
<a name="ln7115">      char_u *end;</a>
<a name="ln7116"> </a>
<a name="ln7117">      if (strtol((char *)cp, (char **)&amp;end, 10) &lt;= 0) {</a>
<a name="ln7118">        if (cp != end) {</a>
<a name="ln7119">          EMSG(_(e_positive));</a>
<a name="ln7120">        } else {</a>
<a name="ln7121">          EMSG(_(e_invarg));</a>
<a name="ln7122">        }</a>
<a name="ln7123">        return false;</a>
<a name="ln7124">      }</a>
<a name="ln7125">    }</a>
<a name="ln7126"> </a>
<a name="ln7127">    if (ascii_isdigit(*cp)) {</a>
<a name="ln7128">      continue;</a>
<a name="ln7129">    }</a>
<a name="ln7130">    if (cp[0] == ',' &amp;&amp; cp &gt; var &amp;&amp; cp[-1] != ',' &amp;&amp; cp[1] != NUL) {</a>
<a name="ln7131">      valcount++;</a>
<a name="ln7132">      continue;</a>
<a name="ln7133">    }</a>
<a name="ln7134">    EMSG(_(e_invarg));</a>
<a name="ln7135">    return false;</a>
<a name="ln7136">  }</a>
<a name="ln7137"> </a>
<a name="ln7138">  *array = (long *)xmalloc((unsigned)(valcount + 1) * sizeof(long));</a>
<a name="ln7139">  (*array)[0] = valcount;</a>
<a name="ln7140"> </a>
<a name="ln7141">  t = 1;</a>
<a name="ln7142">  for (cp = var; *cp != NUL;) {</a>
<a name="ln7143">    (*array)[t++] = atoi((char *)cp);</a>
<a name="ln7144">    while (*cp  != NUL &amp;&amp; *cp != ',') {</a>
<a name="ln7145">      cp++;</a>
<a name="ln7146">    }</a>
<a name="ln7147">    if (*cp != NUL) {</a>
<a name="ln7148">      cp++;</a>
<a name="ln7149">    }</a>
<a name="ln7150">  }</a>
<a name="ln7151"> </a>
<a name="ln7152">  return true;</a>
<a name="ln7153">}</a>
<a name="ln7154"> </a>
<a name="ln7155">// Calculate the number of screen spaces a tab will occupy.</a>
<a name="ln7156">// If &quot;vts&quot; is set then the tab widths are taken from that array,</a>
<a name="ln7157">// otherwise the value of ts is used.</a>
<a name="ln7158">int tabstop_padding(colnr_T col, long ts_arg, long *vts)</a>
<a name="ln7159">{</a>
<a name="ln7160">  long ts = ts_arg == 0 ? 8 : ts_arg;</a>
<a name="ln7161">  colnr_T tabcol = 0;</a>
<a name="ln7162">  int t;</a>
<a name="ln7163">  long padding = 0;</a>
<a name="ln7164"> </a>
<a name="ln7165">  if (vts == NULL || vts[0] == 0) {</a>
<a name="ln7166">    return (int)(ts - (col % ts));</a>
<a name="ln7167">  }</a>
<a name="ln7168"> </a>
<a name="ln7169">  const long tabcount = vts[0];</a>
<a name="ln7170"> </a>
<a name="ln7171">  for (t = 1; t &lt;= tabcount; t++) {</a>
<a name="ln7172">    tabcol += (colnr_T)vts[t];</a>
<a name="ln7173">    if (tabcol &gt; col) {</a>
<a name="ln7174">      padding = tabcol - col;</a>
<a name="ln7175">      break;</a>
<a name="ln7176">    }</a>
<a name="ln7177">  }</a>
<a name="ln7178">  if (t &gt; tabcount) {</a>
<a name="ln7179">    padding = vts[tabcount] - ((col - tabcol) % vts[tabcount]);</a>
<a name="ln7180">  }</a>
<a name="ln7181"> </a>
<a name="ln7182">  return (int)padding;</a>
<a name="ln7183">}</a>
<a name="ln7184"> </a>
<a name="ln7185">// Find the size of the tab that covers a particular column.</a>
<a name="ln7186">int tabstop_at(colnr_T col, long ts, long *vts)</a>
<a name="ln7187">{</a>
<a name="ln7188">  colnr_T tabcol = 0;</a>
<a name="ln7189">  int t;</a>
<a name="ln7190">  long tab_size = 0;</a>
<a name="ln7191"> </a>
<a name="ln7192">  if (vts == NULL || vts[0] == 0) {</a>
<a name="ln7193">    return (int)ts;</a>
<a name="ln7194">  }</a>
<a name="ln7195"> </a>
<a name="ln7196">  const long tabcount = vts[0];</a>
<a name="ln7197">  for (t = 1; t &lt;= tabcount; t++) {</a>
<a name="ln7198">    tabcol += (colnr_T)vts[t];</a>
<a name="ln7199">    if (tabcol &gt; col) {</a>
<a name="ln7200">      tab_size = vts[t];</a>
<a name="ln7201">      break;</a>
<a name="ln7202">    }</a>
<a name="ln7203">  }</a>
<a name="ln7204">  if (t &gt; tabcount) {</a>
<a name="ln7205">    tab_size = vts[tabcount];</a>
<a name="ln7206">  }</a>
<a name="ln7207"> </a>
<a name="ln7208">  return (int)tab_size;</a>
<a name="ln7209">}</a>
<a name="ln7210"> </a>
<a name="ln7211">// Find the column on which a tab starts.</a>
<a name="ln7212">colnr_T tabstop_start(colnr_T col, long ts, long *vts)</a>
<a name="ln7213">{</a>
<a name="ln7214">  colnr_T tabcol = 0;</a>
<a name="ln7215">  int t;</a>
<a name="ln7216"> </a>
<a name="ln7217">  if (vts == NULL || vts[0] == 0) {</a>
<a name="ln7218">    return (int)((col / ts) * ts);</a>
<a name="ln7219">  }</a>
<a name="ln7220"> </a>
<a name="ln7221">  const long tabcount = vts[0];</a>
<a name="ln7222">  for (t = 1; t &lt;= tabcount; t++) {</a>
<a name="ln7223">    tabcol += (colnr_T)vts[t];</a>
<a name="ln7224">    if (tabcol &gt; col) {</a>
<a name="ln7225">      return (int)(tabcol - vts[t]);</a>
<a name="ln7226">    }</a>
<a name="ln7227">  }</a>
<a name="ln7228"> </a>
<a name="ln7229">  const int excess = (int)(tabcol % vts[tabcount]);</a>
<a name="ln7230">  return (int)(excess + ((col - excess) / vts[tabcount]) * vts[tabcount]);</a>
<a name="ln7231">}</a>
<a name="ln7232"> </a>
<a name="ln7233">// Find the number of tabs and spaces necessary to get from one column</a>
<a name="ln7234">// to another.</a>
<a name="ln7235">void tabstop_fromto(colnr_T start_col,</a>
<a name="ln7236">                    colnr_T end_col,</a>
<a name="ln7237">                    long ts_arg,</a>
<a name="ln7238">                    long *vts,</a>
<a name="ln7239">                    int *ntabs,</a>
<a name="ln7240">                    int *nspcs)</a>
<a name="ln7241">{</a>
<a name="ln7242">  int spaces = end_col - start_col;</a>
<a name="ln7243">  colnr_T tabcol = 0;</a>
<a name="ln7244">  long padding = 0;</a>
<a name="ln7245">  int t;</a>
<a name="ln7246">  long ts = ts_arg == 0 ? curbuf-&gt;b_p_ts : ts_arg;</a>
<a name="ln7247"> </a>
<a name="ln7248">  if (vts == NULL || vts[0] == 0) {</a>
<a name="ln7249">    int tabs = 0;</a>
<a name="ln7250"> </a>
<a name="ln7251">    const int initspc = (int)(ts - (start_col % ts));</a>
<a name="ln7252">    if (spaces &gt;= initspc) {</a>
<a name="ln7253">      spaces -= initspc;</a>
<a name="ln7254">      tabs++;</a>
<a name="ln7255">    }</a>
<a name="ln7256">    tabs += (int)(spaces / ts);</a>
<a name="ln7257">    spaces -= (int)((spaces / ts) * ts);</a>
<a name="ln7258"> </a>
<a name="ln7259">    *ntabs = tabs;</a>
<a name="ln7260">    *nspcs = spaces;</a>
<a name="ln7261">    return;</a>
<a name="ln7262">  }</a>
<a name="ln7263"> </a>
<a name="ln7264">  // Find the padding needed to reach the next tabstop.</a>
<a name="ln7265">  const long tabcount = vts[0];</a>
<a name="ln7266">  for (t = 1; t &lt;= tabcount; t++) {</a>
<a name="ln7267">    tabcol += (colnr_T)vts[t];</a>
<a name="ln7268">    if (tabcol &gt; start_col) {</a>
<a name="ln7269">      padding = tabcol - start_col;</a>
<a name="ln7270">      break;</a>
<a name="ln7271">    }</a>
<a name="ln7272">  }</a>
<a name="ln7273">  if (t &gt; tabcount) {</a>
<a name="ln7274">    padding = vts[tabcount] - ((start_col - tabcol) % vts[tabcount]);</a>
<a name="ln7275">  }</a>
<a name="ln7276"> </a>
<a name="ln7277">  // If the space needed is less than the padding no tabs can be used.</a>
<a name="ln7278">  if (spaces &lt; padding) {</a>
<a name="ln7279">    *ntabs = 0;</a>
<a name="ln7280">    *nspcs = spaces;</a>
<a name="ln7281">    return;</a>
<a name="ln7282">  }</a>
<a name="ln7283"> </a>
<a name="ln7284">  *ntabs = 1;</a>
<a name="ln7285">  spaces -= (int)padding;</a>
<a name="ln7286"> </a>
<a name="ln7287">  // At least one tab has been used. See if any more will fit.</a>
<a name="ln7288">  while (spaces != 0 &amp;&amp; ++t &lt;= tabcount) {</a>
<a name="ln7289">    padding = vts[t];</a>
<a name="ln7290">    if (spaces &lt; padding) {</a>
<a name="ln7291">      *nspcs = spaces;</a>
<a name="ln7292">      return;</a>
<a name="ln7293">    }</a>
<a name="ln7294">    *ntabs += 1;</a>
<a name="ln7295">    spaces -= (int)padding;</a>
<a name="ln7296">  }</a>
<a name="ln7297"> </a>
<a name="ln7298">  *ntabs += spaces / (int)vts[tabcount];</a>
<a name="ln7299">  *nspcs = spaces % (int)vts[tabcount];</a>
<a name="ln7300">}</a>
<a name="ln7301"> </a>
<a name="ln7302">// See if two tabstop arrays contain the same values.</a>
<a name="ln7303">bool tabstop_eq(long *ts1, long *ts2)</a>
<a name="ln7304">{</a>
<a name="ln7305">  int t;</a>
<a name="ln7306"> </a>
<a name="ln7307">  if ((ts1 == 0 &amp;&amp; ts2) || (ts1 &amp;&amp; ts2 == 0)) {</a>
<a name="ln7308">    return false;</a>
<a name="ln7309">  }</a>
<a name="ln7310">  if (ts1 == ts2) {</a>
<a name="ln7311">    return true;</a>
<a name="ln7312">  }</a>
<a name="ln7313">  if (ts1[0] != ts2[0]) {</a>
<a name="ln7314">    return false;</a>
<a name="ln7315">  }</a>
<a name="ln7316"> </a>
<a name="ln7317">  for (t = 1; t &lt;= ts1[0]; t++) {</a>
<a name="ln7318">    if (ts1[t] != ts2[t]) {</a>
<a name="ln7319">      return false;</a>
<a name="ln7320">    }</a>
<a name="ln7321">  }</a>
<a name="ln7322"> </a>
<a name="ln7323">  return true;</a>
<a name="ln7324">}</a>
<a name="ln7325"> </a>
<a name="ln7326">// Copy a tabstop array, allocating space for the new array.</a>
<a name="ln7327">int *tabstop_copy(long *oldts)</a>
<a name="ln7328">{</a>
<a name="ln7329">  long *newts;</a>
<a name="ln7330">  int t;</a>
<a name="ln7331"> </a>
<a name="ln7332">  if (oldts == 0) {</a>
<a name="ln7333">    return 0;</a>
<a name="ln7334">  }</a>
<a name="ln7335"> </a>
<a name="ln7336">  newts = xmalloc((unsigned)(oldts[0] + 1) * sizeof(long));</a>
<a name="ln7337">  for (t = 0; t &lt;= oldts[0]; t++) {</a>
<a name="ln7338">    newts[t] = oldts[t];</a>
<a name="ln7339">  }</a>
<a name="ln7340"> </a>
<a name="ln7341">  return (int *)newts;</a>
<a name="ln7342">}</a>
<a name="ln7343"> </a>
<a name="ln7344">// Return a count of the number of tabstops.</a>
<a name="ln7345">int tabstop_count(long *ts)</a>
<a name="ln7346">{</a>
<a name="ln7347">  return ts != NULL ? (int)ts[0] : 0;</a>
<a name="ln7348">}</a>
<a name="ln7349"> </a>
<a name="ln7350">// Return the first tabstop, or 8 if there are no tabstops defined.</a>
<a name="ln7351">int tabstop_first(long *ts)</a>
<a name="ln7352">{</a>
<a name="ln7353">  return ts != NULL ? (int)ts[1] : 8;</a>
<a name="ln7354">}</a>
<a name="ln7355"> </a>
<a name="ln7356">/// Return the effective shiftwidth value for current buffer, using the</a>
<a name="ln7357">/// 'tabstop' value when 'shiftwidth' is zero.</a>
<a name="ln7358">int get_sw_value(buf_T *buf)</a>
<a name="ln7359">{</a>
<a name="ln7360">  long result = get_sw_value_col(buf, 0);</a>
<a name="ln7361">  assert(result &gt;= 0 &amp;&amp; result &lt;= INT_MAX);</a>
<a name="ln7362">  return (int)result;</a>
<a name="ln7363">}</a>
<a name="ln7364"> </a>
<a name="ln7365">// Idem, using the first non-black in the current line.</a>
<a name="ln7366">long get_sw_value_indent(buf_T *buf)</a>
<a name="ln7367">{</a>
<a name="ln7368">  pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln7369"> </a>
<a name="ln7370">  pos.col = (colnr_T)getwhitecols_curline();</a>
<a name="ln7371">  return get_sw_value_pos(buf, &amp;pos);</a>
<a name="ln7372">}</a>
<a name="ln7373"> </a>
<a name="ln7374">// Idem, using &quot;pos&quot;.</a>
<a name="ln7375">long get_sw_value_pos(buf_T *buf, pos_T *pos)</a>
<a name="ln7376">{</a>
<a name="ln7377">  pos_T save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln7378">  long sw_value;</a>
<a name="ln7379"> </a>
<a name="ln7380">  curwin-&gt;w_cursor = *pos;</a>
<a name="ln7381">  sw_value = get_sw_value_col(buf, get_nolist_virtcol());</a>
<a name="ln7382">  curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln7383">  return sw_value;</a>
<a name="ln7384">}</a>
<a name="ln7385"> </a>
<a name="ln7386">// Idem, using virtual column &quot;col&quot;.</a>
<a name="ln7387">long get_sw_value_col(buf_T *buf, colnr_T col)</a>
<a name="ln7388">{</a>
<a name="ln7389">  return buf-&gt;b_p_sw ? buf-&gt;b_p_sw</a>
<a name="ln7390">                     : tabstop_at(col, buf-&gt;b_p_ts, buf-&gt;b_p_vts_array);</a>
<a name="ln7391">}</a>
<a name="ln7392"> </a>
<a name="ln7393">/// Return the effective softtabstop value for the current buffer,</a>
<a name="ln7394">/// using the shiftwidth  value when 'softtabstop' is negative.</a>
<a name="ln7395">int get_sts_value(void)</a>
<a name="ln7396">{</a>
<a name="ln7397">  long result = curbuf-&gt;b_p_sts &lt; 0 ? get_sw_value(curbuf) : curbuf-&gt;b_p_sts;</a>
<a name="ln7398">  assert(result &gt;= 0 &amp;&amp; result &lt;= INT_MAX);</a>
<a name="ln7399">  return (int)result;</a>
<a name="ln7400">}</a>
<a name="ln7401"> </a>
<a name="ln7402">/// This is called when 'breakindentopt' is changed and when a window is</a>
<a name="ln7403">/// initialized</a>
<a name="ln7404">static bool briopt_check(win_T *wp)</a>
<a name="ln7405">{</a>
<a name="ln7406">  int bri_shift = 0;</a>
<a name="ln7407">  int bri_min = 20;</a>
<a name="ln7408">  bool bri_sbr = false;</a>
<a name="ln7409"> </a>
<a name="ln7410">  char_u *p = wp-&gt;w_p_briopt;</a>
<a name="ln7411">  while (*p != NUL)</a>
<a name="ln7412">  {</a>
<a name="ln7413">    if (STRNCMP(p, &quot;shift:&quot;, 6) == 0</a>
<a name="ln7414">        &amp;&amp; ((p[6] == '-' &amp;&amp; ascii_isdigit(p[7])) || ascii_isdigit(p[6])))</a>
<a name="ln7415">    {</a>
<a name="ln7416">      p += 6;</a>
<a name="ln7417">      bri_shift = getdigits_int(&amp;p, true, 0);</a>
<a name="ln7418">    }</a>
<a name="ln7419">    else if (STRNCMP(p, &quot;min:&quot;, 4) == 0 &amp;&amp; ascii_isdigit(p[4]))</a>
<a name="ln7420">    {</a>
<a name="ln7421">      p += 4;</a>
<a name="ln7422">      bri_min = getdigits_int(&amp;p, true, 0);</a>
<a name="ln7423">    }</a>
<a name="ln7424">    else if (STRNCMP(p, &quot;sbr&quot;, 3) == 0)</a>
<a name="ln7425">    {</a>
<a name="ln7426">      p += 3;</a>
<a name="ln7427">      bri_sbr = true;</a>
<a name="ln7428">    }</a>
<a name="ln7429">    if (*p != ',' &amp;&amp; *p != NUL) {</a>
<a name="ln7430">      return false;</a>
<a name="ln7431">    }</a>
<a name="ln7432">    if (*p == ',') {</a>
<a name="ln7433">      p++;</a>
<a name="ln7434">    }</a>
<a name="ln7435">  }</a>
<a name="ln7436"> </a>
<a name="ln7437">  wp-&gt;w_briopt_shift = bri_shift;</a>
<a name="ln7438">  wp-&gt;w_briopt_min = bri_min;</a>
<a name="ln7439">  wp-&gt;w_briopt_sbr = bri_sbr;</a>
<a name="ln7440"> </a>
<a name="ln7441">  return true;</a>
<a name="ln7442">}</a>
<a name="ln7443"> </a>
<a name="ln7444">/// Get the local or global value of 'backupcopy'.</a>
<a name="ln7445">///</a>
<a name="ln7446">/// @param buf The buffer.</a>
<a name="ln7447">unsigned int get_bkc_value(buf_T *buf)</a>
<a name="ln7448">{</a>
<a name="ln7449">  return buf-&gt;b_bkc_flags ? buf-&gt;b_bkc_flags : bkc_flags;</a>
<a name="ln7450">}</a>
<a name="ln7451"> </a>
<a name="ln7452">/// Return the current end-of-line type: EOL_DOS, EOL_UNIX or EOL_MAC.</a>
<a name="ln7453">int get_fileformat(const buf_T *buf)</a>
<a name="ln7454">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7455">{</a>
<a name="ln7456">  int c = *buf-&gt;b_p_ff;</a>
<a name="ln7457"> </a>
<a name="ln7458">  if (buf-&gt;b_p_bin || c == 'u') {</a>
<a name="ln7459">    return EOL_UNIX;</a>
<a name="ln7460">  }</a>
<a name="ln7461">  if (c == 'm') {</a>
<a name="ln7462">    return EOL_MAC;</a>
<a name="ln7463">  }</a>
<a name="ln7464">  return EOL_DOS;</a>
<a name="ln7465">}</a>
<a name="ln7466"> </a>
<a name="ln7467">/// Like get_fileformat(), but override 'fileformat' with &quot;p&quot; for &quot;++opt=val&quot;</a>
<a name="ln7468">/// argument.</a>
<a name="ln7469">///</a>
<a name="ln7470">/// @param eap  can be NULL!</a>
<a name="ln7471">int get_fileformat_force(const buf_T *buf, const exarg_T *eap)</a>
<a name="ln7472">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln7473">{</a>
<a name="ln7474">  int c;</a>
<a name="ln7475"> </a>
<a name="ln7476">  if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln7477">    c = eap-&gt;force_ff;</a>
<a name="ln7478">  } else {</a>
<a name="ln7479">    if ((eap != NULL &amp;&amp; eap-&gt;force_bin != 0)</a>
<a name="ln7480">        ? (eap-&gt;force_bin == FORCE_BIN) : buf-&gt;b_p_bin) {</a>
<a name="ln7481">      return EOL_UNIX;</a>
<a name="ln7482">    }</a>
<a name="ln7483">    c = *buf-&gt;b_p_ff;</a>
<a name="ln7484">  }</a>
<a name="ln7485">  if (c == 'u') {</a>
<a name="ln7486">    return EOL_UNIX;</a>
<a name="ln7487">  }</a>
<a name="ln7488">  if (c == 'm') {</a>
<a name="ln7489">    return EOL_MAC;</a>
<a name="ln7490">  }</a>
<a name="ln7491">  return EOL_DOS;</a>
<a name="ln7492">}</a>
<a name="ln7493"> </a>
<a name="ln7494">/// Return the default fileformat from 'fileformats'.</a>
<a name="ln7495">int default_fileformat(void)</a>
<a name="ln7496">{</a>
<a name="ln7497">  switch (*p_ffs) {</a>
<a name="ln7498">  case 'm':   return EOL_MAC;</a>
<a name="ln7499">  case 'd':   return EOL_DOS;</a>
<a name="ln7500">  }</a>
<a name="ln7501">  return EOL_UNIX;</a>
<a name="ln7502">}</a>
<a name="ln7503"> </a>
<a name="ln7504">/// Set the current end-of-line type to EOL_UNIX, EOL_MAC, or EOL_DOS.</a>
<a name="ln7505">///</a>
<a name="ln7506">/// Sets 'fileformat'.</a>
<a name="ln7507">///</a>
<a name="ln7508">/// @param eol_style End-of-line style.</a>
<a name="ln7509">/// @param opt_flags OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln7510">void set_fileformat(int eol_style, int opt_flags)</a>
<a name="ln7511">{</a>
<a name="ln7512">  char *p = NULL;</a>
<a name="ln7513"> </a>
<a name="ln7514">  switch (eol_style) {</a>
<a name="ln7515">      case EOL_UNIX:</a>
<a name="ln7516">          p = FF_UNIX;</a>
<a name="ln7517">          break;</a>
<a name="ln7518">      case EOL_MAC:</a>
<a name="ln7519">          p = FF_MAC;</a>
<a name="ln7520">          break;</a>
<a name="ln7521">      case EOL_DOS:</a>
<a name="ln7522">          p = FF_DOS;</a>
<a name="ln7523">          break;</a>
<a name="ln7524">  }</a>
<a name="ln7525"> </a>
<a name="ln7526">  // p is NULL if &quot;eol_style&quot; is EOL_UNKNOWN.</a>
<a name="ln7527">  if (p != NULL) {</a>
<a name="ln7528">    set_string_option_direct(&quot;ff&quot;,</a>
<a name="ln7529">                             -1,</a>
<a name="ln7530">                             (char_u *)p,</a>
<a name="ln7531">                             OPT_FREE | opt_flags,</a>
<a name="ln7532">                             0);</a>
<a name="ln7533">  }</a>
<a name="ln7534"> </a>
<a name="ln7535">  // This may cause the buffer to become (un)modified.</a>
<a name="ln7536">  check_status(curbuf);</a>
<a name="ln7537">  redraw_tabline = true;</a>
<a name="ln7538">  need_maketitle = true;  // Set window title later.</a>
<a name="ln7539">}</a>
<a name="ln7540"> </a>
<a name="ln7541">/// Skip to next part of an option argument: skip space and comma</a>
<a name="ln7542">char_u *skip_to_option_part(const char_u *p)</a>
<a name="ln7543">{</a>
<a name="ln7544">  if (*p == ',') {</a>
<a name="ln7545">    p++;</a>
<a name="ln7546">  }</a>
<a name="ln7547">  while (*p == ' ') {</a>
<a name="ln7548">    p++;</a>
<a name="ln7549">  }</a>
<a name="ln7550">  return (char_u *)p;</a>
<a name="ln7551">}</a>
<a name="ln7552"> </a>
<a name="ln7553">/// Isolate one part of a string option separated by `sep_chars`.</a>
<a name="ln7554">///</a>
<a name="ln7555">/// @param[in,out]  option    advanced to the next part</a>
<a name="ln7556">/// @param[in,out]  buf       copy of the isolated part</a>
<a name="ln7557">/// @param[in]      maxlen    length of `buf`</a>
<a name="ln7558">/// @param[in]      sep_chars chars that separate the option parts</a>
<a name="ln7559">///</a>
<a name="ln7560">/// @return length of `*option`</a>
<a name="ln7561">size_t copy_option_part(char_u **option, char_u *buf, size_t maxlen,</a>
<a name="ln7562">                        char *sep_chars)</a>
<a name="ln7563">{</a>
<a name="ln7564">  size_t len = 0;</a>
<a name="ln7565">  char_u  *p = *option;</a>
<a name="ln7566"> </a>
<a name="ln7567">  // skip '.' at start of option part, for 'suffixes'</a>
<a name="ln7568">  if (*p == '.') {</a>
<a name="ln7569">    buf[len++] = *p++;</a>
<a name="ln7570">  }</a>
<a name="ln7571">  while (*p != NUL &amp;&amp; vim_strchr((char_u *)sep_chars, *p) == NULL) {</a>
<a name="ln7572">    // Skip backslash before a separator character and space.</a>
<a name="ln7573">    if (p[0] == '\\' &amp;&amp; vim_strchr((char_u *)sep_chars, p[1]) != NULL) {</a>
<a name="ln7574">      p++;</a>
<a name="ln7575">    }</a>
<a name="ln7576">    if (len &lt; maxlen - 1) {</a>
<a name="ln7577">      buf[len++] = *p;</a>
<a name="ln7578">    }</a>
<a name="ln7579">    p++;</a>
<a name="ln7580">  }</a>
<a name="ln7581">  buf[len] = NUL;</a>
<a name="ln7582"> </a>
<a name="ln7583">  if (*p != NUL &amp;&amp; *p != ',') {  // skip non-standard separator</a>
<a name="ln7584">    p++;</a>
<a name="ln7585">  }</a>
<a name="ln7586">  p = skip_to_option_part(p);    // p points to next file name</a>
<a name="ln7587"> </a>
<a name="ln7588">  *option = p;</a>
<a name="ln7589">  return len;</a>
<a name="ln7590">}</a>
<a name="ln7591"> </a>
<a name="ln7592">/// Return true when 'shell' has &quot;csh&quot; in the tail.</a>
<a name="ln7593">int csh_like_shell(void)</a>
<a name="ln7594">{</a>
<a name="ln7595">  return strstr((char *)path_tail(p_sh), &quot;csh&quot;) != NULL;</a>
<a name="ln7596">}</a>
<a name="ln7597"> </a>
<a name="ln7598">/// Return the number of requested sign columns, based on current</a>
<a name="ln7599">/// buffer signs and on user configuration.</a>
<a name="ln7600">int win_signcol_count(win_T *wp)</a>
<a name="ln7601">{</a>
<a name="ln7602">  return win_signcol_configured(wp, NULL);</a>
<a name="ln7603">}</a>
<a name="ln7604"> </a>
<a name="ln7605">/// Return the number of requested sign columns, based on user / configuration.</a>
<a name="ln7606">int win_signcol_configured(win_T *wp, int *is_fixed)</a>
<a name="ln7607">{</a>
<a name="ln7608">  int minimum = 0, maximum = 1, needed_signcols;</a>
<a name="ln7609">  const char *scl = (const char *)wp-&gt;w_p_scl;</a>
<a name="ln7610"> </a>
<a name="ln7611">  if (is_fixed) {</a>
<a name="ln7612">    *is_fixed = 1;</a>
<a name="ln7613">  }</a>
<a name="ln7614"> </a>
<a name="ln7615">  // Note: It checks &quot;no&quot; or &quot;number&quot; in 'signcolumn' option</a>
<a name="ln7616">  if (*scl == 'n'</a>
<a name="ln7617">      &amp;&amp; (*(scl + 1) == 'o' || (*(scl + 1) == 'u'</a>
<a name="ln7618">                                &amp;&amp; (wp-&gt;w_p_nu || wp-&gt;w_p_rnu)))) {</a>
<a name="ln7619">    return 0;</a>
<a name="ln7620">  }</a>
<a name="ln7621">  needed_signcols = buf_signcols(wp-&gt;w_buffer);</a>
<a name="ln7622"> </a>
<a name="ln7623">  // yes or yes</a>
<a name="ln7624">  if (!strncmp(scl, &quot;yes:&quot;, 4)) {</a>
<a name="ln7625">    // Fixed amount of columns</a>
<a name="ln7626">    return scl[4] - '0';</a>
<a name="ln7627">  }</a>
<a name="ln7628">  if (*scl == 'y') {</a>
<a name="ln7629">    return 1;</a>
<a name="ln7630">  }</a>
<a name="ln7631"> </a>
<a name="ln7632">  if (is_fixed) {</a>
<a name="ln7633">    // auto or auto:&lt;NUM&gt;</a>
<a name="ln7634">    *is_fixed = 0;</a>
<a name="ln7635">  }</a>
<a name="ln7636"> </a>
<a name="ln7637">  if (!strncmp(scl, &quot;auto:&quot;, 5)) {</a>
<a name="ln7638">    // Variable depending on a configuration</a>
<a name="ln7639">    maximum = scl[5] - '0';</a>
<a name="ln7640">    // auto:&lt;NUM&gt;-&lt;NUM&gt;</a>
<a name="ln7641">    if (strlen(scl) == 8 &amp;&amp; *(scl + 6) == '-') {</a>
<a name="ln7642">      minimum = maximum;</a>
<a name="ln7643">      maximum = scl[7] - '0';</a>
<a name="ln7644">    }</a>
<a name="ln7645">  }</a>
<a name="ln7646"> </a>
<a name="ln7647">  int ret = MAX(minimum, MIN(maximum, needed_signcols));</a>
<a name="ln7648">  assert(ret &lt;= SIGN_SHOW_MAX);</a>
<a name="ln7649">  return ret;</a>
<a name="ln7650">}</a>
<a name="ln7651"> </a>
<a name="ln7652">/// Get window or buffer local options</a>
<a name="ln7653">dict_T *get_winbuf_options(const int bufopt)</a>
<a name="ln7654">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7655">{</a>
<a name="ln7656">  dict_T *const d = tv_dict_alloc();</a>
<a name="ln7657"> </a>
<a name="ln7658">  for (int opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln7659">    struct vimoption *opt = &amp;options[opt_idx];</a>
<a name="ln7660"> </a>
<a name="ln7661">    if ((bufopt &amp;&amp; (opt-&gt;indir &amp; PV_BUF))</a>
<a name="ln7662">        || (!bufopt &amp;&amp; (opt-&gt;indir &amp; PV_WIN))) {</a>
<a name="ln7663">      char_u *varp = get_varp(opt);</a>
<a name="ln7664"> </a>
<a name="ln7665">      if (varp != NULL) {</a>
<a name="ln7666">        if (opt-&gt;flags &amp; P_STRING) {</a>
<a name="ln7667">          tv_dict_add_str(d, opt-&gt;fullname, strlen(opt-&gt;fullname),</a>
<a name="ln7668">                          *(const char **)varp);</a>
<a name="ln7669">        } else if (opt-&gt;flags &amp; P_NUM) {</a>
<a name="ln7670">          tv_dict_add_nr(d, opt-&gt;fullname, strlen(opt-&gt;fullname),</a>
<a name="ln7671">                         *(long *)varp);</a>
<a name="ln7672">        } else {</a>
<a name="ln7673">          tv_dict_add_nr(d, opt-&gt;fullname, strlen(opt-&gt;fullname), *(int *)varp);</a>
<a name="ln7674">        }</a>
<a name="ln7675">      }</a>
<a name="ln7676">    }</a>
<a name="ln7677">  }</a>
<a name="ln7678"> </a>
<a name="ln7679">  return d;</a>
<a name="ln7680">}</a>
<a name="ln7681"> </a>
<a name="ln7682">/// Return the effective 'scrolloff' value for the current window, using the</a>
<a name="ln7683">/// global value when appropriate.</a>
<a name="ln7684">long get_scrolloff_value(win_T *wp)</a>
<a name="ln7685">{</a>
<a name="ln7686">  // Disallow scrolloff in terminal-mode. #11915</a>
<a name="ln7687">  if (State &amp; TERM_FOCUS) {</a>
<a name="ln7688">    return 0;</a>
<a name="ln7689">  }</a>
<a name="ln7690">  return wp-&gt;w_p_so &lt; 0 ? p_so : wp-&gt;w_p_so;</a>
<a name="ln7691">}</a>
<a name="ln7692"> </a>
<a name="ln7693">/// Return the effective 'sidescrolloff' value for the current window, using the</a>
<a name="ln7694">/// global value when appropriate.</a>
<a name="ln7695">long get_sidescrolloff_value(win_T *wp)</a>
<a name="ln7696">{</a>
<a name="ln7697">  return wp-&gt;w_p_siso &lt; 0 ? p_siso : wp-&gt;w_p_siso;</a>
<a name="ln7698">}</a>
<a name="ln7699"> </a>
<a name="ln7700">Dictionary get_vimoption(String name, Error *err)</a>
<a name="ln7701">{</a>
<a name="ln7702">  int opt_idx = findoption_len((const char *)name.data, name.size);</a>
<a name="ln7703">  if (opt_idx &lt; 0) {</a>
<a name="ln7704">    api_set_error(err, kErrorTypeValidation, &quot;no such option: '%s'&quot;, name.data);</a>
<a name="ln7705">    return (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln7706">  }</a>
<a name="ln7707">  return vimoption2dict(&amp;options[opt_idx]);</a>
<a name="ln7708">}</a>
<a name="ln7709"> </a>
<a name="ln7710">Dictionary get_all_vimoptions(void)</a>
<a name="ln7711">{</a>
<a name="ln7712">  Dictionary retval = ARRAY_DICT_INIT;</a>
<a name="ln7713">  for (size_t i = 0; options[i].fullname != NULL; i++) {</a>
<a name="ln7714">    Dictionary opt_dict = vimoption2dict(&amp;options[i]);</a>
<a name="ln7715">    PUT(retval, options[i].fullname, DICTIONARY_OBJ(opt_dict));</a>
<a name="ln7716">  }</a>
<a name="ln7717">  return retval;</a>
<a name="ln7718">}</a>
<a name="ln7719"> </a>
<a name="ln7720">static Dictionary vimoption2dict(vimoption_T *opt)</a>
<a name="ln7721">{</a>
<a name="ln7722">    Dictionary dict = ARRAY_DICT_INIT;</a>
<a name="ln7723"> </a>
<a name="ln7724">    PUT(dict, &quot;name&quot;, CSTR_TO_OBJ(opt-&gt;fullname));</a>
<a name="ln7725">    PUT(dict, &quot;shortname&quot;, CSTR_TO_OBJ(opt-&gt;shortname));</a>
<a name="ln7726"> </a>
<a name="ln7727">    const char *scope;</a>
<a name="ln7728">    if (opt-&gt;indir &amp; PV_BUF) {</a>
<a name="ln7729">      scope = &quot;buf&quot;;</a>
<a name="ln7730">    } else if (opt-&gt;indir &amp; PV_WIN) {</a>
<a name="ln7731">      scope = &quot;win&quot;;</a>
<a name="ln7732">    } else {</a>
<a name="ln7733">      scope = &quot;global&quot;;</a>
<a name="ln7734">    }</a>
<a name="ln7735"> </a>
<a name="ln7736">    PUT(dict, &quot;scope&quot;, CSTR_TO_OBJ(scope));</a>
<a name="ln7737"> </a>
<a name="ln7738">    // welcome to the jungle</a>
<a name="ln7739">    PUT(dict, &quot;global_local&quot;, BOOL(opt-&gt;indir &amp; PV_BOTH));</a>
<a name="ln7740">    PUT(dict, &quot;commalist&quot;, BOOL(opt-&gt;flags &amp; P_COMMA));</a>
<a name="ln7741">    PUT(dict, &quot;flaglist&quot;, BOOL(opt-&gt;flags &amp; P_FLAGLIST));</a>
<a name="ln7742"> </a>
<a name="ln7743">    PUT(dict, &quot;was_set&quot;, BOOL(opt-&gt;flags &amp; P_WAS_SET));</a>
<a name="ln7744"> </a>
<a name="ln7745">    PUT(dict, &quot;last_set_sid&quot;, INTEGER_OBJ(opt-&gt;last_set.script_ctx.sc_sid));</a>
<a name="ln7746">    PUT(dict, &quot;last_set_linenr&quot;, INTEGER_OBJ(opt-&gt;last_set.script_ctx.sc_lnum));</a>
<a name="ln7747">    PUT(dict, &quot;last_set_chan&quot;, INTEGER_OBJ((int64_t)opt-&gt;last_set.channel_id));</a>
<a name="ln7748"> </a>
<a name="ln7749">    const char *type;</a>
<a name="ln7750">    Object def;</a>
<a name="ln7751">    // TODO(bfredl): do you even nocp?</a>
<a name="ln7752">    char_u *def_val = opt-&gt;def_val[(opt-&gt;flags &amp; P_VI_DEF)</a>
<a name="ln7753">                                   ? VI_DEFAULT : VIM_DEFAULT];</a>
<a name="ln7754">    if (opt-&gt;flags &amp; P_STRING) {</a>
<a name="ln7755">      type = &quot;string&quot;;</a>
<a name="ln7756">      def = CSTR_TO_OBJ(def_val ? (char *)def_val : &quot;&quot;);</a>
<a name="ln7757">    } else if (opt-&gt;flags &amp; P_NUM) {</a>
<a name="ln7758">      type = &quot;number&quot;;</a>
<a name="ln7759">      def = INTEGER_OBJ((Integer)(intptr_t)def_val);</a>
<a name="ln7760">    } else if (opt-&gt;flags &amp; P_BOOL) {</a>
<a name="ln7761">      type = &quot;boolean&quot;;</a>
<a name="ln7762">      def = BOOL((intptr_t)def_val);</a>
<a name="ln7763">    } else {</a>
<a name="ln7764">      type = &quot;&quot;; def = NIL;</a>
<a name="ln7765">    }</a>
<a name="ln7766">    PUT(dict, &quot;type&quot;, CSTR_TO_OBJ(type));</a>
<a name="ln7767">    PUT(dict, &quot;default&quot;, def);</a>
<a name="ln7768">    PUT(dict, &quot;allows_duplicates&quot;, BOOL(!(opt-&gt;flags &amp; P_NODUP)));</a>
<a name="ln7769"> </a>
<a name="ln7770">    return dict;</a>
<a name="ln7771">}</a>

</code></pre>
<div class="balloon" rel="1451"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'strlen((char *)(errbuf)) - 1' index could reach 18446744073709551615.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
