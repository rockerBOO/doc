
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>funcs.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;float.h&gt;</a>
<a name="ln5">#include &lt;math.h&gt;</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln8">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln9">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln10">#include &quot;nvim/assert.h&quot;</a>
<a name="ln11">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln12">#include &quot;nvim/change.h&quot;</a>
<a name="ln13">#include &quot;nvim/channel.h&quot;</a>
<a name="ln14">#include &quot;nvim/charset.h&quot;</a>
<a name="ln15">#include &quot;nvim/context.h&quot;</a>
<a name="ln16">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln17">#include &quot;nvim/diff.h&quot;</a>
<a name="ln18">#include &quot;nvim/edit.h&quot;</a>
<a name="ln19">#include &quot;nvim/eval.h&quot;</a>
<a name="ln20">#include &quot;nvim/eval/decode.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/executor.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/funcs.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln28">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln29">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln30">#include &quot;nvim/fold.h&quot;</a>
<a name="ln31">#include &quot;nvim/if_cscope.h&quot;</a>
<a name="ln32">#include &quot;nvim/indent.h&quot;</a>
<a name="ln33">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln34">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln35">#include &quot;nvim/macros.h&quot;</a>
<a name="ln36">#include &quot;nvim/mark.h&quot;</a>
<a name="ln37">#include &quot;nvim/math.h&quot;</a>
<a name="ln38">#include &quot;nvim/memline.h&quot;</a>
<a name="ln39">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln40">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln41">#include &quot;nvim/move.h&quot;</a>
<a name="ln42">#include &quot;nvim/msgpack_rpc/channel.h&quot;</a>
<a name="ln43">#include &quot;nvim/msgpack_rpc/server.h&quot;</a>
<a name="ln44">#include &quot;nvim/ops.h&quot;</a>
<a name="ln45">#include &quot;nvim/option.h&quot;</a>
<a name="ln46">#include &quot;nvim/os/dl.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln48">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln49">#include &quot;nvim/path.h&quot;</a>
<a name="ln50">#include &quot;nvim/popupmnu.h&quot;</a>
<a name="ln51">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln52">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln53">#include &quot;nvim/screen.h&quot;</a>
<a name="ln54">#include &quot;nvim/search.h&quot;</a>
<a name="ln55">#include &quot;nvim/sha256.h&quot;</a>
<a name="ln56">#include &quot;nvim/sign.h&quot;</a>
<a name="ln57">#include &quot;nvim/spell.h&quot;</a>
<a name="ln58">#include &quot;nvim/state.h&quot;</a>
<a name="ln59">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln60">#include &quot;nvim/tag.h&quot;</a>
<a name="ln61">#include &quot;nvim/ui.h&quot;</a>
<a name="ln62">#include &quot;nvim/undo.h&quot;</a>
<a name="ln63">#include &quot;nvim/version.h&quot;</a>
<a name="ln64">#include &quot;nvim/vim.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">/// Describe data to return from find_some_match()</a>
<a name="ln68">typedef enum {</a>
<a name="ln69">  kSomeMatch,  ///&lt; Data for match().</a>
<a name="ln70">  kSomeMatchEnd,  ///&lt; Data for matchend().</a>
<a name="ln71">  kSomeMatchList,  ///&lt; Data for matchlist().</a>
<a name="ln72">  kSomeMatchStr,  ///&lt; Data for matchstr().</a>
<a name="ln73">  kSomeMatchStrPos,  ///&lt; Data for matchstrpos().</a>
<a name="ln74">} SomeMatchType;</a>
<a name="ln75"> </a>
<a name="ln76">KHASH_MAP_INIT_STR(functions, VimLFuncDef)</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln80"># include &quot;eval/funcs.c.generated.h&quot;</a>
<a name="ln81"> </a>
<a name="ln82">#ifdef _MSC_VER</a>
<a name="ln83">// This prevents MSVC from replacing the functions with intrinsics,</a>
<a name="ln84">// and causing errors when trying to get their addresses in funcs.generated.h</a>
<a name="ln85">#pragma function(ceil)</a>
<a name="ln86">#pragma function(floor)</a>
<a name="ln87">#endif</a>
<a name="ln88"> </a>
<a name="ln89">PRAGMA_DIAG_PUSH_IGNORE_MISSING_PROTOTYPES</a>
<a name="ln90">PRAGMA_DIAG_PUSH_IGNORE_IMPLICIT_FALLTHROUGH</a>
<a name="ln91">#include &quot;funcs.generated.h&quot;</a>
<a name="ln92">PRAGMA_DIAG_POP</a>
<a name="ln93">PRAGMA_DIAG_POP</a>
<a name="ln94">#endif</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">static char *e_listarg = N_(&quot;E686: Argument of %s must be a List&quot;);</a>
<a name="ln98">static char *e_invalwindow = N_(&quot;E957: Invalid window number&quot;);</a>
<a name="ln99"> </a>
<a name="ln100">/// Dummy va_list for passing to vim_snprintf</a>
<a name="ln101">///</a>
<a name="ln102">/// Used because:</a>
<a name="ln103">/// - passing a NULL pointer doesn't work when va_list isn't a pointer</a>
<a name="ln104">/// - locally in the function results in a &quot;used before set&quot; warning</a>
<a name="ln105">/// - using va_start() to initialize it gives &quot;function with fixed args&quot; error</a>
<a name="ln106">static va_list dummy_ap;</a>
<a name="ln107"> </a>
<a name="ln108"> </a>
<a name="ln109">/// Function given to ExpandGeneric() to obtain the list of internal</a>
<a name="ln110">/// or user defined function names.</a>
<a name="ln111">char_u *get_function_name(expand_T *xp, int idx)</a>
<a name="ln112">{</a>
<a name="ln113">  static int intidx = -1;</a>
<a name="ln114">  char_u *name;</a>
<a name="ln115"> </a>
<a name="ln116">  if (idx == 0)</a>
<a name="ln117">    intidx = -1;</a>
<a name="ln118">  if (intidx &lt; 0) {</a>
<a name="ln119">    name = get_user_func_name(xp, idx);</a>
<a name="ln120">    if (name != NULL) {</a>
<a name="ln121">      if (*name != '&lt;' &amp;&amp; STRNCMP(&quot;g:&quot;, xp-&gt;xp_pattern, 2) == 0) {</a>
<a name="ln122">        return cat_prefix_varname('g', name);</a>
<a name="ln123">      }</a>
<a name="ln124">      return name;</a>
<a name="ln125">    }</a>
<a name="ln126">  }</a>
<a name="ln127">  while ((size_t)++intidx &lt; ARRAY_SIZE(functions)</a>
<a name="ln128">         &amp;&amp; functions[intidx].name[0] == '\0') {</a>
<a name="ln129">  }</a>
<a name="ln130"> </a>
<a name="ln131">  if ((size_t)intidx &gt;= ARRAY_SIZE(functions)) {</a>
<a name="ln132">    return NULL;</a>
<a name="ln133">  }</a>
<a name="ln134"> </a>
<a name="ln135">  const char *const key = functions[intidx].name;</a>
<a name="ln136">  const size_t key_len = strlen(key);</a>
<a name="ln137">  memcpy(IObuff, key, key_len);</a>
<a name="ln138">  IObuff[key_len] = '(';</a>
<a name="ln139">  if (functions[intidx].max_argc == 0) {</a>
<a name="ln140">    IObuff[key_len + 1] = ')';</a>
<a name="ln141">    IObuff[key_len + 2] = NUL;</a>
<a name="ln142">  } else {</a>
<a name="ln143">    IObuff[key_len + 1] = NUL;</a>
<a name="ln144">  }</a>
<a name="ln145">  return IObuff;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">/// Function given to ExpandGeneric() to obtain the list of internal or</a>
<a name="ln149">/// user defined variable or function names.</a>
<a name="ln150">char_u *get_expr_name(expand_T *xp, int idx)</a>
<a name="ln151">{</a>
<a name="ln152">  static int intidx = -1;</a>
<a name="ln153">  char_u *name;</a>
<a name="ln154"> </a>
<a name="ln155">  if (idx == 0)</a>
<a name="ln156">    intidx = -1;</a>
<a name="ln157">  if (intidx &lt; 0) {</a>
<a name="ln158">    name = get_function_name(xp, idx);</a>
<a name="ln159">    if (name != NULL)</a>
<a name="ln160">      return name;</a>
<a name="ln161">  }</a>
<a name="ln162">  return get_user_var_name(xp, ++intidx);</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">/// Find internal function in hash functions</a>
<a name="ln166">///</a>
<a name="ln167">/// @param[in]  name  Name of the function.</a>
<a name="ln168">///</a>
<a name="ln169">/// Returns pointer to the function definition or NULL if not found.</a>
<a name="ln170">const VimLFuncDef *find_internal_func(const char *const name)</a>
<a name="ln171">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL</a>
<a name="ln172">{</a>
<a name="ln173">  size_t len = strlen(name);</a>
<a name="ln174">  return find_internal_func_gperf(name, len);</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">/*</a>
<a name="ln178"> * Return TRUE for a non-zero Number and a non-empty String.</a>
<a name="ln179"> */</a>
<a name="ln180">static int non_zero_arg(typval_T *argvars)</a>
<a name="ln181">{</a>
<a name="ln182">  return ((argvars[0].v_type == VAR_NUMBER</a>
<a name="ln183">           &amp;&amp; argvars[0].vval.v_number != 0)</a>
<a name="ln184">          || (argvars[0].v_type == VAR_BOOL</a>
<a name="ln185">              &amp;&amp; argvars[0].vval.v_bool == kBoolVarTrue)</a>
<a name="ln186">          || (argvars[0].v_type == VAR_STRING</a>
<a name="ln187">              &amp;&amp; argvars[0].vval.v_string != NULL</a>
<a name="ln188">              &amp;&amp; *argvars[0].vval.v_string != NUL));</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">// Apply a floating point C function on a typval with one float_T.</a>
<a name="ln192">//</a>
<a name="ln193">// Some versions of glibc on i386 have an optimization that makes it harder to</a>
<a name="ln194">// call math functions indirectly from inside an inlined function, causing</a>
<a name="ln195">// compile-time errors. Avoid `inline` in that case. #3072</a>
<a name="ln196">static void float_op_wrapper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln197">{</a>
<a name="ln198">  float_T f;</a>
<a name="ln199">  float_T (*function)(float_T) = (float_T (*)(float_T))fptr;</a>
<a name="ln200"> </a>
<a name="ln201">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln202">  if (tv_get_float_chk(argvars, &amp;f)) {</a>
<a name="ln203">    rettv-&gt;vval.v_float = function(f);</a>
<a name="ln204">  } else {</a>
<a name="ln205">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln206">  }</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">static void api_wrapper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln210">{</a>
<a name="ln211">  if (check_secure()) {</a>
<a name="ln212">    return;</a>
<a name="ln213">  }</a>
<a name="ln214"> </a>
<a name="ln215">  ApiDispatchWrapper fn = (ApiDispatchWrapper)fptr;</a>
<a name="ln216"> </a>
<a name="ln217">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln218"> </a>
<a name="ln219">  for (typval_T *tv = argvars; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln220">    ADD(args, vim_to_object(tv));</a>
<a name="ln221">  }</a>
<a name="ln222"> </a>
<a name="ln223">  Error err = ERROR_INIT;</a>
<a name="ln224">  Object result = fn(VIML_INTERNAL_CALL, args, &amp;err);</a>
<a name="ln225"> </a>
<a name="ln226">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln227">    emsgf_multiline((const char *)e_api_error, err.msg);</a>
<a name="ln228">    goto end;</a>
<a name="ln229">  }</a>
<a name="ln230"> </a>
<a name="ln231">  if (!object_to_vim(result, rettv, &amp;err)) {</a>
<a name="ln232">    EMSG2(_(&quot;Error converting the call result: %s&quot;), err.msg);</a>
<a name="ln233">  }</a>
<a name="ln234"> </a>
<a name="ln235">end:</a>
<a name="ln236">  api_free_array(args);</a>
<a name="ln237">  api_free_object(result);</a>
<a name="ln238">  api_clear_error(&amp;err);</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">/*</a>
<a name="ln242"> * &quot;abs(expr)&quot; function</a>
<a name="ln243"> */</a>
<a name="ln244">static void f_abs(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln245">{</a>
<a name="ln246">  if (argvars[0].v_type == VAR_FLOAT) {</a>
<a name="ln247">    float_op_wrapper(argvars, rettv, (FunPtr)&amp;fabs);</a>
<a name="ln248">  } else {</a>
<a name="ln249">    varnumber_T n;</a>
<a name="ln250">    bool error = false;</a>
<a name="ln251"> </a>
<a name="ln252">    n = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln253">    if (error) {</a>
<a name="ln254">      rettv-&gt;vval.v_number = -1;</a>
<a name="ln255">    } else if (n &gt; 0) {</a>
<a name="ln256">      rettv-&gt;vval.v_number = n;</a>
<a name="ln257">    } else {</a>
<a name="ln258">      rettv-&gt;vval.v_number = -n;</a>
<a name="ln259">    }</a>
<a name="ln260">  }</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">/*</a>
<a name="ln264"> * &quot;add(list, item)&quot; function</a>
<a name="ln265"> */</a>
<a name="ln266">static void f_add(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln267">{</a>
<a name="ln268">  rettv-&gt;vval.v_number = 1;  // Default: failed.</a>
<a name="ln269">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln270">    list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln271">    if (!var_check_lock(tv_list_locked(l), N_(&quot;add() argument&quot;),</a>
<a name="ln272">                        TV_TRANSLATE)) {</a>
<a name="ln273">      tv_list_append_tv(l, &amp;argvars[1]);</a>
<a name="ln274">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln275">    }</a>
<a name="ln276">  } else {</a>
<a name="ln277">    EMSG(_(e_listreq));</a>
<a name="ln278">  }</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">/*</a>
<a name="ln282"> * &quot;and(expr, expr)&quot; function</a>
<a name="ln283"> */</a>
<a name="ln284">static void f_and(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln285">{</a>
<a name="ln286">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln287">                         &amp; tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290"> </a>
<a name="ln291">/// &quot;api_info()&quot; function</a>
<a name="ln292">static void f_api_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln293">{</a>
<a name="ln294">  Dictionary metadata = api_metadata();</a>
<a name="ln295">  (void)object_to_vim(DICTIONARY_OBJ(metadata), rettv, NULL);</a>
<a name="ln296">  api_free_dictionary(metadata);</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">// &quot;append(lnum, string/list)&quot; function</a>
<a name="ln300">static void f_append(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln301">{</a>
<a name="ln302">  const linenr_T lnum = tv_get_lnum(&amp;argvars[0]);</a>
<a name="ln303"> </a>
<a name="ln304">  set_buffer_lines(curbuf, lnum, true, &amp;argvars[1], rettv);</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">// &quot;appendbufline(buf, lnum, string/list)&quot; function</a>
<a name="ln308">static void f_appendbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln309">{</a>
<a name="ln310">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln311">  if (buf == NULL) {</a>
<a name="ln312">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln313">  } else {</a>
<a name="ln314">    const linenr_T lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln315">    set_buffer_lines(buf, lnum, true, &amp;argvars[2], rettv);</a>
<a name="ln316">  }</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">static void f_argc(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln320">{</a>
<a name="ln321">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln322">    // use the current window</a>
<a name="ln323">    rettv-&gt;vval.v_number = ARGCOUNT;</a>
<a name="ln324">  } else if (argvars[0].v_type == VAR_NUMBER</a>
<a name="ln325">             &amp;&amp; tv_get_number(&amp;argvars[0]) == -1) {</a>
<a name="ln326">    // use the global argument list</a>
<a name="ln327">    rettv-&gt;vval.v_number = GARGCOUNT;</a>
<a name="ln328">  } else {</a>
<a name="ln329">    // use the argument list of the specified window</a>
<a name="ln330">    win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln331">    if (wp != NULL) {</a>
<a name="ln332">      rettv-&gt;vval.v_number = WARGCOUNT(wp);</a>
<a name="ln333">    } else {</a>
<a name="ln334">      rettv-&gt;vval.v_number = -1;</a>
<a name="ln335">    }</a>
<a name="ln336">  }</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">/*</a>
<a name="ln340"> * &quot;argidx()&quot; function</a>
<a name="ln341"> */</a>
<a name="ln342">static void f_argidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln343">{</a>
<a name="ln344">  rettv-&gt;vval.v_number = curwin-&gt;w_arg_idx;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347">/// &quot;arglistid&quot; function</a>
<a name="ln348">static void f_arglistid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln349">{</a>
<a name="ln350">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln351">  win_T *wp = find_tabwin(&amp;argvars[0], &amp;argvars[1]);</a>
<a name="ln352">  if (wp != NULL) {</a>
<a name="ln353">    rettv-&gt;vval.v_number = wp-&gt;w_alist-&gt;id;</a>
<a name="ln354">  }</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">/*</a>
<a name="ln358"> * &quot;argv(nr)&quot; function</a>
<a name="ln359"> */</a>
<a name="ln360">static void f_argv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln361">{</a>
<a name="ln362">  aentry_T *arglist = NULL;</a>
<a name="ln363">  int argcount = -1;</a>
<a name="ln364"> </a>
<a name="ln365">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln366">    if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln367">      arglist = ARGLIST;</a>
<a name="ln368">      argcount = ARGCOUNT;</a>
<a name="ln369">    } else if (argvars[1].v_type == VAR_NUMBER</a>
<a name="ln370">               &amp;&amp; tv_get_number(&amp;argvars[1]) == -1) {</a>
<a name="ln371">      arglist = GARGLIST;</a>
<a name="ln372">      argcount = GARGCOUNT;</a>
<a name="ln373">    } else {</a>
<a name="ln374">      win_T *wp = find_win_by_nr_or_id(&amp;argvars[1]);</a>
<a name="ln375">      if (wp != NULL) {</a>
<a name="ln376">        // Use the argument list of the specified window</a>
<a name="ln377">        arglist = WARGLIST(wp);</a>
<a name="ln378">        argcount = WARGCOUNT(wp);</a>
<a name="ln379">      }</a>
<a name="ln380">    }</a>
<a name="ln381">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln382">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln383">    int idx = tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln384">    if (arglist != NULL &amp;&amp; idx &gt;= 0 &amp;&amp; idx &lt; argcount) {</a>
<a name="ln385">      rettv-&gt;vval.v_string = (char_u *)xstrdup(</a>
<a name="ln386">          (const char *)alist_name(&amp;arglist[idx]));</a>
<a name="ln387">    } else if (idx == -1) {</a>
<a name="ln388">      get_arglist_as_rettv(arglist, argcount, rettv);</a>
<a name="ln389">    }</a>
<a name="ln390">  } else {</a>
<a name="ln391">    get_arglist_as_rettv(ARGLIST, ARGCOUNT, rettv);</a>
<a name="ln392">  }</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">// &quot;assert_beeps(cmd [, error])&quot; function</a>
<a name="ln396">static void f_assert_beeps(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln397">{</a>
<a name="ln398">  rettv-&gt;vval.v_number = assert_beeps(argvars, false);</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">// &quot;assert_nobeep(cmd [, error])&quot; function</a>
<a name="ln402">static void f_assert_nobeep(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln403">{</a>
<a name="ln404">  rettv-&gt;vval.v_number = assert_beeps(argvars, true);</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">// &quot;assert_equal(expected, actual[, msg])&quot; function</a>
<a name="ln408">static void f_assert_equal(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln409">{</a>
<a name="ln410">  rettv-&gt;vval.v_number = assert_equal_common(argvars, ASSERT_EQUAL);</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">// &quot;assert_equalfile(fname-one, fname-two[, msg])&quot; function</a>
<a name="ln414">static void f_assert_equalfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln415">{</a>
<a name="ln416">  rettv-&gt;vval.v_number = assert_equalfile(argvars);</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">// &quot;assert_notequal(expected, actual[, msg])&quot; function</a>
<a name="ln420">static void f_assert_notequal(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln421">{</a>
<a name="ln422">  rettv-&gt;vval.v_number = assert_equal_common(argvars, ASSERT_NOTEQUAL);</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">/// &quot;assert_report(msg)</a>
<a name="ln426">static void f_assert_report(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln427">{</a>
<a name="ln428">    garray_T ga;</a>
<a name="ln429"> </a>
<a name="ln430">    prepare_assert_error(&amp;ga);</a>
<a name="ln431">    ga_concat(&amp;ga, (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln432">    assert_error(&amp;ga);</a>
<a name="ln433">    ga_clear(&amp;ga);</a>
<a name="ln434">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">/// &quot;assert_exception(string[, msg])&quot; function</a>
<a name="ln438">static void f_assert_exception(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln439">{</a>
<a name="ln440">  rettv-&gt;vval.v_number = assert_exception(argvars);</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">/// &quot;assert_fails(cmd [, error [, msg]])&quot; function</a>
<a name="ln444">static void f_assert_fails(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln445">{</a>
<a name="ln446">  rettv-&gt;vval.v_number = assert_fails(argvars);</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">// &quot;assert_false(actual[, msg])&quot; function</a>
<a name="ln450">static void f_assert_false(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln451">{</a>
<a name="ln452">  rettv-&gt;vval.v_number = assert_bool(argvars, false);</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">/// &quot;assert_inrange(lower, upper[, msg])&quot; function</a>
<a name="ln456">static void f_assert_inrange(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln457">{</a>
<a name="ln458">  rettv-&gt;vval.v_number = assert_inrange(argvars);</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461">/// &quot;assert_match(pattern, actual[, msg])&quot; function</a>
<a name="ln462">static void f_assert_match(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln463">{</a>
<a name="ln464">  rettv-&gt;vval.v_number = assert_match_common(argvars, ASSERT_MATCH);</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">/// &quot;assert_notmatch(pattern, actual[, msg])&quot; function</a>
<a name="ln468">static void f_assert_notmatch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln469">{</a>
<a name="ln470">  rettv-&gt;vval.v_number = assert_match_common(argvars, ASSERT_NOTMATCH);</a>
<a name="ln471">}</a>
<a name="ln472"> </a>
<a name="ln473">// &quot;assert_true(actual[, msg])&quot; function</a>
<a name="ln474">static void f_assert_true(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln475">{</a>
<a name="ln476">  rettv-&gt;vval.v_number = assert_bool(argvars, true);</a>
<a name="ln477">}</a>
<a name="ln478"> </a>
<a name="ln479">/*</a>
<a name="ln480"> * &quot;atan2()&quot; function</a>
<a name="ln481"> */</a>
<a name="ln482">static void f_atan2(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln483">{</a>
<a name="ln484">  float_T fx;</a>
<a name="ln485">  float_T fy;</a>
<a name="ln486"> </a>
<a name="ln487">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln488">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln489">    rettv-&gt;vval.v_float = atan2(fx, fy);</a>
<a name="ln490">  } else {</a>
<a name="ln491">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln492">  }</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495">/*</a>
<a name="ln496"> * &quot;browse(save, title, initdir, default)&quot; function</a>
<a name="ln497"> */</a>
<a name="ln498">static void f_browse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln499">{</a>
<a name="ln500">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln501">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">/*</a>
<a name="ln505"> * &quot;browsedir(title, initdir)&quot; function</a>
<a name="ln506"> */</a>
<a name="ln507">static void f_browsedir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln508">{</a>
<a name="ln509">  f_browse(argvars, rettv, NULL);</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512"> </a>
<a name="ln513">/*</a>
<a name="ln514"> * Find a buffer by number or exact name.</a>
<a name="ln515"> */</a>
<a name="ln516">static buf_T *find_buffer(typval_T *avar)</a>
<a name="ln517">{</a>
<a name="ln518">  buf_T       *buf = NULL;</a>
<a name="ln519"> </a>
<a name="ln520">  if (avar-&gt;v_type == VAR_NUMBER)</a>
<a name="ln521">    buf = buflist_findnr((int)avar-&gt;vval.v_number);</a>
<a name="ln522">  else if (avar-&gt;v_type == VAR_STRING &amp;&amp; avar-&gt;vval.v_string != NULL) {</a>
<a name="ln523">    buf = buflist_findname_exp(avar-&gt;vval.v_string);</a>
<a name="ln524">    if (buf == NULL) {</a>
<a name="ln525">      /* No full path name match, try a match with a URL or a &quot;nofile&quot;</a>
<a name="ln526">       * buffer, these don't use the full path. */</a>
<a name="ln527">      FOR_ALL_BUFFERS(bp) {</a>
<a name="ln528">        if (bp-&gt;b_fname != NULL</a>
<a name="ln529">            &amp;&amp; (path_with_url((char *)bp-&gt;b_fname)</a>
<a name="ln530">                || bt_nofile(bp)</a>
<a name="ln531">                )</a>
<a name="ln532">            &amp;&amp; STRCMP(bp-&gt;b_fname, avar-&gt;vval.v_string) == 0) {</a>
<a name="ln533">          buf = bp;</a>
<a name="ln534">          break;</a>
<a name="ln535">        }</a>
<a name="ln536">      }</a>
<a name="ln537">    }</a>
<a name="ln538">  }</a>
<a name="ln539">  return buf;</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">// &quot;bufadd(expr)&quot; function</a>
<a name="ln543">static void f_bufadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln544">{</a>
<a name="ln545">  char_u *name = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln546"> </a>
<a name="ln547">  rettv-&gt;vval.v_number = buflist_add(*name == NUL ? NULL : name, 0);</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550">/*</a>
<a name="ln551"> * &quot;bufexists(expr)&quot; function</a>
<a name="ln552"> */</a>
<a name="ln553">static void f_bufexists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln554">{</a>
<a name="ln555">  rettv-&gt;vval.v_number = (find_buffer(&amp;argvars[0]) != NULL);</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">/*</a>
<a name="ln559"> * &quot;buflisted(expr)&quot; function</a>
<a name="ln560"> */</a>
<a name="ln561">static void f_buflisted(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln562">{</a>
<a name="ln563">  buf_T       *buf;</a>
<a name="ln564"> </a>
<a name="ln565">  buf = find_buffer(&amp;argvars[0]);</a>
<a name="ln566">  rettv-&gt;vval.v_number = (buf != NULL &amp;&amp; buf-&gt;b_p_bl);</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">// &quot;bufload(expr)&quot; function</a>
<a name="ln570">static void f_bufload(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln571">{</a>
<a name="ln572">  buf_T *buf = get_buf_arg(&amp;argvars[0]);</a>
<a name="ln573"> </a>
<a name="ln574">  if (buf != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln575">    aco_save_T aco;</a>
<a name="ln576"> </a>
<a name="ln577">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln578">    swap_exists_action = SEA_NONE;</a>
<a name="ln579">    open_buffer(false, NULL, 0);</a>
<a name="ln580">    aucmd_restbuf(&amp;aco);</a>
<a name="ln581">  }</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">/*</a>
<a name="ln585"> * &quot;bufloaded(expr)&quot; function</a>
<a name="ln586"> */</a>
<a name="ln587">static void f_bufloaded(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln588">{</a>
<a name="ln589">  buf_T       *buf;</a>
<a name="ln590"> </a>
<a name="ln591">  buf = find_buffer(&amp;argvars[0]);</a>
<a name="ln592">  rettv-&gt;vval.v_number = (buf != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp != NULL);</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595">/*</a>
<a name="ln596"> * &quot;bufname(expr)&quot; function</a>
<a name="ln597"> */</a>
<a name="ln598">static void f_bufname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln599">{</a>
<a name="ln600">  const buf_T *buf;</a>
<a name="ln601">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln602">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln603">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln604">    buf = curbuf;</a>
<a name="ln605">  } else {</a>
<a name="ln606">    buf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln607">  }</a>
<a name="ln608">  if (buf != NULL &amp;&amp; buf-&gt;b_fname != NULL) {</a>
<a name="ln609">    rettv-&gt;vval.v_string = (char_u *)xstrdup((char *)buf-&gt;b_fname);</a>
<a name="ln610">  }</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">/*</a>
<a name="ln614"> * &quot;bufnr(expr)&quot; function</a>
<a name="ln615"> */</a>
<a name="ln616">static void f_bufnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln617">{</a>
<a name="ln618">  const buf_T *buf;</a>
<a name="ln619">  bool error = false;</a>
<a name="ln620"> </a>
<a name="ln621">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln622"> </a>
<a name="ln623">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln624">    buf = curbuf;</a>
<a name="ln625">  } else {</a>
<a name="ln626">    // Don't use tv_get_buf_from_arg(); we continue if the buffer wasn't found</a>
<a name="ln627">    // and the second argument isn't zero, but we want to return early if the</a>
<a name="ln628">    // first argument isn't a string or number so only one error is shown.</a>
<a name="ln629">    if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln630">      return;</a>
<a name="ln631">    }</a>
<a name="ln632">    emsg_off++;</a>
<a name="ln633">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln634">    emsg_off--;</a>
<a name="ln635">  }</a>
<a name="ln636"> </a>
<a name="ln637">  // If the buffer isn't found and the second argument is not zero create a</a>
<a name="ln638">  // new buffer.</a>
<a name="ln639">  const char *name;</a>
<a name="ln640">  if (buf == NULL</a>
<a name="ln641">      &amp;&amp; argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln642">      &amp;&amp; tv_get_number_chk(&amp;argvars[1], &amp;error) != 0</a>
<a name="ln643">      &amp;&amp; !error</a>
<a name="ln644">      &amp;&amp; (name = tv_get_string_chk(&amp;argvars[0])) != NULL) {</a>
<a name="ln645">    buf = buflist_new((char_u *)name, NULL, 1, 0);</a>
<a name="ln646">  }</a>
<a name="ln647"> </a>
<a name="ln648">  if (buf != NULL) {</a>
<a name="ln649">    rettv-&gt;vval.v_number = buf-&gt;b_fnum;</a>
<a name="ln650">  }</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653">static void buf_win_common(typval_T *argvars, typval_T *rettv, bool get_nr)</a>
<a name="ln654">{</a>
<a name="ln655">  const buf_T *const buf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln656">  if (buf == NULL) {  // no need to search if invalid arg or buffer not found</a>
<a name="ln657">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln658">    return;</a>
<a name="ln659">  }</a>
<a name="ln660"> </a>
<a name="ln661">  int winnr = 0;</a>
<a name="ln662">  int winid;</a>
<a name="ln663">  bool found_buf = false;</a>
<a name="ln664">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln665">    winnr++;</a>
<a name="ln666">    if (wp-&gt;w_buffer == buf) {</a>
<a name="ln667">      found_buf = true;</a>
<a name="ln668">      winid = wp-&gt;handle;</a>
<a name="ln669">      break;</a>
<a name="ln670">    }</a>
<a name="ln671">  }</a>
<a name="ln672">  rettv-&gt;vval.v_number = (found_buf ? (get_nr ? winnr : winid) : -1);</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675">/// &quot;bufwinid(nr)&quot; function</a>
<a name="ln676">static void f_bufwinid(typval_T *argvars, typval_T *rettv, FunPtr fptr) {</a>
<a name="ln677">  buf_win_common(argvars, rettv, false);</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">/// &quot;bufwinnr(nr)&quot; function</a>
<a name="ln681">static void f_bufwinnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln682">{</a>
<a name="ln683">  buf_win_common(argvars, rettv, true);</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686">/*</a>
<a name="ln687"> * Get buffer by number or pattern.</a>
<a name="ln688"> */</a>
<a name="ln689">buf_T *tv_get_buf(typval_T *tv, int curtab_only)</a>
<a name="ln690">{</a>
<a name="ln691">  char_u      *name = tv-&gt;vval.v_string;</a>
<a name="ln692">  int save_magic;</a>
<a name="ln693">  char_u      *save_cpo;</a>
<a name="ln694">  buf_T       *buf;</a>
<a name="ln695"> </a>
<a name="ln696">  if (tv-&gt;v_type == VAR_NUMBER)</a>
<a name="ln697">    return buflist_findnr((int)tv-&gt;vval.v_number);</a>
<a name="ln698">  if (tv-&gt;v_type != VAR_STRING)</a>
<a name="ln699">    return NULL;</a>
<a name="ln700">  if (name == NULL || *name == NUL)</a>
<a name="ln701">    return curbuf;</a>
<a name="ln702">  if (name[0] == '$' &amp;&amp; name[1] == NUL)</a>
<a name="ln703">    return lastbuf;</a>
<a name="ln704"> </a>
<a name="ln705">  // Ignore 'magic' and 'cpoptions' here to make scripts portable</a>
<a name="ln706">  save_magic = p_magic;</a>
<a name="ln707">  p_magic = TRUE;</a>
<a name="ln708">  save_cpo = p_cpo;</a>
<a name="ln709">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln710"> </a>
<a name="ln711">  buf = buflist_findnr(buflist_findpat(name, name + STRLEN(name),</a>
<a name="ln712">                                       true, false, curtab_only));</a>
<a name="ln713"> </a>
<a name="ln714">  p_magic = save_magic;</a>
<a name="ln715">  p_cpo = save_cpo;</a>
<a name="ln716"> </a>
<a name="ln717">  // If not found, try expanding the name, like done for bufexists().</a>
<a name="ln718">  if (buf == NULL) {</a>
<a name="ln719">    buf = find_buffer(tv);</a>
<a name="ln720">  }</a>
<a name="ln721"> </a>
<a name="ln722">  return buf;</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725">/// Like tv_get_buf() but give an error message if the type is wrong.</a>
<a name="ln726">buf_T *tv_get_buf_from_arg(typval_T *const tv) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln727">{</a>
<a name="ln728">  if (!tv_check_str_or_nr(tv)) {</a>
<a name="ln729">    return NULL;</a>
<a name="ln730">  }</a>
<a name="ln731">  emsg_off++;</a>
<a name="ln732">  buf_T *const buf = tv_get_buf(tv, false);</a>
<a name="ln733">  emsg_off--;</a>
<a name="ln734">  return buf;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">/// Get the buffer from &quot;arg&quot; and give an error and return NULL if it is not</a>
<a name="ln738">/// valid.</a>
<a name="ln739">buf_T * get_buf_arg(typval_T *arg)</a>
<a name="ln740">{</a>
<a name="ln741">  buf_T *buf;</a>
<a name="ln742"> </a>
<a name="ln743">  emsg_off++;</a>
<a name="ln744">  buf = tv_get_buf(arg, false);</a>
<a name="ln745">  emsg_off--;</a>
<a name="ln746">  if (buf == NULL) {</a>
<a name="ln747">    EMSG2(_(&quot;E158: Invalid buffer name: %s&quot;), tv_get_string(arg));</a>
<a name="ln748">  }</a>
<a name="ln749">  return buf;</a>
<a name="ln750">}</a>
<a name="ln751"> </a>
<a name="ln752">/*</a>
<a name="ln753"> * &quot;byte2line(byte)&quot; function</a>
<a name="ln754"> */</a>
<a name="ln755">static void f_byte2line(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln756">{</a>
<a name="ln757">  long boff = tv_get_number(&amp;argvars[0]) - 1;</a>
<a name="ln758">  if (boff &lt; 0) {</a>
<a name="ln759">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln760">  } else {</a>
<a name="ln761">    rettv-&gt;vval.v_number = (varnumber_T)ml_find_line_or_offset(curbuf, 0,</a>
<a name="ln762">                                                               &amp;boff, false);</a>
<a name="ln763">  }</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766">static void byteidx(typval_T *argvars, typval_T *rettv, int comp)</a>
<a name="ln767">{</a>
<a name="ln768">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln769">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln770">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln771">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln772">    return;</a>
<a name="ln773">  }</a>
<a name="ln774"> </a>
<a name="ln775">  const char *t = str;</a>
<a name="ln776">  for (; idx &gt; 0; idx--) {</a>
<a name="ln777">    if (*t == NUL) {  // EOL reached.</a>
<a name="ln778">      return;</a>
<a name="ln779">    }</a>
<a name="ln780">    if (comp) {</a>
<a name="ln781">      t += utf_ptr2len((const char_u *)t);</a>
<a name="ln782">    } else {</a>
<a name="ln783">      t += utfc_ptr2len((const char_u *)t);</a>
<a name="ln784">    }</a>
<a name="ln785">  }</a>
<a name="ln786">  rettv-&gt;vval.v_number = (varnumber_T)(t - str);</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">/*</a>
<a name="ln790"> * &quot;byteidx()&quot; function</a>
<a name="ln791"> */</a>
<a name="ln792">static void f_byteidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln793">{</a>
<a name="ln794">  byteidx(argvars, rettv, FALSE);</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797">/*</a>
<a name="ln798"> * &quot;byteidxcomp()&quot; function</a>
<a name="ln799"> */</a>
<a name="ln800">static void f_byteidxcomp(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln801">{</a>
<a name="ln802">  byteidx(argvars, rettv, TRUE);</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">/// &quot;call(func, arglist [, dict])&quot; function</a>
<a name="ln806">static void f_call(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln807">{</a>
<a name="ln808">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln809">    EMSG(_(e_listreq));</a>
<a name="ln810">    return;</a>
<a name="ln811">  }</a>
<a name="ln812">  if (argvars[1].vval.v_list == NULL) {</a>
<a name="ln813">    return;</a>
<a name="ln814">  }</a>
<a name="ln815"> </a>
<a name="ln816">  bool owned = false;</a>
<a name="ln817">  char_u      *func;</a>
<a name="ln818">  partial_T   *partial = NULL;</a>
<a name="ln819">  dict_T      *selfdict = NULL;</a>
<a name="ln820">  if (argvars[0].v_type == VAR_FUNC) {</a>
<a name="ln821">    func = argvars[0].vval.v_string;</a>
<a name="ln822">  } else if (argvars[0].v_type == VAR_PARTIAL) {</a>
<a name="ln823">    partial = argvars[0].vval.v_partial;</a>
<a name="ln824">    func = partial_name(partial);</a>
<a name="ln825">  } else if (nlua_is_table_from_lua(&amp;argvars[0])) {</a>
<a name="ln826">    func = nlua_register_table_as_callable(&amp;argvars[0]);</a>
<a name="ln827">    owned = true;</a>
<a name="ln828">  } else {</a>
<a name="ln829">    func = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln830">  }</a>
<a name="ln831"> </a>
<a name="ln832">  if (*func == NUL) {</a>
<a name="ln833">    return;             // type error or empty name</a>
<a name="ln834">  }</a>
<a name="ln835"> </a>
<a name="ln836">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln837">    if (argvars[2].v_type != VAR_DICT) {</a>
<a name="ln838">      EMSG(_(e_dictreq));</a>
<a name="ln839">      return;</a>
<a name="ln840">    }</a>
<a name="ln841">    selfdict = argvars[2].vval.v_dict;</a>
<a name="ln842">  }</a>
<a name="ln843"> </a>
<a name="ln844">  func_call(func, &amp;argvars[1], partial, selfdict, rettv);</a>
<a name="ln845">  if (owned) {</a>
<a name="ln846">    func_unref(func);</a>
<a name="ln847">  }</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">/*</a>
<a name="ln851"> * &quot;changenr()&quot; function</a>
<a name="ln852"> */</a>
<a name="ln853">static void f_changenr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln854">{</a>
<a name="ln855">  rettv-&gt;vval.v_number = curbuf-&gt;b_u_seq_cur;</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">// &quot;chanclose(id[, stream])&quot; function</a>
<a name="ln859">static void f_chanclose(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln860">{</a>
<a name="ln861">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln862">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln863"> </a>
<a name="ln864">  if (check_secure()) {</a>
<a name="ln865">    return;</a>
<a name="ln866">  }</a>
<a name="ln867"> </a>
<a name="ln868">  if (argvars[0].v_type != VAR_NUMBER || (argvars[1].v_type != VAR_STRING</a>
<a name="ln869">        &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln870">    EMSG(_(e_invarg));</a>
<a name="ln871">    return;</a>
<a name="ln872">  }</a>
<a name="ln873"> </a>
<a name="ln874">  ChannelPart part = kChannelPartAll;</a>
<a name="ln875">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln876">    char *stream = (char *)argvars[1].vval.v_string;</a>
<a name="ln877">    if (!strcmp(stream, &quot;stdin&quot;)) {</a>
<a name="ln878">      part = kChannelPartStdin;</a>
<a name="ln879">    } else if (!strcmp(stream, &quot;stdout&quot;)) {</a>
<a name="ln880">      part = kChannelPartStdout;</a>
<a name="ln881">    } else if (!strcmp(stream, &quot;stderr&quot;)) {</a>
<a name="ln882">      part = kChannelPartStderr;</a>
<a name="ln883">    } else if (!strcmp(stream, &quot;rpc&quot;)) {</a>
<a name="ln884">      part = kChannelPartRpc;</a>
<a name="ln885">    } else {</a>
<a name="ln886">      EMSG2(_(&quot;Invalid channel stream \&quot;%s\&quot;&quot;), stream);</a>
<a name="ln887">      return;</a>
<a name="ln888">    }</a>
<a name="ln889">  }</a>
<a name="ln890">  const char *error;</a>
<a name="ln891">  rettv-&gt;vval.v_number = channel_close(argvars[0].vval.v_number, part, &amp;error);</a>
<a name="ln892">  if (!rettv-&gt;vval.v_number) {</a>
<a name="ln893">    EMSG(error);</a>
<a name="ln894">  }</a>
<a name="ln895">}</a>
<a name="ln896"> </a>
<a name="ln897">// &quot;chansend(id, data)&quot; function</a>
<a name="ln898">static void f_chansend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln899">{</a>
<a name="ln900">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln901">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln902"> </a>
<a name="ln903">  if (check_secure()) {</a>
<a name="ln904">    return;</a>
<a name="ln905">  }</a>
<a name="ln906"> </a>
<a name="ln907">  if (argvars[0].v_type != VAR_NUMBER || argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln908">    // First argument is the channel id and second is the data to write</a>
<a name="ln909">    EMSG(_(e_invarg));</a>
<a name="ln910">    return;</a>
<a name="ln911">  }</a>
<a name="ln912"> </a>
<a name="ln913">  ptrdiff_t input_len = 0;</a>
<a name="ln914">  char *input = save_tv_as_string(&amp;argvars[1], &amp;input_len, false);</a>
<a name="ln915">  if (!input) {</a>
<a name="ln916">    // Either the error has been handled by save_tv_as_string(),</a>
<a name="ln917">    // or there is no input to send.</a>
<a name="ln918">    return;</a>
<a name="ln919">  }</a>
<a name="ln920">  uint64_t id = argvars[0].vval.v_number;</a>
<a name="ln921">  const char *error = NULL;</a>
<a name="ln922">  rettv-&gt;vval.v_number = channel_send(id, input, input_len, true, &amp;error);</a>
<a name="ln923">  if (error) {</a>
<a name="ln924">    EMSG(error);</a>
<a name="ln925">  }</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">/*</a>
<a name="ln929"> * &quot;char2nr(string)&quot; function</a>
<a name="ln930"> */</a>
<a name="ln931">static void f_char2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln932">{</a>
<a name="ln933">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln934">    if (!tv_check_num(&amp;argvars[1])) {</a>
<a name="ln935">      return;</a>
<a name="ln936">    }</a>
<a name="ln937">  }</a>
<a name="ln938"> </a>
<a name="ln939">  rettv-&gt;vval.v_number = utf_ptr2char(</a>
<a name="ln940">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">// &quot;charidx()&quot; function</a>
<a name="ln944">static void f_charidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln945">{</a>
<a name="ln946">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln947"> </a>
<a name="ln948">  if (argvars[0].v_type != VAR_STRING</a>
<a name="ln949">      || argvars[1].v_type != VAR_NUMBER</a>
<a name="ln950">      || (argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln951">          &amp;&amp; argvars[2].v_type != VAR_NUMBER)) {</a>
<a name="ln952">    EMSG(_(e_invarg));</a>
<a name="ln953">    return;</a>
<a name="ln954">  }</a>
<a name="ln955"> </a>
<a name="ln956">  const char *str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln957">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln958">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln959">    return;</a>
<a name="ln960">  }</a>
<a name="ln961">  int countcc = 0;</a>
<a name="ln962">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln963">    countcc = (int)tv_get_number(&amp;argvars[2]);</a>
<a name="ln964">  }</a>
<a name="ln965">  if (countcc &lt; 0 || countcc &gt; 1) {</a>
<a name="ln966">    EMSG(_(e_invarg));</a>
<a name="ln967">    return;</a>
<a name="ln968">  }</a>
<a name="ln969"> </a>
<a name="ln970">  int (*ptr2len)(const char_u *);</a>
<a name="ln971">  if (countcc) {</a>
<a name="ln972">    ptr2len = utf_ptr2len;</a>
<a name="ln973">  } else {</a>
<a name="ln974">    ptr2len = utfc_ptr2len;</a>
<a name="ln975">  }</a>
<a name="ln976"> </a>
<a name="ln977">  const char *p;</a>
<a name="ln978">  int len;</a>
<a name="ln979">  for (p = str, len = 0; p &lt;= str + idx; len++) {</a>
<a name="ln980">    if (*p == NUL) {</a>
<a name="ln981">      return;</a>
<a name="ln982">    }</a>
<a name="ln983">    p += ptr2len((const char_u *)p);</a>
<a name="ln984">  }</a>
<a name="ln985"> </a>
<a name="ln986">  rettv-&gt;vval.v_number = len &gt; 0 ? len - 1 : 0;</a>
<a name="ln987">}</a>
<a name="ln988"> </a>
<a name="ln989">/*</a>
<a name="ln990"> * &quot;cindent(lnum)&quot; function</a>
<a name="ln991"> */</a>
<a name="ln992">static void f_cindent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln993">{</a>
<a name="ln994">  pos_T pos;</a>
<a name="ln995">  linenr_T lnum;</a>
<a name="ln996"> </a>
<a name="ln997">  pos = curwin-&gt;w_cursor;</a>
<a name="ln998">  lnum = tv_get_lnum(argvars);</a>
<a name="ln999">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1000">    curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln1001">    rettv-&gt;vval.v_number = get_c_indent();</a>
<a name="ln1002">    curwin-&gt;w_cursor = pos;</a>
<a name="ln1003">  } else</a>
<a name="ln1004">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln1005">}</a>
<a name="ln1006"> </a>
<a name="ln1007">static win_T * get_optional_window(typval_T *argvars, int idx)</a>
<a name="ln1008">{</a>
<a name="ln1009">  win_T *win = curwin;</a>
<a name="ln1010"> </a>
<a name="ln1011">  if (argvars[idx].v_type != VAR_UNKNOWN) {</a>
<a name="ln1012">    win = find_win_by_nr_or_id(&amp;argvars[idx]);</a>
<a name="ln1013">    if (win == NULL) {</a>
<a name="ln1014">      EMSG(_(e_invalwindow));</a>
<a name="ln1015">      return NULL;</a>
<a name="ln1016">    }</a>
<a name="ln1017">  }</a>
<a name="ln1018">  return win;</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021">/*</a>
<a name="ln1022"> * &quot;clearmatches()&quot; function</a>
<a name="ln1023"> */</a>
<a name="ln1024">static void f_clearmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1025">{</a>
<a name="ln1026">  win_T *win = get_optional_window(argvars, 0);</a>
<a name="ln1027"> </a>
<a name="ln1028">  if (win != NULL) {</a>
<a name="ln1029">    clear_matches(win);</a>
<a name="ln1030">  }</a>
<a name="ln1031">}</a>
<a name="ln1032"> </a>
<a name="ln1033">/*</a>
<a name="ln1034"> * &quot;col(string)&quot; function</a>
<a name="ln1035"> */</a>
<a name="ln1036">static void f_col(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1037">{</a>
<a name="ln1038">  colnr_T col = 0;</a>
<a name="ln1039">  pos_T       *fp;</a>
<a name="ln1040">  int fnum = curbuf-&gt;b_fnum;</a>
<a name="ln1041"> </a>
<a name="ln1042">  fp = var2fpos(&amp;argvars[0], FALSE, &amp;fnum);</a>
<a name="ln1043">  if (fp != NULL &amp;&amp; fnum == curbuf-&gt;b_fnum) {</a>
<a name="ln1044">    if (fp-&gt;col == MAXCOL) {</a>
<a name="ln1045">      // '&gt; can be MAXCOL, get the length of the line then</a>
<a name="ln1046">      if (fp-&gt;lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1047">        col = (colnr_T)STRLEN(ml_get(fp-&gt;lnum)) + 1;</a>
<a name="ln1048">      } else {</a>
<a name="ln1049">        col = MAXCOL;</a>
<a name="ln1050">      }</a>
<a name="ln1051">    } else {</a>
<a name="ln1052">      col = fp-&gt;col + 1;</a>
<a name="ln1053">      // col(&quot;.&quot;) when the cursor is on the NUL at the end of the line</a>
<a name="ln1054">      // because of &quot;coladd&quot; can be seen as an extra column.</a>
<a name="ln1055">      if (virtual_active() &amp;&amp; fp == &amp;curwin-&gt;w_cursor) {</a>
<a name="ln1056">        char_u  *p = get_cursor_pos_ptr();</a>
<a name="ln1057"> </a>
<a name="ln1058">        if (curwin-&gt;w_cursor.coladd &gt;= (colnr_T)chartabsize(p,</a>
<a name="ln1059">                curwin-&gt;w_virtcol - curwin-&gt;w_cursor.coladd)) {</a>
<a name="ln1060">          int l;</a>
<a name="ln1061"> </a>
<a name="ln1062">          if (*p != NUL &amp;&amp; p[(l = (*mb_ptr2len)(p))] == NUL)</a>
<a name="ln1063">            col += l;</a>
<a name="ln1064">        }</a>
<a name="ln1065">      }</a>
<a name="ln1066">    }</a>
<a name="ln1067">  }</a>
<a name="ln1068">  rettv-&gt;vval.v_number = col;</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071">/*</a>
<a name="ln1072"> * &quot;complete()&quot; function</a>
<a name="ln1073"> */</a>
<a name="ln1074">static void f_complete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1075">{</a>
<a name="ln1076">  if ((State &amp; INSERT) == 0) {</a>
<a name="ln1077">    EMSG(_(&quot;E785: complete() can only be used in Insert mode&quot;));</a>
<a name="ln1078">    return;</a>
<a name="ln1079">  }</a>
<a name="ln1080"> </a>
<a name="ln1081">  /* Check for undo allowed here, because if something was already inserted</a>
<a name="ln1082">   * the line was already saved for undo and this check isn't done. */</a>
<a name="ln1083">  if (!undo_allowed())</a>
<a name="ln1084">    return;</a>
<a name="ln1085"> </a>
<a name="ln1086">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln1087">    EMSG(_(e_invarg));</a>
<a name="ln1088">    return;</a>
<a name="ln1089">  }</a>
<a name="ln1090"> </a>
<a name="ln1091">  const colnr_T startcol = tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln1092">  if (startcol &lt;= 0) {</a>
<a name="ln1093">    return;</a>
<a name="ln1094">  }</a>
<a name="ln1095"> </a>
<a name="ln1096">  set_completion(startcol - 1, argvars[1].vval.v_list);</a>
<a name="ln1097">}</a>
<a name="ln1098"> </a>
<a name="ln1099">/*</a>
<a name="ln1100"> * &quot;complete_add()&quot; function</a>
<a name="ln1101"> */</a>
<a name="ln1102">static void f_complete_add(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1103">{</a>
<a name="ln1104">  rettv-&gt;vval.v_number = ins_compl_add_tv(&amp;argvars[0], 0, false);</a>
<a name="ln1105">}</a>
<a name="ln1106"> </a>
<a name="ln1107">/*</a>
<a name="ln1108"> * &quot;complete_check()&quot; function</a>
<a name="ln1109"> */</a>
<a name="ln1110">static void f_complete_check(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1111">{</a>
<a name="ln1112">  int saved = RedrawingDisabled;</a>
<a name="ln1113"> </a>
<a name="ln1114">  RedrawingDisabled = 0;</a>
<a name="ln1115">  ins_compl_check_keys(0, true);</a>
<a name="ln1116">  rettv-&gt;vval.v_number = compl_interrupted;</a>
<a name="ln1117">  RedrawingDisabled = saved;</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">// &quot;complete_info()&quot; function</a>
<a name="ln1121">static void f_complete_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1122">{</a>
<a name="ln1123">  tv_dict_alloc_ret(rettv);</a>
<a name="ln1124"> </a>
<a name="ln1125">  list_T *what_list = NULL;</a>
<a name="ln1126"> </a>
<a name="ln1127">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1128">    if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln1129">      EMSG(_(e_listreq));</a>
<a name="ln1130">      return;</a>
<a name="ln1131">    }</a>
<a name="ln1132">    what_list = argvars[0].vval.v_list;</a>
<a name="ln1133">  }</a>
<a name="ln1134">  get_complete_info(what_list, rettv-&gt;vval.v_dict);</a>
<a name="ln1135">}</a>
<a name="ln1136"> </a>
<a name="ln1137">/*</a>
<a name="ln1138"> * &quot;confirm(message, buttons[, default [, type]])&quot; function</a>
<a name="ln1139"> */</a>
<a name="ln1140">static void f_confirm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1141">{</a>
<a name="ln1142">  char buf[NUMBUFLEN];</a>
<a name="ln1143">  char buf2[NUMBUFLEN];</a>
<a name="ln1144">  const char *message;</a>
<a name="ln1145">  const char *buttons = NULL;</a>
<a name="ln1146">  int def = 1;</a>
<a name="ln1147">  int type = VIM_GENERIC;</a>
<a name="ln1148">  const char *typestr;</a>
<a name="ln1149">  bool error = false;</a>
<a name="ln1150"> </a>
<a name="ln1151">  message = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln1152">  if (message == NULL) {</a>
<a name="ln1153">    error = true;</a>
<a name="ln1154">  }</a>
<a name="ln1155">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1156">    buttons = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln1157">    if (buttons == NULL) {</a>
<a name="ln1158">      error = true;</a>
<a name="ln1159">    }</a>
<a name="ln1160">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1161">      def = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln1162">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1163">        typestr = tv_get_string_buf_chk(&amp;argvars[3], buf2);</a>
<a name="ln1164">        if (typestr == NULL) {</a>
<a name="ln1165">          error = true;</a>
<a name="ln1166">        } else {</a>
<a name="ln1167">          switch (TOUPPER_ASC(*typestr)) {</a>
<a name="ln1168">            case 'E': type = VIM_ERROR; break;</a>
<a name="ln1169">            case 'Q': type = VIM_QUESTION; break;</a>
<a name="ln1170">            case 'I': type = VIM_INFO; break;</a>
<a name="ln1171">            case 'W': type = VIM_WARNING; break;</a>
<a name="ln1172">            case 'G': type = VIM_GENERIC; break;</a>
<a name="ln1173">          }</a>
<a name="ln1174">        }</a>
<a name="ln1175">      }</a>
<a name="ln1176">    }</a>
<a name="ln1177">  }</a>
<a name="ln1178"> </a>
<a name="ln1179">  if (buttons == NULL || *buttons == NUL) {</a>
<a name="ln1180">    buttons = _(&quot;&amp;Ok&quot;);</a>
<a name="ln1181">  }</a>
<a name="ln1182"> </a>
<a name="ln1183">  if (!error) {</a>
<a name="ln1184">    rettv-&gt;vval.v_number = do_dialog(</a>
<a name="ln1185">        type, NULL, (char_u *)message, (char_u *)buttons, def, NULL, false);</a>
<a name="ln1186">  }</a>
<a name="ln1187">}</a>
<a name="ln1188"> </a>
<a name="ln1189">/*</a>
<a name="ln1190"> * &quot;copy()&quot; function</a>
<a name="ln1191"> */</a>
<a name="ln1192">static void f_copy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1193">{</a>
<a name="ln1194">  var_item_copy(NULL, &amp;argvars[0], rettv, false, 0);</a>
<a name="ln1195">}</a>
<a name="ln1196"> </a>
<a name="ln1197">/*</a>
<a name="ln1198"> * &quot;count()&quot; function</a>
<a name="ln1199"> */</a>
<a name="ln1200">static void f_count(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1201">{</a>
<a name="ln1202">  long n = 0;</a>
<a name="ln1203">  int ic = 0;</a>
<a name="ln1204">  bool error = false;</a>
<a name="ln1205"> </a>
<a name="ln1206">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1207">    ic = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln1208">  }</a>
<a name="ln1209"> </a>
<a name="ln1210">  if (argvars[0].v_type == VAR_STRING) {</a>
<a name="ln1211">    const char_u *expr = (char_u *)tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln1212">    const char_u *p = argvars[0].vval.v_string;</a>
<a name="ln1213"> </a>
<a name="ln1214">    if (!error &amp;&amp; expr != NULL &amp;&amp; *expr != NUL &amp;&amp; p != NULL) {</a>
<a name="ln1215">      if (ic) {</a>
<a name="ln1216">        const size_t len = STRLEN(expr);</a>
<a name="ln1217"> </a>
<a name="ln1218">        while (*p != NUL) {</a>
<a name="ln1219">          if (mb_strnicmp(p, expr, len) == 0) {</a>
<a name="ln1220">            n++;</a>
<a name="ln1221">            p += len;</a>
<a name="ln1222">          } else {</a>
<a name="ln1223">            MB_PTR_ADV(p);</a>
<a name="ln1224">          }</a>
<a name="ln1225">        }</a>
<a name="ln1226">      } else {</a>
<a name="ln1227">        char_u *next;</a>
<a name="ln1228">        while ((next = (char_u *)strstr((char *)p, (char *)expr)) != NULL) {</a>
<a name="ln1229">          n++;</a>
<a name="ln1230">          p = next + STRLEN(expr);</a>
<a name="ln1231">        }</a>
<a name="ln1232">      }</a>
<a name="ln1233">    }</a>
<a name="ln1234">  } else if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln1235">    listitem_T      *li;</a>
<a name="ln1236">    list_T          *l;</a>
<a name="ln1237">    long idx;</a>
<a name="ln1238"> </a>
<a name="ln1239">    if ((l = argvars[0].vval.v_list) != NULL) {</a>
<a name="ln1240">      li = tv_list_first(l);</a>
<a name="ln1241">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1242">        if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1243">          idx = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln1244">          if (!error) {</a>
<a name="ln1245">            li = tv_list_find(l, idx);</a>
<a name="ln1246">            if (li == NULL) {</a>
<a name="ln1247">              EMSGN(_(e_listidx), idx);</a>
<a name="ln1248">            }</a>
<a name="ln1249">          }</a>
<a name="ln1250">        }</a>
<a name="ln1251">        if (error)</a>
<a name="ln1252">          li = NULL;</a>
<a name="ln1253">      }</a>
<a name="ln1254"> </a>
<a name="ln1255">      for (; li != NULL; li = TV_LIST_ITEM_NEXT(l, li)) {</a>
<a name="ln1256">        if (tv_equal(TV_LIST_ITEM_TV(li), &amp;argvars[1], ic, false)) {</a>
<a name="ln1257">          n++;</a>
<a name="ln1258">        }</a>
<a name="ln1259">      }</a>
<a name="ln1260">    }</a>
<a name="ln1261">  } else if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln1262">    int todo;</a>
<a name="ln1263">    dict_T          *d;</a>
<a name="ln1264">    hashitem_T      *hi;</a>
<a name="ln1265"> </a>
<a name="ln1266">    if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln1267">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1268">        if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1269">          EMSG(_(e_invarg));</a>
<a name="ln1270">        }</a>
<a name="ln1271">      }</a>
<a name="ln1272"> </a>
<a name="ln1273">      todo = error ? 0 : (int)d-&gt;dv_hashtab.ht_used;</a>
<a name="ln1274">      for (hi = d-&gt;dv_hashtab.ht_array; todo &gt; 0; ++hi) {</a>
<a name="ln1275">        if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1276">          todo--;</a>
<a name="ln1277">          if (tv_equal(&amp;TV_DICT_HI2DI(hi)-&gt;di_tv, &amp;argvars[1], ic, false)) {</a>
<a name="ln1278">            n++;</a>
<a name="ln1279">          }</a>
<a name="ln1280">        }</a>
<a name="ln1281">      }</a>
<a name="ln1282">    }</a>
<a name="ln1283">  } else {</a>
<a name="ln1284">    EMSG2(_(e_listdictarg), &quot;count()&quot;);</a>
<a name="ln1285">  }</a>
<a name="ln1286">  rettv-&gt;vval.v_number = n;</a>
<a name="ln1287">}</a>
<a name="ln1288"> </a>
<a name="ln1289">/*</a>
<a name="ln1290"> * &quot;cscope_connection([{num} , {dbpath} [, {prepend}]])&quot; function</a>
<a name="ln1291"> *</a>
<a name="ln1292"> * Checks the existence of a cscope connection.</a>
<a name="ln1293"> */</a>
<a name="ln1294">static void f_cscope_connection(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1295">{</a>
<a name="ln1296">  int num = 0;</a>
<a name="ln1297">  const char *dbpath = NULL;</a>
<a name="ln1298">  const char *prepend = NULL;</a>
<a name="ln1299">  char buf[NUMBUFLEN];</a>
<a name="ln1300"> </a>
<a name="ln1301">  if (argvars[0].v_type != VAR_UNKNOWN</a>
<a name="ln1302">      &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1303">    num = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln1304">    dbpath = tv_get_string(&amp;argvars[1]);</a>
<a name="ln1305">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1306">      prepend = tv_get_string_buf(&amp;argvars[2], buf);</a>
<a name="ln1307">    }</a>
<a name="ln1308">  }</a>
<a name="ln1309"> </a>
<a name="ln1310">  rettv-&gt;vval.v_number = cs_connection(num, (char_u *)dbpath,</a>
<a name="ln1311">                                       (char_u *)prepend);</a>
<a name="ln1312">}</a>
<a name="ln1313"> </a>
<a name="ln1314">/// &quot;ctxget([{index}])&quot; function</a>
<a name="ln1315">static void f_ctxget(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1316">{</a>
<a name="ln1317">  size_t index = 0;</a>
<a name="ln1318">  if (argvars[0].v_type == VAR_NUMBER) {</a>
<a name="ln1319">    index = argvars[0].vval.v_number;</a>
<a name="ln1320">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1321">    EMSG2(_(e_invarg2), &quot;expected nothing or a Number as an argument&quot;);</a>
<a name="ln1322">    return;</a>
<a name="ln1323">  }</a>
<a name="ln1324"> </a>
<a name="ln1325">  Context *ctx = ctx_get(index);</a>
<a name="ln1326">  if (ctx == NULL) {</a>
<a name="ln1327">    EMSG3(_(e_invargNval), &quot;index&quot;, &quot;out of bounds&quot;);</a>
<a name="ln1328">    return;</a>
<a name="ln1329">  }</a>
<a name="ln1330"> </a>
<a name="ln1331">  Dictionary ctx_dict = ctx_to_dict(ctx);</a>
<a name="ln1332">  Error err = ERROR_INIT;</a>
<a name="ln1333">  object_to_vim(DICTIONARY_OBJ(ctx_dict), rettv, &amp;err);</a>
<a name="ln1334">  api_free_dictionary(ctx_dict);</a>
<a name="ln1335">  api_clear_error(&amp;err);</a>
<a name="ln1336">}</a>
<a name="ln1337"> </a>
<a name="ln1338">/// &quot;ctxpop()&quot; function</a>
<a name="ln1339">static void f_ctxpop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1340">{</a>
<a name="ln1341">  if (!ctx_restore(NULL, kCtxAll)) {</a>
<a name="ln1342">    EMSG(_(&quot;Context stack is empty&quot;));</a>
<a name="ln1343">  }</a>
<a name="ln1344">}</a>
<a name="ln1345"> </a>
<a name="ln1346">/// &quot;ctxpush([{types}])&quot; function</a>
<a name="ln1347">static void f_ctxpush(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1348">{</a>
<a name="ln1349">  int types = kCtxAll;</a>
<a name="ln1350">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln1351">    types = 0;</a>
<a name="ln1352">    TV_LIST_ITER(argvars[0].vval.v_list, li, {</a>
<a name="ln1353">      typval_T *tv_li = TV_LIST_ITEM_TV(li);</a>
<a name="ln1354">      if (tv_li-&gt;v_type == VAR_STRING) {</a>
<a name="ln1355">        if (strequal((char *)tv_li-&gt;vval.v_string, &quot;regs&quot;)) {</a>
<a name="ln1356">          types |= kCtxRegs;</a>
<a name="ln1357">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;jumps&quot;)) {</a>
<a name="ln1358">          types |= kCtxJumps;</a>
<a name="ln1359">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;bufs&quot;)) {</a>
<a name="ln1360">          types |= kCtxBufs;</a>
<a name="ln1361">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;gvars&quot;)) {</a>
<a name="ln1362">          types |= kCtxGVars;</a>
<a name="ln1363">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;sfuncs&quot;)) {</a>
<a name="ln1364">          types |= kCtxSFuncs;</a>
<a name="ln1365">        } else if (strequal((char *)tv_li-&gt;vval.v_string, &quot;funcs&quot;)) {</a>
<a name="ln1366">          types |= kCtxFuncs;</a>
<a name="ln1367">        }</a>
<a name="ln1368">      }</a>
<a name="ln1369">    });</a>
<a name="ln1370">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln1371">    EMSG2(_(e_invarg2), &quot;expected nothing or a List as an argument&quot;);</a>
<a name="ln1372">    return;</a>
<a name="ln1373">  }</a>
<a name="ln1374">  ctx_save(NULL, types);</a>
<a name="ln1375">}</a>
<a name="ln1376"> </a>
<a name="ln1377">/// &quot;ctxset({context}[, {index}])&quot; function</a>
<a name="ln1378">static void f_ctxset(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1379">{</a>
<a name="ln1380">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1381">    EMSG2(_(e_invarg2), &quot;expected dictionary as first argument&quot;);</a>
<a name="ln1382">    return;</a>
<a name="ln1383">  }</a>
<a name="ln1384"> </a>
<a name="ln1385">  size_t index = 0;</a>
<a name="ln1386">  if (argvars[1].v_type == VAR_NUMBER) {</a>
<a name="ln1387">    index = argvars[1].vval.v_number;</a>
<a name="ln1388">  } else if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1389">    EMSG2(_(e_invarg2), &quot;expected nothing or a Number as second argument&quot;);</a>
<a name="ln1390">    return;</a>
<a name="ln1391">  }</a>
<a name="ln1392"> </a>
<a name="ln1393">  Context *ctx = ctx_get(index);</a>
<a name="ln1394">  if (ctx == NULL) {</a>
<a name="ln1395">    EMSG3(_(e_invargNval), &quot;index&quot;, &quot;out of bounds&quot;);</a>
<a name="ln1396">    return;</a>
<a name="ln1397">  }</a>
<a name="ln1398"> </a>
<a name="ln1399">  int save_did_emsg = did_emsg;</a>
<a name="ln1400">  did_emsg = false;</a>
<a name="ln1401"> </a>
<a name="ln1402">  Dictionary dict = vim_to_object(&amp;argvars[0]).data.dictionary;</a>
<a name="ln1403">  Context tmp = CONTEXT_INIT;</a>
<a name="ln1404">  ctx_from_dict(dict, &amp;tmp);</a>
<a name="ln1405"> </a>
<a name="ln1406">  if (did_emsg) {</a>
<a name="ln1407">    ctx_free(&amp;tmp);</a>
<a name="ln1408">  } else {</a>
<a name="ln1409">    ctx_free(ctx);</a>
<a name="ln1410">    *ctx = tmp;</a>
<a name="ln1411">  }</a>
<a name="ln1412"> </a>
<a name="ln1413">  api_free_dictionary(dict);</a>
<a name="ln1414">  did_emsg = save_did_emsg;</a>
<a name="ln1415">}</a>
<a name="ln1416"> </a>
<a name="ln1417">/// &quot;ctxsize()&quot; function</a>
<a name="ln1418">static void f_ctxsize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1419">{</a>
<a name="ln1420">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln1421">  rettv-&gt;vval.v_number = ctx_size();</a>
<a name="ln1422">}</a>
<a name="ln1423"> </a>
<a name="ln1424">/// &quot;cursor(lnum, col)&quot; function, or</a>
<a name="ln1425">/// &quot;cursor(list)&quot;</a>
<a name="ln1426">///</a>
<a name="ln1427">/// Moves the cursor to the specified line and column.</a>
<a name="ln1428">///</a>
<a name="ln1429">/// @returns 0 when the position could be set, -1 otherwise.</a>
<a name="ln1430">static void f_cursor(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1431">{</a>
<a name="ln1432">  long line, col;</a>
<a name="ln1433">  long coladd = 0;</a>
<a name="ln1434">  bool set_curswant = true;</a>
<a name="ln1435"> </a>
<a name="ln1436">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1437">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln1438">    pos_T pos;</a>
<a name="ln1439">    colnr_T curswant = -1;</a>
<a name="ln1440"> </a>
<a name="ln1441">    if (list2fpos(argvars, &amp;pos, NULL, &amp;curswant) == FAIL) {</a>
<a name="ln1442">      EMSG(_(e_invarg));</a>
<a name="ln1443">      return;</a>
<a name="ln1444">    }</a>
<a name="ln1445"> </a>
<a name="ln1446">    line = pos.lnum;</a>
<a name="ln1447">    col = pos.col;</a>
<a name="ln1448">    coladd = pos.coladd;</a>
<a name="ln1449">    if (curswant &gt;= 0) {</a>
<a name="ln1450">      curwin-&gt;w_curswant = curswant - 1;</a>
<a name="ln1451">      set_curswant = false;</a>
<a name="ln1452">    }</a>
<a name="ln1453">  } else {</a>
<a name="ln1454">    line = tv_get_lnum(argvars);</a>
<a name="ln1455">    col = (long)tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln1456">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1457">      coladd = (long)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln1458">    }</a>
<a name="ln1459">  }</a>
<a name="ln1460">  if (line &lt; 0 || col &lt; 0</a>
<a name="ln1461">      || coladd &lt; 0) {</a>
<a name="ln1462">    return;             // type error; errmsg already given</a>
<a name="ln1463">  }</a>
<a name="ln1464">  if (line &gt; 0) {</a>
<a name="ln1465">    curwin-&gt;w_cursor.lnum = line;</a>
<a name="ln1466">  }</a>
<a name="ln1467">  if (col &gt; 0) {</a>
<a name="ln1468">    curwin-&gt;w_cursor.col = col - 1;</a>
<a name="ln1469">  }</a>
<a name="ln1470">  curwin-&gt;w_cursor.coladd = coladd;</a>
<a name="ln1471"> </a>
<a name="ln1472">  // Make sure the cursor is in a valid position.</a>
<a name="ln1473">  check_cursor();</a>
<a name="ln1474">  // Correct cursor for multi-byte character.</a>
<a name="ln1475">  mb_adjust_cursor();</a>
<a name="ln1476"> </a>
<a name="ln1477">  curwin-&gt;w_set_curswant = set_curswant;</a>
<a name="ln1478">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln1479">}</a>
<a name="ln1480"> </a>
<a name="ln1481">// &quot;debugbreak()&quot; function</a>
<a name="ln1482">static void f_debugbreak(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1483">{</a>
<a name="ln1484">  int pid;</a>
<a name="ln1485"> </a>
<a name="ln1486">  rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln1487">  pid = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln1488">  if (pid == 0) {</a>
<a name="ln1489">    EMSG(_(e_invarg));</a>
<a name="ln1490">  } else {</a>
<a name="ln1491">#ifdef WIN32</a>
<a name="ln1492">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);</a>
<a name="ln1493"> </a>
<a name="ln1494">    if (hProcess != NULL) {</a>
<a name="ln1495">      DebugBreakProcess(hProcess);</a>
<a name="ln1496">      CloseHandle(hProcess);</a>
<a name="ln1497">      rettv-&gt;vval.v_number = OK;</a>
<a name="ln1498">    }</a>
<a name="ln1499">#else</a>
<a name="ln1500">    uv_kill(pid, SIGINT);</a>
<a name="ln1501">#endif</a>
<a name="ln1502">  }</a>
<a name="ln1503">}</a>
<a name="ln1504"> </a>
<a name="ln1505">// &quot;deepcopy()&quot; function</a>
<a name="ln1506">static void f_deepcopy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1507">{</a>
<a name="ln1508">  int noref = 0;</a>
<a name="ln1509"> </a>
<a name="ln1510">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1511">    noref = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln1512">  }</a>
<a name="ln1513">  if (noref &lt; 0 || noref &gt; 1) {</a>
<a name="ln1514">    EMSG(_(e_invarg));</a>
<a name="ln1515">  } else {</a>
<a name="ln1516">    var_item_copy(NULL, &amp;argvars[0], rettv, true, (noref == 0</a>
<a name="ln1517">                                                   ? get_copyID()</a>
<a name="ln1518">                                                   : 0));</a>
<a name="ln1519">  }</a>
<a name="ln1520">}</a>
<a name="ln1521"> </a>
<a name="ln1522">// &quot;delete()&quot; function</a>
<a name="ln1523">static void f_delete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1524">{</a>
<a name="ln1525">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1526">  if (check_secure()) {</a>
<a name="ln1527">    return;</a>
<a name="ln1528">  }</a>
<a name="ln1529"> </a>
<a name="ln1530">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1531">  if (*name == NUL) {</a>
<a name="ln1532">    EMSG(_(e_invarg));</a>
<a name="ln1533">    return;</a>
<a name="ln1534">  }</a>
<a name="ln1535"> </a>
<a name="ln1536">  char nbuf[NUMBUFLEN];</a>
<a name="ln1537">  const char *flags;</a>
<a name="ln1538">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1539">    flags = tv_get_string_buf(&amp;argvars[1], nbuf);</a>
<a name="ln1540">  } else {</a>
<a name="ln1541">    flags = &quot;&quot;;</a>
<a name="ln1542">  }</a>
<a name="ln1543"> </a>
<a name="ln1544">  if (*flags == NUL) {</a>
<a name="ln1545">    // delete a file</a>
<a name="ln1546">    rettv-&gt;vval.v_number = os_remove(name) == 0 ? 0 : -1;</a>
<a name="ln1547">  } else if (strcmp(flags, &quot;d&quot;) == 0) {</a>
<a name="ln1548">    // delete an empty directory</a>
<a name="ln1549">    rettv-&gt;vval.v_number = os_rmdir(name) == 0 ? 0 : -1;</a>
<a name="ln1550">  } else if (strcmp(flags, &quot;rf&quot;) == 0) {</a>
<a name="ln1551">    // delete a directory recursively</a>
<a name="ln1552">    rettv-&gt;vval.v_number = delete_recursive(name);</a>
<a name="ln1553">  } else {</a>
<a name="ln1554">    emsgf(_(e_invexpr2), flags);</a>
<a name="ln1555">  }</a>
<a name="ln1556">}</a>
<a name="ln1557"> </a>
<a name="ln1558">// dictwatcheradd(dict, key, funcref) function</a>
<a name="ln1559">static void f_dictwatcheradd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1560">{</a>
<a name="ln1561">  if (check_secure()) {</a>
<a name="ln1562">    return;</a>
<a name="ln1563">  }</a>
<a name="ln1564"> </a>
<a name="ln1565">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1566">    emsgf(_(e_invarg2), &quot;dict&quot;);</a>
<a name="ln1567">    return;</a>
<a name="ln1568">  } else if (argvars[0].vval.v_dict == NULL) {</a>
<a name="ln1569">    const char *const arg_errmsg = _(&quot;dictwatcheradd() argument&quot;);</a>
<a name="ln1570">    const size_t arg_errmsg_len = strlen(arg_errmsg);</a>
<a name="ln1571">    emsgf(_(e_readonlyvar), (int)arg_errmsg_len, arg_errmsg);</a>
<a name="ln1572">    return;</a>
<a name="ln1573">  }</a>
<a name="ln1574"> </a>
<a name="ln1575">  if (argvars[1].v_type != VAR_STRING &amp;&amp; argvars[1].v_type != VAR_NUMBER) {</a>
<a name="ln1576">    emsgf(_(e_invarg2), &quot;key&quot;);</a>
<a name="ln1577">    return;</a>
<a name="ln1578">  }</a>
<a name="ln1579"> </a>
<a name="ln1580">  const char *const key_pattern = tv_get_string_chk(argvars + 1);</a>
<a name="ln1581">  if (key_pattern == NULL) {</a>
<a name="ln1582">    return;</a>
<a name="ln1583">  }</a>
<a name="ln1584">  const size_t key_pattern_len = strlen(key_pattern);</a>
<a name="ln1585"> </a>
<a name="ln1586">  Callback callback;</a>
<a name="ln1587">  if (!callback_from_typval(&amp;callback, &amp;argvars[2])) {</a>
<a name="ln1588">    emsgf(_(e_invarg2), &quot;funcref&quot;);</a>
<a name="ln1589">    return;</a>
<a name="ln1590">  }</a>
<a name="ln1591"> </a>
<a name="ln1592">  tv_dict_watcher_add(argvars[0].vval.v_dict, key_pattern, key_pattern_len,</a>
<a name="ln1593">                      callback);</a>
<a name="ln1594">}</a>
<a name="ln1595"> </a>
<a name="ln1596">// dictwatcherdel(dict, key, funcref) function</a>
<a name="ln1597">static void f_dictwatcherdel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1598">{</a>
<a name="ln1599">  if (check_secure()) {</a>
<a name="ln1600">    return;</a>
<a name="ln1601">  }</a>
<a name="ln1602"> </a>
<a name="ln1603">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln1604">    emsgf(_(e_invarg2), &quot;dict&quot;);</a>
<a name="ln1605">    return;</a>
<a name="ln1606">  }</a>
<a name="ln1607"> </a>
<a name="ln1608">  if (argvars[2].v_type != VAR_FUNC &amp;&amp; argvars[2].v_type != VAR_STRING) {</a>
<a name="ln1609">    emsgf(_(e_invarg2), &quot;funcref&quot;);</a>
<a name="ln1610">    return;</a>
<a name="ln1611">  }</a>
<a name="ln1612"> </a>
<a name="ln1613">  const char *const key_pattern = tv_get_string_chk(argvars + 1);</a>
<a name="ln1614">  if (key_pattern == NULL) {</a>
<a name="ln1615">    return;</a>
<a name="ln1616">  }</a>
<a name="ln1617"> </a>
<a name="ln1618">  Callback callback;</a>
<a name="ln1619">  if (!callback_from_typval(&amp;callback, &amp;argvars[2])) {</a>
<a name="ln1620">    return;</a>
<a name="ln1621">  }</a>
<a name="ln1622"> </a>
<a name="ln1623">  if (!tv_dict_watcher_remove(argvars[0].vval.v_dict, key_pattern,</a>
<a name="ln1624">                              strlen(key_pattern), callback)) {</a>
<a name="ln1625">    EMSG(&quot;Couldn't find a watcher matching key and callback&quot;);</a>
<a name="ln1626">  }</a>
<a name="ln1627"> </a>
<a name="ln1628">  callback_free(&amp;callback);</a>
<a name="ln1629">}</a>
<a name="ln1630"> </a>
<a name="ln1631">/// &quot;deletebufline()&quot; function</a>
<a name="ln1632">static void f_deletebufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1633">{</a>
<a name="ln1634">  linenr_T last;</a>
<a name="ln1635">  buf_T *curbuf_save = NULL;</a>
<a name="ln1636">  win_T *curwin_save = NULL;</a>
<a name="ln1637"> </a>
<a name="ln1638">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln1639">  if (buf == NULL) {</a>
<a name="ln1640">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1641">    return;</a>
<a name="ln1642">  }</a>
<a name="ln1643">  const bool is_curbuf = buf == curbuf;</a>
<a name="ln1644"> </a>
<a name="ln1645">  const linenr_T first = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln1646">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1647">    last = tv_get_lnum_buf(&amp;argvars[2], buf);</a>
<a name="ln1648">  } else {</a>
<a name="ln1649">    last = first;</a>
<a name="ln1650">  }</a>
<a name="ln1651"> </a>
<a name="ln1652">  if (buf-&gt;b_ml.ml_mfp == NULL || first &lt; 1</a>
<a name="ln1653">      || first &gt; buf-&gt;b_ml.ml_line_count || last &lt; first) {</a>
<a name="ln1654">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1655">    return;</a>
<a name="ln1656">  }</a>
<a name="ln1657"> </a>
<a name="ln1658">  if (!is_curbuf) {</a>
<a name="ln1659">    curbuf_save = curbuf;</a>
<a name="ln1660">    curwin_save = curwin;</a>
<a name="ln1661">    curbuf = buf;</a>
<a name="ln1662">    find_win_for_curbuf();</a>
<a name="ln1663">  }</a>
<a name="ln1664">  if (last &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1665">    last = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1666">  }</a>
<a name="ln1667">  const long count = last - first + 1;</a>
<a name="ln1668"> </a>
<a name="ln1669">  // When coming here from Insert mode, sync undo, so that this can be</a>
<a name="ln1670">  // undone separately from what was previously inserted.</a>
<a name="ln1671">  if (u_sync_once == 2) {</a>
<a name="ln1672">    u_sync_once = 1;  // notify that u_sync() was called</a>
<a name="ln1673">    u_sync(true);</a>
<a name="ln1674">  }</a>
<a name="ln1675"> </a>
<a name="ln1676">  if (u_save(first - 1, last + 1) == FAIL) {</a>
<a name="ln1677">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln1678">  } else {</a>
<a name="ln1679">    for (linenr_T lnum = first; lnum &lt;= last; lnum++) {</a>
<a name="ln1680">      ml_delete(first, true);</a>
<a name="ln1681">    }</a>
<a name="ln1682"> </a>
<a name="ln1683">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln1684">      if (wp-&gt;w_buffer == buf) {</a>
<a name="ln1685">        if (wp-&gt;w_cursor.lnum &gt; last) {</a>
<a name="ln1686">          wp-&gt;w_cursor.lnum -= count;</a>
<a name="ln1687">        } else if (wp-&gt;w_cursor.lnum&gt; first) {</a>
<a name="ln1688">          wp-&gt;w_cursor.lnum = first;</a>
<a name="ln1689">        }</a>
<a name="ln1690">        if (wp-&gt;w_cursor.lnum &gt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln1691">          wp-&gt;w_cursor.lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln1692">        }</a>
<a name="ln1693">      }</a>
<a name="ln1694">    }</a>
<a name="ln1695">    check_cursor_col();</a>
<a name="ln1696">    deleted_lines_mark(first, count);</a>
<a name="ln1697">  }</a>
<a name="ln1698"> </a>
<a name="ln1699">  if (!is_curbuf) {</a>
<a name="ln1700">    curbuf = curbuf_save;</a>
<a name="ln1701">    curwin = curwin_save;</a>
<a name="ln1702">  }</a>
<a name="ln1703">}</a>
<a name="ln1704"> </a>
<a name="ln1705">/*</a>
<a name="ln1706"> * &quot;did_filetype()&quot; function</a>
<a name="ln1707"> */</a>
<a name="ln1708">static void f_did_filetype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1709">{</a>
<a name="ln1710">  rettv-&gt;vval.v_number = did_filetype;</a>
<a name="ln1711">}</a>
<a name="ln1712"> </a>
<a name="ln1713">/*</a>
<a name="ln1714"> * &quot;diff_filler()&quot; function</a>
<a name="ln1715"> */</a>
<a name="ln1716">static void f_diff_filler(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1717">{</a>
<a name="ln1718">  rettv-&gt;vval.v_number = diff_check_fill(curwin, tv_get_lnum(argvars));</a>
<a name="ln1719">}</a>
<a name="ln1720"> </a>
<a name="ln1721">/*</a>
<a name="ln1722"> * &quot;diff_hlID()&quot; function</a>
<a name="ln1723"> */</a>
<a name="ln1724">static void f_diff_hlID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1725">{</a>
<a name="ln1726">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln1727">  static linenr_T prev_lnum = 0;</a>
<a name="ln1728">  static int changedtick = 0;</a>
<a name="ln1729">  static int fnum = 0;</a>
<a name="ln1730">  static int change_start = 0;</a>
<a name="ln1731">  static int change_end = 0;</a>
<a name="ln1732">  static hlf_T hlID = (hlf_T)0;</a>
<a name="ln1733">  int filler_lines;</a>
<a name="ln1734">  int col;</a>
<a name="ln1735"> </a>
<a name="ln1736">  if (lnum &lt; 0) {       // ignore type error in {lnum} arg</a>
<a name="ln1737">    lnum = 0;</a>
<a name="ln1738">  }</a>
<a name="ln1739">  if (lnum != prev_lnum</a>
<a name="ln1740">      || changedtick != buf_get_changedtick(curbuf)</a>
<a name="ln1741">      || fnum != curbuf-&gt;b_fnum) {</a>
<a name="ln1742">    // New line, buffer, change: need to get the values.</a>
<a name="ln1743">    filler_lines = diff_check(curwin, lnum);</a>
<a name="ln1744">    if (filler_lines &lt; 0) {</a>
<a name="ln1745">      if (filler_lines == -1) {</a>
<a name="ln1746">        change_start = MAXCOL;</a>
<a name="ln1747">        change_end = -1;</a>
<a name="ln1748">        if (diff_find_change(curwin, lnum, &amp;change_start, &amp;change_end)) {</a>
<a name="ln1749">          hlID = HLF_ADD;               // added line</a>
<a name="ln1750">        } else {</a>
<a name="ln1751">          hlID = HLF_CHD;               // changed line</a>
<a name="ln1752">        }</a>
<a name="ln1753">      } else {</a>
<a name="ln1754">        hlID = HLF_ADD;         // added line</a>
<a name="ln1755">      }</a>
<a name="ln1756">    } else {</a>
<a name="ln1757">      hlID = (hlf_T)0;</a>
<a name="ln1758">    }</a>
<a name="ln1759">    prev_lnum = lnum;</a>
<a name="ln1760">    changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln1761">    fnum = curbuf-&gt;b_fnum;</a>
<a name="ln1762">  }</a>
<a name="ln1763"> </a>
<a name="ln1764">  if (hlID == HLF_CHD || hlID == HLF_TXD) {</a>
<a name="ln1765">    col = tv_get_number(&amp;argvars[1]) - 1;  // Ignore type error in {col}.</a>
<a name="ln1766">    if (col &gt;= change_start &amp;&amp; col &lt;= change_end) {</a>
<a name="ln1767">      hlID = HLF_TXD;  // Changed text.</a>
<a name="ln1768">    } else {</a>
<a name="ln1769">      hlID = HLF_CHD;  // Changed line.</a>
<a name="ln1770">    }</a>
<a name="ln1771">  }</a>
<a name="ln1772">  rettv-&gt;vval.v_number = hlID == (hlf_T)0 ? 0 : (int)(hlID + 1);</a>
<a name="ln1773">}</a>
<a name="ln1774"> </a>
<a name="ln1775">/*</a>
<a name="ln1776"> * &quot;empty({expr})&quot; function</a>
<a name="ln1777"> */</a>
<a name="ln1778">static void f_empty(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1779">{</a>
<a name="ln1780">  bool n = true;</a>
<a name="ln1781"> </a>
<a name="ln1782">  switch (argvars[0].v_type) {</a>
<a name="ln1783">    case VAR_STRING:</a>
<a name="ln1784">    case VAR_FUNC: {</a>
<a name="ln1785">      n = argvars[0].vval.v_string == NULL</a>
<a name="ln1786">          || *argvars[0].vval.v_string == NUL;</a>
<a name="ln1787">      break;</a>
<a name="ln1788">    }</a>
<a name="ln1789">    case VAR_PARTIAL: {</a>
<a name="ln1790">      n = false;</a>
<a name="ln1791">      break;</a>
<a name="ln1792">    }</a>
<a name="ln1793">    case VAR_NUMBER: {</a>
<a name="ln1794">      n = argvars[0].vval.v_number == 0;</a>
<a name="ln1795">      break;</a>
<a name="ln1796">    }</a>
<a name="ln1797">    case VAR_FLOAT: {</a>
<a name="ln1798">      n = argvars[0].vval.v_float == 0.0;</a>
<a name="ln1799">      break;</a>
<a name="ln1800">    }</a>
<a name="ln1801">    case VAR_LIST: {</a>
<a name="ln1802">      n = (tv_list_len(argvars[0].vval.v_list) == 0);</a>
<a name="ln1803">      break;</a>
<a name="ln1804">    }</a>
<a name="ln1805">    case VAR_DICT: {</a>
<a name="ln1806">      n = (tv_dict_len(argvars[0].vval.v_dict) == 0);</a>
<a name="ln1807">      break;</a>
<a name="ln1808">    }</a>
<a name="ln1809">    case VAR_BOOL: {</a>
<a name="ln1810">      switch (argvars[0].vval.v_bool) {</a>
<a name="ln1811">        case kBoolVarTrue: {</a>
<a name="ln1812">          n = false;</a>
<a name="ln1813">          break;</a>
<a name="ln1814">        }</a>
<a name="ln1815">        case kBoolVarFalse: {</a>
<a name="ln1816">          n = true;</a>
<a name="ln1817">          break;</a>
<a name="ln1818">        }</a>
<a name="ln1819">      }</a>
<a name="ln1820">      break;</a>
<a name="ln1821">    }</a>
<a name="ln1822">    case VAR_SPECIAL: {</a>
<a name="ln1823">      n = argvars[0].vval.v_special == kSpecialVarNull;</a>
<a name="ln1824">      break;</a>
<a name="ln1825">    }</a>
<a name="ln1826">    case VAR_UNKNOWN: {</a>
<a name="ln1827">      internal_error(&quot;f_empty(UNKNOWN)&quot;);</a>
<a name="ln1828">      break;</a>
<a name="ln1829">    }</a>
<a name="ln1830">  }</a>
<a name="ln1831"> </a>
<a name="ln1832">  rettv-&gt;vval.v_number = n;</a>
<a name="ln1833">}</a>
<a name="ln1834"> </a>
<a name="ln1835">/// &quot;environ()&quot; function</a>
<a name="ln1836">static void f_environ(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1837">{</a>
<a name="ln1838">  tv_dict_alloc_ret(rettv);</a>
<a name="ln1839"> </a>
<a name="ln1840">  size_t env_size = os_get_fullenv_size();</a>
<a name="ln1841">  char **env = xmalloc(sizeof(*env) * (env_size + 1));</a>
<a name="ln1842">  env[env_size] = NULL;</a>
<a name="ln1843"> </a>
<a name="ln1844">  os_copy_fullenv(env, env_size);</a>
<a name="ln1845"> </a>
<a name="ln1846">  for (ssize_t i = env_size - 1; i &gt;= 0; i--) {</a>
<a name="ln1847">    const char * str = env[i];</a>
<a name="ln1848">    const char * const end = strchr(str + (str[0] == '=' ? 1 : 0),</a>
<a name="ln1849">                                    '=');</a>
<a name="ln1850">    assert(end != NULL);</a>
<a name="ln1851">    ptrdiff_t len = end - str;</a>
<a name="ln1852">    assert(len &gt; 0);</a>
<a name="ln1853">    const char * value = str + len + 1;</a>
<a name="ln1854"> </a>
<a name="ln1855">    char c = env[i][len];</a>
<a name="ln1856">    env[i][len] = NUL;</a>
<a name="ln1857"> </a>
<a name="ln1858">#ifdef WIN32</a>
<a name="ln1859">    // Upper-case all the keys for Windows so we can detect duplicates</a>
<a name="ln1860">    char *const key = strcase_save(str, true);</a>
<a name="ln1861">#else</a>
<a name="ln1862">    char *const key = xstrdup(str);</a>
<a name="ln1863">#endif</a>
<a name="ln1864"> </a>
<a name="ln1865">    env[i][len] = c;</a>
<a name="ln1866"> </a>
<a name="ln1867">    if (tv_dict_find(rettv-&gt;vval.v_dict, key, len) != NULL) {</a>
<a name="ln1868">      // Since we're traversing from the end of the env block to the front, any</a>
<a name="ln1869">      // duplicate names encountered should be ignored.  This preserves the</a>
<a name="ln1870">      // semantics of env vars defined later in the env block taking precedence.</a>
<a name="ln1871">      xfree(key);</a>
<a name="ln1872">      continue;</a>
<a name="ln1873">    }</a>
<a name="ln1874">    tv_dict_add_str(rettv-&gt;vval.v_dict,</a>
<a name="ln1875">                    key, len,</a>
<a name="ln1876">                    value);</a>
<a name="ln1877">    xfree(key);</a>
<a name="ln1878">  }</a>
<a name="ln1879">  os_free_fullenv(env);</a>
<a name="ln1880">}</a>
<a name="ln1881"> </a>
<a name="ln1882">/*</a>
<a name="ln1883"> * &quot;escape({string}, {chars})&quot; function</a>
<a name="ln1884"> */</a>
<a name="ln1885">static void f_escape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1886">{</a>
<a name="ln1887">  char buf[NUMBUFLEN];</a>
<a name="ln1888"> </a>
<a name="ln1889">  rettv-&gt;vval.v_string = vim_strsave_escaped(</a>
<a name="ln1890">      (const char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln1891">      (const char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln1892">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1893">}</a>
<a name="ln1894"> </a>
<a name="ln1895">/// &quot;getenv()&quot; function</a>
<a name="ln1896">static void f_getenv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1897">{</a>
<a name="ln1898">  char_u *p = (char_u *)vim_getenv(tv_get_string(&amp;argvars[0]));</a>
<a name="ln1899"> </a>
<a name="ln1900">  if (p == NULL) {</a>
<a name="ln1901">    rettv-&gt;v_type = VAR_SPECIAL;</a>
<a name="ln1902">    rettv-&gt;vval.v_special = kSpecialVarNull;</a>
<a name="ln1903">    return;</a>
<a name="ln1904">  }</a>
<a name="ln1905">  rettv-&gt;vval.v_string = p;</a>
<a name="ln1906">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1907">}</a>
<a name="ln1908"> </a>
<a name="ln1909">/*</a>
<a name="ln1910"> * &quot;eval()&quot; function</a>
<a name="ln1911"> */</a>
<a name="ln1912">static void f_eval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1913">{</a>
<a name="ln1914">  const char *s = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln1915">  if (s != NULL) {</a>
<a name="ln1916">    s = (const char *)skipwhite((const char_u *)s);</a>
<a name="ln1917">  }</a>
<a name="ln1918"> </a>
<a name="ln1919">  const char *const expr_start = s;</a>
<a name="ln1920">  if (s == NULL || eval1((char_u **)&amp;s, rettv, true) == FAIL) {</a>
<a name="ln1921">    if (expr_start != NULL &amp;&amp; !aborting()) {</a>
<a name="ln1922">      EMSG2(_(e_invexpr2), expr_start);</a>
<a name="ln1923">    }</a>
<a name="ln1924">    need_clr_eos = FALSE;</a>
<a name="ln1925">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln1926">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln1927">  } else if (*s != NUL) {</a>
<a name="ln1928">    EMSG(_(e_trailing));</a>
<a name="ln1929">  }</a>
<a name="ln1930">}</a>
<a name="ln1931"> </a>
<a name="ln1932">/*</a>
<a name="ln1933"> * &quot;eventhandler()&quot; function</a>
<a name="ln1934"> */</a>
<a name="ln1935">static void f_eventhandler(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1936">{</a>
<a name="ln1937">  rettv-&gt;vval.v_number = vgetc_busy;</a>
<a name="ln1938">}</a>
<a name="ln1939"> </a>
<a name="ln1940">/*</a>
<a name="ln1941"> * &quot;executable()&quot; function</a>
<a name="ln1942"> */</a>
<a name="ln1943">static void f_executable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln1944">{</a>
<a name="ln1945">  if (tv_check_for_string(&amp;argvars[0]) == FAIL) {</a>
<a name="ln1946">    return;</a>
<a name="ln1947">  }</a>
<a name="ln1948"> </a>
<a name="ln1949">  // Check in $PATH and also check directly if there is a directory name</a>
<a name="ln1950">  rettv-&gt;vval.v_number = os_can_exe(tv_get_string(&amp;argvars[0]), NULL, true);</a>
<a name="ln1951">}</a>
<a name="ln1952"> </a>
<a name="ln1953">typedef struct {</a>
<a name="ln1954">  const list_T *const l;</a>
<a name="ln1955">  const listitem_T *li;</a>
<a name="ln1956">} GetListLineCookie;</a>
<a name="ln1957"> </a>
<a name="ln1958">static char_u *get_list_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln1959">{</a>
<a name="ln1960">  GetListLineCookie *const p = (GetListLineCookie *)cookie;</a>
<a name="ln1961"> </a>
<a name="ln1962">  const listitem_T *const item = p-&gt;li;</a>
<a name="ln1963">  if (item == NULL) {</a>
<a name="ln1964">    return NULL;</a>
<a name="ln1965">  }</a>
<a name="ln1966">  char buf[NUMBUFLEN];</a>
<a name="ln1967">  const char *const s = tv_get_string_buf_chk(TV_LIST_ITEM_TV(item), buf);</a>
<a name="ln1968">  p-&gt;li = TV_LIST_ITEM_NEXT(p-&gt;l, item);</a>
<a name="ln1969">  return (char_u *)(s == NULL ? NULL : xstrdup(s));</a>
<a name="ln1970">}</a>
<a name="ln1971"> </a>
<a name="ln1972">static void execute_common(typval_T *argvars, typval_T *rettv, FunPtr fptr,</a>
<a name="ln1973">                           int arg_off)</a>
<a name="ln1974">{</a>
<a name="ln1975">  const int save_msg_silent = msg_silent;</a>
<a name="ln1976">  const int save_emsg_silent = emsg_silent;</a>
<a name="ln1977">  const bool save_emsg_noredir = emsg_noredir;</a>
<a name="ln1978">  const bool save_redir_off = redir_off;</a>
<a name="ln1979">  garray_T *const save_capture_ga = capture_ga;</a>
<a name="ln1980">  const int save_msg_col = msg_col;</a>
<a name="ln1981">  bool echo_output = false;</a>
<a name="ln1982"> </a>
<a name="ln1983">  if (check_secure()) {</a>
<a name="ln1984">    return;</a>
<a name="ln1985">  }</a>
<a name="ln1986"> </a>
<a name="ln1987">  if (argvars[arg_off + 1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1988">    char buf[NUMBUFLEN];</a>
<a name="ln1989">    const char *const s = tv_get_string_buf_chk(&amp;argvars[arg_off + 1], buf);</a>
<a name="ln1990"> </a>
<a name="ln1991">    if (s == NULL) {</a>
<a name="ln1992">      return;</a>
<a name="ln1993">    }</a>
<a name="ln1994">    if (*s == NUL) {</a>
<a name="ln1995">      echo_output = true;</a>
<a name="ln1996">    }</a>
<a name="ln1997">    if (strncmp(s, &quot;silent&quot;, 6) == 0) {</a>
<a name="ln1998">      msg_silent++;</a>
<a name="ln1999">    }</a>
<a name="ln2000">    if (strcmp(s, &quot;silent!&quot;) == 0) {</a>
<a name="ln2001">      emsg_silent = true;</a>
<a name="ln2002">      emsg_noredir = true;</a>
<a name="ln2003">    }</a>
<a name="ln2004">  } else {</a>
<a name="ln2005">    msg_silent++;</a>
<a name="ln2006">  }</a>
<a name="ln2007"> </a>
<a name="ln2008">  garray_T capture_local;</a>
<a name="ln2009">  ga_init(&amp;capture_local, (int)sizeof(char), 80);</a>
<a name="ln2010">  capture_ga = &amp;capture_local;</a>
<a name="ln2011">  redir_off = false;</a>
<a name="ln2012">  if (!echo_output) {</a>
<a name="ln2013">    msg_col = 0;  // prevent leading spaces</a>
<a name="ln2014">  }</a>
<a name="ln2015"> </a>
<a name="ln2016">  if (argvars[arg_off].v_type != VAR_LIST) {</a>
<a name="ln2017">    do_cmdline_cmd(tv_get_string(&amp;argvars[arg_off]));</a>
<a name="ln2018">  } else if (argvars[arg_off].vval.v_list != NULL) {</a>
<a name="ln2019">    list_T *const list = argvars[arg_off].vval.v_list;</a>
<a name="ln2020">    tv_list_ref(list);</a>
<a name="ln2021">    GetListLineCookie cookie = {</a>
<a name="ln2022">      .l = list,</a>
<a name="ln2023">      .li = tv_list_first(list),</a>
<a name="ln2024">    };</a>
<a name="ln2025">    do_cmdline(NULL, get_list_line, (void *)&amp;cookie,</a>
<a name="ln2026">               DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT|DOCMD_KEYTYPED);</a>
<a name="ln2027">    tv_list_unref(list);</a>
<a name="ln2028">  }</a>
<a name="ln2029">  msg_silent = save_msg_silent;</a>
<a name="ln2030">  emsg_silent = save_emsg_silent;</a>
<a name="ln2031">  emsg_noredir = save_emsg_noredir;</a>
<a name="ln2032">  redir_off = save_redir_off;</a>
<a name="ln2033">  // &quot;silent reg&quot; or &quot;silent echo x&quot; leaves msg_col somewhere in the line.</a>
<a name="ln2034">  if (echo_output) {</a>
<a name="ln2035">    // When not working silently: put it in column zero.  A following</a>
<a name="ln2036">    // &quot;echon&quot; will overwrite the message, unavoidably.</a>
<a name="ln2037">    msg_col = 0;</a>
<a name="ln2038">  } else {</a>
<a name="ln2039">    // When working silently: Put it back where it was, since nothing</a>
<a name="ln2040">    // should have been written.</a>
<a name="ln2041">    msg_col = save_msg_col;</a>
<a name="ln2042">  }</a>
<a name="ln2043"> </a>
<a name="ln2044">  ga_append(capture_ga, NUL);</a>
<a name="ln2045">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2046">  rettv-&gt;vval.v_string = capture_ga-&gt;ga_data;</a>
<a name="ln2047"> </a>
<a name="ln2048">  capture_ga = save_capture_ga;</a>
<a name="ln2049">}</a>
<a name="ln2050"> </a>
<a name="ln2051">// &quot;execute(command)&quot; function</a>
<a name="ln2052">static void f_execute(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2053">{</a>
<a name="ln2054">  execute_common(argvars, rettv, fptr, 0);</a>
<a name="ln2055">}</a>
<a name="ln2056"> </a>
<a name="ln2057">// &quot;win_execute(win_id, command)&quot; function</a>
<a name="ln2058">static void f_win_execute(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2059">{</a>
<a name="ln2060">  tabpage_T *tp;</a>
<a name="ln2061">  win_T *wp = win_id2wp_tp(argvars, &amp;tp);</a>
<a name="ln2062">  win_T *save_curwin;</a>
<a name="ln2063">  tabpage_T *save_curtab;</a>
<a name="ln2064">  // Return an empty string if something fails.</a>
<a name="ln2065">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2066">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2067"> </a>
<a name="ln2068">  if (wp != NULL &amp;&amp; tp != NULL) {</a>
<a name="ln2069">    pos_T curpos = wp-&gt;w_cursor;</a>
<a name="ln2070">    if (switch_win_noblock(&amp;save_curwin, &amp;save_curtab, wp, tp, true) ==</a>
<a name="ln2071">        OK) {</a>
<a name="ln2072">      check_cursor();</a>
<a name="ln2073">      execute_common(argvars, rettv, fptr, 1);</a>
<a name="ln2074">    }</a>
<a name="ln2075">    restore_win_noblock(save_curwin, save_curtab, true);</a>
<a name="ln2076"> </a>
<a name="ln2077">    // Update the status line if the cursor moved.</a>
<a name="ln2078">    if (win_valid(wp) &amp;&amp; !equalpos(curpos, wp-&gt;w_cursor)) {</a>
<a name="ln2079">        wp-&gt;w_redr_status = true;</a>
<a name="ln2080">    }</a>
<a name="ln2081">  }</a>
<a name="ln2082">}</a>
<a name="ln2083"> </a>
<a name="ln2084">/// &quot;exepath()&quot; function</a>
<a name="ln2085">static void f_exepath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2086">{</a>
<a name="ln2087">  if (tv_check_for_string(&amp;argvars[0]) == FAIL) {</a>
<a name="ln2088">    return;</a>
<a name="ln2089">  }</a>
<a name="ln2090"> </a>
<a name="ln2091">  char *path = NULL;</a>
<a name="ln2092"> </a>
<a name="ln2093">  (void)os_can_exe(tv_get_string(&amp;argvars[0]), &amp;path, true);</a>
<a name="ln2094"> </a>
<a name="ln2095">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2096">  rettv-&gt;vval.v_string = (char_u *)path;</a>
<a name="ln2097">}</a>
<a name="ln2098"> </a>
<a name="ln2099">/*</a>
<a name="ln2100"> * &quot;exists()&quot; function</a>
<a name="ln2101"> */</a>
<a name="ln2102">static void f_exists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2103">{</a>
<a name="ln2104">  int n = false;</a>
<a name="ln2105"> </a>
<a name="ln2106">  const char *p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2107">  if (*p == '$') {  // Environment variable.</a>
<a name="ln2108">    // First try &quot;normal&quot; environment variables (fast).</a>
<a name="ln2109">    if (os_env_exists(p + 1)) {</a>
<a name="ln2110">      n = true;</a>
<a name="ln2111">    } else {</a>
<a name="ln2112">      // Try expanding things like $VIM and ${HOME}.</a>
<a name="ln2113">      char_u *const exp = expand_env_save((char_u *)p);</a>
<a name="ln2114">      if (exp != NULL &amp;&amp; *exp != '$') {</a>
<a name="ln2115">        n = true;</a>
<a name="ln2116">      }</a>
<a name="ln2117">      xfree(exp);</a>
<a name="ln2118">    }</a>
<a name="ln2119">  } else if (*p == '&amp;' || *p == '+') {  // Option.</a>
<a name="ln2120">    n = (get_option_tv(&amp;p, NULL, true) == OK);</a>
<a name="ln2121">    if (*skipwhite((const char_u *)p) != NUL) {</a>
<a name="ln2122">      n = false;  // Trailing garbage.</a>
<a name="ln2123">    }</a>
<a name="ln2124">  } else if (*p == '*') {  // Internal or user defined function.</a>
<a name="ln2125">    n = function_exists(p + 1, false);</a>
<a name="ln2126">  } else if (*p == ':') {</a>
<a name="ln2127">    n = cmd_exists(p + 1);</a>
<a name="ln2128">  } else if (*p == '#') {</a>
<a name="ln2129">    if (p[1] == '#') {</a>
<a name="ln2130">      n = autocmd_supported(p + 2);</a>
<a name="ln2131">    } else {</a>
<a name="ln2132">      n = au_exists(p + 1);</a>
<a name="ln2133">    }</a>
<a name="ln2134">  } else {  // Internal variable.</a>
<a name="ln2135">    n = var_exists(p);</a>
<a name="ln2136">  }</a>
<a name="ln2137"> </a>
<a name="ln2138">  rettv-&gt;vval.v_number = n;</a>
<a name="ln2139">}</a>
<a name="ln2140"> </a>
<a name="ln2141">/*</a>
<a name="ln2142"> * &quot;expand()&quot; function</a>
<a name="ln2143"> */</a>
<a name="ln2144">static void f_expand(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2145">{</a>
<a name="ln2146">  size_t len;</a>
<a name="ln2147">  char_u      *errormsg;</a>
<a name="ln2148">  int options = WILD_SILENT|WILD_USE_NL|WILD_LIST_NOTFOUND;</a>
<a name="ln2149">  expand_T xpc;</a>
<a name="ln2150">  bool error = false;</a>
<a name="ln2151">  char_u *result;</a>
<a name="ln2152">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2153">  char_u *p_csl_save = p_csl;</a>
<a name="ln2154"> </a>
<a name="ln2155">  // avoid using 'completeslash' here</a>
<a name="ln2156">  p_csl = empty_option;</a>
<a name="ln2157">#endif</a>
<a name="ln2158"> </a>
<a name="ln2159">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2160">  if (argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln2161">      &amp;&amp; argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln2162">      &amp;&amp; tv_get_number_chk(&amp;argvars[2], &amp;error)</a>
<a name="ln2163">      &amp;&amp; !error) {</a>
<a name="ln2164">    tv_list_set_ret(rettv, NULL);</a>
<a name="ln2165">  }</a>
<a name="ln2166"> </a>
<a name="ln2167">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2168">  if (*s == '%' || *s == '#' || *s == '&lt;') {</a>
<a name="ln2169">    emsg_off++;</a>
<a name="ln2170">    result = eval_vars((char_u *)s, (char_u *)s, &amp;len, NULL, &amp;errormsg, NULL);</a>
<a name="ln2171">    emsg_off--;</a>
<a name="ln2172">    if (rettv-&gt;v_type == VAR_LIST) {</a>
<a name="ln2173">      tv_list_alloc_ret(rettv, (result != NULL));</a>
<a name="ln2174">      if (result != NULL) {</a>
<a name="ln2175">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)result, -1);</a>
<a name="ln2176">      }</a>
<a name="ln2177">      XFREE_CLEAR(result);</a>
<a name="ln2178">    } else {</a>
<a name="ln2179">      rettv-&gt;vval.v_string = result;</a>
<a name="ln2180">    }</a>
<a name="ln2181">  } else {</a>
<a name="ln2182">    // When the optional second argument is non-zero, don't remove matches</a>
<a name="ln2183">    // for 'wildignore' and don't put matches for 'suffixes' at the end.</a>
<a name="ln2184">    if (argvars[1].v_type != VAR_UNKNOWN</a>
<a name="ln2185">        &amp;&amp; tv_get_number_chk(&amp;argvars[1], &amp;error)) {</a>
<a name="ln2186">      options |= WILD_KEEP_ALL;</a>
<a name="ln2187">    }</a>
<a name="ln2188">    if (!error) {</a>
<a name="ln2189">      ExpandInit(&amp;xpc);</a>
<a name="ln2190">      xpc.xp_context = EXPAND_FILES;</a>
<a name="ln2191">      if (p_wic) {</a>
<a name="ln2192">        options += WILD_ICASE;</a>
<a name="ln2193">      }</a>
<a name="ln2194">      if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln2195">        rettv-&gt;vval.v_string = ExpandOne(&amp;xpc, (char_u *)s, NULL, options,</a>
<a name="ln2196">                                         WILD_ALL);</a>
<a name="ln2197">      } else {</a>
<a name="ln2198">        ExpandOne(&amp;xpc, (char_u *)s, NULL, options, WILD_ALL_KEEP);</a>
<a name="ln2199">        tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln2200">        for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln2201">          tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln2202">                                (const char *)xpc.xp_files[i], -1);</a>
<a name="ln2203">        }</a>
<a name="ln2204">        ExpandCleanup(&amp;xpc);</a>
<a name="ln2205">      }</a>
<a name="ln2206">    } else {</a>
<a name="ln2207">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2208">    }</a>
<a name="ln2209">  }</a>
<a name="ln2210">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2211">  p_csl = p_csl_save;</a>
<a name="ln2212">#endif</a>
<a name="ln2213">}</a>
<a name="ln2214"> </a>
<a name="ln2215"> </a>
<a name="ln2216">/// &quot;menu_get(path [, modes])&quot; function</a>
<a name="ln2217">static void f_menu_get(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2218">{</a>
<a name="ln2219">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln2220">  int modes = MENU_ALL_MODES;</a>
<a name="ln2221">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln2222">    const char *const strmodes = tv_get_string(&amp;argvars[1]);</a>
<a name="ln2223">    modes = get_menu_cmd_modes(strmodes, false, NULL, NULL);</a>
<a name="ln2224">  }</a>
<a name="ln2225">  menu_get((char_u *)tv_get_string(&amp;argvars[0]), modes, rettv-&gt;vval.v_list);</a>
<a name="ln2226">}</a>
<a name="ln2227"> </a>
<a name="ln2228">// &quot;expandcmd()&quot; function</a>
<a name="ln2229">// Expand all the special characters in a command string.</a>
<a name="ln2230">static void f_expandcmd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2231">{</a>
<a name="ln2232">  char_u *errormsg = NULL;</a>
<a name="ln2233"> </a>
<a name="ln2234">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2235">  char_u *cmdstr = (char_u *)xstrdup(tv_get_string(&amp;argvars[0]));</a>
<a name="ln2236"> </a>
<a name="ln2237">  exarg_T eap = {</a>
<a name="ln2238">    .cmd = cmdstr,</a>
<a name="ln2239">    .arg = cmdstr,</a>
<a name="ln2240">    .usefilter = false,</a>
<a name="ln2241">    .nextcmd = NULL,</a>
<a name="ln2242">    .cmdidx = CMD_USER,</a>
<a name="ln2243">  };</a>
<a name="ln2244">  eap.argt |= EX_NOSPC;</a>
<a name="ln2245"> </a>
<a name="ln2246">  expand_filename(&amp;eap, &amp;cmdstr, &amp;errormsg);</a>
<a name="ln2247">  if (errormsg != NULL &amp;&amp; *errormsg != NUL) {</a>
<a name="ln2248">    EMSG(errormsg);</a>
<a name="ln2249">  }</a>
<a name="ln2250">  rettv-&gt;vval.v_string = cmdstr;</a>
<a name="ln2251">}</a>
<a name="ln2252"> </a>
<a name="ln2253"> </a>
<a name="ln2254">/// &quot;flatten(list[, {maxdepth}])&quot; function</a>
<a name="ln2255">static void f_flatten(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2256">{</a>
<a name="ln2257">  list_T *list;</a>
<a name="ln2258">  long maxdepth;</a>
<a name="ln2259">  bool error = false;</a>
<a name="ln2260"> </a>
<a name="ln2261">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln2262">    EMSG2(_(e_listarg), &quot;flatten()&quot;);</a>
<a name="ln2263">    return;</a>
<a name="ln2264">  }</a>
<a name="ln2265"> </a>
<a name="ln2266">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln2267">    maxdepth = 999999;</a>
<a name="ln2268">  } else {</a>
<a name="ln2269">    maxdepth = (long)tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln2270">    if (error) {</a>
<a name="ln2271">      return;</a>
<a name="ln2272">    }</a>
<a name="ln2273">    if (maxdepth &lt; 0) {</a>
<a name="ln2274">      EMSG(_(&quot;E900: maxdepth must be non-negative number&quot;));</a>
<a name="ln2275">      return;</a>
<a name="ln2276">    }</a>
<a name="ln2277">  }</a>
<a name="ln2278"> </a>
<a name="ln2279">  list = argvars[0].vval.v_list;</a>
<a name="ln2280">  if (list != NULL</a>
<a name="ln2281">      &amp;&amp; !var_check_lock(tv_list_locked(list),</a>
<a name="ln2282">                         N_(&quot;flatten() argument&quot;),</a>
<a name="ln2283">                         TV_TRANSLATE)</a>
<a name="ln2284">      &amp;&amp; tv_list_flatten(list, maxdepth) == OK) {</a>
<a name="ln2285">    tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2286">  }</a>
<a name="ln2287">}</a>
<a name="ln2288"> </a>
<a name="ln2289">/*</a>
<a name="ln2290"> * &quot;extend(list, list [, idx])&quot; function</a>
<a name="ln2291"> * &quot;extend(dict, dict [, action])&quot; function</a>
<a name="ln2292"> */</a>
<a name="ln2293">static void f_extend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2294">{</a>
<a name="ln2295">  const char *const arg_errmsg = N_(&quot;extend() argument&quot;);</a>
<a name="ln2296"> </a>
<a name="ln2297">  if (argvars[0].v_type == VAR_LIST &amp;&amp; argvars[1].v_type == VAR_LIST) {</a>
<a name="ln2298">    long before;</a>
<a name="ln2299">    bool error = false;</a>
<a name="ln2300"> </a>
<a name="ln2301">    list_T *const l1 = argvars[0].vval.v_list;</a>
<a name="ln2302">    list_T *const l2 = argvars[1].vval.v_list;</a>
<a name="ln2303">    if (!var_check_lock(tv_list_locked(l1), arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2304">      listitem_T *item;</a>
<a name="ln2305">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2306">        before = (long)tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2307">        if (error) {</a>
<a name="ln2308">          return;  // Type error; errmsg already given.</a>
<a name="ln2309">        }</a>
<a name="ln2310"> </a>
<a name="ln2311">        if (before == tv_list_len(l1)) {</a>
<a name="ln2312">          item = NULL;</a>
<a name="ln2313">        } else {</a>
<a name="ln2314">          item = tv_list_find(l1, before);</a>
<a name="ln2315">          if (item == NULL) {</a>
<a name="ln2316">            EMSGN(_(e_listidx), before);</a>
<a name="ln2317">            return;</a>
<a name="ln2318">          }</a>
<a name="ln2319">        }</a>
<a name="ln2320">      } else {</a>
<a name="ln2321">        item = NULL;</a>
<a name="ln2322">      }</a>
<a name="ln2323">      tv_list_extend(l1, l2, item);</a>
<a name="ln2324"> </a>
<a name="ln2325">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2326">    }</a>
<a name="ln2327">  } else if (argvars[0].v_type == VAR_DICT &amp;&amp; argvars[1].v_type ==</a>
<a name="ln2328">             VAR_DICT) {</a>
<a name="ln2329">    dict_T *const d1 = argvars[0].vval.v_dict;</a>
<a name="ln2330">    dict_T *const d2 = argvars[1].vval.v_dict;</a>
<a name="ln2331">    if (d1 == NULL) {</a>
<a name="ln2332">      const bool locked = var_check_lock(VAR_FIXED, arg_errmsg, TV_TRANSLATE);</a>
<a name="ln2333">      (void)locked;</a>
<a name="ln2334">      assert(locked == true);</a>
<a name="ln2335">    } else if (d2 == NULL) {</a>
<a name="ln2336">      // Do nothing</a>
<a name="ln2337">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2338">    } else if (!var_check_lock(d1-&gt;dv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2339">      const char *action = &quot;force&quot;;</a>
<a name="ln2340">      // Check the third argument.</a>
<a name="ln2341">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2342">        const char *const av[] = { &quot;keep&quot;, &quot;force&quot;, &quot;error&quot; };</a>
<a name="ln2343"> </a>
<a name="ln2344">        action = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln2345">        if (action == NULL) {</a>
<a name="ln2346">          return;  // Type error; error message already given.</a>
<a name="ln2347">        }</a>
<a name="ln2348">        size_t i;</a>
<a name="ln2349">        for (i = 0; i &lt; ARRAY_SIZE(av); i++) {</a>
<a name="ln2350">          if (strcmp(action, av[i]) == 0) {</a>
<a name="ln2351">            break;</a>
<a name="ln2352">          }</a>
<a name="ln2353">        }</a>
<a name="ln2354">        if (i == 3) {</a>
<a name="ln2355">          EMSG2(_(e_invarg2), action);</a>
<a name="ln2356">          return;</a>
<a name="ln2357">        }</a>
<a name="ln2358">      }</a>
<a name="ln2359"> </a>
<a name="ln2360">      tv_dict_extend(d1, d2, action);</a>
<a name="ln2361"> </a>
<a name="ln2362">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln2363">    }</a>
<a name="ln2364">  } else {</a>
<a name="ln2365">    EMSG2(_(e_listdictarg), &quot;extend()&quot;);</a>
<a name="ln2366">  }</a>
<a name="ln2367">}</a>
<a name="ln2368"> </a>
<a name="ln2369">/*</a>
<a name="ln2370"> * &quot;feedkeys()&quot; function</a>
<a name="ln2371"> */</a>
<a name="ln2372">static void f_feedkeys(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2373">{</a>
<a name="ln2374">  // This is not allowed in the sandbox.  If the commands would still be</a>
<a name="ln2375">  // executed in the sandbox it would be OK, but it probably happens later,</a>
<a name="ln2376">  // when &quot;sandbox&quot; is no longer set.</a>
<a name="ln2377">  if (check_secure()) {</a>
<a name="ln2378">    return;</a>
<a name="ln2379">  }</a>
<a name="ln2380"> </a>
<a name="ln2381">  const char *const keys = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2382">  char nbuf[NUMBUFLEN];</a>
<a name="ln2383">  const char *flags = NULL;</a>
<a name="ln2384">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2385">    flags = tv_get_string_buf(&amp;argvars[1], nbuf);</a>
<a name="ln2386">  }</a>
<a name="ln2387"> </a>
<a name="ln2388">  nvim_feedkeys(cstr_as_string((char *)keys),</a>
<a name="ln2389">                cstr_as_string((char *)flags), true);</a>
<a name="ln2390">}</a>
<a name="ln2391"> </a>
<a name="ln2392">/// &quot;filereadable()&quot; function</a>
<a name="ln2393">static void f_filereadable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2394">{</a>
<a name="ln2395">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2396">  rettv-&gt;vval.v_number =</a>
<a name="ln2397">    (*p &amp;&amp; !os_isdir((const char_u *)p) &amp;&amp; os_file_is_readable(p));</a>
<a name="ln2398">}</a>
<a name="ln2399"> </a>
<a name="ln2400">/*</a>
<a name="ln2401"> * Return 0 for not writable, 1 for writable file, 2 for a dir which we have</a>
<a name="ln2402"> * rights to write into.</a>
<a name="ln2403"> */</a>
<a name="ln2404">static void f_filewritable(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2405">{</a>
<a name="ln2406">  const char *filename = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2407">  rettv-&gt;vval.v_number = os_file_is_writable(filename);</a>
<a name="ln2408">}</a>
<a name="ln2409"> </a>
<a name="ln2410"> </a>
<a name="ln2411">static void findfilendir(typval_T *argvars, typval_T *rettv, int find_what)</a>
<a name="ln2412">{</a>
<a name="ln2413">  char_u *fresult = NULL;</a>
<a name="ln2414">  char_u *path = *curbuf-&gt;b_p_path == NUL ? p_path : curbuf-&gt;b_p_path;</a>
<a name="ln2415">  int count = 1;</a>
<a name="ln2416">  bool first = true;</a>
<a name="ln2417">  bool error = false;</a>
<a name="ln2418"> </a>
<a name="ln2419">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2420">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2421"> </a>
<a name="ln2422">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2423"> </a>
<a name="ln2424">  char pathbuf[NUMBUFLEN];</a>
<a name="ln2425">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2426">    const char *p = tv_get_string_buf_chk(&amp;argvars[1], pathbuf);</a>
<a name="ln2427">    if (p == NULL) {</a>
<a name="ln2428">      error = true;</a>
<a name="ln2429">    } else {</a>
<a name="ln2430">      if (*p != NUL) {</a>
<a name="ln2431">        path = (char_u *)p;</a>
<a name="ln2432">      }</a>
<a name="ln2433"> </a>
<a name="ln2434">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2435">        count = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2436">      }</a>
<a name="ln2437">    }</a>
<a name="ln2438">  }</a>
<a name="ln2439"> </a>
<a name="ln2440">  if (count &lt; 0) {</a>
<a name="ln2441">    tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln2442">  }</a>
<a name="ln2443"> </a>
<a name="ln2444">  if (*fname != NUL &amp;&amp; !error) {</a>
<a name="ln2445">    do {</a>
<a name="ln2446">      if (rettv-&gt;v_type == VAR_STRING || rettv-&gt;v_type == VAR_LIST)</a>
<a name="ln2447">        xfree(fresult);</a>
<a name="ln2448">      fresult = find_file_in_path_option(first ? (char_u *)fname : NULL,</a>
<a name="ln2449">                                         first ? strlen(fname) : 0,</a>
<a name="ln2450">                                         0, first, path,</a>
<a name="ln2451">                                         find_what, curbuf-&gt;b_ffname,</a>
<a name="ln2452">                                         (find_what == FINDFILE_DIR</a>
<a name="ln2453">                                          ? (char_u *)&quot;&quot;</a>
<a name="ln2454">                                          : curbuf-&gt;b_p_sua));</a>
<a name="ln2455">      first = false;</a>
<a name="ln2456"> </a>
<a name="ln2457">      if (fresult != NULL &amp;&amp; rettv-&gt;v_type == VAR_LIST) {</a>
<a name="ln2458">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)fresult, -1);</a>
<a name="ln2459">      }</a>
<a name="ln2460">    } while ((rettv-&gt;v_type == VAR_LIST || --count &gt; 0) &amp;&amp; fresult != NULL);</a>
<a name="ln2461">  }</a>
<a name="ln2462"> </a>
<a name="ln2463">  if (rettv-&gt;v_type == VAR_STRING)</a>
<a name="ln2464">    rettv-&gt;vval.v_string = fresult;</a>
<a name="ln2465">}</a>
<a name="ln2466"> </a>
<a name="ln2467"> </a>
<a name="ln2468">/*</a>
<a name="ln2469"> * &quot;filter()&quot; function</a>
<a name="ln2470"> */</a>
<a name="ln2471">static void f_filter(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2472">{</a>
<a name="ln2473">  filter_map(argvars, rettv, FALSE);</a>
<a name="ln2474">}</a>
<a name="ln2475"> </a>
<a name="ln2476">/*</a>
<a name="ln2477"> * &quot;finddir({fname}[, {path}[, {count}]])&quot; function</a>
<a name="ln2478"> */</a>
<a name="ln2479">static void f_finddir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2480">{</a>
<a name="ln2481">  findfilendir(argvars, rettv, FINDFILE_DIR);</a>
<a name="ln2482">}</a>
<a name="ln2483"> </a>
<a name="ln2484">/*</a>
<a name="ln2485"> * &quot;findfile({fname}[, {path}[, {count}]])&quot; function</a>
<a name="ln2486"> */</a>
<a name="ln2487">static void f_findfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2488">{</a>
<a name="ln2489">  findfilendir(argvars, rettv, FINDFILE_FILE);</a>
<a name="ln2490">}</a>
<a name="ln2491"> </a>
<a name="ln2492">/*</a>
<a name="ln2493"> * &quot;float2nr({float})&quot; function</a>
<a name="ln2494"> */</a>
<a name="ln2495">static void f_float2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2496">{</a>
<a name="ln2497">  float_T f;</a>
<a name="ln2498"> </a>
<a name="ln2499">  if (tv_get_float_chk(argvars, &amp;f)) {</a>
<a name="ln2500">    if (f &lt;= (float_T)-VARNUMBER_MAX + DBL_EPSILON) {</a>
<a name="ln2501">      rettv-&gt;vval.v_number = -VARNUMBER_MAX;</a>
<a name="ln2502">    } else if (f &gt;= (float_T)VARNUMBER_MAX - DBL_EPSILON) {</a>
<a name="ln2503">      rettv-&gt;vval.v_number = VARNUMBER_MAX;</a>
<a name="ln2504">    } else {</a>
<a name="ln2505">      rettv-&gt;vval.v_number = (varnumber_T)f;</a>
<a name="ln2506">    }</a>
<a name="ln2507">  }</a>
<a name="ln2508">}</a>
<a name="ln2509"> </a>
<a name="ln2510">/*</a>
<a name="ln2511"> * &quot;fmod()&quot; function</a>
<a name="ln2512"> */</a>
<a name="ln2513">static void f_fmod(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2514">{</a>
<a name="ln2515">  float_T fx;</a>
<a name="ln2516">  float_T fy;</a>
<a name="ln2517"> </a>
<a name="ln2518">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln2519">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln2520">    rettv-&gt;vval.v_float = fmod(fx, fy);</a>
<a name="ln2521">  } else {</a>
<a name="ln2522">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln2523">  }</a>
<a name="ln2524">}</a>
<a name="ln2525"> </a>
<a name="ln2526">/*</a>
<a name="ln2527"> * &quot;fnameescape({string})&quot; function</a>
<a name="ln2528"> */</a>
<a name="ln2529">static void f_fnameescape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2530">{</a>
<a name="ln2531">  rettv-&gt;vval.v_string = (char_u *)vim_strsave_fnameescape(</a>
<a name="ln2532">      tv_get_string(&amp;argvars[0]), false);</a>
<a name="ln2533">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2534">}</a>
<a name="ln2535"> </a>
<a name="ln2536">/*</a>
<a name="ln2537"> * &quot;fnamemodify({fname}, {mods})&quot; function</a>
<a name="ln2538"> */</a>
<a name="ln2539">static void f_fnamemodify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2540">{</a>
<a name="ln2541">  char_u *fbuf = NULL;</a>
<a name="ln2542">  size_t len = 0;</a>
<a name="ln2543">  char buf[NUMBUFLEN];</a>
<a name="ln2544">  const char *fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln2545">  const char *const mods = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln2546">  if (fname == NULL || mods == NULL) {</a>
<a name="ln2547">    fname = NULL;</a>
<a name="ln2548">  } else {</a>
<a name="ln2549">    len = strlen(fname);</a>
<a name="ln2550">    size_t usedlen = 0;</a>
<a name="ln2551">    if (*mods != NUL) {</a>
<a name="ln2552">      (void)modify_fname((char_u *)mods, false, &amp;usedlen,</a>
<a name="ln2553">                         (char_u **)&amp;fname, &amp;fbuf, &amp;len);</a>
<a name="ln2554">    }</a>
<a name="ln2555">  }</a>
<a name="ln2556"> </a>
<a name="ln2557">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2558">  if (fname == NULL) {</a>
<a name="ln2559">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2560">  } else {</a>
<a name="ln2561">    rettv-&gt;vval.v_string = (char_u *)xmemdupz(fname, len);</a>
<a name="ln2562">  }</a>
<a name="ln2563">  xfree(fbuf);</a>
<a name="ln2564">}</a>
<a name="ln2565"> </a>
<a name="ln2566"> </a>
<a name="ln2567">/*</a>
<a name="ln2568"> * &quot;foldclosed()&quot; function</a>
<a name="ln2569"> */</a>
<a name="ln2570">static void foldclosed_both(typval_T *argvars, typval_T *rettv, int end)</a>
<a name="ln2571">{</a>
<a name="ln2572">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2573">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2574">    linenr_T first;</a>
<a name="ln2575">    linenr_T last;</a>
<a name="ln2576">    if (hasFoldingWin(curwin, lnum, &amp;first, &amp;last, false, NULL)) {</a>
<a name="ln2577">      if (end) {</a>
<a name="ln2578">        rettv-&gt;vval.v_number = (varnumber_T)last;</a>
<a name="ln2579">      } else {</a>
<a name="ln2580">        rettv-&gt;vval.v_number = (varnumber_T)first;</a>
<a name="ln2581">      }</a>
<a name="ln2582">      return;</a>
<a name="ln2583">    }</a>
<a name="ln2584">  }</a>
<a name="ln2585">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln2586">}</a>
<a name="ln2587"> </a>
<a name="ln2588">/*</a>
<a name="ln2589"> * &quot;foldclosed()&quot; function</a>
<a name="ln2590"> */</a>
<a name="ln2591">static void f_foldclosed(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2592">{</a>
<a name="ln2593">  foldclosed_both(argvars, rettv, FALSE);</a>
<a name="ln2594">}</a>
<a name="ln2595"> </a>
<a name="ln2596">/*</a>
<a name="ln2597"> * &quot;foldclosedend()&quot; function</a>
<a name="ln2598"> */</a>
<a name="ln2599">static void f_foldclosedend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2600">{</a>
<a name="ln2601">  foldclosed_both(argvars, rettv, TRUE);</a>
<a name="ln2602">}</a>
<a name="ln2603"> </a>
<a name="ln2604">/*</a>
<a name="ln2605"> * &quot;foldlevel()&quot; function</a>
<a name="ln2606"> */</a>
<a name="ln2607">static void f_foldlevel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2608">{</a>
<a name="ln2609">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2610">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2611">    rettv-&gt;vval.v_number = foldLevel(lnum);</a>
<a name="ln2612">  }</a>
<a name="ln2613">}</a>
<a name="ln2614"> </a>
<a name="ln2615">/*</a>
<a name="ln2616"> * &quot;foldtext()&quot; function</a>
<a name="ln2617"> */</a>
<a name="ln2618">static void f_foldtext(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2619">{</a>
<a name="ln2620">  linenr_T    foldstart;</a>
<a name="ln2621">  linenr_T    foldend;</a>
<a name="ln2622">  char_u      *dashes;</a>
<a name="ln2623">  linenr_T    lnum;</a>
<a name="ln2624">  char_u      *s;</a>
<a name="ln2625">  char_u      *r;</a>
<a name="ln2626">  int         len;</a>
<a name="ln2627">  char        *txt;</a>
<a name="ln2628"> </a>
<a name="ln2629">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2630">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2631"> </a>
<a name="ln2632">  foldstart = (linenr_T)get_vim_var_nr(VV_FOLDSTART);</a>
<a name="ln2633">  foldend = (linenr_T)get_vim_var_nr(VV_FOLDEND);</a>
<a name="ln2634">  dashes = get_vim_var_str(VV_FOLDDASHES);</a>
<a name="ln2635">  if (foldstart &gt; 0 &amp;&amp; foldend &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2636">    // Find first non-empty line in the fold.</a>
<a name="ln2637">    for (lnum = foldstart; lnum &lt; foldend; lnum++) {</a>
<a name="ln2638">      if (!linewhite(lnum)) {</a>
<a name="ln2639">        break;</a>
<a name="ln2640">      }</a>
<a name="ln2641">    }</a>
<a name="ln2642"> </a>
<a name="ln2643">    // Find interesting text in this line.</a>
<a name="ln2644">    s = skipwhite(ml_get(lnum));</a>
<a name="ln2645">    // skip C comment-start</a>
<a name="ln2646">    if (s[0] == '/' &amp;&amp; (s[1] == '*' || s[1] == '/')) {</a>
<a name="ln2647">      s = skipwhite(s + 2);</a>
<a name="ln2648">      if (*skipwhite(s) == NUL &amp;&amp; lnum + 1 &lt; foldend) {</a>
<a name="ln2649">        s = skipwhite(ml_get(lnum + 1));</a>
<a name="ln2650">        if (*s == '*')</a>
<a name="ln2651">          s = skipwhite(s + 1);</a>
<a name="ln2652">      }</a>
<a name="ln2653">    }</a>
<a name="ln2654">    unsigned long count = (unsigned long)(foldend - foldstart + 1);</a>
<a name="ln2655">    txt = NGETTEXT(&quot;+-%s%3ld line: &quot;, &quot;+-%s%3ld lines: &quot;, count);</a>
<a name="ln2656">    r = xmalloc(STRLEN(txt)</a>
<a name="ln2657">                + STRLEN(dashes)  // for %s</a>
<a name="ln2658">                + 20              // for %3ld</a>
<a name="ln2659">                + STRLEN(s));     // concatenated</a>
<a name="ln2660">    sprintf((char *)r, txt, dashes, count);</a>
<a name="ln2661">    len = (int)STRLEN(r);</a>
<a name="ln2662">    STRCAT(r, s);</a>
<a name="ln2663">    // remove 'foldmarker' and 'commentstring'</a>
<a name="ln2664">    foldtext_cleanup(r + len);</a>
<a name="ln2665">    rettv-&gt;vval.v_string = r;</a>
<a name="ln2666">  }</a>
<a name="ln2667">}</a>
<a name="ln2668"> </a>
<a name="ln2669">/*</a>
<a name="ln2670"> * &quot;foldtextresult(lnum)&quot; function</a>
<a name="ln2671"> */</a>
<a name="ln2672">static void f_foldtextresult(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2673">{</a>
<a name="ln2674">  char_u      *text;</a>
<a name="ln2675">  char_u buf[FOLD_TEXT_LEN];</a>
<a name="ln2676">  static bool entered = false;</a>
<a name="ln2677"> </a>
<a name="ln2678">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2679">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2680">  if (entered) {</a>
<a name="ln2681">    return;  // reject recursive use</a>
<a name="ln2682">  }</a>
<a name="ln2683">  entered = true;</a>
<a name="ln2684">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln2685">  // Treat illegal types and illegal string values for {lnum} the same.</a>
<a name="ln2686">  if (lnum &lt; 0) {</a>
<a name="ln2687">    lnum = 0;</a>
<a name="ln2688">  }</a>
<a name="ln2689"> </a>
<a name="ln2690">  foldinfo_T info = fold_info(curwin, lnum);</a>
<a name="ln2691">  if (info.fi_lines &gt; 0) {</a>
<a name="ln2692">    text = get_foldtext(curwin, lnum, lnum + info.fi_lines - 1, info, buf);</a>
<a name="ln2693">    if (text == buf) {</a>
<a name="ln2694">      text = vim_strsave(text);</a>
<a name="ln2695">    }</a>
<a name="ln2696">    rettv-&gt;vval.v_string = text;</a>
<a name="ln2697">  }</a>
<a name="ln2698"> </a>
<a name="ln2699">  entered = false;</a>
<a name="ln2700">}</a>
<a name="ln2701"> </a>
<a name="ln2702">/*</a>
<a name="ln2703"> * &quot;foreground()&quot; function</a>
<a name="ln2704"> */</a>
<a name="ln2705">static void f_foreground(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2706">{</a>
<a name="ln2707">}</a>
<a name="ln2708"> </a>
<a name="ln2709">static void f_funcref(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2710">{</a>
<a name="ln2711">  common_function(argvars, rettv, true, fptr);</a>
<a name="ln2712">}</a>
<a name="ln2713"> </a>
<a name="ln2714">static void f_function(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2715">{</a>
<a name="ln2716">  common_function(argvars, rettv, false, fptr);</a>
<a name="ln2717">}</a>
<a name="ln2718"> </a>
<a name="ln2719">/// &quot;garbagecollect()&quot; function</a>
<a name="ln2720">static void f_garbagecollect(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2721">{</a>
<a name="ln2722">  // This is postponed until we are back at the toplevel, because we may be</a>
<a name="ln2723">  // using Lists and Dicts internally.  E.g.: &quot;:echo [garbagecollect()]&quot;.</a>
<a name="ln2724">  want_garbage_collect = true;</a>
<a name="ln2725"> </a>
<a name="ln2726">  if (argvars[0].v_type != VAR_UNKNOWN &amp;&amp; tv_get_number(&amp;argvars[0]) == 1) {</a>
<a name="ln2727">    garbage_collect_at_exit = true;</a>
<a name="ln2728">  }</a>
<a name="ln2729">}</a>
<a name="ln2730"> </a>
<a name="ln2731">/*</a>
<a name="ln2732"> * &quot;get()&quot; function</a>
<a name="ln2733"> */</a>
<a name="ln2734">static void f_get(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2735">{</a>
<a name="ln2736">  listitem_T  *li;</a>
<a name="ln2737">  list_T      *l;</a>
<a name="ln2738">  dictitem_T  *di;</a>
<a name="ln2739">  dict_T      *d;</a>
<a name="ln2740">  typval_T    *tv = NULL;</a>
<a name="ln2741">  bool what_is_dict = false;</a>
<a name="ln2742"> </a>
<a name="ln2743">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln2744">    if ((l = argvars[0].vval.v_list) != NULL) {</a>
<a name="ln2745">      bool error = false;</a>
<a name="ln2746"> </a>
<a name="ln2747">      li = tv_list_find(l, tv_get_number_chk(&amp;argvars[1], &amp;error));</a>
<a name="ln2748">      if (!error &amp;&amp; li != NULL) {</a>
<a name="ln2749">        tv = TV_LIST_ITEM_TV(li);</a>
<a name="ln2750">      }</a>
<a name="ln2751">    }</a>
<a name="ln2752">  } else if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln2753">    if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln2754">      di = tv_dict_find(d, tv_get_string(&amp;argvars[1]), -1);</a>
<a name="ln2755">      if (di != NULL) {</a>
<a name="ln2756">        tv = &amp;di-&gt;di_tv;</a>
<a name="ln2757">      }</a>
<a name="ln2758">    }</a>
<a name="ln2759">  } else if (tv_is_func(argvars[0])) {</a>
<a name="ln2760">    partial_T *pt;</a>
<a name="ln2761">    partial_T fref_pt;</a>
<a name="ln2762"> </a>
<a name="ln2763">    if (argvars[0].v_type == VAR_PARTIAL) {</a>
<a name="ln2764">      pt = argvars[0].vval.v_partial;</a>
<a name="ln2765">    } else {</a>
<a name="ln2766">      memset(&amp;fref_pt, 0, sizeof(fref_pt));</a>
<a name="ln2767">      fref_pt.pt_name = argvars[0].vval.v_string;</a>
<a name="ln2768">      pt = &amp;fref_pt;</a>
<a name="ln2769">    }</a>
<a name="ln2770"> </a>
<a name="ln2771">    if (pt != NULL) {</a>
<a name="ln2772">      const char *const what = tv_get_string(&amp;argvars[1]);</a>
<a name="ln2773"> </a>
<a name="ln2774">      if (strcmp(what, &quot;func&quot;) == 0 || strcmp(what, &quot;name&quot;) == 0) {</a>
<a name="ln2775">        rettv-&gt;v_type = (*what == 'f' ? VAR_FUNC : VAR_STRING);</a>
<a name="ln2776">        const char *const n = (const char *)partial_name(pt);</a>
<a name="ln2777">        assert(n != NULL);</a>
<a name="ln2778">        rettv-&gt;vval.v_string = (char_u *)xstrdup(n);</a>
<a name="ln2779">        if (rettv-&gt;v_type == VAR_FUNC) {</a>
<a name="ln2780">          func_ref(rettv-&gt;vval.v_string);</a>
<a name="ln2781">        }</a>
<a name="ln2782">      } else if (strcmp(what, &quot;dict&quot;) == 0) {</a>
<a name="ln2783">        what_is_dict = true;</a>
<a name="ln2784">        if (pt-&gt;pt_dict != NULL) {</a>
<a name="ln2785">          tv_dict_set_ret(rettv, pt-&gt;pt_dict);</a>
<a name="ln2786">        }</a>
<a name="ln2787">      } else if (strcmp(what, &quot;args&quot;) == 0) {</a>
<a name="ln2788">        rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln2789">        tv_list_alloc_ret(rettv, pt-&gt;pt_argc);</a>
<a name="ln2790">        for (int i = 0; i &lt; pt-&gt;pt_argc; i++) {</a>
<a name="ln2791">          tv_list_append_tv(rettv-&gt;vval.v_list, &amp;pt-&gt;pt_argv[i]);</a>
<a name="ln2792">        }</a>
<a name="ln2793">      } else {</a>
<a name="ln2794">        EMSG2(_(e_invarg2), what);</a>
<a name="ln2795">      }</a>
<a name="ln2796"> </a>
<a name="ln2797">      // When {what} == &quot;dict&quot; and pt-&gt;pt_dict == NULL, evaluate the</a>
<a name="ln2798">      // third argument</a>
<a name="ln2799">      if (!what_is_dict) {</a>
<a name="ln2800">        return;</a>
<a name="ln2801">      }</a>
<a name="ln2802">    }</a>
<a name="ln2803">  } else {</a>
<a name="ln2804">    EMSG2(_(e_listdictarg), &quot;get()&quot;);</a>
<a name="ln2805">  }</a>
<a name="ln2806"> </a>
<a name="ln2807">  if (tv == NULL) {</a>
<a name="ln2808">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2809">      tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln2810">    }</a>
<a name="ln2811">  } else {</a>
<a name="ln2812">    tv_copy(tv, rettv);</a>
<a name="ln2813">  }</a>
<a name="ln2814">}</a>
<a name="ln2815"> </a>
<a name="ln2816">/// &quot;getbufinfo()&quot; function</a>
<a name="ln2817">static void f_getbufinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2818">{</a>
<a name="ln2819">  buf_T *argbuf = NULL;</a>
<a name="ln2820">  bool filtered = false;</a>
<a name="ln2821">  bool sel_buflisted = false;</a>
<a name="ln2822">  bool sel_bufloaded = false;</a>
<a name="ln2823">  bool sel_bufmodified = false;</a>
<a name="ln2824"> </a>
<a name="ln2825">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln2826"> </a>
<a name="ln2827">  // List of all the buffers or selected buffers</a>
<a name="ln2828">  if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln2829">    dict_T *sel_d = argvars[0].vval.v_dict;</a>
<a name="ln2830"> </a>
<a name="ln2831">    if (sel_d != NULL) {</a>
<a name="ln2832">      dictitem_T *di;</a>
<a name="ln2833"> </a>
<a name="ln2834">      filtered = true;</a>
<a name="ln2835"> </a>
<a name="ln2836">      di = tv_dict_find(sel_d, S_LEN(&quot;buflisted&quot;));</a>
<a name="ln2837">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2838">        sel_buflisted = true;</a>
<a name="ln2839">      }</a>
<a name="ln2840"> </a>
<a name="ln2841">      di = tv_dict_find(sel_d, S_LEN(&quot;bufloaded&quot;));</a>
<a name="ln2842">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2843">        sel_bufloaded = true;</a>
<a name="ln2844">      }</a>
<a name="ln2845">      di = tv_dict_find(sel_d, S_LEN(&quot;bufmodified&quot;));</a>
<a name="ln2846">      if (di != NULL &amp;&amp; tv_get_number(&amp;di-&gt;di_tv)) {</a>
<a name="ln2847">        sel_bufmodified = true;</a>
<a name="ln2848">      }</a>
<a name="ln2849">    }</a>
<a name="ln2850">  } else if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln2851">    // Information about one buffer.  Argument specifies the buffer</a>
<a name="ln2852">    argbuf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln2853">    if (argbuf == NULL) {</a>
<a name="ln2854">      return;</a>
<a name="ln2855">    }</a>
<a name="ln2856">  }</a>
<a name="ln2857"> </a>
<a name="ln2858">  // Return information about all the buffers or a specified buffer</a>
<a name="ln2859">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2860">    if (argbuf != NULL &amp;&amp; argbuf != buf) {</a>
<a name="ln2861">      continue;</a>
<a name="ln2862">    }</a>
<a name="ln2863">    if (filtered &amp;&amp; ((sel_bufloaded &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL)</a>
<a name="ln2864">                     || (sel_buflisted &amp;&amp; !buf-&gt;b_p_bl)</a>
<a name="ln2865">                     || (sel_bufmodified &amp;&amp; !buf-&gt;b_changed))) {</a>
<a name="ln2866">      continue;</a>
<a name="ln2867">    }</a>
<a name="ln2868"> </a>
<a name="ln2869">    dict_T *const d = get_buffer_info(buf);</a>
<a name="ln2870">    tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln2871">    if (argbuf != NULL) {</a>
<a name="ln2872">      return;</a>
<a name="ln2873">    }</a>
<a name="ln2874">  }</a>
<a name="ln2875">}</a>
<a name="ln2876"> </a>
<a name="ln2877">/*</a>
<a name="ln2878"> * Get line or list of lines from buffer &quot;buf&quot; into &quot;rettv&quot;.</a>
<a name="ln2879"> * Return a range (from start to end) of lines in rettv from the specified</a>
<a name="ln2880"> * buffer.</a>
<a name="ln2881"> * If 'retlist' is TRUE, then the lines are returned as a Vim List.</a>
<a name="ln2882"> */</a>
<a name="ln2883">static void get_buffer_lines(buf_T *buf,</a>
<a name="ln2884">                             linenr_T start,</a>
<a name="ln2885">                             linenr_T end,</a>
<a name="ln2886">                             int retlist,</a>
<a name="ln2887">                             typval_T *rettv)</a>
<a name="ln2888">{</a>
<a name="ln2889">  rettv-&gt;v_type = (retlist ? VAR_LIST : VAR_STRING);</a>
<a name="ln2890">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2891"> </a>
<a name="ln2892">  if (buf == NULL || buf-&gt;b_ml.ml_mfp == NULL || start &lt; 0 || end &lt; start) {</a>
<a name="ln2893">    if (retlist) {</a>
<a name="ln2894">      tv_list_alloc_ret(rettv, 0);</a>
<a name="ln2895">    }</a>
<a name="ln2896">    return;</a>
<a name="ln2897">  }</a>
<a name="ln2898"> </a>
<a name="ln2899">  if (retlist) {</a>
<a name="ln2900">    if (start &lt; 1) {</a>
<a name="ln2901">      start = 1;</a>
<a name="ln2902">    }</a>
<a name="ln2903">    if (end &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2904">      end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2905">    }</a>
<a name="ln2906">    tv_list_alloc_ret(rettv, end - start + 1);</a>
<a name="ln2907">    while (start &lt;= end) {</a>
<a name="ln2908">      tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln2909">                            (const char *)ml_get_buf(buf, start++, false), -1);</a>
<a name="ln2910">    }</a>
<a name="ln2911">  } else {</a>
<a name="ln2912">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2913">    rettv-&gt;vval.v_string = ((start &gt;= 1 &amp;&amp; start &lt;= buf-&gt;b_ml.ml_line_count)</a>
<a name="ln2914">                            ? vim_strsave(ml_get_buf(buf, start, false))</a>
<a name="ln2915">                            : NULL);</a>
<a name="ln2916">  }</a>
<a name="ln2917">}</a>
<a name="ln2918"> </a>
<a name="ln2919">/*</a>
<a name="ln2920"> * &quot;getbufline()&quot; function</a>
<a name="ln2921"> */</a>
<a name="ln2922">static void f_getbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2923">{</a>
<a name="ln2924">  buf_T *const buf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln2925"> </a>
<a name="ln2926">  const linenr_T lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln2927">  const linenr_T end = (argvars[2].v_type == VAR_UNKNOWN</a>
<a name="ln2928">                        ? lnum</a>
<a name="ln2929">                        : tv_get_lnum_buf(&amp;argvars[2], buf));</a>
<a name="ln2930"> </a>
<a name="ln2931">  get_buffer_lines(buf, lnum, end, true, rettv);</a>
<a name="ln2932">}</a>
<a name="ln2933"> </a>
<a name="ln2934">/*</a>
<a name="ln2935"> * &quot;getbufvar()&quot; function</a>
<a name="ln2936"> */</a>
<a name="ln2937">static void f_getbufvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2938">{</a>
<a name="ln2939">  bool done = false;</a>
<a name="ln2940"> </a>
<a name="ln2941">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2942">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2943"> </a>
<a name="ln2944">  if (!tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln2945">    goto f_getbufvar_end;</a>
<a name="ln2946">  }</a>
<a name="ln2947"> </a>
<a name="ln2948">  const char *varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln2949">  emsg_off++;</a>
<a name="ln2950">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln2951"> </a>
<a name="ln2952">  if (buf != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln2953">    if (*varname == '&amp;') {  // buffer-local-option</a>
<a name="ln2954">      buf_T *const save_curbuf = curbuf;</a>
<a name="ln2955"> </a>
<a name="ln2956">      // set curbuf to be our buf, temporarily</a>
<a name="ln2957">      curbuf = buf;</a>
<a name="ln2958"> </a>
<a name="ln2959">      if (varname[1] == NUL) {</a>
<a name="ln2960">        // get all buffer-local options in a dict</a>
<a name="ln2961">        dict_T *opts = get_winbuf_options(true);</a>
<a name="ln2962"> </a>
<a name="ln2963">        if (opts != NULL) {</a>
<a name="ln2964">          tv_dict_set_ret(rettv, opts);</a>
<a name="ln2965">          done = true;</a>
<a name="ln2966">        }</a>
<a name="ln2967">      } else if (get_option_tv(&amp;varname, rettv, true) == OK) {</a>
<a name="ln2968">        // buffer-local-option</a>
<a name="ln2969">        done = true;</a>
<a name="ln2970">      }</a>
<a name="ln2971"> </a>
<a name="ln2972">      // restore previous notion of curbuf</a>
<a name="ln2973">      curbuf = save_curbuf;</a>
<a name="ln2974">    } else {</a>
<a name="ln2975">      // Look up the variable.</a>
<a name="ln2976">      // Let getbufvar({nr}, &quot;&quot;) return the &quot;b:&quot; dictionary.</a>
<a name="ln2977">      dictitem_T *const v = *varname == NUL</a>
<a name="ln2978">        ? (dictitem_T *)&amp;buf-&gt;b_bufvar</a>
<a name="ln2979">        : find_var_in_ht(&amp;buf-&gt;b_vars-&gt;dv_hashtab, 'b',</a>
<a name="ln2980">                         varname, strlen(varname), false);</a>
<a name="ln2981">      if (v != NULL) {</a>
<a name="ln2982">        tv_copy(&amp;v-&gt;di_tv, rettv);</a>
<a name="ln2983">        done = true;</a>
<a name="ln2984">      }</a>
<a name="ln2985">    }</a>
<a name="ln2986">  }</a>
<a name="ln2987">  emsg_off--;</a>
<a name="ln2988"> </a>
<a name="ln2989">f_getbufvar_end:</a>
<a name="ln2990">  if (!done &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2991">    // use the default value</a>
<a name="ln2992">    tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln2993">  }</a>
<a name="ln2994">}</a>
<a name="ln2995"> </a>
<a name="ln2996">// &quot;getchangelist()&quot; function</a>
<a name="ln2997">static void f_getchangelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln2998">{</a>
<a name="ln2999">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln3000">  vim_ignored = tv_get_number(&amp;argvars[0]);  // issue errmsg if type error</a>
<a name="ln3001">  emsg_off++;</a>
<a name="ln3002">  const buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln3003">  emsg_off--;</a>
<a name="ln3004">  if (buf == NULL) {</a>
<a name="ln3005">    return;</a>
<a name="ln3006">  }</a>
<a name="ln3007"> </a>
<a name="ln3008">  list_T *const l = tv_list_alloc(buf-&gt;b_changelistlen);</a>
<a name="ln3009">  tv_list_append_list(rettv-&gt;vval.v_list, l);</a>
<a name="ln3010">  // The current window change list index tracks only the position in the</a>
<a name="ln3011">  // current buffer change list. For other buffers, use the change list</a>
<a name="ln3012">  // length as the current index.</a>
<a name="ln3013">  tv_list_append_number(rettv-&gt;vval.v_list,</a>
<a name="ln3014">                        (buf == curwin-&gt;w_buffer)</a>
<a name="ln3015">                        ? curwin-&gt;w_changelistidx</a>
<a name="ln3016">                        : buf-&gt;b_changelistlen);</a>
<a name="ln3017"> </a>
<a name="ln3018">  for (int i = 0; i &lt; buf-&gt;b_changelistlen; i++) {</a>
<a name="ln3019">    if (buf-&gt;b_changelist[i].mark.lnum == 0) {</a>
<a name="ln3020">      continue;</a>
<a name="ln3021">    }</a>
<a name="ln3022">    dict_T *const d = tv_dict_alloc();</a>
<a name="ln3023">    tv_list_append_dict(l, d);</a>
<a name="ln3024">    tv_dict_add_nr(d, S_LEN(&quot;lnum&quot;), buf-&gt;b_changelist[i].mark.lnum);</a>
<a name="ln3025">    tv_dict_add_nr(d, S_LEN(&quot;col&quot;), buf-&gt;b_changelist[i].mark.col);</a>
<a name="ln3026">    tv_dict_add_nr(d, S_LEN(&quot;coladd&quot;), buf-&gt;b_changelist[i].mark.coladd);</a>
<a name="ln3027">  }</a>
<a name="ln3028">}</a>
<a name="ln3029"> </a>
<a name="ln3030">/*</a>
<a name="ln3031"> * &quot;getchar()&quot; function</a>
<a name="ln3032"> */</a>
<a name="ln3033">static void f_getchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3034">{</a>
<a name="ln3035">  varnumber_T n;</a>
<a name="ln3036">  bool error = false;</a>
<a name="ln3037"> </a>
<a name="ln3038">  no_mapping++;</a>
<a name="ln3039">  for (;; ) {</a>
<a name="ln3040">    // Position the cursor.  Needed after a message that ends in a space,</a>
<a name="ln3041">    // or if event processing caused a redraw.</a>
<a name="ln3042">    ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln3043"> </a>
<a name="ln3044">    if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln3045">      // getchar(): blocking wait.</a>
<a name="ln3046">      // TODO(bfredl): deduplicate shared logic with state_enter ?</a>
<a name="ln3047">      if (!(char_avail() || using_script() || input_available())) {</a>
<a name="ln3048">        (void)os_inchar(NULL, 0, -1, 0, main_loop.events);</a>
<a name="ln3049">        if (!multiqueue_empty(main_loop.events)) {</a>
<a name="ln3050">          state_handle_k_event();</a>
<a name="ln3051">          continue;</a>
<a name="ln3052">        }</a>
<a name="ln3053">      }</a>
<a name="ln3054">      n = safe_vgetc();</a>
<a name="ln3055">    } else if (tv_get_number_chk(&amp;argvars[0], &amp;error) == 1) {</a>
<a name="ln3056">      // getchar(1): only check if char avail</a>
<a name="ln3057">      n = vpeekc_any();</a>
<a name="ln3058">    } else if (error || vpeekc_any() == NUL) {</a>
<a name="ln3059">      // illegal argument or getchar(0) and no char avail: return zero</a>
<a name="ln3060">      n = 0;</a>
<a name="ln3061">    } else {</a>
<a name="ln3062">      // getchar(0) and char avail() != NUL: get a character.</a>
<a name="ln3063">      // Note that vpeekc_any() returns K_SPECIAL for K_IGNORE.</a>
<a name="ln3064">      n = safe_vgetc();</a>
<a name="ln3065">    }</a>
<a name="ln3066"> </a>
<a name="ln3067">    if (n == K_IGNORE</a>
<a name="ln3068">        || n == K_MOUSEMOVE</a>
<a name="ln3069">        || n == K_VER_SCROLLBAR</a>
<a name="ln3070">        || n == K_HOR_SCROLLBAR) {</a>
<a name="ln3071">      continue;</a>
<a name="ln3072">    }</a>
<a name="ln3073">    break;</a>
<a name="ln3074">  }</a>
<a name="ln3075">  no_mapping--;</a>
<a name="ln3076"> </a>
<a name="ln3077">  set_vim_var_nr(VV_MOUSE_WIN, 0);</a>
<a name="ln3078">  set_vim_var_nr(VV_MOUSE_WINID, 0);</a>
<a name="ln3079">  set_vim_var_nr(VV_MOUSE_LNUM, 0);</a>
<a name="ln3080">  set_vim_var_nr(VV_MOUSE_COL, 0);</a>
<a name="ln3081"> </a>
<a name="ln3082">  rettv-&gt;vval.v_number = n;</a>
<a name="ln3083">  if (IS_SPECIAL(n) || mod_mask != 0) {</a>
<a name="ln3084">    char_u temp[10];                // modifier: 3, mbyte-char: 6, NUL: 1</a>
<a name="ln3085">    int i = 0;</a>
<a name="ln3086"> </a>
<a name="ln3087">    // Turn a special key into three bytes, plus modifier.</a>
<a name="ln3088">    if (mod_mask != 0) {</a>
<a name="ln3089">      temp[i++] = K_SPECIAL;</a>
<a name="ln3090">      temp[i++] = KS_MODIFIER;</a>
<a name="ln3091">      temp[i++] = mod_mask;</a>
<a name="ln3092">    }</a>
<a name="ln3093">    if (IS_SPECIAL(n)) {</a>
<a name="ln3094">      temp[i++] = K_SPECIAL;</a>
<a name="ln3095">      temp[i++] = K_SECOND(n);</a>
<a name="ln3096">      temp[i++] = K_THIRD(n);</a>
<a name="ln3097">    } else {</a>
<a name="ln3098">      i += utf_char2bytes(n, temp + i);</a>
<a name="ln3099">    }</a>
<a name="ln3100">    temp[i++] = NUL;</a>
<a name="ln3101">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3102">    rettv-&gt;vval.v_string = vim_strsave(temp);</a>
<a name="ln3103"> </a>
<a name="ln3104">    if (is_mouse_key(n)) {</a>
<a name="ln3105">      int row = mouse_row;</a>
<a name="ln3106">      int col = mouse_col;</a>
<a name="ln3107">      int grid = mouse_grid;</a>
<a name="ln3108">      win_T       *win;</a>
<a name="ln3109">      linenr_T lnum;</a>
<a name="ln3110">      win_T       *wp;</a>
<a name="ln3111">      int winnr = 1;</a>
<a name="ln3112"> </a>
<a name="ln3113">      if (row &gt;= 0 &amp;&amp; col &gt;= 0) {</a>
<a name="ln3114">        /* Find the window at the mouse coordinates and compute the</a>
<a name="ln3115">         * text position. */</a>
<a name="ln3116">        win = mouse_find_win(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln3117">        if (win == NULL) {</a>
<a name="ln3118">          return;</a>
<a name="ln3119">        }</a>
<a name="ln3120">        (void)mouse_comp_pos(win, &amp;row, &amp;col, &amp;lnum);</a>
<a name="ln3121">        for (wp = firstwin; wp != win; wp = wp-&gt;w_next)</a>
<a name="ln3122">          ++winnr;</a>
<a name="ln3123">        set_vim_var_nr(VV_MOUSE_WIN, winnr);</a>
<a name="ln3124">        set_vim_var_nr(VV_MOUSE_WINID, wp-&gt;handle);</a>
<a name="ln3125">        set_vim_var_nr(VV_MOUSE_LNUM, lnum);</a>
<a name="ln3126">        set_vim_var_nr(VV_MOUSE_COL, col + 1);</a>
<a name="ln3127">      }</a>
<a name="ln3128">    }</a>
<a name="ln3129">  }</a>
<a name="ln3130">}</a>
<a name="ln3131"> </a>
<a name="ln3132">/*</a>
<a name="ln3133"> * &quot;getcharmod()&quot; function</a>
<a name="ln3134"> */</a>
<a name="ln3135">static void f_getcharmod(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3136">{</a>
<a name="ln3137">  rettv-&gt;vval.v_number = mod_mask;</a>
<a name="ln3138">}</a>
<a name="ln3139"> </a>
<a name="ln3140">/*</a>
<a name="ln3141"> * &quot;getcharsearch()&quot; function</a>
<a name="ln3142"> */</a>
<a name="ln3143">static void f_getcharsearch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3144">{</a>
<a name="ln3145">  tv_dict_alloc_ret(rettv);</a>
<a name="ln3146"> </a>
<a name="ln3147">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln3148"> </a>
<a name="ln3149">  tv_dict_add_str(dict, S_LEN(&quot;char&quot;), last_csearch());</a>
<a name="ln3150">  tv_dict_add_nr(dict, S_LEN(&quot;forward&quot;), last_csearch_forward());</a>
<a name="ln3151">  tv_dict_add_nr(dict, S_LEN(&quot;until&quot;), last_csearch_until());</a>
<a name="ln3152">}</a>
<a name="ln3153"> </a>
<a name="ln3154">/*</a>
<a name="ln3155"> * &quot;getcmdline()&quot; function</a>
<a name="ln3156"> */</a>
<a name="ln3157">static void f_getcmdline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3158">{</a>
<a name="ln3159">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3160">  rettv-&gt;vval.v_string = get_cmdline_str();</a>
<a name="ln3161">}</a>
<a name="ln3162"> </a>
<a name="ln3163">/*</a>
<a name="ln3164"> * &quot;getcmdpos()&quot; function</a>
<a name="ln3165"> */</a>
<a name="ln3166">static void f_getcmdpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3167">{</a>
<a name="ln3168">  rettv-&gt;vval.v_number = get_cmdline_pos() + 1;</a>
<a name="ln3169">}</a>
<a name="ln3170"> </a>
<a name="ln3171">/*</a>
<a name="ln3172"> * &quot;getcmdtype()&quot; function</a>
<a name="ln3173"> */</a>
<a name="ln3174">static void f_getcmdtype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3175">{</a>
<a name="ln3176">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3177">  rettv-&gt;vval.v_string = xmallocz(1);</a>
<a name="ln3178">  rettv-&gt;vval.v_string[0] = get_cmdline_type();</a>
<a name="ln3179">}</a>
<a name="ln3180"> </a>
<a name="ln3181">/*</a>
<a name="ln3182"> * &quot;getcmdwintype()&quot; function</a>
<a name="ln3183"> */</a>
<a name="ln3184">static void f_getcmdwintype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3185">{</a>
<a name="ln3186">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3187">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3188">  rettv-&gt;vval.v_string = xmallocz(1);</a>
<a name="ln3189">  rettv-&gt;vval.v_string[0] = cmdwin_type;</a>
<a name="ln3190">}</a>
<a name="ln3191"> </a>
<a name="ln3192">// &quot;getcompletion()&quot; function</a>
<a name="ln3193">static void f_getcompletion(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3194">{</a>
<a name="ln3195">  char_u        *pat;</a>
<a name="ln3196">  expand_T      xpc;</a>
<a name="ln3197">  bool          filtered = false;</a>
<a name="ln3198">  int           options = WILD_SILENT | WILD_USE_NL | WILD_ADD_SLASH</a>
<a name="ln3199">          | WILD_NO_BEEP;</a>
<a name="ln3200"> </a>
<a name="ln3201">  if (argvars[1].v_type != VAR_STRING) {</a>
<a name="ln3202">    EMSG2(_(e_invarg2), &quot;type must be a string&quot;);</a>
<a name="ln3203">    return;</a>
<a name="ln3204">  }</a>
<a name="ln3205">  const char *const type = tv_get_string(&amp;argvars[1]);</a>
<a name="ln3206"> </a>
<a name="ln3207">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3208">    filtered = (bool)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln3209">  }</a>
<a name="ln3210"> </a>
<a name="ln3211">  if (p_wic) {</a>
<a name="ln3212">    options |= WILD_ICASE;</a>
<a name="ln3213">  }</a>
<a name="ln3214"> </a>
<a name="ln3215">  // For filtered results, 'wildignore' is used</a>
<a name="ln3216">  if (!filtered) {</a>
<a name="ln3217">    options |= WILD_KEEP_ALL;</a>
<a name="ln3218">  }</a>
<a name="ln3219"> </a>
<a name="ln3220">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln3221">    EMSG(_(e_invarg));</a>
<a name="ln3222">    return;</a>
<a name="ln3223">  }</a>
<a name="ln3224"> </a>
<a name="ln3225">  if (strcmp(type, &quot;cmdline&quot;) == 0) {</a>
<a name="ln3226">    set_one_cmd_context(&amp;xpc, tv_get_string(&amp;argvars[0]));</a>
<a name="ln3227">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3228">    goto theend;</a>
<a name="ln3229">  }</a>
<a name="ln3230"> </a>
<a name="ln3231">  ExpandInit(&amp;xpc);</a>
<a name="ln3232">  xpc.xp_pattern = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln3233">  xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3234">  xpc.xp_context = cmdcomplete_str_to_type(type);</a>
<a name="ln3235">  if (xpc.xp_context == EXPAND_NOTHING) {</a>
<a name="ln3236">    EMSG2(_(e_invarg2), type);</a>
<a name="ln3237">    return;</a>
<a name="ln3238">  }</a>
<a name="ln3239"> </a>
<a name="ln3240">  if (xpc.xp_context == EXPAND_MENUS) {</a>
<a name="ln3241">    set_context_in_menu_cmd(&amp;xpc, &quot;menu&quot;, xpc.xp_pattern, false);</a>
<a name="ln3242">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3243">  }</a>
<a name="ln3244"> </a>
<a name="ln3245">  if (xpc.xp_context == EXPAND_CSCOPE) {</a>
<a name="ln3246">    set_context_in_cscope_cmd(&amp;xpc, (const char *)xpc.xp_pattern, CMD_cscope);</a>
<a name="ln3247">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3248">  }</a>
<a name="ln3249"> </a>
<a name="ln3250">  if (xpc.xp_context == EXPAND_SIGN) {</a>
<a name="ln3251">    set_context_in_sign_cmd(&amp;xpc, xpc.xp_pattern);</a>
<a name="ln3252">    xpc.xp_pattern_len = STRLEN(xpc.xp_pattern);</a>
<a name="ln3253">  }</a>
<a name="ln3254"> </a>
<a name="ln3255">theend:</a>
<a name="ln3256">  pat = addstar(xpc.xp_pattern, xpc.xp_pattern_len, xpc.xp_context);</a>
<a name="ln3257">  ExpandOne(&amp;xpc, pat, NULL, options, WILD_ALL_KEEP);</a>
<a name="ln3258">  tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln3259"> </a>
<a name="ln3260">  for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln3261">    tv_list_append_string(rettv-&gt;vval.v_list, (const char *)xpc.xp_files[i],</a>
<a name="ln3262">                          -1);</a>
<a name="ln3263">  }</a>
<a name="ln3264">  xfree(pat);</a>
<a name="ln3265">  ExpandCleanup(&amp;xpc);</a>
<a name="ln3266">}</a>
<a name="ln3267"> </a>
<a name="ln3268">/// `getcwd([{win}[, {tab}]])` function</a>
<a name="ln3269">///</a>
<a name="ln3270">/// Every scope not specified implies the currently selected scope object.</a>
<a name="ln3271">///</a>
<a name="ln3272">/// @pre  The arguments must be of type number.</a>
<a name="ln3273">/// @pre  There may not be more than two arguments.</a>
<a name="ln3274">/// @pre  An argument may not be -1 if preceding arguments are not all -1.</a>
<a name="ln3275">///</a>
<a name="ln3276">/// @post  The return value will be a string.</a>
<a name="ln3277">static void f_getcwd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3278">{</a>
<a name="ln3279">  // Possible scope of working directory to return.</a>
<a name="ln3280">  CdScope scope = kCdScopeInvalid;</a>
<a name="ln3281"> </a>
<a name="ln3282">  // Numbers of the scope objects (window, tab) we want the working directory</a>
<a name="ln3283">  // of. A `-1` means to skip this scope, a `0` means the current object.</a>
<a name="ln3284">  int scope_number[] = {</a>
<a name="ln3285">    [kCdScopeWindow] = 0,  // Number of window to look at.</a>
<a name="ln3286">    [kCdScopeTab   ] = 0,  // Number of tab to look at.</a>
<a name="ln3287">  };</a>
<a name="ln3288"> </a>
<a name="ln3289">  char_u *cwd  = NULL;  // Current working directory to print</a>
<a name="ln3290">  char_u *from = NULL;  // The original string to copy</a>
<a name="ln3291"> </a>
<a name="ln3292">  tabpage_T *tp  = curtab;  // The tabpage to look at.</a>
<a name="ln3293">  win_T     *win = curwin;  // The window to look at.</a>
<a name="ln3294"> </a>
<a name="ln3295">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3296">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3297"> </a>
<a name="ln3298">  // Pre-conditions and scope extraction together</a>
<a name="ln3299">  for (int i = MIN_CD_SCOPE; i &lt; MAX_CD_SCOPE; i++) {</a>
<a name="ln3300">    // If there is no argument there are no more scopes after it, break out.</a>
<a name="ln3301">    if (argvars[i].v_type == VAR_UNKNOWN) {</a>
<a name="ln3302">      break;</a>
<a name="ln3303">    }</a>
<a name="ln3304">    if (argvars[i].v_type != VAR_NUMBER) {</a>
<a name="ln3305">      EMSG(_(e_invarg));</a>
<a name="ln3306">      return;</a>
<a name="ln3307">    }</a>
<a name="ln3308">    scope_number[i] = argvars[i].vval.v_number;</a>
<a name="ln3309">    // It is an error for the scope number to be less than `-1`.</a>
<a name="ln3310">    if (scope_number[i] &lt; -1) {</a>
<a name="ln3311">      EMSG(_(e_invarg));</a>
<a name="ln3312">      return;</a>
<a name="ln3313">    }</a>
<a name="ln3314">    // Use the narrowest scope the user requested</a>
<a name="ln3315">    if (scope_number[i] &gt;= 0 &amp;&amp; scope == kCdScopeInvalid) {</a>
<a name="ln3316">      // The scope is the current iteration step.</a>
<a name="ln3317">      scope = i;</a>
<a name="ln3318">    } else if (scope_number[i] &lt; 0) {</a>
<a name="ln3319">      scope = i + 1;</a>
<a name="ln3320">    }</a>
<a name="ln3321">  }</a>
<a name="ln3322"> </a>
<a name="ln3323">  // If the user didn't specify anything, default to window scope</a>
<a name="ln3324">  if (scope == kCdScopeInvalid) {</a>
<a name="ln3325">    scope = MIN_CD_SCOPE;</a>
<a name="ln3326">  }</a>
<a name="ln3327"> </a>
<a name="ln3328">  // Find the tabpage by number</a>
<a name="ln3329">  if (scope_number[kCdScopeTab] &gt; 0) {</a>
<a name="ln3330">    tp = find_tabpage(scope_number[kCdScopeTab]);</a>
<a name="ln3331">    if (!tp) {</a>
<a name="ln3332">      EMSG(_(&quot;E5000: Cannot find tab number.&quot;));</a>
<a name="ln3333">      return;</a>
<a name="ln3334">    }</a>
<a name="ln3335">  }</a>
<a name="ln3336"> </a>
<a name="ln3337">  // Find the window in `tp` by number, `NULL` if none.</a>
<a name="ln3338">  if (scope_number[kCdScopeWindow] &gt;= 0) {</a>
<a name="ln3339">    if (scope_number[kCdScopeTab] &lt; 0) {</a>
<a name="ln3340">      EMSG(_(&quot;E5001: Higher scope cannot be -1 if lower scope is &gt;= 0.&quot;));</a>
<a name="ln3341">      return;</a>
<a name="ln3342">    }</a>
<a name="ln3343"> </a>
<a name="ln3344">    if (scope_number[kCdScopeWindow] &gt; 0) {</a>
<a name="ln3345">      win = find_win_by_nr(&amp;argvars[0], tp);</a>
<a name="ln3346">      if (!win) {</a>
<a name="ln3347">        EMSG(_(&quot;E5002: Cannot find window number.&quot;));</a>
<a name="ln3348">        return;</a>
<a name="ln3349">      }</a>
<a name="ln3350">    }</a>
<a name="ln3351">  }</a>
<a name="ln3352"> </a>
<a name="ln3353">  cwd = xmalloc(MAXPATHL);</a>
<a name="ln3354"> </a>
<a name="ln3355">  switch (scope) {</a>
<a name="ln3356">    case kCdScopeWindow:</a>
<a name="ln3357">      assert(win);</a>
<a name="ln3358">      from = win-&gt;w_localdir;</a>
<a name="ln3359">      if (from) {</a>
<a name="ln3360">        break;</a>
<a name="ln3361">      }</a>
<a name="ln3362">      FALLTHROUGH;</a>
<a name="ln3363">    case kCdScopeTab:</a>
<a name="ln3364">      assert(tp);</a>
<a name="ln3365">      from = tp-&gt;tp_localdir;</a>
<a name="ln3366">      if (from) {</a>
<a name="ln3367">        break;</a>
<a name="ln3368">      }</a>
<a name="ln3369">      FALLTHROUGH;</a>
<a name="ln3370">    case kCdScopeGlobal:</a>
<a name="ln3371">      if (globaldir) {        // `globaldir` is not always set.</a>
<a name="ln3372">        from = globaldir;</a>
<a name="ln3373">      } else if (os_dirname(cwd, MAXPATHL) == FAIL) {  // Get the OS CWD.</a>
<a name="ln3374">        from = (char_u *)&quot;&quot;;  // Return empty string on failure.</a>
<a name="ln3375">      }</a>
<a name="ln3376">      break;</a>
<a name="ln3377">    case kCdScopeInvalid:     // We should never get here</a>
<a name="ln3378">      abort();</a>
<a name="ln3379">  }</a>
<a name="ln3380"> </a>
<a name="ln3381">  if (from) {</a>
<a name="ln3382">    xstrlcpy((char *)cwd, (char *)from, MAXPATHL);</a>
<a name="ln3383">  }</a>
<a name="ln3384"> </a>
<a name="ln3385">  rettv-&gt;vval.v_string = vim_strsave(cwd);</a>
<a name="ln3386">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3387">  slash_adjust(rettv-&gt;vval.v_string);</a>
<a name="ln3388">#endif</a>
<a name="ln3389"> </a>
<a name="ln3390">  xfree(cwd);</a>
<a name="ln3391">}</a>
<a name="ln3392"> </a>
<a name="ln3393">/*</a>
<a name="ln3394"> * &quot;getfontname()&quot; function</a>
<a name="ln3395"> */</a>
<a name="ln3396">static void f_getfontname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3397">{</a>
<a name="ln3398">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3399">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3400">}</a>
<a name="ln3401"> </a>
<a name="ln3402">/*</a>
<a name="ln3403"> * &quot;getfperm({fname})&quot; function</a>
<a name="ln3404"> */</a>
<a name="ln3405">static void f_getfperm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3406">{</a>
<a name="ln3407">  char *perm = NULL;</a>
<a name="ln3408">  char_u flags[] = &quot;rwx&quot;;</a>
<a name="ln3409"> </a>
<a name="ln3410">  const char *filename = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3411">  int32_t file_perm = os_getperm(filename);</a>
<a name="ln3412">  if (file_perm &gt;= 0) {</a>
<a name="ln3413">    perm = xstrdup(&quot;---------&quot;);</a>
<a name="ln3414">    for (int i = 0; i &lt; 9; i++) {</a>
<a name="ln3415">      if (file_perm &amp; (1 &lt;&lt; (8 - i))) {</a>
<a name="ln3416">        perm[i] = flags[i % 3];</a>
<a name="ln3417">      }</a>
<a name="ln3418">    }</a>
<a name="ln3419">  }</a>
<a name="ln3420">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3421">  rettv-&gt;vval.v_string = (char_u *)perm;</a>
<a name="ln3422">}</a>
<a name="ln3423"> </a>
<a name="ln3424">/*</a>
<a name="ln3425"> * &quot;getfsize({fname})&quot; function</a>
<a name="ln3426"> */</a>
<a name="ln3427">static void f_getfsize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3428">{</a>
<a name="ln3429">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3430"> </a>
<a name="ln3431">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3432"> </a>
<a name="ln3433">  FileInfo file_info;</a>
<a name="ln3434">  if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln3435">    uint64_t filesize = os_fileinfo_size(&amp;file_info);</a>
<a name="ln3436">    if (os_isdir((const char_u *)fname)) {</a>
<a name="ln3437">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln3438">    } else {</a>
<a name="ln3439">      rettv-&gt;vval.v_number = (varnumber_T)filesize;</a>
<a name="ln3440"> </a>
<a name="ln3441">      // non-perfect check for overflow</a>
<a name="ln3442">      if ((uint64_t)rettv-&gt;vval.v_number != filesize) {</a>
<a name="ln3443">        rettv-&gt;vval.v_number = -2;</a>
<a name="ln3444">      }</a>
<a name="ln3445">    }</a>
<a name="ln3446">  } else {</a>
<a name="ln3447">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln3448">  }</a>
<a name="ln3449">}</a>
<a name="ln3450"> </a>
<a name="ln3451">/*</a>
<a name="ln3452"> * &quot;getftime({fname})&quot; function</a>
<a name="ln3453"> */</a>
<a name="ln3454">static void f_getftime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3455">{</a>
<a name="ln3456">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3457"> </a>
<a name="ln3458">  FileInfo file_info;</a>
<a name="ln3459">  if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln3460">    rettv-&gt;vval.v_number = (varnumber_T)file_info.stat.st_mtim.tv_sec;</a>
<a name="ln3461">  } else {</a>
<a name="ln3462">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln3463">  }</a>
<a name="ln3464">}</a>
<a name="ln3465"> </a>
<a name="ln3466">/*</a>
<a name="ln3467"> * &quot;getftype({fname})&quot; function</a>
<a name="ln3468"> */</a>
<a name="ln3469">static void f_getftype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3470">{</a>
<a name="ln3471">  char_u      *type = NULL;</a>
<a name="ln3472">  char        *t;</a>
<a name="ln3473"> </a>
<a name="ln3474">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln3475"> </a>
<a name="ln3476">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3477">  FileInfo file_info;</a>
<a name="ln3478">  if (os_fileinfo_link(fname, &amp;file_info)) {</a>
<a name="ln3479">    uint64_t mode = file_info.stat.st_mode;</a>
<a name="ln3480">    if (S_ISREG(mode)) {</a>
<a name="ln3481">      t = &quot;file&quot;;</a>
<a name="ln3482">    } else if (S_ISDIR(mode)) {</a>
<a name="ln3483">      t = &quot;dir&quot;;</a>
<a name="ln3484">    } else if (S_ISLNK(mode)) {</a>
<a name="ln3485">      t = &quot;link&quot;;</a>
<a name="ln3486">    } else if (S_ISBLK(mode)) {</a>
<a name="ln3487">      t = &quot;bdev&quot;;</a>
<a name="ln3488">    } else if (S_ISCHR(mode)) {</a>
<a name="ln3489">      t = &quot;cdev&quot;;</a>
<a name="ln3490">    } else if (S_ISFIFO(mode)) {</a>
<a name="ln3491">      t = &quot;fifo&quot;;</a>
<a name="ln3492">    } else if (S_ISSOCK(mode)) {</a>
<a name="ln3493">      t = &quot;socket&quot;;</a>
<a name="ln3494">    } else {</a>
<a name="ln3495">      t = &quot;other&quot;;</a>
<a name="ln3496">    }</a>
<a name="ln3497">    type = vim_strsave((char_u *)t);</a>
<a name="ln3498">  }</a>
<a name="ln3499">  rettv-&gt;vval.v_string = type;</a>
<a name="ln3500">}</a>
<a name="ln3501"> </a>
<a name="ln3502">// &quot;getjumplist()&quot; function</a>
<a name="ln3503">static void f_getjumplist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3504">{</a>
<a name="ln3505">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3506">  win_T *const wp = find_tabwin(&amp;argvars[0], &amp;argvars[1]);</a>
<a name="ln3507">  if (wp == NULL) {</a>
<a name="ln3508">    return;</a>
<a name="ln3509">  }</a>
<a name="ln3510"> </a>
<a name="ln3511">  cleanup_jumplist(wp, true);</a>
<a name="ln3512"> </a>
<a name="ln3513">  list_T *const l = tv_list_alloc(wp-&gt;w_jumplistlen);</a>
<a name="ln3514">  tv_list_append_list(rettv-&gt;vval.v_list, l);</a>
<a name="ln3515">  tv_list_append_number(rettv-&gt;vval.v_list, wp-&gt;w_jumplistidx);</a>
<a name="ln3516"> </a>
<a name="ln3517">  for (int i = 0; i &lt; wp-&gt;w_jumplistlen; i++) {</a>
<a name="ln3518">    if (wp-&gt;w_jumplist[i].fmark.mark.lnum == 0) {</a>
<a name="ln3519">      continue;</a>
<a name="ln3520">    }</a>
<a name="ln3521">    dict_T *const d = tv_dict_alloc();</a>
<a name="ln3522">    tv_list_append_dict(l, d);</a>
<a name="ln3523">    tv_dict_add_nr(d, S_LEN(&quot;lnum&quot;), wp-&gt;w_jumplist[i].fmark.mark.lnum);</a>
<a name="ln3524">    tv_dict_add_nr(d, S_LEN(&quot;col&quot;), wp-&gt;w_jumplist[i].fmark.mark.col);</a>
<a name="ln3525">    tv_dict_add_nr(d, S_LEN(&quot;coladd&quot;), wp-&gt;w_jumplist[i].fmark.mark.coladd);</a>
<a name="ln3526">    tv_dict_add_nr(d, S_LEN(&quot;bufnr&quot;), wp-&gt;w_jumplist[i].fmark.fnum);</a>
<a name="ln3527">    if (wp-&gt;w_jumplist[i].fname != NULL) {</a>
<a name="ln3528">      tv_dict_add_str(d, S_LEN(&quot;filename&quot;), (char *)wp-&gt;w_jumplist[i].fname);</a>
<a name="ln3529">    }</a>
<a name="ln3530">  }</a>
<a name="ln3531">}</a>
<a name="ln3532"> </a>
<a name="ln3533">/*</a>
<a name="ln3534"> * &quot;getline(lnum, [end])&quot; function</a>
<a name="ln3535"> */</a>
<a name="ln3536">static void f_getline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3537">{</a>
<a name="ln3538">  linenr_T end;</a>
<a name="ln3539">  bool retlist;</a>
<a name="ln3540"> </a>
<a name="ln3541">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln3542">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln3543">    end = lnum;</a>
<a name="ln3544">    retlist = false;</a>
<a name="ln3545">  } else {</a>
<a name="ln3546">    end = tv_get_lnum(&amp;argvars[1]);</a>
<a name="ln3547">    retlist = true;</a>
<a name="ln3548">  }</a>
<a name="ln3549"> </a>
<a name="ln3550">  get_buffer_lines(curbuf, lnum, end, retlist, rettv);</a>
<a name="ln3551">}</a>
<a name="ln3552"> </a>
<a name="ln3553">/// &quot;getloclist()&quot; function</a>
<a name="ln3554">static void f_getloclist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3555">{</a>
<a name="ln3556">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3557">  get_qf_loc_list(false, wp, &amp;argvars[1], rettv);</a>
<a name="ln3558">}</a>
<a name="ln3559"> </a>
<a name="ln3560"> </a>
<a name="ln3561">/// &quot;getmarklist()&quot; function</a>
<a name="ln3562">static void f_getmarklist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3563">{</a>
<a name="ln3564">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3565"> </a>
<a name="ln3566">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln3567">    get_global_marks(rettv-&gt;vval.v_list);</a>
<a name="ln3568">    return;</a>
<a name="ln3569">  }</a>
<a name="ln3570"> </a>
<a name="ln3571">  buf_T *buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln3572">  if (buf == NULL) {</a>
<a name="ln3573">    return;</a>
<a name="ln3574">  }</a>
<a name="ln3575"> </a>
<a name="ln3576">  get_buf_local_marks(buf, rettv-&gt;vval.v_list);</a>
<a name="ln3577">}</a>
<a name="ln3578"> </a>
<a name="ln3579">/*</a>
<a name="ln3580"> * &quot;getmatches()&quot; function</a>
<a name="ln3581"> */</a>
<a name="ln3582">static void f_getmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3583">{</a>
<a name="ln3584">  matchitem_T *cur;</a>
<a name="ln3585">  int i;</a>
<a name="ln3586">  win_T *win = get_optional_window(argvars, 0);</a>
<a name="ln3587"> </a>
<a name="ln3588">  if (win == NULL) {</a>
<a name="ln3589">    return;</a>
<a name="ln3590">  }</a>
<a name="ln3591"> </a>
<a name="ln3592">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3593">  cur = win-&gt;w_match_head;</a>
<a name="ln3594">  while (cur != NULL) {</a>
<a name="ln3595">    dict_T *dict = tv_dict_alloc();</a>
<a name="ln3596">    if (cur-&gt;match.regprog == NULL) {</a>
<a name="ln3597">      // match added with matchaddpos()</a>
<a name="ln3598">      for (i = 0; i &lt; MAXPOSMATCH; i++) {</a>
<a name="ln3599">        llpos_T   *llpos;</a>
<a name="ln3600">        char buf[30];  // use 30 to avoid compiler warning</a>
<a name="ln3601"> </a>
<a name="ln3602">        llpos = &amp;cur-&gt;pos.pos[i];</a>
<a name="ln3603">        if (llpos-&gt;lnum == 0) {</a>
<a name="ln3604">          break;</a>
<a name="ln3605">        }</a>
<a name="ln3606">        list_T *const l = tv_list_alloc(1 + (llpos-&gt;col &gt; 0 ? 2 : 0));</a>
<a name="ln3607">        tv_list_append_number(l, (varnumber_T)llpos-&gt;lnum);</a>
<a name="ln3608">        if (llpos-&gt;col &gt; 0) {</a>
<a name="ln3609">          tv_list_append_number(l, (varnumber_T)llpos-&gt;col);</a>
<a name="ln3610">          tv_list_append_number(l, (varnumber_T)llpos-&gt;len);</a>
<a name="ln3611">        }</a>
<a name="ln3612">        int len = snprintf(buf, sizeof(buf), &quot;pos%d&quot;, i + 1);</a>
<a name="ln3613">        assert((size_t)len &lt; sizeof(buf));</a>
<a name="ln3614">        tv_dict_add_list(dict, buf, (size_t)len, l);</a>
<a name="ln3615">      }</a>
<a name="ln3616">    } else {</a>
<a name="ln3617">      tv_dict_add_str(dict, S_LEN(&quot;pattern&quot;), (const char *)cur-&gt;pattern);</a>
<a name="ln3618">    }</a>
<a name="ln3619">    tv_dict_add_str(dict, S_LEN(&quot;group&quot;),</a>
<a name="ln3620">                    (const char *)syn_id2name(cur-&gt;hlg_id));</a>
<a name="ln3621">    tv_dict_add_nr(dict, S_LEN(&quot;priority&quot;), (varnumber_T)cur-&gt;priority);</a>
<a name="ln3622">    tv_dict_add_nr(dict, S_LEN(&quot;id&quot;), (varnumber_T)cur-&gt;id);</a>
<a name="ln3623"> </a>
<a name="ln3624">    if (cur-&gt;conceal_char) {</a>
<a name="ln3625">      char buf[MB_MAXBYTES + 1];</a>
<a name="ln3626"> </a>
<a name="ln3627">      buf[utf_char2bytes((int)cur-&gt;conceal_char, (char_u *)buf)] = NUL;</a>
<a name="ln3628">      tv_dict_add_str(dict, S_LEN(&quot;conceal&quot;), buf);</a>
<a name="ln3629">    }</a>
<a name="ln3630"> </a>
<a name="ln3631">    tv_list_append_dict(rettv-&gt;vval.v_list, dict);</a>
<a name="ln3632">    cur = cur-&gt;next;</a>
<a name="ln3633">  }</a>
<a name="ln3634">}</a>
<a name="ln3635"> </a>
<a name="ln3636">/*</a>
<a name="ln3637"> * &quot;getpid()&quot; function</a>
<a name="ln3638"> */</a>
<a name="ln3639">static void f_getpid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3640">{</a>
<a name="ln3641">  rettv-&gt;vval.v_number = os_get_pid();</a>
<a name="ln3642">}</a>
<a name="ln3643"> </a>
<a name="ln3644">static void getpos_both(typval_T *argvars, typval_T *rettv, bool getcurpos)</a>
<a name="ln3645">{</a>
<a name="ln3646">  pos_T *fp;</a>
<a name="ln3647">  int fnum = -1;</a>
<a name="ln3648"> </a>
<a name="ln3649">  if (getcurpos) {</a>
<a name="ln3650">    fp = &amp;curwin-&gt;w_cursor;</a>
<a name="ln3651">  } else {</a>
<a name="ln3652">    fp = var2fpos(&amp;argvars[0], true, &amp;fnum);</a>
<a name="ln3653">  }</a>
<a name="ln3654"> </a>
<a name="ln3655">  list_T *const l = tv_list_alloc_ret(rettv, 4 + (!!getcurpos));</a>
<a name="ln3656">  tv_list_append_number(l, (fnum != -1) ? (varnumber_T)fnum : (varnumber_T)0);</a>
<a name="ln3657">  tv_list_append_number(l, ((fp != NULL)</a>
<a name="ln3658">                            ? (varnumber_T)fp-&gt;lnum</a>
<a name="ln3659">                            : (varnumber_T)0));</a>
<a name="ln3660">  tv_list_append_number(</a>
<a name="ln3661">      l, ((fp != NULL)</a>
<a name="ln3662">          ? (varnumber_T)(fp-&gt;col == MAXCOL ? MAXCOL : fp-&gt;col + 1)</a>
<a name="ln3663">          : (varnumber_T)0));</a>
<a name="ln3664">  tv_list_append_number(</a>
<a name="ln3665">      l, (fp != NULL) ? (varnumber_T)fp-&gt;coladd : (varnumber_T)0);</a>
<a name="ln3666">  if (getcurpos) {</a>
<a name="ln3667">    const int save_set_curswant = curwin-&gt;w_set_curswant;</a>
<a name="ln3668">    const colnr_T save_curswant = curwin-&gt;w_curswant;</a>
<a name="ln3669">    const colnr_T save_virtcol = curwin-&gt;w_virtcol;</a>
<a name="ln3670"> </a>
<a name="ln3671">    update_curswant();</a>
<a name="ln3672">    tv_list_append_number(l, (curwin-&gt;w_curswant == MAXCOL</a>
<a name="ln3673">                              ? (varnumber_T)MAXCOL</a>
<a name="ln3674">                              : (varnumber_T)curwin-&gt;w_curswant + 1));</a>
<a name="ln3675"> </a>
<a name="ln3676">    // Do not change &quot;curswant&quot;, as it is unexpected that a get</a>
<a name="ln3677">    // function has a side effect.</a>
<a name="ln3678">    if (save_set_curswant) {</a>
<a name="ln3679">      curwin-&gt;w_set_curswant = save_set_curswant;</a>
<a name="ln3680">      curwin-&gt;w_curswant = save_curswant;</a>
<a name="ln3681">      curwin-&gt;w_virtcol = save_virtcol;</a>
<a name="ln3682">      curwin-&gt;w_valid &amp;= ~VALID_VIRTCOL;</a>
<a name="ln3683">    }</a>
<a name="ln3684">  }</a>
<a name="ln3685">}</a>
<a name="ln3686"> </a>
<a name="ln3687">/*</a>
<a name="ln3688"> * &quot;getcurpos(string)&quot; function</a>
<a name="ln3689"> */</a>
<a name="ln3690">static void f_getcurpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3691">{</a>
<a name="ln3692">  getpos_both(argvars, rettv, true);</a>
<a name="ln3693">}</a>
<a name="ln3694"> </a>
<a name="ln3695">/*</a>
<a name="ln3696"> * &quot;getpos(string)&quot; function</a>
<a name="ln3697"> */</a>
<a name="ln3698">static void f_getpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3699">{</a>
<a name="ln3700">  getpos_both(argvars, rettv, false);</a>
<a name="ln3701">}</a>
<a name="ln3702"> </a>
<a name="ln3703">/// &quot;getqflist()&quot; functions</a>
<a name="ln3704">static void f_getqflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3705">{</a>
<a name="ln3706">  get_qf_loc_list(true, NULL, &amp;argvars[0], rettv);</a>
<a name="ln3707">}</a>
<a name="ln3708"> </a>
<a name="ln3709">/// &quot;getreg()&quot; function</a>
<a name="ln3710">static void f_getreg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3711">{</a>
<a name="ln3712">  const char *strregname;</a>
<a name="ln3713">  int arg2 = false;</a>
<a name="ln3714">  bool return_list = false;</a>
<a name="ln3715">  bool error = false;</a>
<a name="ln3716"> </a>
<a name="ln3717">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3718">    strregname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln3719">    error = strregname == NULL;</a>
<a name="ln3720">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln3721">      arg2 = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln3722">      if (!error &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3723">        return_list = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln3724">      }</a>
<a name="ln3725">    }</a>
<a name="ln3726">  } else {</a>
<a name="ln3727">    strregname = _(get_vim_var_str(VV_REG));</a>
<a name="ln3728">  }</a>
<a name="ln3729"> </a>
<a name="ln3730">  if (error) {</a>
<a name="ln3731">    return;</a>
<a name="ln3732">  }</a>
<a name="ln3733"> </a>
<a name="ln3734">  int regname = (uint8_t)(strregname == NULL ? '&quot;' : *strregname);</a>
<a name="ln3735">  if (regname == 0) {</a>
<a name="ln3736">    regname = '&quot;';</a>
<a name="ln3737">  }</a>
<a name="ln3738"> </a>
<a name="ln3739">  if (return_list) {</a>
<a name="ln3740">    rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln3741">    rettv-&gt;vval.v_list =</a>
<a name="ln3742">      get_reg_contents(regname, (arg2 ? kGRegExprSrc : 0) | kGRegList);</a>
<a name="ln3743">    if (rettv-&gt;vval.v_list == NULL) {</a>
<a name="ln3744">      rettv-&gt;vval.v_list = tv_list_alloc(0);</a>
<a name="ln3745">    }</a>
<a name="ln3746">    tv_list_ref(rettv-&gt;vval.v_list);</a>
<a name="ln3747">  } else {</a>
<a name="ln3748">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3749">    rettv-&gt;vval.v_string = get_reg_contents(regname, arg2 ? kGRegExprSrc : 0);</a>
<a name="ln3750">  }</a>
<a name="ln3751">}</a>
<a name="ln3752"> </a>
<a name="ln3753">/*</a>
<a name="ln3754"> * &quot;getregtype()&quot; function</a>
<a name="ln3755"> */</a>
<a name="ln3756">static void f_getregtype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3757">{</a>
<a name="ln3758">  const char *strregname;</a>
<a name="ln3759"> </a>
<a name="ln3760">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3761">    strregname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln3762">    if (strregname == NULL) {  // Type error; errmsg already given.</a>
<a name="ln3763">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3764">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3765">      return;</a>
<a name="ln3766">    }</a>
<a name="ln3767">  } else {</a>
<a name="ln3768">    // Default to v:register.</a>
<a name="ln3769">    strregname = _(get_vim_var_str(VV_REG));</a>
<a name="ln3770">  }</a>
<a name="ln3771"> </a>
<a name="ln3772">  int regname = (uint8_t)(strregname == NULL ? '&quot;' : *strregname);</a>
<a name="ln3773">  if (regname == 0) {</a>
<a name="ln3774">    regname = '&quot;';</a>
<a name="ln3775">  }</a>
<a name="ln3776"> </a>
<a name="ln3777">  colnr_T reglen = 0;</a>
<a name="ln3778">  char buf[NUMBUFLEN + 2];</a>
<a name="ln3779">  MotionType reg_type = get_reg_type(regname, &amp;reglen);</a>
<a name="ln3780">  format_reg_type(reg_type, reglen, buf, ARRAY_SIZE(buf));</a>
<a name="ln3781"> </a>
<a name="ln3782">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3783">  rettv-&gt;vval.v_string = (char_u *)xstrdup(buf);</a>
<a name="ln3784">}</a>
<a name="ln3785"> </a>
<a name="ln3786">/// &quot;gettabinfo()&quot; function</a>
<a name="ln3787">static void f_gettabinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3788">{</a>
<a name="ln3789">  tabpage_T *tparg = NULL;</a>
<a name="ln3790"> </a>
<a name="ln3791">  tv_list_alloc_ret(rettv, (argvars[0].v_type == VAR_UNKNOWN</a>
<a name="ln3792">                            ? 1</a>
<a name="ln3793">                            : kListLenMayKnow));</a>
<a name="ln3794"> </a>
<a name="ln3795">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3796">    // Information about one tab page</a>
<a name="ln3797">    tparg = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln3798">    if (tparg == NULL) {</a>
<a name="ln3799">      return;</a>
<a name="ln3800">    }</a>
<a name="ln3801">  }</a>
<a name="ln3802"> </a>
<a name="ln3803">  // Get information about a specific tab page or all tab pages</a>
<a name="ln3804">  int tpnr = 0;</a>
<a name="ln3805">  FOR_ALL_TABS(tp) {</a>
<a name="ln3806">    tpnr++;</a>
<a name="ln3807">    if (tparg != NULL &amp;&amp; tp != tparg) {</a>
<a name="ln3808">      continue;</a>
<a name="ln3809">    }</a>
<a name="ln3810">    dict_T *const d = get_tabpage_info(tp, tpnr);</a>
<a name="ln3811">    tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln3812">    if (tparg != NULL) {</a>
<a name="ln3813">      return;</a>
<a name="ln3814">    }</a>
<a name="ln3815">  }</a>
<a name="ln3816">}</a>
<a name="ln3817"> </a>
<a name="ln3818">/*</a>
<a name="ln3819"> * &quot;gettabvar()&quot; function</a>
<a name="ln3820"> */</a>
<a name="ln3821">static void f_gettabvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3822">{</a>
<a name="ln3823">  win_T *oldcurwin;</a>
<a name="ln3824">  tabpage_T *oldtabpage;</a>
<a name="ln3825">  bool done = false;</a>
<a name="ln3826"> </a>
<a name="ln3827">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3828">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3829"> </a>
<a name="ln3830">  const char *const varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln3831">  tabpage_T *const tp = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln3832">  if (tp != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln3833">    // Set tp to be our tabpage, temporarily.  Also set the window to the</a>
<a name="ln3834">    // first window in the tabpage, otherwise the window is not valid.</a>
<a name="ln3835">    win_T *const window = tp == curtab || tp-&gt;tp_firstwin == NULL</a>
<a name="ln3836">        ? firstwin</a>
<a name="ln3837">        : tp-&gt;tp_firstwin;</a>
<a name="ln3838">    if (switch_win(&amp;oldcurwin, &amp;oldtabpage, window, tp, true) == OK) {</a>
<a name="ln3839">      // look up the variable</a>
<a name="ln3840">      // Let gettabvar({nr}, &quot;&quot;) return the &quot;t:&quot; dictionary.</a>
<a name="ln3841">      const dictitem_T *const v = find_var_in_ht(&amp;tp-&gt;tp_vars-&gt;dv_hashtab, 't',</a>
<a name="ln3842">                                                 varname, strlen(varname),</a>
<a name="ln3843">                                                 false);</a>
<a name="ln3844">      if (v != NULL) {</a>
<a name="ln3845">        tv_copy(&amp;v-&gt;di_tv, rettv);</a>
<a name="ln3846">        done = true;</a>
<a name="ln3847">      }</a>
<a name="ln3848">    }</a>
<a name="ln3849"> </a>
<a name="ln3850">    // restore previous notion of curwin</a>
<a name="ln3851">    restore_win(oldcurwin, oldtabpage, true);</a>
<a name="ln3852">  }</a>
<a name="ln3853"> </a>
<a name="ln3854">  if (!done &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3855">    tv_copy(&amp;argvars[2], rettv);</a>
<a name="ln3856">  }</a>
<a name="ln3857">}</a>
<a name="ln3858"> </a>
<a name="ln3859">/*</a>
<a name="ln3860"> * &quot;gettabwinvar()&quot; function</a>
<a name="ln3861"> */</a>
<a name="ln3862">static void f_gettabwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3863">{</a>
<a name="ln3864">  getwinvar(argvars, rettv, 1);</a>
<a name="ln3865">}</a>
<a name="ln3866"> </a>
<a name="ln3867">// &quot;gettagstack()&quot; function</a>
<a name="ln3868">static void f_gettagstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3869">{</a>
<a name="ln3870">    win_T        *wp = curwin;                  // default is current window</a>
<a name="ln3871"> </a>
<a name="ln3872">    tv_dict_alloc_ret(rettv);</a>
<a name="ln3873"> </a>
<a name="ln3874">    if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3875">        wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3876">        if (wp == NULL) {</a>
<a name="ln3877">          return;</a>
<a name="ln3878">        }</a>
<a name="ln3879">    }</a>
<a name="ln3880"> </a>
<a name="ln3881">    get_tagstack(wp, rettv-&gt;vval.v_dict);</a>
<a name="ln3882">}</a>
<a name="ln3883"> </a>
<a name="ln3884">/// &quot;getwininfo()&quot; function</a>
<a name="ln3885">static void f_getwininfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3886">{</a>
<a name="ln3887">  win_T *wparg = NULL;</a>
<a name="ln3888"> </a>
<a name="ln3889">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3890"> </a>
<a name="ln3891">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln3892">    wparg = win_id2wp(argvars);</a>
<a name="ln3893">    if (wparg == NULL) {</a>
<a name="ln3894">      return;</a>
<a name="ln3895">    }</a>
<a name="ln3896">  }</a>
<a name="ln3897"> </a>
<a name="ln3898">  // Collect information about either all the windows across all the tab</a>
<a name="ln3899">  // pages or one particular window.</a>
<a name="ln3900">  int16_t tabnr = 0;</a>
<a name="ln3901">  FOR_ALL_TABS(tp) {</a>
<a name="ln3902">    tabnr++;</a>
<a name="ln3903">    int16_t winnr = 0;</a>
<a name="ln3904">    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln3905">      winnr++;</a>
<a name="ln3906">      if (wparg != NULL &amp;&amp; wp != wparg) {</a>
<a name="ln3907">        continue;</a>
<a name="ln3908">      }</a>
<a name="ln3909">      dict_T *const d = get_win_info(wp, tabnr, winnr);</a>
<a name="ln3910">      tv_list_append_dict(rettv-&gt;vval.v_list, d);</a>
<a name="ln3911">      if (wparg != NULL) {</a>
<a name="ln3912">        // found information about a specific window</a>
<a name="ln3913">        return;</a>
<a name="ln3914">      }</a>
<a name="ln3915">    }</a>
<a name="ln3916">  }</a>
<a name="ln3917">}</a>
<a name="ln3918"> </a>
<a name="ln3919">// Dummy timer callback. Used by f_wait().</a>
<a name="ln3920">static void dummy_timer_due_cb(TimeWatcher *tw, void *data)</a>
<a name="ln3921">{</a>
<a name="ln3922">}</a>
<a name="ln3923"> </a>
<a name="ln3924">// Dummy timer close callback. Used by f_wait().</a>
<a name="ln3925">static void dummy_timer_close_cb(TimeWatcher *tw, void *data)</a>
<a name="ln3926">{</a>
<a name="ln3927">  xfree(tw);</a>
<a name="ln3928">}</a>
<a name="ln3929"> </a>
<a name="ln3930">/// &quot;wait(timeout, condition[, interval])&quot; function</a>
<a name="ln3931">static void f_wait(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3932">{</a>
<a name="ln3933">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3934">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln3935"> </a>
<a name="ln3936">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln3937">    EMSG2(_(e_invargval), &quot;1&quot;);</a>
<a name="ln3938">    return;</a>
<a name="ln3939">  }</a>
<a name="ln3940">  if ((argvars[2].v_type != VAR_NUMBER &amp;&amp; argvars[2].v_type != VAR_UNKNOWN)</a>
<a name="ln3941">      || (argvars[2].v_type == VAR_NUMBER &amp;&amp; argvars[2].vval.v_number &lt;= 0)) {</a>
<a name="ln3942">    EMSG2(_(e_invargval), &quot;3&quot;);</a>
<a name="ln3943">    return;</a>
<a name="ln3944">  }</a>
<a name="ln3945"> </a>
<a name="ln3946">  int timeout = argvars[0].vval.v_number;</a>
<a name="ln3947">  typval_T expr = argvars[1];</a>
<a name="ln3948">  int interval = argvars[2].v_type == VAR_NUMBER</a>
<a name="ln3949">    ? argvars[2].vval.v_number</a>
<a name="ln3950">    : 200;  // Default.</a>
<a name="ln3951">  TimeWatcher *tw = xmalloc(sizeof(TimeWatcher));</a>
<a name="ln3952"> </a>
<a name="ln3953">  // Start dummy timer.</a>
<a name="ln3954">  time_watcher_init(&amp;main_loop, tw, NULL);</a>
<a name="ln3955">  tw-&gt;events = main_loop.events;</a>
<a name="ln3956">  tw-&gt;blockable = true;</a>
<a name="ln3957">  time_watcher_start(tw, dummy_timer_due_cb, interval, interval);</a>
<a name="ln3958"> </a>
<a name="ln3959">  typval_T argv = TV_INITIAL_VALUE;</a>
<a name="ln3960">  typval_T exprval = TV_INITIAL_VALUE;</a>
<a name="ln3961">  bool error = false;</a>
<a name="ln3962">  int save_called_emsg = called_emsg;</a>
<a name="ln3963">  called_emsg = false;</a>
<a name="ln3964"> </a>
<a name="ln3965">  LOOP_PROCESS_EVENTS_UNTIL(&amp;main_loop, main_loop.events, timeout,</a>
<a name="ln3966">                            eval_expr_typval(&amp;expr, &amp;argv, 0, &amp;exprval) != OK</a>
<a name="ln3967">                            || tv_get_number_chk(&amp;exprval, &amp;error)</a>
<a name="ln3968">                            || called_emsg || error || got_int);</a>
<a name="ln3969"> </a>
<a name="ln3970">  if (called_emsg || error) {</a>
<a name="ln3971">    rettv-&gt;vval.v_number = -3;</a>
<a name="ln3972">  } else if (got_int) {</a>
<a name="ln3973">    got_int = false;</a>
<a name="ln3974">    vgetc();</a>
<a name="ln3975">    rettv-&gt;vval.v_number = -2;</a>
<a name="ln3976">  } else if (tv_get_number_chk(&amp;exprval, &amp;error)) {</a>
<a name="ln3977">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln3978">  }</a>
<a name="ln3979"> </a>
<a name="ln3980">  called_emsg = save_called_emsg;</a>
<a name="ln3981"> </a>
<a name="ln3982">  // Stop dummy timer</a>
<a name="ln3983">  time_watcher_stop(tw);</a>
<a name="ln3984">  time_watcher_close(tw, dummy_timer_close_cb);</a>
<a name="ln3985">}</a>
<a name="ln3986"> </a>
<a name="ln3987">// &quot;win_screenpos()&quot; function</a>
<a name="ln3988">static void f_win_screenpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln3989">{</a>
<a name="ln3990">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln3991">  const win_T *const wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln3992">  tv_list_append_number(rettv-&gt;vval.v_list, wp == NULL ? 0 : wp-&gt;w_winrow + 1);</a>
<a name="ln3993">  tv_list_append_number(rettv-&gt;vval.v_list, wp == NULL ? 0 : wp-&gt;w_wincol + 1);</a>
<a name="ln3994">}</a>
<a name="ln3995"> </a>
<a name="ln3996">//</a>
<a name="ln3997">// Move the window wp into a new split of targetwin in a given direction</a>
<a name="ln3998">//</a>
<a name="ln3999">static void win_move_into_split(win_T *wp, win_T *targetwin,</a>
<a name="ln4000">                                int size, int flags)</a>
<a name="ln4001">{</a>
<a name="ln4002">  int     dir;</a>
<a name="ln4003">  int     height = wp-&gt;w_height;</a>
<a name="ln4004">  win_T   *oldwin = curwin;</a>
<a name="ln4005"> </a>
<a name="ln4006">  if (wp == targetwin) {</a>
<a name="ln4007">    return;</a>
<a name="ln4008">  }</a>
<a name="ln4009"> </a>
<a name="ln4010">  // Jump to the target window</a>
<a name="ln4011">  if (curwin != targetwin) {</a>
<a name="ln4012">    win_goto(targetwin);</a>
<a name="ln4013">  }</a>
<a name="ln4014"> </a>
<a name="ln4015">  // Remove the old window and frame from the tree of frames</a>
<a name="ln4016">  (void)winframe_remove(wp, &amp;dir, NULL);</a>
<a name="ln4017">  win_remove(wp, NULL);</a>
<a name="ln4018">  last_status(false);     // may need to remove last status line</a>
<a name="ln4019">  (void)win_comp_pos();   // recompute window positions</a>
<a name="ln4020"> </a>
<a name="ln4021">  // Split a window on the desired side and put the old window there</a>
<a name="ln4022">  (void)win_split_ins(size, flags, wp, dir);</a>
<a name="ln4023"> </a>
<a name="ln4024">  // If splitting horizontally, try to preserve height</a>
<a name="ln4025">  if (size == 0 &amp;&amp; !(flags &amp; WSP_VERT)) {</a>
<a name="ln4026">    win_setheight_win(height, wp);</a>
<a name="ln4027">    if (p_ea) {</a>
<a name="ln4028">      win_equal(wp, true, 'v');</a>
<a name="ln4029">    }</a>
<a name="ln4030">  }</a>
<a name="ln4031"> </a>
<a name="ln4032">  if (oldwin != curwin) {</a>
<a name="ln4033">    win_goto(oldwin);</a>
<a name="ln4034">  }</a>
<a name="ln4035">}</a>
<a name="ln4036"> </a>
<a name="ln4037">// &quot;win_splitmove()&quot; function</a>
<a name="ln4038">static void f_win_splitmove(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4039">{</a>
<a name="ln4040">  win_T   *wp;</a>
<a name="ln4041">  win_T   *targetwin;</a>
<a name="ln4042">  int     flags = 0, size = 0;</a>
<a name="ln4043"> </a>
<a name="ln4044">  wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln4045">  targetwin = find_win_by_nr_or_id(&amp;argvars[1]);</a>
<a name="ln4046"> </a>
<a name="ln4047">  if (wp == NULL || targetwin == NULL || wp == targetwin</a>
<a name="ln4048">      || !win_valid(wp) || !win_valid(targetwin)</a>
<a name="ln4049">      || win_valid_floating(wp) || win_valid_floating(targetwin)) {</a>
<a name="ln4050">    EMSG(_(e_invalwindow));</a>
<a name="ln4051">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln4052">    return;</a>
<a name="ln4053">  }</a>
<a name="ln4054"> </a>
<a name="ln4055">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4056">    dict_T      *d;</a>
<a name="ln4057">    dictitem_T  *di;</a>
<a name="ln4058"> </a>
<a name="ln4059">    if (argvars[2].v_type != VAR_DICT || argvars[2].vval.v_dict == NULL) {</a>
<a name="ln4060">      EMSG(_(e_invarg));</a>
<a name="ln4061">      return;</a>
<a name="ln4062">    }</a>
<a name="ln4063"> </a>
<a name="ln4064">    d = argvars[2].vval.v_dict;</a>
<a name="ln4065">    if (tv_dict_get_number(d, &quot;vertical&quot;)) {</a>
<a name="ln4066">      flags |= WSP_VERT;</a>
<a name="ln4067">    }</a>
<a name="ln4068">    if ((di = tv_dict_find(d, &quot;rightbelow&quot;, -1)) != NULL) {</a>
<a name="ln4069">      flags |= tv_get_number(&amp;di-&gt;di_tv) ? WSP_BELOW : WSP_ABOVE;</a>
<a name="ln4070">    }</a>
<a name="ln4071">    size = tv_dict_get_number(d, &quot;size&quot;);</a>
<a name="ln4072">  }</a>
<a name="ln4073"> </a>
<a name="ln4074">  win_move_into_split(wp, targetwin, size, flags);</a>
<a name="ln4075">}</a>
<a name="ln4076"> </a>
<a name="ln4077">// &quot;getwinpos({timeout})&quot; function</a>
<a name="ln4078">static void f_getwinpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4079">{</a>
<a name="ln4080">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln4081">  tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln4082">  tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln4083">}</a>
<a name="ln4084"> </a>
<a name="ln4085">/*</a>
<a name="ln4086"> * &quot;getwinposx()&quot; function</a>
<a name="ln4087"> */</a>
<a name="ln4088">static void f_getwinposx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4089">{</a>
<a name="ln4090">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4091">}</a>
<a name="ln4092"> </a>
<a name="ln4093">/*</a>
<a name="ln4094"> * &quot;getwinposy()&quot; function</a>
<a name="ln4095"> */</a>
<a name="ln4096">static void f_getwinposy(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4097">{</a>
<a name="ln4098">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4099">}</a>
<a name="ln4100"> </a>
<a name="ln4101">/// &quot;getwinvar()&quot; function</a>
<a name="ln4102">static void f_getwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4103">{</a>
<a name="ln4104">  getwinvar(argvars, rettv, 0);</a>
<a name="ln4105">}</a>
<a name="ln4106"> </a>
<a name="ln4107">/*</a>
<a name="ln4108"> * &quot;glob()&quot; function</a>
<a name="ln4109"> */</a>
<a name="ln4110">static void f_glob(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4111">{</a>
<a name="ln4112">  int options = WILD_SILENT|WILD_USE_NL;</a>
<a name="ln4113">  expand_T xpc;</a>
<a name="ln4114">  bool error = false;</a>
<a name="ln4115"> </a>
<a name="ln4116">  /* When the optional second argument is non-zero, don't remove matches</a>
<a name="ln4117">  * for 'wildignore' and don't put matches for 'suffixes' at the end. */</a>
<a name="ln4118">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4119">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln4120">    if (tv_get_number_chk(&amp;argvars[1], &amp;error)) {</a>
<a name="ln4121">      options |= WILD_KEEP_ALL;</a>
<a name="ln4122">    }</a>
<a name="ln4123">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4124">      if (tv_get_number_chk(&amp;argvars[2], &amp;error)) {</a>
<a name="ln4125">        tv_list_set_ret(rettv, NULL);</a>
<a name="ln4126">      }</a>
<a name="ln4127">      if (argvars[3].v_type != VAR_UNKNOWN</a>
<a name="ln4128">          &amp;&amp; tv_get_number_chk(&amp;argvars[3], &amp;error)) {</a>
<a name="ln4129">        options |= WILD_ALLLINKS;</a>
<a name="ln4130">      }</a>
<a name="ln4131">    }</a>
<a name="ln4132">  }</a>
<a name="ln4133">  if (!error) {</a>
<a name="ln4134">    ExpandInit(&amp;xpc);</a>
<a name="ln4135">    xpc.xp_context = EXPAND_FILES;</a>
<a name="ln4136">    if (p_wic)</a>
<a name="ln4137">      options += WILD_ICASE;</a>
<a name="ln4138">    if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln4139">      rettv-&gt;vval.v_string = ExpandOne(</a>
<a name="ln4140">          &amp;xpc, (char_u *)tv_get_string(&amp;argvars[0]), NULL, options, WILD_ALL);</a>
<a name="ln4141">    } else {</a>
<a name="ln4142">      ExpandOne(&amp;xpc, (char_u *)tv_get_string(&amp;argvars[0]), NULL, options,</a>
<a name="ln4143">                WILD_ALL_KEEP);</a>
<a name="ln4144">      tv_list_alloc_ret(rettv, xpc.xp_numfiles);</a>
<a name="ln4145">      for (int i = 0; i &lt; xpc.xp_numfiles; i++) {</a>
<a name="ln4146">        tv_list_append_string(rettv-&gt;vval.v_list, (const char *)xpc.xp_files[i],</a>
<a name="ln4147">                              -1);</a>
<a name="ln4148">      }</a>
<a name="ln4149">      ExpandCleanup(&amp;xpc);</a>
<a name="ln4150">    }</a>
<a name="ln4151">  } else</a>
<a name="ln4152">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4153">}</a>
<a name="ln4154"> </a>
<a name="ln4155">/// &quot;globpath()&quot; function</a>
<a name="ln4156">static void f_globpath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4157">{</a>
<a name="ln4158">  int flags = WILD_IGNORE_COMPLETESLASH;  // Flags for globpath.</a>
<a name="ln4159">  bool error = false;</a>
<a name="ln4160"> </a>
<a name="ln4161">  // Return a string, or a list if the optional third argument is non-zero.</a>
<a name="ln4162">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4163"> </a>
<a name="ln4164">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4165">    // When the optional second argument is non-zero, don't remove matches</a>
<a name="ln4166">    // for 'wildignore' and don't put matches for 'suffixes' at the end.</a>
<a name="ln4167">    if (tv_get_number_chk(&amp;argvars[2], &amp;error)) {</a>
<a name="ln4168">      flags |= WILD_KEEP_ALL;</a>
<a name="ln4169">    }</a>
<a name="ln4170"> </a>
<a name="ln4171">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln4172">      if (tv_get_number_chk(&amp;argvars[3], &amp;error)) {</a>
<a name="ln4173">        tv_list_set_ret(rettv, NULL);</a>
<a name="ln4174">      }</a>
<a name="ln4175">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln4176">          &amp;&amp; tv_get_number_chk(&amp;argvars[4], &amp;error)) {</a>
<a name="ln4177">        flags |= WILD_ALLLINKS;</a>
<a name="ln4178">      }</a>
<a name="ln4179">    }</a>
<a name="ln4180">  }</a>
<a name="ln4181"> </a>
<a name="ln4182">  char buf1[NUMBUFLEN];</a>
<a name="ln4183">  const char *const file = tv_get_string_buf_chk(&amp;argvars[1], buf1);</a>
<a name="ln4184">  if (file != NULL &amp;&amp; !error) {</a>
<a name="ln4185">    garray_T ga;</a>
<a name="ln4186">    ga_init(&amp;ga, (int)sizeof(char_u *), 10);</a>
<a name="ln4187">    globpath((char_u *)tv_get_string(&amp;argvars[0]), (char_u *)file, &amp;ga, flags);</a>
<a name="ln4188"> </a>
<a name="ln4189">    if (rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln4190">      rettv-&gt;vval.v_string = ga_concat_strings_sep(&amp;ga, &quot;\n&quot;);</a>
<a name="ln4191">    } else {</a>
<a name="ln4192">      tv_list_alloc_ret(rettv, ga.ga_len);</a>
<a name="ln4193">      for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln4194">        tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln4195">                              ((const char **)(ga.ga_data))[i], -1);</a>
<a name="ln4196">      }</a>
<a name="ln4197">    }</a>
<a name="ln4198"> </a>
<a name="ln4199">    ga_clear_strings(&amp;ga);</a>
<a name="ln4200">  } else {</a>
<a name="ln4201">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4202">  }</a>
<a name="ln4203">}</a>
<a name="ln4204"> </a>
<a name="ln4205">// &quot;glob2regpat()&quot; function</a>
<a name="ln4206">static void f_glob2regpat(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4207">{</a>
<a name="ln4208">  const char *const pat = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4209"> </a>
<a name="ln4210">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4211">  rettv-&gt;vval.v_string = ((pat == NULL)</a>
<a name="ln4212">                          ? NULL</a>
<a name="ln4213">                          : file_pat_to_reg_pat((char_u *)pat, NULL, NULL,</a>
<a name="ln4214">                                                false));</a>
<a name="ln4215">}</a>
<a name="ln4216"> </a>
<a name="ln4217">/// &quot;has()&quot; function</a>
<a name="ln4218">static void f_has(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4219">{</a>
<a name="ln4220">  static const char *const has_list[] = {</a>
<a name="ln4221">#if defined(BSD) &amp;&amp; !defined(__APPLE__)</a>
<a name="ln4222">    &quot;bsd&quot;,</a>
<a name="ln4223">#endif</a>
<a name="ln4224">#ifdef UNIX</a>
<a name="ln4225">    &quot;unix&quot;,</a>
<a name="ln4226">#endif</a>
<a name="ln4227">#if defined(WIN32)</a>
<a name="ln4228">    &quot;win32&quot;,</a>
<a name="ln4229">#endif</a>
<a name="ln4230">#ifdef _WIN64</a>
<a name="ln4231">    &quot;win64&quot;,</a>
<a name="ln4232">#endif</a>
<a name="ln4233">#ifndef CASE_INSENSITIVE_FILENAME</a>
<a name="ln4234">    &quot;fname_case&quot;,</a>
<a name="ln4235">#endif</a>
<a name="ln4236">#ifdef HAVE_ACL</a>
<a name="ln4237">    &quot;acl&quot;,</a>
<a name="ln4238">#endif</a>
<a name="ln4239">    &quot;autochdir&quot;,</a>
<a name="ln4240">    &quot;arabic&quot;,</a>
<a name="ln4241">    &quot;autocmd&quot;,</a>
<a name="ln4242">    &quot;browsefilter&quot;,</a>
<a name="ln4243">    &quot;byte_offset&quot;,</a>
<a name="ln4244">    &quot;cindent&quot;,</a>
<a name="ln4245">    &quot;cmdline_compl&quot;,</a>
<a name="ln4246">    &quot;cmdline_hist&quot;,</a>
<a name="ln4247">    &quot;comments&quot;,</a>
<a name="ln4248">    &quot;conceal&quot;,</a>
<a name="ln4249">    &quot;cscope&quot;,</a>
<a name="ln4250">    &quot;cursorbind&quot;,</a>
<a name="ln4251">    &quot;cursorshape&quot;,</a>
<a name="ln4252">#ifdef DEBUG</a>
<a name="ln4253">    &quot;debug&quot;,</a>
<a name="ln4254">#endif</a>
<a name="ln4255">    &quot;dialog_con&quot;,</a>
<a name="ln4256">    &quot;diff&quot;,</a>
<a name="ln4257">    &quot;digraphs&quot;,</a>
<a name="ln4258">    &quot;eval&quot;,         // always present, of course!</a>
<a name="ln4259">    &quot;ex_extra&quot;,</a>
<a name="ln4260">    &quot;extra_search&quot;,</a>
<a name="ln4261">    &quot;file_in_path&quot;,</a>
<a name="ln4262">    &quot;filterpipe&quot;,</a>
<a name="ln4263">    &quot;find_in_path&quot;,</a>
<a name="ln4264">    &quot;float&quot;,</a>
<a name="ln4265">    &quot;folding&quot;,</a>
<a name="ln4266">#if defined(UNIX)</a>
<a name="ln4267">    &quot;fork&quot;,</a>
<a name="ln4268">#endif</a>
<a name="ln4269">    &quot;gettext&quot;,</a>
<a name="ln4270">#if defined(HAVE_ICONV)</a>
<a name="ln4271">    &quot;iconv&quot;,</a>
<a name="ln4272">#endif</a>
<a name="ln4273">    &quot;insert_expand&quot;,</a>
<a name="ln4274">    &quot;jumplist&quot;,</a>
<a name="ln4275">    &quot;keymap&quot;,</a>
<a name="ln4276">    &quot;lambda&quot;,</a>
<a name="ln4277">    &quot;langmap&quot;,</a>
<a name="ln4278">    &quot;libcall&quot;,</a>
<a name="ln4279">    &quot;linebreak&quot;,</a>
<a name="ln4280">    &quot;lispindent&quot;,</a>
<a name="ln4281">    &quot;listcmds&quot;,</a>
<a name="ln4282">    &quot;localmap&quot;,</a>
<a name="ln4283">#ifdef __APPLE__</a>
<a name="ln4284">    &quot;mac&quot;,</a>
<a name="ln4285">    &quot;macunix&quot;,</a>
<a name="ln4286">    &quot;osx&quot;,</a>
<a name="ln4287">    &quot;osxdarwin&quot;,</a>
<a name="ln4288">#endif</a>
<a name="ln4289">    &quot;menu&quot;,</a>
<a name="ln4290">    &quot;mksession&quot;,</a>
<a name="ln4291">    &quot;modify_fname&quot;,</a>
<a name="ln4292">    &quot;mouse&quot;,</a>
<a name="ln4293">    &quot;multi_byte&quot;,</a>
<a name="ln4294">    &quot;multi_lang&quot;,</a>
<a name="ln4295">    &quot;num64&quot;,</a>
<a name="ln4296">    &quot;packages&quot;,</a>
<a name="ln4297">    &quot;path_extra&quot;,</a>
<a name="ln4298">    &quot;persistent_undo&quot;,</a>
<a name="ln4299">    &quot;postscript&quot;,</a>
<a name="ln4300">    &quot;printer&quot;,</a>
<a name="ln4301">    &quot;profile&quot;,</a>
<a name="ln4302">    &quot;pythonx&quot;,</a>
<a name="ln4303">    &quot;reltime&quot;,</a>
<a name="ln4304">    &quot;quickfix&quot;,</a>
<a name="ln4305">    &quot;rightleft&quot;,</a>
<a name="ln4306">    &quot;scrollbind&quot;,</a>
<a name="ln4307">    &quot;showcmd&quot;,</a>
<a name="ln4308">    &quot;cmdline_info&quot;,</a>
<a name="ln4309">    &quot;shada&quot;,</a>
<a name="ln4310">    &quot;signs&quot;,</a>
<a name="ln4311">    &quot;smartindent&quot;,</a>
<a name="ln4312">    &quot;startuptime&quot;,</a>
<a name="ln4313">    &quot;statusline&quot;,</a>
<a name="ln4314">    &quot;spell&quot;,</a>
<a name="ln4315">    &quot;syntax&quot;,</a>
<a name="ln4316">#if !defined(UNIX)</a>
<a name="ln4317">    &quot;system&quot;,  // TODO(SplinterOfChaos): This IS defined for UNIX!</a>
<a name="ln4318">#endif</a>
<a name="ln4319">    &quot;tablineat&quot;,</a>
<a name="ln4320">    &quot;tag_binary&quot;,</a>
<a name="ln4321">    &quot;termguicolors&quot;,</a>
<a name="ln4322">    &quot;termresponse&quot;,</a>
<a name="ln4323">    &quot;textobjects&quot;,</a>
<a name="ln4324">    &quot;timers&quot;,</a>
<a name="ln4325">    &quot;title&quot;,</a>
<a name="ln4326">    &quot;user-commands&quot;,        // was accidentally included in 5.4</a>
<a name="ln4327">    &quot;user_commands&quot;,</a>
<a name="ln4328">    &quot;vartabs&quot;,</a>
<a name="ln4329">    &quot;vertsplit&quot;,</a>
<a name="ln4330">    &quot;virtualedit&quot;,</a>
<a name="ln4331">    &quot;visual&quot;,</a>
<a name="ln4332">    &quot;visualextra&quot;,</a>
<a name="ln4333">    &quot;vreplace&quot;,</a>
<a name="ln4334">    &quot;wildignore&quot;,</a>
<a name="ln4335">    &quot;wildmenu&quot;,</a>
<a name="ln4336">    &quot;windows&quot;,</a>
<a name="ln4337">    &quot;winaltkeys&quot;,</a>
<a name="ln4338">    &quot;writebackup&quot;,</a>
<a name="ln4339">#if defined(HAVE_WSL)</a>
<a name="ln4340">    &quot;wsl&quot;,</a>
<a name="ln4341">#endif</a>
<a name="ln4342">    &quot;nvim&quot;,</a>
<a name="ln4343">  };</a>
<a name="ln4344"> </a>
<a name="ln4345">  bool n = false;</a>
<a name="ln4346">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4347">  for (size_t i = 0; i &lt; ARRAY_SIZE(has_list); i++) {</a>
<a name="ln4348">    if (STRICMP(name, has_list[i]) == 0) {</a>
<a name="ln4349">      n = true;</a>
<a name="ln4350">      break;</a>
<a name="ln4351">    }</a>
<a name="ln4352">  }</a>
<a name="ln4353"> </a>
<a name="ln4354">  if (!n) {</a>
<a name="ln4355">    if (STRNICMP(name, &quot;patch&quot;, 5) == 0) {</a>
<a name="ln4356">      if (name[5] == '-'</a>
<a name="ln4357">          &amp;&amp; strlen(name) &gt;= 11</a>
<a name="ln4358">          &amp;&amp; ascii_isdigit(name[6])</a>
<a name="ln4359">          &amp;&amp; ascii_isdigit(name[8])</a>
<a name="ln4360">          &amp;&amp; ascii_isdigit(name[10])) {</a>
<a name="ln4361">        int major = atoi(name + 6);</a>
<a name="ln4362">        int minor = atoi(name + 8);</a>
<a name="ln4363"> </a>
<a name="ln4364">        // Expect &quot;patch-9.9.01234&quot;.</a>
<a name="ln4365">        n = (major &lt; VIM_VERSION_MAJOR</a>
<a name="ln4366">             || (major == VIM_VERSION_MAJOR</a>
<a name="ln4367">                 &amp;&amp; (minor &lt; VIM_VERSION_MINOR</a>
<a name="ln4368">                     || (minor == VIM_VERSION_MINOR</a>
<a name="ln4369">                         &amp;&amp; has_vim_patch(atoi(name + 10))))));</a>
<a name="ln4370">      } else {</a>
<a name="ln4371">        n = has_vim_patch(atoi(name + 5));</a>
<a name="ln4372">      }</a>
<a name="ln4373">    } else if (STRNICMP(name, &quot;nvim-&quot;, 5) == 0) {</a>
<a name="ln4374">      // Expect &quot;nvim-x.y.z&quot;</a>
<a name="ln4375">      n = has_nvim_version(name + 5);</a>
<a name="ln4376">    } else if (STRICMP(name, &quot;vim_starting&quot;) == 0) {</a>
<a name="ln4377">      n = (starting != 0);</a>
<a name="ln4378">    } else if (STRICMP(name, &quot;ttyin&quot;) == 0) {</a>
<a name="ln4379">      n = stdin_isatty;</a>
<a name="ln4380">    } else if (STRICMP(name, &quot;ttyout&quot;) == 0) {</a>
<a name="ln4381">      n = stdout_isatty;</a>
<a name="ln4382">    } else if (STRICMP(name, &quot;multi_byte_encoding&quot;) == 0) {</a>
<a name="ln4383">      n = true;</a>
<a name="ln4384">    } else if (STRICMP(name, &quot;syntax_items&quot;) == 0) {</a>
<a name="ln4385">      n = syntax_present(curwin);</a>
<a name="ln4386">    } else if (STRICMP(name, &quot;clipboard_working&quot;) == 0) {</a>
<a name="ln4387">      n = eval_has_provider(&quot;clipboard&quot;);</a>
<a name="ln4388">#ifdef UNIX</a>
<a name="ln4389">    } else if (STRICMP(name, &quot;unnamedplus&quot;) == 0) {</a>
<a name="ln4390">      n = eval_has_provider(&quot;clipboard&quot;);</a>
<a name="ln4391">#endif</a>
<a name="ln4392">    }</a>
<a name="ln4393">  }</a>
<a name="ln4394"> </a>
<a name="ln4395">  if (!n &amp;&amp; eval_has_provider(name)) {</a>
<a name="ln4396">    n = true;</a>
<a name="ln4397">  }</a>
<a name="ln4398"> </a>
<a name="ln4399">  rettv-&gt;vval.v_number = n;</a>
<a name="ln4400">}</a>
<a name="ln4401"> </a>
<a name="ln4402">/*</a>
<a name="ln4403"> * &quot;has_key()&quot; function</a>
<a name="ln4404"> */</a>
<a name="ln4405">static void f_has_key(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4406">{</a>
<a name="ln4407">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln4408">    EMSG(_(e_dictreq));</a>
<a name="ln4409">    return;</a>
<a name="ln4410">  }</a>
<a name="ln4411">  if (argvars[0].vval.v_dict == NULL)</a>
<a name="ln4412">    return;</a>
<a name="ln4413"> </a>
<a name="ln4414">  rettv-&gt;vval.v_number = tv_dict_find(argvars[0].vval.v_dict,</a>
<a name="ln4415">                                      tv_get_string(&amp;argvars[1]),</a>
<a name="ln4416">                                      -1) != NULL;</a>
<a name="ln4417">}</a>
<a name="ln4418"> </a>
<a name="ln4419">/// `haslocaldir([{win}[, {tab}]])` function</a>
<a name="ln4420">///</a>
<a name="ln4421">/// Returns `1` if the scope object has a local directory, `0` otherwise. If a</a>
<a name="ln4422">/// scope object is not specified the current one is implied. This function</a>
<a name="ln4423">/// share a lot of code with `f_getcwd`.</a>
<a name="ln4424">///</a>
<a name="ln4425">/// @pre  The arguments must be of type number.</a>
<a name="ln4426">/// @pre  There may not be more than two arguments.</a>
<a name="ln4427">/// @pre  An argument may not be -1 if preceding arguments are not all -1.</a>
<a name="ln4428">///</a>
<a name="ln4429">/// @post  The return value will be either the number `1` or `0`.</a>
<a name="ln4430">static void f_haslocaldir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4431">{</a>
<a name="ln4432">  // Possible scope of working directory to return.</a>
<a name="ln4433">  CdScope scope = kCdScopeInvalid;</a>
<a name="ln4434"> </a>
<a name="ln4435">  // Numbers of the scope objects (window, tab) we want the working directory</a>
<a name="ln4436">  // of. A `-1` means to skip this scope, a `0` means the current object.</a>
<a name="ln4437">  int scope_number[] = {</a>
<a name="ln4438">    [kCdScopeWindow] = 0,  // Number of window to look at.</a>
<a name="ln4439">    [kCdScopeTab   ] = 0,  // Number of tab to look at.</a>
<a name="ln4440">  };</a>
<a name="ln4441"> </a>
<a name="ln4442">  tabpage_T *tp  = curtab;  // The tabpage to look at.</a>
<a name="ln4443">  win_T     *win = curwin;  // The window to look at.</a>
<a name="ln4444"> </a>
<a name="ln4445">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4446">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4447"> </a>
<a name="ln4448">  // Pre-conditions and scope extraction together</a>
<a name="ln4449">  for (int i = MIN_CD_SCOPE; i &lt; MAX_CD_SCOPE; i++) {</a>
<a name="ln4450">    if (argvars[i].v_type == VAR_UNKNOWN) {</a>
<a name="ln4451">      break;</a>
<a name="ln4452">    }</a>
<a name="ln4453">    if (argvars[i].v_type != VAR_NUMBER) {</a>
<a name="ln4454">      EMSG(_(e_invarg));</a>
<a name="ln4455">      return;</a>
<a name="ln4456">    }</a>
<a name="ln4457">    scope_number[i] = argvars[i].vval.v_number;</a>
<a name="ln4458">    if (scope_number[i] &lt; -1) {</a>
<a name="ln4459">      EMSG(_(e_invarg));</a>
<a name="ln4460">      return;</a>
<a name="ln4461">    }</a>
<a name="ln4462">    // Use the narrowest scope the user requested</a>
<a name="ln4463">    if (scope_number[i] &gt;= 0 &amp;&amp; scope == kCdScopeInvalid) {</a>
<a name="ln4464">      // The scope is the current iteration step.</a>
<a name="ln4465">      scope = i;</a>
<a name="ln4466">    } else if (scope_number[i] &lt; 0) {</a>
<a name="ln4467">      scope = i + 1;</a>
<a name="ln4468">    }</a>
<a name="ln4469">  }</a>
<a name="ln4470"> </a>
<a name="ln4471">  // If the user didn't specify anything, default to window scope</a>
<a name="ln4472">  if (scope == kCdScopeInvalid) {</a>
<a name="ln4473">    scope = MIN_CD_SCOPE;</a>
<a name="ln4474">  }</a>
<a name="ln4475"> </a>
<a name="ln4476">  // Find the tabpage by number</a>
<a name="ln4477">  if (scope_number[kCdScopeTab] &gt; 0) {</a>
<a name="ln4478">    tp = find_tabpage(scope_number[kCdScopeTab]);</a>
<a name="ln4479">    if (!tp) {</a>
<a name="ln4480">      EMSG(_(&quot;E5000: Cannot find tab number.&quot;));</a>
<a name="ln4481">      return;</a>
<a name="ln4482">    }</a>
<a name="ln4483">  }</a>
<a name="ln4484"> </a>
<a name="ln4485">  // Find the window in `tp` by number, `NULL` if none.</a>
<a name="ln4486">  if (scope_number[kCdScopeWindow] &gt;= 0) {</a>
<a name="ln4487">    if (scope_number[kCdScopeTab] &lt; 0) {</a>
<a name="ln4488">      EMSG(_(&quot;E5001: Higher scope cannot be -1 if lower scope is &gt;= 0.&quot;));</a>
<a name="ln4489">      return;</a>
<a name="ln4490">    }</a>
<a name="ln4491"> </a>
<a name="ln4492">    if (scope_number[kCdScopeWindow] &gt; 0) {</a>
<a name="ln4493">      win = find_win_by_nr(&amp;argvars[0], tp);</a>
<a name="ln4494">      if (!win) {</a>
<a name="ln4495">        EMSG(_(&quot;E5002: Cannot find window number.&quot;));</a>
<a name="ln4496">        return;</a>
<a name="ln4497">      }</a>
<a name="ln4498">    }</a>
<a name="ln4499">  }</a>
<a name="ln4500"> </a>
<a name="ln4501">  switch (scope) {</a>
<a name="ln4502">    case kCdScopeWindow:</a>
<a name="ln4503">      assert(win);</a>
<a name="ln4504">      rettv-&gt;vval.v_number = win-&gt;w_localdir ? 1 : 0;</a>
<a name="ln4505">      break;</a>
<a name="ln4506">    case kCdScopeTab:</a>
<a name="ln4507">      assert(tp);</a>
<a name="ln4508">      rettv-&gt;vval.v_number = tp-&gt;tp_localdir ? 1 : 0;</a>
<a name="ln4509">      break;</a>
<a name="ln4510">    case kCdScopeGlobal:</a>
<a name="ln4511">      // The global scope never has a local directory</a>
<a name="ln4512">      break;</a>
<a name="ln4513">    case kCdScopeInvalid:</a>
<a name="ln4514">      // We should never get here</a>
<a name="ln4515">      abort();</a>
<a name="ln4516">  }</a>
<a name="ln4517">}</a>
<a name="ln4518"> </a>
<a name="ln4519">/*</a>
<a name="ln4520"> * &quot;hasmapto()&quot; function</a>
<a name="ln4521"> */</a>
<a name="ln4522">static void f_hasmapto(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4523">{</a>
<a name="ln4524">  const char *mode;</a>
<a name="ln4525">  const char *const name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4526">  bool abbr = false;</a>
<a name="ln4527">  char buf[NUMBUFLEN];</a>
<a name="ln4528">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4529">    mode = &quot;nvo&quot;;</a>
<a name="ln4530">  } else {</a>
<a name="ln4531">    mode = tv_get_string_buf(&amp;argvars[1], buf);</a>
<a name="ln4532">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4533">      abbr = tv_get_number(&amp;argvars[2]);</a>
<a name="ln4534">    }</a>
<a name="ln4535">  }</a>
<a name="ln4536"> </a>
<a name="ln4537">  if (map_to_exists(name, mode, abbr)) {</a>
<a name="ln4538">    rettv-&gt;vval.v_number = true;</a>
<a name="ln4539">  } else {</a>
<a name="ln4540">    rettv-&gt;vval.v_number = false;</a>
<a name="ln4541">  }</a>
<a name="ln4542">}</a>
<a name="ln4543"> </a>
<a name="ln4544">/*</a>
<a name="ln4545"> * &quot;histadd()&quot; function</a>
<a name="ln4546"> */</a>
<a name="ln4547">static void f_histadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4548">{</a>
<a name="ln4549">  HistoryType histype;</a>
<a name="ln4550"> </a>
<a name="ln4551">  rettv-&gt;vval.v_number = false;</a>
<a name="ln4552">  if (check_secure()) {</a>
<a name="ln4553">    return;</a>
<a name="ln4554">  }</a>
<a name="ln4555">  const char *str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4556">  histype = str != NULL ? get_histtype(str, strlen(str), false) : HIST_INVALID;</a>
<a name="ln4557">  if (histype != HIST_INVALID) {</a>
<a name="ln4558">    char buf[NUMBUFLEN];</a>
<a name="ln4559">    str = tv_get_string_buf(&amp;argvars[1], buf);</a>
<a name="ln4560">    if (*str != NUL) {</a>
<a name="ln4561">      init_history();</a>
<a name="ln4562">      add_to_history(histype, (char_u *)str, false, NUL);</a>
<a name="ln4563">      rettv-&gt;vval.v_number = true;</a>
<a name="ln4564">      return;</a>
<a name="ln4565">    }</a>
<a name="ln4566">  }</a>
<a name="ln4567">}</a>
<a name="ln4568"> </a>
<a name="ln4569">/*</a>
<a name="ln4570"> * &quot;histdel()&quot; function</a>
<a name="ln4571"> */</a>
<a name="ln4572">static void f_histdel(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4573">{</a>
<a name="ln4574">  int n;</a>
<a name="ln4575">  const char *const str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4576">  if (str == NULL) {</a>
<a name="ln4577">    n = 0;</a>
<a name="ln4578">  } else if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4579">    // only one argument: clear entire history</a>
<a name="ln4580">    n = clr_history(get_histtype(str, strlen(str), false));</a>
<a name="ln4581">  } else if (argvars[1].v_type == VAR_NUMBER) {</a>
<a name="ln4582">    // index given: remove that entry</a>
<a name="ln4583">    n = del_history_idx(get_histtype(str, strlen(str), false),</a>
<a name="ln4584">                        (int)tv_get_number(&amp;argvars[1]));</a>
<a name="ln4585">  } else {</a>
<a name="ln4586">    // string given: remove all matching entries</a>
<a name="ln4587">    char buf[NUMBUFLEN];</a>
<a name="ln4588">    n = del_history_entry(get_histtype(str, strlen(str), false),</a>
<a name="ln4589">                          (char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln4590">  }</a>
<a name="ln4591">  rettv-&gt;vval.v_number = n;</a>
<a name="ln4592">}</a>
<a name="ln4593"> </a>
<a name="ln4594">/*</a>
<a name="ln4595"> * &quot;histget()&quot; function</a>
<a name="ln4596"> */</a>
<a name="ln4597">static void f_histget(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4598">{</a>
<a name="ln4599">  HistoryType type;</a>
<a name="ln4600">  int idx;</a>
<a name="ln4601"> </a>
<a name="ln4602">  const char *const str = tv_get_string_chk(&amp;argvars[0]);  // NULL on type error</a>
<a name="ln4603">  if (str == NULL) {</a>
<a name="ln4604">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4605">  } else {</a>
<a name="ln4606">    type = get_histtype(str, strlen(str), false);</a>
<a name="ln4607">    if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln4608">      idx = get_history_idx(type);</a>
<a name="ln4609">    } else {</a>
<a name="ln4610">      idx = (int)tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln4611">    }</a>
<a name="ln4612">    // -1 on type error</a>
<a name="ln4613">    rettv-&gt;vval.v_string = vim_strsave(get_history_entry(type, idx));</a>
<a name="ln4614">  }</a>
<a name="ln4615">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4616">}</a>
<a name="ln4617"> </a>
<a name="ln4618">/*</a>
<a name="ln4619"> * &quot;histnr()&quot; function</a>
<a name="ln4620"> */</a>
<a name="ln4621">static void f_histnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4622">{</a>
<a name="ln4623">  const char *const history = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln4624">  HistoryType i = history == NULL</a>
<a name="ln4625">    ? HIST_INVALID</a>
<a name="ln4626">    : get_histtype(history, strlen(history), false);</a>
<a name="ln4627">  if (i != HIST_INVALID) {</a>
<a name="ln4628">    i = get_history_idx(i);</a>
<a name="ln4629">  }</a>
<a name="ln4630">  rettv-&gt;vval.v_number = i;</a>
<a name="ln4631">}</a>
<a name="ln4632"> </a>
<a name="ln4633">/*</a>
<a name="ln4634"> * &quot;highlightID(name)&quot; function</a>
<a name="ln4635"> */</a>
<a name="ln4636">static void f_hlID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4637">{</a>
<a name="ln4638">  rettv-&gt;vval.v_number = syn_name2id(</a>
<a name="ln4639">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4640">}</a>
<a name="ln4641"> </a>
<a name="ln4642">/*</a>
<a name="ln4643"> * &quot;highlight_exists()&quot; function</a>
<a name="ln4644"> */</a>
<a name="ln4645">static void f_hlexists(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4646">{</a>
<a name="ln4647">  rettv-&gt;vval.v_number = highlight_exists(</a>
<a name="ln4648">      (const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4649">}</a>
<a name="ln4650"> </a>
<a name="ln4651">/*</a>
<a name="ln4652"> * &quot;hostname()&quot; function</a>
<a name="ln4653"> */</a>
<a name="ln4654">static void f_hostname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4655">{</a>
<a name="ln4656">  char hostname[256];</a>
<a name="ln4657"> </a>
<a name="ln4658">  os_get_hostname(hostname, 256);</a>
<a name="ln4659">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4660">  rettv-&gt;vval.v_string = vim_strsave((char_u *)hostname);</a>
<a name="ln4661">}</a>
<a name="ln4662"> </a>
<a name="ln4663">/*</a>
<a name="ln4664"> * iconv() function</a>
<a name="ln4665"> */</a>
<a name="ln4666">static void f_iconv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4667">{</a>
<a name="ln4668">  vimconv_T vimconv;</a>
<a name="ln4669"> </a>
<a name="ln4670">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4671">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4672"> </a>
<a name="ln4673">  const char *const str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln4674">  char buf1[NUMBUFLEN];</a>
<a name="ln4675">  char_u *const from = enc_canonize(enc_skip(</a>
<a name="ln4676">      (char_u *)tv_get_string_buf(&amp;argvars[1], buf1)));</a>
<a name="ln4677">  char buf2[NUMBUFLEN];</a>
<a name="ln4678">  char_u *const to = enc_canonize(enc_skip(</a>
<a name="ln4679">      (char_u *)tv_get_string_buf(&amp;argvars[2], buf2)));</a>
<a name="ln4680">  vimconv.vc_type = CONV_NONE;</a>
<a name="ln4681">  convert_setup(&amp;vimconv, from, to);</a>
<a name="ln4682"> </a>
<a name="ln4683">  // If the encodings are equal, no conversion needed.</a>
<a name="ln4684">  if (vimconv.vc_type == CONV_NONE) {</a>
<a name="ln4685">    rettv-&gt;vval.v_string = (char_u *)xstrdup(str);</a>
<a name="ln4686">  } else {</a>
<a name="ln4687">    rettv-&gt;vval.v_string = string_convert(&amp;vimconv, (char_u *)str, NULL);</a>
<a name="ln4688">  }</a>
<a name="ln4689"> </a>
<a name="ln4690">  convert_setup(&amp;vimconv, NULL, NULL);</a>
<a name="ln4691">  xfree(from);</a>
<a name="ln4692">  xfree(to);</a>
<a name="ln4693">}</a>
<a name="ln4694"> </a>
<a name="ln4695">/*</a>
<a name="ln4696"> * &quot;indent()&quot; function</a>
<a name="ln4697"> */</a>
<a name="ln4698">static void f_indent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4699">{</a>
<a name="ln4700">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln4701">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln4702">    rettv-&gt;vval.v_number = get_indent_lnum(lnum);</a>
<a name="ln4703">  } else {</a>
<a name="ln4704">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln4705">  }</a>
<a name="ln4706">}</a>
<a name="ln4707"> </a>
<a name="ln4708">/*</a>
<a name="ln4709"> * &quot;index()&quot; function</a>
<a name="ln4710"> */</a>
<a name="ln4711">static void f_index(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4712">{</a>
<a name="ln4713">  long idx = 0;</a>
<a name="ln4714">  bool ic = false;</a>
<a name="ln4715"> </a>
<a name="ln4716">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4717">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4718">    EMSG(_(e_listreq));</a>
<a name="ln4719">    return;</a>
<a name="ln4720">  }</a>
<a name="ln4721">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln4722">  if (l != NULL) {</a>
<a name="ln4723">    listitem_T *item = tv_list_first(l);</a>
<a name="ln4724">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4725">      bool error = false;</a>
<a name="ln4726"> </a>
<a name="ln4727">      // Start at specified item.</a>
<a name="ln4728">      idx = tv_list_uidx(l, tv_get_number_chk(&amp;argvars[2], &amp;error));</a>
<a name="ln4729">      if (error || idx == -1) {</a>
<a name="ln4730">        item = NULL;</a>
<a name="ln4731">      } else {</a>
<a name="ln4732">        item = tv_list_find(l, idx);</a>
<a name="ln4733">        assert(item != NULL);</a>
<a name="ln4734">      }</a>
<a name="ln4735">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln4736">        ic = !!tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln4737">        if (error) {</a>
<a name="ln4738">          item = NULL;</a>
<a name="ln4739">        }</a>
<a name="ln4740">      }</a>
<a name="ln4741">    }</a>
<a name="ln4742"> </a>
<a name="ln4743">    for (; item != NULL; item = TV_LIST_ITEM_NEXT(l, item), idx++) {</a>
<a name="ln4744">      if (tv_equal(TV_LIST_ITEM_TV(item), &amp;argvars[1], ic, false)) {</a>
<a name="ln4745">        rettv-&gt;vval.v_number = idx;</a>
<a name="ln4746">        break;</a>
<a name="ln4747">      }</a>
<a name="ln4748">    }</a>
<a name="ln4749">  }</a>
<a name="ln4750">}</a>
<a name="ln4751"> </a>
<a name="ln4752">static bool inputsecret_flag = false;</a>
<a name="ln4753"> </a>
<a name="ln4754">/*</a>
<a name="ln4755"> * &quot;input()&quot; function</a>
<a name="ln4756"> *     Also handles inputsecret() when inputsecret is set.</a>
<a name="ln4757"> */</a>
<a name="ln4758">static void f_input(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4759">{</a>
<a name="ln4760">  get_user_input(argvars, rettv, FALSE, inputsecret_flag);</a>
<a name="ln4761">}</a>
<a name="ln4762"> </a>
<a name="ln4763">/*</a>
<a name="ln4764"> * &quot;inputdialog()&quot; function</a>
<a name="ln4765"> */</a>
<a name="ln4766">static void f_inputdialog(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4767">{</a>
<a name="ln4768">  get_user_input(argvars, rettv, TRUE, inputsecret_flag);</a>
<a name="ln4769">}</a>
<a name="ln4770"> </a>
<a name="ln4771">/*</a>
<a name="ln4772"> * &quot;inputlist()&quot; function</a>
<a name="ln4773"> */</a>
<a name="ln4774">static void f_inputlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4775">{</a>
<a name="ln4776">  int selected;</a>
<a name="ln4777">  int mouse_used;</a>
<a name="ln4778"> </a>
<a name="ln4779">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4780">    EMSG2(_(e_listarg), &quot;inputlist()&quot;);</a>
<a name="ln4781">    return;</a>
<a name="ln4782">  }</a>
<a name="ln4783"> </a>
<a name="ln4784">  msg_start();</a>
<a name="ln4785">  msg_row = Rows - 1;   // for when 'cmdheight' &gt; 1</a>
<a name="ln4786">  lines_left = Rows;    // avoid more prompt</a>
<a name="ln4787">  msg_scroll = true;</a>
<a name="ln4788">  msg_clr_eos();</a>
<a name="ln4789"> </a>
<a name="ln4790">  TV_LIST_ITER_CONST(argvars[0].vval.v_list, li, {</a>
<a name="ln4791">    msg_puts(tv_get_string(TV_LIST_ITEM_TV(li)));</a>
<a name="ln4792">    msg_putchar('\n');</a>
<a name="ln4793">  });</a>
<a name="ln4794"> </a>
<a name="ln4795">  // Ask for choice.</a>
<a name="ln4796">  selected = prompt_for_number(&amp;mouse_used);</a>
<a name="ln4797">  if (mouse_used) {</a>
<a name="ln4798">    selected -= lines_left;</a>
<a name="ln4799">  }</a>
<a name="ln4800"> </a>
<a name="ln4801">  rettv-&gt;vval.v_number = selected;</a>
<a name="ln4802">}</a>
<a name="ln4803"> </a>
<a name="ln4804"> </a>
<a name="ln4805">static garray_T ga_userinput = { 0, 0, sizeof(tasave_T), 4, NULL };</a>
<a name="ln4806"> </a>
<a name="ln4807">/// &quot;inputrestore()&quot; function</a>
<a name="ln4808">static void f_inputrestore(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4809">{</a>
<a name="ln4810">  if (!GA_EMPTY(&amp;ga_userinput)) {</a>
<a name="ln4811">    ga_userinput.ga_len--;</a>
<a name="ln4812">    restore_typeahead((tasave_T *)(ga_userinput.ga_data)</a>
<a name="ln4813">                      + ga_userinput.ga_len);</a>
<a name="ln4814">    // default return is zero == OK</a>
<a name="ln4815">  } else if (p_verbose &gt; 1) {</a>
<a name="ln4816">    verb_msg(_(&quot;called inputrestore() more often than inputsave()&quot;));</a>
<a name="ln4817">    rettv-&gt;vval.v_number = 1;  // Failed</a>
<a name="ln4818">  }</a>
<a name="ln4819">}</a>
<a name="ln4820"> </a>
<a name="ln4821">/// &quot;inputsave()&quot; function</a>
<a name="ln4822">static void f_inputsave(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4823">{</a>
<a name="ln4824">  // Add an entry to the stack of typeahead storage.</a>
<a name="ln4825">  tasave_T *p = GA_APPEND_VIA_PTR(tasave_T, &amp;ga_userinput);</a>
<a name="ln4826">  save_typeahead(p);</a>
<a name="ln4827">}</a>
<a name="ln4828"> </a>
<a name="ln4829">/// &quot;inputsecret()&quot; function</a>
<a name="ln4830">static void f_inputsecret(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4831">{</a>
<a name="ln4832">  cmdline_star++;</a>
<a name="ln4833">  inputsecret_flag = true;</a>
<a name="ln4834">  f_input(argvars, rettv, NULL);</a>
<a name="ln4835">  cmdline_star--;</a>
<a name="ln4836">  inputsecret_flag = false;</a>
<a name="ln4837">}</a>
<a name="ln4838"> </a>
<a name="ln4839">/*</a>
<a name="ln4840"> * &quot;insert()&quot; function</a>
<a name="ln4841"> */</a>
<a name="ln4842">static void f_insert(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4843">{</a>
<a name="ln4844">  list_T *l;</a>
<a name="ln4845">  bool error = false;</a>
<a name="ln4846"> </a>
<a name="ln4847">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln4848">    EMSG2(_(e_listarg), &quot;insert()&quot;);</a>
<a name="ln4849">  } else if (!var_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln4850">                             N_(&quot;insert() argument&quot;), TV_TRANSLATE)) {</a>
<a name="ln4851">    long before = 0;</a>
<a name="ln4852">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln4853">      before = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln4854">    }</a>
<a name="ln4855">    if (error) {</a>
<a name="ln4856">      // type error; errmsg already given</a>
<a name="ln4857">      return;</a>
<a name="ln4858">    }</a>
<a name="ln4859"> </a>
<a name="ln4860">    listitem_T *item = NULL;</a>
<a name="ln4861">    if (before != tv_list_len(l)) {</a>
<a name="ln4862">      item = tv_list_find(l, before);</a>
<a name="ln4863">      if (item == NULL) {</a>
<a name="ln4864">        EMSGN(_(e_listidx), before);</a>
<a name="ln4865">        l = NULL;</a>
<a name="ln4866">      }</a>
<a name="ln4867">    }</a>
<a name="ln4868">    if (l != NULL) {</a>
<a name="ln4869">      tv_list_insert_tv(l, &amp;argvars[1], item);</a>
<a name="ln4870">      tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln4871">    }</a>
<a name="ln4872">  }</a>
<a name="ln4873">}</a>
<a name="ln4874"> </a>
<a name="ln4875">// &quot;interrupt()&quot; function</a>
<a name="ln4876">static void f_interrupt(typval_T *argvars FUNC_ATTR_UNUSED,</a>
<a name="ln4877">                        typval_T *rettv FUNC_ATTR_UNUSED,</a>
<a name="ln4878">                        FunPtr fptr FUNC_ATTR_UNUSED)</a>
<a name="ln4879">{</a>
<a name="ln4880">  got_int = true;</a>
<a name="ln4881">}</a>
<a name="ln4882"> </a>
<a name="ln4883">/*</a>
<a name="ln4884"> * &quot;invert(expr)&quot; function</a>
<a name="ln4885"> */</a>
<a name="ln4886">static void f_invert(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4887">{</a>
<a name="ln4888">  rettv-&gt;vval.v_number = ~tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln4889">}</a>
<a name="ln4890"> </a>
<a name="ln4891">/*</a>
<a name="ln4892"> * &quot;isdirectory()&quot; function</a>
<a name="ln4893"> */</a>
<a name="ln4894">static void f_isdirectory(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4895">{</a>
<a name="ln4896">  rettv-&gt;vval.v_number = os_isdir((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln4897">}</a>
<a name="ln4898"> </a>
<a name="ln4899">/*</a>
<a name="ln4900"> * &quot;islocked()&quot; function</a>
<a name="ln4901"> */</a>
<a name="ln4902">static void f_islocked(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4903">{</a>
<a name="ln4904">  lval_T lv;</a>
<a name="ln4905">  dictitem_T  *di;</a>
<a name="ln4906"> </a>
<a name="ln4907">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln4908">  const char_u *const end = get_lval((char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln4909">                                     NULL,</a>
<a name="ln4910">                                     &amp;lv, false, false,</a>
<a name="ln4911">                                     GLV_NO_AUTOLOAD|GLV_READ_ONLY,</a>
<a name="ln4912">                                     FNE_CHECK_START);</a>
<a name="ln4913">  if (end != NULL &amp;&amp; lv.ll_name != NULL) {</a>
<a name="ln4914">    if (*end != NUL) {</a>
<a name="ln4915">      EMSG(_(e_trailing));</a>
<a name="ln4916">    } else {</a>
<a name="ln4917">      if (lv.ll_tv == NULL) {</a>
<a name="ln4918">        di = find_var((const char *)lv.ll_name, lv.ll_name_len, NULL, true);</a>
<a name="ln4919">        if (di != NULL) {</a>
<a name="ln4920">          // Consider a variable locked when:</a>
<a name="ln4921">          // 1. the variable itself is locked</a>
<a name="ln4922">          // 2. the value of the variable is locked.</a>
<a name="ln4923">          // 3. the List or Dict value is locked.</a>
<a name="ln4924">          rettv-&gt;vval.v_number = ((di-&gt;di_flags &amp; DI_FLAGS_LOCK)</a>
<a name="ln4925">                                  || tv_islocked(&amp;di-&gt;di_tv));</a>
<a name="ln4926">        }</a>
<a name="ln4927">      } else if (lv.ll_range) {</a>
<a name="ln4928">        EMSG(_(&quot;E786: Range not allowed&quot;));</a>
<a name="ln4929">      } else if (lv.ll_newkey != NULL) {</a>
<a name="ln4930">        EMSG2(_(e_dictkey), lv.ll_newkey);</a>
<a name="ln4931">      } else if (lv.ll_list != NULL) {</a>
<a name="ln4932">        // List item.</a>
<a name="ln4933">        rettv-&gt;vval.v_number = tv_islocked(TV_LIST_ITEM_TV(lv.ll_li));</a>
<a name="ln4934">      } else {</a>
<a name="ln4935">        // Dictionary item.</a>
<a name="ln4936">        rettv-&gt;vval.v_number = tv_islocked(&amp;lv.ll_di-&gt;di_tv);</a>
<a name="ln4937">      }</a>
<a name="ln4938">    }</a>
<a name="ln4939">  }</a>
<a name="ln4940"> </a>
<a name="ln4941">  clear_lval(&amp;lv);</a>
<a name="ln4942">}</a>
<a name="ln4943"> </a>
<a name="ln4944">// &quot;isinf()&quot; function</a>
<a name="ln4945">static void f_isinf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4946">{</a>
<a name="ln4947">  if (argvars[0].v_type == VAR_FLOAT</a>
<a name="ln4948">      &amp;&amp; xisinf(argvars[0].vval.v_float)) {</a>
<a name="ln4949">    rettv-&gt;vval.v_number = argvars[0].vval.v_float &gt; 0.0 ? 1 : -1;</a>
<a name="ln4950">  }</a>
<a name="ln4951">}</a>
<a name="ln4952"> </a>
<a name="ln4953">// &quot;isnan()&quot; function</a>
<a name="ln4954">static void f_isnan(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4955">{</a>
<a name="ln4956">  rettv-&gt;vval.v_number = argvars[0].v_type == VAR_FLOAT</a>
<a name="ln4957">    &amp;&amp; xisnan(argvars[0].vval.v_float);</a>
<a name="ln4958">}</a>
<a name="ln4959"> </a>
<a name="ln4960">/// &quot;id()&quot; function</a>
<a name="ln4961">static void f_id(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4962">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4963">{</a>
<a name="ln4964">  const int len = vim_vsnprintf_typval(NULL, 0, &quot;%p&quot;, dummy_ap, argvars);</a>
<a name="ln4965">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4966">  rettv-&gt;vval.v_string = xmalloc(len + 1);</a>
<a name="ln4967">  vim_vsnprintf_typval((char *)rettv-&gt;vval.v_string, len + 1, &quot;%p&quot;,</a>
<a name="ln4968">                       dummy_ap, argvars);</a>
<a name="ln4969">}</a>
<a name="ln4970"> </a>
<a name="ln4971">/*</a>
<a name="ln4972"> * &quot;items(dict)&quot; function</a>
<a name="ln4973"> */</a>
<a name="ln4974">static void f_items(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4975">{</a>
<a name="ln4976">  dict_list(argvars, rettv, 2);</a>
<a name="ln4977">}</a>
<a name="ln4978"> </a>
<a name="ln4979">// &quot;jobpid(id)&quot; function</a>
<a name="ln4980">static void f_jobpid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4981">{</a>
<a name="ln4982">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4983">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln4984"> </a>
<a name="ln4985">  if (check_secure()) {</a>
<a name="ln4986">    return;</a>
<a name="ln4987">  }</a>
<a name="ln4988"> </a>
<a name="ln4989">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln4990">    EMSG(_(e_invarg));</a>
<a name="ln4991">    return;</a>
<a name="ln4992">  }</a>
<a name="ln4993"> </a>
<a name="ln4994">  Channel *data = find_job(argvars[0].vval.v_number, true);</a>
<a name="ln4995">  if (!data) {</a>
<a name="ln4996">    return;</a>
<a name="ln4997">  }</a>
<a name="ln4998"> </a>
<a name="ln4999">  Process *proc = (Process *)&amp;data-&gt;stream.proc;</a>
<a name="ln5000">  rettv-&gt;vval.v_number = proc-&gt;pid;</a>
<a name="ln5001">}</a>
<a name="ln5002"> </a>
<a name="ln5003">// &quot;jobresize(job, width, height)&quot; function</a>
<a name="ln5004">static void f_jobresize(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5005">{</a>
<a name="ln5006">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5007">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5008"> </a>
<a name="ln5009">  if (check_secure()) {</a>
<a name="ln5010">    return;</a>
<a name="ln5011">  }</a>
<a name="ln5012"> </a>
<a name="ln5013">  if (argvars[0].v_type != VAR_NUMBER || argvars[1].v_type != VAR_NUMBER</a>
<a name="ln5014">      || argvars[2].v_type != VAR_NUMBER) {</a>
<a name="ln5015">    // job id, width, height</a>
<a name="ln5016">    EMSG(_(e_invarg));</a>
<a name="ln5017">    return;</a>
<a name="ln5018">  }</a>
<a name="ln5019"> </a>
<a name="ln5020"> </a>
<a name="ln5021">  Channel *data = find_job(argvars[0].vval.v_number, true);</a>
<a name="ln5022">  if (!data) {</a>
<a name="ln5023">    return;</a>
<a name="ln5024">  }</a>
<a name="ln5025"> </a>
<a name="ln5026">  if (data-&gt;stream.proc.type != kProcessTypePty) {</a>
<a name="ln5027">    EMSG(_(e_channotpty));</a>
<a name="ln5028">    return;</a>
<a name="ln5029">  }</a>
<a name="ln5030"> </a>
<a name="ln5031">  pty_process_resize(&amp;data-&gt;stream.pty, argvars[1].vval.v_number,</a>
<a name="ln5032">                     argvars[2].vval.v_number);</a>
<a name="ln5033">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln5034">}</a>
<a name="ln5035"> </a>
<a name="ln5036">static const char *ignored_env_vars[] = {</a>
<a name="ln5037">#ifndef WIN32</a>
<a name="ln5038">  &quot;COLUMNS&quot;,</a>
<a name="ln5039">  &quot;LINES&quot;,</a>
<a name="ln5040">  &quot;TERMCAP&quot;,</a>
<a name="ln5041">  &quot;COLORFGBG&quot;,</a>
<a name="ln5042">#endif</a>
<a name="ln5043">  NULL</a>
<a name="ln5044">};</a>
<a name="ln5045"> </a>
<a name="ln5046">/// According to comments in src/win/process.c of libuv, Windows has a few</a>
<a name="ln5047">/// &quot;essential&quot; environment variables.</a>
<a name="ln5048">static const char *required_env_vars[] = {</a>
<a name="ln5049">#ifdef WIN32</a>
<a name="ln5050">  &quot;HOMEDRIVE&quot;,</a>
<a name="ln5051">  &quot;HOMEPATH&quot;,</a>
<a name="ln5052">  &quot;LOGONSERVER&quot;,</a>
<a name="ln5053">  &quot;PATH&quot;,</a>
<a name="ln5054">  &quot;SYSTEMDRIVE&quot;,</a>
<a name="ln5055">  &quot;SYSTEMROOT&quot;,</a>
<a name="ln5056">  &quot;TEMP&quot;,</a>
<a name="ln5057">  &quot;USERDOMAIN&quot;,</a>
<a name="ln5058">  &quot;USERNAME&quot;,</a>
<a name="ln5059">  &quot;USERPROFILE&quot;,</a>
<a name="ln5060">  &quot;WINDIR&quot;,</a>
<a name="ln5061">#endif</a>
<a name="ln5062">  NULL</a>
<a name="ln5063">};</a>
<a name="ln5064"> </a>
<a name="ln5065">static dict_T *create_environment(const dictitem_T *job_env,</a>
<a name="ln5066">                                  const bool clear_env,</a>
<a name="ln5067">                                  const bool pty,</a>
<a name="ln5068">                                  const char * const pty_term_name)</a>
<a name="ln5069">{</a>
<a name="ln5070">  dict_T * env = tv_dict_alloc();</a>
<a name="ln5071"> </a>
<a name="ln5072">  if (!clear_env) {</a>
<a name="ln5073">    typval_T temp_env = TV_INITIAL_VALUE;</a>
<a name="ln5074">    f_environ(NULL, &amp;temp_env, NULL);</a>
<a name="ln5075">    tv_dict_extend(env, temp_env.vval.v_dict, &quot;force&quot;);</a>
<a name="ln5076">    tv_dict_free(temp_env.vval.v_dict);</a>
<a name="ln5077"> </a>
<a name="ln5078">    if (pty) {</a>
<a name="ln5079">      // These environment variables generally shouldn't be propagated to the</a>
<a name="ln5080">      // child process.  We're removing them here so the user can still decide</a>
<a name="ln5081">      // they want to explicitly set them.</a>
<a name="ln5082">      for (size_t i = 0;</a>
<a name="ln5083">           i &lt; ARRAY_SIZE(ignored_env_vars) &amp;&amp; ignored_env_vars[i];</a>
<a name="ln5084">           i++) {</a>
<a name="ln5085">        dictitem_T *dv = tv_dict_find(env, ignored_env_vars[i], -1);</a>
<a name="ln5086">        if (dv) {</a>
<a name="ln5087">          tv_dict_item_remove(env, dv);</a>
<a name="ln5088">        }</a>
<a name="ln5089">      }</a>
<a name="ln5090">#ifndef WIN32</a>
<a name="ln5091">      // Set COLORTERM to &quot;truecolor&quot; if termguicolors is set and 256</a>
<a name="ln5092">      // otherwise, but only if it was set in the parent terminal at all</a>
<a name="ln5093">      dictitem_T *dv = tv_dict_find(env, S_LEN(&quot;COLORTERM&quot;));</a>
<a name="ln5094">      if (dv) {</a>
<a name="ln5095">        tv_dict_item_remove(env, dv);</a>
<a name="ln5096">        tv_dict_add_str(env, S_LEN(&quot;COLORTERM&quot;), p_tgc ? &quot;truecolor&quot; : &quot;256&quot;);</a>
<a name="ln5097">      }</a>
<a name="ln5098">#endif</a>
<a name="ln5099">    }</a>
<a name="ln5100">  }</a>
<a name="ln5101"> </a>
<a name="ln5102">  // For a pty, we need a sane $TERM set.  We can't rely on nvim's environment,</a>
<a name="ln5103">  // because the child process is going to be communicating with nvim, not the</a>
<a name="ln5104">  // parent terminal.  Set a sane default, but let the user override it in the</a>
<a name="ln5105">  // job's environment if they want.</a>
<a name="ln5106">  if (pty) {</a>
<a name="ln5107">    dictitem_T *dv = tv_dict_find(env, S_LEN(&quot;TERM&quot;));</a>
<a name="ln5108">    if (dv) {</a>
<a name="ln5109">      tv_dict_item_remove(env, dv);</a>
<a name="ln5110">    }</a>
<a name="ln5111">    tv_dict_add_str(env, S_LEN(&quot;TERM&quot;), pty_term_name);</a>
<a name="ln5112">  }</a>
<a name="ln5113"> </a>
<a name="ln5114">  if (job_env) {</a>
<a name="ln5115">#ifdef WIN32</a>
<a name="ln5116">    TV_DICT_ITER(job_env-&gt;di_tv.vval.v_dict, var, {</a>
<a name="ln5117">      // Always use upper-case keys for Windows so we detect duplicate keys</a>
<a name="ln5118">      char *const key = strcase_save((const char *)var-&gt;di_key, true);</a>
<a name="ln5119">      size_t len = strlen(key);</a>
<a name="ln5120">      dictitem_T *dv = tv_dict_find(env, key, len);</a>
<a name="ln5121">      if (dv) {</a>
<a name="ln5122">        tv_dict_item_remove(env, dv);</a>
<a name="ln5123">      }</a>
<a name="ln5124">      tv_dict_add_str(env, key, len, tv_get_string(&amp;var-&gt;di_tv));</a>
<a name="ln5125">      xfree(key);</a>
<a name="ln5126">    });</a>
<a name="ln5127">#else</a>
<a name="ln5128">    tv_dict_extend(env, job_env-&gt;di_tv.vval.v_dict, &quot;force&quot;);</a>
<a name="ln5129">#endif</a>
<a name="ln5130">  }</a>
<a name="ln5131"> </a>
<a name="ln5132">  if (pty) {</a>
<a name="ln5133">    // Now that the custom environment is configured, we need to ensure certain</a>
<a name="ln5134">    // environment variables are present.</a>
<a name="ln5135">    for (size_t i = 0;</a>
<a name="ln5136">         i &lt; ARRAY_SIZE(required_env_vars) &amp;&amp; required_env_vars[i];</a>
<a name="ln5137">         i++) {</a>
<a name="ln5138">      size_t len = strlen(required_env_vars[i]);</a>
<a name="ln5139">      dictitem_T *dv = tv_dict_find(env, required_env_vars[i], len);</a>
<a name="ln5140">      if (!dv) {</a>
<a name="ln5141">        const char *env_var = os_getenv(required_env_vars[i]);</a>
<a name="ln5142">        if (env_var) {</a>
<a name="ln5143">          tv_dict_add_str(env, required_env_vars[i], len, env_var);</a>
<a name="ln5144">        }</a>
<a name="ln5145">      }</a>
<a name="ln5146">    }</a>
<a name="ln5147">  }</a>
<a name="ln5148"> </a>
<a name="ln5149">  return env;</a>
<a name="ln5150">}</a>
<a name="ln5151"> </a>
<a name="ln5152">// &quot;jobstart()&quot; function</a>
<a name="ln5153">static void f_jobstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5154">{</a>
<a name="ln5155">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5156">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5157"> </a>
<a name="ln5158">  if (check_secure()) {</a>
<a name="ln5159">    return;</a>
<a name="ln5160">  }</a>
<a name="ln5161"> </a>
<a name="ln5162">  bool executable = true;</a>
<a name="ln5163">  char **argv = tv_to_argv(&amp;argvars[0], NULL, &amp;executable);</a>
<a name="ln5164">  dict_T *env = NULL;</a>
<a name="ln5165">  if (!argv) {</a>
<a name="ln5166">    rettv-&gt;vval.v_number = executable ? 0 : -1;</a>
<a name="ln5167">    return;  // Did error message in tv_to_argv.</a>
<a name="ln5168">  }</a>
<a name="ln5169"> </a>
<a name="ln5170">  if (argvars[1].v_type != VAR_DICT &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5171">    // Wrong argument types</a>
<a name="ln5172">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln5173">    shell_free_argv(argv);</a>
<a name="ln5174">    return;</a>
<a name="ln5175">  }</a>
<a name="ln5176"> </a>
<a name="ln5177"> </a>
<a name="ln5178">  dict_T *job_opts = NULL;</a>
<a name="ln5179">  bool detach = false;</a>
<a name="ln5180">  bool rpc = false;</a>
<a name="ln5181">  bool pty = false;</a>
<a name="ln5182">  bool clear_env = false;</a>
<a name="ln5183">  bool overlapped = false;</a>
<a name="ln5184">  CallbackReader on_stdout = CALLBACK_READER_INIT,</a>
<a name="ln5185">                 on_stderr = CALLBACK_READER_INIT;</a>
<a name="ln5186">  Callback on_exit = CALLBACK_NONE;</a>
<a name="ln5187">  char *cwd = NULL;</a>
<a name="ln5188">  dictitem_T *job_env = NULL;</a>
<a name="ln5189">  if (argvars[1].v_type == VAR_DICT) {</a>
<a name="ln5190">    job_opts = argvars[1].vval.v_dict;</a>
<a name="ln5191"> </a>
<a name="ln5192">    detach = tv_dict_get_number(job_opts, &quot;detach&quot;) != 0;</a>
<a name="ln5193">    rpc = tv_dict_get_number(job_opts, &quot;rpc&quot;) != 0;</a>
<a name="ln5194">    pty = tv_dict_get_number(job_opts, &quot;pty&quot;) != 0;</a>
<a name="ln5195">    clear_env = tv_dict_get_number(job_opts, &quot;clear_env&quot;) != 0;</a>
<a name="ln5196">    overlapped = tv_dict_get_number(job_opts, &quot;overlapped&quot;) != 0;</a>
<a name="ln5197"> </a>
<a name="ln5198">    if (pty &amp;&amp; rpc) {</a>
<a name="ln5199">      EMSG2(_(e_invarg2), &quot;job cannot have both 'pty' and 'rpc' options set&quot;);</a>
<a name="ln5200">      shell_free_argv(argv);</a>
<a name="ln5201">      return;</a>
<a name="ln5202">    }</a>
<a name="ln5203"> </a>
<a name="ln5204">#ifdef WIN32</a>
<a name="ln5205">    if (pty &amp;&amp; overlapped) {</a>
<a name="ln5206">      EMSG2(_(e_invarg2),</a>
<a name="ln5207">            &quot;job cannot have both 'pty' and 'overlapped' options set&quot;);</a>
<a name="ln5208">      shell_free_argv(argv);</a>
<a name="ln5209">      return;</a>
<a name="ln5210">    }</a>
<a name="ln5211">#endif</a>
<a name="ln5212"> </a>
<a name="ln5213">    char *new_cwd = tv_dict_get_string(job_opts, &quot;cwd&quot;, false);</a>
<a name="ln5214">    if (new_cwd &amp;&amp; *new_cwd != NUL) {</a>
<a name="ln5215">      cwd = new_cwd;</a>
<a name="ln5216">      // The new cwd must be a directory.</a>
<a name="ln5217">      if (!os_isdir_executable((const char *)cwd)) {</a>
<a name="ln5218">        EMSG2(_(e_invarg2), &quot;expected valid directory&quot;);</a>
<a name="ln5219">        shell_free_argv(argv);</a>
<a name="ln5220">        return;</a>
<a name="ln5221">      }</a>
<a name="ln5222">    }</a>
<a name="ln5223"> </a>
<a name="ln5224">    job_env = tv_dict_find(job_opts, S_LEN(&quot;env&quot;));</a>
<a name="ln5225">    if (job_env &amp;&amp; job_env-&gt;di_tv.v_type != VAR_DICT) {</a>
<a name="ln5226">      EMSG2(_(e_invarg2), &quot;env&quot;);</a>
<a name="ln5227">      shell_free_argv(argv);</a>
<a name="ln5228">      return;</a>
<a name="ln5229">    }</a>
<a name="ln5230"> </a>
<a name="ln5231">    if (!common_job_callbacks(job_opts, &amp;on_stdout, &amp;on_stderr, &amp;on_exit)) {</a>
<a name="ln5232">      shell_free_argv(argv);</a>
<a name="ln5233">      return;</a>
<a name="ln5234">    }</a>
<a name="ln5235">  }</a>
<a name="ln5236"> </a>
<a name="ln5237">  uint16_t width = 0, height = 0;</a>
<a name="ln5238">  char *term_name = NULL;</a>
<a name="ln5239"> </a>
<a name="ln5240">  if (pty) {</a>
<a name="ln5241">    width = (uint16_t)tv_dict_get_number(job_opts, &quot;width&quot;);</a>
<a name="ln5242">    height = (uint16_t)tv_dict_get_number(job_opts, &quot;height&quot;);</a>
<a name="ln5243">    // Legacy method, before env option existed, to specify $TERM.  No longer</a>
<a name="ln5244">    // documented, but still usable to avoid breaking scripts.</a>
<a name="ln5245">    term_name = tv_dict_get_string(job_opts, &quot;TERM&quot;, false);</a>
<a name="ln5246">    if (!term_name) {</a>
<a name="ln5247">      term_name = &quot;ansi&quot;;</a>
<a name="ln5248">    }</a>
<a name="ln5249">  }</a>
<a name="ln5250"> </a>
<a name="ln5251">  env = create_environment(job_env, clear_env, pty, term_name);</a>
<a name="ln5252"> </a>
<a name="ln5253">  Channel *chan = channel_job_start(argv, on_stdout, on_stderr, on_exit, pty,</a>
<a name="ln5254">                                    rpc, overlapped, detach, cwd, width, height,</a>
<a name="ln5255">                                    env, &amp;rettv-&gt;vval.v_number);</a>
<a name="ln5256">  if (chan) {</a>
<a name="ln5257">    channel_create_event(chan, NULL);</a>
<a name="ln5258">  }</a>
<a name="ln5259">}</a>
<a name="ln5260"> </a>
<a name="ln5261">// &quot;jobstop()&quot; function</a>
<a name="ln5262">static void f_jobstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5263">{</a>
<a name="ln5264">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5265">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5266"> </a>
<a name="ln5267">  if (check_secure()) {</a>
<a name="ln5268">    return;</a>
<a name="ln5269">  }</a>
<a name="ln5270"> </a>
<a name="ln5271">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln5272">    // Only argument is the job id</a>
<a name="ln5273">    EMSG(_(e_invarg));</a>
<a name="ln5274">    return;</a>
<a name="ln5275">  }</a>
<a name="ln5276"> </a>
<a name="ln5277">  Channel *data = find_job(argvars[0].vval.v_number, false);</a>
<a name="ln5278">  if (!data) {</a>
<a name="ln5279">    return;</a>
<a name="ln5280">  }</a>
<a name="ln5281"> </a>
<a name="ln5282">  const char *error = NULL;</a>
<a name="ln5283">  if (data-&gt;is_rpc) {</a>
<a name="ln5284">    // Ignore return code, but show error later.</a>
<a name="ln5285">    (void)channel_close(data-&gt;id, kChannelPartRpc, &amp;error);</a>
<a name="ln5286">  }</a>
<a name="ln5287">  process_stop((Process *)&amp;data-&gt;stream.proc);</a>
<a name="ln5288">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln5289">  if (error) {</a>
<a name="ln5290">    EMSG(error);</a>
<a name="ln5291">  }</a>
<a name="ln5292">}</a>
<a name="ln5293"> </a>
<a name="ln5294">// &quot;jobwait(ids[, timeout])&quot; function</a>
<a name="ln5295">static void f_jobwait(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5296">{</a>
<a name="ln5297">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5298">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln5299"> </a>
<a name="ln5300">  if (check_secure()) {</a>
<a name="ln5301">    return;</a>
<a name="ln5302">  }</a>
<a name="ln5303">  if (argvars[0].v_type != VAR_LIST || (argvars[1].v_type != VAR_NUMBER</a>
<a name="ln5304">        &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln5305">    EMSG(_(e_invarg));</a>
<a name="ln5306">    return;</a>
<a name="ln5307">  }</a>
<a name="ln5308"> </a>
<a name="ln5309">  ui_busy_start();</a>
<a name="ln5310">  list_T *args = argvars[0].vval.v_list;</a>
<a name="ln5311">  Channel **jobs = xcalloc(tv_list_len(args), sizeof(*jobs));</a>
<a name="ln5312">  MultiQueue *waiting_jobs = multiqueue_new_parent(loop_on_put, &amp;main_loop);</a>
<a name="ln5313"> </a>
<a name="ln5314">  // Validate, prepare jobs for waiting.</a>
<a name="ln5315">  int i = 0;</a>
<a name="ln5316">  TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln5317">    Channel *chan = NULL;</a>
<a name="ln5318">    if (TV_LIST_ITEM_TV(arg)-&gt;v_type != VAR_NUMBER</a>
<a name="ln5319">        || !(chan = find_job(TV_LIST_ITEM_TV(arg)-&gt;vval.v_number, false))) {</a>
<a name="ln5320">      jobs[i] = NULL;  // Invalid job.</a>
<a name="ln5321">    } else {</a>
<a name="ln5322">      jobs[i] = chan;</a>
<a name="ln5323">      channel_incref(chan);</a>
<a name="ln5324">      if (chan-&gt;stream.proc.status &lt; 0) {</a>
<a name="ln5325">        // Process any pending events on the job's queue before temporarily</a>
<a name="ln5326">        // replacing it.</a>
<a name="ln5327">        multiqueue_process_events(chan-&gt;events);</a>
<a name="ln5328">        multiqueue_replace_parent(chan-&gt;events, waiting_jobs);</a>
<a name="ln5329">      }</a>
<a name="ln5330">    }</a>
<a name="ln5331">    i++;</a>
<a name="ln5332">  });</a>
<a name="ln5333"> </a>
<a name="ln5334">  int remaining = -1;</a>
<a name="ln5335">  uint64_t before = 0;</a>
<a name="ln5336">  if (argvars[1].v_type == VAR_NUMBER &amp;&amp; argvars[1].vval.v_number &gt;= 0) {</a>
<a name="ln5337">    remaining = argvars[1].vval.v_number;</a>
<a name="ln5338">    before = os_hrtime();</a>
<a name="ln5339">  }</a>
<a name="ln5340"> </a>
<a name="ln5341">  for (i = 0; i &lt; tv_list_len(args); i++) {</a>
<a name="ln5342">    if (remaining == 0) {</a>
<a name="ln5343">      break;  // Timeout.</a>
<a name="ln5344">    }</a>
<a name="ln5345">    if (jobs[i] == NULL) {</a>
<a name="ln5346">      continue;  // Invalid job, will assign status=-3 below.</a>
<a name="ln5347">    }</a>
<a name="ln5348">    int status = process_wait(&amp;jobs[i]-&gt;stream.proc, remaining,</a>
<a name="ln5349">                              waiting_jobs);</a>
<a name="ln5350">    if (status &lt; 0) {</a>
<a name="ln5351">      break;  // Interrupted (CTRL-C) or timeout, skip remaining jobs.</a>
<a name="ln5352">    }</a>
<a name="ln5353">    if (remaining &gt; 0) {</a>
<a name="ln5354">      uint64_t now = os_hrtime();</a>
<a name="ln5355">      remaining = MIN(0, remaining - (int)((now - before) / 1000000));</a>
<a name="ln5356">      before = now;</a>
<a name="ln5357">    }</a>
<a name="ln5358">  }</a>
<a name="ln5359"> </a>
<a name="ln5360">  list_T *const rv = tv_list_alloc(tv_list_len(args));</a>
<a name="ln5361"> </a>
<a name="ln5362">  // For each job:</a>
<a name="ln5363">  //  * Restore its parent queue if the job is still alive.</a>
<a name="ln5364">  //  * Append its status to the output list, or:</a>
<a name="ln5365">  //       -3 for &quot;invalid job id&quot;</a>
<a name="ln5366">  //       -2 for &quot;interrupted&quot; (user hit CTRL-C)</a>
<a name="ln5367">  //       -1 for jobs that were skipped or timed out</a>
<a name="ln5368">  for (i = 0; i &lt; tv_list_len(args); i++) {</a>
<a name="ln5369">    if (jobs[i] == NULL) {</a>
<a name="ln5370">      tv_list_append_number(rv, -3);</a>
<a name="ln5371">      continue;</a>
<a name="ln5372">    }</a>
<a name="ln5373">    multiqueue_process_events(jobs[i]-&gt;events);</a>
<a name="ln5374">    multiqueue_replace_parent(jobs[i]-&gt;events, main_loop.events);</a>
<a name="ln5375"> </a>
<a name="ln5376">    tv_list_append_number(rv, jobs[i]-&gt;stream.proc.status);</a>
<a name="ln5377">    channel_decref(jobs[i]);</a>
<a name="ln5378">  }</a>
<a name="ln5379"> </a>
<a name="ln5380">  multiqueue_free(waiting_jobs);</a>
<a name="ln5381">  xfree(jobs);</a>
<a name="ln5382">  ui_busy_stop();</a>
<a name="ln5383">  tv_list_ref(rv);</a>
<a name="ln5384">  rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln5385">  rettv-&gt;vval.v_list = rv;</a>
<a name="ln5386">}</a>
<a name="ln5387"> </a>
<a name="ln5388">/*</a>
<a name="ln5389"> * &quot;join()&quot; function</a>
<a name="ln5390"> */</a>
<a name="ln5391">static void f_join(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5392">{</a>
<a name="ln5393">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln5394">    EMSG(_(e_listreq));</a>
<a name="ln5395">    return;</a>
<a name="ln5396">  }</a>
<a name="ln5397">  const char *const sep = (argvars[1].v_type == VAR_UNKNOWN</a>
<a name="ln5398">                           ? &quot; &quot;</a>
<a name="ln5399">                           : tv_get_string_chk(&amp;argvars[1]));</a>
<a name="ln5400"> </a>
<a name="ln5401">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5402"> </a>
<a name="ln5403">  if (sep != NULL) {</a>
<a name="ln5404">    garray_T ga;</a>
<a name="ln5405">    ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln5406">    tv_list_join(&amp;ga, argvars[0].vval.v_list, sep);</a>
<a name="ln5407">    ga_append(&amp;ga, NUL);</a>
<a name="ln5408">    rettv-&gt;vval.v_string = (char_u *)ga.ga_data;</a>
<a name="ln5409">  } else {</a>
<a name="ln5410">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5411">  }</a>
<a name="ln5412">}</a>
<a name="ln5413"> </a>
<a name="ln5414">/// json_decode() function</a>
<a name="ln5415">static void f_json_decode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5416">{</a>
<a name="ln5417">  char numbuf[NUMBUFLEN];</a>
<a name="ln5418">  const char *s = NULL;</a>
<a name="ln5419">  char *tofree = NULL;</a>
<a name="ln5420">  size_t len;</a>
<a name="ln5421">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln5422">    if (!encode_vim_list_to_buf(argvars[0].vval.v_list, &amp;len, &amp;tofree)) {</a>
<a name="ln5423">      EMSG(_(&quot;E474: Failed to convert list to string&quot;));</a>
<a name="ln5424">      return;</a>
<a name="ln5425">    }</a>
<a name="ln5426">    s = tofree;</a>
<a name="ln5427">    if (s == NULL) {</a>
<a name="ln5428">      assert(len == 0);</a>
<a name="ln5429">      s = &quot;&quot;;</a>
<a name="ln5430">    }</a>
<a name="ln5431">  } else {</a>
<a name="ln5432">    s = tv_get_string_buf_chk(&amp;argvars[0], numbuf);</a>
<a name="ln5433">    if (s) {</a>
<a name="ln5434">      len = strlen(s);</a>
<a name="ln5435">    } else {</a>
<a name="ln5436">      return;</a>
<a name="ln5437">    }</a>
<a name="ln5438">  }</a>
<a name="ln5439">  if (json_decode_string(s, len, rettv) == FAIL) {</a>
<a name="ln5440">    emsgf(_(&quot;E474: Failed to parse %.*s&quot;), (int)len, s);</a>
<a name="ln5441">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln5442">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln5443">  }</a>
<a name="ln5444">  assert(rettv-&gt;v_type != VAR_UNKNOWN);</a>
<a name="ln5445">  xfree(tofree);</a>
<a name="ln5446">}</a>
<a name="ln5447"> </a>
<a name="ln5448">/// json_encode() function</a>
<a name="ln5449">static void f_json_encode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5450">{</a>
<a name="ln5451">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5452">  rettv-&gt;vval.v_string = (char_u *)encode_tv2json(&amp;argvars[0], NULL);</a>
<a name="ln5453">}</a>
<a name="ln5454"> </a>
<a name="ln5455">/*</a>
<a name="ln5456"> * &quot;keys()&quot; function</a>
<a name="ln5457"> */</a>
<a name="ln5458">static void f_keys(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5459">{</a>
<a name="ln5460">  dict_list(argvars, rettv, 0);</a>
<a name="ln5461">}</a>
<a name="ln5462"> </a>
<a name="ln5463">/*</a>
<a name="ln5464"> * &quot;last_buffer_nr()&quot; function.</a>
<a name="ln5465"> */</a>
<a name="ln5466">static void f_last_buffer_nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5467">{</a>
<a name="ln5468">  int n = 0;</a>
<a name="ln5469"> </a>
<a name="ln5470">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln5471">    if (n &lt; buf-&gt;b_fnum) {</a>
<a name="ln5472">      n = buf-&gt;b_fnum;</a>
<a name="ln5473">    }</a>
<a name="ln5474">  }</a>
<a name="ln5475"> </a>
<a name="ln5476">  rettv-&gt;vval.v_number = n;</a>
<a name="ln5477">}</a>
<a name="ln5478"> </a>
<a name="ln5479">/*</a>
<a name="ln5480"> * &quot;len()&quot; function</a>
<a name="ln5481"> */</a>
<a name="ln5482">static void f_len(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5483">{</a>
<a name="ln5484">  switch (argvars[0].v_type) {</a>
<a name="ln5485">    case VAR_STRING:</a>
<a name="ln5486">    case VAR_NUMBER: {</a>
<a name="ln5487">      rettv-&gt;vval.v_number = (varnumber_T)strlen(</a>
<a name="ln5488">          tv_get_string(&amp;argvars[0]));</a>
<a name="ln5489">      break;</a>
<a name="ln5490">    }</a>
<a name="ln5491">    case VAR_LIST: {</a>
<a name="ln5492">      rettv-&gt;vval.v_number = tv_list_len(argvars[0].vval.v_list);</a>
<a name="ln5493">      break;</a>
<a name="ln5494">    }</a>
<a name="ln5495">    case VAR_DICT: {</a>
<a name="ln5496">      rettv-&gt;vval.v_number = tv_dict_len(argvars[0].vval.v_dict);</a>
<a name="ln5497">      break;</a>
<a name="ln5498">    }</a>
<a name="ln5499">    case VAR_UNKNOWN:</a>
<a name="ln5500">    case VAR_BOOL:</a>
<a name="ln5501">    case VAR_SPECIAL:</a>
<a name="ln5502">    case VAR_FLOAT:</a>
<a name="ln5503">    case VAR_PARTIAL:</a>
<a name="ln5504">    case VAR_FUNC: {</a>
<a name="ln5505">      EMSG(_(&quot;E701: Invalid type for len()&quot;));</a>
<a name="ln5506">      break;</a>
<a name="ln5507">    }</a>
<a name="ln5508">  }</a>
<a name="ln5509">}</a>
<a name="ln5510"> </a>
<a name="ln5511">static void libcall_common(typval_T *argvars, typval_T *rettv, int out_type)</a>
<a name="ln5512">{</a>
<a name="ln5513">  rettv-&gt;v_type = out_type;</a>
<a name="ln5514">  if (out_type != VAR_NUMBER) {</a>
<a name="ln5515">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5516">  }</a>
<a name="ln5517"> </a>
<a name="ln5518">  if (check_secure()) {</a>
<a name="ln5519">    return;</a>
<a name="ln5520">  }</a>
<a name="ln5521"> </a>
<a name="ln5522">  // The first two args (libname and funcname) must be strings</a>
<a name="ln5523">  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {</a>
<a name="ln5524">    return;</a>
<a name="ln5525">  }</a>
<a name="ln5526"> </a>
<a name="ln5527">  const char *libname = (char *)argvars[0].vval.v_string;</a>
<a name="ln5528">  const char *funcname = (char *)argvars[1].vval.v_string;</a>
<a name="ln5529"> </a>
<a name="ln5530">  VarType in_type = argvars[2].v_type;</a>
<a name="ln5531"> </a>
<a name="ln5532">  // input variables</a>
<a name="ln5533">  char *str_in = (in_type == VAR_STRING)</a>
<a name="ln5534">      ? (char *)argvars[2].vval.v_string : NULL;</a>
<a name="ln5535">  int int_in = argvars[2].vval.v_number;</a>
<a name="ln5536"> </a>
<a name="ln5537">  // output variables</a>
<a name="ln5538">  char **str_out = (out_type == VAR_STRING)</a>
<a name="ln5539">      ? (char **)&amp;rettv-&gt;vval.v_string : NULL;</a>
<a name="ln5540">  int int_out = 0;</a>
<a name="ln5541"> </a>
<a name="ln5542">  bool success = os_libcall(libname, funcname,</a>
<a name="ln5543">                            str_in, int_in,</a>
<a name="ln5544">                            str_out, &amp;int_out);</a>
<a name="ln5545"> </a>
<a name="ln5546">  if (!success) {</a>
<a name="ln5547">    EMSG2(_(e_libcall), funcname);</a>
<a name="ln5548">    return;</a>
<a name="ln5549">  }</a>
<a name="ln5550"> </a>
<a name="ln5551">  if (out_type == VAR_NUMBER) {</a>
<a name="ln5552">     rettv-&gt;vval.v_number = (varnumber_T)int_out;</a>
<a name="ln5553">  }</a>
<a name="ln5554">}</a>
<a name="ln5555"> </a>
<a name="ln5556">/*</a>
<a name="ln5557"> * &quot;libcall()&quot; function</a>
<a name="ln5558"> */</a>
<a name="ln5559">static void f_libcall(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5560">{</a>
<a name="ln5561">  libcall_common(argvars, rettv, VAR_STRING);</a>
<a name="ln5562">}</a>
<a name="ln5563"> </a>
<a name="ln5564">/*</a>
<a name="ln5565"> * &quot;libcallnr()&quot; function</a>
<a name="ln5566"> */</a>
<a name="ln5567">static void f_libcallnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5568">{</a>
<a name="ln5569">  libcall_common(argvars, rettv, VAR_NUMBER);</a>
<a name="ln5570">}</a>
<a name="ln5571"> </a>
<a name="ln5572">// &quot;line(string, [winid])&quot; function</a>
<a name="ln5573">static void f_line(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5574">{</a>
<a name="ln5575">  linenr_T lnum = 0;</a>
<a name="ln5576">  pos_T *fp = NULL;</a>
<a name="ln5577">  int fnum;</a>
<a name="ln5578"> </a>
<a name="ln5579">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5580">    tabpage_T *tp;</a>
<a name="ln5581">    win_T *save_curwin;</a>
<a name="ln5582">    tabpage_T *save_curtab;</a>
<a name="ln5583"> </a>
<a name="ln5584">    // use window specified in the second argument</a>
<a name="ln5585">    win_T *wp = win_id2wp_tp(&amp;argvars[1], &amp;tp);</a>
<a name="ln5586">    if (wp != NULL &amp;&amp; tp != NULL) {</a>
<a name="ln5587">      if (switch_win_noblock(&amp;save_curwin, &amp;save_curtab, wp, tp, true)</a>
<a name="ln5588">          == OK) {</a>
<a name="ln5589">        check_cursor();</a>
<a name="ln5590">        fp = var2fpos(&amp;argvars[0], true, &amp;fnum);</a>
<a name="ln5591">      }</a>
<a name="ln5592">      restore_win_noblock(save_curwin, save_curtab, true);</a>
<a name="ln5593">    }</a>
<a name="ln5594">  } else {</a>
<a name="ln5595">    // use current window</a>
<a name="ln5596">    fp = var2fpos(&amp;argvars[0], true, &amp;fnum);</a>
<a name="ln5597">  }</a>
<a name="ln5598"> </a>
<a name="ln5599">  if (fp != NULL) {</a>
<a name="ln5600">    lnum = fp-&gt;lnum;</a>
<a name="ln5601">  }</a>
<a name="ln5602">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln5603">}</a>
<a name="ln5604"> </a>
<a name="ln5605">/*</a>
<a name="ln5606"> * &quot;line2byte(lnum)&quot; function</a>
<a name="ln5607"> */</a>
<a name="ln5608">static void f_line2byte(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5609">{</a>
<a name="ln5610">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln5611">  if (lnum &lt; 1 || lnum &gt; curbuf-&gt;b_ml.ml_line_count + 1) {</a>
<a name="ln5612">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln5613">  } else {</a>
<a name="ln5614">    rettv-&gt;vval.v_number = ml_find_line_or_offset(curbuf, lnum, NULL, false);</a>
<a name="ln5615">  }</a>
<a name="ln5616">  if (rettv-&gt;vval.v_number &gt;= 0) {</a>
<a name="ln5617">    rettv-&gt;vval.v_number++;</a>
<a name="ln5618">  }</a>
<a name="ln5619">}</a>
<a name="ln5620"> </a>
<a name="ln5621">/*</a>
<a name="ln5622"> * &quot;lispindent(lnum)&quot; function</a>
<a name="ln5623"> */</a>
<a name="ln5624">static void f_lispindent(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5625">{</a>
<a name="ln5626">  const pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln5627">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln5628">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5629">    curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln5630">    rettv-&gt;vval.v_number = get_lisp_indent();</a>
<a name="ln5631">    curwin-&gt;w_cursor = pos;</a>
<a name="ln5632">  } else {</a>
<a name="ln5633">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln5634">  }</a>
<a name="ln5635">}</a>
<a name="ln5636"> </a>
<a name="ln5637">// &quot;list2str()&quot; function</a>
<a name="ln5638">static void f_list2str(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5639">{</a>
<a name="ln5640">  garray_T ga;</a>
<a name="ln5641"> </a>
<a name="ln5642">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5643">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5644">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln5645">    EMSG(_(e_invarg));</a>
<a name="ln5646">    return;</a>
<a name="ln5647">  }</a>
<a name="ln5648"> </a>
<a name="ln5649">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln5650">  if (l == NULL) {</a>
<a name="ln5651">    return;  // empty list results in empty string</a>
<a name="ln5652">  }</a>
<a name="ln5653"> </a>
<a name="ln5654">  ga_init(&amp;ga, 1, 80);</a>
<a name="ln5655">  char_u buf[MB_MAXBYTES + 1];</a>
<a name="ln5656"> </a>
<a name="ln5657">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln5658">    buf[utf_char2bytes(tv_get_number(TV_LIST_ITEM_TV(li)), buf)] = NUL;</a>
<a name="ln5659">    ga_concat(&amp;ga, buf);</a>
<a name="ln5660">  });</a>
<a name="ln5661">  ga_append(&amp;ga, NUL);</a>
<a name="ln5662"> </a>
<a name="ln5663">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln5664">}</a>
<a name="ln5665"> </a>
<a name="ln5666">/*</a>
<a name="ln5667"> * &quot;localtime()&quot; function</a>
<a name="ln5668"> */</a>
<a name="ln5669">static void f_localtime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5670">{</a>
<a name="ln5671">  rettv-&gt;vval.v_number = (varnumber_T)time(NULL);</a>
<a name="ln5672">}</a>
<a name="ln5673"> </a>
<a name="ln5674"> </a>
<a name="ln5675">static void get_maparg(typval_T *argvars, typval_T *rettv, int exact)</a>
<a name="ln5676">{</a>
<a name="ln5677">  char_u *keys_buf = NULL;</a>
<a name="ln5678">  char_u *rhs;</a>
<a name="ln5679">  int mode;</a>
<a name="ln5680">  int abbr = FALSE;</a>
<a name="ln5681">  int get_dict = FALSE;</a>
<a name="ln5682">  mapblock_T  *mp;</a>
<a name="ln5683">  int buffer_local;</a>
<a name="ln5684"> </a>
<a name="ln5685">  // Return empty string for failure.</a>
<a name="ln5686">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5687">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5688"> </a>
<a name="ln5689">  char_u *keys = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln5690">  if (*keys == NUL) {</a>
<a name="ln5691">    return;</a>
<a name="ln5692">  }</a>
<a name="ln5693"> </a>
<a name="ln5694">  char buf[NUMBUFLEN];</a>
<a name="ln5695">  const char *which;</a>
<a name="ln5696">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5697">    which = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln5698">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5699">      abbr = tv_get_number(&amp;argvars[2]);</a>
<a name="ln5700">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5701">        get_dict = tv_get_number(&amp;argvars[3]);</a>
<a name="ln5702">      }</a>
<a name="ln5703">    }</a>
<a name="ln5704">  } else {</a>
<a name="ln5705">    which = &quot;&quot;;</a>
<a name="ln5706">  }</a>
<a name="ln5707">  if (which == NULL) {</a>
<a name="ln5708">    return;</a>
<a name="ln5709">  }</a>
<a name="ln5710"> </a>
<a name="ln5711">  mode = get_map_mode((char_u **)&amp;which, 0);</a>
<a name="ln5712"> </a>
<a name="ln5713">  keys = replace_termcodes(keys, STRLEN(keys), &amp;keys_buf, true, true, true,</a>
<a name="ln5714">                           CPO_TO_CPO_FLAGS);</a>
<a name="ln5715">  rhs = check_map(keys, mode, exact, false, abbr, &amp;mp, &amp;buffer_local);</a>
<a name="ln5716">  xfree(keys_buf);</a>
<a name="ln5717"> </a>
<a name="ln5718">  if (!get_dict) {</a>
<a name="ln5719">    // Return a string.</a>
<a name="ln5720">    if (rhs != NULL) {</a>
<a name="ln5721">      if (*rhs == NUL) {</a>
<a name="ln5722">        rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;&lt;Nop&gt;&quot;);</a>
<a name="ln5723">      } else {</a>
<a name="ln5724">        rettv-&gt;vval.v_string = (char_u *)str2special_save(</a>
<a name="ln5725">            (char *)rhs, false, false);</a>
<a name="ln5726">      }</a>
<a name="ln5727">    }</a>
<a name="ln5728"> </a>
<a name="ln5729">  } else {</a>
<a name="ln5730">    tv_dict_alloc_ret(rettv);</a>
<a name="ln5731">    if (rhs != NULL) {</a>
<a name="ln5732">      // Return a dictionary.</a>
<a name="ln5733">      mapblock_fill_dict(rettv-&gt;vval.v_dict, mp, buffer_local, true);</a>
<a name="ln5734">    }</a>
<a name="ln5735">  }</a>
<a name="ln5736">}</a>
<a name="ln5737"> </a>
<a name="ln5738">/// luaeval() function implementation</a>
<a name="ln5739">static void f_luaeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5740">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5741">{</a>
<a name="ln5742">  const char *const str = (const char *)tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln5743">  if (str == NULL) {</a>
<a name="ln5744">    return;</a>
<a name="ln5745">  }</a>
<a name="ln5746"> </a>
<a name="ln5747">  nlua_typval_eval(cstr_as_string((char *)str), &amp;argvars[1], rettv);</a>
<a name="ln5748">}</a>
<a name="ln5749"> </a>
<a name="ln5750">/*</a>
<a name="ln5751"> * &quot;map()&quot; function</a>
<a name="ln5752"> */</a>
<a name="ln5753">static void f_map(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5754">{</a>
<a name="ln5755">  filter_map(argvars, rettv, TRUE);</a>
<a name="ln5756">}</a>
<a name="ln5757"> </a>
<a name="ln5758">/*</a>
<a name="ln5759"> * &quot;maparg()&quot; function</a>
<a name="ln5760"> */</a>
<a name="ln5761">static void f_maparg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5762">{</a>
<a name="ln5763">  get_maparg(argvars, rettv, TRUE);</a>
<a name="ln5764">}</a>
<a name="ln5765"> </a>
<a name="ln5766">/*</a>
<a name="ln5767"> * &quot;mapcheck()&quot; function</a>
<a name="ln5768"> */</a>
<a name="ln5769">static void f_mapcheck(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5770">{</a>
<a name="ln5771">  get_maparg(argvars, rettv, FALSE);</a>
<a name="ln5772">}</a>
<a name="ln5773"> </a>
<a name="ln5774"> </a>
<a name="ln5775">static void find_some_match(typval_T *const argvars, typval_T *const rettv,</a>
<a name="ln5776">                            const SomeMatchType type)</a>
<a name="ln5777">{</a>
<a name="ln5778">  char_u      *str = NULL;</a>
<a name="ln5779">  long        len = 0;</a>
<a name="ln5780">  char_u      *expr = NULL;</a>
<a name="ln5781">  regmatch_T regmatch;</a>
<a name="ln5782">  char_u      *save_cpo;</a>
<a name="ln5783">  long start = 0;</a>
<a name="ln5784">  long nth = 1;</a>
<a name="ln5785">  colnr_T startcol = 0;</a>
<a name="ln5786">  bool match = false;</a>
<a name="ln5787">  list_T      *l = NULL;</a>
<a name="ln5788">  listitem_T  *li = NULL;</a>
<a name="ln5789">  long idx = 0;</a>
<a name="ln5790">  char_u      *tofree = NULL;</a>
<a name="ln5791"> </a>
<a name="ln5792">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln5793">  save_cpo = p_cpo;</a>
<a name="ln5794">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln5795"> </a>
<a name="ln5796">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln5797">  switch (type) {</a>
<a name="ln5798">    // matchlist(): return empty list when there are no matches.</a>
<a name="ln5799">    case kSomeMatchList: {</a>
<a name="ln5800">      tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln5801">      break;</a>
<a name="ln5802">    }</a>
<a name="ln5803">    // matchstrpos(): return [&quot;&quot;, -1, -1, -1]</a>
<a name="ln5804">    case kSomeMatchStrPos: {</a>
<a name="ln5805">      tv_list_alloc_ret(rettv, 4);</a>
<a name="ln5806">      tv_list_append_string(rettv-&gt;vval.v_list, &quot;&quot;, 0);</a>
<a name="ln5807">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5808">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5809">      tv_list_append_number(rettv-&gt;vval.v_list, -1);</a>
<a name="ln5810">      break;</a>
<a name="ln5811">    }</a>
<a name="ln5812">    case kSomeMatchStr: {</a>
<a name="ln5813">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5814">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5815">      break;</a>
<a name="ln5816">    }</a>
<a name="ln5817">    case kSomeMatch:</a>
<a name="ln5818">    case kSomeMatchEnd: {</a>
<a name="ln5819">      // Do nothing: zero is default.</a>
<a name="ln5820">      break;</a>
<a name="ln5821">    }</a>
<a name="ln5822">  }</a>
<a name="ln5823"> </a>
<a name="ln5824">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln5825">    if ((l = argvars[0].vval.v_list) == NULL) {</a>
<a name="ln5826">      goto theend;</a>
<a name="ln5827">    }</a>
<a name="ln5828">    li = tv_list_first(l);</a>
<a name="ln5829">  } else {</a>
<a name="ln5830">    expr = str = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln5831">    len = (long)STRLEN(str);</a>
<a name="ln5832">  }</a>
<a name="ln5833"> </a>
<a name="ln5834">  char patbuf[NUMBUFLEN];</a>
<a name="ln5835">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln5836">  if (pat == NULL) {</a>
<a name="ln5837">    goto theend;</a>
<a name="ln5838">  }</a>
<a name="ln5839"> </a>
<a name="ln5840">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5841">    bool error = false;</a>
<a name="ln5842"> </a>
<a name="ln5843">    start = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln5844">    if (error) {</a>
<a name="ln5845">      goto theend;</a>
<a name="ln5846">    }</a>
<a name="ln5847">    if (l != NULL) {</a>
<a name="ln5848">      idx = tv_list_uidx(l, start);</a>
<a name="ln5849">      if (idx == -1) {</a>
<a name="ln5850">        goto theend;</a>
<a name="ln5851">      }</a>
<a name="ln5852">      li = tv_list_find(l, idx);</a>
<a name="ln5853">    } else {</a>
<a name="ln5854">      if (start &lt; 0)</a>
<a name="ln5855">        start = 0;</a>
<a name="ln5856">      if (start &gt; len)</a>
<a name="ln5857">        goto theend;</a>
<a name="ln5858">      // When &quot;count&quot; argument is there ignore matches before &quot;start&quot;,</a>
<a name="ln5859">      // otherwise skip part of the string.  Differs when pattern is &quot;^&quot;</a>
<a name="ln5860">      // or &quot;\&lt;&quot;.</a>
<a name="ln5861">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5862">        startcol = start;</a>
<a name="ln5863">      } else {</a>
<a name="ln5864">        str += start;</a>
<a name="ln5865">        len -= start;</a>
<a name="ln5866">      }</a>
<a name="ln5867">    }</a>
<a name="ln5868"> </a>
<a name="ln5869">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5870">      nth = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln5871">    }</a>
<a name="ln5872">    if (error) {</a>
<a name="ln5873">      goto theend;</a>
<a name="ln5874">    }</a>
<a name="ln5875">  }</a>
<a name="ln5876"> </a>
<a name="ln5877">  regmatch.regprog = vim_regcomp((char_u *)pat, RE_MAGIC + RE_STRING);</a>
<a name="ln5878">  if (regmatch.regprog != NULL) {</a>
<a name="ln5879">    regmatch.rm_ic = p_ic;</a>
<a name="ln5880"> </a>
<a name="ln5881">    for (;; ) {</a>
<a name="ln5882">      if (l != NULL) {</a>
<a name="ln5883">        if (li == NULL) {</a>
<a name="ln5884">          match = false;</a>
<a name="ln5885">          break;</a>
<a name="ln5886">        }</a>
<a name="ln5887">        xfree(tofree);</a>
<a name="ln5888">        tofree = expr = str = (char_u *)encode_tv2echo(TV_LIST_ITEM_TV(li),</a>
<a name="ln5889">                                                       NULL);</a>
<a name="ln5890">        if (str == NULL) {</a>
<a name="ln5891">          break;</a>
<a name="ln5892">        }</a>
<a name="ln5893">      }</a>
<a name="ln5894"> </a>
<a name="ln5895">      match = vim_regexec_nl(&amp;regmatch, str, (colnr_T)startcol);</a>
<a name="ln5896"> </a>
<a name="ln5897">      if (match &amp;&amp; --nth &lt;= 0)</a>
<a name="ln5898">        break;</a>
<a name="ln5899">      if (l == NULL &amp;&amp; !match)</a>
<a name="ln5900">        break;</a>
<a name="ln5901"> </a>
<a name="ln5902">      // Advance to just after the match.</a>
<a name="ln5903">      if (l != NULL) {</a>
<a name="ln5904">        li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln5905">        idx++;</a>
<a name="ln5906">      } else {</a>
<a name="ln5907">        startcol = (colnr_T)(regmatch.startp[0]</a>
<a name="ln5908">                             + (*mb_ptr2len)(regmatch.startp[0]) - str);</a>
<a name="ln5909">        if (startcol &gt; (colnr_T)len || str + startcol &lt;= regmatch.startp[0]) {</a>
<a name="ln5910">            match = false;</a>
<a name="ln5911">            break;</a>
<a name="ln5912">        }</a>
<a name="ln5913">      }</a>
<a name="ln5914">    }</a>
<a name="ln5915"> </a>
<a name="ln5916">    if (match) {</a>
<a name="ln5917">      switch (type) {</a>
<a name="ln5918">        case kSomeMatchStrPos: {</a>
<a name="ln5919">          list_T *const ret_l = rettv-&gt;vval.v_list;</a>
<a name="ln5920">          listitem_T *li1 = tv_list_first(ret_l);</a>
<a name="ln5921">          listitem_T *li2 = TV_LIST_ITEM_NEXT(ret_l, li1);</a>
<a name="ln5922">          listitem_T *li3 = TV_LIST_ITEM_NEXT(ret_l, li2);</a>
<a name="ln5923">          listitem_T *li4 = TV_LIST_ITEM_NEXT(ret_l, li3);</a>
<a name="ln5924">          xfree(TV_LIST_ITEM_TV(li1)-&gt;vval.v_string);</a>
<a name="ln5925"> </a>
<a name="ln5926">          const size_t rd = (size_t)(regmatch.endp[0] - regmatch.startp[0]);</a>
<a name="ln5927">          TV_LIST_ITEM_TV(li1)-&gt;vval.v_string = xmemdupz(</a>
<a name="ln5928">              (const char *)regmatch.startp[0], rd);</a>
<a name="ln5929">          TV_LIST_ITEM_TV(li3)-&gt;vval.v_number = (varnumber_T)(</a>
<a name="ln5930">              regmatch.startp[0] - expr);</a>
<a name="ln5931">          TV_LIST_ITEM_TV(li4)-&gt;vval.v_number = (varnumber_T)(</a>
<a name="ln5932">              regmatch.endp[0] - expr);</a>
<a name="ln5933">          if (l != NULL) {</a>
<a name="ln5934">            TV_LIST_ITEM_TV(li2)-&gt;vval.v_number = (varnumber_T)idx;</a>
<a name="ln5935">          }</a>
<a name="ln5936">          break;</a>
<a name="ln5937">        }</a>
<a name="ln5938">        case kSomeMatchList: {</a>
<a name="ln5939">          // Return list with matched string and submatches.</a>
<a name="ln5940">          for (int i = 0; i &lt; NSUBEXP; i++) {</a>
<a name="ln5941">            if (regmatch.endp[i] == NULL) {</a>
<a name="ln5942">              tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln5943">            } else {</a>
<a name="ln5944">              tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln5945">                                    (const char *)regmatch.startp[i],</a>
<a name="ln5946">                                    (regmatch.endp[i] - regmatch.startp[i]));</a>
<a name="ln5947">            }</a>
<a name="ln5948">          }</a>
<a name="ln5949">          break;</a>
<a name="ln5950">        }</a>
<a name="ln5951">        case kSomeMatchStr: {</a>
<a name="ln5952">          // Return matched string.</a>
<a name="ln5953">          if (l != NULL) {</a>
<a name="ln5954">            tv_copy(TV_LIST_ITEM_TV(li), rettv);</a>
<a name="ln5955">          } else {</a>
<a name="ln5956">            rettv-&gt;vval.v_string = (char_u *)xmemdupz(</a>
<a name="ln5957">                (const char *)regmatch.startp[0],</a>
<a name="ln5958">                (size_t)(regmatch.endp[0] - regmatch.startp[0]));</a>
<a name="ln5959">          }</a>
<a name="ln5960">          break;</a>
<a name="ln5961">        }</a>
<a name="ln5962">        case kSomeMatch:</a>
<a name="ln5963">        case kSomeMatchEnd: {</a>
<a name="ln5964">          if (l != NULL) {</a>
<a name="ln5965">            rettv-&gt;vval.v_number = idx;</a>
<a name="ln5966">          } else {</a>
<a name="ln5967">            if (type == kSomeMatch) {</a>
<a name="ln5968">              rettv-&gt;vval.v_number =</a>
<a name="ln5969">                (varnumber_T)(regmatch.startp[0] - str);</a>
<a name="ln5970">            } else {</a>
<a name="ln5971">              rettv-&gt;vval.v_number =</a>
<a name="ln5972">                (varnumber_T)(regmatch.endp[0] - str);</a>
<a name="ln5973">            }</a>
<a name="ln5974">            rettv-&gt;vval.v_number += (varnumber_T)(str - expr);</a>
<a name="ln5975">          }</a>
<a name="ln5976">          break;</a>
<a name="ln5977">        }</a>
<a name="ln5978">      }</a>
<a name="ln5979">    }</a>
<a name="ln5980">    vim_regfree(regmatch.regprog);</a>
<a name="ln5981">  }</a>
<a name="ln5982"> </a>
<a name="ln5983">theend:</a>
<a name="ln5984">  if (type == kSomeMatchStrPos &amp;&amp; l == NULL &amp;&amp; rettv-&gt;vval.v_list != NULL) {</a>
<a name="ln5985">    // matchstrpos() without a list: drop the second item</a>
<a name="ln5986">    list_T *const ret_l = rettv-&gt;vval.v_list;</a>
<a name="ln5987">    tv_list_item_remove(ret_l, TV_LIST_ITEM_NEXT(ret_l, tv_list_first(ret_l)));</a>
<a name="ln5988">  }</a>
<a name="ln5989"> </a>
<a name="ln5990">  xfree(tofree);</a>
<a name="ln5991">  p_cpo = save_cpo;</a>
<a name="ln5992">}</a>
<a name="ln5993"> </a>
<a name="ln5994">/*</a>
<a name="ln5995"> * &quot;match()&quot; function</a>
<a name="ln5996"> */</a>
<a name="ln5997">static void f_match(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln5998">{</a>
<a name="ln5999">  find_some_match(argvars, rettv, kSomeMatch);</a>
<a name="ln6000">}</a>
<a name="ln6001"> </a>
<a name="ln6002">/*</a>
<a name="ln6003"> * &quot;matchadd()&quot; function</a>
<a name="ln6004"> */</a>
<a name="ln6005">static void f_matchadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6006">{</a>
<a name="ln6007">  char grpbuf[NUMBUFLEN];</a>
<a name="ln6008">  char patbuf[NUMBUFLEN];</a>
<a name="ln6009">  // group</a>
<a name="ln6010">  const char *const grp = tv_get_string_buf_chk(&amp;argvars[0], grpbuf);</a>
<a name="ln6011">  // pattern</a>
<a name="ln6012">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln6013">  // default priority</a>
<a name="ln6014">  int prio = 10;</a>
<a name="ln6015">  int id = -1;</a>
<a name="ln6016">  bool error = false;</a>
<a name="ln6017">  const char *conceal_char = NULL;</a>
<a name="ln6018">  win_T *win = curwin;</a>
<a name="ln6019"> </a>
<a name="ln6020">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln6021"> </a>
<a name="ln6022">  if (grp == NULL || pat == NULL) {</a>
<a name="ln6023">    return;</a>
<a name="ln6024">  }</a>
<a name="ln6025">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6026">    prio = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln6027">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln6028">      id = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln6029">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln6030">          &amp;&amp; matchadd_dict_arg(&amp;argvars[4], &amp;conceal_char, &amp;win) == FAIL) {</a>
<a name="ln6031">        return;</a>
<a name="ln6032">      }</a>
<a name="ln6033">    }</a>
<a name="ln6034">  }</a>
<a name="ln6035">  if (error) {</a>
<a name="ln6036">    return;</a>
<a name="ln6037">  }</a>
<a name="ln6038">  if (id &gt;= 1 &amp;&amp; id &lt;= 3) {</a>
<a name="ln6039">    EMSGN(_(&quot;E798: ID is reserved for \&quot;:match\&quot;: %&quot; PRId64), id);</a>
<a name="ln6040">    return;</a>
<a name="ln6041">  }</a>
<a name="ln6042"> </a>
<a name="ln6043">  rettv-&gt;vval.v_number = match_add(win, grp, pat, prio, id, NULL, conceal_char);</a>
<a name="ln6044">}</a>
<a name="ln6045"> </a>
<a name="ln6046">static void f_matchaddpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6047">{</a>
<a name="ln6048">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln6049"> </a>
<a name="ln6050">  char buf[NUMBUFLEN];</a>
<a name="ln6051">  const char *const group = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln6052">  if (group == NULL) {</a>
<a name="ln6053">    return;</a>
<a name="ln6054">  }</a>
<a name="ln6055"> </a>
<a name="ln6056">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln6057">    EMSG2(_(e_listarg), &quot;matchaddpos()&quot;);</a>
<a name="ln6058">    return;</a>
<a name="ln6059">  }</a>
<a name="ln6060"> </a>
<a name="ln6061">  list_T *l;</a>
<a name="ln6062">  l = argvars[1].vval.v_list;</a>
<a name="ln6063">  if (l == NULL) {</a>
<a name="ln6064">    return;</a>
<a name="ln6065">  }</a>
<a name="ln6066"> </a>
<a name="ln6067">  bool error = false;</a>
<a name="ln6068">  int prio = 10;</a>
<a name="ln6069">  int id = -1;</a>
<a name="ln6070">  const char *conceal_char = NULL;</a>
<a name="ln6071">  win_T *win = curwin;</a>
<a name="ln6072"> </a>
<a name="ln6073">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6074">    prio = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln6075">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln6076">      id = tv_get_number_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln6077">      if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln6078">          &amp;&amp; matchadd_dict_arg(&amp;argvars[4], &amp;conceal_char, &amp;win) == FAIL) {</a>
<a name="ln6079">        return;</a>
<a name="ln6080">      }</a>
<a name="ln6081">    }</a>
<a name="ln6082">  }</a>
<a name="ln6083">  if (error == true) {</a>
<a name="ln6084">    return;</a>
<a name="ln6085">  }</a>
<a name="ln6086"> </a>
<a name="ln6087">  // id == 3 is ok because matchaddpos() is supposed to substitute :3match</a>
<a name="ln6088">  if (id == 1 || id == 2) {</a>
<a name="ln6089">    EMSGN(_(&quot;E798: ID is reserved for \&quot;match\&quot;: %&quot; PRId64), id);</a>
<a name="ln6090">    return;</a>
<a name="ln6091">  }</a>
<a name="ln6092"> </a>
<a name="ln6093">  rettv-&gt;vval.v_number = match_add(win, group, NULL, prio, id, l, conceal_char);</a>
<a name="ln6094">}</a>
<a name="ln6095"> </a>
<a name="ln6096">/*</a>
<a name="ln6097"> * &quot;matcharg()&quot; function</a>
<a name="ln6098"> */</a>
<a name="ln6099">static void f_matcharg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6100">{</a>
<a name="ln6101">  const int id = tv_get_number(&amp;argvars[0]);</a>
<a name="ln6102"> </a>
<a name="ln6103">  tv_list_alloc_ret(rettv, (id &gt;= 1 &amp;&amp; id &lt;= 3</a>
<a name="ln6104">                            ? 2</a>
<a name="ln6105">                            : 0));</a>
<a name="ln6106"> </a>
<a name="ln6107">  if (id &gt;= 1 &amp;&amp; id &lt;= 3) {</a>
<a name="ln6108">    matchitem_T *const m = (matchitem_T *)get_match(curwin, id);</a>
<a name="ln6109"> </a>
<a name="ln6110">    if (m != NULL) {</a>
<a name="ln6111">      tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln6112">                            (const char *)syn_id2name(m-&gt;hlg_id), -1);</a>
<a name="ln6113">      tv_list_append_string(rettv-&gt;vval.v_list, (const char *)m-&gt;pattern, -1);</a>
<a name="ln6114">    } else {</a>
<a name="ln6115">      tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln6116">      tv_list_append_string(rettv-&gt;vval.v_list, NULL, 0);</a>
<a name="ln6117">    }</a>
<a name="ln6118">  }</a>
<a name="ln6119">}</a>
<a name="ln6120"> </a>
<a name="ln6121">/*</a>
<a name="ln6122"> * &quot;matchdelete()&quot; function</a>
<a name="ln6123"> */</a>
<a name="ln6124">static void f_matchdelete(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6125">{</a>
<a name="ln6126">  win_T   *win = get_optional_window(argvars, 1);</a>
<a name="ln6127">  if (win == NULL) {</a>
<a name="ln6128">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln6129">  } else {</a>
<a name="ln6130">    rettv-&gt;vval.v_number = match_delete(win,</a>
<a name="ln6131">                                        (int)tv_get_number(&amp;argvars[0]), true);</a>
<a name="ln6132">  }</a>
<a name="ln6133">}</a>
<a name="ln6134"> </a>
<a name="ln6135">/*</a>
<a name="ln6136"> * &quot;matchend()&quot; function</a>
<a name="ln6137"> */</a>
<a name="ln6138">static void f_matchend(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6139">{</a>
<a name="ln6140">  find_some_match(argvars, rettv, kSomeMatchEnd);</a>
<a name="ln6141">}</a>
<a name="ln6142"> </a>
<a name="ln6143">/*</a>
<a name="ln6144"> * &quot;matchlist()&quot; function</a>
<a name="ln6145"> */</a>
<a name="ln6146">static void f_matchlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6147">{</a>
<a name="ln6148">  find_some_match(argvars, rettv, kSomeMatchList);</a>
<a name="ln6149">}</a>
<a name="ln6150"> </a>
<a name="ln6151">/*</a>
<a name="ln6152"> * &quot;matchstr()&quot; function</a>
<a name="ln6153"> */</a>
<a name="ln6154">static void f_matchstr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6155">{</a>
<a name="ln6156">  find_some_match(argvars, rettv, kSomeMatchStr);</a>
<a name="ln6157">}</a>
<a name="ln6158"> </a>
<a name="ln6159">/// &quot;matchstrpos()&quot; function</a>
<a name="ln6160">static void f_matchstrpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6161">{</a>
<a name="ln6162">  find_some_match(argvars, rettv, kSomeMatchStrPos);</a>
<a name="ln6163">}</a>
<a name="ln6164"> </a>
<a name="ln6165">/// Get maximal/minimal number value in a list or dictionary</a>
<a name="ln6166">///</a>
<a name="ln6167">/// @param[in]  tv  List or dictionary to work with. If it contains something</a>
<a name="ln6168">///                 that is not an integer number (or cannot be coerced to</a>
<a name="ln6169">///                 it) error is given.</a>
<a name="ln6170">/// @param[out]  rettv  Location where result will be saved. Only assigns</a>
<a name="ln6171">///                     vval.v_number, type is not touched. Returns zero for</a>
<a name="ln6172">///                     empty lists/dictionaries.</a>
<a name="ln6173">/// @param[in]  domax  Determines whether maximal or minimal value is desired.</a>
<a name="ln6174">static void max_min(const typval_T *const tv, typval_T *const rettv,</a>
<a name="ln6175">                    const bool domax)</a>
<a name="ln6176">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6177">{</a>
<a name="ln6178">  bool error = false;</a>
<a name="ln6179"> </a>
<a name="ln6180">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln6181">  varnumber_T n = (domax ? VARNUMBER_MIN : VARNUMBER_MAX);</a>
<a name="ln6182">  if (tv-&gt;v_type == VAR_LIST) {</a>
<a name="ln6183">    if (tv_list_len(tv-&gt;vval.v_list) == 0) {</a>
<a name="ln6184">      return;</a>
<a name="ln6185">    }</a>
<a name="ln6186">    TV_LIST_ITER_CONST(tv-&gt;vval.v_list, li, {</a>
<a name="ln6187">      const varnumber_T i = tv_get_number_chk(TV_LIST_ITEM_TV(li), &amp;error);</a>
<a name="ln6188">      if (error) {</a>
<a name="ln6189">        return;</a>
<a name="ln6190">      }</a>
<a name="ln6191">      if (domax ? i &gt; n : i &lt; n) {</a>
<a name="ln6192">        n = i;</a>
<a name="ln6193">      }</a>
<a name="ln6194">    });</a>
<a name="ln6195">  } else if (tv-&gt;v_type == VAR_DICT) {</a>
<a name="ln6196">    if (tv_dict_len(tv-&gt;vval.v_dict) == 0) {</a>
<a name="ln6197">      return;</a>
<a name="ln6198">    }</a>
<a name="ln6199">    TV_DICT_ITER(tv-&gt;vval.v_dict, di, {</a>
<a name="ln6200">      const varnumber_T i = tv_get_number_chk(&amp;di-&gt;di_tv, &amp;error);</a>
<a name="ln6201">      if (error) {</a>
<a name="ln6202">        return;</a>
<a name="ln6203">      }</a>
<a name="ln6204">      if (domax ? i &gt; n : i &lt; n) {</a>
<a name="ln6205">        n = i;</a>
<a name="ln6206">      }</a>
<a name="ln6207">    });</a>
<a name="ln6208">  } else {</a>
<a name="ln6209">    EMSG2(_(e_listdictarg), domax ? &quot;max()&quot; : &quot;min()&quot;);</a>
<a name="ln6210">    return;</a>
<a name="ln6211">  }</a>
<a name="ln6212">  rettv-&gt;vval.v_number = n;</a>
<a name="ln6213">}</a>
<a name="ln6214"> </a>
<a name="ln6215">/*</a>
<a name="ln6216"> * &quot;max()&quot; function</a>
<a name="ln6217"> */</a>
<a name="ln6218">static void f_max(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6219">{</a>
<a name="ln6220">  max_min(argvars, rettv, TRUE);</a>
<a name="ln6221">}</a>
<a name="ln6222"> </a>
<a name="ln6223">/*</a>
<a name="ln6224"> * &quot;min()&quot; function</a>
<a name="ln6225"> */</a>
<a name="ln6226">static void f_min(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6227">{</a>
<a name="ln6228">  max_min(argvars, rettv, FALSE);</a>
<a name="ln6229">}</a>
<a name="ln6230"> </a>
<a name="ln6231">/*</a>
<a name="ln6232"> * &quot;mkdir()&quot; function</a>
<a name="ln6233"> */</a>
<a name="ln6234">static void f_mkdir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6235">{</a>
<a name="ln6236">  int prot = 0755;  // -V536</a>
<a name="ln6237"> </a>
<a name="ln6238">  rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln6239">  if (check_secure()) {</a>
<a name="ln6240">    return;</a>
<a name="ln6241">  }</a>
<a name="ln6242"> </a>
<a name="ln6243">  char buf[NUMBUFLEN];</a>
<a name="ln6244">  const char *const dir = tv_get_string_buf(&amp;argvars[0], buf);</a>
<a name="ln6245">  if (*dir == NUL) {</a>
<a name="ln6246">    return;</a>
<a name="ln6247">  }</a>
<a name="ln6248"> </a>
<a name="ln6249">  if (*path_tail((char_u *)dir) == NUL) {</a>
<a name="ln6250">    // Remove trailing slashes.</a>
<a name="ln6251">    *path_tail_with_sep((char_u *)dir) = NUL;</a>
<a name="ln6252">  }</a>
<a name="ln6253"> </a>
<a name="ln6254">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6255">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6256">      prot = tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln6257">      if (prot == -1) {</a>
<a name="ln6258">        return;</a>
<a name="ln6259">      }</a>
<a name="ln6260">    }</a>
<a name="ln6261">    if (strcmp(tv_get_string(&amp;argvars[1]), &quot;p&quot;) == 0) {</a>
<a name="ln6262">      char *failed_dir;</a>
<a name="ln6263">      int ret = os_mkdir_recurse(dir, prot, &amp;failed_dir);</a>
<a name="ln6264">      if (ret != 0) {</a>
<a name="ln6265">        EMSG3(_(e_mkdir), failed_dir, os_strerror(ret));</a>
<a name="ln6266">        xfree(failed_dir);</a>
<a name="ln6267">        rettv-&gt;vval.v_number = FAIL;</a>
<a name="ln6268">        return;</a>
<a name="ln6269">      } else {</a>
<a name="ln6270">        rettv-&gt;vval.v_number = OK;</a>
<a name="ln6271">        return;</a>
<a name="ln6272">      }</a>
<a name="ln6273">    }</a>
<a name="ln6274">  }</a>
<a name="ln6275">  rettv-&gt;vval.v_number = vim_mkdir_emsg(dir, prot);</a>
<a name="ln6276">}</a>
<a name="ln6277"> </a>
<a name="ln6278">/// &quot;mode()&quot; function</a>
<a name="ln6279">static void f_mode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6280">{</a>
<a name="ln6281">  char *mode = get_mode();</a>
<a name="ln6282"> </a>
<a name="ln6283">  // Clear out the minor mode when the argument is not a non-zero number or</a>
<a name="ln6284">  // non-empty string.</a>
<a name="ln6285">  if (!non_zero_arg(&amp;argvars[0])) {</a>
<a name="ln6286">    mode[1] = NUL;</a>
<a name="ln6287">  }</a>
<a name="ln6288"> </a>
<a name="ln6289">  rettv-&gt;vval.v_string = (char_u *)mode;</a>
<a name="ln6290">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6291">}</a>
<a name="ln6292"> </a>
<a name="ln6293">/// &quot;msgpackdump()&quot; function</a>
<a name="ln6294">static void f_msgpackdump(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6295">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6296">{</a>
<a name="ln6297">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln6298">    EMSG2(_(e_listarg), &quot;msgpackdump()&quot;);</a>
<a name="ln6299">    return;</a>
<a name="ln6300">  }</a>
<a name="ln6301">  list_T *const ret_list = tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln6302">  list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln6303">  msgpack_packer *lpacker = msgpack_packer_new(ret_list, &amp;encode_list_write);</a>
<a name="ln6304">  const char *const msg = _(&quot;msgpackdump() argument, index %i&quot;);</a>
<a name="ln6305">  // Assume that translation will not take more then 4 times more space</a>
<a name="ln6306">  char msgbuf[sizeof(&quot;msgpackdump() argument, index &quot;) * 4 + NUMBUFLEN];</a>
<a name="ln6307">  int idx = 0;</a>
<a name="ln6308">  TV_LIST_ITER(list, li, {</a>
<a name="ln6309">    vim_snprintf(msgbuf, sizeof(msgbuf), (char *)msg, idx);</a>
<a name="ln6310">    idx++;</a>
<a name="ln6311">    if (encode_vim_to_msgpack(lpacker, TV_LIST_ITEM_TV(li), msgbuf) == FAIL) {</a>
<a name="ln6312">      break;</a>
<a name="ln6313">    }</a>
<a name="ln6314">  });</a>
<a name="ln6315">  msgpack_packer_free(lpacker);</a>
<a name="ln6316">}</a>
<a name="ln6317"> </a>
<a name="ln6318">/// &quot;msgpackparse&quot; function</a>
<a name="ln6319">static void f_msgpackparse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6320">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6321">{</a>
<a name="ln6322">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln6323">    EMSG2(_(e_listarg), &quot;msgpackparse()&quot;);</a>
<a name="ln6324">    return;</a>
<a name="ln6325">  }</a>
<a name="ln6326">  list_T *const ret_list = tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln6327">  const list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln6328">  if (tv_list_len(list) == 0) {</a>
<a name="ln6329">    return;</a>
<a name="ln6330">  }</a>
<a name="ln6331">  if (TV_LIST_ITEM_TV(tv_list_first(list))-&gt;v_type != VAR_STRING) {</a>
<a name="ln6332">    EMSG2(_(e_invarg2), &quot;List item is not a string&quot;);</a>
<a name="ln6333">    return;</a>
<a name="ln6334">  }</a>
<a name="ln6335">  ListReaderState lrstate = encode_init_lrstate(list);</a>
<a name="ln6336">  msgpack_unpacker *const unpacker = msgpack_unpacker_new(IOSIZE);</a>
<a name="ln6337">  if (unpacker == NULL) {</a>
<a name="ln6338">    EMSG(_(e_outofmem));</a>
<a name="ln6339">    return;</a>
<a name="ln6340">  }</a>
<a name="ln6341">  msgpack_unpacked unpacked;</a>
<a name="ln6342">  msgpack_unpacked_init(&amp;unpacked);</a>
<a name="ln6343">  do {</a>
<a name="ln6344">    if (!msgpack_unpacker_reserve_buffer(unpacker, IOSIZE)) {</a>
<a name="ln6345">      EMSG(_(e_outofmem));</a>
<a name="ln6346">      goto f_msgpackparse_exit;</a>
<a name="ln6347">    }</a>
<a name="ln6348">    size_t read_bytes;</a>
<a name="ln6349">    const int rlret = encode_read_from_list(</a>
<a name="ln6350">        &amp;lrstate, msgpack_unpacker_buffer(unpacker), IOSIZE, &amp;read_bytes);</a>
<a name="ln6351">    if (rlret == FAIL) {</a>
<a name="ln6352">      EMSG2(_(e_invarg2), &quot;List item is not a string&quot;);</a>
<a name="ln6353">      goto f_msgpackparse_exit;</a>
<a name="ln6354">    }</a>
<a name="ln6355">    msgpack_unpacker_buffer_consumed(unpacker, read_bytes);</a>
<a name="ln6356">    if (read_bytes == 0) {</a>
<a name="ln6357">      break;</a>
<a name="ln6358">    }</a>
<a name="ln6359">    while (unpacker-&gt;off &lt; unpacker-&gt;used) {</a>
<a name="ln6360">      const msgpack_unpack_return result = msgpack_unpacker_next(unpacker,</a>
<a name="ln6361">                                                                 &amp;unpacked);</a>
<a name="ln6362">      if (result == MSGPACK_UNPACK_PARSE_ERROR) {</a>
<a name="ln6363">        EMSG2(_(e_invarg2), &quot;Failed to parse msgpack string&quot;);</a>
<a name="ln6364">        goto f_msgpackparse_exit;</a>
<a name="ln6365">      }</a>
<a name="ln6366">      if (result == MSGPACK_UNPACK_NOMEM_ERROR) {</a>
<a name="ln6367">        EMSG(_(e_outofmem));</a>
<a name="ln6368">        goto f_msgpackparse_exit;</a>
<a name="ln6369">      }</a>
<a name="ln6370">      if (result == MSGPACK_UNPACK_SUCCESS) {</a>
<a name="ln6371">        typval_T tv = { .v_type = VAR_UNKNOWN };</a>
<a name="ln6372">        if (msgpack_to_vim(unpacked.data, &amp;tv) == FAIL) {</a>
<a name="ln6373">          EMSG2(_(e_invarg2), &quot;Failed to convert msgpack string&quot;);</a>
<a name="ln6374">          goto f_msgpackparse_exit;</a>
<a name="ln6375">        }</a>
<a name="ln6376">        tv_list_append_owned_tv(ret_list, tv);</a>
<a name="ln6377">      }</a>
<a name="ln6378">      if (result == MSGPACK_UNPACK_CONTINUE) {</a>
<a name="ln6379">        if (rlret == OK) {</a>
<a name="ln6380">          EMSG2(_(e_invarg2), &quot;Incomplete msgpack string&quot;);</a>
<a name="ln6381">        }</a>
<a name="ln6382">        break;</a>
<a name="ln6383">      }</a>
<a name="ln6384">    }</a>
<a name="ln6385">    if (rlret == OK) {</a>
<a name="ln6386">      break;</a>
<a name="ln6387">    }</a>
<a name="ln6388">  } while (true);</a>
<a name="ln6389"> </a>
<a name="ln6390">f_msgpackparse_exit:</a>
<a name="ln6391">  msgpack_unpacked_destroy(&amp;unpacked);</a>
<a name="ln6392">  msgpack_unpacker_free(unpacker);</a>
<a name="ln6393">  return;</a>
<a name="ln6394">}</a>
<a name="ln6395"> </a>
<a name="ln6396">/*</a>
<a name="ln6397"> * &quot;nextnonblank()&quot; function</a>
<a name="ln6398"> */</a>
<a name="ln6399">static void f_nextnonblank(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6400">{</a>
<a name="ln6401">  linenr_T lnum;</a>
<a name="ln6402"> </a>
<a name="ln6403">  for (lnum = tv_get_lnum(argvars);; lnum++) {</a>
<a name="ln6404">    if (lnum &lt; 0 || lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6405">      lnum = 0;</a>
<a name="ln6406">      break;</a>
<a name="ln6407">    }</a>
<a name="ln6408">    if (*skipwhite(ml_get(lnum)) != NUL) {</a>
<a name="ln6409">      break;</a>
<a name="ln6410">    }</a>
<a name="ln6411">  }</a>
<a name="ln6412">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln6413">}</a>
<a name="ln6414"> </a>
<a name="ln6415">/*</a>
<a name="ln6416"> * &quot;nr2char()&quot; function</a>
<a name="ln6417"> */</a>
<a name="ln6418">static void f_nr2char(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6419">{</a>
<a name="ln6420">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6421">    if (!tv_check_num(&amp;argvars[1])) {</a>
<a name="ln6422">      return;</a>
<a name="ln6423">    }</a>
<a name="ln6424">  }</a>
<a name="ln6425"> </a>
<a name="ln6426">  bool error = false;</a>
<a name="ln6427">  const varnumber_T num = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln6428">  if (error) {</a>
<a name="ln6429">    return;</a>
<a name="ln6430">  }</a>
<a name="ln6431">  if (num &lt; 0) {</a>
<a name="ln6432">    EMSG(_(&quot;E5070: Character number must not be less than zero&quot;));</a>
<a name="ln6433">    return;</a>
<a name="ln6434">  }</a>
<a name="ln6435">  if (num &gt; INT_MAX) {</a>
<a name="ln6436">    emsgf(_(&quot;E5071: Character number must not be greater than INT_MAX (%i)&quot;),</a>
<a name="ln6437">          INT_MAX);</a>
<a name="ln6438">    return;</a>
<a name="ln6439">  }</a>
<a name="ln6440"> </a>
<a name="ln6441">  char buf[MB_MAXBYTES];</a>
<a name="ln6442">  const int len = utf_char2bytes((int)num, (char_u *)buf);</a>
<a name="ln6443"> </a>
<a name="ln6444">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6445">  rettv-&gt;vval.v_string = xmemdupz(buf, (size_t)len);</a>
<a name="ln6446">}</a>
<a name="ln6447"> </a>
<a name="ln6448">/*</a>
<a name="ln6449"> * &quot;or(expr, expr)&quot; function</a>
<a name="ln6450"> */</a>
<a name="ln6451">static void f_or(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6452">{</a>
<a name="ln6453">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln6454">                         | tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln6455">}</a>
<a name="ln6456"> </a>
<a name="ln6457">/*</a>
<a name="ln6458"> * &quot;pathshorten()&quot; function</a>
<a name="ln6459"> */</a>
<a name="ln6460">static void f_pathshorten(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6461">{</a>
<a name="ln6462">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6463">  const char *const s = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln6464">  if (!s) {</a>
<a name="ln6465">    return;</a>
<a name="ln6466">  }</a>
<a name="ln6467">  rettv-&gt;vval.v_string = shorten_dir((char_u *)xstrdup(s));</a>
<a name="ln6468">}</a>
<a name="ln6469"> </a>
<a name="ln6470">/*</a>
<a name="ln6471"> * &quot;pow()&quot; function</a>
<a name="ln6472"> */</a>
<a name="ln6473">static void f_pow(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6474">{</a>
<a name="ln6475">  float_T fx;</a>
<a name="ln6476">  float_T fy;</a>
<a name="ln6477"> </a>
<a name="ln6478">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln6479">  if (tv_get_float_chk(argvars, &amp;fx) &amp;&amp; tv_get_float_chk(&amp;argvars[1], &amp;fy)) {</a>
<a name="ln6480">    rettv-&gt;vval.v_float = pow(fx, fy);</a>
<a name="ln6481">  } else {</a>
<a name="ln6482">    rettv-&gt;vval.v_float = 0.0;</a>
<a name="ln6483">  }</a>
<a name="ln6484">}</a>
<a name="ln6485"> </a>
<a name="ln6486">/*</a>
<a name="ln6487"> * &quot;prevnonblank()&quot; function</a>
<a name="ln6488"> */</a>
<a name="ln6489">static void f_prevnonblank(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6490">{</a>
<a name="ln6491">  linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln6492">  if (lnum &lt; 1 || lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6493">    lnum = 0;</a>
<a name="ln6494">  } else {</a>
<a name="ln6495">    while (lnum &gt;= 1 &amp;&amp; *skipwhite(ml_get(lnum)) == NUL) {</a>
<a name="ln6496">      lnum--;</a>
<a name="ln6497">    }</a>
<a name="ln6498">  }</a>
<a name="ln6499">  rettv-&gt;vval.v_number = lnum;</a>
<a name="ln6500">}</a>
<a name="ln6501"> </a>
<a name="ln6502">/*</a>
<a name="ln6503"> * &quot;printf()&quot; function</a>
<a name="ln6504"> */</a>
<a name="ln6505">static void f_printf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6506">{</a>
<a name="ln6507">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6508">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6509">  {</a>
<a name="ln6510">    int len;</a>
<a name="ln6511">    int saved_did_emsg = did_emsg;</a>
<a name="ln6512"> </a>
<a name="ln6513">    // Get the required length, allocate the buffer and do it for real.</a>
<a name="ln6514">    did_emsg = false;</a>
<a name="ln6515">    char buf[NUMBUFLEN];</a>
<a name="ln6516">    const char *fmt = tv_get_string_buf(&amp;argvars[0], buf);</a>
<a name="ln6517">    len = vim_vsnprintf_typval(NULL, 0, fmt, dummy_ap, argvars + 1);</a>
<a name="ln6518">    if (!did_emsg) {</a>
<a name="ln6519">      char *s = xmalloc(len + 1);</a>
<a name="ln6520">      rettv-&gt;vval.v_string = (char_u *)s;</a>
<a name="ln6521">      (void)vim_vsnprintf_typval(s, len + 1, fmt, dummy_ap, argvars + 1);</a>
<a name="ln6522">    }</a>
<a name="ln6523">    did_emsg |= saved_did_emsg;</a>
<a name="ln6524">  }</a>
<a name="ln6525">}</a>
<a name="ln6526"> </a>
<a name="ln6527">// &quot;prompt_setcallback({buffer}, {callback})&quot; function</a>
<a name="ln6528">static void f_prompt_setcallback(typval_T *argvars,</a>
<a name="ln6529">                                 typval_T *rettv, FunPtr fptr)</a>
<a name="ln6530">{</a>
<a name="ln6531">    buf_T *buf;</a>
<a name="ln6532">    Callback prompt_callback = { .type = kCallbackNone };</a>
<a name="ln6533"> </a>
<a name="ln6534">    if (check_secure()) {</a>
<a name="ln6535">      return;</a>
<a name="ln6536">    }</a>
<a name="ln6537">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6538">    if (buf == NULL) {</a>
<a name="ln6539">      return;</a>
<a name="ln6540">    }</a>
<a name="ln6541"> </a>
<a name="ln6542">    if (argvars[1].v_type != VAR_STRING || *argvars[1].vval.v_string != NUL) {</a>
<a name="ln6543">      if (!callback_from_typval(&amp;prompt_callback, &amp;argvars[1])) {</a>
<a name="ln6544">        return;</a>
<a name="ln6545">      }</a>
<a name="ln6546">    }</a>
<a name="ln6547"> </a>
<a name="ln6548">    callback_free(&amp;buf-&gt;b_prompt_callback);</a>
<a name="ln6549">    buf-&gt;b_prompt_callback = prompt_callback;</a>
<a name="ln6550">}</a>
<a name="ln6551"> </a>
<a name="ln6552">// &quot;prompt_setinterrupt({buffer}, {callback})&quot; function</a>
<a name="ln6553">static void f_prompt_setinterrupt(typval_T *argvars,</a>
<a name="ln6554">                                  typval_T *rettv, FunPtr fptr)</a>
<a name="ln6555">{</a>
<a name="ln6556">    buf_T *buf;</a>
<a name="ln6557">    Callback interrupt_callback = { .type = kCallbackNone };</a>
<a name="ln6558"> </a>
<a name="ln6559">    if (check_secure()) {</a>
<a name="ln6560">      return;</a>
<a name="ln6561">    }</a>
<a name="ln6562">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6563">    if (buf == NULL) {</a>
<a name="ln6564">      return;</a>
<a name="ln6565">    }</a>
<a name="ln6566"> </a>
<a name="ln6567">    if (argvars[1].v_type != VAR_STRING || *argvars[1].vval.v_string != NUL) {</a>
<a name="ln6568">      if (!callback_from_typval(&amp;interrupt_callback, &amp;argvars[1])) {</a>
<a name="ln6569">        return;</a>
<a name="ln6570">      }</a>
<a name="ln6571">    }</a>
<a name="ln6572"> </a>
<a name="ln6573">    callback_free(&amp;buf-&gt;b_prompt_interrupt);</a>
<a name="ln6574">    buf-&gt;b_prompt_interrupt= interrupt_callback;</a>
<a name="ln6575">}</a>
<a name="ln6576"> </a>
<a name="ln6577">/// &quot;prompt_getprompt({buffer})&quot; function</a>
<a name="ln6578">void f_prompt_getprompt(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6579">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6580">{</a>
<a name="ln6581">  // return an empty string by default, e.g. it's not a prompt buffer</a>
<a name="ln6582">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6583">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6584"> </a>
<a name="ln6585">  buf_T *const buf = tv_get_buf_from_arg(&amp;argvars[0]);</a>
<a name="ln6586">  if (buf == NULL) {</a>
<a name="ln6587">    return;</a>
<a name="ln6588">  }</a>
<a name="ln6589"> </a>
<a name="ln6590">  if (!bt_prompt(buf)) {</a>
<a name="ln6591">    return;</a>
<a name="ln6592">  }</a>
<a name="ln6593"> </a>
<a name="ln6594">  rettv-&gt;vval.v_string = vim_strsave(buf_prompt_text(buf));</a>
<a name="ln6595">}</a>
<a name="ln6596"> </a>
<a name="ln6597">// &quot;prompt_setprompt({buffer}, {text})&quot; function</a>
<a name="ln6598">static void f_prompt_setprompt(typval_T *argvars,</a>
<a name="ln6599">                               typval_T *rettv, FunPtr fptr)</a>
<a name="ln6600">{</a>
<a name="ln6601">    buf_T *buf;</a>
<a name="ln6602">    const char_u *text;</a>
<a name="ln6603"> </a>
<a name="ln6604">    if (check_secure()) {</a>
<a name="ln6605">      return;</a>
<a name="ln6606">    }</a>
<a name="ln6607">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln6608">    if (buf == NULL) {</a>
<a name="ln6609">      return;</a>
<a name="ln6610">    }</a>
<a name="ln6611"> </a>
<a name="ln6612">    text = (const char_u *)tv_get_string(&amp;argvars[1]);</a>
<a name="ln6613">    xfree(buf-&gt;b_prompt_text);</a>
<a name="ln6614">    buf-&gt;b_prompt_text = vim_strsave(text);</a>
<a name="ln6615">}</a>
<a name="ln6616"> </a>
<a name="ln6617">// &quot;pum_getpos()&quot; function</a>
<a name="ln6618">static void f_pum_getpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6619">{</a>
<a name="ln6620">  tv_dict_alloc_ret(rettv);</a>
<a name="ln6621">  pum_set_event_info(rettv-&gt;vval.v_dict);</a>
<a name="ln6622">}</a>
<a name="ln6623"> </a>
<a name="ln6624">/*</a>
<a name="ln6625"> * &quot;pumvisible()&quot; function</a>
<a name="ln6626"> */</a>
<a name="ln6627">static void f_pumvisible(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6628">{</a>
<a name="ln6629">  if (pum_visible())</a>
<a name="ln6630">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln6631">}</a>
<a name="ln6632"> </a>
<a name="ln6633">/*</a>
<a name="ln6634"> * &quot;pyeval()&quot; function</a>
<a name="ln6635"> */</a>
<a name="ln6636">static void f_pyeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6637">{</a>
<a name="ln6638">  script_host_eval(&quot;python&quot;, argvars, rettv);</a>
<a name="ln6639">}</a>
<a name="ln6640"> </a>
<a name="ln6641">/*</a>
<a name="ln6642"> * &quot;py3eval()&quot; function</a>
<a name="ln6643"> */</a>
<a name="ln6644">static void f_py3eval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6645">{</a>
<a name="ln6646">  script_host_eval(&quot;python3&quot;, argvars, rettv);</a>
<a name="ln6647">}</a>
<a name="ln6648"> </a>
<a name="ln6649">// &quot;pyxeval()&quot; function</a>
<a name="ln6650">static void f_pyxeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6651">{</a>
<a name="ln6652">  init_pyxversion();</a>
<a name="ln6653">  if (p_pyx == 2) {</a>
<a name="ln6654">    f_pyeval(argvars, rettv, NULL);</a>
<a name="ln6655">  } else {</a>
<a name="ln6656">    f_py3eval(argvars, rettv, NULL);</a>
<a name="ln6657">  }</a>
<a name="ln6658">}</a>
<a name="ln6659"> </a>
<a name="ln6660">///</a>
<a name="ln6661">/// &quot;perleval()&quot; function</a>
<a name="ln6662">///</a>
<a name="ln6663">static void f_perleval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6664">{</a>
<a name="ln6665">  script_host_eval(&quot;perl&quot;, argvars, rettv);</a>
<a name="ln6666">}</a>
<a name="ln6667"> </a>
<a name="ln6668">// &quot;rubyeval()&quot; function</a>
<a name="ln6669">static void f_rubyeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6670">{</a>
<a name="ln6671">  script_host_eval(&quot;ruby&quot;, argvars, rettv);</a>
<a name="ln6672">}</a>
<a name="ln6673"> </a>
<a name="ln6674">/*</a>
<a name="ln6675"> * &quot;range()&quot; function</a>
<a name="ln6676"> */</a>
<a name="ln6677">static void f_range(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6678">{</a>
<a name="ln6679">  varnumber_T start;</a>
<a name="ln6680">  varnumber_T end;</a>
<a name="ln6681">  varnumber_T stride = 1;</a>
<a name="ln6682">  varnumber_T i;</a>
<a name="ln6683">  bool error = false;</a>
<a name="ln6684"> </a>
<a name="ln6685">  start = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln6686">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln6687">    end = start - 1;</a>
<a name="ln6688">    start = 0;</a>
<a name="ln6689">  } else {</a>
<a name="ln6690">    end = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln6691">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6692">      stride = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln6693">    }</a>
<a name="ln6694">  }</a>
<a name="ln6695"> </a>
<a name="ln6696">  if (error) {</a>
<a name="ln6697">    return;  // Type error; errmsg already given.</a>
<a name="ln6698">  }</a>
<a name="ln6699">  if (stride == 0) {</a>
<a name="ln6700">    EMSG(_(&quot;E726: Stride is zero&quot;));</a>
<a name="ln6701">  } else if (stride &gt; 0 ? end + 1 &lt; start : end - 1 &gt; start) {</a>
<a name="ln6702">    EMSG(_(&quot;E727: Start past end&quot;));</a>
<a name="ln6703">  } else {</a>
<a name="ln6704">    tv_list_alloc_ret(rettv, (end - start) / stride);</a>
<a name="ln6705">    for (i = start; stride &gt; 0 ? i &lt;= end : i &gt;= end; i += stride) {</a>
<a name="ln6706">      tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)i);</a>
<a name="ln6707">    }</a>
<a name="ln6708">  }</a>
<a name="ln6709">}</a>
<a name="ln6710"> </a>
<a name="ln6711">// Evaluate &quot;expr&quot; for readdir().</a>
<a name="ln6712">static varnumber_T readdir_checkitem(typval_T *expr, const char *name)</a>
<a name="ln6713">{</a>
<a name="ln6714">  typval_T save_val;</a>
<a name="ln6715">  typval_T rettv;</a>
<a name="ln6716">  typval_T argv[2];</a>
<a name="ln6717">  varnumber_T retval = 0;</a>
<a name="ln6718">  bool error = false;</a>
<a name="ln6719"> </a>
<a name="ln6720">  prepare_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln6721">  set_vim_var_string(VV_VAL, name, -1);</a>
<a name="ln6722">  argv[0].v_type = VAR_STRING;</a>
<a name="ln6723">  argv[0].vval.v_string = (char_u *)name;</a>
<a name="ln6724"> </a>
<a name="ln6725">  if (eval_expr_typval(expr, argv, 1, &amp;rettv) == FAIL) {</a>
<a name="ln6726">    goto theend;</a>
<a name="ln6727">  }</a>
<a name="ln6728"> </a>
<a name="ln6729">  retval = tv_get_number_chk(&amp;rettv, &amp;error);</a>
<a name="ln6730">  if (error) {</a>
<a name="ln6731">    retval = -1;</a>
<a name="ln6732">  }</a>
<a name="ln6733"> </a>
<a name="ln6734">  tv_clear(&amp;rettv);</a>
<a name="ln6735"> </a>
<a name="ln6736">theend:</a>
<a name="ln6737">  set_vim_var_string(VV_VAL, NULL, 0);</a>
<a name="ln6738">  restore_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln6739">  return retval;</a>
<a name="ln6740">}</a>
<a name="ln6741"> </a>
<a name="ln6742">// &quot;readdir()&quot; function</a>
<a name="ln6743">static void f_readdir(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6744">{</a>
<a name="ln6745">  typval_T *expr;</a>
<a name="ln6746">  const char *path;</a>
<a name="ln6747">  garray_T ga;</a>
<a name="ln6748">  Directory dir;</a>
<a name="ln6749"> </a>
<a name="ln6750">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln6751">  path = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6752">  expr = &amp;argvars[1];</a>
<a name="ln6753">  ga_init(&amp;ga, (int)sizeof(char *), 20);</a>
<a name="ln6754"> </a>
<a name="ln6755">  if (!os_scandir(&amp;dir, path)) {</a>
<a name="ln6756">    smsg(_(e_notopen), path);</a>
<a name="ln6757">  } else {</a>
<a name="ln6758">    for (;;) {</a>
<a name="ln6759">      bool ignore;</a>
<a name="ln6760"> </a>
<a name="ln6761">      path = os_scandir_next(&amp;dir);</a>
<a name="ln6762">      if (path == NULL) {</a>
<a name="ln6763">        break;</a>
<a name="ln6764">      }</a>
<a name="ln6765"> </a>
<a name="ln6766">      ignore = (path[0] == '.'</a>
<a name="ln6767">                &amp;&amp; (path[1] == NUL || (path[1] == '.' &amp;&amp; path[2] == NUL)));</a>
<a name="ln6768">      if (!ignore &amp;&amp; expr-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln6769">        varnumber_T r = readdir_checkitem(expr, path);</a>
<a name="ln6770"> </a>
<a name="ln6771">        if (r &lt; 0) {</a>
<a name="ln6772">          break;</a>
<a name="ln6773">        }</a>
<a name="ln6774">        if (r == 0) {</a>
<a name="ln6775">          ignore = true;</a>
<a name="ln6776">        }</a>
<a name="ln6777">      }</a>
<a name="ln6778"> </a>
<a name="ln6779">      if (!ignore) {</a>
<a name="ln6780">        ga_grow(&amp;ga, 1);</a>
<a name="ln6781">        ((char **)ga.ga_data)[ga.ga_len++] = xstrdup(path);</a>
<a name="ln6782">      }</a>
<a name="ln6783">    }</a>
<a name="ln6784"> </a>
<a name="ln6785">    os_closedir(&amp;dir);</a>
<a name="ln6786">  }</a>
<a name="ln6787"> </a>
<a name="ln6788">  if (rettv-&gt;vval.v_list != NULL &amp;&amp; ga.ga_len &gt; 0) {</a>
<a name="ln6789">    sort_strings((char_u **)ga.ga_data, ga.ga_len);</a>
<a name="ln6790">    for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln6791">      path = ((const char **)ga.ga_data)[i];</a>
<a name="ln6792">      tv_list_append_string(rettv-&gt;vval.v_list, path, -1);</a>
<a name="ln6793">    }</a>
<a name="ln6794">  }</a>
<a name="ln6795">  ga_clear_strings(&amp;ga);</a>
<a name="ln6796">}</a>
<a name="ln6797"> </a>
<a name="ln6798">/*</a>
<a name="ln6799"> * &quot;readfile()&quot; function</a>
<a name="ln6800"> */</a>
<a name="ln6801">static void f_readfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6802">{</a>
<a name="ln6803">  bool binary = false;</a>
<a name="ln6804">  FILE        *fd;</a>
<a name="ln6805">  char_u buf[(IOSIZE/256) * 256];       // rounded to avoid odd + 1</a>
<a name="ln6806">  int io_size = sizeof(buf);</a>
<a name="ln6807">  int readlen;                          // size of last fread()</a>
<a name="ln6808">  char_u      *prev    = NULL;          // previously read bytes, if any</a>
<a name="ln6809">  long prevlen  = 0;                    // length of data in prev</a>
<a name="ln6810">  long prevsize = 0;                    // size of prev buffer</a>
<a name="ln6811">  long maxline  = MAXLNUM;</a>
<a name="ln6812"> </a>
<a name="ln6813">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6814">    if (strcmp(tv_get_string(&amp;argvars[1]), &quot;b&quot;) == 0) {</a>
<a name="ln6815">      binary = true;</a>
<a name="ln6816">    }</a>
<a name="ln6817">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6818">      maxline = tv_get_number(&amp;argvars[2]);</a>
<a name="ln6819">    }</a>
<a name="ln6820">  }</a>
<a name="ln6821"> </a>
<a name="ln6822">  list_T *const l = tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln6823"> </a>
<a name="ln6824">  // Always open the file in binary mode, library functions have a mind of</a>
<a name="ln6825">  // their own about CR-LF conversion.</a>
<a name="ln6826">  const char *const fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln6827">  if (*fname == NUL || (fd = os_fopen(fname, READBIN)) == NULL) {</a>
<a name="ln6828">    EMSG2(_(e_notopen), *fname == NUL ? _(&quot;&lt;empty&gt;&quot;) : fname);</a>
<a name="ln6829">    return;</a>
<a name="ln6830">  }</a>
<a name="ln6831"> </a>
<a name="ln6832">  while (maxline &lt; 0 || tv_list_len(l) &lt; maxline) {</a>
<a name="ln6833">    readlen = (int)fread(buf, 1, io_size, fd);</a>
<a name="ln6834"> </a>
<a name="ln6835">    // This for loop processes what was read, but is also entered at end</a>
<a name="ln6836">    // of file so that either:</a>
<a name="ln6837">    // - an incomplete line gets written</a>
<a name="ln6838">    // - a &quot;binary&quot; file gets an empty line at the end if it ends in a</a>
<a name="ln6839">    //   newline.</a>
<a name="ln6840">    char_u *p;  // Position in buf.</a>
<a name="ln6841">    char_u *start;  // Start of current line.</a>
<a name="ln6842">    for (p = buf, start = buf;</a>
<a name="ln6843">         p &lt; buf + readlen || (readlen &lt;= 0 &amp;&amp; (prevlen &gt; 0 || binary));</a>
<a name="ln6844">         p++) {</a>
<a name="ln6845">      if (*p == '\n' || readlen &lt;= 0) {</a>
<a name="ln6846">        char_u      *s  = NULL;</a>
<a name="ln6847">        size_t len = p - start;</a>
<a name="ln6848"> </a>
<a name="ln6849">        // Finished a line.  Remove CRs before NL.</a>
<a name="ln6850">        if (readlen &gt; 0 &amp;&amp; !binary) {</a>
<a name="ln6851">          while (len &gt; 0 &amp;&amp; start[len - 1] == '\r') {</a>
<a name="ln6852">            len--;</a>
<a name="ln6853">          }</a>
<a name="ln6854">          // removal may cross back to the &quot;prev&quot; string</a>
<a name="ln6855">          if (len == 0) {</a>
<a name="ln6856">            while (prevlen &gt; 0 &amp;&amp; prev[prevlen - 1] == '\r') {</a>
<a name="ln6857">              prevlen--;</a>
<a name="ln6858">            }</a>
<a name="ln6859">          }</a>
<a name="ln6860">        }</a>
<a name="ln6861">        if (prevlen == 0) {</a>
<a name="ln6862">          assert(len &lt; INT_MAX);</a>
<a name="ln6863">          s = vim_strnsave(start, len);</a>
<a name="ln6864">        } else {</a>
<a name="ln6865">          /* Change &quot;prev&quot; buffer to be the right size.  This way</a>
<a name="ln6866">           * the bytes are only copied once, and very long lines are</a>
<a name="ln6867">           * allocated only once.  */</a>
<a name="ln6868">          s = xrealloc(prev, prevlen + len + 1);</a>
<a name="ln6869">          memcpy(s + prevlen, start, len);</a>
<a name="ln6870">          s[prevlen + len] = NUL;</a>
<a name="ln6871">          prev = NULL;             // the list will own the string</a>
<a name="ln6872">          prevlen = prevsize = 0;</a>
<a name="ln6873">        }</a>
<a name="ln6874"> </a>
<a name="ln6875">        tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln6876">          .v_type = VAR_STRING,</a>
<a name="ln6877">          .v_lock = VAR_UNLOCKED,</a>
<a name="ln6878">          .vval.v_string = s,</a>
<a name="ln6879">        });</a>
<a name="ln6880"> </a>
<a name="ln6881">        start = p + 1;  // Step over newline.</a>
<a name="ln6882">        if (maxline &lt; 0) {</a>
<a name="ln6883">          if (tv_list_len(l) &gt; -maxline) {</a>
<a name="ln6884">            assert(tv_list_len(l) == 1 + (-maxline));</a>
<a name="ln6885">            tv_list_item_remove(l, tv_list_first(l));</a>
<a name="ln6886">          }</a>
<a name="ln6887">        } else if (tv_list_len(l) &gt;= maxline) {</a>
<a name="ln6888">          assert(tv_list_len(l) == maxline);</a>
<a name="ln6889">          break;</a>
<a name="ln6890">        }</a>
<a name="ln6891">        if (readlen &lt;= 0) {</a>
<a name="ln6892">          break;</a>
<a name="ln6893">        }</a>
<a name="ln6894">      } else if (*p == NUL) {</a>
<a name="ln6895">        *p = '\n';</a>
<a name="ln6896">      // Check for utf8 &quot;bom&quot;; U+FEFF is encoded as EF BB BF.  Do this</a>
<a name="ln6897">      // when finding the BF and check the previous two bytes.</a>
<a name="ln6898">      } else if (*p == 0xbf &amp;&amp; !binary) {</a>
<a name="ln6899">        // Find the two bytes before the 0xbf.  If p is at buf, or buf + 1,</a>
<a name="ln6900">        // these may be in the &quot;prev&quot; string.</a>
<a name="ln6901">        char_u back1 = p &gt;= buf + 1 ? p[-1]</a>
<a name="ln6902">                       : prevlen &gt;= 1 ? prev[prevlen - 1] : NUL;</a>
<a name="ln6903">        char_u back2 = p &gt;= buf + 2 ? p[-2]</a>
<a name="ln6904">                       : p == buf + 1 &amp;&amp; prevlen &gt;= 1 ? prev[prevlen - 1]</a>
<a name="ln6905">                       : prevlen &gt;= 2 ? prev[prevlen - 2] : NUL;</a>
<a name="ln6906"> </a>
<a name="ln6907">        if (back2 == 0xef &amp;&amp; back1 == 0xbb) {</a>
<a name="ln6908">          char_u *dest = p - 2;</a>
<a name="ln6909"> </a>
<a name="ln6910">          // Usually a BOM is at the beginning of a file, and so at</a>
<a name="ln6911">          // the beginning of a line; then we can just step over it.</a>
<a name="ln6912">          if (start == dest) {</a>
<a name="ln6913">            start = p + 1;</a>
<a name="ln6914">          } else {</a>
<a name="ln6915">            // have to shuffle buf to close gap</a>
<a name="ln6916">            int adjust_prevlen = 0;</a>
<a name="ln6917"> </a>
<a name="ln6918">            if (dest &lt; buf) {  // -V782</a>
<a name="ln6919">              adjust_prevlen = (int)(buf - dest);  // -V782</a>
<a name="ln6920">              // adjust_prevlen must be 1 or 2.</a>
<a name="ln6921">              dest = buf;</a>
<a name="ln6922">            }</a>
<a name="ln6923">            if (readlen &gt; p - buf + 1)</a>
<a name="ln6924">              memmove(dest, p + 1, readlen - (p - buf) - 1);</a>
<a name="ln6925">            readlen -= 3 - adjust_prevlen;</a>
<a name="ln6926">            prevlen -= adjust_prevlen;</a>
<a name="ln6927">            p = dest - 1;</a>
<a name="ln6928">          }</a>
<a name="ln6929">        }</a>
<a name="ln6930">      }</a>
<a name="ln6931">    }     // for</a>
<a name="ln6932"> </a>
<a name="ln6933">    if ((maxline &gt;= 0 &amp;&amp; tv_list_len(l) &gt;= maxline) || readlen &lt;= 0) {</a>
<a name="ln6934">      break;</a>
<a name="ln6935">    }</a>
<a name="ln6936">    if (start &lt; p) {</a>
<a name="ln6937">      // There's part of a line in buf, store it in &quot;prev&quot;.</a>
<a name="ln6938">      if (p - start + prevlen &gt;= prevsize) {</a>
<a name="ln6939">        /* A common use case is ordinary text files and &quot;prev&quot; gets a</a>
<a name="ln6940">         * fragment of a line, so the first allocation is made</a>
<a name="ln6941">         * small, to avoid repeatedly 'allocing' large and</a>
<a name="ln6942">         * 'reallocing' small. */</a>
<a name="ln6943">        if (prevsize == 0)</a>
<a name="ln6944">          prevsize = (long)(p - start);</a>
<a name="ln6945">        else {</a>
<a name="ln6946">          long grow50pc = (prevsize * 3) / 2;</a>
<a name="ln6947">          long growmin  = (long)((p - start) * 2 + prevlen);</a>
<a name="ln6948">          prevsize = grow50pc &gt; growmin ? grow50pc : growmin;</a>
<a name="ln6949">        }</a>
<a name="ln6950">        prev = xrealloc(prev, prevsize);</a>
<a name="ln6951">      }</a>
<a name="ln6952">      // Add the line part to end of &quot;prev&quot;.</a>
<a name="ln6953">      memmove(prev + prevlen, start, p - start);</a>
<a name="ln6954">      prevlen += (long)(p - start);</a>
<a name="ln6955">    }</a>
<a name="ln6956">  }   // while</a>
<a name="ln6957"> </a>
<a name="ln6958">  xfree(prev);</a>
<a name="ln6959">  fclose(fd);</a>
<a name="ln6960">}</a>
<a name="ln6961"> </a>
<a name="ln6962">// &quot;reg_executing()&quot; function</a>
<a name="ln6963">static void f_reg_executing(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6964">{</a>
<a name="ln6965">  return_register(reg_executing, rettv);</a>
<a name="ln6966">}</a>
<a name="ln6967"> </a>
<a name="ln6968">// &quot;reg_recording()&quot; function</a>
<a name="ln6969">static void f_reg_recording(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln6970">{</a>
<a name="ln6971">  return_register(reg_recording, rettv);</a>
<a name="ln6972">}</a>
<a name="ln6973"> </a>
<a name="ln6974">/// list2proftime - convert a List to proftime_T</a>
<a name="ln6975">///</a>
<a name="ln6976">/// @param arg The input list, must be of type VAR_LIST and have</a>
<a name="ln6977">///            exactly 2 items</a>
<a name="ln6978">/// @param[out] tm The proftime_T representation of `arg`</a>
<a name="ln6979">/// @return OK In case of success, FAIL in case of error</a>
<a name="ln6980">static int list2proftime(typval_T *arg, proftime_T *tm) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6981">{</a>
<a name="ln6982">  if (arg-&gt;v_type != VAR_LIST || tv_list_len(arg-&gt;vval.v_list) != 2) {</a>
<a name="ln6983">    return FAIL;</a>
<a name="ln6984">  }</a>
<a name="ln6985"> </a>
<a name="ln6986">  bool error = false;</a>
<a name="ln6987">  varnumber_T n1 = tv_list_find_nr(arg-&gt;vval.v_list, 0L, &amp;error);</a>
<a name="ln6988">  varnumber_T n2 = tv_list_find_nr(arg-&gt;vval.v_list, 1L, &amp;error);</a>
<a name="ln6989">  if (error) {</a>
<a name="ln6990">    return FAIL;</a>
<a name="ln6991">  }</a>
<a name="ln6992"> </a>
<a name="ln6993">  // in f_reltime() we split up the 64-bit proftime_T into two 32-bit</a>
<a name="ln6994">  // values, now we combine them again.</a>
<a name="ln6995">  union {</a>
<a name="ln6996">    struct { int32_t low, high; } split;</a>
<a name="ln6997">    proftime_T prof;</a>
<a name="ln6998">  } u = { .split.high = n1, .split.low = n2 };</a>
<a name="ln6999"> </a>
<a name="ln7000">  *tm = u.prof;</a>
<a name="ln7001"> </a>
<a name="ln7002">  return OK;</a>
<a name="ln7003">}</a>
<a name="ln7004"> </a>
<a name="ln7005">/// f_reltime - return an item that represents a time value</a>
<a name="ln7006">///</a>
<a name="ln7007">/// @param[out] rettv Without an argument it returns the current time. With</a>
<a name="ln7008">///             one argument it returns the time passed since the argument.</a>
<a name="ln7009">///             With two arguments it returns the time passed between</a>
<a name="ln7010">///             the two arguments.</a>
<a name="ln7011">static void f_reltime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7012">{</a>
<a name="ln7013">  proftime_T res;</a>
<a name="ln7014">  proftime_T start;</a>
<a name="ln7015"> </a>
<a name="ln7016">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln7017">    // no arguments: get current time.</a>
<a name="ln7018">    res = profile_start();</a>
<a name="ln7019">  } else if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln7020">    if (list2proftime(&amp;argvars[0], &amp;res) == FAIL) {</a>
<a name="ln7021">      return;</a>
<a name="ln7022">    }</a>
<a name="ln7023">    res = profile_end(res);</a>
<a name="ln7024">  } else {</a>
<a name="ln7025">    // two arguments: compute the difference.</a>
<a name="ln7026">    if (list2proftime(&amp;argvars[0], &amp;start) == FAIL</a>
<a name="ln7027">        || list2proftime(&amp;argvars[1], &amp;res) == FAIL) {</a>
<a name="ln7028">      return;</a>
<a name="ln7029">    }</a>
<a name="ln7030">    res = profile_sub(res, start);</a>
<a name="ln7031">  }</a>
<a name="ln7032"> </a>
<a name="ln7033">  // we have to store the 64-bit proftime_T inside of a list of int's</a>
<a name="ln7034">  // (varnumber_T is defined as int). For all our supported platforms, int's</a>
<a name="ln7035">  // are at least 32-bits wide. So we'll use two 32-bit values to store it.</a>
<a name="ln7036">  union {</a>
<a name="ln7037">    struct { int32_t low, high; } split;</a>
<a name="ln7038">    proftime_T prof;</a>
<a name="ln7039">  } u = { .prof = res };</a>
<a name="ln7040"> </a>
<a name="ln7041">  // statically assert that the union type conv will provide the correct</a>
<a name="ln7042">  // results, if varnumber_T or proftime_T change, the union cast will need</a>
<a name="ln7043">  // to be revised.</a>
<a name="ln7044">  STATIC_ASSERT(sizeof(u.prof) == sizeof(u) &amp;&amp; sizeof(u.split) == sizeof(u),</a>
<a name="ln7045">      &quot;type punning will produce incorrect results on this platform&quot;);</a>
<a name="ln7046"> </a>
<a name="ln7047">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln7048">  tv_list_append_number(rettv-&gt;vval.v_list, u.split.high);</a>
<a name="ln7049">  tv_list_append_number(rettv-&gt;vval.v_list, u.split.low);</a>
<a name="ln7050">}</a>
<a name="ln7051"> </a>
<a name="ln7052">/// &quot;reltimestr()&quot; function</a>
<a name="ln7053">static void f_reltimestr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7054">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7055">{</a>
<a name="ln7056">  proftime_T tm;</a>
<a name="ln7057"> </a>
<a name="ln7058">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln7059">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln7060">  if (list2proftime(&amp;argvars[0], &amp;tm) == OK) {</a>
<a name="ln7061">    rettv-&gt;vval.v_string = (char_u *)xstrdup(profile_msg(tm));</a>
<a name="ln7062">  }</a>
<a name="ln7063">}</a>
<a name="ln7064"> </a>
<a name="ln7065">/*</a>
<a name="ln7066"> * &quot;remove()&quot; function</a>
<a name="ln7067"> */</a>
<a name="ln7068">static void f_remove(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7069">{</a>
<a name="ln7070">  list_T      *l;</a>
<a name="ln7071">  listitem_T  *item, *item2;</a>
<a name="ln7072">  listitem_T  *li;</a>
<a name="ln7073">  long idx;</a>
<a name="ln7074">  long end;</a>
<a name="ln7075">  dict_T      *d;</a>
<a name="ln7076">  dictitem_T  *di;</a>
<a name="ln7077">  const char *const arg_errmsg = N_(&quot;remove() argument&quot;);</a>
<a name="ln7078"> </a>
<a name="ln7079">  if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln7080">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln7081">      EMSG2(_(e_toomanyarg), &quot;remove()&quot;);</a>
<a name="ln7082">    } else if ((d = argvars[0].vval.v_dict) != NULL</a>
<a name="ln7083">               &amp;&amp; !var_check_lock(d-&gt;dv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln7084">      const char *key = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln7085">      if (key != NULL) {</a>
<a name="ln7086">        di = tv_dict_find(d, key, -1);</a>
<a name="ln7087">        if (di == NULL) {</a>
<a name="ln7088">          EMSG2(_(e_dictkey), key);</a>
<a name="ln7089">        } else if (!var_check_fixed(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)</a>
<a name="ln7090">                   &amp;&amp; !var_check_ro(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln7091">          *rettv = di-&gt;di_tv;</a>
<a name="ln7092">          di-&gt;di_tv = TV_INITIAL_VALUE;</a>
<a name="ln7093">          tv_dict_item_remove(d, di);</a>
<a name="ln7094">          if (tv_dict_is_watched(d)) {</a>
<a name="ln7095">            tv_dict_watcher_notify(d, key, NULL, rettv);</a>
<a name="ln7096">          }</a>
<a name="ln7097">        }</a>
<a name="ln7098">      }</a>
<a name="ln7099">    }</a>
<a name="ln7100">  } else if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln7101">    EMSG2(_(e_listdictarg), &quot;remove()&quot;);</a>
<a name="ln7102">  } else if (!var_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln7103">                             arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln7104">    bool error = false;</a>
<a name="ln7105"> </a>
<a name="ln7106">    idx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln7107">    if (error) {</a>
<a name="ln7108">      // Type error: do nothing, errmsg already given.</a>
<a name="ln7109">    } else if ((item = tv_list_find(l, idx)) == NULL) {</a>
<a name="ln7110">      EMSGN(_(e_listidx), idx);</a>
<a name="ln7111">    } else {</a>
<a name="ln7112">      if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln7113">        // Remove one item, return its value.</a>
<a name="ln7114">        tv_list_drop_items(l, item, item);</a>
<a name="ln7115">        *rettv = *TV_LIST_ITEM_TV(item);</a>
<a name="ln7116">        xfree(item);</a>
<a name="ln7117">      } else {</a>
<a name="ln7118">        // Remove range of items, return list with values.</a>
<a name="ln7119">        end = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln7120">        if (error) {</a>
<a name="ln7121">          // Type error: do nothing.</a>
<a name="ln7122">        } else if ((item2 = tv_list_find(l, end)) == NULL) {</a>
<a name="ln7123">          EMSGN(_(e_listidx), end);</a>
<a name="ln7124">        } else {</a>
<a name="ln7125">          int cnt = 0;</a>
<a name="ln7126"> </a>
<a name="ln7127">          for (li = item; li != NULL; li = TV_LIST_ITEM_NEXT(l, li)) {</a>
<a name="ln7128">            cnt++;</a>
<a name="ln7129">            if (li == item2) {</a>
<a name="ln7130">              break;</a>
<a name="ln7131">            }</a>
<a name="ln7132">          }</a>
<a name="ln7133">          if (li == NULL) {  // Didn't find &quot;item2&quot; after &quot;item&quot;.</a>
<a name="ln7134">            EMSG(_(e_invrange));</a>
<a name="ln7135">          } else {</a>
<a name="ln7136">            tv_list_move_items(l, item, item2, tv_list_alloc_ret(rettv, cnt),</a>
<a name="ln7137">                               cnt);</a>
<a name="ln7138">          }</a>
<a name="ln7139">        }</a>
<a name="ln7140">      }</a>
<a name="ln7141">    }</a>
<a name="ln7142">  }</a>
<a name="ln7143">}</a>
<a name="ln7144"> </a>
<a name="ln7145">/*</a>
<a name="ln7146"> * &quot;rename({from}, {to})&quot; function</a>
<a name="ln7147"> */</a>
<a name="ln7148">static void f_rename(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7149">{</a>
<a name="ln7150">  if (check_secure()) {</a>
<a name="ln7151">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln7152">  } else {</a>
<a name="ln7153">    char buf[NUMBUFLEN];</a>
<a name="ln7154">    rettv-&gt;vval.v_number = vim_rename(</a>
<a name="ln7155">        (const char_u *)tv_get_string(&amp;argvars[0]),</a>
<a name="ln7156">        (const char_u *)tv_get_string_buf(&amp;argvars[1], buf));</a>
<a name="ln7157">  }</a>
<a name="ln7158">}</a>
<a name="ln7159"> </a>
<a name="ln7160">/*</a>
<a name="ln7161"> * &quot;repeat()&quot; function</a>
<a name="ln7162"> */</a>
<a name="ln7163">static void f_repeat(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7164">{</a>
<a name="ln7165">  varnumber_T n = tv_get_number(&amp;argvars[1]);</a>
<a name="ln7166">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln7167">    tv_list_alloc_ret(rettv, (n &gt; 0) * n * tv_list_len(argvars[0].vval.v_list));</a>
<a name="ln7168">    while (n-- &gt; 0) {</a>
<a name="ln7169">      tv_list_extend(rettv-&gt;vval.v_list, argvars[0].vval.v_list, NULL);</a>
<a name="ln7170">    }</a>
<a name="ln7171">  } else {</a>
<a name="ln7172">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln7173">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln7174">    if (n &lt;= 0) {</a>
<a name="ln7175">      return;</a>
<a name="ln7176">    }</a>
<a name="ln7177"> </a>
<a name="ln7178">    const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln7179"> </a>
<a name="ln7180">    const size_t slen = strlen(p);</a>
<a name="ln7181">    if (slen == 0) {</a>
<a name="ln7182">      return;</a>
<a name="ln7183">    }</a>
<a name="ln7184">    const size_t len = slen * n;</a>
<a name="ln7185">    // Detect overflow.</a>
<a name="ln7186">    if (len / n != slen) {</a>
<a name="ln7187">      return;</a>
<a name="ln7188">    }</a>
<a name="ln7189"> </a>
<a name="ln7190">    char *const r = xmallocz(len);</a>
<a name="ln7191">    for (varnumber_T i = 0; i &lt; n; i++) {</a>
<a name="ln7192">      memmove(r + i * slen, p, slen);</a>
<a name="ln7193">    }</a>
<a name="ln7194"> </a>
<a name="ln7195">    rettv-&gt;vval.v_string = (char_u *)r;</a>
<a name="ln7196">  }</a>
<a name="ln7197">}</a>
<a name="ln7198"> </a>
<a name="ln7199">/*</a>
<a name="ln7200"> * &quot;resolve()&quot; function</a>
<a name="ln7201"> */</a>
<a name="ln7202">static void f_resolve(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7203">{</a>
<a name="ln7204">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln7205">  const char *fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln7206">#ifdef WIN32</a>
<a name="ln7207">  char *v = os_resolve_shortcut(fname);</a>
<a name="ln7208">  if (v == NULL) {</a>
<a name="ln7209">    if (os_is_reparse_point_include(fname)) {</a>
<a name="ln7210">      v = os_realpath(fname, v);</a>
<a name="ln7211">    }</a>
<a name="ln7212">  }</a>
<a name="ln7213">  rettv-&gt;vval.v_string = (char_u *)(v == NULL ? xstrdup(fname) : v);</a>
<a name="ln7214">#else</a>
<a name="ln7215"># ifdef HAVE_READLINK</a>
<a name="ln7216">  {</a>
<a name="ln7217">    bool is_relative_to_current = false;</a>
<a name="ln7218">    bool has_trailing_pathsep = false;</a>
<a name="ln7219">    int limit = 100;</a>
<a name="ln7220"> </a>
<a name="ln7221">    char *p = xstrdup(fname);</a>
<a name="ln7222"> </a>
<a name="ln7223">    if (p[0] == '.' &amp;&amp; (vim_ispathsep(p[1])</a>
<a name="ln7224">                        || (p[1] == '.' &amp;&amp; (vim_ispathsep(p[2]))))) {</a>
<a name="ln7225">      is_relative_to_current = true;</a>
<a name="ln7226">    }</a>
<a name="ln7227"> </a>
<a name="ln7228">    ptrdiff_t len = (ptrdiff_t)strlen(p);</a>
<a name="ln7229">    if (len &gt; 1 &amp;&amp; after_pathsep(p, p + len)) {</a>
<a name="ln7230">      has_trailing_pathsep = true;</a>
<a name="ln7231">      p[len - 1] = NUL;  // The trailing slash breaks readlink().</a>
<a name="ln7232">    }</a>
<a name="ln7233"> </a>
<a name="ln7234">    char *q = (char *)path_next_component(p);</a>
<a name="ln7235">    char *remain = NULL;</a>
<a name="ln7236">    if (*q != NUL) {</a>
<a name="ln7237">      // Separate the first path component in &quot;p&quot;, and keep the</a>
<a name="ln7238">      // remainder (beginning with the path separator).</a>
<a name="ln7239">      remain = xstrdup(q - 1);</a>
<a name="ln7240">      q[-1] = NUL;</a>
<a name="ln7241">    }</a>
<a name="ln7242"> </a>
<a name="ln7243">    char *const buf = xmallocz(MAXPATHL);</a>
<a name="ln7244"> </a>
<a name="ln7245">    char *cpy;</a>
<a name="ln7246">    for (;; ) {</a>
<a name="ln7247">      for (;; ) {</a>
<a name="ln7248">        len = readlink(p, buf, MAXPATHL);</a>
<a name="ln7249">        if (len &lt;= 0) {</a>
<a name="ln7250">          break;</a>
<a name="ln7251">        }</a>
<a name="ln7252">        buf[len] = NUL;</a>
<a name="ln7253"> </a>
<a name="ln7254">        if (limit-- == 0) {</a>
<a name="ln7255">          xfree(p);</a>
<a name="ln7256">          xfree(remain);</a>
<a name="ln7257">          EMSG(_(&quot;E655: Too many symbolic links (cycle?)&quot;));</a>
<a name="ln7258">          rettv-&gt;vval.v_string = NULL;</a>
<a name="ln7259">          xfree(buf);</a>
<a name="ln7260">          return;</a>
<a name="ln7261">        }</a>
<a name="ln7262"> </a>
<a name="ln7263">        // Ensure that the result will have a trailing path separator</a>
<a name="ln7264">        // if the argument has one. */</a>
<a name="ln7265">        if (remain == NULL &amp;&amp; has_trailing_pathsep) {</a>
<a name="ln7266">          add_pathsep(buf);</a>
<a name="ln7267">        }</a>
<a name="ln7268"> </a>
<a name="ln7269">        // Separate the first path component in the link value and</a>
<a name="ln7270">        // concatenate the remainders. */</a>
<a name="ln7271">        q = (char *)path_next_component(vim_ispathsep(*buf) ? buf + 1 : buf);</a>
<a name="ln7272">        if (*q != NUL) {</a>
<a name="ln7273">          cpy = remain;</a>
<a name="ln7274">          remain = (remain</a>
<a name="ln7275">                    ? (char *)concat_str((char_u *)q - 1, (char_u *)remain)</a>
<a name="ln7276">                    : xstrdup(q - 1));</a>
<a name="ln7277">          xfree(cpy);</a>
<a name="ln7278">          q[-1] = NUL;</a>
<a name="ln7279">        }</a>
<a name="ln7280"> </a>
<a name="ln7281">        q = (char *)path_tail((char_u *)p);</a>
<a name="ln7282">        if (q &gt; p &amp;&amp; *q == NUL) {</a>
<a name="ln7283">          // Ignore trailing path separator.</a>
<a name="ln7284">          q[-1] = NUL;</a>
<a name="ln7285">          q = (char *)path_tail((char_u *)p);</a>
<a name="ln7286">        }</a>
<a name="ln7287">        if (q &gt; p &amp;&amp; !path_is_absolute((const char_u *)buf)) {</a>
<a name="ln7288">          // Symlink is relative to directory of argument. Replace the</a>
<a name="ln7289">          // symlink with the resolved name in the same directory.</a>
<a name="ln7290">          const size_t p_len = strlen(p);</a>
<a name="ln7291">          const size_t buf_len = strlen(buf);</a>
<a name="ln7292">          p = xrealloc(p, p_len + buf_len + 1);</a>
<a name="ln7293">          memcpy(path_tail((char_u *)p), buf, buf_len + 1);</a>
<a name="ln7294">        } else {</a>
<a name="ln7295">          xfree(p);</a>
<a name="ln7296">          p = xstrdup(buf);</a>
<a name="ln7297">        }</a>
<a name="ln7298">      }</a>
<a name="ln7299"> </a>
<a name="ln7300">      if (remain == NULL) {</a>
<a name="ln7301">        break;</a>
<a name="ln7302">      }</a>
<a name="ln7303"> </a>
<a name="ln7304">      // Append the first path component of &quot;remain&quot; to &quot;p&quot;.</a>
<a name="ln7305">      q = (char *)path_next_component(remain + 1);</a>
<a name="ln7306">      len = q - remain - (*q != NUL);</a>
<a name="ln7307">      const size_t p_len = strlen(p);</a>
<a name="ln7308">      cpy = xmallocz(p_len + len);</a>
<a name="ln7309">      memcpy(cpy, p, p_len + 1);</a>
<a name="ln7310">      xstrlcat(cpy + p_len, remain, len + 1);</a>
<a name="ln7311">      xfree(p);</a>
<a name="ln7312">      p = cpy;</a>
<a name="ln7313"> </a>
<a name="ln7314">      // Shorten &quot;remain&quot;.</a>
<a name="ln7315">      if (*q != NUL) {</a>
<a name="ln7316">        STRMOVE(remain, q - 1);</a>
<a name="ln7317">      } else {</a>
<a name="ln7318">        XFREE_CLEAR(remain);</a>
<a name="ln7319">      }</a>
<a name="ln7320">    }</a>
<a name="ln7321"> </a>
<a name="ln7322">    // If the result is a relative path name, make it explicitly relative to</a>
<a name="ln7323">    // the current directory if and only if the argument had this form.</a>
<a name="ln7324">    if (!vim_ispathsep(*p)) {</a>
<a name="ln7325">      if (is_relative_to_current</a>
<a name="ln7326">          &amp;&amp; *p != NUL</a>
<a name="ln7327">          &amp;&amp; !(p[0] == '.'</a>
<a name="ln7328">               &amp;&amp; (p[1] == NUL</a>
<a name="ln7329">                   || vim_ispathsep(p[1])</a>
<a name="ln7330">                   || (p[1] == '.'</a>
<a name="ln7331">                       &amp;&amp; (p[2] == NUL</a>
<a name="ln7332">                           || vim_ispathsep(p[2])))))) {</a>
<a name="ln7333">        // Prepend &quot;./&quot;.</a>
<a name="ln7334">        cpy = (char *)concat_str((const char_u *)&quot;./&quot;, (const char_u *)p);</a>
<a name="ln7335">        xfree(p);</a>
<a name="ln7336">        p = cpy;</a>
<a name="ln7337">      } else if (!is_relative_to_current) {</a>
<a name="ln7338">        // Strip leading &quot;./&quot;.</a>
<a name="ln7339">        q = p;</a>
<a name="ln7340">        while (q[0] == '.' &amp;&amp; vim_ispathsep(q[1])) {</a>
<a name="ln7341">          q += 2;</a>
<a name="ln7342">        }</a>
<a name="ln7343">        if (q &gt; p) {</a>
<a name="ln7344">          STRMOVE(p, p + 2);</a>
<a name="ln7345">        }</a>
<a name="ln7346">      }</a>
<a name="ln7347">    }</a>
<a name="ln7348"> </a>
<a name="ln7349">    // Ensure that the result will have no trailing path separator</a>
<a name="ln7350">    // if the argument had none.  But keep &quot;/&quot; or &quot;//&quot;.</a>
<a name="ln7351">    if (!has_trailing_pathsep) {</a>
<a name="ln7352">      q = p + strlen(p);</a>
<a name="ln7353">      if (after_pathsep(p, q)) {</a>
<a name="ln7354">        *path_tail_with_sep((char_u *)p) = NUL;</a>
<a name="ln7355">      }</a>
<a name="ln7356">    }</a>
<a name="ln7357"> </a>
<a name="ln7358">    rettv-&gt;vval.v_string = (char_u *)p;</a>
<a name="ln7359">    xfree(buf);</a>
<a name="ln7360">  }</a>
<a name="ln7361"># else</a>
<a name="ln7362">  char *v = os_realpath(fname, NULL);</a>
<a name="ln7363">  rettv-&gt;vval.v_string = (char_u *)(v == NULL ? xstrdup(fname) : v);</a>
<a name="ln7364"># endif</a>
<a name="ln7365">#endif</a>
<a name="ln7366"> </a>
<a name="ln7367">  simplify_filename(rettv-&gt;vval.v_string);</a>
<a name="ln7368">}</a>
<a name="ln7369"> </a>
<a name="ln7370">/*</a>
<a name="ln7371"> * &quot;reverse({list})&quot; function</a>
<a name="ln7372"> */</a>
<a name="ln7373">static void f_reverse(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7374">{</a>
<a name="ln7375">  list_T *l;</a>
<a name="ln7376">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln7377">    EMSG2(_(e_listarg), &quot;reverse()&quot;);</a>
<a name="ln7378">  } else if (!var_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln7379">                             N_(&quot;reverse() argument&quot;), TV_TRANSLATE)) {</a>
<a name="ln7380">    tv_list_reverse(l);</a>
<a name="ln7381">    tv_list_set_ret(rettv, l);</a>
<a name="ln7382">  }</a>
<a name="ln7383">}</a>
<a name="ln7384"> </a>
<a name="ln7385">#define SP_NOMOVE       0x01        ///&lt; don't move cursor</a>
<a name="ln7386">#define SP_REPEAT       0x02        ///&lt; repeat to find outer pair</a>
<a name="ln7387">#define SP_RETCOUNT     0x04        ///&lt; return matchcount</a>
<a name="ln7388">#define SP_SETPCMARK    0x08        ///&lt; set previous context mark</a>
<a name="ln7389">#define SP_START        0x10        ///&lt; accept match at start position</a>
<a name="ln7390">#define SP_SUBPAT       0x20        ///&lt; return nr of matching sub-pattern</a>
<a name="ln7391">#define SP_END          0x40        ///&lt; leave cursor at end of match</a>
<a name="ln7392">#define SP_COLUMN       0x80        ///&lt; start at cursor column</a>
<a name="ln7393"> </a>
<a name="ln7394">/*</a>
<a name="ln7395"> * Get flags for a search function.</a>
<a name="ln7396"> * Possibly sets &quot;p_ws&quot;.</a>
<a name="ln7397"> * Returns BACKWARD, FORWARD or zero (for an error).</a>
<a name="ln7398"> */</a>
<a name="ln7399">static int get_search_arg(typval_T *varp, int *flagsp)</a>
<a name="ln7400">{</a>
<a name="ln7401">  int dir = FORWARD;</a>
<a name="ln7402">  int mask;</a>
<a name="ln7403"> </a>
<a name="ln7404">  if (varp-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln7405">    char nbuf[NUMBUFLEN];</a>
<a name="ln7406">    const char *flags = tv_get_string_buf_chk(varp, nbuf);</a>
<a name="ln7407">    if (flags == NULL) {</a>
<a name="ln7408">      return 0;  // Type error; errmsg already given.</a>
<a name="ln7409">    }</a>
<a name="ln7410">    while (*flags != NUL) {</a>
<a name="ln7411">      switch (*flags) {</a>
<a name="ln7412">        case 'b': dir = BACKWARD; break;</a>
<a name="ln7413">        case 'w': p_ws = true; break;</a>
<a name="ln7414">        case 'W': p_ws = false; break;</a>
<a name="ln7415">        default: {</a>
<a name="ln7416">          mask = 0;</a>
<a name="ln7417">          if (flagsp != NULL) {</a>
<a name="ln7418">            switch (*flags) {</a>
<a name="ln7419">              case 'c': mask = SP_START; break;</a>
<a name="ln7420">              case 'e': mask = SP_END; break;</a>
<a name="ln7421">              case 'm': mask = SP_RETCOUNT; break;</a>
<a name="ln7422">              case 'n': mask = SP_NOMOVE; break;</a>
<a name="ln7423">              case 'p': mask = SP_SUBPAT; break;</a>
<a name="ln7424">              case 'r': mask = SP_REPEAT; break;</a>
<a name="ln7425">              case 's': mask = SP_SETPCMARK; break;</a>
<a name="ln7426">              case 'z': mask = SP_COLUMN; break;</a>
<a name="ln7427">            }</a>
<a name="ln7428">          }</a>
<a name="ln7429">          if (mask == 0) {</a>
<a name="ln7430">            emsgf(_(e_invarg2), flags);</a>
<a name="ln7431">            dir = 0;</a>
<a name="ln7432">          } else {</a>
<a name="ln7433">            *flagsp |= mask;</a>
<a name="ln7434">          }</a>
<a name="ln7435">        }</a>
<a name="ln7436">      }</a>
<a name="ln7437">      if (dir == 0) {</a>
<a name="ln7438">        break;</a>
<a name="ln7439">      }</a>
<a name="ln7440">      flags++;</a>
<a name="ln7441">    }</a>
<a name="ln7442">  }</a>
<a name="ln7443">  return dir;</a>
<a name="ln7444">}</a>
<a name="ln7445"> </a>
<a name="ln7446">// Shared by search() and searchpos() functions.</a>
<a name="ln7447">static int search_cmn(typval_T *argvars, pos_T *match_pos, int *flagsp)</a>
<a name="ln7448">{</a>
<a name="ln7449">  int flags;</a>
<a name="ln7450">  pos_T pos;</a>
<a name="ln7451">  pos_T save_cursor;</a>
<a name="ln7452">  bool save_p_ws = p_ws;</a>
<a name="ln7453">  int dir;</a>
<a name="ln7454">  int retval = 0;               // default: FAIL</a>
<a name="ln7455">  long lnum_stop = 0;</a>
<a name="ln7456">  proftime_T tm;</a>
<a name="ln7457">  long time_limit = 0;</a>
<a name="ln7458">  int options = SEARCH_KEEP;</a>
<a name="ln7459">  int subpatnum;</a>
<a name="ln7460">  searchit_arg_T sia;</a>
<a name="ln7461"> </a>
<a name="ln7462">  const char *const pat = tv_get_string(&amp;argvars[0]);</a>
<a name="ln7463">  dir = get_search_arg(&amp;argvars[1], flagsp);  // May set p_ws.</a>
<a name="ln7464">  if (dir == 0) {</a>
<a name="ln7465">    goto theend;</a>
<a name="ln7466">  }</a>
<a name="ln7467">  flags = *flagsp;</a>
<a name="ln7468">  if (flags &amp; SP_START) {</a>
<a name="ln7469">    options |= SEARCH_START;</a>
<a name="ln7470">  }</a>
<a name="ln7471">  if (flags &amp; SP_END) {</a>
<a name="ln7472">    options |= SEARCH_END;</a>
<a name="ln7473">  }</a>
<a name="ln7474">  if (flags &amp; SP_COLUMN) {</a>
<a name="ln7475">    options |= SEARCH_COL;</a>
<a name="ln7476">  }</a>
<a name="ln7477"> </a>
<a name="ln7478">  // Optional arguments: line number to stop searching and timeout.</a>
<a name="ln7479">  if (argvars[1].v_type != VAR_UNKNOWN &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln7480">    lnum_stop = tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln7481">    if (lnum_stop &lt; 0) {</a>
<a name="ln7482">      goto theend;</a>
<a name="ln7483">    }</a>
<a name="ln7484">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln7485">      time_limit = tv_get_number_chk(&amp;argvars[3], NULL);</a>
<a name="ln7486">      if (time_limit &lt; 0) {</a>
<a name="ln7487">        goto theend;</a>
<a name="ln7488">      }</a>
<a name="ln7489">    }</a>
<a name="ln7490">  }</a>
<a name="ln7491"> </a>
<a name="ln7492">  // Set the time limit, if there is one.</a>
<a name="ln7493">  tm = profile_setlimit(time_limit);</a>
<a name="ln7494"> </a>
<a name="ln7495">  /*</a>
<a name="ln7496">   * This function does not accept SP_REPEAT and SP_RETCOUNT flags.</a>
<a name="ln7497">   * Check to make sure only those flags are set.</a>
<a name="ln7498">   * Also, Only the SP_NOMOVE or the SP_SETPCMARK flag can be set. Both</a>
<a name="ln7499">   * flags cannot be set. Check for that condition also.</a>
<a name="ln7500">   */</a>
<a name="ln7501">  if (((flags &amp; (SP_REPEAT | SP_RETCOUNT)) != 0)</a>
<a name="ln7502">      || ((flags &amp; SP_NOMOVE) &amp;&amp; (flags &amp; SP_SETPCMARK))) {</a>
<a name="ln7503">    EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[1]));</a>
<a name="ln7504">    goto theend;</a>
<a name="ln7505">  }</a>
<a name="ln7506"> </a>
<a name="ln7507">  pos = save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln7508">  memset(&amp;sia, 0, sizeof(sia));</a>
<a name="ln7509">  sia.sa_stop_lnum = (linenr_T)lnum_stop;</a>
<a name="ln7510">  sia.sa_tm = &amp;tm;</a>
<a name="ln7511">  subpatnum = searchit(curwin, curbuf, &amp;pos, NULL, dir, (char_u *)pat, 1,</a>
<a name="ln7512">                       options, RE_SEARCH, &amp;sia);</a>
<a name="ln7513">  if (subpatnum != FAIL) {</a>
<a name="ln7514">    if (flags &amp; SP_SUBPAT)</a>
<a name="ln7515">      retval = subpatnum;</a>
<a name="ln7516">    else</a>
<a name="ln7517">      retval = pos.lnum;</a>
<a name="ln7518">    if (flags &amp; SP_SETPCMARK)</a>
<a name="ln7519">      setpcmark();</a>
<a name="ln7520">    curwin-&gt;w_cursor = pos;</a>
<a name="ln7521">    if (match_pos != NULL) {</a>
<a name="ln7522">      // Store the match cursor position</a>
<a name="ln7523">      match_pos-&gt;lnum = pos.lnum;</a>
<a name="ln7524">      match_pos-&gt;col = pos.col + 1;</a>
<a name="ln7525">    }</a>
<a name="ln7526">    // &quot;/$&quot; will put the cursor after the end of the line, may need to</a>
<a name="ln7527">    // correct that here</a>
<a name="ln7528">    check_cursor();</a>
<a name="ln7529">  }</a>
<a name="ln7530"> </a>
<a name="ln7531">  // If 'n' flag is used: restore cursor position.</a>
<a name="ln7532">  if (flags &amp; SP_NOMOVE) {</a>
<a name="ln7533">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln7534">  } else {</a>
<a name="ln7535">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln7536">  }</a>
<a name="ln7537">theend:</a>
<a name="ln7538">  p_ws = save_p_ws;</a>
<a name="ln7539"> </a>
<a name="ln7540">  return retval;</a>
<a name="ln7541">}</a>
<a name="ln7542"> </a>
<a name="ln7543">// &quot;rpcnotify()&quot; function</a>
<a name="ln7544">static void f_rpcnotify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7545">{</a>
<a name="ln7546">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7547">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7548"> </a>
<a name="ln7549">  if (check_secure()) {</a>
<a name="ln7550">    return;</a>
<a name="ln7551">  }</a>
<a name="ln7552"> </a>
<a name="ln7553">  if (argvars[0].v_type != VAR_NUMBER || argvars[0].vval.v_number &lt; 0) {</a>
<a name="ln7554">    EMSG2(_(e_invarg2), &quot;Channel id must be a positive integer&quot;);</a>
<a name="ln7555">    return;</a>
<a name="ln7556">  }</a>
<a name="ln7557"> </a>
<a name="ln7558">  if (argvars[1].v_type != VAR_STRING) {</a>
<a name="ln7559">    EMSG2(_(e_invarg2), &quot;Event type must be a string&quot;);</a>
<a name="ln7560">    return;</a>
<a name="ln7561">  }</a>
<a name="ln7562"> </a>
<a name="ln7563">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln7564"> </a>
<a name="ln7565">  for (typval_T *tv = argvars + 2; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln7566">    ADD(args, vim_to_object(tv));</a>
<a name="ln7567">  }</a>
<a name="ln7568"> </a>
<a name="ln7569">  if (!rpc_send_event((uint64_t)argvars[0].vval.v_number,</a>
<a name="ln7570">                      tv_get_string(&amp;argvars[1]), args)) {</a>
<a name="ln7571">    EMSG2(_(e_invarg2), &quot;Channel doesn't exist&quot;);</a>
<a name="ln7572">    return;</a>
<a name="ln7573">  }</a>
<a name="ln7574"> </a>
<a name="ln7575">  rettv-&gt;vval.v_number = 1;</a>
<a name="ln7576">}</a>
<a name="ln7577"> </a>
<a name="ln7578">// &quot;rpcrequest()&quot; function</a>
<a name="ln7579">static void f_rpcrequest(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7580">{</a>
<a name="ln7581">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7582">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7583">  const int l_provider_call_nesting = provider_call_nesting;</a>
<a name="ln7584"> </a>
<a name="ln7585">  if (check_secure()) {</a>
<a name="ln7586">    return;</a>
<a name="ln7587">  }</a>
<a name="ln7588"> </a>
<a name="ln7589">  if (argvars[0].v_type != VAR_NUMBER || argvars[0].vval.v_number &lt;= 0) {</a>
<a name="ln7590">    EMSG2(_(e_invarg2), &quot;Channel id must be a positive integer&quot;);</a>
<a name="ln7591">    return;</a>
<a name="ln7592">  }</a>
<a name="ln7593"> </a>
<a name="ln7594">  if (argvars[1].v_type != VAR_STRING) {</a>
<a name="ln7595">    EMSG2(_(e_invarg2), &quot;Method name must be a string&quot;);</a>
<a name="ln7596">    return;</a>
<a name="ln7597">  }</a>
<a name="ln7598"> </a>
<a name="ln7599">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln7600"> </a>
<a name="ln7601">  for (typval_T *tv = argvars + 2; tv-&gt;v_type != VAR_UNKNOWN; tv++) {</a>
<a name="ln7602">    ADD(args, vim_to_object(tv));</a>
<a name="ln7603">  }</a>
<a name="ln7604"> </a>
<a name="ln7605">  sctx_T save_current_sctx;</a>
<a name="ln7606">  uint8_t *save_sourcing_name, *save_autocmd_fname, *save_autocmd_match;</a>
<a name="ln7607">  linenr_T save_sourcing_lnum;</a>
<a name="ln7608">  int save_autocmd_bufnr;</a>
<a name="ln7609">  funccal_entry_T funccal_entry;</a>
<a name="ln7610"> </a>
<a name="ln7611">  if (l_provider_call_nesting) {</a>
<a name="ln7612">    // If this is called from a provider function, restore the scope</a>
<a name="ln7613">    // information of the caller.</a>
<a name="ln7614">    save_current_sctx = current_sctx;</a>
<a name="ln7615">    save_sourcing_name = sourcing_name;</a>
<a name="ln7616">    save_sourcing_lnum = sourcing_lnum;</a>
<a name="ln7617">    save_autocmd_fname = autocmd_fname;</a>
<a name="ln7618">    save_autocmd_match = autocmd_match;</a>
<a name="ln7619">    save_autocmd_bufnr = autocmd_bufnr;</a>
<a name="ln7620">    save_funccal(&amp;funccal_entry);</a>
<a name="ln7621"> </a>
<a name="ln7622">    current_sctx = provider_caller_scope.script_ctx;</a>
<a name="ln7623">    sourcing_name = provider_caller_scope.sourcing_name;</a>
<a name="ln7624">    sourcing_lnum = provider_caller_scope.sourcing_lnum;</a>
<a name="ln7625">    autocmd_fname = provider_caller_scope.autocmd_fname;</a>
<a name="ln7626">    autocmd_match = provider_caller_scope.autocmd_match;</a>
<a name="ln7627">    autocmd_bufnr = provider_caller_scope.autocmd_bufnr;</a>
<a name="ln7628">    set_current_funccal((funccall_T *)(provider_caller_scope.funccalp));</a>
<a name="ln7629">  }</a>
<a name="ln7630"> </a>
<a name="ln7631"> </a>
<a name="ln7632">  Error err = ERROR_INIT;</a>
<a name="ln7633"> </a>
<a name="ln7634">  uint64_t chan_id = (uint64_t)argvars[0].vval.v_number;</a>
<a name="ln7635">  const char *method = tv_get_string(&amp;argvars[1]);</a>
<a name="ln7636"> </a>
<a name="ln7637">  Object result = rpc_send_call(chan_id, method, args, &amp;err);</a>
<a name="ln7638"> </a>
<a name="ln7639">  if (l_provider_call_nesting) {</a>
<a name="ln7640">    current_sctx = save_current_sctx;</a>
<a name="ln7641">    sourcing_name = save_sourcing_name;</a>
<a name="ln7642">    sourcing_lnum = save_sourcing_lnum;</a>
<a name="ln7643">    autocmd_fname = save_autocmd_fname;</a>
<a name="ln7644">    autocmd_match = save_autocmd_match;</a>
<a name="ln7645">    autocmd_bufnr = save_autocmd_bufnr;</a>
<a name="ln7646">    restore_funccal();</a>
<a name="ln7647">  }</a>
<a name="ln7648"> </a>
<a name="ln7649">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7650">    const char *name = NULL;</a>
<a name="ln7651">    Channel *chan = find_channel(chan_id);</a>
<a name="ln7652">    if (chan) {</a>
<a name="ln7653">      name = rpc_client_name(chan);</a>
<a name="ln7654">    }</a>
<a name="ln7655">    msg_ext_set_kind(&quot;rpc_error&quot;);</a>
<a name="ln7656">    if (name) {</a>
<a name="ln7657">      emsgf_multiline(&quot;Error invoking '%s' on channel %&quot;PRIu64&quot; (%s):\n%s&quot;,</a>
<a name="ln7658">                      method, chan_id, name, err.msg);</a>
<a name="ln7659">    } else {</a>
<a name="ln7660">      emsgf_multiline(&quot;Error invoking '%s' on channel %&quot;PRIu64&quot;:\n%s&quot;,</a>
<a name="ln7661">                      method, chan_id, err.msg);</a>
<a name="ln7662">    }</a>
<a name="ln7663"> </a>
<a name="ln7664">    goto end;</a>
<a name="ln7665">  }</a>
<a name="ln7666"> </a>
<a name="ln7667">  if (!object_to_vim(result, rettv, &amp;err)) {</a>
<a name="ln7668">    EMSG2(_(&quot;Error converting the call result: %s&quot;), err.msg);</a>
<a name="ln7669">  }</a>
<a name="ln7670"> </a>
<a name="ln7671">end:</a>
<a name="ln7672">  api_free_object(result);</a>
<a name="ln7673">  api_clear_error(&amp;err);</a>
<a name="ln7674">}</a>
<a name="ln7675"> </a>
<a name="ln7676">// &quot;rpcstart()&quot; function (DEPRECATED)</a>
<a name="ln7677">static void f_rpcstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7678">{</a>
<a name="ln7679">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7680">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7681"> </a>
<a name="ln7682">  if (check_secure()) {</a>
<a name="ln7683">    return;</a>
<a name="ln7684">  }</a>
<a name="ln7685"> </a>
<a name="ln7686">  if (argvars[0].v_type != VAR_STRING</a>
<a name="ln7687">      || (argvars[1].v_type != VAR_LIST &amp;&amp; argvars[1].v_type != VAR_UNKNOWN)) {</a>
<a name="ln7688">    // Wrong argument types</a>
<a name="ln7689">    EMSG(_(e_invarg));</a>
<a name="ln7690">    return;</a>
<a name="ln7691">  }</a>
<a name="ln7692"> </a>
<a name="ln7693">  list_T *args = NULL;</a>
<a name="ln7694">  int argsl = 0;</a>
<a name="ln7695">  if (argvars[1].v_type == VAR_LIST) {</a>
<a name="ln7696">    args = argvars[1].vval.v_list;</a>
<a name="ln7697">    argsl = tv_list_len(args);</a>
<a name="ln7698">    // Assert that all list items are strings</a>
<a name="ln7699">    int i = 0;</a>
<a name="ln7700">    TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln7701">      if (TV_LIST_ITEM_TV(arg)-&gt;v_type != VAR_STRING) {</a>
<a name="ln7702">        emsgf(_(&quot;E5010: List item %d of the second argument is not a string&quot;),</a>
<a name="ln7703">              i);</a>
<a name="ln7704">        return;</a>
<a name="ln7705">      }</a>
<a name="ln7706">      i++;</a>
<a name="ln7707">    });</a>
<a name="ln7708">  }</a>
<a name="ln7709"> </a>
<a name="ln7710">  if (argvars[0].vval.v_string == NULL || argvars[0].vval.v_string[0] == NUL) {</a>
<a name="ln7711">    EMSG(_(e_api_spawn_failed));</a>
<a name="ln7712">    return;</a>
<a name="ln7713">  }</a>
<a name="ln7714"> </a>
<a name="ln7715">  // Allocate extra memory for the argument vector and the NULL pointer</a>
<a name="ln7716">  int argvl = argsl + 2;</a>
<a name="ln7717">  char **argv = xmalloc(sizeof(char_u *) * argvl);</a>
<a name="ln7718"> </a>
<a name="ln7719">  // Copy program name</a>
<a name="ln7720">  argv[0] = xstrdup((char *)argvars[0].vval.v_string);</a>
<a name="ln7721"> </a>
<a name="ln7722">  int i = 1;</a>
<a name="ln7723">  // Copy arguments to the vector</a>
<a name="ln7724">  if (argsl &gt; 0) {</a>
<a name="ln7725">    TV_LIST_ITER_CONST(args, arg, {</a>
<a name="ln7726">      argv[i++] = xstrdup(tv_get_string(TV_LIST_ITEM_TV(arg)));</a>
<a name="ln7727">    });</a>
<a name="ln7728">  }</a>
<a name="ln7729"> </a>
<a name="ln7730">  // The last item of argv must be NULL</a>
<a name="ln7731">  argv[i] = NULL;</a>
<a name="ln7732"> </a>
<a name="ln7733">  Channel *chan = channel_job_start(argv, CALLBACK_READER_INIT,</a>
<a name="ln7734">                                    CALLBACK_READER_INIT, CALLBACK_NONE,</a>
<a name="ln7735">                                    false, true, false, false, NULL, 0, 0,</a>
<a name="ln7736">                                    NULL, &amp;rettv-&gt;vval.v_number);</a>
<a name="ln7737">  if (chan) {</a>
<a name="ln7738">    channel_create_event(chan, NULL);</a>
<a name="ln7739">  }</a>
<a name="ln7740">}</a>
<a name="ln7741"> </a>
<a name="ln7742">// &quot;rpcstop()&quot; function</a>
<a name="ln7743">static void f_rpcstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7744">{</a>
<a name="ln7745">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln7746">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln7747"> </a>
<a name="ln7748">  if (check_secure()) {</a>
<a name="ln7749">    return;</a>
<a name="ln7750">  }</a>
<a name="ln7751"> </a>
<a name="ln7752">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln7753">    // Wrong argument types</a>
<a name="ln7754">    EMSG(_(e_invarg));</a>
<a name="ln7755">    return;</a>
<a name="ln7756">  }</a>
<a name="ln7757"> </a>
<a name="ln7758">  // if called with a job, stop it, else closes the channel</a>
<a name="ln7759">  uint64_t id = argvars[0].vval.v_number;</a>
<a name="ln7760">  if (find_job(id, false)) {</a>
<a name="ln7761">    f_jobstop(argvars, rettv, NULL);</a>
<a name="ln7762">  } else {</a>
<a name="ln7763">    const char *error;</a>
<a name="ln7764">    rettv-&gt;vval.v_number = channel_close(argvars[0].vval.v_number,</a>
<a name="ln7765">                                         kChannelPartRpc, &amp;error);</a>
<a name="ln7766">    if (!rettv-&gt;vval.v_number) {</a>
<a name="ln7767">      EMSG(error);</a>
<a name="ln7768">    }</a>
<a name="ln7769">  }</a>
<a name="ln7770">}</a>
<a name="ln7771"> </a>
<a name="ln7772">/*</a>
<a name="ln7773"> * &quot;screenattr()&quot; function</a>
<a name="ln7774"> */</a>
<a name="ln7775">static void f_screenattr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7776">{</a>
<a name="ln7777">  int c;</a>
<a name="ln7778"> </a>
<a name="ln7779">  int row = (int)tv_get_number_chk(&amp;argvars[0], NULL) - 1;</a>
<a name="ln7780">  int col = (int)tv_get_number_chk(&amp;argvars[1], NULL) - 1;</a>
<a name="ln7781">  if (row &lt; 0 || row &gt;= default_grid.Rows</a>
<a name="ln7782">      || col &lt; 0 || col &gt;= default_grid.Columns) {</a>
<a name="ln7783">    c = -1;</a>
<a name="ln7784">  } else {</a>
<a name="ln7785">    ScreenGrid *grid = &amp;default_grid;</a>
<a name="ln7786">    screenchar_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln7787">    c = grid-&gt;attrs[grid-&gt;line_offset[row] + col];</a>
<a name="ln7788">  }</a>
<a name="ln7789">  rettv-&gt;vval.v_number = c;</a>
<a name="ln7790">}</a>
<a name="ln7791"> </a>
<a name="ln7792">/*</a>
<a name="ln7793"> * &quot;screenchar()&quot; function</a>
<a name="ln7794"> */</a>
<a name="ln7795">static void f_screenchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7796">{</a>
<a name="ln7797">  int c;</a>
<a name="ln7798"> </a>
<a name="ln7799">  int row = tv_get_number_chk(&amp;argvars[0], NULL) - 1;</a>
<a name="ln7800">  int col = tv_get_number_chk(&amp;argvars[1], NULL) - 1;</a>
<a name="ln7801">  if (row &lt; 0 || row &gt;= default_grid.Rows</a>
<a name="ln7802">      || col &lt; 0 || col &gt;= default_grid.Columns) {</a>
<a name="ln7803">    c = -1;</a>
<a name="ln7804">  } else {</a>
<a name="ln7805">    ScreenGrid *grid = &amp;default_grid;</a>
<a name="ln7806">    screenchar_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln7807">    c = utf_ptr2char(grid-&gt;chars[grid-&gt;line_offset[row] + col]);</a>
<a name="ln7808">  }</a>
<a name="ln7809">  rettv-&gt;vval.v_number = c;</a>
<a name="ln7810">}</a>
<a name="ln7811"> </a>
<a name="ln7812">/*</a>
<a name="ln7813"> * &quot;screencol()&quot; function</a>
<a name="ln7814"> *</a>
<a name="ln7815"> * First column is 1 to be consistent with virtcol().</a>
<a name="ln7816"> */</a>
<a name="ln7817">static void f_screencol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7818">{</a>
<a name="ln7819">  rettv-&gt;vval.v_number = ui_current_col() + 1;</a>
<a name="ln7820">}</a>
<a name="ln7821"> </a>
<a name="ln7822">/// &quot;screenpos({winid}, {lnum}, {col})&quot; function</a>
<a name="ln7823">static void f_screenpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7824">{</a>
<a name="ln7825">  pos_T pos;</a>
<a name="ln7826">  int row = 0;</a>
<a name="ln7827">  int scol = 0, ccol = 0, ecol = 0;</a>
<a name="ln7828"> </a>
<a name="ln7829">  tv_dict_alloc_ret(rettv);</a>
<a name="ln7830">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln7831"> </a>
<a name="ln7832">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln7833">  if (wp == NULL) {</a>
<a name="ln7834">    return;</a>
<a name="ln7835">  }</a>
<a name="ln7836"> </a>
<a name="ln7837">  pos.lnum = tv_get_number(&amp;argvars[1]);</a>
<a name="ln7838">  pos.col = tv_get_number(&amp;argvars[2]) - 1;</a>
<a name="ln7839">  pos.coladd = 0;</a>
<a name="ln7840">  textpos2screenpos(wp, &amp;pos, &amp;row, &amp;scol, &amp;ccol, &amp;ecol, false);</a>
<a name="ln7841"> </a>
<a name="ln7842">  tv_dict_add_nr(dict, S_LEN(&quot;row&quot;), row);</a>
<a name="ln7843">  tv_dict_add_nr(dict, S_LEN(&quot;col&quot;), scol);</a>
<a name="ln7844">  tv_dict_add_nr(dict, S_LEN(&quot;curscol&quot;), ccol);</a>
<a name="ln7845">  tv_dict_add_nr(dict, S_LEN(&quot;endcol&quot;), ecol);</a>
<a name="ln7846">}</a>
<a name="ln7847"> </a>
<a name="ln7848">/*</a>
<a name="ln7849"> * &quot;screenrow()&quot; function</a>
<a name="ln7850"> */</a>
<a name="ln7851">static void f_screenrow(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7852">{</a>
<a name="ln7853">  rettv-&gt;vval.v_number = ui_current_row() + 1;</a>
<a name="ln7854">}</a>
<a name="ln7855"> </a>
<a name="ln7856">/*</a>
<a name="ln7857"> * &quot;search()&quot; function</a>
<a name="ln7858"> */</a>
<a name="ln7859">static void f_search(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7860">{</a>
<a name="ln7861">  int flags = 0;</a>
<a name="ln7862"> </a>
<a name="ln7863">  rettv-&gt;vval.v_number = search_cmn(argvars, NULL, &amp;flags);</a>
<a name="ln7864">}</a>
<a name="ln7865"> </a>
<a name="ln7866">/*</a>
<a name="ln7867"> * &quot;searchdecl()&quot; function</a>
<a name="ln7868"> */</a>
<a name="ln7869">static void f_searchdecl(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7870">{</a>
<a name="ln7871">  int locally = 1;</a>
<a name="ln7872">  int thisblock = 0;</a>
<a name="ln7873">  bool error = false;</a>
<a name="ln7874"> </a>
<a name="ln7875">  rettv-&gt;vval.v_number = 1;     // default: FAIL</a>
<a name="ln7876"> </a>
<a name="ln7877">  const char *const name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln7878">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln7879">    locally = tv_get_number_chk(&amp;argvars[1], &amp;error) == 0;</a>
<a name="ln7880">    if (!error &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln7881">      thisblock = tv_get_number_chk(&amp;argvars[2], &amp;error) != 0;</a>
<a name="ln7882">    }</a>
<a name="ln7883">  }</a>
<a name="ln7884">  if (!error &amp;&amp; name != NULL) {</a>
<a name="ln7885">    rettv-&gt;vval.v_number = find_decl((char_u *)name, strlen(name), locally,</a>
<a name="ln7886">                                     thisblock, SEARCH_KEEP) == FAIL;</a>
<a name="ln7887">  }</a>
<a name="ln7888">}</a>
<a name="ln7889"> </a>
<a name="ln7890">/*</a>
<a name="ln7891"> * Used by searchpair() and searchpairpos()</a>
<a name="ln7892"> */</a>
<a name="ln7893">static int searchpair_cmn(typval_T *argvars, pos_T *match_pos)</a>
<a name="ln7894">{</a>
<a name="ln7895">  bool save_p_ws = p_ws;</a>
<a name="ln7896">  int dir;</a>
<a name="ln7897">  int flags = 0;</a>
<a name="ln7898">  int retval = 0;  // default: FAIL</a>
<a name="ln7899">  long lnum_stop = 0;</a>
<a name="ln7900">  long time_limit = 0;</a>
<a name="ln7901"> </a>
<a name="ln7902">  // Get the three pattern arguments: start, middle, end. Will result in an</a>
<a name="ln7903">  // error if not a valid argument.</a>
<a name="ln7904">  char nbuf1[NUMBUFLEN];</a>
<a name="ln7905">  char nbuf2[NUMBUFLEN];</a>
<a name="ln7906">  const char *spat = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln7907">  const char *mpat = tv_get_string_buf_chk(&amp;argvars[1], nbuf1);</a>
<a name="ln7908">  const char *epat = tv_get_string_buf_chk(&amp;argvars[2], nbuf2);</a>
<a name="ln7909">  if (spat == NULL || mpat == NULL || epat == NULL) {</a>
<a name="ln7910">    goto theend;  // Type error.</a>
<a name="ln7911">  }</a>
<a name="ln7912"> </a>
<a name="ln7913">  // Handle the optional fourth argument: flags.</a>
<a name="ln7914">  dir = get_search_arg(&amp;argvars[3], &amp;flags);   // may set p_ws.</a>
<a name="ln7915">  if (dir == 0) {</a>
<a name="ln7916">    goto theend;</a>
<a name="ln7917">  }</a>
<a name="ln7918"> </a>
<a name="ln7919">  // Don't accept SP_END or SP_SUBPAT.</a>
<a name="ln7920">  // Only one of the SP_NOMOVE or SP_SETPCMARK flags can be set.</a>
<a name="ln7921">  if ((flags &amp; (SP_END | SP_SUBPAT)) != 0</a>
<a name="ln7922">      || ((flags &amp; SP_NOMOVE) &amp;&amp; (flags &amp; SP_SETPCMARK))) {</a>
<a name="ln7923">    EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[3]));</a>
<a name="ln7924">    goto theend;</a>
<a name="ln7925">  }</a>
<a name="ln7926"> </a>
<a name="ln7927">  // Using 'r' implies 'W', otherwise it doesn't work.</a>
<a name="ln7928">  if (flags &amp; SP_REPEAT) {</a>
<a name="ln7929">    p_ws = false;</a>
<a name="ln7930">  }</a>
<a name="ln7931"> </a>
<a name="ln7932">  // Optional fifth argument: skip expression.</a>
<a name="ln7933">  const typval_T *skip;</a>
<a name="ln7934">  if (argvars[3].v_type == VAR_UNKNOWN</a>
<a name="ln7935">      || argvars[4].v_type == VAR_UNKNOWN) {</a>
<a name="ln7936">    skip = NULL;</a>
<a name="ln7937">  } else {</a>
<a name="ln7938">    skip = &amp;argvars[4];</a>
<a name="ln7939">    if (skip-&gt;v_type != VAR_FUNC</a>
<a name="ln7940">        &amp;&amp; skip-&gt;v_type != VAR_PARTIAL</a>
<a name="ln7941">        &amp;&amp; skip-&gt;v_type != VAR_STRING) {</a>
<a name="ln7942">      emsgf(_(e_invarg2), tv_get_string(&amp;argvars[4]));</a>
<a name="ln7943">      goto theend;  // Type error.</a>
<a name="ln7944">    }</a>
<a name="ln7945">    if (argvars[5].v_type != VAR_UNKNOWN) {</a>
<a name="ln7946">      lnum_stop = tv_get_number_chk(&amp;argvars[5], NULL);</a>
<a name="ln7947">      if (lnum_stop &lt; 0) {</a>
<a name="ln7948">        emsgf(_(e_invarg2), tv_get_string(&amp;argvars[5]));</a>
<a name="ln7949">        goto theend;</a>
<a name="ln7950">      }</a>
<a name="ln7951">      if (argvars[6].v_type != VAR_UNKNOWN) {</a>
<a name="ln7952">        time_limit = tv_get_number_chk(&amp;argvars[6], NULL);</a>
<a name="ln7953">        if (time_limit &lt; 0) {</a>
<a name="ln7954">          emsgf(_(e_invarg2), tv_get_string(&amp;argvars[6]));</a>
<a name="ln7955">          goto theend;</a>
<a name="ln7956">        }</a>
<a name="ln7957">      }</a>
<a name="ln7958">    }</a>
<a name="ln7959">  }</a>
<a name="ln7960"> </a>
<a name="ln7961">  retval = do_searchpair(</a>
<a name="ln7962">      spat, mpat, epat, dir, skip,</a>
<a name="ln7963">      flags, match_pos, lnum_stop, time_limit);</a>
<a name="ln7964"> </a>
<a name="ln7965">theend:</a>
<a name="ln7966">  p_ws = save_p_ws;</a>
<a name="ln7967"> </a>
<a name="ln7968">  return retval;</a>
<a name="ln7969">}</a>
<a name="ln7970"> </a>
<a name="ln7971">/*</a>
<a name="ln7972"> * &quot;searchpair()&quot; function</a>
<a name="ln7973"> */</a>
<a name="ln7974">static void f_searchpair(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7975">{</a>
<a name="ln7976">  rettv-&gt;vval.v_number = searchpair_cmn(argvars, NULL);</a>
<a name="ln7977">}</a>
<a name="ln7978"> </a>
<a name="ln7979">/*</a>
<a name="ln7980"> * &quot;searchpairpos()&quot; function</a>
<a name="ln7981"> */</a>
<a name="ln7982">static void f_searchpairpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln7983">{</a>
<a name="ln7984">  pos_T match_pos;</a>
<a name="ln7985">  int lnum = 0;</a>
<a name="ln7986">  int col = 0;</a>
<a name="ln7987"> </a>
<a name="ln7988">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln7989"> </a>
<a name="ln7990">  if (searchpair_cmn(argvars, &amp;match_pos) &gt; 0) {</a>
<a name="ln7991">    lnum = match_pos.lnum;</a>
<a name="ln7992">    col = match_pos.col;</a>
<a name="ln7993">  }</a>
<a name="ln7994"> </a>
<a name="ln7995">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)lnum);</a>
<a name="ln7996">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)col);</a>
<a name="ln7997">}</a>
<a name="ln7998"> </a>
<a name="ln7999">/*</a>
<a name="ln8000"> * Search for a start/middle/end thing.</a>
<a name="ln8001"> * Used by searchpair(), see its documentation for the details.</a>
<a name="ln8002"> * Returns 0 or -1 for no match,</a>
<a name="ln8003"> */</a>
<a name="ln8004">long</a>
<a name="ln8005">do_searchpair(</a>
<a name="ln8006">    const char *spat,      // start pattern</a>
<a name="ln8007">    const char *mpat,      // middle pattern</a>
<a name="ln8008">    const char *epat,      // end pattern</a>
<a name="ln8009">    int dir,               // BACKWARD or FORWARD</a>
<a name="ln8010">    const typval_T *skip,  // skip expression</a>
<a name="ln8011">    int flags,             // SP_SETPCMARK and other SP_ values</a>
<a name="ln8012">    pos_T *match_pos,</a>
<a name="ln8013">    linenr_T lnum_stop,    // stop at this line if not zero</a>
<a name="ln8014">    long time_limit        // stop after this many msec</a>
<a name="ln8015">)</a>
<a name="ln8016">  FUNC_ATTR_NONNULL_ARG(1, 2, 3)</a>
<a name="ln8017">{</a>
<a name="ln8018">  char_u      *save_cpo;</a>
<a name="ln8019">  char_u      *pat, *pat2 = NULL, *pat3 = NULL;</a>
<a name="ln8020">  long retval = 0;</a>
<a name="ln8021">  pos_T pos;</a>
<a name="ln8022">  pos_T firstpos;</a>
<a name="ln8023">  pos_T foundpos;</a>
<a name="ln8024">  pos_T save_cursor;</a>
<a name="ln8025">  pos_T save_pos;</a>
<a name="ln8026">  int n;</a>
<a name="ln8027">  int nest = 1;</a>
<a name="ln8028">  bool use_skip = false;</a>
<a name="ln8029">  int options = SEARCH_KEEP;</a>
<a name="ln8030">  proftime_T tm;</a>
<a name="ln8031"> </a>
<a name="ln8032">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln8033">  save_cpo = p_cpo;</a>
<a name="ln8034">  p_cpo = empty_option;</a>
<a name="ln8035"> </a>
<a name="ln8036">  // Set the time limit, if there is one.</a>
<a name="ln8037">  tm = profile_setlimit(time_limit);</a>
<a name="ln8038"> </a>
<a name="ln8039">  // Make two search patterns: start/end (pat2, for in nested pairs) and</a>
<a name="ln8040">  // start/middle/end (pat3, for the top pair).</a>
<a name="ln8041">  const size_t pat2_len = strlen(spat) + strlen(epat) + 17;</a>
<a name="ln8042">  pat2 = xmalloc(pat2_len);</a>
<a name="ln8043">  const size_t pat3_len = strlen(spat) + strlen(mpat) + strlen(epat) + 25;</a>
<a name="ln8044">  pat3 = xmalloc(pat3_len);</a>
<a name="ln8045">  snprintf((char *)pat2, pat2_len, &quot;\\m\\(%s\\m\\)\\|\\(%s\\m\\)&quot;, spat, epat);</a>
<a name="ln8046">  if (*mpat == NUL) {</a>
<a name="ln8047">    STRCPY(pat3, pat2);</a>
<a name="ln8048">  } else {</a>
<a name="ln8049">    snprintf((char *)pat3, pat3_len,</a>
<a name="ln8050">             &quot;\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)&quot;, spat, epat, mpat);</a>
<a name="ln8051">  }</a>
<a name="ln8052">  if (flags &amp; SP_START) {</a>
<a name="ln8053">    options |= SEARCH_START;</a>
<a name="ln8054">  }</a>
<a name="ln8055"> </a>
<a name="ln8056">  if (skip != NULL) {</a>
<a name="ln8057">    // Empty string means to not use the skip expression.</a>
<a name="ln8058">    if (skip-&gt;v_type == VAR_STRING || skip-&gt;v_type == VAR_FUNC) {</a>
<a name="ln8059">      use_skip = skip-&gt;vval.v_string != NULL &amp;&amp; *skip-&gt;vval.v_string != NUL;</a>
<a name="ln8060">    }</a>
<a name="ln8061">  }</a>
<a name="ln8062"> </a>
<a name="ln8063">  save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln8064">  pos = curwin-&gt;w_cursor;</a>
<a name="ln8065">  clearpos(&amp;firstpos);</a>
<a name="ln8066">  clearpos(&amp;foundpos);</a>
<a name="ln8067">  pat = pat3;</a>
<a name="ln8068">  for (;; ) {</a>
<a name="ln8069">    searchit_arg_T sia;</a>
<a name="ln8070">    memset(&amp;sia, 0, sizeof(sia));</a>
<a name="ln8071">    sia.sa_stop_lnum = lnum_stop;</a>
<a name="ln8072">    sia.sa_tm = &amp;tm;</a>
<a name="ln8073"> </a>
<a name="ln8074">    n = searchit(curwin, curbuf, &amp;pos, NULL, dir, pat, 1L,</a>
<a name="ln8075">                 options, RE_SEARCH, &amp;sia);</a>
<a name="ln8076">    if (n == FAIL || (firstpos.lnum != 0 &amp;&amp; equalpos(pos, firstpos))) {</a>
<a name="ln8077">      // didn't find it or found the first match again: FAIL</a>
<a name="ln8078">      break;</a>
<a name="ln8079">    }</a>
<a name="ln8080"> </a>
<a name="ln8081">    if (firstpos.lnum == 0)</a>
<a name="ln8082">      firstpos = pos;</a>
<a name="ln8083">    if (equalpos(pos, foundpos)) {</a>
<a name="ln8084">      // Found the same position again.  Can happen with a pattern that</a>
<a name="ln8085">      // has &quot;\zs&quot; at the end and searching backwards.  Advance one</a>
<a name="ln8086">      // character and try again.</a>
<a name="ln8087">      if (dir == BACKWARD) {</a>
<a name="ln8088">        decl(&amp;pos);</a>
<a name="ln8089">      } else {</a>
<a name="ln8090">        incl(&amp;pos);</a>
<a name="ln8091">      }</a>
<a name="ln8092">    }</a>
<a name="ln8093">    foundpos = pos;</a>
<a name="ln8094"> </a>
<a name="ln8095">    // clear the start flag to avoid getting stuck here</a>
<a name="ln8096">    options &amp;= ~SEARCH_START;</a>
<a name="ln8097"> </a>
<a name="ln8098">    // If the skip pattern matches, ignore this match.</a>
<a name="ln8099">    if (use_skip) {</a>
<a name="ln8100">      save_pos = curwin-&gt;w_cursor;</a>
<a name="ln8101">      curwin-&gt;w_cursor = pos;</a>
<a name="ln8102">      bool err = false;</a>
<a name="ln8103">      const bool r = eval_expr_to_bool(skip, &amp;err);</a>
<a name="ln8104">      curwin-&gt;w_cursor = save_pos;</a>
<a name="ln8105">      if (err) {</a>
<a name="ln8106">        // Evaluating {skip} caused an error, break here.</a>
<a name="ln8107">        curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln8108">        retval = -1;</a>
<a name="ln8109">        break;</a>
<a name="ln8110">      }</a>
<a name="ln8111">      if (r)</a>
<a name="ln8112">        continue;</a>
<a name="ln8113">    }</a>
<a name="ln8114"> </a>
<a name="ln8115">    if ((dir == BACKWARD &amp;&amp; n == 3) || (dir == FORWARD &amp;&amp; n == 2)) {</a>
<a name="ln8116">      // Found end when searching backwards or start when searching</a>
<a name="ln8117">      // forward: nested pair.</a>
<a name="ln8118">      nest++;</a>
<a name="ln8119">      pat = pat2;               // nested, don't search for middle</a>
<a name="ln8120">    } else {</a>
<a name="ln8121">      // Found end when searching forward or start when searching</a>
<a name="ln8122">      // backward: end of (nested) pair; or found middle in outer pair.</a>
<a name="ln8123">      if (--nest == 1) {</a>
<a name="ln8124">        pat = pat3;             // outer level, search for middle</a>
<a name="ln8125">      }</a>
<a name="ln8126">    }</a>
<a name="ln8127"> </a>
<a name="ln8128">    if (nest == 0) {</a>
<a name="ln8129">      // Found the match: return matchcount or line number.</a>
<a name="ln8130">      if (flags &amp; SP_RETCOUNT) {</a>
<a name="ln8131">        retval++;</a>
<a name="ln8132">      } else {</a>
<a name="ln8133">        retval = pos.lnum;</a>
<a name="ln8134">      }</a>
<a name="ln8135">      if (flags &amp; SP_SETPCMARK) {</a>
<a name="ln8136">        setpcmark();</a>
<a name="ln8137">      }</a>
<a name="ln8138">      curwin-&gt;w_cursor = pos;</a>
<a name="ln8139">      if (!(flags &amp; SP_REPEAT))</a>
<a name="ln8140">        break;</a>
<a name="ln8141">      nest = 1;             // search for next unmatched</a>
<a name="ln8142">    }</a>
<a name="ln8143">  }</a>
<a name="ln8144"> </a>
<a name="ln8145">  if (match_pos != NULL) {</a>
<a name="ln8146">    // Store the match cursor position</a>
<a name="ln8147">    match_pos-&gt;lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln8148">    match_pos-&gt;col = curwin-&gt;w_cursor.col + 1;</a>
<a name="ln8149">  }</a>
<a name="ln8150"> </a>
<a name="ln8151">  // If 'n' flag is used or search failed: restore cursor position.</a>
<a name="ln8152">  if ((flags &amp; SP_NOMOVE) || retval == 0) {</a>
<a name="ln8153">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln8154">  }</a>
<a name="ln8155"> </a>
<a name="ln8156">  xfree(pat2);</a>
<a name="ln8157">  xfree(pat3);</a>
<a name="ln8158">  if (p_cpo == empty_option) {</a>
<a name="ln8159">    p_cpo = save_cpo;</a>
<a name="ln8160">  } else {</a>
<a name="ln8161">    // Darn, evaluating the {skip} expression changed the value.</a>
<a name="ln8162">    free_string_option(save_cpo);</a>
<a name="ln8163">  }</a>
<a name="ln8164"> </a>
<a name="ln8165">  return retval;</a>
<a name="ln8166">}</a>
<a name="ln8167"> </a>
<a name="ln8168">/*</a>
<a name="ln8169"> * &quot;searchpos()&quot; function</a>
<a name="ln8170"> */</a>
<a name="ln8171">static void f_searchpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8172">{</a>
<a name="ln8173">  pos_T match_pos;</a>
<a name="ln8174">  int flags = 0;</a>
<a name="ln8175"> </a>
<a name="ln8176">  const int n = search_cmn(argvars, &amp;match_pos, &amp;flags);</a>
<a name="ln8177"> </a>
<a name="ln8178">  tv_list_alloc_ret(rettv, 2 + (!!(flags &amp; SP_SUBPAT)));</a>
<a name="ln8179"> </a>
<a name="ln8180">  const int lnum = (n &gt; 0 ? match_pos.lnum : 0);</a>
<a name="ln8181">  const int col = (n &gt; 0 ? match_pos.col : 0);</a>
<a name="ln8182"> </a>
<a name="ln8183">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)lnum);</a>
<a name="ln8184">  tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)col);</a>
<a name="ln8185">  if (flags &amp; SP_SUBPAT) {</a>
<a name="ln8186">    tv_list_append_number(rettv-&gt;vval.v_list, (varnumber_T)n);</a>
<a name="ln8187">  }</a>
<a name="ln8188">}</a>
<a name="ln8189"> </a>
<a name="ln8190">/// &quot;serverlist()&quot; function</a>
<a name="ln8191">static void f_serverlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8192">{</a>
<a name="ln8193">  size_t n;</a>
<a name="ln8194">  char **addrs = server_address_list(&amp;n);</a>
<a name="ln8195"> </a>
<a name="ln8196">  // Copy addrs into a linked list.</a>
<a name="ln8197">  list_T *const l = tv_list_alloc_ret(rettv, n);</a>
<a name="ln8198">  for (size_t i = 0; i &lt; n; i++) {</a>
<a name="ln8199">    tv_list_append_allocated_string(l, addrs[i]);</a>
<a name="ln8200">  }</a>
<a name="ln8201">  xfree(addrs);</a>
<a name="ln8202">}</a>
<a name="ln8203"> </a>
<a name="ln8204">/// &quot;serverstart()&quot; function</a>
<a name="ln8205">static void f_serverstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8206">{</a>
<a name="ln8207">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8208">  rettv-&gt;vval.v_string = NULL;  // Address of the new server</a>
<a name="ln8209"> </a>
<a name="ln8210">  if (check_secure()) {</a>
<a name="ln8211">    return;</a>
<a name="ln8212">  }</a>
<a name="ln8213"> </a>
<a name="ln8214">  char *address;</a>
<a name="ln8215">  // If the user supplied an address, use it, otherwise use a temp.</a>
<a name="ln8216">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8217">    if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln8218">      EMSG(_(e_invarg));</a>
<a name="ln8219">      return;</a>
<a name="ln8220">    } else {</a>
<a name="ln8221">      address = xstrdup(tv_get_string(argvars));</a>
<a name="ln8222">    }</a>
<a name="ln8223">  } else {</a>
<a name="ln8224">    address = server_address_new();</a>
<a name="ln8225">  }</a>
<a name="ln8226"> </a>
<a name="ln8227">  int result = server_start(address);</a>
<a name="ln8228">  xfree(address);</a>
<a name="ln8229"> </a>
<a name="ln8230">  if (result != 0) {</a>
<a name="ln8231">    EMSG2(&quot;Failed to start server: %s&quot;,</a>
<a name="ln8232">          result &gt; 0 ? &quot;Unknown system error&quot; : uv_strerror(result));</a>
<a name="ln8233">    return;</a>
<a name="ln8234">  }</a>
<a name="ln8235"> </a>
<a name="ln8236">  // Since it's possible server_start adjusted the given {address} (e.g.,</a>
<a name="ln8237">  // &quot;localhost:&quot; will now have a port), return the final value to the user.</a>
<a name="ln8238">  size_t n;</a>
<a name="ln8239">  char **addrs = server_address_list(&amp;n);</a>
<a name="ln8240">  rettv-&gt;vval.v_string = (char_u *)addrs[n - 1];</a>
<a name="ln8241"> </a>
<a name="ln8242">  n--;</a>
<a name="ln8243">  for (size_t i = 0; i &lt; n; i++) {</a>
<a name="ln8244">    xfree(addrs[i]);</a>
<a name="ln8245">  }</a>
<a name="ln8246">  xfree(addrs);</a>
<a name="ln8247">}</a>
<a name="ln8248"> </a>
<a name="ln8249">/// &quot;serverstop()&quot; function</a>
<a name="ln8250">static void f_serverstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8251">{</a>
<a name="ln8252">  if (check_secure()) {</a>
<a name="ln8253">    return;</a>
<a name="ln8254">  }</a>
<a name="ln8255"> </a>
<a name="ln8256">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln8257">    EMSG(_(e_invarg));</a>
<a name="ln8258">    return;</a>
<a name="ln8259">  }</a>
<a name="ln8260"> </a>
<a name="ln8261">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln8262">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8263">  if (argvars[0].vval.v_string) {</a>
<a name="ln8264">    bool rv = server_stop((char *)argvars[0].vval.v_string);</a>
<a name="ln8265">    rettv-&gt;vval.v_number = (rv ? 1 : 0);</a>
<a name="ln8266">  }</a>
<a name="ln8267">}</a>
<a name="ln8268"> </a>
<a name="ln8269">/// &quot;setbufline()&quot; function</a>
<a name="ln8270">static void f_setbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8271">{</a>
<a name="ln8272">    linenr_T lnum;</a>
<a name="ln8273">    buf_T    *buf;</a>
<a name="ln8274"> </a>
<a name="ln8275">    buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln8276">    if (buf == NULL) {</a>
<a name="ln8277">      rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln8278">    } else {</a>
<a name="ln8279">      lnum = tv_get_lnum_buf(&amp;argvars[1], buf);</a>
<a name="ln8280">      set_buffer_lines(buf, lnum, false, &amp;argvars[2], rettv);</a>
<a name="ln8281">    }</a>
<a name="ln8282">}</a>
<a name="ln8283"> </a>
<a name="ln8284">/*</a>
<a name="ln8285"> * &quot;setbufvar()&quot; function</a>
<a name="ln8286"> */</a>
<a name="ln8287">static void f_setbufvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8288">{</a>
<a name="ln8289">  if (check_secure()</a>
<a name="ln8290">      || !tv_check_str_or_nr(&amp;argvars[0])) {</a>
<a name="ln8291">    return;</a>
<a name="ln8292">  }</a>
<a name="ln8293">  const char *varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8294">  buf_T *const buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln8295">  typval_T *varp = &amp;argvars[2];</a>
<a name="ln8296"> </a>
<a name="ln8297">  if (buf != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln8298">    if (*varname == '&amp;') {</a>
<a name="ln8299">      long numval;</a>
<a name="ln8300">      bool error = false;</a>
<a name="ln8301">      aco_save_T aco;</a>
<a name="ln8302"> </a>
<a name="ln8303">      // set curbuf to be our buf, temporarily</a>
<a name="ln8304">      aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln8305"> </a>
<a name="ln8306">      varname++;</a>
<a name="ln8307">      numval = tv_get_number_chk(varp, &amp;error);</a>
<a name="ln8308">      char nbuf[NUMBUFLEN];</a>
<a name="ln8309">      const char *const strval = tv_get_string_buf_chk(varp, nbuf);</a>
<a name="ln8310">      if (!error &amp;&amp; strval != NULL) {</a>
<a name="ln8311">        set_option_value(varname, numval, strval, OPT_LOCAL);</a>
<a name="ln8312">      }</a>
<a name="ln8313"> </a>
<a name="ln8314">      // reset notion of buffer</a>
<a name="ln8315">      aucmd_restbuf(&amp;aco);</a>
<a name="ln8316">    } else {</a>
<a name="ln8317">      const size_t varname_len = STRLEN(varname);</a>
<a name="ln8318">      char *const bufvarname = xmalloc(varname_len + 3);</a>
<a name="ln8319">      buf_T *const save_curbuf = curbuf;</a>
<a name="ln8320">      curbuf = buf;</a>
<a name="ln8321">      memcpy(bufvarname, &quot;b:&quot;, 2);</a>
<a name="ln8322">      memcpy(bufvarname + 2, varname, varname_len + 1);</a>
<a name="ln8323">      set_var(bufvarname, varname_len + 2, varp, true);</a>
<a name="ln8324">      xfree(bufvarname);</a>
<a name="ln8325">      curbuf = save_curbuf;</a>
<a name="ln8326">    }</a>
<a name="ln8327">  }</a>
<a name="ln8328">}</a>
<a name="ln8329"> </a>
<a name="ln8330">static void f_setcharsearch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8331">{</a>
<a name="ln8332">  dict_T        *d;</a>
<a name="ln8333">  dictitem_T        *di;</a>
<a name="ln8334"> </a>
<a name="ln8335">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln8336">    EMSG(_(e_dictreq));</a>
<a name="ln8337">    return;</a>
<a name="ln8338">  }</a>
<a name="ln8339"> </a>
<a name="ln8340">  if ((d = argvars[0].vval.v_dict) != NULL) {</a>
<a name="ln8341">    char_u *const csearch = (char_u *)tv_dict_get_string(d, &quot;char&quot;, false);</a>
<a name="ln8342">    if (csearch != NULL) {</a>
<a name="ln8343">      int pcc[MAX_MCO];</a>
<a name="ln8344">      const int c = utfc_ptr2char(csearch, pcc);</a>
<a name="ln8345">      set_last_csearch(c, csearch, utfc_ptr2len(csearch));</a>
<a name="ln8346">    }</a>
<a name="ln8347"> </a>
<a name="ln8348">    di = tv_dict_find(d, S_LEN(&quot;forward&quot;));</a>
<a name="ln8349">    if (di != NULL) {</a>
<a name="ln8350">      set_csearch_direction(tv_get_number(&amp;di-&gt;di_tv) ? FORWARD : BACKWARD);</a>
<a name="ln8351">    }</a>
<a name="ln8352"> </a>
<a name="ln8353">    di = tv_dict_find(d, S_LEN(&quot;until&quot;));</a>
<a name="ln8354">    if (di != NULL) {</a>
<a name="ln8355">      set_csearch_until(!!tv_get_number(&amp;di-&gt;di_tv));</a>
<a name="ln8356">    }</a>
<a name="ln8357">  }</a>
<a name="ln8358">}</a>
<a name="ln8359"> </a>
<a name="ln8360">/*</a>
<a name="ln8361"> * &quot;setcmdpos()&quot; function</a>
<a name="ln8362"> */</a>
<a name="ln8363">static void f_setcmdpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8364">{</a>
<a name="ln8365">  const int pos = (int)tv_get_number(&amp;argvars[0]) - 1;</a>
<a name="ln8366"> </a>
<a name="ln8367">  if (pos &gt;= 0) {</a>
<a name="ln8368">    rettv-&gt;vval.v_number = set_cmdline_pos(pos);</a>
<a name="ln8369">  }</a>
<a name="ln8370">}</a>
<a name="ln8371"> </a>
<a name="ln8372">/// &quot;setenv()&quot; function</a>
<a name="ln8373">static void f_setenv(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8374">{</a>
<a name="ln8375">  char namebuf[NUMBUFLEN];</a>
<a name="ln8376">  char valbuf[NUMBUFLEN];</a>
<a name="ln8377">  const char *name = tv_get_string_buf(&amp;argvars[0], namebuf);</a>
<a name="ln8378"> </a>
<a name="ln8379">  if (argvars[1].v_type == VAR_SPECIAL</a>
<a name="ln8380">      &amp;&amp; argvars[1].vval.v_special == kSpecialVarNull) {</a>
<a name="ln8381">    os_unsetenv(name);</a>
<a name="ln8382">  } else {</a>
<a name="ln8383">    os_setenv(name, tv_get_string_buf(&amp;argvars[1], valbuf), 1);</a>
<a name="ln8384">  }</a>
<a name="ln8385">}</a>
<a name="ln8386"> </a>
<a name="ln8387">/// &quot;setfperm({fname}, {mode})&quot; function</a>
<a name="ln8388">static void f_setfperm(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8389">{</a>
<a name="ln8390">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8391"> </a>
<a name="ln8392">  const char *const fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln8393">  if (fname == NULL) {</a>
<a name="ln8394">    return;</a>
<a name="ln8395">  }</a>
<a name="ln8396"> </a>
<a name="ln8397">  char modebuf[NUMBUFLEN];</a>
<a name="ln8398">  const char *const mode_str = tv_get_string_buf_chk(&amp;argvars[1], modebuf);</a>
<a name="ln8399">  if (mode_str == NULL) {</a>
<a name="ln8400">    return;</a>
<a name="ln8401">  }</a>
<a name="ln8402">  if (strlen(mode_str) != 9) {</a>
<a name="ln8403">    EMSG2(_(e_invarg2), mode_str);</a>
<a name="ln8404">    return;</a>
<a name="ln8405">  }</a>
<a name="ln8406"> </a>
<a name="ln8407">  int mask = 1;</a>
<a name="ln8408">  int mode = 0;</a>
<a name="ln8409">  for (int i = 8; i &gt;= 0; i--) {</a>
<a name="ln8410">    if (mode_str[i] != '-') {</a>
<a name="ln8411">      mode |= mask;</a>
<a name="ln8412">    }</a>
<a name="ln8413">    mask = mask &lt;&lt; 1;</a>
<a name="ln8414">  }</a>
<a name="ln8415">  rettv-&gt;vval.v_number = os_setperm(fname, mode) == OK;</a>
<a name="ln8416">}</a>
<a name="ln8417"> </a>
<a name="ln8418">/*</a>
<a name="ln8419"> * &quot;setline()&quot; function</a>
<a name="ln8420"> */</a>
<a name="ln8421">static void f_setline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8422">{</a>
<a name="ln8423">  linenr_T lnum = tv_get_lnum(&amp;argvars[0]);</a>
<a name="ln8424">  set_buffer_lines(curbuf, lnum, false, &amp;argvars[1], rettv);</a>
<a name="ln8425">}</a>
<a name="ln8426"> </a>
<a name="ln8427">/// Create quickfix/location list from VimL values</a>
<a name="ln8428">///</a>
<a name="ln8429">/// Used by `setqflist()` and `setloclist()` functions. Accepts invalid</a>
<a name="ln8430">/// args argument in which case errors out, including VAR_UNKNOWN parameters.</a>
<a name="ln8431">///</a>
<a name="ln8432">/// @param[in,out]  wp  Window to create location list for. May be NULL in</a>
<a name="ln8433">///                     which case quickfix list will be created.</a>
<a name="ln8434">/// @param[in]  args  [list, action, what]</a>
<a name="ln8435">/// @param[in]  args[0]  Quickfix list contents.</a>
<a name="ln8436">/// @param[in]  args[1]  Optional. Action to perform:</a>
<a name="ln8437">///                      append to an existing list, replace its content,</a>
<a name="ln8438">///                      or create a new one.</a>
<a name="ln8439">/// @param[in]  args[2]  Optional. Quickfix list properties or title.</a>
<a name="ln8440">///                      Defaults to caller function name.</a>
<a name="ln8441">/// @param[out]  rettv  Return value: 0 in case of success, -1 otherwise.</a>
<a name="ln8442">static void set_qf_ll_list(win_T *wp, typval_T *args, typval_T *rettv)</a>
<a name="ln8443">  FUNC_ATTR_NONNULL_ARG(2, 3)</a>
<a name="ln8444">{</a>
<a name="ln8445">  static char *e_invact = N_(&quot;E927: Invalid action: '%s'&quot;);</a>
<a name="ln8446">  const char *title = NULL;</a>
<a name="ln8447">  int action = ' ';</a>
<a name="ln8448">  static int recursive = 0;</a>
<a name="ln8449">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8450">  dict_T *what = NULL;</a>
<a name="ln8451"> </a>
<a name="ln8452">  typval_T *list_arg = &amp;args[0];</a>
<a name="ln8453">  if (list_arg-&gt;v_type != VAR_LIST) {</a>
<a name="ln8454">    EMSG(_(e_listreq));</a>
<a name="ln8455">    return;</a>
<a name="ln8456">  } else if (recursive != 0) {</a>
<a name="ln8457">    EMSG(_(e_au_recursive));</a>
<a name="ln8458">    return;</a>
<a name="ln8459">  }</a>
<a name="ln8460"> </a>
<a name="ln8461">  typval_T *action_arg = &amp;args[1];</a>
<a name="ln8462">  if (action_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln8463">    // Option argument was not given.</a>
<a name="ln8464">    goto skip_args;</a>
<a name="ln8465">  } else if (action_arg-&gt;v_type != VAR_STRING) {</a>
<a name="ln8466">    EMSG(_(e_stringreq));</a>
<a name="ln8467">    return;</a>
<a name="ln8468">  }</a>
<a name="ln8469">  const char *const act = tv_get_string_chk(action_arg);</a>
<a name="ln8470">  if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f')</a>
<a name="ln8471">      &amp;&amp; act[1] == NUL) {</a>
<a name="ln8472">    action = *act;</a>
<a name="ln8473">  } else {</a>
<a name="ln8474">    EMSG2(_(e_invact), act);</a>
<a name="ln8475">    return;</a>
<a name="ln8476">  }</a>
<a name="ln8477"> </a>
<a name="ln8478">  typval_T *const what_arg = &amp;args[2];</a>
<a name="ln8479">  if (what_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln8480">    // Option argument was not given.</a>
<a name="ln8481">    goto skip_args;</a>
<a name="ln8482">  } else if (what_arg-&gt;v_type == VAR_STRING) {</a>
<a name="ln8483">    title = tv_get_string_chk(what_arg);</a>
<a name="ln8484">    if (!title) {</a>
<a name="ln8485">      // Type error. Error already printed by tv_get_string_chk().</a>
<a name="ln8486">      return;</a>
<a name="ln8487">    }</a>
<a name="ln8488">  } else if (what_arg-&gt;v_type == VAR_DICT &amp;&amp; what_arg-&gt;vval.v_dict != NULL) {</a>
<a name="ln8489">    what = what_arg-&gt;vval.v_dict;</a>
<a name="ln8490">  } else {</a>
<a name="ln8491">    EMSG(_(e_dictreq));</a>
<a name="ln8492">    return;</a>
<a name="ln8493">  }</a>
<a name="ln8494"> </a>
<a name="ln8495">skip_args:</a>
<a name="ln8496">  if (!title) {</a>
<a name="ln8497">    title = (wp ? &quot;:setloclist()&quot; : &quot;:setqflist()&quot;);</a>
<a name="ln8498">  }</a>
<a name="ln8499"> </a>
<a name="ln8500">  recursive++;</a>
<a name="ln8501">  list_T *const l = list_arg-&gt;vval.v_list;</a>
<a name="ln8502">  if (set_errorlist(wp, l, action, (char_u *)title, what) == OK) {</a>
<a name="ln8503">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8504">  }</a>
<a name="ln8505">  recursive--;</a>
<a name="ln8506">}</a>
<a name="ln8507"> </a>
<a name="ln8508">/*</a>
<a name="ln8509"> * &quot;setloclist()&quot; function</a>
<a name="ln8510"> */</a>
<a name="ln8511">static void f_setloclist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8512">{</a>
<a name="ln8513">  win_T       *win;</a>
<a name="ln8514"> </a>
<a name="ln8515">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8516"> </a>
<a name="ln8517">  win = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln8518">  if (win != NULL) {</a>
<a name="ln8519">    set_qf_ll_list(win, &amp;argvars[1], rettv);</a>
<a name="ln8520">  }</a>
<a name="ln8521">}</a>
<a name="ln8522"> </a>
<a name="ln8523">/*</a>
<a name="ln8524"> * &quot;setmatches()&quot; function</a>
<a name="ln8525"> */</a>
<a name="ln8526">static void f_setmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8527">{</a>
<a name="ln8528">  dict_T *d;</a>
<a name="ln8529">  list_T *s = NULL;</a>
<a name="ln8530">  win_T *win = get_optional_window(argvars, 1);</a>
<a name="ln8531"> </a>
<a name="ln8532">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8533">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln8534">    EMSG(_(e_listreq));</a>
<a name="ln8535">    return;</a>
<a name="ln8536">  }</a>
<a name="ln8537">  if (win == NULL) {</a>
<a name="ln8538">    return;</a>
<a name="ln8539">  }</a>
<a name="ln8540"> </a>
<a name="ln8541">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln8542">  // To some extent make sure that we are dealing with a list from</a>
<a name="ln8543">  // &quot;getmatches()&quot;.</a>
<a name="ln8544">  int li_idx = 0;</a>
<a name="ln8545">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln8546">    if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_DICT</a>
<a name="ln8547">        || (d = TV_LIST_ITEM_TV(li)-&gt;vval.v_dict) == NULL) {</a>
<a name="ln8548">      emsgf(_(&quot;E474: List item %d is either not a dictionary &quot;</a>
<a name="ln8549">              &quot;or an empty one&quot;), li_idx);</a>
<a name="ln8550">      return;</a>
<a name="ln8551">    }</a>
<a name="ln8552">    if (!(tv_dict_find(d, S_LEN(&quot;group&quot;)) != NULL</a>
<a name="ln8553">          &amp;&amp; (tv_dict_find(d, S_LEN(&quot;pattern&quot;)) != NULL</a>
<a name="ln8554">              || tv_dict_find(d, S_LEN(&quot;pos1&quot;)) != NULL)</a>
<a name="ln8555">          &amp;&amp; tv_dict_find(d, S_LEN(&quot;priority&quot;)) != NULL</a>
<a name="ln8556">          &amp;&amp; tv_dict_find(d, S_LEN(&quot;id&quot;)) != NULL)) {</a>
<a name="ln8557">      emsgf(_(&quot;E474: List item %d is missing one of the required keys&quot;),</a>
<a name="ln8558">            li_idx);</a>
<a name="ln8559">      return;</a>
<a name="ln8560">    }</a>
<a name="ln8561">    li_idx++;</a>
<a name="ln8562">  });</a>
<a name="ln8563"> </a>
<a name="ln8564">  clear_matches(win);</a>
<a name="ln8565">  bool match_add_failed = false;</a>
<a name="ln8566">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln8567">    int i = 0;</a>
<a name="ln8568"> </a>
<a name="ln8569">    d = TV_LIST_ITEM_TV(li)-&gt;vval.v_dict;</a>
<a name="ln8570">    dictitem_T *const di = tv_dict_find(d, S_LEN(&quot;pattern&quot;));</a>
<a name="ln8571">    if (di == NULL) {</a>
<a name="ln8572">      if (s == NULL) {</a>
<a name="ln8573">        s = tv_list_alloc(9);</a>
<a name="ln8574">      }</a>
<a name="ln8575"> </a>
<a name="ln8576">      // match from matchaddpos()</a>
<a name="ln8577">      for (i = 1; i &lt; 9; i++) {</a>
<a name="ln8578">        char buf[30];  // use 30 to avoid compiler warning</a>
<a name="ln8579">        snprintf(buf, sizeof(buf), &quot;pos%d&quot;, i);</a>
<a name="ln8580">        dictitem_T *const pos_di = tv_dict_find(d, buf, -1);</a>
<a name="ln8581">        if (pos_di != NULL) {</a>
<a name="ln8582">          if (pos_di-&gt;di_tv.v_type != VAR_LIST) {</a>
<a name="ln8583">            return;</a>
<a name="ln8584">          }</a>
<a name="ln8585"> </a>
<a name="ln8586">          tv_list_append_tv(s, &amp;pos_di-&gt;di_tv);</a>
<a name="ln8587">          tv_list_ref(s);</a>
<a name="ln8588">        } else {</a>
<a name="ln8589">          break;</a>
<a name="ln8590">        }</a>
<a name="ln8591">      }</a>
<a name="ln8592">    }</a>
<a name="ln8593"> </a>
<a name="ln8594">    // Note: there are three number buffers involved:</a>
<a name="ln8595">    // - group_buf below.</a>
<a name="ln8596">    // - numbuf in tv_dict_get_string().</a>
<a name="ln8597">    // - mybuf in tv_get_string().</a>
<a name="ln8598">    //</a>
<a name="ln8599">    // If you change this code make sure that buffers will not get</a>
<a name="ln8600">    // accidentally reused.</a>
<a name="ln8601">    char group_buf[NUMBUFLEN];</a>
<a name="ln8602">    const char *const group = tv_dict_get_string_buf(d, &quot;group&quot;, group_buf);</a>
<a name="ln8603">    const int priority = (int)tv_dict_get_number(d, &quot;priority&quot;);</a>
<a name="ln8604">    const int id = (int)tv_dict_get_number(d, &quot;id&quot;);</a>
<a name="ln8605">    dictitem_T *const conceal_di = tv_dict_find(d, S_LEN(&quot;conceal&quot;));</a>
<a name="ln8606">    const char *const conceal = (conceal_di != NULL</a>
<a name="ln8607">                                 ? tv_get_string(&amp;conceal_di-&gt;di_tv)</a>
<a name="ln8608">                                 : NULL);</a>
<a name="ln8609">    if (i == 0) {</a>
<a name="ln8610">      if (match_add(win, group,</a>
<a name="ln8611">                    tv_dict_get_string(d, &quot;pattern&quot;, false),</a>
<a name="ln8612">                    priority, id, NULL, conceal) != id) {</a>
<a name="ln8613">        match_add_failed = true;</a>
<a name="ln8614">      }</a>
<a name="ln8615">    } else {</a>
<a name="ln8616">      if (match_add(win, group, NULL, priority, id, s, conceal) != id) {</a>
<a name="ln8617">        match_add_failed = true;</a>
<a name="ln8618">      }</a>
<a name="ln8619">      tv_list_unref(s);</a>
<a name="ln8620">      s = NULL;</a>
<a name="ln8621">    }</a>
<a name="ln8622">  });</a>
<a name="ln8623">  if (!match_add_failed) {</a>
<a name="ln8624">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln8625">  }</a>
<a name="ln8626">}</a>
<a name="ln8627"> </a>
<a name="ln8628">/*</a>
<a name="ln8629"> * &quot;setpos()&quot; function</a>
<a name="ln8630"> */</a>
<a name="ln8631">static void f_setpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8632">{</a>
<a name="ln8633">  pos_T pos;</a>
<a name="ln8634">  int fnum;</a>
<a name="ln8635">  colnr_T     curswant = -1;</a>
<a name="ln8636"> </a>
<a name="ln8637">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8638">  const char *const name = tv_get_string_chk(argvars);</a>
<a name="ln8639">  if (name != NULL) {</a>
<a name="ln8640">    if (list2fpos(&amp;argvars[1], &amp;pos, &amp;fnum, &amp;curswant) == OK) {</a>
<a name="ln8641">      if (pos.col != MAXCOL &amp;&amp; --pos.col &lt; 0) {</a>
<a name="ln8642">        pos.col = 0;</a>
<a name="ln8643">      }</a>
<a name="ln8644">      if (name[0] == '.' &amp;&amp; name[1] == NUL) {</a>
<a name="ln8645">        // set cursor; &quot;fnum&quot; is ignored</a>
<a name="ln8646">        curwin-&gt;w_cursor = pos;</a>
<a name="ln8647">        if (curswant &gt;= 0) {</a>
<a name="ln8648">          curwin-&gt;w_curswant = curswant - 1;</a>
<a name="ln8649">          curwin-&gt;w_set_curswant = false;</a>
<a name="ln8650">        }</a>
<a name="ln8651">        check_cursor();</a>
<a name="ln8652">        rettv-&gt;vval.v_number = 0;</a>
<a name="ln8653">      } else if (name[0] == '\'' &amp;&amp; name[1] != NUL &amp;&amp; name[2] == NUL)   {</a>
<a name="ln8654">        // set mark</a>
<a name="ln8655">        if (setmark_pos((uint8_t)name[1], &amp;pos, fnum) == OK) {</a>
<a name="ln8656">          rettv-&gt;vval.v_number = 0;</a>
<a name="ln8657">        }</a>
<a name="ln8658">      } else {</a>
<a name="ln8659">        EMSG(_(e_invarg));</a>
<a name="ln8660">      }</a>
<a name="ln8661">    }</a>
<a name="ln8662">  }</a>
<a name="ln8663">}</a>
<a name="ln8664"> </a>
<a name="ln8665">/*</a>
<a name="ln8666"> * &quot;setqflist()&quot; function</a>
<a name="ln8667"> */</a>
<a name="ln8668">static void f_setqflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8669">{</a>
<a name="ln8670">  set_qf_ll_list(NULL, argvars, rettv);</a>
<a name="ln8671">}</a>
<a name="ln8672"> </a>
<a name="ln8673">/*</a>
<a name="ln8674"> * &quot;setreg()&quot; function</a>
<a name="ln8675"> */</a>
<a name="ln8676">static void f_setreg(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8677">{</a>
<a name="ln8678">  int regname;</a>
<a name="ln8679">  bool append = false;</a>
<a name="ln8680">  MotionType yank_type;</a>
<a name="ln8681">  long block_len;</a>
<a name="ln8682"> </a>
<a name="ln8683">  block_len = -1;</a>
<a name="ln8684">  yank_type = kMTUnknown;</a>
<a name="ln8685"> </a>
<a name="ln8686">  rettv-&gt;vval.v_number = 1;  // FAIL is default.</a>
<a name="ln8687"> </a>
<a name="ln8688">  const char *const strregname = tv_get_string_chk(argvars);</a>
<a name="ln8689">  if (strregname == NULL) {</a>
<a name="ln8690">    return;  // Type error; errmsg already given.</a>
<a name="ln8691">  }</a>
<a name="ln8692">  regname = (uint8_t)(*strregname);</a>
<a name="ln8693">  if (regname == 0 || regname == '@') {</a>
<a name="ln8694">    regname = '&quot;';</a>
<a name="ln8695">  }</a>
<a name="ln8696"> </a>
<a name="ln8697">  bool set_unnamed = false;</a>
<a name="ln8698">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln8699">    const char *stropt = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln8700">    if (stropt == NULL) {</a>
<a name="ln8701">      return;  // Type error.</a>
<a name="ln8702">    }</a>
<a name="ln8703">    for (; *stropt != NUL; stropt++) {</a>
<a name="ln8704">      switch (*stropt) {</a>
<a name="ln8705">        case 'a': case 'A': {  // append</a>
<a name="ln8706">          append = true;</a>
<a name="ln8707">          break;</a>
<a name="ln8708">        }</a>
<a name="ln8709">        case 'v': case 'c': {  // character-wise selection</a>
<a name="ln8710">          yank_type = kMTCharWise;</a>
<a name="ln8711">          break;</a>
<a name="ln8712">        }</a>
<a name="ln8713">        case 'V': case 'l': {  // line-wise selection</a>
<a name="ln8714">          yank_type = kMTLineWise;</a>
<a name="ln8715">          break;</a>
<a name="ln8716">        }</a>
<a name="ln8717">        case 'b': case Ctrl_V: {  // block-wise selection</a>
<a name="ln8718">          yank_type = kMTBlockWise;</a>
<a name="ln8719">          if (ascii_isdigit(stropt[1])) {</a>
<a name="ln8720">            stropt++;</a>
<a name="ln8721">            block_len = getdigits_long((char_u **)&amp;stropt, true, 0) - 1;</a>
<a name="ln8722">            stropt--;</a>
<a name="ln8723">          }</a>
<a name="ln8724">          break;</a>
<a name="ln8725">        }</a>
<a name="ln8726">        case 'u': case '&quot;': {  // unnamed register</a>
<a name="ln8727">          set_unnamed = true;</a>
<a name="ln8728">          break;</a>
<a name="ln8729">        }</a>
<a name="ln8730">      }</a>
<a name="ln8731">    }</a>
<a name="ln8732">  }</a>
<a name="ln8733"> </a>
<a name="ln8734">  if (argvars[1].v_type == VAR_LIST) {</a>
<a name="ln8735">    list_T *ll = argvars[1].vval.v_list;</a>
<a name="ln8736">    // If the list is NULL handle like an empty list.</a>
<a name="ln8737">    const int len = tv_list_len(ll);</a>
<a name="ln8738"> </a>
<a name="ln8739">    // First half: use for pointers to result lines; second half: use for</a>
<a name="ln8740">    // pointers to allocated copies.</a>
<a name="ln8741">    char **lstval = xmalloc(sizeof(char *) * ((len + 1) * 2));</a>
<a name="ln8742">    const char **curval = (const char **)lstval;</a>
<a name="ln8743">    char **allocval = lstval + len + 2;</a>
<a name="ln8744">    char **curallocval = allocval;</a>
<a name="ln8745"> </a>
<a name="ln8746">    TV_LIST_ITER_CONST(ll, li, {</a>
<a name="ln8747">      char buf[NUMBUFLEN];</a>
<a name="ln8748">      *curval = tv_get_string_buf_chk(TV_LIST_ITEM_TV(li), buf);</a>
<a name="ln8749">      if (*curval == NULL) {</a>
<a name="ln8750">        goto free_lstval;</a>
<a name="ln8751">      }</a>
<a name="ln8752">      if (*curval == buf) {</a>
<a name="ln8753">        // Need to make a copy,</a>
<a name="ln8754">        // next tv_get_string_buf_chk() will overwrite the string.</a>
<a name="ln8755">        *curallocval = xstrdup(*curval);</a>
<a name="ln8756">        *curval = *curallocval;</a>
<a name="ln8757">        curallocval++;</a>
<a name="ln8758">      }</a>
<a name="ln8759">      curval++;</a>
<a name="ln8760">    });</a>
<a name="ln8761">    *curval++ = NULL;</a>
<a name="ln8762"> </a>
<a name="ln8763">    write_reg_contents_lst(regname, (char_u **)lstval, append, yank_type,</a>
<a name="ln8764">                           block_len);</a>
<a name="ln8765"> </a>
<a name="ln8766">free_lstval:</a>
<a name="ln8767">    while (curallocval &gt; allocval) {</a>
<a name="ln8768">      xfree(*--curallocval);</a>
<a name="ln8769">    }</a>
<a name="ln8770">    xfree(lstval);</a>
<a name="ln8771">  } else {</a>
<a name="ln8772">    const char *strval = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8773">    if (strval == NULL) {</a>
<a name="ln8774">      return;</a>
<a name="ln8775">    }</a>
<a name="ln8776">    write_reg_contents_ex(regname, (const char_u *)strval, STRLEN(strval),</a>
<a name="ln8777">                          append, yank_type, block_len);</a>
<a name="ln8778">  }</a>
<a name="ln8779">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8780"> </a>
<a name="ln8781">  if (set_unnamed) {</a>
<a name="ln8782">    // Discard the result. We already handle the error case.</a>
<a name="ln8783">    if (op_reg_set_previous(regname)) { }</a>
<a name="ln8784">  }</a>
<a name="ln8785">}</a>
<a name="ln8786"> </a>
<a name="ln8787">/*</a>
<a name="ln8788"> * &quot;settabvar()&quot; function</a>
<a name="ln8789"> */</a>
<a name="ln8790">static void f_settabvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8791">{</a>
<a name="ln8792">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8793"> </a>
<a name="ln8794">  if (check_secure()) {</a>
<a name="ln8795">    return;</a>
<a name="ln8796">  }</a>
<a name="ln8797"> </a>
<a name="ln8798">  tabpage_T *const tp = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln8799">  const char *const varname = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln8800">  typval_T *const varp = &amp;argvars[2];</a>
<a name="ln8801"> </a>
<a name="ln8802">  if (varname != NULL &amp;&amp; tp != NULL) {</a>
<a name="ln8803">    tabpage_T *const save_curtab = curtab;</a>
<a name="ln8804">    goto_tabpage_tp(tp, false, false);</a>
<a name="ln8805"> </a>
<a name="ln8806">    const size_t varname_len = strlen(varname);</a>
<a name="ln8807">    char *const tabvarname = xmalloc(varname_len + 3);</a>
<a name="ln8808">    memcpy(tabvarname, &quot;t:&quot;, 2);</a>
<a name="ln8809">    memcpy(tabvarname + 2, varname, varname_len + 1);</a>
<a name="ln8810">    set_var(tabvarname, varname_len + 2, varp, true);</a>
<a name="ln8811">    xfree(tabvarname);</a>
<a name="ln8812"> </a>
<a name="ln8813">    // Restore current tabpage.</a>
<a name="ln8814">    if (valid_tabpage(save_curtab)) {</a>
<a name="ln8815">      goto_tabpage_tp(save_curtab, false, false);</a>
<a name="ln8816">    }</a>
<a name="ln8817">  }</a>
<a name="ln8818">}</a>
<a name="ln8819"> </a>
<a name="ln8820">/*</a>
<a name="ln8821"> * &quot;settabwinvar()&quot; function</a>
<a name="ln8822"> */</a>
<a name="ln8823">static void f_settabwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8824">{</a>
<a name="ln8825">  setwinvar(argvars, rettv, 1);</a>
<a name="ln8826">}</a>
<a name="ln8827"> </a>
<a name="ln8828">// &quot;settagstack()&quot; function</a>
<a name="ln8829">static void f_settagstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8830">{</a>
<a name="ln8831">    static char *e_invact2 = N_(&quot;E962: Invalid action: '%s'&quot;);</a>
<a name="ln8832">    win_T       *wp;</a>
<a name="ln8833">    dict_T      *d;</a>
<a name="ln8834">    int         action = 'r';</a>
<a name="ln8835"> </a>
<a name="ln8836">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln8837"> </a>
<a name="ln8838">    // first argument: window number or id</a>
<a name="ln8839">    wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln8840">    if (wp == NULL) {</a>
<a name="ln8841">      return;</a>
<a name="ln8842">    }</a>
<a name="ln8843"> </a>
<a name="ln8844">    // second argument: dict with items to set in the tag stack</a>
<a name="ln8845">    if (argvars[1].v_type != VAR_DICT) {</a>
<a name="ln8846">        EMSG(_(e_dictreq));</a>
<a name="ln8847">        return;</a>
<a name="ln8848">    }</a>
<a name="ln8849">    d = argvars[1].vval.v_dict;</a>
<a name="ln8850">    if (d == NULL) {</a>
<a name="ln8851">      return;</a>
<a name="ln8852">    }</a>
<a name="ln8853"> </a>
<a name="ln8854">    // third argument: action - 'a' for append and 'r' for replace.</a>
<a name="ln8855">    // default is to replace the stack.</a>
<a name="ln8856">    if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln8857">      action = 'r';</a>
<a name="ln8858">    } else if (argvars[2].v_type == VAR_STRING) {</a>
<a name="ln8859">        const char *actstr;</a>
<a name="ln8860">        actstr = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln8861">        if (actstr == NULL) {</a>
<a name="ln8862">          return;</a>
<a name="ln8863">        }</a>
<a name="ln8864">        if ((*actstr == 'r' || *actstr == 'a' || *actstr == 't')</a>
<a name="ln8865">            &amp;&amp; actstr[1] == NUL) {</a>
<a name="ln8866">          action = *actstr;</a>
<a name="ln8867">        } else {</a>
<a name="ln8868">            EMSG2(_(e_invact2), actstr);</a>
<a name="ln8869">            return;</a>
<a name="ln8870">        }</a>
<a name="ln8871">    } else {</a>
<a name="ln8872">        EMSG(_(e_stringreq));</a>
<a name="ln8873">        return;</a>
<a name="ln8874">    }</a>
<a name="ln8875"> </a>
<a name="ln8876">    if (set_tagstack(wp, d, action) == OK) {</a>
<a name="ln8877">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln8878">    }</a>
<a name="ln8879">}</a>
<a name="ln8880"> </a>
<a name="ln8881">/*</a>
<a name="ln8882"> * &quot;setwinvar()&quot; function</a>
<a name="ln8883"> */</a>
<a name="ln8884">static void f_setwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8885">{</a>
<a name="ln8886">  setwinvar(argvars, rettv, 0);</a>
<a name="ln8887">}</a>
<a name="ln8888"> </a>
<a name="ln8889">/// f_sha256 - sha256({string}) function</a>
<a name="ln8890">static void f_sha256(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8891">{</a>
<a name="ln8892">  const char *p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8893">  const char *hash = sha256_bytes((const uint8_t *)p, strlen(p) , NULL, 0);</a>
<a name="ln8894"> </a>
<a name="ln8895">  // make a copy of the hash (sha256_bytes returns a static buffer)</a>
<a name="ln8896">  rettv-&gt;vval.v_string = (char_u *)xstrdup(hash);</a>
<a name="ln8897">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8898">}</a>
<a name="ln8899"> </a>
<a name="ln8900">/*</a>
<a name="ln8901"> * &quot;shellescape({string})&quot; function</a>
<a name="ln8902"> */</a>
<a name="ln8903">static void f_shellescape(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8904">{</a>
<a name="ln8905">  const bool do_special = non_zero_arg(&amp;argvars[1]);</a>
<a name="ln8906"> </a>
<a name="ln8907">  rettv-&gt;vval.v_string = vim_strsave_shellescape(</a>
<a name="ln8908">      (const char_u *)tv_get_string(&amp;argvars[0]), do_special, do_special);</a>
<a name="ln8909">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln8910">}</a>
<a name="ln8911"> </a>
<a name="ln8912">/*</a>
<a name="ln8913"> * shiftwidth() function</a>
<a name="ln8914"> */</a>
<a name="ln8915">static void f_shiftwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8916">{</a>
<a name="ln8917">  rettv-&gt;vval.v_number = 0;</a>
<a name="ln8918"> </a>
<a name="ln8919">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8920">    long col;</a>
<a name="ln8921"> </a>
<a name="ln8922">    col = (long)tv_get_number_chk(argvars, NULL);</a>
<a name="ln8923">    if (col &lt; 0) {</a>
<a name="ln8924">      return;  // type error; errmsg already given</a>
<a name="ln8925">    }</a>
<a name="ln8926">    rettv-&gt;vval.v_number = get_sw_value_col(curbuf, col);</a>
<a name="ln8927">    return;</a>
<a name="ln8928">  }</a>
<a name="ln8929">  rettv-&gt;vval.v_number = get_sw_value(curbuf);</a>
<a name="ln8930">}</a>
<a name="ln8931"> </a>
<a name="ln8932">/// &quot;sign_define()&quot; function</a>
<a name="ln8933">static void f_sign_define(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8934">{</a>
<a name="ln8935">  const char *name;</a>
<a name="ln8936"> </a>
<a name="ln8937">  if (argvars[0].v_type == VAR_LIST &amp;&amp; argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln8938">    // Define multiple signs</a>
<a name="ln8939">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln8940"> </a>
<a name="ln8941">    sign_define_multiple(argvars[0].vval.v_list, rettv-&gt;vval.v_list);</a>
<a name="ln8942">    return;</a>
<a name="ln8943">  }</a>
<a name="ln8944"> </a>
<a name="ln8945">  // Define a single sign</a>
<a name="ln8946">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln8947"> </a>
<a name="ln8948">  name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln8949">  if (name == NULL) {</a>
<a name="ln8950">    return;</a>
<a name="ln8951">  }</a>
<a name="ln8952"> </a>
<a name="ln8953">  if (argvars[1].v_type != VAR_UNKNOWN &amp;&amp; argvars[1].v_type != VAR_DICT) {</a>
<a name="ln8954">    EMSG(_(e_dictreq));</a>
<a name="ln8955">    return;</a>
<a name="ln8956">  }</a>
<a name="ln8957"> </a>
<a name="ln8958">  rettv-&gt;vval.v_number = sign_define_from_dict(</a>
<a name="ln8959">      name, argvars[1].v_type == VAR_DICT ? argvars[1].vval.v_dict : NULL);</a>
<a name="ln8960">}</a>
<a name="ln8961"> </a>
<a name="ln8962">/// &quot;sign_getdefined()&quot; function</a>
<a name="ln8963">static void f_sign_getdefined(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8964">{</a>
<a name="ln8965">  const char *name = NULL;</a>
<a name="ln8966"> </a>
<a name="ln8967">  tv_list_alloc_ret(rettv, 0);</a>
<a name="ln8968"> </a>
<a name="ln8969">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8970">    name = tv_get_string(&amp;argvars[0]);</a>
<a name="ln8971">  }</a>
<a name="ln8972"> </a>
<a name="ln8973">  sign_getlist((const char_u *)name, rettv-&gt;vval.v_list);</a>
<a name="ln8974">}</a>
<a name="ln8975"> </a>
<a name="ln8976">/// &quot;sign_getplaced()&quot; function</a>
<a name="ln8977">static void f_sign_getplaced(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln8978">{</a>
<a name="ln8979">  buf_T *buf = NULL;</a>
<a name="ln8980">  dict_T *dict;</a>
<a name="ln8981">  dictitem_T *di;</a>
<a name="ln8982">  linenr_T lnum = 0;</a>
<a name="ln8983">  int sign_id = 0;</a>
<a name="ln8984">  const char *group = NULL;</a>
<a name="ln8985">  bool notanum = false;</a>
<a name="ln8986"> </a>
<a name="ln8987">  tv_list_alloc_ret(rettv, 0);</a>
<a name="ln8988"> </a>
<a name="ln8989">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln8990">    // get signs placed in the specified buffer</a>
<a name="ln8991">    buf = get_buf_arg(&amp;argvars[0]);</a>
<a name="ln8992">    if (buf == NULL) {</a>
<a name="ln8993">      return;</a>
<a name="ln8994">    }</a>
<a name="ln8995"> </a>
<a name="ln8996">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln8997">      if (argvars[1].v_type != VAR_DICT</a>
<a name="ln8998">          || ((dict = argvars[1].vval.v_dict) == NULL)) {</a>
<a name="ln8999">        EMSG(_(e_dictreq));</a>
<a name="ln9000">        return;</a>
<a name="ln9001">      }</a>
<a name="ln9002">      if ((di = tv_dict_find(dict, &quot;lnum&quot;, -1)) != NULL) {</a>
<a name="ln9003">        // get signs placed at this line</a>
<a name="ln9004">        lnum = (linenr_T)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln9005">        if (notanum) {</a>
<a name="ln9006">          return;</a>
<a name="ln9007">        }</a>
<a name="ln9008">        (void)lnum;</a>
<a name="ln9009">        lnum = tv_get_lnum(&amp;di-&gt;di_tv);</a>
<a name="ln9010">      }</a>
<a name="ln9011">      if ((di = tv_dict_find(dict, &quot;id&quot;, -1)) != NULL) {</a>
<a name="ln9012">        // get sign placed with this identifier</a>
<a name="ln9013">        sign_id = (int)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;notanum);</a>
<a name="ln9014">        if (notanum) {</a>
<a name="ln9015">          return;</a>
<a name="ln9016">        }</a>
<a name="ln9017">      }</a>
<a name="ln9018">      if ((di = tv_dict_find(dict, &quot;group&quot;, -1)) != NULL) {</a>
<a name="ln9019">        group = tv_get_string_chk(&amp;di-&gt;di_tv);</a>
<a name="ln9020">        if (group == NULL) {</a>
<a name="ln9021">          return;</a>
<a name="ln9022">        }</a>
<a name="ln9023">        if (*group == '\0') {  // empty string means global group</a>
<a name="ln9024">          group = NULL;</a>
<a name="ln9025">        }</a>
<a name="ln9026">      }</a>
<a name="ln9027">    }</a>
<a name="ln9028">  }</a>
<a name="ln9029"> </a>
<a name="ln9030">  sign_get_placed(buf, lnum, sign_id, (const char_u *)group,</a>
<a name="ln9031">                  rettv-&gt;vval.v_list);</a>
<a name="ln9032">}</a>
<a name="ln9033"> </a>
<a name="ln9034">/// &quot;sign_jump()&quot; function</a>
<a name="ln9035">static void f_sign_jump(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9036">{</a>
<a name="ln9037">  int sign_id;</a>
<a name="ln9038">  char *sign_group = NULL;</a>
<a name="ln9039">  buf_T *buf;</a>
<a name="ln9040">  bool notanum = false;</a>
<a name="ln9041"> </a>
<a name="ln9042">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9043"> </a>
<a name="ln9044">  // Sign identifier</a>
<a name="ln9045">  sign_id = (int)tv_get_number_chk(&amp;argvars[0], &amp;notanum);</a>
<a name="ln9046">  if (notanum) {</a>
<a name="ln9047">    return;</a>
<a name="ln9048">  }</a>
<a name="ln9049">  if (sign_id &lt;= 0) {</a>
<a name="ln9050">    EMSG(_(e_invarg));</a>
<a name="ln9051">    return;</a>
<a name="ln9052">  }</a>
<a name="ln9053"> </a>
<a name="ln9054">  // Sign group</a>
<a name="ln9055">  const char * sign_group_chk = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln9056">  if (sign_group_chk == NULL) {</a>
<a name="ln9057">    return;</a>
<a name="ln9058">  }</a>
<a name="ln9059">  if (sign_group_chk[0] == '\0') {</a>
<a name="ln9060">    sign_group = NULL;  // global sign group</a>
<a name="ln9061">  } else {</a>
<a name="ln9062">    sign_group = xstrdup(sign_group_chk);</a>
<a name="ln9063">  }</a>
<a name="ln9064"> </a>
<a name="ln9065">  // Buffer to place the sign</a>
<a name="ln9066">  buf = get_buf_arg(&amp;argvars[2]);</a>
<a name="ln9067">  if (buf == NULL) {</a>
<a name="ln9068">    goto cleanup;</a>
<a name="ln9069">  }</a>
<a name="ln9070"> </a>
<a name="ln9071">  rettv-&gt;vval.v_number = sign_jump(sign_id, (char_u *)sign_group, buf);</a>
<a name="ln9072"> </a>
<a name="ln9073">cleanup:</a>
<a name="ln9074">  xfree(sign_group);</a>
<a name="ln9075">}</a>
<a name="ln9076"> </a>
<a name="ln9077">/// &quot;sign_place()&quot; function</a>
<a name="ln9078">static void f_sign_place(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9079">{</a>
<a name="ln9080">  dict_T *dict = NULL;</a>
<a name="ln9081"> </a>
<a name="ln9082">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9083"> </a>
<a name="ln9084">  if (argvars[4].v_type != VAR_UNKNOWN</a>
<a name="ln9085">      &amp;&amp; (argvars[4].v_type != VAR_DICT</a>
<a name="ln9086">          || ((dict = argvars[4].vval.v_dict) == NULL))) {</a>
<a name="ln9087">    EMSG(_(e_dictreq));</a>
<a name="ln9088">    return;</a>
<a name="ln9089">  }</a>
<a name="ln9090"> </a>
<a name="ln9091">  rettv-&gt;vval.v_number = sign_place_from_dict(</a>
<a name="ln9092">      &amp;argvars[0], &amp;argvars[1], &amp;argvars[2], &amp;argvars[3], dict);</a>
<a name="ln9093">}</a>
<a name="ln9094"> </a>
<a name="ln9095">/// &quot;sign_placelist()&quot; function.  Place multiple signs.</a>
<a name="ln9096">static void f_sign_placelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9097">{</a>
<a name="ln9098">  int sign_id;</a>
<a name="ln9099"> </a>
<a name="ln9100">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9101"> </a>
<a name="ln9102">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln9103">    EMSG(_(e_listreq));</a>
<a name="ln9104">    return;</a>
<a name="ln9105">  }</a>
<a name="ln9106"> </a>
<a name="ln9107">  // Process the List of sign attributes</a>
<a name="ln9108">  TV_LIST_ITER_CONST(argvars[0].vval.v_list, li, {</a>
<a name="ln9109">    sign_id = -1;</a>
<a name="ln9110">    if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_DICT) {</a>
<a name="ln9111">      sign_id = sign_place_from_dict(</a>
<a name="ln9112">          NULL, NULL, NULL, NULL, TV_LIST_ITEM_TV(li)-&gt;vval.v_dict);</a>
<a name="ln9113">    } else {</a>
<a name="ln9114">      EMSG(_(e_dictreq));</a>
<a name="ln9115">    }</a>
<a name="ln9116">    tv_list_append_number(rettv-&gt;vval.v_list, sign_id);</a>
<a name="ln9117">  });</a>
<a name="ln9118">}</a>
<a name="ln9119"> </a>
<a name="ln9120">/// &quot;sign_undefine()&quot; function</a>
<a name="ln9121">static void f_sign_undefine(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9122">{</a>
<a name="ln9123">  const char *name;</a>
<a name="ln9124"> </a>
<a name="ln9125">  if (argvars[0].v_type == VAR_LIST &amp;&amp; argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln9126">    // Undefine multiple signs</a>
<a name="ln9127">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9128"> </a>
<a name="ln9129">    sign_undefine_multiple(argvars[0].vval.v_list, rettv-&gt;vval.v_list);</a>
<a name="ln9130">    return;</a>
<a name="ln9131">  }</a>
<a name="ln9132"> </a>
<a name="ln9133">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9134"> </a>
<a name="ln9135">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln9136">    // Free all the signs</a>
<a name="ln9137">    free_signs();</a>
<a name="ln9138">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln9139">  } else {</a>
<a name="ln9140">    // Free only the specified sign</a>
<a name="ln9141">    name = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9142">    if (name == NULL) {</a>
<a name="ln9143">      return;</a>
<a name="ln9144">    }</a>
<a name="ln9145"> </a>
<a name="ln9146">    if (sign_undefine_by_name((const char_u *)name) == OK) {</a>
<a name="ln9147">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln9148">    }</a>
<a name="ln9149">  }</a>
<a name="ln9150">}</a>
<a name="ln9151"> </a>
<a name="ln9152">/// &quot;sign_unplace()&quot; function</a>
<a name="ln9153">static void f_sign_unplace(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9154">{</a>
<a name="ln9155">  dict_T *dict = NULL;</a>
<a name="ln9156"> </a>
<a name="ln9157">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln9158"> </a>
<a name="ln9159">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln9160">    EMSG(_(e_invarg));</a>
<a name="ln9161">    return;</a>
<a name="ln9162">  }</a>
<a name="ln9163"> </a>
<a name="ln9164">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9165">    if (argvars[1].v_type != VAR_DICT) {</a>
<a name="ln9166">      EMSG(_(e_dictreq));</a>
<a name="ln9167">      return;</a>
<a name="ln9168">    }</a>
<a name="ln9169">    dict = argvars[1].vval.v_dict;</a>
<a name="ln9170">  }</a>
<a name="ln9171"> </a>
<a name="ln9172">  rettv-&gt;vval.v_number = sign_unplace_from_dict(&amp;argvars[0], dict);</a>
<a name="ln9173">}</a>
<a name="ln9174"> </a>
<a name="ln9175">/// &quot;sign_unplacelist()&quot; function</a>
<a name="ln9176">static void f_sign_unplacelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9177">{</a>
<a name="ln9178">  int retval;</a>
<a name="ln9179"> </a>
<a name="ln9180">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9181"> </a>
<a name="ln9182">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln9183">    EMSG(_(e_listreq));</a>
<a name="ln9184">    return;</a>
<a name="ln9185">  }</a>
<a name="ln9186"> </a>
<a name="ln9187">  TV_LIST_ITER_CONST(argvars[0].vval.v_list, li, {</a>
<a name="ln9188">    retval = -1;</a>
<a name="ln9189">    if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_DICT) {</a>
<a name="ln9190">      retval = sign_unplace_from_dict(NULL, TV_LIST_ITEM_TV(li)-&gt;vval.v_dict);</a>
<a name="ln9191">    } else {</a>
<a name="ln9192">      EMSG(_(e_dictreq));</a>
<a name="ln9193">    }</a>
<a name="ln9194">    tv_list_append_number(rettv-&gt;vval.v_list, retval);</a>
<a name="ln9195">  });</a>
<a name="ln9196">}</a>
<a name="ln9197"> </a>
<a name="ln9198">/*</a>
<a name="ln9199"> * &quot;simplify()&quot; function</a>
<a name="ln9200"> */</a>
<a name="ln9201">static void f_simplify(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9202">{</a>
<a name="ln9203">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9204">  rettv-&gt;vval.v_string = (char_u *)xstrdup(p);</a>
<a name="ln9205">  simplify_filename(rettv-&gt;vval.v_string);  // Simplify in place.</a>
<a name="ln9206">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9207">}</a>
<a name="ln9208"> </a>
<a name="ln9209">/// &quot;sockconnect()&quot; function</a>
<a name="ln9210">static void f_sockconnect(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9211">{</a>
<a name="ln9212">  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {</a>
<a name="ln9213">    EMSG(_(e_invarg));</a>
<a name="ln9214">    return;</a>
<a name="ln9215">  }</a>
<a name="ln9216">  if (argvars[2].v_type != VAR_DICT &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9217">    // Wrong argument types</a>
<a name="ln9218">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln9219">    return;</a>
<a name="ln9220">  }</a>
<a name="ln9221"> </a>
<a name="ln9222">  const char *mode = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9223">  const char *address = tv_get_string(&amp;argvars[1]);</a>
<a name="ln9224"> </a>
<a name="ln9225">  bool tcp;</a>
<a name="ln9226">  if (strcmp(mode, &quot;tcp&quot;) == 0) {</a>
<a name="ln9227">    tcp = true;</a>
<a name="ln9228">  } else if (strcmp(mode, &quot;pipe&quot;) == 0) {</a>
<a name="ln9229">    tcp = false;</a>
<a name="ln9230">  } else {</a>
<a name="ln9231">    EMSG2(_(e_invarg2), &quot;invalid mode&quot;);</a>
<a name="ln9232">    return;</a>
<a name="ln9233">  }</a>
<a name="ln9234"> </a>
<a name="ln9235">  bool rpc = false;</a>
<a name="ln9236">  CallbackReader on_data = CALLBACK_READER_INIT;</a>
<a name="ln9237">  if (argvars[2].v_type == VAR_DICT) {</a>
<a name="ln9238">    dict_T *opts = argvars[2].vval.v_dict;</a>
<a name="ln9239">    rpc = tv_dict_get_number(opts, &quot;rpc&quot;) != 0;</a>
<a name="ln9240"> </a>
<a name="ln9241">    if (!tv_dict_get_callback(opts, S_LEN(&quot;on_data&quot;), &amp;on_data.cb)) {</a>
<a name="ln9242">      return;</a>
<a name="ln9243">    }</a>
<a name="ln9244">    on_data.buffered = tv_dict_get_number(opts, &quot;data_buffered&quot;);</a>
<a name="ln9245">    if (on_data.buffered &amp;&amp; on_data.cb.type == kCallbackNone) {</a>
<a name="ln9246">      on_data.self = opts;</a>
<a name="ln9247">    }</a>
<a name="ln9248">  }</a>
<a name="ln9249"> </a>
<a name="ln9250">  const char *error = NULL;</a>
<a name="ln9251">  uint64_t id = channel_connect(tcp, address, rpc, on_data, 50, &amp;error);</a>
<a name="ln9252"> </a>
<a name="ln9253">  if (error) {</a>
<a name="ln9254">    EMSG2(_(&quot;connection failed: %s&quot;), error);</a>
<a name="ln9255">  }</a>
<a name="ln9256"> </a>
<a name="ln9257">  rettv-&gt;vval.v_number = (varnumber_T)id;</a>
<a name="ln9258">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln9259">}</a>
<a name="ln9260"> </a>
<a name="ln9261">/// struct storing information about current sort</a>
<a name="ln9262">typedef struct {</a>
<a name="ln9263">  int item_compare_ic;</a>
<a name="ln9264">  bool item_compare_lc;</a>
<a name="ln9265">  bool item_compare_numeric;</a>
<a name="ln9266">  bool item_compare_numbers;</a>
<a name="ln9267">  bool item_compare_float;</a>
<a name="ln9268">  const char *item_compare_func;</a>
<a name="ln9269">  partial_T *item_compare_partial;</a>
<a name="ln9270">  dict_T *item_compare_selfdict;</a>
<a name="ln9271">  bool item_compare_func_err;</a>
<a name="ln9272">} sortinfo_T;</a>
<a name="ln9273">static sortinfo_T *sortinfo = NULL;</a>
<a name="ln9274"> </a>
<a name="ln9275">#define ITEM_COMPARE_FAIL 999</a>
<a name="ln9276"> </a>
<a name="ln9277">/*</a>
<a name="ln9278"> * Compare functions for f_sort() and f_uniq() below.</a>
<a name="ln9279"> */</a>
<a name="ln9280">static int item_compare(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln9281">{</a>
<a name="ln9282">  ListSortItem *const si1 = (ListSortItem *)s1;</a>
<a name="ln9283">  ListSortItem *const si2 = (ListSortItem *)s2;</a>
<a name="ln9284"> </a>
<a name="ln9285">  typval_T *const tv1 = TV_LIST_ITEM_TV(si1-&gt;item);</a>
<a name="ln9286">  typval_T *const tv2 = TV_LIST_ITEM_TV(si2-&gt;item);</a>
<a name="ln9287"> </a>
<a name="ln9288">  int res;</a>
<a name="ln9289"> </a>
<a name="ln9290">  if (sortinfo-&gt;item_compare_numbers) {</a>
<a name="ln9291">    const varnumber_T v1 = tv_get_number(tv1);</a>
<a name="ln9292">    const varnumber_T v2 = tv_get_number(tv2);</a>
<a name="ln9293"> </a>
<a name="ln9294">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln9295">    goto item_compare_end;</a>
<a name="ln9296">  }</a>
<a name="ln9297"> </a>
<a name="ln9298">  if (sortinfo-&gt;item_compare_float) {</a>
<a name="ln9299">    const float_T v1 = tv_get_float(tv1);</a>
<a name="ln9300">    const float_T v2 = tv_get_float(tv2);</a>
<a name="ln9301"> </a>
<a name="ln9302">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln9303">    goto item_compare_end;</a>
<a name="ln9304">  }</a>
<a name="ln9305"> </a>
<a name="ln9306">  char *tofree1 = NULL;</a>
<a name="ln9307">  char *tofree2 = NULL;</a>
<a name="ln9308">  char *p1;</a>
<a name="ln9309">  char *p2;</a>
<a name="ln9310"> </a>
<a name="ln9311">  // encode_tv2string() puts quotes around a string and allocates memory.  Don't</a>
<a name="ln9312">  // do that for string variables. Use a single quote when comparing with</a>
<a name="ln9313">  // a non-string to do what the docs promise.</a>
<a name="ln9314">  if (tv1-&gt;v_type == VAR_STRING) {</a>
<a name="ln9315">    if (tv2-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9316">      p1 = &quot;'&quot;;</a>
<a name="ln9317">    } else {</a>
<a name="ln9318">      p1 = (char *)tv1-&gt;vval.v_string;</a>
<a name="ln9319">    }</a>
<a name="ln9320">  } else {</a>
<a name="ln9321">    tofree1 = p1 = encode_tv2string(tv1, NULL);</a>
<a name="ln9322">  }</a>
<a name="ln9323">  if (tv2-&gt;v_type == VAR_STRING) {</a>
<a name="ln9324">    if (tv1-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9325">      p2 = &quot;'&quot;;</a>
<a name="ln9326">    } else {</a>
<a name="ln9327">      p2 = (char *)tv2-&gt;vval.v_string;</a>
<a name="ln9328">    }</a>
<a name="ln9329">  } else {</a>
<a name="ln9330">    tofree2 = p2 = encode_tv2string(tv2, NULL);</a>
<a name="ln9331">  }</a>
<a name="ln9332">  if (p1 == NULL) {</a>
<a name="ln9333">    p1 = &quot;&quot;;</a>
<a name="ln9334">  }</a>
<a name="ln9335">  if (p2 == NULL) {</a>
<a name="ln9336">    p2 = &quot;&quot;;</a>
<a name="ln9337">  }</a>
<a name="ln9338">  if (!sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln9339">    if (sortinfo-&gt;item_compare_lc) {</a>
<a name="ln9340">      res = strcoll(p1, p2);</a>
<a name="ln9341">    } else {</a>
<a name="ln9342">      res = sortinfo-&gt;item_compare_ic ? STRICMP(p1, p2): STRCMP(p1, p2);</a>
<a name="ln9343">    }</a>
<a name="ln9344">  } else {</a>
<a name="ln9345">    double n1, n2;</a>
<a name="ln9346">    n1 = strtod(p1, &amp;p1);</a>
<a name="ln9347">    n2 = strtod(p2, &amp;p2);</a>
<a name="ln9348">    res = n1 == n2 ? 0 : n1 &gt; n2 ? 1 : -1;</a>
<a name="ln9349">  }</a>
<a name="ln9350"> </a>
<a name="ln9351">  xfree(tofree1);</a>
<a name="ln9352">  xfree(tofree2);</a>
<a name="ln9353"> </a>
<a name="ln9354">item_compare_end:</a>
<a name="ln9355">  // When the result would be zero, compare the item indexes.  Makes the</a>
<a name="ln9356">  // sort stable.</a>
<a name="ln9357">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln9358">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln9359">    // indexes are there.</a>
<a name="ln9360">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln9361">  }</a>
<a name="ln9362">  return res;</a>
<a name="ln9363">}</a>
<a name="ln9364"> </a>
<a name="ln9365">static int item_compare_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9366">{</a>
<a name="ln9367">  return item_compare(s1, s2, true);</a>
<a name="ln9368">}</a>
<a name="ln9369"> </a>
<a name="ln9370">static int item_compare_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9371">{</a>
<a name="ln9372">  return item_compare(s1, s2, false);</a>
<a name="ln9373">}</a>
<a name="ln9374"> </a>
<a name="ln9375">static int item_compare2(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln9376">{</a>
<a name="ln9377">  ListSortItem *si1, *si2;</a>
<a name="ln9378">  int res;</a>
<a name="ln9379">  typval_T rettv;</a>
<a name="ln9380">  typval_T argv[3];</a>
<a name="ln9381">  int dummy;</a>
<a name="ln9382">  const char *func_name;</a>
<a name="ln9383">  partial_T *partial = sortinfo-&gt;item_compare_partial;</a>
<a name="ln9384"> </a>
<a name="ln9385">  // shortcut after failure in previous call; compare all items equal</a>
<a name="ln9386">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln9387">    return 0;</a>
<a name="ln9388">  }</a>
<a name="ln9389"> </a>
<a name="ln9390">  si1 = (ListSortItem *)s1;</a>
<a name="ln9391">  si2 = (ListSortItem *)s2;</a>
<a name="ln9392"> </a>
<a name="ln9393">  if (partial == NULL) {</a>
<a name="ln9394">    func_name = sortinfo-&gt;item_compare_func;</a>
<a name="ln9395">  } else {</a>
<a name="ln9396">    func_name = (const char *)partial_name(partial);</a>
<a name="ln9397">  }</a>
<a name="ln9398"> </a>
<a name="ln9399">  // Copy the values.  This is needed to be able to set v_lock to VAR_FIXED</a>
<a name="ln9400">  // in the copy without changing the original list items.</a>
<a name="ln9401">  tv_copy(TV_LIST_ITEM_TV(si1-&gt;item), &amp;argv[0]);</a>
<a name="ln9402">  tv_copy(TV_LIST_ITEM_TV(si2-&gt;item), &amp;argv[1]);</a>
<a name="ln9403"> </a>
<a name="ln9404">  rettv.v_type = VAR_UNKNOWN;  // tv_clear() uses this</a>
<a name="ln9405">  res = call_func((const char_u *)func_name,</a>
<a name="ln9406">                  -1,</a>
<a name="ln9407">                  &amp;rettv, 2, argv, NULL, 0L, 0L, &amp;dummy, true,</a>
<a name="ln9408">                  partial, sortinfo-&gt;item_compare_selfdict);</a>
<a name="ln9409">  tv_clear(&amp;argv[0]);</a>
<a name="ln9410">  tv_clear(&amp;argv[1]);</a>
<a name="ln9411"> </a>
<a name="ln9412">  if (res == FAIL) {</a>
<a name="ln9413">    res = ITEM_COMPARE_FAIL;</a>
<a name="ln9414">  } else {</a>
<a name="ln9415">    res = tv_get_number_chk(&amp;rettv, &amp;sortinfo-&gt;item_compare_func_err);</a>
<a name="ln9416">  }</a>
<a name="ln9417">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln9418">    res = ITEM_COMPARE_FAIL;  // return value has wrong type</a>
<a name="ln9419">  }</a>
<a name="ln9420">  tv_clear(&amp;rettv);</a>
<a name="ln9421"> </a>
<a name="ln9422">  // When the result would be zero, compare the pointers themselves.  Makes</a>
<a name="ln9423">  // the sort stable.</a>
<a name="ln9424">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln9425">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln9426">    // indexes are there.</a>
<a name="ln9427">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln9428">  }</a>
<a name="ln9429"> </a>
<a name="ln9430">  return res;</a>
<a name="ln9431">}</a>
<a name="ln9432"> </a>
<a name="ln9433">static int item_compare2_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9434">{</a>
<a name="ln9435">  return item_compare2(s1, s2, true);</a>
<a name="ln9436">}</a>
<a name="ln9437"> </a>
<a name="ln9438">static int item_compare2_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln9439">{</a>
<a name="ln9440">  return item_compare2(s1, s2, false);</a>
<a name="ln9441">}</a>
<a name="ln9442"> </a>
<a name="ln9443">/*</a>
<a name="ln9444"> * &quot;sort({list})&quot; function</a>
<a name="ln9445"> */</a>
<a name="ln9446">static void do_sort_uniq(typval_T *argvars, typval_T *rettv, bool sort)</a>
<a name="ln9447">{</a>
<a name="ln9448">  ListSortItem  *ptrs;</a>
<a name="ln9449">  long len;</a>
<a name="ln9450">  long i;</a>
<a name="ln9451"> </a>
<a name="ln9452">  // Pointer to current info struct used in compare function. Save and restore</a>
<a name="ln9453">  // the current one for nested calls.</a>
<a name="ln9454">  sortinfo_T info;</a>
<a name="ln9455">  sortinfo_T *old_sortinfo = sortinfo;</a>
<a name="ln9456">  sortinfo = &amp;info;</a>
<a name="ln9457"> </a>
<a name="ln9458">  const char *const arg_errmsg = (sort</a>
<a name="ln9459">                                  ? N_(&quot;sort() argument&quot;)</a>
<a name="ln9460">                                  : N_(&quot;uniq() argument&quot;));</a>
<a name="ln9461"> </a>
<a name="ln9462">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln9463">    EMSG2(_(e_listarg), sort ? &quot;sort()&quot; : &quot;uniq()&quot;);</a>
<a name="ln9464">  } else {</a>
<a name="ln9465">    list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln9466">    if (var_check_lock(tv_list_locked(l), arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln9467">      goto theend;</a>
<a name="ln9468">    }</a>
<a name="ln9469">    tv_list_set_ret(rettv, l);</a>
<a name="ln9470"> </a>
<a name="ln9471">    len = tv_list_len(l);</a>
<a name="ln9472">    if (len &lt;= 1) {</a>
<a name="ln9473">      goto theend;  // short list sorts pretty quickly</a>
<a name="ln9474">    }</a>
<a name="ln9475"> </a>
<a name="ln9476">    info.item_compare_ic = false;</a>
<a name="ln9477">    info.item_compare_lc = false;</a>
<a name="ln9478">    info.item_compare_numeric = false;</a>
<a name="ln9479">    info.item_compare_numbers = false;</a>
<a name="ln9480">    info.item_compare_float = false;</a>
<a name="ln9481">    info.item_compare_func = NULL;</a>
<a name="ln9482">    info.item_compare_partial = NULL;</a>
<a name="ln9483">    info.item_compare_selfdict = NULL;</a>
<a name="ln9484"> </a>
<a name="ln9485">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9486">      // optional second argument: {func}</a>
<a name="ln9487">      if (argvars[1].v_type == VAR_FUNC) {</a>
<a name="ln9488">        info.item_compare_func = (const char *)argvars[1].vval.v_string;</a>
<a name="ln9489">      } else if (argvars[1].v_type == VAR_PARTIAL) {</a>
<a name="ln9490">        info.item_compare_partial = argvars[1].vval.v_partial;</a>
<a name="ln9491">      } else {</a>
<a name="ln9492">        bool error = false;</a>
<a name="ln9493"> </a>
<a name="ln9494">        i = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln9495">        if (error) {</a>
<a name="ln9496">          goto theend;  // type error; errmsg already given</a>
<a name="ln9497">        }</a>
<a name="ln9498">        if (i == 1) {</a>
<a name="ln9499">          info.item_compare_ic = true;</a>
<a name="ln9500">        } else if (argvars[1].v_type != VAR_NUMBER) {</a>
<a name="ln9501">          info.item_compare_func = tv_get_string(&amp;argvars[1]);</a>
<a name="ln9502">        } else if (i != 0) {</a>
<a name="ln9503">          EMSG(_(e_invarg));</a>
<a name="ln9504">          goto theend;</a>
<a name="ln9505">        }</a>
<a name="ln9506">        if (info.item_compare_func != NULL) {</a>
<a name="ln9507">          if (*info.item_compare_func == NUL) {</a>
<a name="ln9508">            // empty string means default sort</a>
<a name="ln9509">            info.item_compare_func = NULL;</a>
<a name="ln9510">          } else if (strcmp(info.item_compare_func, &quot;n&quot;) == 0) {</a>
<a name="ln9511">            info.item_compare_func = NULL;</a>
<a name="ln9512">            info.item_compare_numeric = true;</a>
<a name="ln9513">          } else if (strcmp(info.item_compare_func, &quot;N&quot;) == 0) {</a>
<a name="ln9514">            info.item_compare_func = NULL;</a>
<a name="ln9515">            info.item_compare_numbers = true;</a>
<a name="ln9516">          } else if (strcmp(info.item_compare_func, &quot;f&quot;) == 0) {</a>
<a name="ln9517">            info.item_compare_func = NULL;</a>
<a name="ln9518">            info.item_compare_float = true;</a>
<a name="ln9519">          } else if (strcmp(info.item_compare_func, &quot;i&quot;) == 0) {</a>
<a name="ln9520">            info.item_compare_func = NULL;</a>
<a name="ln9521">            info.item_compare_ic = true;</a>
<a name="ln9522">          } else if (strcmp(info.item_compare_func, &quot;l&quot;) == 0) {</a>
<a name="ln9523">            info.item_compare_func = NULL;</a>
<a name="ln9524">            info.item_compare_lc = true;</a>
<a name="ln9525">          }</a>
<a name="ln9526">        }</a>
<a name="ln9527">      }</a>
<a name="ln9528"> </a>
<a name="ln9529">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9530">        // optional third argument: {dict}</a>
<a name="ln9531">        if (argvars[2].v_type != VAR_DICT) {</a>
<a name="ln9532">          EMSG(_(e_dictreq));</a>
<a name="ln9533">          goto theend;</a>
<a name="ln9534">        }</a>
<a name="ln9535">        info.item_compare_selfdict = argvars[2].vval.v_dict;</a>
<a name="ln9536">      }</a>
<a name="ln9537">    }</a>
<a name="ln9538"> </a>
<a name="ln9539">    // Make an array with each entry pointing to an item in the List.</a>
<a name="ln9540">    ptrs = xmalloc((size_t)(len * sizeof(ListSortItem)));</a>
<a name="ln9541"> </a>
<a name="ln9542">    if (sort) {</a>
<a name="ln9543">      info.item_compare_func_err = false;</a>
<a name="ln9544">      tv_list_item_sort(l, ptrs,</a>
<a name="ln9545">                        ((info.item_compare_func == NULL</a>
<a name="ln9546">                          &amp;&amp; info.item_compare_partial == NULL)</a>
<a name="ln9547">                         ? item_compare_not_keeping_zero</a>
<a name="ln9548">                         : item_compare2_not_keeping_zero),</a>
<a name="ln9549">                        &amp;info.item_compare_func_err);</a>
<a name="ln9550">      if (info.item_compare_func_err) {</a>
<a name="ln9551">        EMSG(_(&quot;E702: Sort compare function failed&quot;));</a>
<a name="ln9552">      }</a>
<a name="ln9553">    } else {</a>
<a name="ln9554">      ListSorter item_compare_func_ptr;</a>
<a name="ln9555"> </a>
<a name="ln9556">      // f_uniq(): ptrs will be a stack of items to remove.</a>
<a name="ln9557">      info.item_compare_func_err = false;</a>
<a name="ln9558">      if (info.item_compare_func != NULL</a>
<a name="ln9559">          || info.item_compare_partial != NULL) {</a>
<a name="ln9560">        item_compare_func_ptr = item_compare2_keeping_zero;</a>
<a name="ln9561">      } else {</a>
<a name="ln9562">        item_compare_func_ptr = item_compare_keeping_zero;</a>
<a name="ln9563">      }</a>
<a name="ln9564"> </a>
<a name="ln9565">      int idx = 0;</a>
<a name="ln9566">      for (listitem_T *li = TV_LIST_ITEM_NEXT(l, tv_list_first(l))</a>
<a name="ln9567">           ; li != NULL;) {</a>
<a name="ln9568">        listitem_T *const prev_li = TV_LIST_ITEM_PREV(l, li);</a>
<a name="ln9569">        if (item_compare_func_ptr(&amp;prev_li, &amp;li) == 0) {</a>
<a name="ln9570">          if (info.item_compare_func_err) {  // -V547</a>
<a name="ln9571">            EMSG(_(&quot;E882: Uniq compare function failed&quot;));</a>
<a name="ln9572">            break;</a>
<a name="ln9573">          }</a>
<a name="ln9574">          li = tv_list_item_remove(l, li);</a>
<a name="ln9575">        } else {</a>
<a name="ln9576">          idx++;</a>
<a name="ln9577">          li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln9578">        }</a>
<a name="ln9579">      }</a>
<a name="ln9580">    }</a>
<a name="ln9581"> </a>
<a name="ln9582">    xfree(ptrs);</a>
<a name="ln9583">  }</a>
<a name="ln9584"> </a>
<a name="ln9585">theend:</a>
<a name="ln9586">  sortinfo = old_sortinfo;</a>
<a name="ln9587">}</a>
<a name="ln9588"> </a>
<a name="ln9589">/// &quot;sort&quot;({list})&quot; function</a>
<a name="ln9590">static void f_sort(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9591">{</a>
<a name="ln9592">  do_sort_uniq(argvars, rettv, true);</a>
<a name="ln9593">}</a>
<a name="ln9594"> </a>
<a name="ln9595">/// &quot;stdioopen()&quot; function</a>
<a name="ln9596">static void f_stdioopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9597">{</a>
<a name="ln9598">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln9599">    EMSG(_(e_invarg));</a>
<a name="ln9600">    return;</a>
<a name="ln9601">  }</a>
<a name="ln9602"> </a>
<a name="ln9603"> </a>
<a name="ln9604">  bool rpc = false;</a>
<a name="ln9605">  CallbackReader on_stdin = CALLBACK_READER_INIT;</a>
<a name="ln9606">  dict_T *opts = argvars[0].vval.v_dict;</a>
<a name="ln9607">  rpc = tv_dict_get_number(opts, &quot;rpc&quot;) != 0;</a>
<a name="ln9608"> </a>
<a name="ln9609">  if (!tv_dict_get_callback(opts, S_LEN(&quot;on_stdin&quot;), &amp;on_stdin.cb)) {</a>
<a name="ln9610">    return;</a>
<a name="ln9611">  }</a>
<a name="ln9612">  on_stdin.buffered = tv_dict_get_number(opts, &quot;stdin_buffered&quot;);</a>
<a name="ln9613">  if (on_stdin.buffered &amp;&amp; on_stdin.cb.type == kCallbackNone) {</a>
<a name="ln9614">    on_stdin.self = opts;</a>
<a name="ln9615">  }</a>
<a name="ln9616"> </a>
<a name="ln9617">  const char *error;</a>
<a name="ln9618">  uint64_t id = channel_from_stdio(rpc, on_stdin, &amp;error);</a>
<a name="ln9619">  if (!id) {</a>
<a name="ln9620">    EMSG2(e_stdiochan2, error);</a>
<a name="ln9621">  }</a>
<a name="ln9622"> </a>
<a name="ln9623"> </a>
<a name="ln9624">  rettv-&gt;vval.v_number = (varnumber_T)id;</a>
<a name="ln9625">  rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln9626">}</a>
<a name="ln9627"> </a>
<a name="ln9628">/// &quot;uniq({list})&quot; function</a>
<a name="ln9629">static void f_uniq(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9630">{</a>
<a name="ln9631">  do_sort_uniq(argvars, rettv, false);</a>
<a name="ln9632">}</a>
<a name="ln9633"> </a>
<a name="ln9634">// &quot;reltimefloat()&quot; function</a>
<a name="ln9635">static void f_reltimefloat(typval_T *argvars , typval_T *rettv, FunPtr fptr)</a>
<a name="ln9636">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln9637">{</a>
<a name="ln9638">  proftime_T tm;</a>
<a name="ln9639"> </a>
<a name="ln9640">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln9641">  rettv-&gt;vval.v_float = 0;</a>
<a name="ln9642">  if (list2proftime(&amp;argvars[0], &amp;tm) == OK) {</a>
<a name="ln9643">    rettv-&gt;vval.v_float = (float_T)profile_signed(tm) / 1000000000.0;</a>
<a name="ln9644">  }</a>
<a name="ln9645">}</a>
<a name="ln9646"> </a>
<a name="ln9647">/*</a>
<a name="ln9648"> * &quot;soundfold({word})&quot; function</a>
<a name="ln9649"> */</a>
<a name="ln9650">static void f_soundfold(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9651">{</a>
<a name="ln9652">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9653">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9654">  rettv-&gt;vval.v_string = (char_u *)eval_soundfold(s);</a>
<a name="ln9655">}</a>
<a name="ln9656"> </a>
<a name="ln9657">/*</a>
<a name="ln9658"> * &quot;spellbadword()&quot; function</a>
<a name="ln9659"> */</a>
<a name="ln9660">static void f_spellbadword(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9661">{</a>
<a name="ln9662">  const char *word = &quot;&quot;;</a>
<a name="ln9663">  hlf_T attr = HLF_COUNT;</a>
<a name="ln9664">  size_t len = 0;</a>
<a name="ln9665">  const int wo_spell_save = curwin-&gt;w_p_spell;</a>
<a name="ln9666"> </a>
<a name="ln9667">  if (!curwin-&gt;w_p_spell) {</a>
<a name="ln9668">    did_set_spelllang(curwin);</a>
<a name="ln9669">    curwin-&gt;w_p_spell = true;</a>
<a name="ln9670">  }</a>
<a name="ln9671"> </a>
<a name="ln9672">  if (*curwin-&gt;w_s-&gt;b_p_spl == NUL) {</a>
<a name="ln9673">    EMSG(_(e_no_spell));</a>
<a name="ln9674">    curwin-&gt;w_p_spell = wo_spell_save;</a>
<a name="ln9675">    return;</a>
<a name="ln9676">  }</a>
<a name="ln9677"> </a>
<a name="ln9678">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln9679">    // Find the start and length of the badly spelled word.</a>
<a name="ln9680">    len = spell_move_to(curwin, FORWARD, true, true, &amp;attr);</a>
<a name="ln9681">    if (len != 0) {</a>
<a name="ln9682">      word = (char *)get_cursor_pos_ptr();</a>
<a name="ln9683">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln9684">    }</a>
<a name="ln9685">  } else if (*curbuf-&gt;b_s.b_p_spl != NUL) {</a>
<a name="ln9686">    const char *str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9687">    int capcol = -1;</a>
<a name="ln9688"> </a>
<a name="ln9689">    if (str != NULL) {</a>
<a name="ln9690">      // Check the argument for spelling.</a>
<a name="ln9691">      while (*str != NUL) {</a>
<a name="ln9692">        len = spell_check(curwin, (char_u *)str, &amp;attr, &amp;capcol, false);</a>
<a name="ln9693">        if (attr != HLF_COUNT) {</a>
<a name="ln9694">          word = str;</a>
<a name="ln9695">          break;</a>
<a name="ln9696">        }</a>
<a name="ln9697">        str += len;</a>
<a name="ln9698">        capcol -= len;</a>
<a name="ln9699">        len = 0;</a>
<a name="ln9700">      }</a>
<a name="ln9701">    }</a>
<a name="ln9702">  }</a>
<a name="ln9703">  curwin-&gt;w_p_spell = wo_spell_save;</a>
<a name="ln9704"> </a>
<a name="ln9705">  assert(len &lt;= INT_MAX);</a>
<a name="ln9706">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln9707">  tv_list_append_string(rettv-&gt;vval.v_list, word, len);</a>
<a name="ln9708">  tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln9709">                        (attr == HLF_SPB ? &quot;bad&quot;</a>
<a name="ln9710">                         : attr == HLF_SPR ? &quot;rare&quot;</a>
<a name="ln9711">                         : attr == HLF_SPL ? &quot;local&quot;</a>
<a name="ln9712">                         : attr == HLF_SPC ? &quot;caps&quot;</a>
<a name="ln9713">                         : NULL), -1);</a>
<a name="ln9714">}</a>
<a name="ln9715"> </a>
<a name="ln9716">/*</a>
<a name="ln9717"> * &quot;spellsuggest()&quot; function</a>
<a name="ln9718"> */</a>
<a name="ln9719">static void f_spellsuggest(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9720">{</a>
<a name="ln9721">  bool typeerr = false;</a>
<a name="ln9722">  int maxcount;</a>
<a name="ln9723">  garray_T ga = GA_EMPTY_INIT_VALUE;</a>
<a name="ln9724">  bool need_capital = false;</a>
<a name="ln9725">  const int wo_spell_save = curwin-&gt;w_p_spell;</a>
<a name="ln9726"> </a>
<a name="ln9727">  if (!curwin-&gt;w_p_spell) {</a>
<a name="ln9728">    did_set_spelllang(curwin);</a>
<a name="ln9729">    curwin-&gt;w_p_spell = true;</a>
<a name="ln9730">  }</a>
<a name="ln9731"> </a>
<a name="ln9732">  if (*curwin-&gt;w_s-&gt;b_p_spl == NUL) {</a>
<a name="ln9733">    EMSG(_(e_no_spell));</a>
<a name="ln9734">    curwin-&gt;w_p_spell = wo_spell_save;</a>
<a name="ln9735">    return;</a>
<a name="ln9736">  }</a>
<a name="ln9737"> </a>
<a name="ln9738">  if (*curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln9739">    const char *const str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9740">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9741">      maxcount = tv_get_number_chk(&amp;argvars[1], &amp;typeerr);</a>
<a name="ln9742">      if (maxcount &lt;= 0) {</a>
<a name="ln9743">        goto f_spellsuggest_return;</a>
<a name="ln9744">      }</a>
<a name="ln9745">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9746">        need_capital = tv_get_number_chk(&amp;argvars[2], &amp;typeerr);</a>
<a name="ln9747">        if (typeerr) {</a>
<a name="ln9748">          goto f_spellsuggest_return;</a>
<a name="ln9749">        }</a>
<a name="ln9750">      }</a>
<a name="ln9751">    } else {</a>
<a name="ln9752">      maxcount = 25;</a>
<a name="ln9753">    }</a>
<a name="ln9754"> </a>
<a name="ln9755">    spell_suggest_list(&amp;ga, (char_u *)str, maxcount, need_capital, false);</a>
<a name="ln9756">  }</a>
<a name="ln9757"> </a>
<a name="ln9758">f_spellsuggest_return:</a>
<a name="ln9759">  tv_list_alloc_ret(rettv, (ptrdiff_t)ga.ga_len);</a>
<a name="ln9760">  for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln9761">    char *const p = ((char **)ga.ga_data)[i];</a>
<a name="ln9762">    tv_list_append_allocated_string(rettv-&gt;vval.v_list, p);</a>
<a name="ln9763">  }</a>
<a name="ln9764">  ga_clear(&amp;ga);</a>
<a name="ln9765">  curwin-&gt;w_p_spell = wo_spell_save;</a>
<a name="ln9766">}</a>
<a name="ln9767"> </a>
<a name="ln9768">static void f_split(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9769">{</a>
<a name="ln9770">  char_u      *save_cpo;</a>
<a name="ln9771">  int match;</a>
<a name="ln9772">  colnr_T col = 0;</a>
<a name="ln9773">  bool keepempty = false;</a>
<a name="ln9774">  bool typeerr = false;</a>
<a name="ln9775"> </a>
<a name="ln9776">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln9777">  save_cpo = p_cpo;</a>
<a name="ln9778">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln9779"> </a>
<a name="ln9780">  const char *str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln9781">  const char *pat = NULL;</a>
<a name="ln9782">  char patbuf[NUMBUFLEN];</a>
<a name="ln9783">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9784">    pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln9785">    if (pat == NULL) {</a>
<a name="ln9786">      typeerr = true;</a>
<a name="ln9787">    }</a>
<a name="ln9788">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln9789">      keepempty = (bool)tv_get_number_chk(&amp;argvars[2], &amp;typeerr);</a>
<a name="ln9790">    }</a>
<a name="ln9791">  }</a>
<a name="ln9792">  if (pat == NULL || *pat == NUL) {</a>
<a name="ln9793">    pat = &quot;[\\x01- ]\\+&quot;;</a>
<a name="ln9794">  }</a>
<a name="ln9795"> </a>
<a name="ln9796">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln9797"> </a>
<a name="ln9798">  if (typeerr) {</a>
<a name="ln9799">    goto theend;</a>
<a name="ln9800">  }</a>
<a name="ln9801"> </a>
<a name="ln9802">  regmatch_T regmatch = {</a>
<a name="ln9803">    .regprog = vim_regcomp((char_u *)pat, RE_MAGIC + RE_STRING),</a>
<a name="ln9804">    .startp = { NULL },</a>
<a name="ln9805">    .endp = { NULL },</a>
<a name="ln9806">    .rm_ic = false,</a>
<a name="ln9807">  };</a>
<a name="ln9808">  if (regmatch.regprog != NULL) {</a>
<a name="ln9809">    while (*str != NUL || keepempty) {</a>
<a name="ln9810">      if (*str == NUL) {</a>
<a name="ln9811">        match = false;  // Empty item at the end.</a>
<a name="ln9812">      } else {</a>
<a name="ln9813">        match = vim_regexec_nl(&amp;regmatch, (char_u *)str, col);</a>
<a name="ln9814">      }</a>
<a name="ln9815">      const char *end;</a>
<a name="ln9816">      if (match) {</a>
<a name="ln9817">        end = (const char *)regmatch.startp[0];</a>
<a name="ln9818">      } else {</a>
<a name="ln9819">        end = str + strlen(str);</a>
<a name="ln9820">      }</a>
<a name="ln9821">      if (keepempty || end &gt; str || (tv_list_len(rettv-&gt;vval.v_list) &gt; 0</a>
<a name="ln9822">                                     &amp;&amp; *str != NUL</a>
<a name="ln9823">                                     &amp;&amp; match</a>
<a name="ln9824">                                     &amp;&amp; end &lt; (const char *)regmatch.endp[0])) {</a>
<a name="ln9825">        tv_list_append_string(rettv-&gt;vval.v_list, str, end - str);</a>
<a name="ln9826">      }</a>
<a name="ln9827">      if (!match) {</a>
<a name="ln9828">        break;</a>
<a name="ln9829">      }</a>
<a name="ln9830">      // Advance to just after the match.</a>
<a name="ln9831">      if (regmatch.endp[0] &gt; (char_u *)str) {</a>
<a name="ln9832">        col = 0;</a>
<a name="ln9833">      } else {</a>
<a name="ln9834">        // Don't get stuck at the same match.</a>
<a name="ln9835">        col = (*mb_ptr2len)(regmatch.endp[0]);</a>
<a name="ln9836">      }</a>
<a name="ln9837">      str = (const char *)regmatch.endp[0];</a>
<a name="ln9838">    }</a>
<a name="ln9839"> </a>
<a name="ln9840">    vim_regfree(regmatch.regprog);</a>
<a name="ln9841">  }</a>
<a name="ln9842"> </a>
<a name="ln9843">theend:</a>
<a name="ln9844">  p_cpo = save_cpo;</a>
<a name="ln9845">}</a>
<a name="ln9846"> </a>
<a name="ln9847">/// &quot;stdpath(type)&quot; function</a>
<a name="ln9848">static void f_stdpath(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9849">{</a>
<a name="ln9850">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9851">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln9852"> </a>
<a name="ln9853">  const char *const p = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln9854">  if (p == NULL) {</a>
<a name="ln9855">    return;  // Type error; errmsg already given.</a>
<a name="ln9856">  }</a>
<a name="ln9857"> </a>
<a name="ln9858">  if (strequal(p, &quot;config&quot;)) {</a>
<a name="ln9859">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGConfigHome);</a>
<a name="ln9860">  } else if (strequal(p, &quot;data&quot;)) {</a>
<a name="ln9861">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGDataHome);</a>
<a name="ln9862">  } else if (strequal(p, &quot;cache&quot;)) {</a>
<a name="ln9863">    rettv-&gt;vval.v_string = (char_u *)get_xdg_home(kXDGCacheHome);</a>
<a name="ln9864">  } else if (strequal(p, &quot;config_dirs&quot;)) {</a>
<a name="ln9865">    get_xdg_var_list(kXDGConfigDirs, rettv);</a>
<a name="ln9866">  } else if (strequal(p, &quot;data_dirs&quot;)) {</a>
<a name="ln9867">    get_xdg_var_list(kXDGDataDirs, rettv);</a>
<a name="ln9868">  } else {</a>
<a name="ln9869">    EMSG2(_(&quot;E6100: \&quot;%s\&quot; is not a valid stdpath&quot;), p);</a>
<a name="ln9870">  }</a>
<a name="ln9871">}</a>
<a name="ln9872"> </a>
<a name="ln9873">/*</a>
<a name="ln9874"> * &quot;str2float()&quot; function</a>
<a name="ln9875"> */</a>
<a name="ln9876">static void f_str2float(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9877">{</a>
<a name="ln9878">  char_u *p = skipwhite((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln9879">  bool isneg = (*p == '-');</a>
<a name="ln9880"> </a>
<a name="ln9881">  if (*p == '+' || *p == '-') {</a>
<a name="ln9882">    p = skipwhite(p + 1);</a>
<a name="ln9883">  }</a>
<a name="ln9884">  (void)string2float((char *)p, &amp;rettv-&gt;vval.v_float);</a>
<a name="ln9885">  if (isneg) {</a>
<a name="ln9886">    rettv-&gt;vval.v_float *= -1;</a>
<a name="ln9887">  }</a>
<a name="ln9888">  rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln9889">}</a>
<a name="ln9890"> </a>
<a name="ln9891">// &quot;str2list()&quot; function</a>
<a name="ln9892">static void f_str2list(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9893">{</a>
<a name="ln9894">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln9895">  const char_u *p = (const char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln9896"> </a>
<a name="ln9897">  for (; *p != NUL; p += utf_ptr2len(p)) {</a>
<a name="ln9898">    tv_list_append_number(rettv-&gt;vval.v_list, utf_ptr2char(p));</a>
<a name="ln9899">  }</a>
<a name="ln9900">}</a>
<a name="ln9901"> </a>
<a name="ln9902">// &quot;str2nr()&quot; function</a>
<a name="ln9903">static void f_str2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9904">{</a>
<a name="ln9905">  int base = 10;</a>
<a name="ln9906">  varnumber_T n;</a>
<a name="ln9907">  int what;</a>
<a name="ln9908"> </a>
<a name="ln9909">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln9910">    base = tv_get_number(&amp;argvars[1]);</a>
<a name="ln9911">    if (base != 2 &amp;&amp; base != 8 &amp;&amp; base != 10 &amp;&amp; base != 16) {</a>
<a name="ln9912">      EMSG(_(e_invarg));</a>
<a name="ln9913">      return;</a>
<a name="ln9914">    }</a>
<a name="ln9915">  }</a>
<a name="ln9916"> </a>
<a name="ln9917">  char_u *p = skipwhite((const char_u *)tv_get_string(&amp;argvars[0]));</a>
<a name="ln9918">  bool isneg = (*p == '-');</a>
<a name="ln9919">  if (*p == '+' || *p == '-') {</a>
<a name="ln9920">    p = skipwhite(p + 1);</a>
<a name="ln9921">  }</a>
<a name="ln9922">  switch (base) {</a>
<a name="ln9923">    case 2: {</a>
<a name="ln9924">      what = STR2NR_BIN | STR2NR_FORCE;</a>
<a name="ln9925">      break;</a>
<a name="ln9926">    }</a>
<a name="ln9927">    case 8: {</a>
<a name="ln9928">      what = STR2NR_OCT | STR2NR_FORCE;</a>
<a name="ln9929">      break;</a>
<a name="ln9930">    }</a>
<a name="ln9931">    case 16: {</a>
<a name="ln9932">      what = STR2NR_HEX | STR2NR_FORCE;</a>
<a name="ln9933">      break;</a>
<a name="ln9934">    }</a>
<a name="ln9935">    default: {</a>
<a name="ln9936">      what = 0;</a>
<a name="ln9937">    }</a>
<a name="ln9938">  }</a>
<a name="ln9939">  vim_str2nr(p, NULL, NULL, what, &amp;n, NULL, 0);</a>
<a name="ln9940">  if (isneg) {</a>
<a name="ln9941">    rettv-&gt;vval.v_number = -n;</a>
<a name="ln9942">  } else {</a>
<a name="ln9943">    rettv-&gt;vval.v_number = n;</a>
<a name="ln9944">  }</a>
<a name="ln9945">}</a>
<a name="ln9946"> </a>
<a name="ln9947">/*</a>
<a name="ln9948"> * &quot;strftime({format}[, {time}])&quot; function</a>
<a name="ln9949"> */</a>
<a name="ln9950">static void f_strftime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln9951">{</a>
<a name="ln9952">  time_t seconds;</a>
<a name="ln9953"> </a>
<a name="ln9954">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln9955"> </a>
<a name="ln9956">  char *p = (char *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln9957">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln9958">    seconds = time(NULL);</a>
<a name="ln9959">  } else {</a>
<a name="ln9960">    seconds = (time_t)tv_get_number(&amp;argvars[1]);</a>
<a name="ln9961">  }</a>
<a name="ln9962"> </a>
<a name="ln9963">  struct tm curtime;</a>
<a name="ln9964">  struct tm *curtime_ptr = os_localtime_r(&amp;seconds, &amp;curtime);</a>
<a name="ln9965">  // MSVC returns NULL for an invalid value of seconds.</a>
<a name="ln9966">  if (curtime_ptr == NULL) {</a>
<a name="ln9967">    rettv-&gt;vval.v_string = vim_strsave((char_u *)_(&quot;(Invalid)&quot;));</a>
<a name="ln9968">  } else {</a>
<a name="ln9969">    vimconv_T conv;</a>
<a name="ln9970">    char_u      *enc;</a>
<a name="ln9971"> </a>
<a name="ln9972">    conv.vc_type = CONV_NONE;</a>
<a name="ln9973">    enc = enc_locale();</a>
<a name="ln9974">    convert_setup(&amp;conv, p_enc, enc);</a>
<a name="ln9975">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9976">      p = (char *)string_convert(&amp;conv, (char_u *)p, NULL);</a>
<a name="ln9977">    }</a>
<a name="ln9978">    char result_buf[256];</a>
<a name="ln9979">    if (p != NULL) {</a>
<a name="ln9980">      (void)strftime(result_buf, sizeof(result_buf), p, curtime_ptr);</a>
<a name="ln9981">    } else {</a>
<a name="ln9982">      result_buf[0] = NUL;</a>
<a name="ln9983">    }</a>
<a name="ln9984"> </a>
<a name="ln9985">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9986">      xfree(p);</a>
<a name="ln9987">    }</a>
<a name="ln9988">    convert_setup(&amp;conv, enc, p_enc);</a>
<a name="ln9989">    if (conv.vc_type != CONV_NONE) {</a>
<a name="ln9990">      rettv-&gt;vval.v_string = string_convert(&amp;conv, (char_u *)result_buf, NULL);</a>
<a name="ln9991">    } else {</a>
<a name="ln9992">      rettv-&gt;vval.v_string = (char_u *)xstrdup(result_buf);</a>
<a name="ln9993">    }</a>
<a name="ln9994"> </a>
<a name="ln9995">    // Release conversion descriptors.</a>
<a name="ln9996">    convert_setup(&amp;conv, NULL, NULL);</a>
<a name="ln9997">    xfree(enc);</a>
<a name="ln9998">  }</a>
<a name="ln9999">}</a>
<a name="ln10000"> </a>
<a name="ln10001">// &quot;strgetchar()&quot; function</a>
<a name="ln10002">static void f_strgetchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10003">{</a>
<a name="ln10004">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln10005"> </a>
<a name="ln10006">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10007">  if (str == NULL) {</a>
<a name="ln10008">    return;</a>
<a name="ln10009">  }</a>
<a name="ln10010">  bool error = false;</a>
<a name="ln10011">  varnumber_T charidx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln10012">  if (error) {</a>
<a name="ln10013">    return;</a>
<a name="ln10014">  }</a>
<a name="ln10015"> </a>
<a name="ln10016">  const size_t len = STRLEN(str);</a>
<a name="ln10017">  size_t byteidx = 0;</a>
<a name="ln10018"> </a>
<a name="ln10019">  while (charidx &gt;= 0 &amp;&amp; byteidx &lt; len) {</a>
<a name="ln10020">    if (charidx == 0) {</a>
<a name="ln10021">      rettv-&gt;vval.v_number = utf_ptr2char((const char_u *)str + byteidx);</a>
<a name="ln10022">      break;</a>
<a name="ln10023">    }</a>
<a name="ln10024">    charidx--;</a>
<a name="ln10025">    byteidx += MB_CPTR2LEN((const char_u *)str + byteidx);</a>
<a name="ln10026">  }</a>
<a name="ln10027">}</a>
<a name="ln10028"> </a>
<a name="ln10029">/*</a>
<a name="ln10030"> * &quot;stridx()&quot; function</a>
<a name="ln10031"> */</a>
<a name="ln10032">static void f_stridx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10033">{</a>
<a name="ln10034">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln10035"> </a>
<a name="ln10036">  char buf[NUMBUFLEN];</a>
<a name="ln10037">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln10038">  const char *haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln10039">  const char *const haystack_start = haystack;</a>
<a name="ln10040">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln10041">    return;  // Type error; errmsg already given.</a>
<a name="ln10042">  }</a>
<a name="ln10043"> </a>
<a name="ln10044">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10045">    bool error = false;</a>
<a name="ln10046"> </a>
<a name="ln10047">    const ptrdiff_t start_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2],</a>
<a name="ln10048">                                                             &amp;error);</a>
<a name="ln10049">    if (error || start_idx &gt;= (ptrdiff_t)strlen(haystack)) {</a>
<a name="ln10050">      return;</a>
<a name="ln10051">    }</a>
<a name="ln10052">    if (start_idx &gt;= 0) {</a>
<a name="ln10053">      haystack += start_idx;</a>
<a name="ln10054">    }</a>
<a name="ln10055">  }</a>
<a name="ln10056"> </a>
<a name="ln10057">  const char *pos = strstr(haystack, needle);</a>
<a name="ln10058">  if (pos != NULL) {</a>
<a name="ln10059">    rettv-&gt;vval.v_number = (varnumber_T)(pos - haystack_start);</a>
<a name="ln10060">  }</a>
<a name="ln10061">}</a>
<a name="ln10062"> </a>
<a name="ln10063">/*</a>
<a name="ln10064"> * &quot;string()&quot; function</a>
<a name="ln10065"> */</a>
<a name="ln10066">void f_string(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10067">{</a>
<a name="ln10068">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10069">  rettv-&gt;vval.v_string = (char_u *)encode_tv2string(&amp;argvars[0], NULL);</a>
<a name="ln10070">}</a>
<a name="ln10071"> </a>
<a name="ln10072">/*</a>
<a name="ln10073"> * &quot;strlen()&quot; function</a>
<a name="ln10074"> */</a>
<a name="ln10075">static void f_strlen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10076">{</a>
<a name="ln10077">  rettv-&gt;vval.v_number = (varnumber_T)strlen(tv_get_string(&amp;argvars[0]));</a>
<a name="ln10078">}</a>
<a name="ln10079"> </a>
<a name="ln10080">/*</a>
<a name="ln10081"> * &quot;strchars()&quot; function</a>
<a name="ln10082"> */</a>
<a name="ln10083">static void f_strchars(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10084">{</a>
<a name="ln10085">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10086">  int skipcc = 0;</a>
<a name="ln10087">  varnumber_T len = 0;</a>
<a name="ln10088">  int (*func_mb_ptr2char_adv)(const char_u **pp);</a>
<a name="ln10089"> </a>
<a name="ln10090">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10091">    skipcc = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln10092">  }</a>
<a name="ln10093">  if (skipcc &lt; 0 || skipcc &gt; 1) {</a>
<a name="ln10094">    EMSG(_(e_invarg));</a>
<a name="ln10095">  } else {</a>
<a name="ln10096">    func_mb_ptr2char_adv = skipcc ? mb_ptr2char_adv : mb_cptr2char_adv;</a>
<a name="ln10097">    while (*s != NUL) {</a>
<a name="ln10098">      func_mb_ptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln10099">      len++;</a>
<a name="ln10100">    }</a>
<a name="ln10101">    rettv-&gt;vval.v_number = len;</a>
<a name="ln10102">  }</a>
<a name="ln10103">}</a>
<a name="ln10104"> </a>
<a name="ln10105">/*</a>
<a name="ln10106"> * &quot;strdisplaywidth()&quot; function</a>
<a name="ln10107"> */</a>
<a name="ln10108">static void f_strdisplaywidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10109">{</a>
<a name="ln10110">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10111">  int col = 0;</a>
<a name="ln10112"> </a>
<a name="ln10113">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10114">    col = tv_get_number(&amp;argvars[1]);</a>
<a name="ln10115">  }</a>
<a name="ln10116"> </a>
<a name="ln10117">  rettv-&gt;vval.v_number = (varnumber_T)(linetabsize_col(col, (char_u *)s) - col);</a>
<a name="ln10118">}</a>
<a name="ln10119"> </a>
<a name="ln10120">/*</a>
<a name="ln10121"> * &quot;strwidth()&quot; function</a>
<a name="ln10122"> */</a>
<a name="ln10123">static void f_strwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10124">{</a>
<a name="ln10125">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10126"> </a>
<a name="ln10127">  rettv-&gt;vval.v_number = (varnumber_T)mb_string2cells((const char_u *)s);</a>
<a name="ln10128">}</a>
<a name="ln10129"> </a>
<a name="ln10130">// &quot;strcharpart()&quot; function</a>
<a name="ln10131">static void f_strcharpart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10132">{</a>
<a name="ln10133">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10134">  const size_t slen = STRLEN(p);</a>
<a name="ln10135"> </a>
<a name="ln10136">  int nbyte = 0;</a>
<a name="ln10137">  bool error = false;</a>
<a name="ln10138">  varnumber_T nchar = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln10139">  if (!error) {</a>
<a name="ln10140">    if (nchar &gt; 0) {</a>
<a name="ln10141">      while (nchar &gt; 0 &amp;&amp; (size_t)nbyte &lt; slen) {</a>
<a name="ln10142">        nbyte += MB_CPTR2LEN((const char_u *)p + nbyte);</a>
<a name="ln10143">        nchar--;</a>
<a name="ln10144">      }</a>
<a name="ln10145">    } else {</a>
<a name="ln10146">      nbyte = nchar;</a>
<a name="ln10147">    }</a>
<a name="ln10148">  }</a>
<a name="ln10149">  int len = 0;</a>
<a name="ln10150">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10151">    int charlen = tv_get_number(&amp;argvars[2]);</a>
<a name="ln10152">    while (charlen &gt; 0 &amp;&amp; nbyte + len &lt; (int)slen) {</a>
<a name="ln10153">      int off = nbyte + len;</a>
<a name="ln10154"> </a>
<a name="ln10155">      if (off &lt; 0) {</a>
<a name="ln10156">        len += 1;</a>
<a name="ln10157">      } else {</a>
<a name="ln10158">        len += (size_t)MB_CPTR2LEN((const char_u *)p + off);</a>
<a name="ln10159">      }</a>
<a name="ln10160">      charlen--;</a>
<a name="ln10161">    }</a>
<a name="ln10162">  } else {</a>
<a name="ln10163">    len = slen - nbyte;    // default: all bytes that are available.</a>
<a name="ln10164">  }</a>
<a name="ln10165"> </a>
<a name="ln10166">  // Only return the overlap between the specified part and the actual</a>
<a name="ln10167">  // string.</a>
<a name="ln10168">  if (nbyte &lt; 0) {</a>
<a name="ln10169">    len += nbyte;</a>
<a name="ln10170">    nbyte = 0;</a>
<a name="ln10171">  } else if ((size_t)nbyte &gt; slen) {</a>
<a name="ln10172">    nbyte = slen;</a>
<a name="ln10173">  }</a>
<a name="ln10174">  if (len &lt; 0) {</a>
<a name="ln10175">    len = 0;</a>
<a name="ln10176">  } else if (nbyte + len &gt; (int)slen) {</a>
<a name="ln10177">    len = slen - nbyte;</a>
<a name="ln10178">  }</a>
<a name="ln10179"> </a>
<a name="ln10180">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10181">  rettv-&gt;vval.v_string = (char_u *)xstrndup(p + nbyte, (size_t)len);</a>
<a name="ln10182">}</a>
<a name="ln10183"> </a>
<a name="ln10184">/*</a>
<a name="ln10185"> * &quot;strpart()&quot; function</a>
<a name="ln10186"> */</a>
<a name="ln10187">static void f_strpart(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10188">{</a>
<a name="ln10189">  bool error = false;</a>
<a name="ln10190"> </a>
<a name="ln10191">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10192">  const size_t slen = strlen(p);</a>
<a name="ln10193"> </a>
<a name="ln10194">  varnumber_T n = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln10195">  varnumber_T len;</a>
<a name="ln10196">  if (error) {</a>
<a name="ln10197">    len = 0;</a>
<a name="ln10198">  } else if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10199">    len = tv_get_number(&amp;argvars[2]);</a>
<a name="ln10200">  } else {</a>
<a name="ln10201">    len = slen - n;  // Default len: all bytes that are available.</a>
<a name="ln10202">  }</a>
<a name="ln10203"> </a>
<a name="ln10204">  // Only return the overlap between the specified part and the actual</a>
<a name="ln10205">  // string.</a>
<a name="ln10206">  if (n &lt; 0) {</a>
<a name="ln10207">    len += n;</a>
<a name="ln10208">    n = 0;</a>
<a name="ln10209">  } else if (n &gt; (varnumber_T)slen) {</a>
<a name="ln10210">    n = slen;</a>
<a name="ln10211">  }</a>
<a name="ln10212">  if (len &lt; 0) {</a>
<a name="ln10213">    len = 0;</a>
<a name="ln10214">  } else if (n + len &gt; (varnumber_T)slen) {</a>
<a name="ln10215">    len = slen - n;</a>
<a name="ln10216">  }</a>
<a name="ln10217"> </a>
<a name="ln10218">  if (argvars[2].v_type != VAR_UNKNOWN &amp;&amp; argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln10219">    int off;</a>
<a name="ln10220"> </a>
<a name="ln10221">    // length in characters</a>
<a name="ln10222">    for (off = n; off &lt; (int)slen &amp;&amp; len &gt; 0; len--) {</a>
<a name="ln10223">      off += utfc_ptr2len((char_u *)p + off);</a>
<a name="ln10224">    }</a>
<a name="ln10225">    len = off - n;</a>
<a name="ln10226">  }</a>
<a name="ln10227"> </a>
<a name="ln10228">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10229">  rettv-&gt;vval.v_string = (char_u *)xmemdupz(p + n, (size_t)len);</a>
<a name="ln10230">}</a>
<a name="ln10231"> </a>
<a name="ln10232">// &quot;strptime({format}, {timestring})&quot; function</a>
<a name="ln10233">static void f_strptime(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10234">{</a>
<a name="ln10235">  char fmt_buf[NUMBUFLEN];</a>
<a name="ln10236">  char str_buf[NUMBUFLEN];</a>
<a name="ln10237"> </a>
<a name="ln10238">  struct tm tmval = {</a>
<a name="ln10239">    .tm_isdst = -1,</a>
<a name="ln10240">  };</a>
<a name="ln10241">  char *fmt = (char *)tv_get_string_buf(&amp;argvars[0], fmt_buf);</a>
<a name="ln10242">  char *str = (char *)tv_get_string_buf(&amp;argvars[1], str_buf);</a>
<a name="ln10243"> </a>
<a name="ln10244">  vimconv_T conv = {</a>
<a name="ln10245">    .vc_type = CONV_NONE,</a>
<a name="ln10246">  };</a>
<a name="ln10247">  char_u *enc = enc_locale();</a>
<a name="ln10248">  convert_setup(&amp;conv, p_enc, enc);</a>
<a name="ln10249">  if (conv.vc_type != CONV_NONE) {</a>
<a name="ln10250">    fmt = (char *)string_convert(&amp;conv, (char_u *)fmt, NULL);</a>
<a name="ln10251">  }</a>
<a name="ln10252">  if (fmt == NULL</a>
<a name="ln10253">      || os_strptime(str, fmt, &amp;tmval) == NULL</a>
<a name="ln10254">      || (rettv-&gt;vval.v_number = mktime(&amp;tmval)) == -1) {</a>
<a name="ln10255">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln10256">  }</a>
<a name="ln10257">  if (conv.vc_type != CONV_NONE) {</a>
<a name="ln10258">    xfree(fmt);</a>
<a name="ln10259">  }</a>
<a name="ln10260">  convert_setup(&amp;conv, NULL, NULL);</a>
<a name="ln10261">  xfree(enc);</a>
<a name="ln10262">}</a>
<a name="ln10263"> </a>
<a name="ln10264">/*</a>
<a name="ln10265"> * &quot;strridx()&quot; function</a>
<a name="ln10266"> */</a>
<a name="ln10267">static void f_strridx(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10268">{</a>
<a name="ln10269">  char buf[NUMBUFLEN];</a>
<a name="ln10270">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln10271">  const char *const haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln10272"> </a>
<a name="ln10273">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln10274">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln10275">    return;  // Type error; errmsg already given.</a>
<a name="ln10276">  }</a>
<a name="ln10277"> </a>
<a name="ln10278">  const size_t haystack_len = STRLEN(haystack);</a>
<a name="ln10279">  ptrdiff_t end_idx;</a>
<a name="ln10280">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10281">    // Third argument: upper limit for index.</a>
<a name="ln10282">    end_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln10283">    if (end_idx &lt; 0) {</a>
<a name="ln10284">      return;  // Can never find a match.</a>
<a name="ln10285">    }</a>
<a name="ln10286">  } else {</a>
<a name="ln10287">    end_idx = (ptrdiff_t)haystack_len;</a>
<a name="ln10288">  }</a>
<a name="ln10289"> </a>
<a name="ln10290">  const char *lastmatch = NULL;</a>
<a name="ln10291">  if (*needle == NUL) {</a>
<a name="ln10292">    // Empty string matches past the end.</a>
<a name="ln10293">    lastmatch = haystack + end_idx;</a>
<a name="ln10294">  } else {</a>
<a name="ln10295">    for (const char *rest = haystack; *rest != NUL; rest++) {</a>
<a name="ln10296">      rest = strstr(rest, needle);</a>
<a name="ln10297">      if (rest == NULL || rest &gt; haystack + end_idx) {</a>
<a name="ln10298">        break;</a>
<a name="ln10299">      }</a>
<a name="ln10300">      lastmatch = rest;</a>
<a name="ln10301">    }</a>
<a name="ln10302">  }</a>
<a name="ln10303"> </a>
<a name="ln10304">  if (lastmatch != NULL) {</a>
<a name="ln10305">    rettv-&gt;vval.v_number = (varnumber_T)(lastmatch - haystack);</a>
<a name="ln10306">  }</a>
<a name="ln10307">}</a>
<a name="ln10308"> </a>
<a name="ln10309">/*</a>
<a name="ln10310"> * &quot;strtrans()&quot; function</a>
<a name="ln10311"> */</a>
<a name="ln10312">static void f_strtrans(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10313">{</a>
<a name="ln10314">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10315">  rettv-&gt;vval.v_string = (char_u *)transstr(tv_get_string(&amp;argvars[0]));</a>
<a name="ln10316">}</a>
<a name="ln10317"> </a>
<a name="ln10318">/*</a>
<a name="ln10319"> * &quot;submatch()&quot; function</a>
<a name="ln10320"> */</a>
<a name="ln10321">static void f_submatch(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10322">{</a>
<a name="ln10323">  bool error = false;</a>
<a name="ln10324">  int no = (int)tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln10325">  if (error) {</a>
<a name="ln10326">    return;</a>
<a name="ln10327">  }</a>
<a name="ln10328"> </a>
<a name="ln10329">  if (no &lt; 0 || no &gt;= NSUBEXP) {</a>
<a name="ln10330">    emsgf(_(&quot;E935: invalid submatch number: %d&quot;), no);</a>
<a name="ln10331">    return;</a>
<a name="ln10332">  }</a>
<a name="ln10333">  int retList = 0;</a>
<a name="ln10334"> </a>
<a name="ln10335">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10336">    retList = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln10337">    if (error) {</a>
<a name="ln10338">      return;</a>
<a name="ln10339">    }</a>
<a name="ln10340">  }</a>
<a name="ln10341"> </a>
<a name="ln10342">  if (retList == 0) {</a>
<a name="ln10343">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10344">    rettv-&gt;vval.v_string = reg_submatch(no);</a>
<a name="ln10345">  } else {</a>
<a name="ln10346">    rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln10347">    rettv-&gt;vval.v_list = reg_submatch_list(no);</a>
<a name="ln10348">  }</a>
<a name="ln10349">}</a>
<a name="ln10350"> </a>
<a name="ln10351">/*</a>
<a name="ln10352"> * &quot;substitute()&quot; function</a>
<a name="ln10353"> */</a>
<a name="ln10354">static void f_substitute(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10355">{</a>
<a name="ln10356">  char patbuf[NUMBUFLEN];</a>
<a name="ln10357">  char subbuf[NUMBUFLEN];</a>
<a name="ln10358">  char flagsbuf[NUMBUFLEN];</a>
<a name="ln10359"> </a>
<a name="ln10360">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10361">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[1], patbuf);</a>
<a name="ln10362">  const char *sub = NULL;</a>
<a name="ln10363">  const char *const flg = tv_get_string_buf_chk(&amp;argvars[3], flagsbuf);</a>
<a name="ln10364"> </a>
<a name="ln10365">  typval_T *expr = NULL;</a>
<a name="ln10366">  if (tv_is_func(argvars[2])) {</a>
<a name="ln10367">    expr = &amp;argvars[2];</a>
<a name="ln10368">  } else {</a>
<a name="ln10369">    sub = tv_get_string_buf_chk(&amp;argvars[2], subbuf);</a>
<a name="ln10370">  }</a>
<a name="ln10371"> </a>
<a name="ln10372">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10373">  if (str == NULL || pat == NULL || (sub == NULL &amp;&amp; expr == NULL)</a>
<a name="ln10374">      || flg == NULL) {</a>
<a name="ln10375">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10376">  } else {</a>
<a name="ln10377">    rettv-&gt;vval.v_string = do_string_sub((char_u *)str, (char_u *)pat,</a>
<a name="ln10378">                                         (char_u *)sub, expr, (char_u *)flg);</a>
<a name="ln10379">  }</a>
<a name="ln10380">}</a>
<a name="ln10381"> </a>
<a name="ln10382">/// &quot;swapinfo(swap_filename)&quot; function</a>
<a name="ln10383">static void f_swapinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10384">{</a>
<a name="ln10385">  tv_dict_alloc_ret(rettv);</a>
<a name="ln10386">  get_b0_dict(tv_get_string(argvars), rettv-&gt;vval.v_dict);</a>
<a name="ln10387">}</a>
<a name="ln10388"> </a>
<a name="ln10389">/// &quot;swapname(expr)&quot; function</a>
<a name="ln10390">static void f_swapname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10391">{</a>
<a name="ln10392">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10393">  buf_T *buf = tv_get_buf(&amp;argvars[0], false);</a>
<a name="ln10394">  if (buf == NULL</a>
<a name="ln10395">      || buf-&gt;b_ml.ml_mfp == NULL</a>
<a name="ln10396">      || buf-&gt;b_ml.ml_mfp-&gt;mf_fname == NULL) {</a>
<a name="ln10397">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln10398">  } else {</a>
<a name="ln10399">    rettv-&gt;vval.v_string = vim_strsave(buf-&gt;b_ml.ml_mfp-&gt;mf_fname);</a>
<a name="ln10400">  }</a>
<a name="ln10401">}</a>
<a name="ln10402"> </a>
<a name="ln10403">/// &quot;synID(lnum, col, trans)&quot; function</a>
<a name="ln10404">static void f_synID(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10405">{</a>
<a name="ln10406">  // -1 on type error (both)</a>
<a name="ln10407">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10408">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10409"> </a>
<a name="ln10410">  bool transerr = false;</a>
<a name="ln10411">  const int trans = tv_get_number_chk(&amp;argvars[2], &amp;transerr);</a>
<a name="ln10412"> </a>
<a name="ln10413">  int id = 0;</a>
<a name="ln10414">  if (!transerr &amp;&amp; lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln10415">      &amp;&amp; col &gt;= 0 &amp;&amp; (size_t)col &lt; STRLEN(ml_get(lnum))) {</a>
<a name="ln10416">    id = syn_get_id(curwin, lnum, col, trans, NULL, false);</a>
<a name="ln10417">  }</a>
<a name="ln10418"> </a>
<a name="ln10419">  rettv-&gt;vval.v_number = id;</a>
<a name="ln10420">}</a>
<a name="ln10421"> </a>
<a name="ln10422">/*</a>
<a name="ln10423"> * &quot;synIDattr(id, what [, mode])&quot; function</a>
<a name="ln10424"> */</a>
<a name="ln10425">static void f_synIDattr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10426">{</a>
<a name="ln10427">  const int id = (int)tv_get_number(&amp;argvars[0]);</a>
<a name="ln10428">  const char *const what = tv_get_string(&amp;argvars[1]);</a>
<a name="ln10429">  int modec;</a>
<a name="ln10430">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10431">    char modebuf[NUMBUFLEN];</a>
<a name="ln10432">    const char *const mode = tv_get_string_buf(&amp;argvars[2], modebuf);</a>
<a name="ln10433">    modec = TOLOWER_ASC(mode[0]);</a>
<a name="ln10434">    if (modec != 'c' &amp;&amp; modec != 'g') {</a>
<a name="ln10435">      modec = 0;  // Replace invalid with current.</a>
<a name="ln10436">    }</a>
<a name="ln10437">  } else if (ui_rgb_attached()) {</a>
<a name="ln10438">    modec = 'g';</a>
<a name="ln10439">  } else {</a>
<a name="ln10440">    modec = 'c';</a>
<a name="ln10441">  }</a>
<a name="ln10442"> </a>
<a name="ln10443"> </a>
<a name="ln10444">  const char *p = NULL;</a>
<a name="ln10445">  switch (TOLOWER_ASC(what[0])) {</a>
<a name="ln10446">    case 'b': {</a>
<a name="ln10447">      if (TOLOWER_ASC(what[1]) == 'g') {  // bg[#]</a>
<a name="ln10448">        p = highlight_color(id, what, modec);</a>
<a name="ln10449">      } else {  // bold</a>
<a name="ln10450">        p = highlight_has_attr(id, HL_BOLD, modec);</a>
<a name="ln10451">      }</a>
<a name="ln10452">      break;</a>
<a name="ln10453">    }</a>
<a name="ln10454">    case 'f': {  // fg[#] or font</a>
<a name="ln10455">      p = highlight_color(id, what, modec);</a>
<a name="ln10456">      break;</a>
<a name="ln10457">    }</a>
<a name="ln10458">    case 'i': {</a>
<a name="ln10459">      if (TOLOWER_ASC(what[1]) == 'n') {  // inverse</a>
<a name="ln10460">        p = highlight_has_attr(id, HL_INVERSE, modec);</a>
<a name="ln10461">      } else {  // italic</a>
<a name="ln10462">        p = highlight_has_attr(id, HL_ITALIC, modec);</a>
<a name="ln10463">      }</a>
<a name="ln10464">      break;</a>
<a name="ln10465">    }</a>
<a name="ln10466">    case 'n': {  // name</a>
<a name="ln10467">      p = get_highlight_name_ext(NULL, id - 1, false);</a>
<a name="ln10468">      break;</a>
<a name="ln10469">    }</a>
<a name="ln10470">    case 'r': {  // reverse</a>
<a name="ln10471">      p = highlight_has_attr(id, HL_INVERSE, modec);</a>
<a name="ln10472">      break;</a>
<a name="ln10473">    }</a>
<a name="ln10474">    case 's': {</a>
<a name="ln10475">      if (TOLOWER_ASC(what[1]) == 'p') {  // sp[#]</a>
<a name="ln10476">        p = highlight_color(id, what, modec);</a>
<a name="ln10477">      } else if (TOLOWER_ASC(what[1]) == 't'</a>
<a name="ln10478">                 &amp;&amp; TOLOWER_ASC(what[2]) == 'r') {  // strikethrough</a>
<a name="ln10479">        p = highlight_has_attr(id, HL_STRIKETHROUGH, modec);</a>
<a name="ln10480">      } else {  // standout</a>
<a name="ln10481">        p = highlight_has_attr(id, HL_STANDOUT, modec);</a>
<a name="ln10482">      }</a>
<a name="ln10483">      break;</a>
<a name="ln10484">    }</a>
<a name="ln10485">    case 'u': {</a>
<a name="ln10486">      if (STRLEN(what) &lt;= 5 || TOLOWER_ASC(what[5]) != 'c') {  // underline</a>
<a name="ln10487">        p = highlight_has_attr(id, HL_UNDERLINE, modec);</a>
<a name="ln10488">      } else {  // undercurl</a>
<a name="ln10489">        p = highlight_has_attr(id, HL_UNDERCURL, modec);</a>
<a name="ln10490">      }</a>
<a name="ln10491">      break;</a>
<a name="ln10492">    }</a>
<a name="ln10493">  }</a>
<a name="ln10494"> </a>
<a name="ln10495">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10496">  rettv-&gt;vval.v_string = (char_u *)(p == NULL ? p : xstrdup(p));</a>
<a name="ln10497">}</a>
<a name="ln10498"> </a>
<a name="ln10499">/*</a>
<a name="ln10500"> * &quot;synIDtrans(id)&quot; function</a>
<a name="ln10501"> */</a>
<a name="ln10502">static void f_synIDtrans(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10503">{</a>
<a name="ln10504">  int id = tv_get_number(&amp;argvars[0]);</a>
<a name="ln10505"> </a>
<a name="ln10506">  if (id &gt; 0) {</a>
<a name="ln10507">    id = syn_get_final_id(id);</a>
<a name="ln10508">  } else {</a>
<a name="ln10509">    id = 0;</a>
<a name="ln10510">  }</a>
<a name="ln10511"> </a>
<a name="ln10512">  rettv-&gt;vval.v_number = id;</a>
<a name="ln10513">}</a>
<a name="ln10514"> </a>
<a name="ln10515">/*</a>
<a name="ln10516"> * &quot;synconcealed(lnum, col)&quot; function</a>
<a name="ln10517"> */</a>
<a name="ln10518">static void f_synconcealed(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10519">{</a>
<a name="ln10520">  int syntax_flags = 0;</a>
<a name="ln10521">  int cchar;</a>
<a name="ln10522">  int matchid = 0;</a>
<a name="ln10523">  char_u str[NUMBUFLEN];</a>
<a name="ln10524"> </a>
<a name="ln10525">  tv_list_set_ret(rettv, NULL);</a>
<a name="ln10526"> </a>
<a name="ln10527">  // -1 on type error (both)</a>
<a name="ln10528">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10529">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10530"> </a>
<a name="ln10531">  memset(str, NUL, sizeof(str));</a>
<a name="ln10532"> </a>
<a name="ln10533">  if (lnum &gt;= 1 &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count &amp;&amp; col &gt;= 0</a>
<a name="ln10534">      &amp;&amp; (size_t)col &lt;= STRLEN(ml_get(lnum)) &amp;&amp; curwin-&gt;w_p_cole &gt; 0) {</a>
<a name="ln10535">    (void)syn_get_id(curwin, lnum, col, false, NULL, false);</a>
<a name="ln10536">    syntax_flags = get_syntax_info(&amp;matchid);</a>
<a name="ln10537"> </a>
<a name="ln10538">    // get the conceal character</a>
<a name="ln10539">    if ((syntax_flags &amp; HL_CONCEAL) &amp;&amp; curwin-&gt;w_p_cole &lt; 3) {</a>
<a name="ln10540">      cchar = syn_get_sub_char();</a>
<a name="ln10541">      if (cchar == NUL &amp;&amp; curwin-&gt;w_p_cole == 1) {</a>
<a name="ln10542">        cchar = (curwin-&gt;w_p_lcs_chars.conceal == NUL)</a>
<a name="ln10543">          ? ' '</a>
<a name="ln10544">          : curwin-&gt;w_p_lcs_chars.conceal;</a>
<a name="ln10545">      }</a>
<a name="ln10546">      if (cchar != NUL) {</a>
<a name="ln10547">        utf_char2bytes(cchar, str);</a>
<a name="ln10548">      }</a>
<a name="ln10549">    }</a>
<a name="ln10550">  }</a>
<a name="ln10551"> </a>
<a name="ln10552">  tv_list_alloc_ret(rettv, 3);</a>
<a name="ln10553">  tv_list_append_number(rettv-&gt;vval.v_list, (syntax_flags &amp; HL_CONCEAL) != 0);</a>
<a name="ln10554">  // -1 to auto-determine strlen</a>
<a name="ln10555">  tv_list_append_string(rettv-&gt;vval.v_list, (const char *)str, -1);</a>
<a name="ln10556">  tv_list_append_number(rettv-&gt;vval.v_list, matchid);</a>
<a name="ln10557">}</a>
<a name="ln10558"> </a>
<a name="ln10559">/*</a>
<a name="ln10560"> * &quot;synstack(lnum, col)&quot; function</a>
<a name="ln10561"> */</a>
<a name="ln10562">static void f_synstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10563">{</a>
<a name="ln10564">  tv_list_set_ret(rettv, NULL);</a>
<a name="ln10565"> </a>
<a name="ln10566">  // -1 on type error (both)</a>
<a name="ln10567">  const linenr_T lnum = tv_get_lnum(argvars);</a>
<a name="ln10568">  const colnr_T col = (colnr_T)tv_get_number(&amp;argvars[1]) - 1;</a>
<a name="ln10569"> </a>
<a name="ln10570">  if (lnum &gt;= 1</a>
<a name="ln10571">      &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln10572">      &amp;&amp; col &gt;= 0</a>
<a name="ln10573">      &amp;&amp; (size_t)col &lt;= STRLEN(ml_get(lnum))) {</a>
<a name="ln10574">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln10575">    (void)syn_get_id(curwin, lnum, col, false, NULL, true);</a>
<a name="ln10576"> </a>
<a name="ln10577">    int id;</a>
<a name="ln10578">    int i = 0;</a>
<a name="ln10579">    while ((id = syn_get_stack_item(i++)) &gt;= 0) {</a>
<a name="ln10580">      tv_list_append_number(rettv-&gt;vval.v_list, id);</a>
<a name="ln10581">    }</a>
<a name="ln10582">  }</a>
<a name="ln10583">}</a>
<a name="ln10584"> </a>
<a name="ln10585">/// f_system - the VimL system() function</a>
<a name="ln10586">static void f_system(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10587">{</a>
<a name="ln10588">  get_system_output_as_rettv(argvars, rettv, false);</a>
<a name="ln10589">}</a>
<a name="ln10590"> </a>
<a name="ln10591">static void f_systemlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10592">{</a>
<a name="ln10593">  get_system_output_as_rettv(argvars, rettv, true);</a>
<a name="ln10594">}</a>
<a name="ln10595"> </a>
<a name="ln10596"> </a>
<a name="ln10597">/*</a>
<a name="ln10598"> * &quot;tabpagebuflist()&quot; function</a>
<a name="ln10599"> */</a>
<a name="ln10600">static void f_tabpagebuflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10601">{</a>
<a name="ln10602">  win_T       *wp = NULL;</a>
<a name="ln10603"> </a>
<a name="ln10604">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln10605">    wp = firstwin;</a>
<a name="ln10606">  } else {</a>
<a name="ln10607">    tabpage_T *const tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln10608">    if (tp != NULL) {</a>
<a name="ln10609">      wp = (tp == curtab) ? firstwin : tp-&gt;tp_firstwin;</a>
<a name="ln10610">    }</a>
<a name="ln10611">  }</a>
<a name="ln10612">  if (wp != NULL) {</a>
<a name="ln10613">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln10614">    while (wp != NULL) {</a>
<a name="ln10615">      tv_list_append_number(rettv-&gt;vval.v_list, wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln10616">      wp = wp-&gt;w_next;</a>
<a name="ln10617">    }</a>
<a name="ln10618">  }</a>
<a name="ln10619">}</a>
<a name="ln10620"> </a>
<a name="ln10621">/*</a>
<a name="ln10622"> * &quot;tabpagenr()&quot; function</a>
<a name="ln10623"> */</a>
<a name="ln10624">static void f_tabpagenr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10625">{</a>
<a name="ln10626">  int nr = 1;</a>
<a name="ln10627"> </a>
<a name="ln10628">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln10629">    const char *const arg = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10630">    nr = 0;</a>
<a name="ln10631">    if (arg != NULL) {</a>
<a name="ln10632">      if (strcmp(arg, &quot;$&quot;) == 0) {</a>
<a name="ln10633">        nr = tabpage_index(NULL) - 1;</a>
<a name="ln10634">      } else if (strcmp(arg, &quot;#&quot;) == 0) {</a>
<a name="ln10635">        nr = valid_tabpage(lastused_tabpage)</a>
<a name="ln10636">             ? tabpage_index(lastused_tabpage)</a>
<a name="ln10637">             : nr;</a>
<a name="ln10638">      } else {</a>
<a name="ln10639">        EMSG2(_(e_invexpr2), arg);</a>
<a name="ln10640">      }</a>
<a name="ln10641">    }</a>
<a name="ln10642">  } else {</a>
<a name="ln10643">    nr = tabpage_index(curtab);</a>
<a name="ln10644">  }</a>
<a name="ln10645">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln10646">}</a>
<a name="ln10647"> </a>
<a name="ln10648"> </a>
<a name="ln10649"> </a>
<a name="ln10650">/*</a>
<a name="ln10651"> * Common code for tabpagewinnr() and winnr().</a>
<a name="ln10652"> */</a>
<a name="ln10653">static int get_winnr(tabpage_T *tp, typval_T *argvar)</a>
<a name="ln10654">{</a>
<a name="ln10655">  win_T       *twin;</a>
<a name="ln10656">  int nr = 1;</a>
<a name="ln10657">  win_T       *wp;</a>
<a name="ln10658"> </a>
<a name="ln10659">  twin = (tp == curtab) ? curwin : tp-&gt;tp_curwin;</a>
<a name="ln10660">  if (argvar-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln10661">    bool invalid_arg = false;</a>
<a name="ln10662">    const char *const arg = tv_get_string_chk(argvar);</a>
<a name="ln10663">    if (arg == NULL) {</a>
<a name="ln10664">      nr = 0;  // Type error; errmsg already given.</a>
<a name="ln10665">    } else if (strcmp(arg, &quot;$&quot;) == 0) {</a>
<a name="ln10666">      twin = (tp == curtab) ? lastwin : tp-&gt;tp_lastwin;</a>
<a name="ln10667">    } else if (strcmp(arg, &quot;#&quot;) == 0) {</a>
<a name="ln10668">      twin = (tp == curtab) ? prevwin : tp-&gt;tp_prevwin;</a>
<a name="ln10669">      if (twin == NULL) {</a>
<a name="ln10670">        nr = 0;</a>
<a name="ln10671">      }</a>
<a name="ln10672">    } else {</a>
<a name="ln10673">      // Extract the window count (if specified). e.g. winnr('3j')</a>
<a name="ln10674">      char_u *endp;</a>
<a name="ln10675">      long count = strtol((char *)arg, (char **)&amp;endp, 10);</a>
<a name="ln10676">      if (count &lt;= 0) {</a>
<a name="ln10677">        // if count is not specified, default to 1</a>
<a name="ln10678">        count = 1;</a>
<a name="ln10679">      }</a>
<a name="ln10680">      if (endp != NULL &amp;&amp; *endp != '\0') {</a>
<a name="ln10681">        if (strequal((char *)endp, &quot;j&quot;)) {</a>
<a name="ln10682">          twin = win_vert_neighbor(tp, twin, false, count);</a>
<a name="ln10683">        } else if (strequal((char *)endp, &quot;k&quot;)) {</a>
<a name="ln10684">          twin = win_vert_neighbor(tp, twin, true, count);</a>
<a name="ln10685">        } else if (strequal((char *)endp, &quot;h&quot;)) {</a>
<a name="ln10686">          twin = win_horz_neighbor(tp, twin, true, count);</a>
<a name="ln10687">        } else if (strequal((char *)endp, &quot;l&quot;)) {</a>
<a name="ln10688">          twin = win_horz_neighbor(tp, twin, false, count);</a>
<a name="ln10689">        } else {</a>
<a name="ln10690">          invalid_arg = true;</a>
<a name="ln10691">        }</a>
<a name="ln10692">      } else {</a>
<a name="ln10693">        invalid_arg = true;</a>
<a name="ln10694">      }</a>
<a name="ln10695">    }</a>
<a name="ln10696"> </a>
<a name="ln10697">    if (invalid_arg) {</a>
<a name="ln10698">      EMSG2(_(e_invexpr2), arg);</a>
<a name="ln10699">      nr = 0;</a>
<a name="ln10700">    }</a>
<a name="ln10701">  }</a>
<a name="ln10702"> </a>
<a name="ln10703">  if (nr &gt; 0)</a>
<a name="ln10704">    for (wp = (tp == curtab) ? firstwin : tp-&gt;tp_firstwin;</a>
<a name="ln10705">         wp != twin; wp = wp-&gt;w_next) {</a>
<a name="ln10706">      if (wp == NULL) {</a>
<a name="ln10707">        // didn't find it in this tabpage</a>
<a name="ln10708">        nr = 0;</a>
<a name="ln10709">        break;</a>
<a name="ln10710">      }</a>
<a name="ln10711">      ++nr;</a>
<a name="ln10712">    }</a>
<a name="ln10713">  return nr;</a>
<a name="ln10714">}</a>
<a name="ln10715"> </a>
<a name="ln10716">/*</a>
<a name="ln10717"> * &quot;tabpagewinnr()&quot; function</a>
<a name="ln10718"> */</a>
<a name="ln10719">static void f_tabpagewinnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10720">{</a>
<a name="ln10721">  int nr = 1;</a>
<a name="ln10722">  tabpage_T *const tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln10723">  if (tp == NULL) {</a>
<a name="ln10724">    nr = 0;</a>
<a name="ln10725">  } else {</a>
<a name="ln10726">    nr = get_winnr(tp, &amp;argvars[1]);</a>
<a name="ln10727">  }</a>
<a name="ln10728">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln10729">}</a>
<a name="ln10730"> </a>
<a name="ln10731">/*</a>
<a name="ln10732"> * &quot;tagfiles()&quot; function</a>
<a name="ln10733"> */</a>
<a name="ln10734">static void f_tagfiles(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10735">{</a>
<a name="ln10736">  char *fname;</a>
<a name="ln10737">  tagname_T tn;</a>
<a name="ln10738"> </a>
<a name="ln10739">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln10740">  fname = xmalloc(MAXPATHL);</a>
<a name="ln10741"> </a>
<a name="ln10742">  bool first = true;</a>
<a name="ln10743">  while (get_tagfname(&amp;tn, first, (char_u *)fname) == OK) {</a>
<a name="ln10744">    tv_list_append_string(rettv-&gt;vval.v_list, fname, -1);</a>
<a name="ln10745">    first = false;</a>
<a name="ln10746">  }</a>
<a name="ln10747"> </a>
<a name="ln10748">  tagname_free(&amp;tn);</a>
<a name="ln10749">  xfree(fname);</a>
<a name="ln10750">}</a>
<a name="ln10751"> </a>
<a name="ln10752">/*</a>
<a name="ln10753"> * &quot;taglist()&quot; function</a>
<a name="ln10754"> */</a>
<a name="ln10755">static void f_taglist(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10756">{</a>
<a name="ln10757">  const char *const tag_pattern = tv_get_string(&amp;argvars[0]);</a>
<a name="ln10758"> </a>
<a name="ln10759">  rettv-&gt;vval.v_number = false;</a>
<a name="ln10760">  if (*tag_pattern == NUL) {</a>
<a name="ln10761">    return;</a>
<a name="ln10762">  }</a>
<a name="ln10763"> </a>
<a name="ln10764">  const char *fname = NULL;</a>
<a name="ln10765">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10766">    fname = tv_get_string(&amp;argvars[1]);</a>
<a name="ln10767">  }</a>
<a name="ln10768">  (void)get_tags(tv_list_alloc_ret(rettv, kListLenUnknown),</a>
<a name="ln10769">                 (char_u *)tag_pattern, (char_u *)fname);</a>
<a name="ln10770">}</a>
<a name="ln10771"> </a>
<a name="ln10772">/*</a>
<a name="ln10773"> * &quot;tempname()&quot; function</a>
<a name="ln10774"> */</a>
<a name="ln10775">static void f_tempname(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10776">{</a>
<a name="ln10777">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln10778">  rettv-&gt;vval.v_string = vim_tempname();</a>
<a name="ln10779">}</a>
<a name="ln10780"> </a>
<a name="ln10781">// &quot;termopen(cmd[, cwd])&quot; function</a>
<a name="ln10782">static void f_termopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10783">{</a>
<a name="ln10784">  if (check_secure()) {</a>
<a name="ln10785">    return;</a>
<a name="ln10786">  }</a>
<a name="ln10787"> </a>
<a name="ln10788">  if (curbuf-&gt;b_changed) {</a>
<a name="ln10789">    EMSG(_(&quot;Can only call this function in an unmodified buffer&quot;));</a>
<a name="ln10790">    return;</a>
<a name="ln10791">  }</a>
<a name="ln10792"> </a>
<a name="ln10793">  const char *cmd;</a>
<a name="ln10794">  bool executable = true;</a>
<a name="ln10795">  char **argv = tv_to_argv(&amp;argvars[0], &amp;cmd, &amp;executable);</a>
<a name="ln10796">  if (!argv) {</a>
<a name="ln10797">    rettv-&gt;vval.v_number = executable ? 0 : -1;</a>
<a name="ln10798">    return;  // Did error message in tv_to_argv.</a>
<a name="ln10799">  }</a>
<a name="ln10800"> </a>
<a name="ln10801">  if (argvars[1].v_type != VAR_DICT &amp;&amp; argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln10802">    // Wrong argument type</a>
<a name="ln10803">    EMSG2(_(e_invarg2), &quot;expected dictionary&quot;);</a>
<a name="ln10804">    shell_free_argv(argv);</a>
<a name="ln10805">    return;</a>
<a name="ln10806">  }</a>
<a name="ln10807"> </a>
<a name="ln10808">  CallbackReader on_stdout = CALLBACK_READER_INIT,</a>
<a name="ln10809">                 on_stderr = CALLBACK_READER_INIT;</a>
<a name="ln10810">  Callback on_exit = CALLBACK_NONE;</a>
<a name="ln10811">  dict_T *job_opts = NULL;</a>
<a name="ln10812">  const char *cwd = &quot;.&quot;;</a>
<a name="ln10813">  dict_T *env = NULL;</a>
<a name="ln10814">  const bool pty = true;</a>
<a name="ln10815">  bool clear_env = false;</a>
<a name="ln10816">  dictitem_T *job_env = NULL;</a>
<a name="ln10817"> </a>
<a name="ln10818">  if (argvars[1].v_type == VAR_DICT) {</a>
<a name="ln10819">    job_opts = argvars[1].vval.v_dict;</a>
<a name="ln10820"> </a>
<a name="ln10821">    const char *const new_cwd = tv_dict_get_string(job_opts, &quot;cwd&quot;, false);</a>
<a name="ln10822">    if (new_cwd &amp;&amp; *new_cwd != NUL) {</a>
<a name="ln10823">      cwd = new_cwd;</a>
<a name="ln10824">      // The new cwd must be a directory.</a>
<a name="ln10825">      if (!os_isdir_executable((const char *)cwd)) {</a>
<a name="ln10826">        EMSG2(_(e_invarg2), &quot;expected valid directory&quot;);</a>
<a name="ln10827">        shell_free_argv(argv);</a>
<a name="ln10828">        return;</a>
<a name="ln10829">      }</a>
<a name="ln10830">    }</a>
<a name="ln10831"> </a>
<a name="ln10832">    job_env = tv_dict_find(job_opts, S_LEN(&quot;env&quot;));</a>
<a name="ln10833">    if (job_env &amp;&amp; job_env-&gt;di_tv.v_type != VAR_DICT) {</a>
<a name="ln10834">      EMSG2(_(e_invarg2), &quot;env&quot;);</a>
<a name="ln10835">      shell_free_argv(argv);</a>
<a name="ln10836">      return;</a>
<a name="ln10837">    }</a>
<a name="ln10838"> </a>
<a name="ln10839">    clear_env = tv_dict_get_number(job_opts, &quot;clear_env&quot;) != 0;</a>
<a name="ln10840"> </a>
<a name="ln10841">    if (!common_job_callbacks(job_opts, &amp;on_stdout, &amp;on_stderr, &amp;on_exit)) {</a>
<a name="ln10842">      shell_free_argv(argv);</a>
<a name="ln10843">      return;</a>
<a name="ln10844">    }</a>
<a name="ln10845">  }</a>
<a name="ln10846"> </a>
<a name="ln10847">  env = create_environment(job_env, clear_env, pty, &quot;xterm-256color&quot;);</a>
<a name="ln10848"> </a>
<a name="ln10849">  const bool rpc = false;</a>
<a name="ln10850">  const bool overlapped = false;</a>
<a name="ln10851">  const bool detach = false;</a>
<a name="ln10852">  uint16_t term_width = MAX(0, curwin-&gt;w_width_inner - win_col_off(curwin));</a>
<a name="ln10853">  Channel *chan = channel_job_start(argv, on_stdout, on_stderr, on_exit,</a>
<a name="ln10854">                                    pty, rpc, overlapped, detach, cwd,</a>
<a name="ln10855">                                    term_width, curwin-&gt;w_height_inner,</a>
<a name="ln10856">                                    env, &amp;rettv-&gt;vval.v_number);</a>
<a name="ln10857">  if (rettv-&gt;vval.v_number &lt;= 0) {</a>
<a name="ln10858">    return;</a>
<a name="ln10859">  }</a>
<a name="ln10860"> </a>
<a name="ln10861">  int pid = chan-&gt;stream.pty.process.pid;</a>
<a name="ln10862"> </a>
<a name="ln10863">  // &quot;./&quot; =&gt; &quot;/home/foo/&quot;</a>
<a name="ln10864">  vim_FullName(cwd, (char *)NameBuff, sizeof(NameBuff), false);</a>
<a name="ln10865">  // &quot;/home/foo/&quot; =&gt; &quot;~/&quot;</a>
<a name="ln10866">  size_t len = home_replace(NULL, NameBuff, IObuff, sizeof(IObuff), true);</a>
<a name="ln10867">  // Trim slash.</a>
<a name="ln10868">  if (IObuff[len - 1] == '\\' || IObuff[len - 1] == '/') {</a>
<a name="ln10869">    IObuff[len - 1] = '\0';</a>
<a name="ln10870">  }</a>
<a name="ln10871"> </a>
<a name="ln10872">  // Terminal URI: &quot;term://$CWD//$PID:$CMD&quot;</a>
<a name="ln10873">  snprintf((char *)NameBuff, sizeof(NameBuff), &quot;term://%s//%d:%s&quot;,</a>
<a name="ln10874">           (char *)IObuff, pid, cmd);</a>
<a name="ln10875">  // at this point the buffer has no terminal instance associated yet, so unset</a>
<a name="ln10876">  // the 'swapfile' option to ensure no swap file will be created</a>
<a name="ln10877">  curbuf-&gt;b_p_swf = false;</a>
<a name="ln10878">  (void)setfname(curbuf, NameBuff, NULL, true);</a>
<a name="ln10879">  // Save the job id and pid in b:terminal_job_{id,pid}</a>
<a name="ln10880">  Error err = ERROR_INIT;</a>
<a name="ln10881">  // deprecated: use 'channel' buffer option</a>
<a name="ln10882">  dict_set_var(curbuf-&gt;b_vars, cstr_as_string(&quot;terminal_job_id&quot;),</a>
<a name="ln10883">               INTEGER_OBJ(chan-&gt;id), false, false, &amp;err);</a>
<a name="ln10884">  api_clear_error(&amp;err);</a>
<a name="ln10885">  dict_set_var(curbuf-&gt;b_vars, cstr_as_string(&quot;terminal_job_pid&quot;),</a>
<a name="ln10886">               INTEGER_OBJ(pid), false, false, &amp;err);</a>
<a name="ln10887">  api_clear_error(&amp;err);</a>
<a name="ln10888"> </a>
<a name="ln10889">  channel_terminal_open(curbuf, chan);</a>
<a name="ln10890">  channel_create_event(chan, NULL);</a>
<a name="ln10891">}</a>
<a name="ln10892"> </a>
<a name="ln10893">// &quot;test_garbagecollect_now()&quot; function</a>
<a name="ln10894">static void f_test_garbagecollect_now(typval_T *argvars,</a>
<a name="ln10895">                                      typval_T *rettv, FunPtr fptr)</a>
<a name="ln10896">{</a>
<a name="ln10897">  // This is dangerous, any Lists and Dicts used internally may be freed</a>
<a name="ln10898">  // while still in use.</a>
<a name="ln10899">  garbage_collect(true);</a>
<a name="ln10900">}</a>
<a name="ln10901"> </a>
<a name="ln10902">// &quot;test_write_list_log()&quot; function</a>
<a name="ln10903">static void f_test_write_list_log(typval_T *const argvars,</a>
<a name="ln10904">                                  typval_T *const rettv,</a>
<a name="ln10905">                                  FunPtr fptr)</a>
<a name="ln10906">{</a>
<a name="ln10907">  const char *const fname = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln10908">  if (fname == NULL) {</a>
<a name="ln10909">    return;</a>
<a name="ln10910">  }</a>
<a name="ln10911">  list_write_log(fname);</a>
<a name="ln10912">}</a>
<a name="ln10913"> </a>
<a name="ln10914">/// &quot;timer_info([timer])&quot; function</a>
<a name="ln10915">static void f_timer_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10916">{</a>
<a name="ln10917">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln10918">    if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10919">      EMSG(_(e_number_exp));</a>
<a name="ln10920">      return;</a>
<a name="ln10921">    }</a>
<a name="ln10922">    tv_list_alloc_ret(rettv, 1);</a>
<a name="ln10923">    timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10924">    if (timer != NULL &amp;&amp; !timer-&gt;stopped) {</a>
<a name="ln10925">      add_timer_info(rettv, timer);</a>
<a name="ln10926">    }</a>
<a name="ln10927">  } else {</a>
<a name="ln10928">    add_timer_info_all(rettv);</a>
<a name="ln10929">  }</a>
<a name="ln10930">}</a>
<a name="ln10931"> </a>
<a name="ln10932">/// &quot;timer_pause(timer, paused)&quot; function</a>
<a name="ln10933">static void f_timer_pause(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln10934">{</a>
<a name="ln10935">  if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10936">    EMSG(_(e_number_exp));</a>
<a name="ln10937">    return;</a>
<a name="ln10938">  }</a>
<a name="ln10939">  int paused = (bool)tv_get_number(&amp;argvars[1]);</a>
<a name="ln10940">  timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10941">  if (timer != NULL) {</a>
<a name="ln10942">    if (!timer-&gt;paused &amp;&amp; paused) {</a>
<a name="ln10943">      time_watcher_stop(&amp;timer-&gt;tw);</a>
<a name="ln10944">    } else if (timer-&gt;paused &amp;&amp; !paused) {</a>
<a name="ln10945">      time_watcher_start(&amp;timer-&gt;tw, timer_due_cb, timer-&gt;timeout,</a>
<a name="ln10946">                         timer-&gt;timeout);</a>
<a name="ln10947">    }</a>
<a name="ln10948">    timer-&gt;paused = paused;</a>
<a name="ln10949">  }</a>
<a name="ln10950">}</a>
<a name="ln10951"> </a>
<a name="ln10952">/// &quot;timer_start(timeout, callback, opts)&quot; function</a>
<a name="ln10953">static void f_timer_start(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10954">{</a>
<a name="ln10955">  int repeat = 1;</a>
<a name="ln10956">  dict_T *dict;</a>
<a name="ln10957"> </a>
<a name="ln10958">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln10959"> </a>
<a name="ln10960">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln10961">    if (argvars[2].v_type != VAR_DICT</a>
<a name="ln10962">        || (dict = argvars[2].vval.v_dict) == NULL) {</a>
<a name="ln10963">      EMSG2(_(e_invarg2), tv_get_string(&amp;argvars[2]));</a>
<a name="ln10964">      return;</a>
<a name="ln10965">    }</a>
<a name="ln10966">    dictitem_T *const di = tv_dict_find(dict, S_LEN(&quot;repeat&quot;));</a>
<a name="ln10967">    if (di != NULL) {</a>
<a name="ln10968">      repeat = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln10969">      if (repeat == 0) {</a>
<a name="ln10970">        repeat = 1;</a>
<a name="ln10971">      }</a>
<a name="ln10972">    }</a>
<a name="ln10973">  }</a>
<a name="ln10974"> </a>
<a name="ln10975">  Callback callback;</a>
<a name="ln10976">  if (!callback_from_typval(&amp;callback, &amp;argvars[1])) {</a>
<a name="ln10977">    return;</a>
<a name="ln10978">  }</a>
<a name="ln10979">  rettv-&gt;vval.v_number =</a>
<a name="ln10980">      timer_start(tv_get_number(&amp;argvars[0]), repeat, &amp;callback);</a>
<a name="ln10981">}</a>
<a name="ln10982"> </a>
<a name="ln10983"> </a>
<a name="ln10984">// &quot;timer_stop(timerid)&quot; function</a>
<a name="ln10985">static void f_timer_stop(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln10986">{</a>
<a name="ln10987">    if (argvars[0].v_type != VAR_NUMBER) {</a>
<a name="ln10988">        EMSG(_(e_number_exp));</a>
<a name="ln10989">        return;</a>
<a name="ln10990">    }</a>
<a name="ln10991"> </a>
<a name="ln10992">    timer_T *timer = find_timer_by_nr(tv_get_number(&amp;argvars[0]));</a>
<a name="ln10993">    if (timer == NULL) {</a>
<a name="ln10994">      return;</a>
<a name="ln10995">    }</a>
<a name="ln10996"> </a>
<a name="ln10997">    timer_stop(timer);</a>
<a name="ln10998">}</a>
<a name="ln10999"> </a>
<a name="ln11000">static void f_timer_stopall(typval_T *argvars, typval_T *unused, FunPtr fptr)</a>
<a name="ln11001">{</a>
<a name="ln11002">  timer_stop_all();</a>
<a name="ln11003">}</a>
<a name="ln11004"> </a>
<a name="ln11005">/*</a>
<a name="ln11006"> * &quot;tolower(string)&quot; function</a>
<a name="ln11007"> */</a>
<a name="ln11008">static void f_tolower(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11009">{</a>
<a name="ln11010">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11011">  rettv-&gt;vval.v_string = (char_u *)strcase_save(tv_get_string(&amp;argvars[0]),</a>
<a name="ln11012">                                                false);</a>
<a name="ln11013">}</a>
<a name="ln11014"> </a>
<a name="ln11015">/*</a>
<a name="ln11016"> * &quot;toupper(string)&quot; function</a>
<a name="ln11017"> */</a>
<a name="ln11018">static void f_toupper(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11019">{</a>
<a name="ln11020">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11021">  rettv-&gt;vval.v_string = (char_u *)strcase_save(tv_get_string(&amp;argvars[0]),</a>
<a name="ln11022">                                                true);</a>
<a name="ln11023">}</a>
<a name="ln11024"> </a>
<a name="ln11025">/*</a>
<a name="ln11026"> * &quot;tr(string, fromstr, tostr)&quot; function</a>
<a name="ln11027"> */</a>
<a name="ln11028">static void f_tr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11029">{</a>
<a name="ln11030">  char buf[NUMBUFLEN];</a>
<a name="ln11031">  char buf2[NUMBUFLEN];</a>
<a name="ln11032"> </a>
<a name="ln11033">  const char *in_str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln11034">  const char *fromstr = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln11035">  const char *tostr = tv_get_string_buf_chk(&amp;argvars[2], buf2);</a>
<a name="ln11036"> </a>
<a name="ln11037">  // Default return value: empty string.</a>
<a name="ln11038">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11039">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln11040">  if (fromstr == NULL || tostr == NULL) {</a>
<a name="ln11041">    return;  // Type error; errmsg already given.</a>
<a name="ln11042">  }</a>
<a name="ln11043">  garray_T ga;</a>
<a name="ln11044">  ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln11045"> </a>
<a name="ln11046">  // fromstr and tostr have to contain the same number of chars.</a>
<a name="ln11047">  bool first = true;</a>
<a name="ln11048">  while (*in_str != NUL) {</a>
<a name="ln11049">    const char *cpstr = in_str;</a>
<a name="ln11050">    const int inlen = utfc_ptr2len((const char_u *)in_str);</a>
<a name="ln11051">    int cplen = inlen;</a>
<a name="ln11052">    int idx = 0;</a>
<a name="ln11053">    int fromlen;</a>
<a name="ln11054">    for (const char *p = fromstr; *p != NUL; p += fromlen) {</a>
<a name="ln11055">      fromlen = utfc_ptr2len((const char_u *)p);</a>
<a name="ln11056">      if (fromlen == inlen &amp;&amp; STRNCMP(in_str, p, inlen) == 0) {</a>
<a name="ln11057">        int tolen;</a>
<a name="ln11058">        for (p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln11059">          tolen = utfc_ptr2len((const char_u *)p);</a>
<a name="ln11060">          if (idx-- == 0) {</a>
<a name="ln11061">            cplen = tolen;</a>
<a name="ln11062">            cpstr = (char *)p;</a>
<a name="ln11063">            break;</a>
<a name="ln11064">          }</a>
<a name="ln11065">        }</a>
<a name="ln11066">        if (*p == NUL) {  // tostr is shorter than fromstr.</a>
<a name="ln11067">          goto error;</a>
<a name="ln11068">        }</a>
<a name="ln11069">        break;</a>
<a name="ln11070">      }</a>
<a name="ln11071">      idx++;</a>
<a name="ln11072">    }</a>
<a name="ln11073"> </a>
<a name="ln11074">    if (first &amp;&amp; cpstr == in_str) {</a>
<a name="ln11075">      // Check that fromstr and tostr have the same number of</a>
<a name="ln11076">      // (multi-byte) characters.  Done only once when a character</a>
<a name="ln11077">      // of in_str doesn't appear in fromstr.</a>
<a name="ln11078">      first = false;</a>
<a name="ln11079">      int tolen;</a>
<a name="ln11080">      for (const char *p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln11081">        tolen = utfc_ptr2len((const char_u *)p);</a>
<a name="ln11082">        idx--;</a>
<a name="ln11083">      }</a>
<a name="ln11084">      if (idx != 0) {</a>
<a name="ln11085">        goto error;</a>
<a name="ln11086">      }</a>
<a name="ln11087">    }</a>
<a name="ln11088"> </a>
<a name="ln11089">    ga_grow(&amp;ga, cplen);</a>
<a name="ln11090">    memmove((char *)ga.ga_data + ga.ga_len, cpstr, (size_t)cplen);</a>
<a name="ln11091">    ga.ga_len += cplen;</a>
<a name="ln11092"> </a>
<a name="ln11093">    in_str += inlen;</a>
<a name="ln11094">  }</a>
<a name="ln11095"> </a>
<a name="ln11096">  // add a terminating NUL</a>
<a name="ln11097">  ga_append(&amp;ga, NUL);</a>
<a name="ln11098"> </a>
<a name="ln11099">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln11100">  return;</a>
<a name="ln11101">error:</a>
<a name="ln11102">  EMSG2(_(e_invarg2), fromstr);</a>
<a name="ln11103">  ga_clear(&amp;ga);</a>
<a name="ln11104">  return;</a>
<a name="ln11105">}</a>
<a name="ln11106"> </a>
<a name="ln11107">// &quot;trim({expr})&quot; function</a>
<a name="ln11108">static void f_trim(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11109">{</a>
<a name="ln11110">  char buf1[NUMBUFLEN];</a>
<a name="ln11111">  char buf2[NUMBUFLEN];</a>
<a name="ln11112">  const char_u *head = (const char_u *)tv_get_string_buf_chk(&amp;argvars[0], buf1);</a>
<a name="ln11113">  const char_u *mask = NULL;</a>
<a name="ln11114">  const char_u *tail;</a>
<a name="ln11115">  const char_u *prev;</a>
<a name="ln11116">  const char_u *p;</a>
<a name="ln11117">  int c1;</a>
<a name="ln11118">  int dir = 0;</a>
<a name="ln11119"> </a>
<a name="ln11120">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11121">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln11122">  if (head == NULL) {</a>
<a name="ln11123">    return;</a>
<a name="ln11124">  }</a>
<a name="ln11125"> </a>
<a name="ln11126">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln11127">    mask = (const char_u *)tv_get_string_buf_chk(&amp;argvars[1], buf2);</a>
<a name="ln11128">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln11129">      bool error = false;</a>
<a name="ln11130">      // leading or trailing characters to trim</a>
<a name="ln11131">      dir = (int)tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln11132">      if (error) {</a>
<a name="ln11133">        return;</a>
<a name="ln11134">      }</a>
<a name="ln11135">      if (dir &lt; 0 || dir &gt; 2) {</a>
<a name="ln11136">        emsgf(_(e_invarg2), tv_get_string(&amp;argvars[2]));</a>
<a name="ln11137">        return;</a>
<a name="ln11138">      }</a>
<a name="ln11139">    }</a>
<a name="ln11140">  }</a>
<a name="ln11141"> </a>
<a name="ln11142">  if (dir == 0 || dir == 1) {</a>
<a name="ln11143">    // Trim leading characters</a>
<a name="ln11144">    while (*head != NUL) {</a>
<a name="ln11145">      c1 = PTR2CHAR(head);</a>
<a name="ln11146">      if (mask == NULL) {</a>
<a name="ln11147">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln11148">          break;</a>
<a name="ln11149">        }</a>
<a name="ln11150">      } else {</a>
<a name="ln11151">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln11152">          if (c1 == PTR2CHAR(p)) {</a>
<a name="ln11153">            break;</a>
<a name="ln11154">          }</a>
<a name="ln11155">        }</a>
<a name="ln11156">        if (*p == NUL) {</a>
<a name="ln11157">          break;</a>
<a name="ln11158">        }</a>
<a name="ln11159">      }</a>
<a name="ln11160">      MB_PTR_ADV(head);</a>
<a name="ln11161">    }</a>
<a name="ln11162">  }</a>
<a name="ln11163"> </a>
<a name="ln11164">  tail = head + STRLEN(head);</a>
<a name="ln11165">  if (dir == 0 || dir == 2) {</a>
<a name="ln11166">    // Trim trailing characters</a>
<a name="ln11167">    for (; tail &gt; head; tail = prev) {</a>
<a name="ln11168">      prev = tail;</a>
<a name="ln11169">      MB_PTR_BACK(head, prev);</a>
<a name="ln11170">      c1 = PTR2CHAR(prev);</a>
<a name="ln11171">      if (mask == NULL) {</a>
<a name="ln11172">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln11173">          break;</a>
<a name="ln11174">        }</a>
<a name="ln11175">      } else {</a>
<a name="ln11176">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln11177">          if (c1 == PTR2CHAR(p)) {</a>
<a name="ln11178">            break;</a>
<a name="ln11179">          }</a>
<a name="ln11180">        }</a>
<a name="ln11181">        if (*p == NUL) {</a>
<a name="ln11182">          break;</a>
<a name="ln11183">        }</a>
<a name="ln11184">      }</a>
<a name="ln11185">    }</a>
<a name="ln11186">  }</a>
<a name="ln11187">  rettv-&gt;vval.v_string = vim_strnsave(head, tail - head);</a>
<a name="ln11188">}</a>
<a name="ln11189"> </a>
<a name="ln11190">/*</a>
<a name="ln11191"> * &quot;type(expr)&quot; function</a>
<a name="ln11192"> */</a>
<a name="ln11193">static void f_type(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11194">{</a>
<a name="ln11195">  int n = -1;</a>
<a name="ln11196"> </a>
<a name="ln11197">  switch (argvars[0].v_type) {</a>
<a name="ln11198">    case VAR_NUMBER: n = VAR_TYPE_NUMBER; break;</a>
<a name="ln11199">    case VAR_STRING: n = VAR_TYPE_STRING; break;</a>
<a name="ln11200">    case VAR_PARTIAL:</a>
<a name="ln11201">    case VAR_FUNC:   n = VAR_TYPE_FUNC; break;</a>
<a name="ln11202">    case VAR_LIST:   n = VAR_TYPE_LIST; break;</a>
<a name="ln11203">    case VAR_DICT:   n = VAR_TYPE_DICT; break;</a>
<a name="ln11204">    case VAR_FLOAT:  n = VAR_TYPE_FLOAT; break;</a>
<a name="ln11205">    case VAR_BOOL:   n = VAR_TYPE_BOOL; break;</a>
<a name="ln11206">    case VAR_SPECIAL:n = VAR_TYPE_SPECIAL; break;</a>
<a name="ln11207">    case VAR_UNKNOWN: {</a>
<a name="ln11208">      internal_error(&quot;f_type(UNKNOWN)&quot;);</a>
<a name="ln11209">      break;</a>
<a name="ln11210">    }</a>
<a name="ln11211">  }</a>
<a name="ln11212">  rettv-&gt;vval.v_number = n;</a>
<a name="ln11213">}</a>
<a name="ln11214"> </a>
<a name="ln11215">/*</a>
<a name="ln11216"> * &quot;undofile(name)&quot; function</a>
<a name="ln11217"> */</a>
<a name="ln11218">static void f_undofile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11219">{</a>
<a name="ln11220">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11221">  const char *const fname = tv_get_string(&amp;argvars[0]);</a>
<a name="ln11222"> </a>
<a name="ln11223">  if (*fname == NUL) {</a>
<a name="ln11224">    // If there is no file name there will be no undo file.</a>
<a name="ln11225">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln11226">  } else {</a>
<a name="ln11227">    char *ffname = FullName_save(fname, true);</a>
<a name="ln11228"> </a>
<a name="ln11229">    if (ffname != NULL) {</a>
<a name="ln11230">      rettv-&gt;vval.v_string = (char_u *)u_get_undo_file_name(ffname, false);</a>
<a name="ln11231">    }</a>
<a name="ln11232">    xfree(ffname);</a>
<a name="ln11233">  }</a>
<a name="ln11234">}</a>
<a name="ln11235"> </a>
<a name="ln11236">/*</a>
<a name="ln11237"> * &quot;undotree()&quot; function</a>
<a name="ln11238"> */</a>
<a name="ln11239">static void f_undotree(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11240">{</a>
<a name="ln11241">  tv_dict_alloc_ret(rettv);</a>
<a name="ln11242"> </a>
<a name="ln11243">  dict_T *dict = rettv-&gt;vval.v_dict;</a>
<a name="ln11244"> </a>
<a name="ln11245">  tv_dict_add_nr(dict, S_LEN(&quot;synced&quot;), (varnumber_T)curbuf-&gt;b_u_synced);</a>
<a name="ln11246">  tv_dict_add_nr(dict, S_LEN(&quot;seq_last&quot;), (varnumber_T)curbuf-&gt;b_u_seq_last);</a>
<a name="ln11247">  tv_dict_add_nr(dict, S_LEN(&quot;save_last&quot;),</a>
<a name="ln11248">                 (varnumber_T)curbuf-&gt;b_u_save_nr_last);</a>
<a name="ln11249">  tv_dict_add_nr(dict, S_LEN(&quot;seq_cur&quot;), (varnumber_T)curbuf-&gt;b_u_seq_cur);</a>
<a name="ln11250">  tv_dict_add_nr(dict, S_LEN(&quot;time_cur&quot;), (varnumber_T)curbuf-&gt;b_u_time_cur);</a>
<a name="ln11251">  tv_dict_add_nr(dict, S_LEN(&quot;save_cur&quot;), (varnumber_T)curbuf-&gt;b_u_save_nr_cur);</a>
<a name="ln11252"> </a>
<a name="ln11253">  tv_dict_add_list(dict, S_LEN(&quot;entries&quot;), u_eval_tree(curbuf-&gt;b_u_oldhead));</a>
<a name="ln11254">}</a>
<a name="ln11255"> </a>
<a name="ln11256">/*</a>
<a name="ln11257"> * &quot;values(dict)&quot; function</a>
<a name="ln11258"> */</a>
<a name="ln11259">static void f_values(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11260">{</a>
<a name="ln11261">  dict_list(argvars, rettv, 1);</a>
<a name="ln11262">}</a>
<a name="ln11263"> </a>
<a name="ln11264">/*</a>
<a name="ln11265"> * &quot;virtcol(string)&quot; function</a>
<a name="ln11266"> */</a>
<a name="ln11267">static void f_virtcol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11268">{</a>
<a name="ln11269">  colnr_T vcol = 0;</a>
<a name="ln11270">  pos_T       *fp;</a>
<a name="ln11271">  int fnum = curbuf-&gt;b_fnum;</a>
<a name="ln11272"> </a>
<a name="ln11273">  fp = var2fpos(&amp;argvars[0], FALSE, &amp;fnum);</a>
<a name="ln11274">  if (fp != NULL &amp;&amp; fp-&gt;lnum &lt;= curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln11275">      &amp;&amp; fnum == curbuf-&gt;b_fnum) {</a>
<a name="ln11276">    // Limit the column to a valid value, getvvcol() doesn't check.</a>
<a name="ln11277">    if (fp-&gt;col &lt; 0) {</a>
<a name="ln11278">      fp-&gt;col = 0;</a>
<a name="ln11279">    } else {</a>
<a name="ln11280">      const size_t len = STRLEN(ml_get(fp-&gt;lnum));</a>
<a name="ln11281">      if (fp-&gt;col &gt; (colnr_T)len) {</a>
<a name="ln11282">        fp-&gt;col = (colnr_T)len;</a>
<a name="ln11283">      }</a>
<a name="ln11284">    }</a>
<a name="ln11285">    getvvcol(curwin, fp, NULL, NULL, &amp;vcol);</a>
<a name="ln11286">    ++vcol;</a>
<a name="ln11287">  }</a>
<a name="ln11288"> </a>
<a name="ln11289">  rettv-&gt;vval.v_number = vcol;</a>
<a name="ln11290">}</a>
<a name="ln11291"> </a>
<a name="ln11292">/*</a>
<a name="ln11293"> * &quot;visualmode()&quot; function</a>
<a name="ln11294"> */</a>
<a name="ln11295">static void f_visualmode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11296">{</a>
<a name="ln11297">  char_u str[2];</a>
<a name="ln11298"> </a>
<a name="ln11299">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11300">  str[0] = curbuf-&gt;b_visual_mode_eval;</a>
<a name="ln11301">  str[1] = NUL;</a>
<a name="ln11302">  rettv-&gt;vval.v_string = vim_strsave(str);</a>
<a name="ln11303"> </a>
<a name="ln11304">  // A non-zero number or non-empty string argument: reset mode.</a>
<a name="ln11305">  if (non_zero_arg(&amp;argvars[0])) {</a>
<a name="ln11306">    curbuf-&gt;b_visual_mode_eval = NUL;</a>
<a name="ln11307">  }</a>
<a name="ln11308">}</a>
<a name="ln11309"> </a>
<a name="ln11310">/*</a>
<a name="ln11311"> * &quot;wildmenumode()&quot; function</a>
<a name="ln11312"> */</a>
<a name="ln11313">static void f_wildmenumode(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11314">{</a>
<a name="ln11315">  if (wild_menu_showing || ((State &amp; CMDLINE) &amp;&amp; pum_visible())) {</a>
<a name="ln11316">    rettv-&gt;vval.v_number = 1;</a>
<a name="ln11317">  }</a>
<a name="ln11318">}</a>
<a name="ln11319"> </a>
<a name="ln11320">/// &quot;win_findbuf()&quot; function</a>
<a name="ln11321">static void f_win_findbuf(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11322">{</a>
<a name="ln11323">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln11324">  win_findbuf(argvars, rettv-&gt;vval.v_list);</a>
<a name="ln11325">}</a>
<a name="ln11326"> </a>
<a name="ln11327">/// &quot;win_getid()&quot; function</a>
<a name="ln11328">static void f_win_getid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11329">{</a>
<a name="ln11330">  rettv-&gt;vval.v_number = win_getid(argvars);</a>
<a name="ln11331">}</a>
<a name="ln11332"> </a>
<a name="ln11333">/// &quot;win_gettype(nr)&quot; function</a>
<a name="ln11334">static void f_win_gettype(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11335">{</a>
<a name="ln11336">  win_T *wp = curwin;</a>
<a name="ln11337"> </a>
<a name="ln11338">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11339">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln11340">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln11341">    wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11342">    if (wp == NULL) {</a>
<a name="ln11343">      rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;unknown&quot;);</a>
<a name="ln11344">      return;</a>
<a name="ln11345">    }</a>
<a name="ln11346">  }</a>
<a name="ln11347">  if (wp == aucmd_win) {</a>
<a name="ln11348">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;autocmd&quot;);</a>
<a name="ln11349">  } else if (wp-&gt;w_p_pvw) {</a>
<a name="ln11350">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;preview&quot;);</a>
<a name="ln11351">  } else if (wp-&gt;w_floating) {</a>
<a name="ln11352">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;popup&quot;);</a>
<a name="ln11353">  } else if (wp == curwin &amp;&amp; cmdwin_type != 0) {</a>
<a name="ln11354">    rettv-&gt;vval.v_string = vim_strsave((char_u *)&quot;command&quot;);</a>
<a name="ln11355">  }</a>
<a name="ln11356">}</a>
<a name="ln11357"> </a>
<a name="ln11358">/// &quot;win_gotoid()&quot; function</a>
<a name="ln11359">static void f_win_gotoid(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11360">{</a>
<a name="ln11361">  rettv-&gt;vval.v_number = win_gotoid(argvars);</a>
<a name="ln11362">}</a>
<a name="ln11363"> </a>
<a name="ln11364">/// &quot;win_id2tabwin()&quot; function</a>
<a name="ln11365">static void f_win_id2tabwin(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11366">{</a>
<a name="ln11367">  win_id2tabwin(argvars, rettv);</a>
<a name="ln11368">}</a>
<a name="ln11369"> </a>
<a name="ln11370">/// &quot;win_id2win()&quot; function</a>
<a name="ln11371">static void f_win_id2win(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11372">{</a>
<a name="ln11373">  rettv-&gt;vval.v_number = win_id2win(argvars);</a>
<a name="ln11374">}</a>
<a name="ln11375"> </a>
<a name="ln11376">/// &quot;winbufnr(nr)&quot; function</a>
<a name="ln11377">static void f_winbufnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11378">{</a>
<a name="ln11379">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11380">  if (wp == NULL) {</a>
<a name="ln11381">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11382">  } else {</a>
<a name="ln11383">    rettv-&gt;vval.v_number = wp-&gt;w_buffer-&gt;b_fnum;</a>
<a name="ln11384">  }</a>
<a name="ln11385">}</a>
<a name="ln11386"> </a>
<a name="ln11387">/*</a>
<a name="ln11388"> * &quot;wincol()&quot; function</a>
<a name="ln11389"> */</a>
<a name="ln11390">static void f_wincol(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11391">{</a>
<a name="ln11392">  validate_cursor();</a>
<a name="ln11393">  rettv-&gt;vval.v_number = curwin-&gt;w_wcol + 1;</a>
<a name="ln11394">}</a>
<a name="ln11395"> </a>
<a name="ln11396">/// &quot;winheight(nr)&quot; function</a>
<a name="ln11397">static void f_winheight(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11398">{</a>
<a name="ln11399">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11400">  if (wp == NULL) {</a>
<a name="ln11401">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11402">  } else {</a>
<a name="ln11403">    rettv-&gt;vval.v_number = wp-&gt;w_height;</a>
<a name="ln11404">  }</a>
<a name="ln11405">}</a>
<a name="ln11406"> </a>
<a name="ln11407">// &quot;winlayout()&quot; function</a>
<a name="ln11408">static void f_winlayout(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11409">{</a>
<a name="ln11410">  tabpage_T *tp;</a>
<a name="ln11411"> </a>
<a name="ln11412">  tv_list_alloc_ret(rettv, 2);</a>
<a name="ln11413"> </a>
<a name="ln11414">  if (argvars[0].v_type == VAR_UNKNOWN) {</a>
<a name="ln11415">    tp = curtab;</a>
<a name="ln11416">  } else {</a>
<a name="ln11417">    tp = find_tabpage((int)tv_get_number(&amp;argvars[0]));</a>
<a name="ln11418">    if (tp == NULL) {</a>
<a name="ln11419">      return;</a>
<a name="ln11420">    }</a>
<a name="ln11421">  }</a>
<a name="ln11422"> </a>
<a name="ln11423">  get_framelayout(tp-&gt;tp_topframe, rettv-&gt;vval.v_list, true);</a>
<a name="ln11424">}</a>
<a name="ln11425"> </a>
<a name="ln11426">/*</a>
<a name="ln11427"> * &quot;winline()&quot; function</a>
<a name="ln11428"> */</a>
<a name="ln11429">static void f_winline(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11430">{</a>
<a name="ln11431">  validate_cursor();</a>
<a name="ln11432">  rettv-&gt;vval.v_number = curwin-&gt;w_wrow + 1;</a>
<a name="ln11433">}</a>
<a name="ln11434"> </a>
<a name="ln11435">/*</a>
<a name="ln11436"> * &quot;winnr()&quot; function</a>
<a name="ln11437"> */</a>
<a name="ln11438">static void f_winnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11439">{</a>
<a name="ln11440">  int nr = 1;</a>
<a name="ln11441"> </a>
<a name="ln11442">  nr = get_winnr(curtab, &amp;argvars[0]);</a>
<a name="ln11443">  rettv-&gt;vval.v_number = nr;</a>
<a name="ln11444">}</a>
<a name="ln11445"> </a>
<a name="ln11446">/*</a>
<a name="ln11447"> * &quot;winrestcmd()&quot; function</a>
<a name="ln11448"> */</a>
<a name="ln11449">static void f_winrestcmd(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11450">{</a>
<a name="ln11451">  garray_T ga;</a>
<a name="ln11452">  char_u buf[50];</a>
<a name="ln11453"> </a>
<a name="ln11454">  ga_init(&amp;ga, (int)sizeof(char), 70);</a>
<a name="ln11455"> </a>
<a name="ln11456">  // Do this twice to handle some window layouts properly.</a>
<a name="ln11457">  for (int i = 0; i &lt; 2; i++) {</a>
<a name="ln11458">    int winnr = 1;</a>
<a name="ln11459">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln11460">      snprintf((char *)buf, sizeof(buf), &quot;%dresize %d|&quot;, winnr,</a>
<a name="ln11461">               wp-&gt;w_height);</a>
<a name="ln11462">      ga_concat(&amp;ga, buf);</a>
<a name="ln11463">      snprintf((char *)buf, sizeof(buf), &quot;vert %dresize %d|&quot;, winnr,</a>
<a name="ln11464">               wp-&gt;w_width);</a>
<a name="ln11465">      ga_concat(&amp;ga, buf);</a>
<a name="ln11466">      winnr++;</a>
<a name="ln11467">    }</a>
<a name="ln11468">  }</a>
<a name="ln11469">  ga_append(&amp;ga, NUL);</a>
<a name="ln11470"> </a>
<a name="ln11471">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln11472">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11473">}</a>
<a name="ln11474"> </a>
<a name="ln11475">/*</a>
<a name="ln11476"> * &quot;winrestview()&quot; function</a>
<a name="ln11477"> */</a>
<a name="ln11478">static void f_winrestview(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11479">{</a>
<a name="ln11480">  dict_T *dict;</a>
<a name="ln11481"> </a>
<a name="ln11482">  if (argvars[0].v_type != VAR_DICT</a>
<a name="ln11483">      || (dict = argvars[0].vval.v_dict) == NULL) {</a>
<a name="ln11484">    EMSG(_(e_invarg));</a>
<a name="ln11485">  } else {</a>
<a name="ln11486">    dictitem_T *di;</a>
<a name="ln11487">    if ((di = tv_dict_find(dict, S_LEN(&quot;lnum&quot;))) != NULL) {</a>
<a name="ln11488">      curwin-&gt;w_cursor.lnum = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11489">    }</a>
<a name="ln11490">    if ((di = tv_dict_find(dict, S_LEN(&quot;col&quot;))) != NULL) {</a>
<a name="ln11491">      curwin-&gt;w_cursor.col = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11492">    }</a>
<a name="ln11493">    if ((di = tv_dict_find(dict, S_LEN(&quot;coladd&quot;))) != NULL) {</a>
<a name="ln11494">      curwin-&gt;w_cursor.coladd = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11495">    }</a>
<a name="ln11496">    if ((di = tv_dict_find(dict, S_LEN(&quot;curswant&quot;))) != NULL) {</a>
<a name="ln11497">      curwin-&gt;w_curswant = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11498">      curwin-&gt;w_set_curswant = false;</a>
<a name="ln11499">    }</a>
<a name="ln11500">    if ((di = tv_dict_find(dict, S_LEN(&quot;topline&quot;))) != NULL) {</a>
<a name="ln11501">      set_topline(curwin, tv_get_number(&amp;di-&gt;di_tv));</a>
<a name="ln11502">    }</a>
<a name="ln11503">    if ((di = tv_dict_find(dict, S_LEN(&quot;topfill&quot;))) != NULL) {</a>
<a name="ln11504">      curwin-&gt;w_topfill = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11505">    }</a>
<a name="ln11506">    if ((di = tv_dict_find(dict, S_LEN(&quot;leftcol&quot;))) != NULL) {</a>
<a name="ln11507">      curwin-&gt;w_leftcol = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11508">    }</a>
<a name="ln11509">    if ((di = tv_dict_find(dict, S_LEN(&quot;skipcol&quot;))) != NULL) {</a>
<a name="ln11510">      curwin-&gt;w_skipcol = tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln11511">    }</a>
<a name="ln11512"> </a>
<a name="ln11513">    check_cursor();</a>
<a name="ln11514">    win_new_height(curwin, curwin-&gt;w_height);</a>
<a name="ln11515">    win_new_width(curwin, curwin-&gt;w_width);</a>
<a name="ln11516">    changed_window_setting();</a>
<a name="ln11517"> </a>
<a name="ln11518">    if (curwin-&gt;w_topline &lt;= 0)</a>
<a name="ln11519">      curwin-&gt;w_topline = 1;</a>
<a name="ln11520">    if (curwin-&gt;w_topline &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln11521">      curwin-&gt;w_topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln11522">    check_topfill(curwin, true);</a>
<a name="ln11523">  }</a>
<a name="ln11524">}</a>
<a name="ln11525"> </a>
<a name="ln11526">/*</a>
<a name="ln11527"> * &quot;winsaveview()&quot; function</a>
<a name="ln11528"> */</a>
<a name="ln11529">static void f_winsaveview(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11530">{</a>
<a name="ln11531">  dict_T      *dict;</a>
<a name="ln11532"> </a>
<a name="ln11533">  tv_dict_alloc_ret(rettv);</a>
<a name="ln11534">  dict = rettv-&gt;vval.v_dict;</a>
<a name="ln11535"> </a>
<a name="ln11536">  tv_dict_add_nr(dict, S_LEN(&quot;lnum&quot;), (varnumber_T)curwin-&gt;w_cursor.lnum);</a>
<a name="ln11537">  tv_dict_add_nr(dict, S_LEN(&quot;col&quot;), (varnumber_T)curwin-&gt;w_cursor.col);</a>
<a name="ln11538">  tv_dict_add_nr(dict, S_LEN(&quot;coladd&quot;), (varnumber_T)curwin-&gt;w_cursor.coladd);</a>
<a name="ln11539">  update_curswant();</a>
<a name="ln11540">  tv_dict_add_nr(dict, S_LEN(&quot;curswant&quot;), (varnumber_T)curwin-&gt;w_curswant);</a>
<a name="ln11541"> </a>
<a name="ln11542">  tv_dict_add_nr(dict, S_LEN(&quot;topline&quot;), (varnumber_T)curwin-&gt;w_topline);</a>
<a name="ln11543">  tv_dict_add_nr(dict, S_LEN(&quot;topfill&quot;), (varnumber_T)curwin-&gt;w_topfill);</a>
<a name="ln11544">  tv_dict_add_nr(dict, S_LEN(&quot;leftcol&quot;), (varnumber_T)curwin-&gt;w_leftcol);</a>
<a name="ln11545">  tv_dict_add_nr(dict, S_LEN(&quot;skipcol&quot;), (varnumber_T)curwin-&gt;w_skipcol);</a>
<a name="ln11546">}</a>
<a name="ln11547"> </a>
<a name="ln11548">/// &quot;winwidth(nr)&quot; function</a>
<a name="ln11549">static void f_winwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11550">{</a>
<a name="ln11551">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln11552">  if (wp == NULL) {</a>
<a name="ln11553">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln11554">  } else {</a>
<a name="ln11555">    rettv-&gt;vval.v_number = wp-&gt;w_width;</a>
<a name="ln11556">  }</a>
<a name="ln11557">}</a>
<a name="ln11558"> </a>
<a name="ln11559">// &quot;windowsversion()&quot; function</a>
<a name="ln11560">static void f_windowsversion(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11561">{</a>
<a name="ln11562">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln11563">  rettv-&gt;vval.v_string = (char_u *)xstrdup(windowsVersion);</a>
<a name="ln11564">}</a>
<a name="ln11565"> </a>
<a name="ln11566">/// &quot;wordcount()&quot; function</a>
<a name="ln11567">static void f_wordcount(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11568">{</a>
<a name="ln11569">  tv_dict_alloc_ret(rettv);</a>
<a name="ln11570">  cursor_pos_info(rettv-&gt;vval.v_dict);</a>
<a name="ln11571">}</a>
<a name="ln11572"> </a>
<a name="ln11573">/// &quot;writefile()&quot; function</a>
<a name="ln11574">static void f_writefile(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11575">{</a>
<a name="ln11576">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln11577"> </a>
<a name="ln11578">  if (check_secure()) {</a>
<a name="ln11579">    return;</a>
<a name="ln11580">  }</a>
<a name="ln11581"> </a>
<a name="ln11582">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln11583">    EMSG2(_(e_listarg), &quot;writefile()&quot;);</a>
<a name="ln11584">    return;</a>
<a name="ln11585">  }</a>
<a name="ln11586">  const list_T *const list = argvars[0].vval.v_list;</a>
<a name="ln11587">  TV_LIST_ITER_CONST(list, li, {</a>
<a name="ln11588">    if (!tv_check_str_or_nr(TV_LIST_ITEM_TV(li))) {</a>
<a name="ln11589">      return;</a>
<a name="ln11590">    }</a>
<a name="ln11591">  });</a>
<a name="ln11592"> </a>
<a name="ln11593">  bool binary = false;</a>
<a name="ln11594">  bool append = false;</a>
<a name="ln11595">  bool do_fsync = !!p_fs;</a>
<a name="ln11596">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln11597">    const char *const flags = tv_get_string_chk(&amp;argvars[2]);</a>
<a name="ln11598">    if (flags == NULL) {</a>
<a name="ln11599">      return;</a>
<a name="ln11600">    }</a>
<a name="ln11601">    for (const char *p = flags; *p; p++) {</a>
<a name="ln11602">      switch (*p) {</a>
<a name="ln11603">        case 'b': { binary = true; break; }</a>
<a name="ln11604">        case 'a': { append = true; break; }</a>
<a name="ln11605">        case 's': { do_fsync = true; break; }</a>
<a name="ln11606">        case 'S': { do_fsync = false; break; }</a>
<a name="ln11607">        default: {</a>
<a name="ln11608">          // Using %s, p and not %c, *p to preserve multibyte characters</a>
<a name="ln11609">          emsgf(_(&quot;E5060: Unknown flag: %s&quot;), p);</a>
<a name="ln11610">          return;</a>
<a name="ln11611">        }</a>
<a name="ln11612">      }</a>
<a name="ln11613">    }</a>
<a name="ln11614">  }</a>
<a name="ln11615"> </a>
<a name="ln11616">  char buf[NUMBUFLEN];</a>
<a name="ln11617">  const char *const fname = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln11618">  if (fname == NULL) {</a>
<a name="ln11619">    return;</a>
<a name="ln11620">  }</a>
<a name="ln11621">  FileDescriptor fp;</a>
<a name="ln11622">  int error;</a>
<a name="ln11623">  if (*fname == NUL) {</a>
<a name="ln11624">    EMSG(_(&quot;E482: Can't open file with an empty name&quot;));</a>
<a name="ln11625">  } else if ((error = file_open(&amp;fp, fname,</a>
<a name="ln11626">                                ((append ? kFileAppend : kFileTruncate)</a>
<a name="ln11627">                                 | kFileCreate), 0666)) != 0) {</a>
<a name="ln11628">    emsgf(_(&quot;E482: Can't open file %s for writing: %s&quot;),</a>
<a name="ln11629">          fname, os_strerror(error));</a>
<a name="ln11630">  } else {</a>
<a name="ln11631">    if (write_list(&amp;fp, list, binary)) {</a>
<a name="ln11632">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln11633">    }</a>
<a name="ln11634">    if ((error = file_close(&amp;fp, do_fsync)) != 0) {</a>
<a name="ln11635">      emsgf(_(&quot;E80: Error when closing file %s: %s&quot;),</a>
<a name="ln11636">            fname, os_strerror(error));</a>
<a name="ln11637">    }</a>
<a name="ln11638">  }</a>
<a name="ln11639">}</a>
<a name="ln11640">/*</a>
<a name="ln11641"> * &quot;xor(expr, expr)&quot; function</a>
<a name="ln11642"> */</a>
<a name="ln11643">static void f_xor(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln11644">{</a>
<a name="ln11645">  rettv-&gt;vval.v_number = tv_get_number_chk(&amp;argvars[0], NULL)</a>
<a name="ln11646">                         ^ tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln11647">}</a>

</code></pre>
<div class="balloon" rel="1823"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression is always true.</p></div>
<div class="balloon" rel="8380"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
