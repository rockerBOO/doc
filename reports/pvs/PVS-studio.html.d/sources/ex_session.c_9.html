
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_session.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// Functions for creating a session file, i.e. implementing:</a>
<a name="ln5">//   :mkexrc</a>
<a name="ln6">//   :mkvimrc</a>
<a name="ln7">//   :mkview</a>
<a name="ln8">//   :mksession</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;assert.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12">#include &lt;stdbool.h&gt;</a>
<a name="ln13">#include &lt;stdlib.h&gt;</a>
<a name="ln14">#include &lt;inttypes.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;nvim/vim.h&quot;</a>
<a name="ln17">#include &quot;nvim/globals.h&quot;</a>
<a name="ln18">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln19">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln20">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln21">#include &quot;nvim/edit.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval.h&quot;</a>
<a name="ln23">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_session.h&quot;</a>
<a name="ln27">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln28">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln29">#include &quot;nvim/fold.h&quot;</a>
<a name="ln30">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln31">#include &quot;nvim/keymap.h&quot;</a>
<a name="ln32">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln33">#include &quot;nvim/move.h&quot;</a>
<a name="ln34">#include &quot;nvim/option.h&quot;</a>
<a name="ln35">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln36">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln37">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln38">#include &quot;nvim/path.h&quot;</a>
<a name="ln39">#include &quot;nvim/window.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln42"># include &quot;ex_session.c.generated.h&quot;</a>
<a name="ln43">#endif</a>
<a name="ln44"> </a>
<a name="ln45">/// Whether &quot;:lcd&quot; or &quot;:tcd&quot; was produced for a session.</a>
<a name="ln46">static int did_lcd;</a>
<a name="ln47"> </a>
<a name="ln48">#define PUTLINE_FAIL(s) \</a>
<a name="ln49">  do { if (FAIL == put_line(fd, (s))) { return FAIL; } } while (0)</a>
<a name="ln50"> </a>
<a name="ln51">static int put_view_curpos(FILE *fd, const win_T *wp, char *spaces)</a>
<a name="ln52">{</a>
<a name="ln53">  int r;</a>
<a name="ln54"> </a>
<a name="ln55">  if (wp-&gt;w_curswant == MAXCOL) {</a>
<a name="ln56">    r = fprintf(fd, &quot;%snormal! $\n&quot;, spaces);</a>
<a name="ln57">  } else {</a>
<a name="ln58">    r = fprintf(fd, &quot;%snormal! 0%d|\n&quot;, spaces, wp-&gt;w_virtcol + 1);</a>
<a name="ln59">  }</a>
<a name="ln60">  return r &gt;= 0;</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">static int ses_winsizes(FILE *fd, int restore_size, win_T *tab_firstwin)</a>
<a name="ln64">{</a>
<a name="ln65">  int n = 0;</a>
<a name="ln66">  win_T       *wp;</a>
<a name="ln67"> </a>
<a name="ln68">  if (restore_size &amp;&amp; (ssop_flags &amp; SSOP_WINSIZE)) {</a>
<a name="ln69">    for (wp = tab_firstwin; wp != NULL; wp = wp-&gt;w_next) {</a>
<a name="ln70">      if (!ses_do_win(wp)) {</a>
<a name="ln71">        continue;</a>
<a name="ln72">      }</a>
<a name="ln73">      n++;</a>
<a name="ln74"> </a>
<a name="ln75">      // restore height when not full height</a>
<a name="ln76">      if (wp-&gt;w_height + wp-&gt;w_status_height &lt; topframe-&gt;fr_height</a>
<a name="ln77">          &amp;&amp; (fprintf(fd,</a>
<a name="ln78">                      &quot;exe '%dresize ' . ((&amp;lines * %&quot; PRId64</a>
<a name="ln79">                      &quot; + %&quot; PRId64 &quot;) / %&quot; PRId64 &quot;)\n&quot;,</a>
<a name="ln80">                      n, (int64_t)wp-&gt;w_height,</a>
<a name="ln81">                      (int64_t)Rows / 2, (int64_t)Rows) &lt; 0)) {</a>
<a name="ln82">        return FAIL;</a>
<a name="ln83">      }</a>
<a name="ln84"> </a>
<a name="ln85">      // restore width when not full width</a>
<a name="ln86">      if (wp-&gt;w_width &lt; Columns</a>
<a name="ln87">          &amp;&amp; (fprintf(fd,</a>
<a name="ln88">                      &quot;exe 'vert %dresize ' . ((&amp;columns * %&quot; PRId64</a>
<a name="ln89">                      &quot; + %&quot; PRId64 &quot;) / %&quot; PRId64 &quot;)\n&quot;,</a>
<a name="ln90">                      n, (int64_t)wp-&gt;w_width, (int64_t)Columns / 2,</a>
<a name="ln91">                      (int64_t)Columns) &lt; 0)) {</a>
<a name="ln92">        return FAIL;</a>
<a name="ln93">      }</a>
<a name="ln94">    }</a>
<a name="ln95">  } else {</a>
<a name="ln96">    // Just equalize window sizes.</a>
<a name="ln97">    PUTLINE_FAIL(&quot;wincmd =&quot;);</a>
<a name="ln98">  }</a>
<a name="ln99">  return OK;</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">// Write commands to &quot;fd&quot; to recursively create windows for frame &quot;fr&quot;,</a>
<a name="ln103">// horizontally and vertically split.</a>
<a name="ln104">// After the commands the last window in the frame is the current window.</a>
<a name="ln105">// Returns FAIL when writing the commands to &quot;fd&quot; fails.</a>
<a name="ln106">static int ses_win_rec(FILE *fd, frame_T *fr)</a>
<a name="ln107">{</a>
<a name="ln108">  frame_T     *frc;</a>
<a name="ln109">  int count = 0;</a>
<a name="ln110"> </a>
<a name="ln111">  if (fr-&gt;fr_layout != FR_LEAF) {</a>
<a name="ln112">    // Find first frame that's not skipped and then create a window for</a>
<a name="ln113">    // each following one (first frame is already there).</a>
<a name="ln114">    frc = ses_skipframe(fr-&gt;fr_child);</a>
<a name="ln115">    if (frc != NULL) {</a>
<a name="ln116">      while ((frc = ses_skipframe(frc-&gt;fr_next)) != NULL) {</a>
<a name="ln117">        // Make window as big as possible so that we have lots of room</a>
<a name="ln118">        // to split.</a>
<a name="ln119">        if (fprintf(fd, &quot;%s%s&quot;,</a>
<a name="ln120">                    &quot;wincmd _ | wincmd |\n&quot;,</a>
<a name="ln121">                    (fr-&gt;fr_layout == FR_COL ? &quot;split\n&quot; : &quot;vsplit\n&quot;)) &lt; 0) {</a>
<a name="ln122">          return FAIL;</a>
<a name="ln123">        }</a>
<a name="ln124">        count++;</a>
<a name="ln125">      }</a>
<a name="ln126">    }</a>
<a name="ln127"> </a>
<a name="ln128">    // Go back to the first window.</a>
<a name="ln129">    if (count &gt; 0 &amp;&amp; (fprintf(fd, fr-&gt;fr_layout == FR_COL</a>
<a name="ln130">                              ? &quot;%dwincmd k\n&quot; : &quot;%dwincmd h\n&quot;, count) &lt; 0)) {</a>
<a name="ln131">      return FAIL;</a>
<a name="ln132">    }</a>
<a name="ln133"> </a>
<a name="ln134">    // Recursively create frames/windows in each window of this column or row.</a>
<a name="ln135">    frc = ses_skipframe(fr-&gt;fr_child);</a>
<a name="ln136">    while (frc != NULL) {</a>
<a name="ln137">      ses_win_rec(fd, frc);</a>
<a name="ln138">      frc = ses_skipframe(frc-&gt;fr_next);</a>
<a name="ln139">      // Go to next window.</a>
<a name="ln140">      if (frc != NULL &amp;&amp; put_line(fd, &quot;wincmd w&quot;) == FAIL) {</a>
<a name="ln141">        return FAIL;</a>
<a name="ln142">      }</a>
<a name="ln143">    }</a>
<a name="ln144">  }</a>
<a name="ln145">  return OK;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">// Skip frames that don't contain windows we want to save in the Session.</a>
<a name="ln149">// Returns NULL when there none.</a>
<a name="ln150">static frame_T *ses_skipframe(frame_T *fr)</a>
<a name="ln151">{</a>
<a name="ln152">  frame_T     *frc;</a>
<a name="ln153"> </a>
<a name="ln154">  FOR_ALL_FRAMES(frc, fr) {</a>
<a name="ln155">    if (ses_do_frame(frc)) {</a>
<a name="ln156">      break;</a>
<a name="ln157">    }</a>
<a name="ln158">  }</a>
<a name="ln159">  return frc;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">// Return true if frame &quot;fr&quot; has a window somewhere that we want to save in</a>
<a name="ln163">// the Session.</a>
<a name="ln164">static bool ses_do_frame(const frame_T *fr)</a>
<a name="ln165">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln166">{</a>
<a name="ln167">  const frame_T *frc;</a>
<a name="ln168"> </a>
<a name="ln169">  if (fr-&gt;fr_layout == FR_LEAF) {</a>
<a name="ln170">    return ses_do_win(fr-&gt;fr_win);</a>
<a name="ln171">  }</a>
<a name="ln172">  FOR_ALL_FRAMES(frc, fr-&gt;fr_child) {</a>
<a name="ln173">    if (ses_do_frame(frc)) {</a>
<a name="ln174">      return true;</a>
<a name="ln175">    }</a>
<a name="ln176">  }</a>
<a name="ln177">  return false;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">/// Return non-zero if window &quot;wp&quot; is to be stored in the Session.</a>
<a name="ln181">static int ses_do_win(win_T *wp)</a>
<a name="ln182">{</a>
<a name="ln183">  if (wp-&gt;w_buffer-&gt;b_fname == NULL</a>
<a name="ln184">      // When 'buftype' is &quot;nofile&quot; can't restore the window contents.</a>
<a name="ln185">      || (!wp-&gt;w_buffer-&gt;terminal &amp;&amp; bt_nofile(wp-&gt;w_buffer))) {</a>
<a name="ln186">    return ssop_flags &amp; SSOP_BLANK;</a>
<a name="ln187">  }</a>
<a name="ln188">  if (bt_help(wp-&gt;w_buffer)) {</a>
<a name="ln189">    return ssop_flags &amp; SSOP_HELP;</a>
<a name="ln190">  }</a>
<a name="ln191">  return true;</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">/// Writes an :argument list to the session file.</a>
<a name="ln195">///</a>
<a name="ln196">/// @param fd</a>
<a name="ln197">/// @param cmd</a>
<a name="ln198">/// @param gap</a>
<a name="ln199">/// @param fullname  true: use full path name</a>
<a name="ln200">/// @param flagp</a>
<a name="ln201">///</a>
<a name="ln202">/// @returns FAIL if writing fails.</a>
<a name="ln203">static int ses_arglist(FILE *fd, char *cmd, garray_T *gap, int fullname,</a>
<a name="ln204">                       unsigned *flagp)</a>
<a name="ln205">{</a>
<a name="ln206">  char_u      *buf = NULL;</a>
<a name="ln207">  char_u      *s;</a>
<a name="ln208"> </a>
<a name="ln209">  if (fprintf(fd, &quot;%s\n%s\n&quot;, cmd, &quot;%argdel&quot;) &lt; 0) {</a>
<a name="ln210">    return FAIL;</a>
<a name="ln211">  }</a>
<a name="ln212">  for (int i = 0; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln213">    // NULL file names are skipped (only happens when out of memory).</a>
<a name="ln214">    s = alist_name(&amp;((aentry_T *)gap-&gt;ga_data)[i]);</a>
<a name="ln215">    if (s != NULL) {</a>
<a name="ln216">      if (fullname) {</a>
<a name="ln217">        buf = xmalloc(MAXPATHL);</a>
<a name="ln218">        (void)vim_FullName((char *)s, (char *)buf, MAXPATHL, false);</a>
<a name="ln219">        s = buf;</a>
<a name="ln220">      }</a>
<a name="ln221">      char *fname_esc = ses_escape_fname((char *)s, flagp);</a>
<a name="ln222">      if (fprintf(fd, &quot;$argadd %s\n&quot;, fname_esc) &lt; 0) {</a>
<a name="ln223">        xfree(fname_esc);</a>
<a name="ln224">        xfree(buf);</a>
<a name="ln225">        return FAIL;</a>
<a name="ln226">      }</a>
<a name="ln227">      xfree(fname_esc);</a>
<a name="ln228">      xfree(buf);</a>
<a name="ln229">    }</a>
<a name="ln230">  }</a>
<a name="ln231">  return OK;</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234">/// Gets the buffer name for `buf`.</a>
<a name="ln235">static char *ses_get_fname(buf_T *buf, unsigned *flagp)</a>
<a name="ln236">{</a>
<a name="ln237">  // Use the short file name if the current directory is known at the time</a>
<a name="ln238">  // the session file will be sourced.</a>
<a name="ln239">  // Don't do this for &quot;:mkview&quot;, we don't know the current directory.</a>
<a name="ln240">  // Don't do this after &quot;:lcd&quot;, we don't keep track of what the current</a>
<a name="ln241">  // directory is.</a>
<a name="ln242">  if (buf-&gt;b_sfname != NULL</a>
<a name="ln243">      &amp;&amp; flagp == &amp;ssop_flags</a>
<a name="ln244">      &amp;&amp; (ssop_flags &amp; (SSOP_CURDIR | SSOP_SESDIR))</a>
<a name="ln245">      &amp;&amp; !p_acd</a>
<a name="ln246">      &amp;&amp; !did_lcd) {</a>
<a name="ln247">    return (char *)buf-&gt;b_sfname;</a>
<a name="ln248">  }</a>
<a name="ln249">  return (char *)buf-&gt;b_ffname;</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">/// Write a buffer name to the session file.</a>
<a name="ln253">/// Also ends the line, if &quot;add_eol&quot; is true.</a>
<a name="ln254">/// Returns FAIL if writing fails.</a>
<a name="ln255">static int ses_fname(FILE *fd, buf_T *buf, unsigned *flagp, bool add_eol)</a>
<a name="ln256">{</a>
<a name="ln257">  char *name = ses_get_fname(buf, flagp);</a>
<a name="ln258">  if (ses_put_fname(fd, (char_u *)name, flagp) == FAIL</a>
<a name="ln259">      || (add_eol &amp;&amp; fprintf(fd, &quot;\n&quot;) &lt; 0)) {</a>
<a name="ln260">    return FAIL;</a>
<a name="ln261">  }</a>
<a name="ln262">  return OK;</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">// Escapes a filename for session writing.</a>
<a name="ln266">// Takes care of &quot;slash&quot; flag in 'sessionoptions' and escapes special</a>
<a name="ln267">// characters.</a>
<a name="ln268">//</a>
<a name="ln269">// Returns allocated string or NULL.</a>
<a name="ln270">static char *ses_escape_fname(char *name, unsigned *flagp)</a>
<a name="ln271">{</a>
<a name="ln272">  char *p;</a>
<a name="ln273">  char *sname = (char *)home_replace_save(NULL, (char_u *)name);</a>
<a name="ln274"> </a>
<a name="ln275">  // Always SSOP_SLASH: change all backslashes to forward slashes.</a>
<a name="ln276">  for (p = sname; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln277">    if (*p == '\\') {</a>
<a name="ln278">      *p = '/';</a>
<a name="ln279">    }</a>
<a name="ln280">  }</a>
<a name="ln281"> </a>
<a name="ln282">  // Escape special characters.</a>
<a name="ln283">  p = vim_strsave_fnameescape(sname, false);</a>
<a name="ln284">  xfree(sname);</a>
<a name="ln285">  return p;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">// Write a file name to the session file.</a>
<a name="ln289">// Takes care of the &quot;slash&quot; option in 'sessionoptions' and escapes special</a>
<a name="ln290">// characters.</a>
<a name="ln291">// Returns FAIL if writing fails.</a>
<a name="ln292">static int ses_put_fname(FILE *fd, char_u *name, unsigned *flagp)</a>
<a name="ln293">{</a>
<a name="ln294">  char *p = ses_escape_fname((char *)name, flagp);</a>
<a name="ln295">  bool retval = fputs(p, fd) &lt; 0 ? FAIL : OK;</a>
<a name="ln296">  xfree(p);</a>
<a name="ln297">  return retval;</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300">// Write commands to &quot;fd&quot; to restore the view of a window.</a>
<a name="ln301">// Caller must make sure 'scrolloff' is zero.</a>
<a name="ln302">static int put_view(</a>
<a name="ln303">    FILE *fd,</a>
<a name="ln304">    win_T *wp,</a>
<a name="ln305">    int add_edit,                // add &quot;:edit&quot; command to view</a>
<a name="ln306">    unsigned *flagp,             // vop_flags or ssop_flags</a>
<a name="ln307">    int current_arg_idx          // current argument index of the window, use</a>
<a name="ln308">)                                // -1 if unknown</a>
<a name="ln309">{</a>
<a name="ln310">  win_T       *save_curwin;</a>
<a name="ln311">  int f;</a>
<a name="ln312">  int do_cursor;</a>
<a name="ln313">  int did_next = false;</a>
<a name="ln314"> </a>
<a name="ln315">  // Always restore cursor position for &quot;:mksession&quot;.  For &quot;:mkview&quot; only</a>
<a name="ln316">  // when 'viewoptions' contains &quot;cursor&quot;.</a>
<a name="ln317">  do_cursor = (flagp == &amp;ssop_flags || *flagp &amp; SSOP_CURSOR);</a>
<a name="ln318"> </a>
<a name="ln319">  //</a>
<a name="ln320">  // Local argument list.</a>
<a name="ln321">  //</a>
<a name="ln322">  if (wp-&gt;w_alist == &amp;global_alist) {</a>
<a name="ln323">    PUTLINE_FAIL(&quot;argglobal&quot;);</a>
<a name="ln324">  } else {</a>
<a name="ln325">    if (ses_arglist(fd, &quot;arglocal&quot;, &amp;wp-&gt;w_alist-&gt;al_ga,</a>
<a name="ln326">                    flagp == &amp;vop_flags</a>
<a name="ln327">                    || !(*flagp &amp; SSOP_CURDIR)</a>
<a name="ln328">                    || wp-&gt;w_localdir != NULL, flagp) == FAIL) {</a>
<a name="ln329">      return FAIL;</a>
<a name="ln330">    }</a>
<a name="ln331">  }</a>
<a name="ln332"> </a>
<a name="ln333">  // Only when part of a session: restore the argument index.  Some</a>
<a name="ln334">  // arguments may have been deleted, check if the index is valid.</a>
<a name="ln335">  if (wp-&gt;w_arg_idx != current_arg_idx &amp;&amp; wp-&gt;w_arg_idx &lt; WARGCOUNT(wp)</a>
<a name="ln336">      &amp;&amp; flagp == &amp;ssop_flags) {</a>
<a name="ln337">    if (fprintf(fd, &quot;%&quot; PRId64 &quot;argu\n&quot;, (int64_t)wp-&gt;w_arg_idx + 1) &lt; 0) {</a>
<a name="ln338">      return FAIL;</a>
<a name="ln339">    }</a>
<a name="ln340">    did_next = true;</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  // Edit the file.  Skip this when &quot;:next&quot; already did it.</a>
<a name="ln344">  if (add_edit &amp;&amp; (!did_next || wp-&gt;w_arg_idx_invalid)) {</a>
<a name="ln345">    char *fname_esc =</a>
<a name="ln346">      ses_escape_fname(ses_get_fname(wp-&gt;w_buffer, flagp), flagp);</a>
<a name="ln347">    //</a>
<a name="ln348">    // Load the file.</a>
<a name="ln349">    //</a>
<a name="ln350">    if (wp-&gt;w_buffer-&gt;b_ffname != NULL</a>
<a name="ln351">        &amp;&amp; (!bt_nofile(wp-&gt;w_buffer) || wp-&gt;w_buffer-&gt;terminal)</a>
<a name="ln352">        ) {</a>
<a name="ln353">      // Editing a file in this buffer: use &quot;:edit file&quot;.</a>
<a name="ln354">      // This may have side effects! (e.g., compressed or network file).</a>
<a name="ln355">      //</a>
<a name="ln356">      // Note, if a buffer for that file already exists, use :badd to</a>
<a name="ln357">      // edit that buffer, to not lose folding information (:edit resets</a>
<a name="ln358">      // folds in other buffers)</a>
<a name="ln359">      if (fprintf(fd,</a>
<a name="ln360">                  &quot;if bufexists(\&quot;%s\&quot;) | buffer %s | else | edit %s | endif\n&quot;</a>
<a name="ln361">                  // Fixup :terminal buffer name. #7836</a>
<a name="ln362">                  &quot;if &amp;buftype ==# 'terminal'\n&quot;</a>
<a name="ln363">                  &quot;  silent file %s\n&quot;</a>
<a name="ln364">                  &quot;endif\n&quot;,</a>
<a name="ln365">                  fname_esc,</a>
<a name="ln366">                  fname_esc,</a>
<a name="ln367">                  fname_esc,</a>
<a name="ln368">                  fname_esc) &lt; 0) {</a>
<a name="ln369">        xfree(fname_esc);</a>
<a name="ln370">        return FAIL;</a>
<a name="ln371">      }</a>
<a name="ln372">    } else {</a>
<a name="ln373">      // No file in this buffer, just make it empty.</a>
<a name="ln374">      PUTLINE_FAIL(&quot;enew&quot;);</a>
<a name="ln375">      if (wp-&gt;w_buffer-&gt;b_ffname != NULL) {</a>
<a name="ln376">        // The buffer does have a name, but it's not a file name.</a>
<a name="ln377">        if (fprintf(fd, &quot;file %s\n&quot;, fname_esc) &lt; 0) {</a>
<a name="ln378">          xfree(fname_esc);</a>
<a name="ln379">          return FAIL;</a>
<a name="ln380">        }</a>
<a name="ln381">      }</a>
<a name="ln382">      do_cursor = false;</a>
<a name="ln383">    }</a>
<a name="ln384">    xfree(fname_esc);</a>
<a name="ln385">  }</a>
<a name="ln386"> </a>
<a name="ln387">  if (wp-&gt;w_alt_fnum) {</a>
<a name="ln388">    buf_T *const alt = buflist_findnr(wp-&gt;w_alt_fnum);</a>
<a name="ln389"> </a>
<a name="ln390">    // Set the alternate file if the buffer is listed.</a>
<a name="ln391">    if ((flagp == &amp;ssop_flags) &amp;&amp; alt != NULL &amp;&amp; alt-&gt;b_fname != NULL</a>
<a name="ln392">        &amp;&amp; *alt-&gt;b_fname != NUL</a>
<a name="ln393">        &amp;&amp; alt-&gt;b_p_bl</a>
<a name="ln394">        &amp;&amp; (fputs(&quot;balt &quot;, fd) &lt; 0</a>
<a name="ln395">            || ses_fname(fd, alt, flagp, true) == FAIL)) {</a>
<a name="ln396">      return FAIL;</a>
<a name="ln397">    }</a>
<a name="ln398">  }</a>
<a name="ln399"> </a>
<a name="ln400">  //</a>
<a name="ln401">  // Local mappings and abbreviations.</a>
<a name="ln402">  //</a>
<a name="ln403">  if ((*flagp &amp; (SSOP_OPTIONS | SSOP_LOCALOPTIONS))</a>
<a name="ln404">      &amp;&amp; makemap(fd, wp-&gt;w_buffer) == FAIL) {</a>
<a name="ln405">    return FAIL;</a>
<a name="ln406">  }</a>
<a name="ln407"> </a>
<a name="ln408">  //</a>
<a name="ln409">  // Local options.  Need to go to the window temporarily.</a>
<a name="ln410">  // Store only local values when using &quot;:mkview&quot; and when &quot;:mksession&quot; is</a>
<a name="ln411">  // used and 'sessionoptions' doesn't include &quot;nvim/options&quot;.</a>
<a name="ln412">  // Some folding options are always stored when &quot;folds&quot; is included,</a>
<a name="ln413">  // otherwise the folds would not be restored correctly.</a>
<a name="ln414">  //</a>
<a name="ln415">  save_curwin = curwin;</a>
<a name="ln416">  curwin = wp;</a>
<a name="ln417">  curbuf = curwin-&gt;w_buffer;</a>
<a name="ln418">  if (*flagp &amp; (SSOP_OPTIONS | SSOP_LOCALOPTIONS)) {</a>
<a name="ln419">    f = makeset(fd, OPT_LOCAL,</a>
<a name="ln420">                flagp == &amp;vop_flags || !(*flagp &amp; SSOP_OPTIONS));</a>
<a name="ln421">  } else if (*flagp &amp; SSOP_FOLDS) {</a>
<a name="ln422">    f = makefoldset(fd);</a>
<a name="ln423">  } else {</a>
<a name="ln424">    f = OK;</a>
<a name="ln425">  }</a>
<a name="ln426">  curwin = save_curwin;</a>
<a name="ln427">  curbuf = curwin-&gt;w_buffer;</a>
<a name="ln428">  if (f == FAIL) {</a>
<a name="ln429">    return FAIL;</a>
<a name="ln430">  }</a>
<a name="ln431"> </a>
<a name="ln432">  //</a>
<a name="ln433">  // Save Folds when 'buftype' is empty and for help files.</a>
<a name="ln434">  //</a>
<a name="ln435">  if ((*flagp &amp; SSOP_FOLDS)</a>
<a name="ln436">      &amp;&amp; wp-&gt;w_buffer-&gt;b_ffname != NULL</a>
<a name="ln437">      &amp;&amp; (bt_normal(wp-&gt;w_buffer) || bt_help(wp-&gt;w_buffer))</a>
<a name="ln438">      ) {</a>
<a name="ln439">    if (put_folds(fd, wp) == FAIL) {</a>
<a name="ln440">      return FAIL;</a>
<a name="ln441">    }</a>
<a name="ln442">  }</a>
<a name="ln443"> </a>
<a name="ln444">  //</a>
<a name="ln445">  // Set the cursor after creating folds, since that moves the cursor.</a>
<a name="ln446">  //</a>
<a name="ln447">  if (do_cursor) {</a>
<a name="ln448">    // Restore the cursor line in the file and relatively in the</a>
<a name="ln449">    // window.  Don't use &quot;G&quot;, it changes the jumplist.</a>
<a name="ln450">    if (wp-&gt;w_height_inner &lt;= 0) {</a>
<a name="ln451">      if (fprintf(fd, &quot;let s:l = %&quot; PRIdLINENR &quot;\n&quot;, wp-&gt;w_cursor.lnum) &lt; 0) {</a>
<a name="ln452">        return FAIL;</a>
<a name="ln453">      }</a>
<a name="ln454">    } else if (fprintf(fd,</a>
<a name="ln455">                       &quot;let s:l = %&quot; PRIdLINENR &quot; - ((%&quot; PRIdLINENR</a>
<a name="ln456">                       &quot; * winheight(0) + %&quot; PRId64 &quot;) / %&quot; PRId64 &quot;)\n&quot;,</a>
<a name="ln457">                       wp-&gt;w_cursor.lnum,</a>
<a name="ln458">                       wp-&gt;w_cursor.lnum - wp-&gt;w_topline,</a>
<a name="ln459">                       (int64_t)(wp-&gt;w_height_inner / 2),</a>
<a name="ln460">                       (int64_t)wp-&gt;w_height_inner) &lt; 0) {</a>
<a name="ln461">      return FAIL;</a>
<a name="ln462">    }</a>
<a name="ln463">    if (fprintf(fd,</a>
<a name="ln464">                &quot;if s:l &lt; 1 | let s:l = 1 | endif\n&quot;</a>
<a name="ln465">                &quot;keepjumps exe s:l\n&quot;</a>
<a name="ln466">                &quot;normal! zt\n&quot;</a>
<a name="ln467">                &quot;keepjumps %&quot; PRIdLINENR &quot;\n&quot;,</a>
<a name="ln468">                wp-&gt;w_cursor.lnum) &lt; 0) {</a>
<a name="ln469">      return FAIL;</a>
<a name="ln470">    }</a>
<a name="ln471">    // Restore the cursor column and left offset when not wrapping.</a>
<a name="ln472">    if (wp-&gt;w_cursor.col == 0) {</a>
<a name="ln473">      PUTLINE_FAIL(&quot;normal! 0&quot;);</a>
<a name="ln474">    } else {</a>
<a name="ln475">      if (!wp-&gt;w_p_wrap &amp;&amp; wp-&gt;w_leftcol &gt; 0 &amp;&amp; wp-&gt;w_width &gt; 0) {</a>
<a name="ln476">        if (fprintf(fd,</a>
<a name="ln477">                    &quot;let s:c = %&quot; PRId64 &quot; - ((%&quot; PRId64</a>
<a name="ln478">                    &quot; * winwidth(0) + %&quot; PRId64 &quot;) / %&quot; PRId64 &quot;)\n&quot;</a>
<a name="ln479">                    &quot;if s:c &gt; 0\n&quot;</a>
<a name="ln480">                    &quot;  exe 'normal! ' . s:c . '|zs' . %&quot; PRId64 &quot; . '|'\n&quot;</a>
<a name="ln481">                    &quot;else\n&quot;,</a>
<a name="ln482">                    (int64_t)wp-&gt;w_virtcol + 1,</a>
<a name="ln483">                    (int64_t)(wp-&gt;w_virtcol - wp-&gt;w_leftcol),</a>
<a name="ln484">                    (int64_t)(wp-&gt;w_width / 2),</a>
<a name="ln485">                    (int64_t)wp-&gt;w_width,</a>
<a name="ln486">                    (int64_t)wp-&gt;w_virtcol + 1) &lt; 0</a>
<a name="ln487">            || put_view_curpos(fd, wp, &quot;  &quot;) == FAIL</a>
<a name="ln488">            || put_line(fd, &quot;endif&quot;) == FAIL) {</a>
<a name="ln489">          return FAIL;</a>
<a name="ln490">        }</a>
<a name="ln491">      } else if (put_view_curpos(fd, wp, &quot;&quot;) == FAIL) {</a>
<a name="ln492">        return FAIL;</a>
<a name="ln493">      }</a>
<a name="ln494">    }</a>
<a name="ln495">  }</a>
<a name="ln496"> </a>
<a name="ln497">  //</a>
<a name="ln498">  // Local directory, if the current flag is not view options or the &quot;curdir&quot;</a>
<a name="ln499">  // option is included.</a>
<a name="ln500">  //</a>
<a name="ln501">  if (wp-&gt;w_localdir != NULL</a>
<a name="ln502">      &amp;&amp; (flagp != &amp;vop_flags || (*flagp &amp; SSOP_CURDIR))) {</a>
<a name="ln503">    if (fputs(&quot;lcd &quot;, fd) &lt; 0</a>
<a name="ln504">        || ses_put_fname(fd, wp-&gt;w_localdir, flagp) == FAIL</a>
<a name="ln505">        || fprintf(fd, &quot;\n&quot;) &lt; 0) {</a>
<a name="ln506">      return FAIL;</a>
<a name="ln507">    }</a>
<a name="ln508">    did_lcd = true;</a>
<a name="ln509">  }</a>
<a name="ln510"> </a>
<a name="ln511">  return OK;</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">/// Writes commands for restoring the current buffers, for :mksession.</a>
<a name="ln515">///</a>
<a name="ln516">/// Legacy 'sessionoptions'/'viewoptions' flags SSOP_UNIX, SSOP_SLASH are</a>
<a name="ln517">/// always enabled.</a>
<a name="ln518">///</a>
<a name="ln519">/// @param dirnow  Current directory name</a>
<a name="ln520">/// @param fd  File descriptor to write to</a>
<a name="ln521">///</a>
<a name="ln522">/// @return FAIL on error, OK otherwise.</a>
<a name="ln523">static int makeopens(FILE *fd, char_u *dirnow)</a>
<a name="ln524">{</a>
<a name="ln525">  int only_save_windows = true;</a>
<a name="ln526">  int nr;</a>
<a name="ln527">  int restore_size = true;</a>
<a name="ln528">  win_T       *wp;</a>
<a name="ln529">  char_u      *sname;</a>
<a name="ln530">  win_T       *edited_win = NULL;</a>
<a name="ln531">  int tabnr;</a>
<a name="ln532">  win_T       *tab_firstwin;</a>
<a name="ln533">  frame_T     *tab_topframe;</a>
<a name="ln534">  int cur_arg_idx = 0;</a>
<a name="ln535">  int next_arg_idx = 0;</a>
<a name="ln536"> </a>
<a name="ln537">  if (ssop_flags &amp; SSOP_BUFFERS) {</a>
<a name="ln538">    only_save_windows = false;  // Save ALL buffers</a>
<a name="ln539">  }</a>
<a name="ln540"> </a>
<a name="ln541">  // Begin by setting v:this_session, and then other sessionable variables.</a>
<a name="ln542">  PUTLINE_FAIL(&quot;let v:this_session=expand(\&quot;&lt;sfile&gt;:p\&quot;)&quot;);</a>
<a name="ln543">  if (ssop_flags &amp; SSOP_GLOBALS) {</a>
<a name="ln544">    if (store_session_globals(fd) == FAIL) {</a>
<a name="ln545">      return FAIL;</a>
<a name="ln546">    }</a>
<a name="ln547">  }</a>
<a name="ln548"> </a>
<a name="ln549">  // Close all windows and tabs but one.</a>
<a name="ln550">  PUTLINE_FAIL(&quot;silent only&quot;);</a>
<a name="ln551">  if ((ssop_flags &amp; SSOP_TABPAGES)</a>
<a name="ln552">      &amp;&amp; put_line(fd, &quot;silent tabonly&quot;) == FAIL) {</a>
<a name="ln553">    return FAIL;</a>
<a name="ln554">  }</a>
<a name="ln555"> </a>
<a name="ln556">  //</a>
<a name="ln557">  // Now a :cd command to the session directory or the current directory</a>
<a name="ln558">  //</a>
<a name="ln559">  if (ssop_flags &amp; SSOP_SESDIR) {</a>
<a name="ln560">    PUTLINE_FAIL(&quot;exe \&quot;cd \&quot; . escape(expand(\&quot;&lt;sfile&gt;:p:h\&quot;), ' ')&quot;);</a>
<a name="ln561">  } else if (ssop_flags &amp; SSOP_CURDIR) {</a>
<a name="ln562">    sname = home_replace_save(NULL, globaldir != NULL ? globaldir : dirnow);</a>
<a name="ln563">    char *fname_esc = ses_escape_fname((char *)sname, &amp;ssop_flags);</a>
<a name="ln564">    if (fprintf(fd, &quot;cd %s\n&quot;, fname_esc) &lt; 0) {</a>
<a name="ln565">      xfree(fname_esc);</a>
<a name="ln566">      xfree(sname);</a>
<a name="ln567">      return FAIL;</a>
<a name="ln568">    }</a>
<a name="ln569">    xfree(fname_esc);</a>
<a name="ln570">    xfree(sname);</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  if (fprintf(fd,</a>
<a name="ln574">              &quot;%s&quot;,</a>
<a name="ln575">              // If there is an empty, unnamed buffer we will wipe it out later.</a>
<a name="ln576">              // Remember the buffer number.</a>
<a name="ln577">              &quot;if expand('%') == '' &amp;&amp; !&amp;modified &amp;&amp; line('$') &lt;= 1&quot;</a>
<a name="ln578">              &quot; &amp;&amp; getline(1) == ''\n&quot;</a>
<a name="ln579">              &quot;  let s:wipebuf = bufnr('%')\n&quot;</a>
<a name="ln580">              &quot;endif\n&quot;</a>
<a name="ln581">              // Now save the current files, current buffer first.</a>
<a name="ln582">              &quot;set shortmess=aoO\n&quot;) &lt; 0) {</a>
<a name="ln583">    return FAIL;</a>
<a name="ln584">  }</a>
<a name="ln585"> </a>
<a name="ln586">  // Now put the other buffers into the buffer list.</a>
<a name="ln587">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln588">    if (!(only_save_windows &amp;&amp; buf-&gt;b_nwindows == 0)</a>
<a name="ln589">        &amp;&amp; !(buf-&gt;b_help &amp;&amp; !(ssop_flags &amp; SSOP_HELP))</a>
<a name="ln590">        &amp;&amp; buf-&gt;b_fname != NULL</a>
<a name="ln591">        &amp;&amp; buf-&gt;b_p_bl) {</a>
<a name="ln592">      if (fprintf(fd, &quot;badd +%&quot; PRId64 &quot; &quot;,</a>
<a name="ln593">                  buf-&gt;b_wininfo == NULL</a>
<a name="ln594">                  ? (int64_t)1L</a>
<a name="ln595">                  : (int64_t)buf-&gt;b_wininfo-&gt;wi_fpos.lnum) &lt; 0</a>
<a name="ln596">          || ses_fname(fd, buf, &amp;ssop_flags, true) == FAIL) {</a>
<a name="ln597">        return FAIL;</a>
<a name="ln598">      }</a>
<a name="ln599">    }</a>
<a name="ln600">  }</a>
<a name="ln601"> </a>
<a name="ln602">  // the global argument list</a>
<a name="ln603">  if (ses_arglist(fd, &quot;argglobal&quot;, &amp;global_alist.al_ga,</a>
<a name="ln604">                  !(ssop_flags &amp; SSOP_CURDIR), &amp;ssop_flags) == FAIL) {</a>
<a name="ln605">    return FAIL;</a>
<a name="ln606">  }</a>
<a name="ln607"> </a>
<a name="ln608">  if (ssop_flags &amp; SSOP_RESIZE) {</a>
<a name="ln609">    // Note: after the restore we still check it worked!</a>
<a name="ln610">    if (fprintf(fd, &quot;set lines=%&quot; PRId64 &quot; columns=%&quot; PRId64 &quot;\n&quot;,</a>
<a name="ln611">                (int64_t)Rows, (int64_t)Columns) &lt; 0) {</a>
<a name="ln612">      return FAIL;</a>
<a name="ln613">    }</a>
<a name="ln614">  }</a>
<a name="ln615"> </a>
<a name="ln616">  int restore_stal = false;</a>
<a name="ln617">  // When there are two or more tabpages and 'showtabline' is 1 the tabline</a>
<a name="ln618">  // will be displayed when creating the next tab.  That resizes the windows</a>
<a name="ln619">  // in the first tab, which may cause problems.  Set 'showtabline' to 2</a>
<a name="ln620">  // temporarily to avoid that.</a>
<a name="ln621">  if (p_stal == 1 &amp;&amp; first_tabpage-&gt;tp_next != NULL) {</a>
<a name="ln622">    PUTLINE_FAIL(&quot;set stal=2&quot;);</a>
<a name="ln623">    restore_stal = true;</a>
<a name="ln624">  }</a>
<a name="ln625"> </a>
<a name="ln626">  //</a>
<a name="ln627">  // For each tab:</a>
<a name="ln628">  // - Put windows for each tab, when &quot;tabpages&quot; is in 'sessionoptions'.</a>
<a name="ln629">  // - Don't use goto_tabpage(), it may change CWD and trigger autocommands.</a>
<a name="ln630">  //</a>
<a name="ln631">  tab_firstwin = firstwin;      // First window in tab page &quot;tabnr&quot;.</a>
<a name="ln632">  tab_topframe = topframe;</a>
<a name="ln633">  if ((ssop_flags &amp; SSOP_TABPAGES)) {</a>
<a name="ln634">    // Similar to ses_win_rec() below, populate the tab pages first so</a>
<a name="ln635">    // later local options won't be copied to the new tabs.</a>
<a name="ln636">    FOR_ALL_TABS(tp) {</a>
<a name="ln637">      if (tp-&gt;tp_next != NULL &amp;&amp; put_line(fd, &quot;tabnew&quot;) == FAIL) {</a>
<a name="ln638">        return FAIL;</a>
<a name="ln639">      }</a>
<a name="ln640">    }</a>
<a name="ln641"> </a>
<a name="ln642">    if (first_tabpage-&gt;tp_next != NULL &amp;&amp; put_line(fd, &quot;tabrewind&quot;) == FAIL) {</a>
<a name="ln643">      return FAIL;</a>
<a name="ln644">    }</a>
<a name="ln645">  }</a>
<a name="ln646">  for (tabnr = 1;; tabnr++) {</a>
<a name="ln647">    tabpage_T *tp = find_tabpage(tabnr);</a>
<a name="ln648">    if (tp == NULL) {</a>
<a name="ln649">      break;  // done all tab pages</a>
<a name="ln650">    }</a>
<a name="ln651"> </a>
<a name="ln652">    bool need_tabnext = false;</a>
<a name="ln653">    int cnr = 1;</a>
<a name="ln654"> </a>
<a name="ln655">    if ((ssop_flags &amp; SSOP_TABPAGES)) {</a>
<a name="ln656">      if (tp == curtab) {</a>
<a name="ln657">        tab_firstwin = firstwin;</a>
<a name="ln658">        tab_topframe = topframe;</a>
<a name="ln659">      } else {</a>
<a name="ln660">        tab_firstwin = tp-&gt;tp_firstwin;</a>
<a name="ln661">        tab_topframe = tp-&gt;tp_topframe;</a>
<a name="ln662">      }</a>
<a name="ln663">      if (tabnr &gt; 1) {</a>
<a name="ln664">        need_tabnext = true;</a>
<a name="ln665">      }</a>
<a name="ln666">    }</a>
<a name="ln667"> </a>
<a name="ln668">    //</a>
<a name="ln669">    // Before creating the window layout, try loading one file.  If this</a>
<a name="ln670">    // is aborted we don't end up with a number of useless windows.</a>
<a name="ln671">    // This may have side effects! (e.g., compressed or network file).</a>
<a name="ln672">    //</a>
<a name="ln673">    for (wp = tab_firstwin; wp != NULL; wp = wp-&gt;w_next) {</a>
<a name="ln674">      if (ses_do_win(wp)</a>
<a name="ln675">          &amp;&amp; wp-&gt;w_buffer-&gt;b_ffname != NULL</a>
<a name="ln676">          &amp;&amp; !bt_help(wp-&gt;w_buffer)</a>
<a name="ln677">          &amp;&amp; !bt_nofile(wp-&gt;w_buffer)</a>
<a name="ln678">          ) {</a>
<a name="ln679">        if (need_tabnext &amp;&amp; put_line(fd, &quot;tabnext&quot;) == FAIL) {</a>
<a name="ln680">          return FAIL;</a>
<a name="ln681">        }</a>
<a name="ln682">        need_tabnext = false;</a>
<a name="ln683"> </a>
<a name="ln684">        if (fputs(&quot;edit &quot;, fd) &lt; 0</a>
<a name="ln685">            || ses_fname(fd, wp-&gt;w_buffer, &amp;ssop_flags, true) == FAIL) {</a>
<a name="ln686">          return FAIL;</a>
<a name="ln687">        }</a>
<a name="ln688">        if (!wp-&gt;w_arg_idx_invalid) {</a>
<a name="ln689">          edited_win = wp;</a>
<a name="ln690">        }</a>
<a name="ln691">        break;</a>
<a name="ln692">      }</a>
<a name="ln693">    }</a>
<a name="ln694"> </a>
<a name="ln695">    // If no file got edited create an empty tab page.</a>
<a name="ln696">    if (need_tabnext &amp;&amp; put_line(fd, &quot;tabnext&quot;) == FAIL) {</a>
<a name="ln697">      return FAIL;</a>
<a name="ln698">    }</a>
<a name="ln699"> </a>
<a name="ln700">    if (tab_topframe-&gt;fr_layout != FR_LEAF) {</a>
<a name="ln701">      // Save current window layout.</a>
<a name="ln702">      PUTLINE_FAIL(&quot;let s:save_splitbelow = &amp;splitbelow&quot;);</a>
<a name="ln703">      PUTLINE_FAIL(&quot;let s:save_splitright = &amp;splitright&quot;);</a>
<a name="ln704">      PUTLINE_FAIL(&quot;set splitbelow splitright&quot;);</a>
<a name="ln705">      if (ses_win_rec(fd, tab_topframe) == FAIL) {</a>
<a name="ln706">        return FAIL;</a>
<a name="ln707">      }</a>
<a name="ln708">      PUTLINE_FAIL(&quot;let &amp;splitbelow = s:save_splitbelow&quot;);</a>
<a name="ln709">      PUTLINE_FAIL(&quot;let &amp;splitright = s:save_splitright&quot;);</a>
<a name="ln710">    }</a>
<a name="ln711"> </a>
<a name="ln712">    //</a>
<a name="ln713">    // Check if window sizes can be restored (no windows omitted).</a>
<a name="ln714">    // Remember the window number of the current window after restoring.</a>
<a name="ln715">    //</a>
<a name="ln716">    nr = 0;</a>
<a name="ln717">    for (wp = tab_firstwin; wp != NULL; wp = wp-&gt;w_next) {</a>
<a name="ln718">      if (ses_do_win(wp)) {</a>
<a name="ln719">        nr++;</a>
<a name="ln720">      } else {</a>
<a name="ln721">        restore_size = false;</a>
<a name="ln722">      }</a>
<a name="ln723">      if (curwin == wp) {</a>
<a name="ln724">        cnr = nr;</a>
<a name="ln725">      }</a>
<a name="ln726">    }</a>
<a name="ln727"> </a>
<a name="ln728">    if (tab_firstwin != NULL &amp;&amp; tab_firstwin-&gt;w_next != NULL) {</a>
<a name="ln729">      // Go to the first window.</a>
<a name="ln730">      PUTLINE_FAIL(&quot;wincmd t&quot;);</a>
<a name="ln731"> </a>
<a name="ln732">      // If more than one window, see if sizes can be restored.</a>
<a name="ln733">      // First set 'winheight' and 'winwidth' to 1 to avoid the windows</a>
<a name="ln734">      // being resized when moving between windows.</a>
<a name="ln735">      // Do this before restoring the view, so that the topline and the</a>
<a name="ln736">      // cursor can be set.  This is done again below.</a>
<a name="ln737">      // winminheight and winminwidth need to be set to avoid an error if</a>
<a name="ln738">      // the user has set winheight or winwidth.</a>
<a name="ln739">      PUTLINE_FAIL(&quot;let s:save_winminheight = &amp;winminheight&quot;);</a>
<a name="ln740">      PUTLINE_FAIL(&quot;let s:save_winminwidth = &amp;winminwidth&quot;);</a>
<a name="ln741">      if (fprintf(fd,</a>
<a name="ln742">                  &quot;set winminheight=0\n&quot;</a>
<a name="ln743">                  &quot;set winheight=1\n&quot;</a>
<a name="ln744">                  &quot;set winminwidth=0\n&quot;</a>
<a name="ln745">                  &quot;set winwidth=1\n&quot;) &lt; 0) {</a>
<a name="ln746">        return FAIL;</a>
<a name="ln747">      }</a>
<a name="ln748">    }</a>
<a name="ln749">    if (nr &gt; 1 &amp;&amp; ses_winsizes(fd, restore_size, tab_firstwin) == FAIL) {</a>
<a name="ln750">      return FAIL;</a>
<a name="ln751">    }</a>
<a name="ln752"> </a>
<a name="ln753">    //</a>
<a name="ln754">    // Restore the view of the window (options, file, cursor, etc.).</a>
<a name="ln755">    //</a>
<a name="ln756">    for (wp = tab_firstwin; wp != NULL; wp = wp-&gt;w_next) {</a>
<a name="ln757">      if (!ses_do_win(wp)) {</a>
<a name="ln758">        continue;</a>
<a name="ln759">      }</a>
<a name="ln760">      if (put_view(fd, wp, wp != edited_win, &amp;ssop_flags, cur_arg_idx)</a>
<a name="ln761">          == FAIL) {</a>
<a name="ln762">        return FAIL;</a>
<a name="ln763">      }</a>
<a name="ln764">      if (nr &gt; 1 &amp;&amp; put_line(fd, &quot;wincmd w&quot;) == FAIL) {</a>
<a name="ln765">        return FAIL;</a>
<a name="ln766">      }</a>
<a name="ln767">      next_arg_idx = wp-&gt;w_arg_idx;</a>
<a name="ln768">    }</a>
<a name="ln769"> </a>
<a name="ln770">    // The argument index in the first tab page is zero, need to set it in</a>
<a name="ln771">    // each window.  For further tab pages it's the window where we do</a>
<a name="ln772">    // &quot;tabedit&quot;.</a>
<a name="ln773">    cur_arg_idx = next_arg_idx;</a>
<a name="ln774"> </a>
<a name="ln775">    //</a>
<a name="ln776">    // Restore cursor to the current window if it's not the first one.</a>
<a name="ln777">    //</a>
<a name="ln778">    if (cnr &gt; 1 &amp;&amp; (fprintf(fd, &quot;%dwincmd w\n&quot;, cnr) &lt; 0)) {</a>
<a name="ln779">      return FAIL;</a>
<a name="ln780">    }</a>
<a name="ln781"> </a>
<a name="ln782">    //</a>
<a name="ln783">    // Restore window sizes again after jumping around in windows, because</a>
<a name="ln784">    // the current window has a minimum size while others may not.</a>
<a name="ln785">    //</a>
<a name="ln786">    if (nr &gt; 1 &amp;&amp; ses_winsizes(fd, restore_size, tab_firstwin) == FAIL) {</a>
<a name="ln787">      return FAIL;</a>
<a name="ln788">    }</a>
<a name="ln789"> </a>
<a name="ln790">    // Take care of tab-local working directories if applicable</a>
<a name="ln791">    if (tp-&gt;tp_localdir) {</a>
<a name="ln792">      if (fputs(&quot;if exists(':tcd') == 2 | tcd &quot;, fd) &lt; 0</a>
<a name="ln793">          || ses_put_fname(fd, tp-&gt;tp_localdir, &amp;ssop_flags) == FAIL</a>
<a name="ln794">          || fputs(&quot; | endif\n&quot;, fd) &lt; 0) {</a>
<a name="ln795">        return FAIL;</a>
<a name="ln796">      }</a>
<a name="ln797">      did_lcd = true;</a>
<a name="ln798">    }</a>
<a name="ln799"> </a>
<a name="ln800">    // Don't continue in another tab page when doing only the current one</a>
<a name="ln801">    // or when at the last tab page.</a>
<a name="ln802">    if (!(ssop_flags &amp; SSOP_TABPAGES)) {</a>
<a name="ln803">      break;</a>
<a name="ln804">    }</a>
<a name="ln805">  }</a>
<a name="ln806"> </a>
<a name="ln807">  if (ssop_flags &amp; SSOP_TABPAGES) {</a>
<a name="ln808">    if (fprintf(fd, &quot;tabnext %d\n&quot;, tabpage_index(curtab)) &lt; 0) {</a>
<a name="ln809">      return FAIL;</a>
<a name="ln810">    }</a>
<a name="ln811">  }</a>
<a name="ln812">  if (restore_stal &amp;&amp; put_line(fd, &quot;set stal=1&quot;) == FAIL) {</a>
<a name="ln813">    return FAIL;</a>
<a name="ln814">  }</a>
<a name="ln815"> </a>
<a name="ln816">  //</a>
<a name="ln817">  // Wipe out an empty unnamed buffer we started in.</a>
<a name="ln818">  //</a>
<a name="ln819">  if (fprintf(fd, &quot;%s&quot;,</a>
<a name="ln820">              &quot;if exists('s:wipebuf') &quot;</a>
<a name="ln821">              &quot;&amp;&amp; len(win_findbuf(s:wipebuf)) == 0&quot;</a>
<a name="ln822">              &quot;&amp;&amp; getbufvar(s:wipebuf, '&amp;buftype') isnot# 'terminal'\n&quot;</a>
<a name="ln823">              &quot;  silent exe 'bwipe ' . s:wipebuf\n&quot;</a>
<a name="ln824">              &quot;endif\n&quot;</a>
<a name="ln825">              &quot;unlet! s:wipebuf\n&quot;) &lt; 0) {</a>
<a name="ln826">    return FAIL;</a>
<a name="ln827">  }</a>
<a name="ln828"> </a>
<a name="ln829">  // Re-apply 'winheight', 'winwidth' and 'shortmess'.</a>
<a name="ln830">  if (fprintf(fd,</a>
<a name="ln831">              &quot;set winheight=%&quot; PRId64 &quot; winwidth=%&quot; PRId64</a>
<a name="ln832">              &quot; shortmess=%s\n&quot;,</a>
<a name="ln833">              (int64_t)p_wh,</a>
<a name="ln834">              (int64_t)p_wiw,</a>
<a name="ln835">              p_shm) &lt; 0) {</a>
<a name="ln836">    return FAIL;</a>
<a name="ln837">  }</a>
<a name="ln838">  if (tab_firstwin != NULL &amp;&amp; tab_firstwin-&gt;w_next != NULL) {</a>
<a name="ln839">    // Restore 'winminheight' and 'winminwidth'.</a>
<a name="ln840">    PUTLINE_FAIL(&quot;let &amp;winminheight = s:save_winminheight&quot;);</a>
<a name="ln841">    PUTLINE_FAIL(&quot;let &amp;winminwidth = s:save_winminwidth&quot;);</a>
<a name="ln842">  }</a>
<a name="ln843"> </a>
<a name="ln844">  //</a>
<a name="ln845">  // Lastly, execute the x.vim file if it exists.</a>
<a name="ln846">  //</a>
<a name="ln847">  if (fprintf(fd, &quot;%s&quot;,</a>
<a name="ln848">              &quot;let s:sx = expand(\&quot;&lt;sfile&gt;:p:r\&quot;).\&quot;x.vim\&quot;\n&quot;</a>
<a name="ln849">              &quot;if filereadable(s:sx)\n&quot;</a>
<a name="ln850">              &quot;  exe \&quot;source \&quot; . fnameescape(s:sx)\n&quot;</a>
<a name="ln851">              &quot;endif\n&quot;) &lt; 0) {</a>
<a name="ln852">    return FAIL;</a>
<a name="ln853">  }</a>
<a name="ln854"> </a>
<a name="ln855">  return OK;</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">/// &quot;:loadview [nr]&quot;</a>
<a name="ln859">void ex_loadview(exarg_T *eap)</a>
<a name="ln860">{</a>
<a name="ln861">  char *fname = get_view_file(*eap-&gt;arg);</a>
<a name="ln862">  if (fname != NULL) {</a>
<a name="ln863">    if (do_source((char_u *)fname, false, DOSO_NONE) == FAIL) {</a>
<a name="ln864">      EMSG2(_(e_notopen), fname);</a>
<a name="ln865">    }</a>
<a name="ln866">    xfree(fname);</a>
<a name="ln867">  }</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">/// &quot;:mkexrc&quot;, &quot;:mkvimrc&quot;, &quot;:mkview&quot;, &quot;:mksession&quot;.</a>
<a name="ln871">///</a>
<a name="ln872">/// Legacy 'sessionoptions'/'viewoptions' flags are always enabled:</a>
<a name="ln873">///   - SSOP_UNIX: line-endings are LF</a>
<a name="ln874">///   - SSOP_SLASH: filenames are written with &quot;/&quot; slash</a>
<a name="ln875">void ex_mkrc(exarg_T *eap)</a>
<a name="ln876">{</a>
<a name="ln877">  FILE        *fd;</a>
<a name="ln878">  int failed = false;</a>
<a name="ln879">  int view_session = false;  // :mkview, :mksession</a>
<a name="ln880">  int using_vdir = false;  // using 'viewdir'?</a>
<a name="ln881">  char *viewFile = NULL;</a>
<a name="ln882">  unsigned    *flagp;</a>
<a name="ln883"> </a>
<a name="ln884">  if (eap-&gt;cmdidx == CMD_mksession || eap-&gt;cmdidx == CMD_mkview) {</a>
<a name="ln885">    view_session = true;</a>
<a name="ln886">  }</a>
<a name="ln887"> </a>
<a name="ln888">  // Use the short file name until &quot;:lcd&quot; is used.  We also don't use the</a>
<a name="ln889">  // short file name when 'acd' is set, that is checked later.</a>
<a name="ln890">  did_lcd = false;</a>
<a name="ln891"> </a>
<a name="ln892">  char *fname;</a>
<a name="ln893">  // &quot;:mkview&quot; or &quot;:mkview 9&quot;: generate file name with 'viewdir'</a>
<a name="ln894">  if (eap-&gt;cmdidx == CMD_mkview</a>
<a name="ln895">      &amp;&amp; (*eap-&gt;arg == NUL</a>
<a name="ln896">          || (ascii_isdigit(*eap-&gt;arg) &amp;&amp; eap-&gt;arg[1] == NUL))) {</a>
<a name="ln897">    eap-&gt;forceit = true;</a>
<a name="ln898">    fname = get_view_file(*eap-&gt;arg);</a>
<a name="ln899">    if (fname == NULL) {</a>
<a name="ln900">      return;</a>
<a name="ln901">    }</a>
<a name="ln902">    viewFile = fname;</a>
<a name="ln903">    using_vdir = true;</a>
<a name="ln904">  } else if (*eap-&gt;arg != NUL) {</a>
<a name="ln905">    fname = (char *)eap-&gt;arg;</a>
<a name="ln906">  } else if (eap-&gt;cmdidx == CMD_mkvimrc) {</a>
<a name="ln907">    fname = VIMRC_FILE;</a>
<a name="ln908">  } else if (eap-&gt;cmdidx == CMD_mksession) {</a>
<a name="ln909">    fname = SESSION_FILE;</a>
<a name="ln910">  } else {</a>
<a name="ln911">    fname = EXRC_FILE;</a>
<a name="ln912">  }</a>
<a name="ln913"> </a>
<a name="ln914">  // When using 'viewdir' may have to create the directory.</a>
<a name="ln915">  if (using_vdir &amp;&amp; !os_isdir(p_vdir)) {</a>
<a name="ln916">    vim_mkdir_emsg((const char *)p_vdir, 0755);</a>
<a name="ln917">  }</a>
<a name="ln918"> </a>
<a name="ln919">  fd = open_exfile((char_u *)fname, eap-&gt;forceit, WRITEBIN);</a>
<a name="ln920">  if (fd != NULL) {</a>
<a name="ln921">    if (eap-&gt;cmdidx == CMD_mkview) {</a>
<a name="ln922">      flagp = &amp;vop_flags;</a>
<a name="ln923">    } else {</a>
<a name="ln924">      flagp = &amp;ssop_flags;</a>
<a name="ln925">    }</a>
<a name="ln926"> </a>
<a name="ln927">    // Write the version command for :mkvimrc</a>
<a name="ln928">    if (eap-&gt;cmdidx == CMD_mkvimrc) {</a>
<a name="ln929">      (void)put_line(fd, &quot;version 6.0&quot;);</a>
<a name="ln930">    }</a>
<a name="ln931"> </a>
<a name="ln932">    if (eap-&gt;cmdidx == CMD_mksession) {</a>
<a name="ln933">      if (put_line(fd, &quot;let SessionLoad = 1&quot;) == FAIL) {</a>
<a name="ln934">        failed = true;</a>
<a name="ln935">      }</a>
<a name="ln936">    }</a>
<a name="ln937"> </a>
<a name="ln938">    if (!view_session || (eap-&gt;cmdidx == CMD_mksession</a>
<a name="ln939">                          &amp;&amp; (*flagp &amp; SSOP_OPTIONS))) {</a>
<a name="ln940">      int flags = OPT_GLOBAL;</a>
<a name="ln941"> </a>
<a name="ln942">      if (eap-&gt;cmdidx == CMD_mksession &amp;&amp; (*flagp &amp; SSOP_SKIP_RTP)) {</a>
<a name="ln943">        flags |= OPT_SKIPRTP;</a>
<a name="ln944">      }</a>
<a name="ln945">      failed |= (makemap(fd, NULL) == FAIL</a>
<a name="ln946">                 || makeset(fd, flags, false) == FAIL);</a>
<a name="ln947">    }</a>
<a name="ln948"> </a>
<a name="ln949">    if (!failed &amp;&amp; view_session) {</a>
<a name="ln950">      if (put_line(fd,</a>
<a name="ln951">                   &quot;let s:so_save = &amp;g:so | let s:siso_save = &amp;g:siso&quot;</a>
<a name="ln952">                   &quot; | setg so=0 siso=0 | setl so=-1 siso=-1&quot;) == FAIL) {</a>
<a name="ln953">        failed = true;</a>
<a name="ln954">      }</a>
<a name="ln955">      if (eap-&gt;cmdidx == CMD_mksession) {</a>
<a name="ln956">        char_u *dirnow;  // current directory</a>
<a name="ln957"> </a>
<a name="ln958">        dirnow = xmalloc(MAXPATHL);</a>
<a name="ln959">        //</a>
<a name="ln960">        // Change to session file's dir.</a>
<a name="ln961">        //</a>
<a name="ln962">        if (os_dirname(dirnow, MAXPATHL) == FAIL</a>
<a name="ln963">            || os_chdir((char *)dirnow) != 0) {</a>
<a name="ln964">          *dirnow = NUL;</a>
<a name="ln965">        }</a>
<a name="ln966">        if (*dirnow != NUL &amp;&amp; (ssop_flags &amp; SSOP_SESDIR)) {</a>
<a name="ln967">          if (vim_chdirfile((char_u *)fname) == OK) {</a>
<a name="ln968">            shorten_fnames(true);</a>
<a name="ln969">          }</a>
<a name="ln970">        } else if (*dirnow != NUL</a>
<a name="ln971">                   &amp;&amp; (ssop_flags &amp; SSOP_CURDIR) &amp;&amp; globaldir != NULL) {</a>
<a name="ln972">          if (os_chdir((char *)globaldir) == 0) {</a>
<a name="ln973">            shorten_fnames(true);</a>
<a name="ln974">          }</a>
<a name="ln975">        }</a>
<a name="ln976"> </a>
<a name="ln977">        failed |= (makeopens(fd, dirnow) == FAIL);</a>
<a name="ln978"> </a>
<a name="ln979">        // restore original dir</a>
<a name="ln980">        if (*dirnow != NUL &amp;&amp; ((ssop_flags &amp; SSOP_SESDIR)</a>
<a name="ln981">                               || ((ssop_flags &amp; SSOP_CURDIR) &amp;&amp; globaldir !=</a>
<a name="ln982">                                   NULL))) {</a>
<a name="ln983">          if (os_chdir((char *)dirnow) != 0) {</a>
<a name="ln984">            EMSG(_(e_prev_dir));</a>
<a name="ln985">          }</a>
<a name="ln986">          shorten_fnames(true);</a>
<a name="ln987">          // restore original dir</a>
<a name="ln988">          if (*dirnow != NUL &amp;&amp; ((ssop_flags &amp; SSOP_SESDIR)</a>
<a name="ln989">                                 || ((ssop_flags &amp; SSOP_CURDIR) &amp;&amp; globaldir !=</a>
<a name="ln990">                                     NULL))) {</a>
<a name="ln991">            if (os_chdir((char *)dirnow) != 0) {</a>
<a name="ln992">              EMSG(_(e_prev_dir));</a>
<a name="ln993">            }</a>
<a name="ln994">            shorten_fnames(true);</a>
<a name="ln995">          }</a>
<a name="ln996">        }</a>
<a name="ln997">        xfree(dirnow);</a>
<a name="ln998">      } else {</a>
<a name="ln999">        failed |= (put_view(fd, curwin, !using_vdir, flagp, -1) == FAIL);</a>
<a name="ln1000">      }</a>
<a name="ln1001">      if (fprintf(fd,</a>
<a name="ln1002">                  &quot;%s&quot;,</a>
<a name="ln1003">                  &quot;let &amp;g:so = s:so_save | let &amp;g:siso = s:siso_save\n&quot;)</a>
<a name="ln1004">          &lt; 0) {</a>
<a name="ln1005">        failed = true;</a>
<a name="ln1006">      }</a>
<a name="ln1007">      if (p_hls &amp;&amp; fprintf(fd, &quot;%s&quot;, &quot;set hlsearch\n&quot;) &lt; 0) {</a>
<a name="ln1008">        failed = true;</a>
<a name="ln1009">      }</a>
<a name="ln1010">      if (no_hlsearch &amp;&amp; fprintf(fd, &quot;%s&quot;, &quot;nohlsearch\n&quot;) &lt; 0) {</a>
<a name="ln1011">        failed = true;</a>
<a name="ln1012">      }</a>
<a name="ln1013">      if (fprintf(fd, &quot;%s&quot;, &quot;doautoall SessionLoadPost\n&quot;) &lt; 0) {</a>
<a name="ln1014">        failed = true;</a>
<a name="ln1015">      }</a>
<a name="ln1016">      if (eap-&gt;cmdidx == CMD_mksession) {</a>
<a name="ln1017">        if (fprintf(fd, &quot;unlet SessionLoad\n&quot;) &lt; 0) {</a>
<a name="ln1018">          failed = true;</a>
<a name="ln1019">        }</a>
<a name="ln1020">      }</a>
<a name="ln1021">    }</a>
<a name="ln1022">    if (put_line(fd, &quot;\&quot; vim: set ft=vim :&quot;) == FAIL) {</a>
<a name="ln1023">      failed = true;</a>
<a name="ln1024">    }</a>
<a name="ln1025"> </a>
<a name="ln1026">    failed |= fclose(fd);</a>
<a name="ln1027"> </a>
<a name="ln1028">    if (failed) {</a>
<a name="ln1029">      EMSG(_(e_write));</a>
<a name="ln1030">    } else if (eap-&gt;cmdidx == CMD_mksession) {</a>
<a name="ln1031">      // successful session write - set v:this_session</a>
<a name="ln1032">      char *const tbuf = xmalloc(MAXPATHL);</a>
<a name="ln1033">      if (vim_FullName(fname, tbuf, MAXPATHL, false) == OK) {</a>
<a name="ln1034">        set_vim_var_string(VV_THIS_SESSION, tbuf, -1);</a>
<a name="ln1035">      }</a>
<a name="ln1036">      xfree(tbuf);</a>
<a name="ln1037">    }</a>
<a name="ln1038">  }</a>
<a name="ln1039"> </a>
<a name="ln1040">  xfree(viewFile);</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043">/// Get the name of the view file for the current buffer.</a>
<a name="ln1044">static char *get_view_file(int c)</a>
<a name="ln1045">{</a>
<a name="ln1046">  if (curbuf-&gt;b_ffname == NULL) {</a>
<a name="ln1047">    EMSG(_(e_noname));</a>
<a name="ln1048">    return NULL;</a>
<a name="ln1049">  }</a>
<a name="ln1050">  char *sname = (char *)home_replace_save(NULL, curbuf-&gt;b_ffname);</a>
<a name="ln1051"> </a>
<a name="ln1052">  // We want a file name without separators, because we're not going to make</a>
<a name="ln1053">  // a directory.</a>
<a name="ln1054">  //    &quot;normal&quot; path separator   -&gt; &quot;=+&quot;</a>
<a name="ln1055">  //    &quot;=&quot;                       -&gt; &quot;==&quot;</a>
<a name="ln1056">  //    &quot;:&quot; path separator        -&gt; &quot;=-&quot;</a>
<a name="ln1057">  size_t len = 0;</a>
<a name="ln1058">  for (char *p = sname; *p; p++) {</a>
<a name="ln1059">    if (*p == '=' || vim_ispathsep(*p)) {</a>
<a name="ln1060">      len++;</a>
<a name="ln1061">    }</a>
<a name="ln1062">  }</a>
<a name="ln1063">  char *retval = xmalloc(strlen(sname) + len + STRLEN(p_vdir) + 9);</a>
<a name="ln1064">  STRCPY(retval, p_vdir);</a>
<a name="ln1065">  add_pathsep(retval);</a>
<a name="ln1066">  char *s = retval + strlen(retval);</a>
<a name="ln1067">  for (char *p = sname; *p; p++) {</a>
<a name="ln1068">    if (*p == '=') {</a>
<a name="ln1069">      *s++ = '=';</a>
<a name="ln1070">      *s++ = '=';</a>
<a name="ln1071">    } else if (vim_ispathsep(*p)) {</a>
<a name="ln1072">      *s++ = '=';</a>
<a name="ln1073">#if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln1074">      *s++ = (*p == ':') ? '-' : '+';</a>
<a name="ln1075">#else</a>
<a name="ln1076">      *s++ = '+';</a>
<a name="ln1077">#endif</a>
<a name="ln1078">    } else {</a>
<a name="ln1079">      *s++ = *p;</a>
<a name="ln1080">    }</a>
<a name="ln1081">  }</a>
<a name="ln1082">  *s++ = '=';</a>
<a name="ln1083">  assert(c &gt;= CHAR_MIN &amp;&amp; c &lt;= CHAR_MAX);</a>
<a name="ln1084">  *s++ = (char)c;</a>
<a name="ln1085">  xstrlcpy(s, &quot;.vim&quot;, 5);</a>
<a name="ln1086"> </a>
<a name="ln1087">  xfree(sname);</a>
<a name="ln1088">  return retval;</a>
<a name="ln1089">}</a>
<a name="ln1090"> </a>
<a name="ln1091">// TODO(justinmk): remove this, not needed after 5ba3cecb68cd.</a>
<a name="ln1092">int put_eol(FILE *fd)</a>
<a name="ln1093">{</a>
<a name="ln1094">  if (putc('\n', fd) &lt; 0) {</a>
<a name="ln1095">    return FAIL;</a>
<a name="ln1096">  }</a>
<a name="ln1097">  return OK;</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100">// TODO(justinmk): remove this, not needed after 5ba3cecb68cd.</a>
<a name="ln1101">int put_line(FILE *fd, char *s)</a>
<a name="ln1102">{</a>
<a name="ln1103">  if (fprintf(fd, &quot;%s\n&quot;, s) &lt; 0) {</a>
<a name="ln1104">    return FAIL;</a>
<a name="ln1105">  }</a>
<a name="ln1106">  return OK;</a>
<a name="ln1107">}</a>

</code></pre>
<div class="balloon" rel="454"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'fprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="454"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the sixth actual argument of the 'fprintf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
