
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>spell.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// spell.c: code for spell checking</a>
<a name="ln5">//</a>
<a name="ln6">// See spellfile.c for the Vim spell file format.</a>
<a name="ln7">//</a>
<a name="ln8">// The spell checking mechanism uses a tree (aka trie).  Each node in the tree</a>
<a name="ln9">// has a list of bytes that can appear (siblings).  For each byte there is a</a>
<a name="ln10">// pointer to the node with the byte that follows in the word (child).</a>
<a name="ln11">//</a>
<a name="ln12">// A NUL byte is used where the word may end.  The bytes are sorted, so that</a>
<a name="ln13">// binary searching can be used and the NUL bytes are at the start.  The</a>
<a name="ln14">// number of possible bytes is stored before the list of bytes.</a>
<a name="ln15">//</a>
<a name="ln16">// The tree uses two arrays: &quot;byts&quot; stores the characters, &quot;idxs&quot; stores</a>
<a name="ln17">// either the next index or flags.  The tree starts at index 0.  For example,</a>
<a name="ln18">// to lookup &quot;vi&quot; this sequence is followed:</a>
<a name="ln19">//      i = 0</a>
<a name="ln20">//      len = byts[i]</a>
<a name="ln21">//      n = where &quot;v&quot; appears in byts[i + 1] to byts[i + len]</a>
<a name="ln22">//      i = idxs[n]</a>
<a name="ln23">//      len = byts[i]</a>
<a name="ln24">//      n = where &quot;i&quot; appears in byts[i + 1] to byts[i + len]</a>
<a name="ln25">//      i = idxs[n]</a>
<a name="ln26">//      len = byts[i]</a>
<a name="ln27">//      find that byts[i + 1] is 0, idxs[i + 1] has flags for &quot;vi&quot;.</a>
<a name="ln28">//</a>
<a name="ln29">// There are two word trees: one with case-folded words and one with words in</a>
<a name="ln30">// original case.  The second one is only used for keep-case words and is</a>
<a name="ln31">// usually small.</a>
<a name="ln32">//</a>
<a name="ln33">// There is one additional tree for when not all prefixes are applied when</a>
<a name="ln34">// generating the .spl file.  This tree stores all the possible prefixes, as</a>
<a name="ln35">// if they were words.  At each word (prefix) end the prefix nr is stored, the</a>
<a name="ln36">// following word must support this prefix nr.  And the condition nr is</a>
<a name="ln37">// stored, used to lookup the condition that the word must match with.</a>
<a name="ln38">//</a>
<a name="ln39">// Thanks to Olaf Seibert for providing an example implementation of this tree</a>
<a name="ln40">// and the compression mechanism.</a>
<a name="ln41">// LZ trie ideas:</a>
<a name="ln42">//      http://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf</a>
<a name="ln43">// More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html</a>
<a name="ln44">//</a>
<a name="ln45">// Matching involves checking the caps type: Onecap ALLCAP KeepCap.</a>
<a name="ln46">//</a>
<a name="ln47">// Why doesn't Vim use aspell/ispell/myspell/etc.?</a>
<a name="ln48">// See &quot;:help develop-spell&quot;.</a>
<a name="ln49"> </a>
<a name="ln50">// Use SPELL_PRINTTREE for debugging: dump the word tree after adding a word.</a>
<a name="ln51">// Only use it for small word lists!</a>
<a name="ln52"> </a>
<a name="ln53">// Use SPELL_COMPRESS_ALLWAYS for debugging: compress the word tree after</a>
<a name="ln54">// adding a word.  Only use it for small word lists!</a>
<a name="ln55"> </a>
<a name="ln56">// Use DEBUG_TRIEWALK to print the changes made in suggest_trie_walk() for a</a>
<a name="ln57">// specific word.</a>
<a name="ln58"> </a>
<a name="ln59">// Use this to adjust the score after finding suggestions, based on the</a>
<a name="ln60">// suggested word sounding like the bad word.  This is much faster than doing</a>
<a name="ln61">// it for every possible suggestion.</a>
<a name="ln62">// Disadvantage: When &quot;the&quot; is typed as &quot;hte&quot; it sounds quite different (&quot;@&quot;</a>
<a name="ln63">// vs &quot;ht&quot;) and goes down in the list.</a>
<a name="ln64">// Used when 'spellsuggest' is set to &quot;best&quot;.</a>
<a name="ln65">#define RESCORE(word_score, sound_score) ((3 * word_score + sound_score) / 4)</a>
<a name="ln66"> </a>
<a name="ln67">// Do the opposite: based on a maximum end score and a known sound score,</a>
<a name="ln68">// compute the maximum word score that can be used.</a>
<a name="ln69">#define MAXSCORE(word_score, sound_score) ((4 * word_score - sound_score) / 3)</a>
<a name="ln70"> </a>
<a name="ln71">#include &lt;assert.h&gt;</a>
<a name="ln72">#include &lt;inttypes.h&gt;</a>
<a name="ln73">#include &lt;limits.h&gt;</a>
<a name="ln74">#include &lt;stdbool.h&gt;</a>
<a name="ln75">#include &lt;string.h&gt;</a>
<a name="ln76">#include &lt;stdlib.h&gt;</a>
<a name="ln77">#include &lt;wctype.h&gt;</a>
<a name="ln78"> </a>
<a name="ln79">/* for offsetof() */</a>
<a name="ln80">#include &lt;stddef.h&gt;</a>
<a name="ln81"> </a>
<a name="ln82">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln83">#include &quot;nvim/spell.h&quot;</a>
<a name="ln84">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln85">#include &quot;nvim/change.h&quot;</a>
<a name="ln86">#include &quot;nvim/charset.h&quot;</a>
<a name="ln87">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln88">#include &quot;nvim/edit.h&quot;</a>
<a name="ln89">#include &quot;nvim/eval.h&quot;</a>
<a name="ln90">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln91">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln92">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln93">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln94">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln95">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln96">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln97">#include &quot;nvim/mark.h&quot;</a>
<a name="ln98">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln99">#include &quot;nvim/memline.h&quot;</a>
<a name="ln100">#include &quot;nvim/memory.h&quot;</a>
<a name="ln101">#include &quot;nvim/message.h&quot;</a>
<a name="ln102">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln103">#include &quot;nvim/garray.h&quot;</a>
<a name="ln104">#include &quot;nvim/normal.h&quot;</a>
<a name="ln105">#include &quot;nvim/option.h&quot;</a>
<a name="ln106">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln107">#include &quot;nvim/path.h&quot;</a>
<a name="ln108">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln109">#include &quot;nvim/screen.h&quot;</a>
<a name="ln110">#include &quot;nvim/search.h&quot;</a>
<a name="ln111">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln112">#include &quot;nvim/strings.h&quot;</a>
<a name="ln113">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln114">#include &quot;nvim/undo.h&quot;</a>
<a name="ln115">#include &quot;nvim/ui.h&quot;</a>
<a name="ln116">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln117">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln118"> </a>
<a name="ln119">// only used for su_badflags</a>
<a name="ln120">#define WF_MIXCAP   0x20        // mix of upper and lower case: macaRONI</a>
<a name="ln121"> </a>
<a name="ln122">#define WF_CAPMASK (WF_ONECAP | WF_ALLCAP | WF_KEEPCAP | WF_FIXCAP)</a>
<a name="ln123"> </a>
<a name="ln124">// Result values.  Lower number is accepted over higher one.</a>
<a name="ln125">#define SP_BANNED       -1</a>
<a name="ln126">#define SP_RARE         0</a>
<a name="ln127">#define SP_OK           1</a>
<a name="ln128">#define SP_LOCAL        2</a>
<a name="ln129">#define SP_BAD          3</a>
<a name="ln130"> </a>
<a name="ln131">// First language that is loaded, start of the linked list of loaded</a>
<a name="ln132">// languages.</a>
<a name="ln133">slang_T *first_lang = NULL;</a>
<a name="ln134"> </a>
<a name="ln135">// file used for &quot;zG&quot; and &quot;zW&quot;</a>
<a name="ln136">char_u *int_wordlist = NULL;</a>
<a name="ln137"> </a>
<a name="ln138">typedef struct wordcount_S {</a>
<a name="ln139">  uint16_t wc_count;                // nr of times word was seen</a>
<a name="ln140">  char_u wc_word[1];                // word, actually longer</a>
<a name="ln141">} wordcount_T;</a>
<a name="ln142"> </a>
<a name="ln143">#define WC_KEY_OFF   offsetof(wordcount_T, wc_word)</a>
<a name="ln144">#define HI2WC(hi)    ((wordcount_T *)((hi)-&gt;hi_key - WC_KEY_OFF))</a>
<a name="ln145">#define MAXWORDCOUNT 0xffff</a>
<a name="ln146"> </a>
<a name="ln147">// Information used when looking for suggestions.</a>
<a name="ln148">typedef struct suginfo_S {</a>
<a name="ln149">  garray_T su_ga;                   // suggestions, contains &quot;suggest_T&quot;</a>
<a name="ln150">  int su_maxcount;                  // max. number of suggestions displayed</a>
<a name="ln151">  int su_maxscore;                  // maximum score for adding to su_ga</a>
<a name="ln152">  int su_sfmaxscore;                // idem, for when doing soundfold words</a>
<a name="ln153">  garray_T su_sga;                  // like su_ga, sound-folded scoring</a>
<a name="ln154">  char_u      *su_badptr;           // start of bad word in line</a>
<a name="ln155">  int su_badlen;                    // length of detected bad word in line</a>
<a name="ln156">  int su_badflags;                  // caps flags for bad word</a>
<a name="ln157">  char_u su_badword[MAXWLEN];       // bad word truncated at su_badlen</a>
<a name="ln158">  char_u su_fbadword[MAXWLEN];      // su_badword case-folded</a>
<a name="ln159">  char_u su_sal_badword[MAXWLEN];   // su_badword soundfolded</a>
<a name="ln160">  hashtab_T su_banned;              // table with banned words</a>
<a name="ln161">  slang_T     *su_sallang;          // default language for sound folding</a>
<a name="ln162">} suginfo_T;</a>
<a name="ln163"> </a>
<a name="ln164">// One word suggestion.  Used in &quot;si_ga&quot;.</a>
<a name="ln165">typedef struct {</a>
<a name="ln166">  char_u      *st_word;         // suggested word, allocated string</a>
<a name="ln167">  int st_wordlen;               // STRLEN(st_word)</a>
<a name="ln168">  int st_orglen;                // length of replaced text</a>
<a name="ln169">  int st_score;                 // lower is better</a>
<a name="ln170">  int st_altscore;              // used when st_score compares equal</a>
<a name="ln171">  bool st_salscore;             // st_score is for soundalike</a>
<a name="ln172">  bool st_had_bonus;            // bonus already included in score</a>
<a name="ln173">  slang_T     *st_slang;        // language used for sound folding</a>
<a name="ln174">} suggest_T;</a>
<a name="ln175"> </a>
<a name="ln176">#define SUG(ga, i) (((suggest_T *)(ga).ga_data)[i])</a>
<a name="ln177"> </a>
<a name="ln178">// True if a word appears in the list of banned words.</a>
<a name="ln179">#define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&amp;su-&gt;su_banned, word)))</a>
<a name="ln180"> </a>
<a name="ln181">// Number of suggestions kept when cleaning up.  We need to keep more than</a>
<a name="ln182">// what is displayed, because when rescore_suggestions() is called the score</a>
<a name="ln183">// may change and wrong suggestions may be removed later.</a>
<a name="ln184">#define SUG_CLEAN_COUNT(su)    ((su)-&gt;su_maxcount &lt; \</a>
<a name="ln185">                                130 ? 150 : (su)-&gt;su_maxcount + 20)</a>
<a name="ln186"> </a>
<a name="ln187">// Threshold for sorting and cleaning up suggestions.  Don't want to keep lots</a>
<a name="ln188">// of suggestions that are not going to be displayed.</a>
<a name="ln189">#define SUG_MAX_COUNT(su)       (SUG_CLEAN_COUNT(su) + 50)</a>
<a name="ln190"> </a>
<a name="ln191">// score for various changes</a>
<a name="ln192">#define SCORE_SPLIT     149     // split bad word</a>
<a name="ln193">#define SCORE_SPLIT_NO  249     // split bad word with NOSPLITSUGS</a>
<a name="ln194">#define SCORE_ICASE     52      // slightly different case</a>
<a name="ln195">#define SCORE_REGION    200     // word is for different region</a>
<a name="ln196">#define SCORE_RARE      180     // rare word</a>
<a name="ln197">#define SCORE_SWAP      75      // swap two characters</a>
<a name="ln198">#define SCORE_SWAP3     110     // swap two characters in three</a>
<a name="ln199">#define SCORE_REP       65      // REP replacement</a>
<a name="ln200">#define SCORE_SUBST     93      // substitute a character</a>
<a name="ln201">#define SCORE_SIMILAR   33      // substitute a similar character</a>
<a name="ln202">#define SCORE_SUBCOMP   33      // substitute a composing character</a>
<a name="ln203">#define SCORE_DEL       94      // delete a character</a>
<a name="ln204">#define SCORE_DELDUP    66      // delete a duplicated character</a>
<a name="ln205">#define SCORE_DELCOMP   28      // delete a composing character</a>
<a name="ln206">#define SCORE_INS       96      // insert a character</a>
<a name="ln207">#define SCORE_INSDUP    67      // insert a duplicate character</a>
<a name="ln208">#define SCORE_INSCOMP   30      // insert a composing character</a>
<a name="ln209">#define SCORE_NONWORD   103     // change non-word to word char</a>
<a name="ln210"> </a>
<a name="ln211">#define SCORE_FILE      30      // suggestion from a file</a>
<a name="ln212">#define SCORE_MAXINIT   350     // Initial maximum score: higher == slower.</a>
<a name="ln213">                                // 350 allows for about three changes.</a>
<a name="ln214"> </a>
<a name="ln215">#define SCORE_COMMON1   30      // subtracted for words seen before</a>
<a name="ln216">#define SCORE_COMMON2   40      // subtracted for words often seen</a>
<a name="ln217">#define SCORE_COMMON3   50      // subtracted for words very often seen</a>
<a name="ln218">#define SCORE_THRES2    10      // word count threshold for COMMON2</a>
<a name="ln219">#define SCORE_THRES3    100     // word count threshold for COMMON3</a>
<a name="ln220"> </a>
<a name="ln221">// When trying changed soundfold words it becomes slow when trying more than</a>
<a name="ln222">// two changes.  With less then two changes it's slightly faster but we miss a</a>
<a name="ln223">// few good suggestions.  In rare cases we need to try three of four changes.</a>
<a name="ln224">#define SCORE_SFMAX1    200     // maximum score for first try</a>
<a name="ln225">#define SCORE_SFMAX2    300     // maximum score for second try</a>
<a name="ln226">#define SCORE_SFMAX3    400     // maximum score for third try</a>
<a name="ln227"> </a>
<a name="ln228">#define SCORE_BIG       SCORE_INS * 3   // big difference</a>
<a name="ln229">#define SCORE_MAXMAX    999999          // accept any score</a>
<a name="ln230">#define SCORE_LIMITMAX  350             // for spell_edit_score_limit()</a>
<a name="ln231"> </a>
<a name="ln232">// for spell_edit_score_limit() we need to know the minimum value of</a>
<a name="ln233">// SCORE_ICASE, SCORE_SWAP, SCORE_DEL, SCORE_SIMILAR and SCORE_INS</a>
<a name="ln234">#define SCORE_EDIT_MIN  SCORE_SIMILAR</a>
<a name="ln235"> </a>
<a name="ln236">// Structure to store info for word matching.</a>
<a name="ln237">typedef struct matchinf_S {</a>
<a name="ln238">  langp_T     *mi_lp;                   // info for language and region</a>
<a name="ln239"> </a>
<a name="ln240">  // pointers to original text to be checked</a>
<a name="ln241">  char_u      *mi_word;                 // start of word being checked</a>
<a name="ln242">  char_u      *mi_end;                  // end of matching word so far</a>
<a name="ln243">  char_u      *mi_fend;                 // next char to be added to mi_fword</a>
<a name="ln244">  char_u      *mi_cend;                 // char after what was used for</a>
<a name="ln245">                                        // mi_capflags</a>
<a name="ln246"> </a>
<a name="ln247">  // case-folded text</a>
<a name="ln248">  char_u mi_fword[MAXWLEN + 1];         // mi_word case-folded</a>
<a name="ln249">  int mi_fwordlen;                      // nr of valid bytes in mi_fword</a>
<a name="ln250"> </a>
<a name="ln251">  // for when checking word after a prefix</a>
<a name="ln252">  int mi_prefarridx;                    // index in sl_pidxs with list of</a>
<a name="ln253">                                        // affixID/condition</a>
<a name="ln254">  int mi_prefcnt;                       // number of entries at mi_prefarridx</a>
<a name="ln255">  int mi_prefixlen;                     // byte length of prefix</a>
<a name="ln256">  int mi_cprefixlen;                    // byte length of prefix in original</a>
<a name="ln257">                                        // case</a>
<a name="ln258"> </a>
<a name="ln259">  // for when checking a compound word</a>
<a name="ln260">  int mi_compoff;                       // start of following word offset</a>
<a name="ln261">  char_u mi_compflags[MAXWLEN];         // flags for compound words used</a>
<a name="ln262">  int mi_complen;                       // nr of compound words used</a>
<a name="ln263">  int mi_compextra;                     // nr of COMPOUNDROOT words</a>
<a name="ln264"> </a>
<a name="ln265">  // others</a>
<a name="ln266">  int mi_result;                        // result so far: SP_BAD, SP_OK, etc.</a>
<a name="ln267">  int mi_capflags;                      // WF_ONECAP WF_ALLCAP WF_KEEPCAP</a>
<a name="ln268">  win_T       *mi_win;                  // buffer being checked</a>
<a name="ln269"> </a>
<a name="ln270">  // for NOBREAK</a>
<a name="ln271">  int mi_result2;                       // &quot;mi_resul&quot; without following word</a>
<a name="ln272">  char_u      *mi_end2;                 // &quot;mi_end&quot; without following word</a>
<a name="ln273">} matchinf_T;</a>
<a name="ln274"> </a>
<a name="ln275">// Structure used for the cookie argument of do_in_runtimepath().</a>
<a name="ln276">typedef struct spelload_S {</a>
<a name="ln277">  char_u sl_lang[MAXWLEN + 1];          // language name</a>
<a name="ln278">  slang_T *sl_slang;                    // resulting slang_T struct</a>
<a name="ln279">  int sl_nobreak;                       // NOBREAK language found</a>
<a name="ln280">} spelload_T;</a>
<a name="ln281"> </a>
<a name="ln282">#define SY_MAXLEN   30</a>
<a name="ln283">typedef struct syl_item_S {</a>
<a name="ln284">  char_u sy_chars[SY_MAXLEN];               // the sequence of chars</a>
<a name="ln285">  int sy_len;</a>
<a name="ln286">} syl_item_T;</a>
<a name="ln287"> </a>
<a name="ln288">spelltab_T spelltab;</a>
<a name="ln289">int did_set_spelltab;</a>
<a name="ln290"> </a>
<a name="ln291">// structure used to store soundfolded words that add_sound_suggest() has</a>
<a name="ln292">// handled already.</a>
<a name="ln293">typedef struct {</a>
<a name="ln294">  short sft_score;              // lowest score used</a>
<a name="ln295">  char_u sft_word[1];           // soundfolded word, actually longer</a>
<a name="ln296">} sftword_T;</a>
<a name="ln297"> </a>
<a name="ln298">typedef struct {</a>
<a name="ln299">  int badi;</a>
<a name="ln300">  int goodi;</a>
<a name="ln301">  int score;</a>
<a name="ln302">} limitscore_T;</a>
<a name="ln303"> </a>
<a name="ln304"> </a>
<a name="ln305">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln306"># include &quot;spell.c.generated.h&quot;</a>
<a name="ln307">#endif</a>
<a name="ln308"> </a>
<a name="ln309">// values for ts_isdiff</a>
<a name="ln310">#define DIFF_NONE       0       // no different byte (yet)</a>
<a name="ln311">#define DIFF_YES        1       // different byte found</a>
<a name="ln312">#define DIFF_INSERT     2       // inserting character</a>
<a name="ln313"> </a>
<a name="ln314">// values for ts_flags</a>
<a name="ln315">#define TSF_PREFIXOK    1       // already checked that prefix is OK</a>
<a name="ln316">#define TSF_DIDSPLIT    2       // tried split at this point</a>
<a name="ln317">#define TSF_DIDDEL      4       // did a delete, &quot;ts_delidx&quot; has index</a>
<a name="ln318"> </a>
<a name="ln319">// special values ts_prefixdepth</a>
<a name="ln320">#define PFD_NOPREFIX    0xff    // not using prefixes</a>
<a name="ln321">#define PFD_PREFIXTREE  0xfe    // walking through the prefix tree</a>
<a name="ln322">#define PFD_NOTSPECIAL  0xfd    // highest value that's not special</a>
<a name="ln323"> </a>
<a name="ln324">// mode values for find_word</a>
<a name="ln325">#define FIND_FOLDWORD       0   // find word case-folded</a>
<a name="ln326">#define FIND_KEEPWORD       1   // find keep-case word</a>
<a name="ln327">#define FIND_PREFIX         2   // find word after prefix</a>
<a name="ln328">#define FIND_COMPOUND       3   // find case-folded compound word</a>
<a name="ln329">#define FIND_KEEPCOMPOUND   4   // find keep-case compound word</a>
<a name="ln330"> </a>
<a name="ln331">char *e_format = N_(&quot;E759: Format error in spell file&quot;);</a>
<a name="ln332"> </a>
<a name="ln333">// Remember what &quot;z?&quot; replaced.</a>
<a name="ln334">static char_u *repl_from = NULL;</a>
<a name="ln335">static char_u *repl_to = NULL;</a>
<a name="ln336"> </a>
<a name="ln337">// Main spell-checking function.</a>
<a name="ln338">// &quot;ptr&quot; points to a character that could be the start of a word.</a>
<a name="ln339">// &quot;*attrp&quot; is set to the highlight index for a badly spelled word.  For a</a>
<a name="ln340">// non-word or when it's OK it remains unchanged.</a>
<a name="ln341">// This must only be called when 'spelllang' is not empty.</a>
<a name="ln342">//</a>
<a name="ln343">// &quot;capcol&quot; is used to check for a Capitalised word after the end of a</a>
<a name="ln344">// sentence.  If it's zero then perform the check.  Return the column where to</a>
<a name="ln345">// check next, or -1 when no sentence end was found.  If it's NULL then don't</a>
<a name="ln346">// worry.</a>
<a name="ln347">//</a>
<a name="ln348">// Returns the length of the word in bytes, also when it's OK, so that the</a>
<a name="ln349">// caller can skip over the word.</a>
<a name="ln350">size_t spell_check(</a>
<a name="ln351">    win_T *wp,                // current window</a>
<a name="ln352">    char_u *ptr,</a>
<a name="ln353">    hlf_T *attrp,</a>
<a name="ln354">    int *capcol,              // column to check for Capital</a>
<a name="ln355">    bool docount              // count good words</a>
<a name="ln356">)</a>
<a name="ln357">{</a>
<a name="ln358">  matchinf_T mi;              // Most things are put in &quot;mi&quot; so that it can</a>
<a name="ln359">                              // be passed to functions quickly.</a>
<a name="ln360">  size_t nrlen = 0;              // found a number first</a>
<a name="ln361">  int c;</a>
<a name="ln362">  size_t wrongcaplen = 0;</a>
<a name="ln363">  int lpi;</a>
<a name="ln364">  bool count_word = docount;</a>
<a name="ln365">  bool use_camel_case = *wp-&gt;w_s-&gt;b_p_spo != NUL;</a>
<a name="ln366">  bool camel_case = false;</a>
<a name="ln367"> </a>
<a name="ln368">  // A word never starts at a space or a control character. Return quickly</a>
<a name="ln369">  // then, skipping over the character.</a>
<a name="ln370">  if (*ptr &lt;= ' ') {</a>
<a name="ln371">    return 1;</a>
<a name="ln372">  }</a>
<a name="ln373"> </a>
<a name="ln374">  // Return here when loading language files failed.</a>
<a name="ln375">  if (GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)) {</a>
<a name="ln376">    return 1;</a>
<a name="ln377">  }</a>
<a name="ln378"> </a>
<a name="ln379">  memset(&amp;mi, 0, sizeof(matchinf_T));</a>
<a name="ln380"> </a>
<a name="ln381">  // A number is always OK.  Also skip hexadecimal numbers 0xFF99 and</a>
<a name="ln382">  // 0X99FF.  But always do check spelling to find &quot;3GPP&quot; and &quot;11</a>
<a name="ln383">  // julifeest&quot;.</a>
<a name="ln384">  if (*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9') {</a>
<a name="ln385">    if (*ptr == '0' &amp;&amp; (ptr[1] == 'b' || ptr[1] == 'B')) {</a>
<a name="ln386">      mi.mi_end = (char_u*) skipbin((char*) ptr + 2);</a>
<a name="ln387">    } else if (*ptr == '0' &amp;&amp; (ptr[1] == 'x' || ptr[1] == 'X')) {</a>
<a name="ln388">      mi.mi_end = skiphex(ptr + 2);</a>
<a name="ln389">    } else {</a>
<a name="ln390">      mi.mi_end = skipdigits(ptr);</a>
<a name="ln391">    }</a>
<a name="ln392">    nrlen = (size_t)(mi.mi_end - ptr);</a>
<a name="ln393">  }</a>
<a name="ln394"> </a>
<a name="ln395">  // Find the normal end of the word (until the next non-word character).</a>
<a name="ln396">  mi.mi_word = ptr;</a>
<a name="ln397">  mi.mi_fend = ptr;</a>
<a name="ln398">  if (spell_iswordp(mi.mi_fend, wp)) {</a>
<a name="ln399">    bool this_upper = false;  // init for gcc</a>
<a name="ln400"> </a>
<a name="ln401">    if (use_camel_case) {</a>
<a name="ln402">      c = PTR2CHAR(mi.mi_fend);</a>
<a name="ln403">      this_upper = SPELL_ISUPPER(c);</a>
<a name="ln404">    }</a>
<a name="ln405"> </a>
<a name="ln406">    do {</a>
<a name="ln407">      MB_PTR_ADV(mi.mi_fend);</a>
<a name="ln408">      if (use_camel_case) {</a>
<a name="ln409">        const bool prev_upper = this_upper;</a>
<a name="ln410">        c = PTR2CHAR(mi.mi_fend);</a>
<a name="ln411">        this_upper = SPELL_ISUPPER(c);</a>
<a name="ln412">        camel_case = !prev_upper &amp;&amp; this_upper;</a>
<a name="ln413">      }</a>
<a name="ln414">    } while (*mi.mi_fend != NUL &amp;&amp; spell_iswordp(mi.mi_fend, wp)</a>
<a name="ln415">             &amp;&amp; !camel_case);</a>
<a name="ln416"> </a>
<a name="ln417">    if (capcol != NULL &amp;&amp; *capcol == 0 &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != NULL) {</a>
<a name="ln418">      // Check word starting with capital letter.</a>
<a name="ln419">      c = PTR2CHAR(ptr);</a>
<a name="ln420">      if (!SPELL_ISUPPER(c)) {</a>
<a name="ln421">        wrongcaplen = (size_t)(mi.mi_fend - ptr);</a>
<a name="ln422">      }</a>
<a name="ln423">    }</a>
<a name="ln424">  }</a>
<a name="ln425">  if (capcol != NULL) {</a>
<a name="ln426">    *capcol = -1;</a>
<a name="ln427">  }</a>
<a name="ln428"> </a>
<a name="ln429">  // We always use the characters up to the next non-word character,</a>
<a name="ln430">  // also for bad words.</a>
<a name="ln431">  mi.mi_end = mi.mi_fend;</a>
<a name="ln432"> </a>
<a name="ln433">  // Check caps type later.</a>
<a name="ln434">  mi.mi_capflags = 0;</a>
<a name="ln435">  mi.mi_cend = NULL;</a>
<a name="ln436">  mi.mi_win = wp;</a>
<a name="ln437"> </a>
<a name="ln438">  // case-fold the word with one non-word character, so that we can check</a>
<a name="ln439">  // for the word end.</a>
<a name="ln440">  if (*mi.mi_fend != NUL) {</a>
<a name="ln441">    MB_PTR_ADV(mi.mi_fend);</a>
<a name="ln442">  }</a>
<a name="ln443"> </a>
<a name="ln444">  (void)spell_casefold(wp, ptr, (int)(mi.mi_fend - ptr), mi.mi_fword,</a>
<a name="ln445">                       MAXWLEN + 1);</a>
<a name="ln446">  mi.mi_fwordlen = (int)STRLEN(mi.mi_fword);</a>
<a name="ln447"> </a>
<a name="ln448">  if (camel_case) {</a>
<a name="ln449">    // introduce a fake word end space into the folded word.</a>
<a name="ln450">    mi.mi_fword[mi.mi_fwordlen - 1] = ' ';</a>
<a name="ln451">  }</a>
<a name="ln452"> </a>
<a name="ln453">  // The word is bad unless we recognize it.</a>
<a name="ln454">  mi.mi_result = SP_BAD;</a>
<a name="ln455">  mi.mi_result2 = SP_BAD;</a>
<a name="ln456"> </a>
<a name="ln457">  // Loop over the languages specified in 'spelllang'.</a>
<a name="ln458">  // We check them all, because a word may be matched longer in another</a>
<a name="ln459">  // language.</a>
<a name="ln460">  for (lpi = 0; lpi &lt; wp-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln461">    mi.mi_lp = LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln462"> </a>
<a name="ln463">    // If reloading fails the language is still in the list but everything</a>
<a name="ln464">    // has been cleared.</a>
<a name="ln465">    if (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs == NULL) {</a>
<a name="ln466">      continue;</a>
<a name="ln467">    }</a>
<a name="ln468"> </a>
<a name="ln469">    // Check for a matching word in case-folded words.</a>
<a name="ln470">    find_word(&amp;mi, FIND_FOLDWORD);</a>
<a name="ln471"> </a>
<a name="ln472">    // Check for a matching word in keep-case words.</a>
<a name="ln473">    find_word(&amp;mi, FIND_KEEPWORD);</a>
<a name="ln474"> </a>
<a name="ln475">    // Check for matching prefixes.</a>
<a name="ln476">    find_prefix(&amp;mi, FIND_FOLDWORD);</a>
<a name="ln477"> </a>
<a name="ln478">    // For a NOBREAK language, may want to use a word without a following</a>
<a name="ln479">    // word as a backup.</a>
<a name="ln480">    if (mi.mi_lp-&gt;lp_slang-&gt;sl_nobreak &amp;&amp; mi.mi_result == SP_BAD</a>
<a name="ln481">        &amp;&amp; mi.mi_result2 != SP_BAD) {</a>
<a name="ln482">      mi.mi_result = mi.mi_result2;</a>
<a name="ln483">      mi.mi_end = mi.mi_end2;</a>
<a name="ln484">    }</a>
<a name="ln485"> </a>
<a name="ln486">    // Count the word in the first language where it's found to be OK.</a>
<a name="ln487">    if (count_word &amp;&amp; mi.mi_result == SP_OK) {</a>
<a name="ln488">      count_common_word(mi.mi_lp-&gt;lp_slang, ptr,</a>
<a name="ln489">          (int)(mi.mi_end - ptr), 1);</a>
<a name="ln490">      count_word = false;</a>
<a name="ln491">    }</a>
<a name="ln492">  }</a>
<a name="ln493"> </a>
<a name="ln494">  if (mi.mi_result != SP_OK) {</a>
<a name="ln495">    // If we found a number skip over it.  Allows for &quot;42nd&quot;.  Do flag</a>
<a name="ln496">    // rare and local words, e.g., &quot;3GPP&quot;.</a>
<a name="ln497">    if (nrlen &gt; 0) {</a>
<a name="ln498">      if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {</a>
<a name="ln499">        return nrlen;</a>
<a name="ln500">      }</a>
<a name="ln501">    } else if (!spell_iswordp_nmw(ptr, wp)) {</a>
<a name="ln502">    // When we are at a non-word character there is no error, just</a>
<a name="ln503">    // skip over the character (try looking for a word after it).</a>
<a name="ln504">      if (capcol != NULL &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != NULL) {</a>
<a name="ln505">        regmatch_T regmatch;</a>
<a name="ln506"> </a>
<a name="ln507">        // Check for end of sentence.</a>
<a name="ln508">        regmatch.regprog = wp-&gt;w_s-&gt;b_cap_prog;</a>
<a name="ln509">        regmatch.rm_ic = false;</a>
<a name="ln510">        int r = vim_regexec(&amp;regmatch, ptr, 0);</a>
<a name="ln511">        wp-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</a>
<a name="ln512">        if (r) {</a>
<a name="ln513">          *capcol = (int)(regmatch.endp[0] - ptr);</a>
<a name="ln514">        }</a>
<a name="ln515">      }</a>
<a name="ln516"> </a>
<a name="ln517">      return (size_t)(utfc_ptr2len(ptr));</a>
<a name="ln518">    } else if (mi.mi_end == ptr) {</a>
<a name="ln519">      // Always include at least one character.  Required for when there</a>
<a name="ln520">      // is a mixup in &quot;midword&quot;.</a>
<a name="ln521">      MB_PTR_ADV(mi.mi_end);</a>
<a name="ln522">    } else if (mi.mi_result == SP_BAD</a>
<a name="ln523">               &amp;&amp; LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0)-&gt;lp_slang-&gt;sl_nobreak) {</a>
<a name="ln524">      char_u      *p, *fp;</a>
<a name="ln525">      int save_result = mi.mi_result;</a>
<a name="ln526"> </a>
<a name="ln527">      // First language in 'spelllang' is NOBREAK.  Find first position</a>
<a name="ln528">      // at which any word would be valid.</a>
<a name="ln529">      mi.mi_lp = LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0);</a>
<a name="ln530">      if (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs != NULL) {</a>
<a name="ln531">        p = mi.mi_word;</a>
<a name="ln532">        fp = mi.mi_fword;</a>
<a name="ln533">        for (;;) {</a>
<a name="ln534">          MB_PTR_ADV(p);</a>
<a name="ln535">          MB_PTR_ADV(fp);</a>
<a name="ln536">          if (p &gt;= mi.mi_end) {</a>
<a name="ln537">            break;</a>
<a name="ln538">          }</a>
<a name="ln539">          mi.mi_compoff = (int)(fp - mi.mi_fword);</a>
<a name="ln540">          find_word(&amp;mi, FIND_COMPOUND);</a>
<a name="ln541">          if (mi.mi_result != SP_BAD) {</a>
<a name="ln542">            mi.mi_end = p;</a>
<a name="ln543">            break;</a>
<a name="ln544">          }</a>
<a name="ln545">        }</a>
<a name="ln546">        mi.mi_result = save_result;</a>
<a name="ln547">      }</a>
<a name="ln548">    }</a>
<a name="ln549"> </a>
<a name="ln550">    if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {</a>
<a name="ln551">      *attrp = HLF_SPB;</a>
<a name="ln552">    } else if (mi.mi_result == SP_RARE) {</a>
<a name="ln553">      *attrp = HLF_SPR;</a>
<a name="ln554">    } else {</a>
<a name="ln555">      *attrp = HLF_SPL;</a>
<a name="ln556">    }</a>
<a name="ln557">  }</a>
<a name="ln558"> </a>
<a name="ln559">  if (wrongcaplen &gt; 0 &amp;&amp; (mi.mi_result == SP_OK || mi.mi_result == SP_RARE)) {</a>
<a name="ln560">    // Report SpellCap only when the word isn't badly spelled.</a>
<a name="ln561">    *attrp = HLF_SPC;</a>
<a name="ln562">    return wrongcaplen;</a>
<a name="ln563">  }</a>
<a name="ln564"> </a>
<a name="ln565">  return (size_t)(mi.mi_end - ptr);</a>
<a name="ln566">}</a>
<a name="ln567"> </a>
<a name="ln568">// Check if the word at &quot;mip-&gt;mi_word&quot; is in the tree.</a>
<a name="ln569">// When &quot;mode&quot; is FIND_FOLDWORD check in fold-case word tree.</a>
<a name="ln570">// When &quot;mode&quot; is FIND_KEEPWORD check in keep-case word tree.</a>
<a name="ln571">// When &quot;mode&quot; is FIND_PREFIX check for word after prefix in fold-case word</a>
<a name="ln572">// tree.</a>
<a name="ln573">//</a>
<a name="ln574">// For a match mip-&gt;mi_result is updated.</a>
<a name="ln575">static void find_word(matchinf_T *mip, int mode)</a>
<a name="ln576">{</a>
<a name="ln577">  int wlen = 0;</a>
<a name="ln578">  int flen;</a>
<a name="ln579">  char_u      *ptr;</a>
<a name="ln580">  slang_T     *slang = mip-&gt;mi_lp-&gt;lp_slang;</a>
<a name="ln581">  char_u      *byts;</a>
<a name="ln582">  idx_T       *idxs;</a>
<a name="ln583"> </a>
<a name="ln584">  if (mode == FIND_KEEPWORD || mode == FIND_KEEPCOMPOUND) {</a>
<a name="ln585">    // Check for word with matching case in keep-case tree.</a>
<a name="ln586">    ptr = mip-&gt;mi_word;</a>
<a name="ln587">    flen = 9999;                    // no case folding, always enough bytes</a>
<a name="ln588">    byts = slang-&gt;sl_kbyts;</a>
<a name="ln589">    idxs = slang-&gt;sl_kidxs;</a>
<a name="ln590"> </a>
<a name="ln591">    if (mode == FIND_KEEPCOMPOUND)</a>
<a name="ln592">      // Skip over the previously found word(s).</a>
<a name="ln593">      wlen += mip-&gt;mi_compoff;</a>
<a name="ln594">  } else {</a>
<a name="ln595">    // Check for case-folded in case-folded tree.</a>
<a name="ln596">    ptr = mip-&gt;mi_fword;</a>
<a name="ln597">    flen = mip-&gt;mi_fwordlen;        // available case-folded bytes</a>
<a name="ln598">    byts = slang-&gt;sl_fbyts;</a>
<a name="ln599">    idxs = slang-&gt;sl_fidxs;</a>
<a name="ln600"> </a>
<a name="ln601">    if (mode == FIND_PREFIX) {</a>
<a name="ln602">      // Skip over the prefix.</a>
<a name="ln603">      wlen = mip-&gt;mi_prefixlen;</a>
<a name="ln604">      flen -= mip-&gt;mi_prefixlen;</a>
<a name="ln605">    } else if (mode == FIND_COMPOUND) {</a>
<a name="ln606">      // Skip over the previously found word(s).</a>
<a name="ln607">      wlen = mip-&gt;mi_compoff;</a>
<a name="ln608">      flen -= mip-&gt;mi_compoff;</a>
<a name="ln609">    }</a>
<a name="ln610"> </a>
<a name="ln611">  }</a>
<a name="ln612"> </a>
<a name="ln613">  if (byts == NULL)</a>
<a name="ln614">    return;                     // array is empty</a>
<a name="ln615"> </a>
<a name="ln616">  idx_T arridx = 0;</a>
<a name="ln617">  int endlen[MAXWLEN];              // length at possible word endings</a>
<a name="ln618">  idx_T endidx[MAXWLEN];            // possible word endings</a>
<a name="ln619">  int endidxcnt = 0;</a>
<a name="ln620">  int len;</a>
<a name="ln621">  int c;</a>
<a name="ln622"> </a>
<a name="ln623">  // Repeat advancing in the tree until:</a>
<a name="ln624">  // - there is a byte that doesn't match,</a>
<a name="ln625">  // - we reach the end of the tree,</a>
<a name="ln626">  // - or we reach the end of the line.</a>
<a name="ln627">  for (;; ) {</a>
<a name="ln628">    if (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != NUL)</a>
<a name="ln629">      flen = fold_more(mip);</a>
<a name="ln630"> </a>
<a name="ln631">    len = byts[arridx++];</a>
<a name="ln632"> </a>
<a name="ln633">    // If the first possible byte is a zero the word could end here.</a>
<a name="ln634">    // Remember this index, we first check for the longest word.</a>
<a name="ln635">    if (byts[arridx] == 0) {</a>
<a name="ln636">      if (endidxcnt == MAXWLEN) {</a>
<a name="ln637">        // Must be a corrupted spell file.</a>
<a name="ln638">        EMSG(_(e_format));</a>
<a name="ln639">        return;</a>
<a name="ln640">      }</a>
<a name="ln641">      endlen[endidxcnt] = wlen;</a>
<a name="ln642">      endidx[endidxcnt++] = arridx++;</a>
<a name="ln643">      --len;</a>
<a name="ln644"> </a>
<a name="ln645">      // Skip over the zeros, there can be several flag/region</a>
<a name="ln646">      // combinations.</a>
<a name="ln647">      while (len &gt; 0 &amp;&amp; byts[arridx] == 0) {</a>
<a name="ln648">        ++arridx;</a>
<a name="ln649">        --len;</a>
<a name="ln650">      }</a>
<a name="ln651">      if (len == 0)</a>
<a name="ln652">        break;              // no children, word must end here</a>
<a name="ln653">    }</a>
<a name="ln654"> </a>
<a name="ln655">    // Stop looking at end of the line.</a>
<a name="ln656">    if (ptr[wlen] == NUL)</a>
<a name="ln657">      break;</a>
<a name="ln658"> </a>
<a name="ln659">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln660">    c = ptr[wlen];</a>
<a name="ln661">    if (c == TAB)           // &lt;Tab&gt; is handled like &lt;Space&gt;</a>
<a name="ln662">      c = ' ';</a>
<a name="ln663">    idx_T lo = arridx;</a>
<a name="ln664">    idx_T hi = arridx + len - 1;</a>
<a name="ln665">    while (lo &lt; hi) {</a>
<a name="ln666">      idx_T m = (lo + hi) / 2;</a>
<a name="ln667">      if (byts[m] &gt; c)</a>
<a name="ln668">        hi = m - 1;</a>
<a name="ln669">      else if (byts[m] &lt; c)</a>
<a name="ln670">        lo = m + 1;</a>
<a name="ln671">      else {</a>
<a name="ln672">        lo = hi = m;</a>
<a name="ln673">        break;</a>
<a name="ln674">      }</a>
<a name="ln675">    }</a>
<a name="ln676"> </a>
<a name="ln677">    // Stop if there is no matching byte.</a>
<a name="ln678">    if (hi &lt; lo || byts[lo] != c)</a>
<a name="ln679">      break;</a>
<a name="ln680"> </a>
<a name="ln681">    // Continue at the child (if there is one).</a>
<a name="ln682">    arridx = idxs[lo];</a>
<a name="ln683">    ++wlen;</a>
<a name="ln684">    --flen;</a>
<a name="ln685"> </a>
<a name="ln686">    // One space in the good word may stand for several spaces in the</a>
<a name="ln687">    // checked word.</a>
<a name="ln688">    if (c == ' ') {</a>
<a name="ln689">      for (;; ) {</a>
<a name="ln690">        if (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != NUL)</a>
<a name="ln691">          flen = fold_more(mip);</a>
<a name="ln692">        if (ptr[wlen] != ' ' &amp;&amp; ptr[wlen] != TAB)</a>
<a name="ln693">          break;</a>
<a name="ln694">        ++wlen;</a>
<a name="ln695">        --flen;</a>
<a name="ln696">      }</a>
<a name="ln697">    }</a>
<a name="ln698">  }</a>
<a name="ln699"> </a>
<a name="ln700">  char_u *p;</a>
<a name="ln701">  bool word_ends;</a>
<a name="ln702"> </a>
<a name="ln703">  // Verify that one of the possible endings is valid.  Try the longest</a>
<a name="ln704">  // first.</a>
<a name="ln705">  while (endidxcnt &gt; 0) {</a>
<a name="ln706">    --endidxcnt;</a>
<a name="ln707">    arridx = endidx[endidxcnt];</a>
<a name="ln708">    wlen = endlen[endidxcnt];</a>
<a name="ln709"> </a>
<a name="ln710">    if (utf_head_off(ptr, ptr + wlen) &gt; 0) {</a>
<a name="ln711">      continue;             // not at first byte of character</a>
<a name="ln712">    }</a>
<a name="ln713">    if (spell_iswordp(ptr + wlen, mip-&gt;mi_win)) {</a>
<a name="ln714">      if (slang-&gt;sl_compprog == NULL &amp;&amp; !slang-&gt;sl_nobreak)</a>
<a name="ln715">        continue;                   // next char is a word character</a>
<a name="ln716">      word_ends = false;</a>
<a name="ln717">    } else</a>
<a name="ln718">      word_ends = true;</a>
<a name="ln719">    // The prefix flag is before compound flags.  Once a valid prefix flag</a>
<a name="ln720">    // has been found we try compound flags.</a>
<a name="ln721">    bool prefix_found = false;</a>
<a name="ln722"> </a>
<a name="ln723">    if (mode != FIND_KEEPWORD) {</a>
<a name="ln724">      // Compute byte length in original word, length may change</a>
<a name="ln725">      // when folding case.  This can be slow, take a shortcut when the</a>
<a name="ln726">      // case-folded word is equal to the keep-case word.</a>
<a name="ln727">      p = mip-&gt;mi_word;</a>
<a name="ln728">      if (STRNCMP(ptr, p, wlen) != 0) {</a>
<a name="ln729">        for (char_u *s = ptr; s &lt; ptr + wlen; MB_PTR_ADV(s)) {</a>
<a name="ln730">          MB_PTR_ADV(p);</a>
<a name="ln731">        }</a>
<a name="ln732">        wlen = (int)(p - mip-&gt;mi_word);</a>
<a name="ln733">      }</a>
<a name="ln734">    }</a>
<a name="ln735"> </a>
<a name="ln736">    // Check flags and region.  For FIND_PREFIX check the condition and</a>
<a name="ln737">    // prefix ID.</a>
<a name="ln738">    // Repeat this if there are more flags/region alternatives until there</a>
<a name="ln739">    // is a match.</a>
<a name="ln740">    for (len = byts[arridx - 1]; len &gt; 0 &amp;&amp; byts[arridx] == 0;</a>
<a name="ln741">         --len, ++arridx) {</a>
<a name="ln742">      uint32_t flags = idxs[arridx];</a>
<a name="ln743"> </a>
<a name="ln744">      // For the fold-case tree check that the case of the checked word</a>
<a name="ln745">      // matches with what the word in the tree requires.</a>
<a name="ln746">      // For keep-case tree the case is always right.  For prefixes we</a>
<a name="ln747">      // don't bother to check.</a>
<a name="ln748">      if (mode == FIND_FOLDWORD) {</a>
<a name="ln749">        if (mip-&gt;mi_cend != mip-&gt;mi_word + wlen) {</a>
<a name="ln750">          // mi_capflags was set for a different word length, need</a>
<a name="ln751">          // to do it again.</a>
<a name="ln752">          mip-&gt;mi_cend = mip-&gt;mi_word + wlen;</a>
<a name="ln753">          mip-&gt;mi_capflags = captype(mip-&gt;mi_word, mip-&gt;mi_cend);</a>
<a name="ln754">        }</a>
<a name="ln755"> </a>
<a name="ln756">        if (mip-&gt;mi_capflags == WF_KEEPCAP</a>
<a name="ln757">            || !spell_valid_case(mip-&gt;mi_capflags, flags))</a>
<a name="ln758">          continue;</a>
<a name="ln759">      }</a>
<a name="ln760">      // When mode is FIND_PREFIX the word must support the prefix:</a>
<a name="ln761">      // check the prefix ID and the condition.  Do that for the list at</a>
<a name="ln762">      // mip-&gt;mi_prefarridx that find_prefix() filled.</a>
<a name="ln763">      else if (mode == FIND_PREFIX &amp;&amp; !prefix_found) {</a>
<a name="ln764">        c = valid_word_prefix(mip-&gt;mi_prefcnt, mip-&gt;mi_prefarridx,</a>
<a name="ln765">            flags,</a>
<a name="ln766">            mip-&gt;mi_word + mip-&gt;mi_cprefixlen, slang,</a>
<a name="ln767">            false);</a>
<a name="ln768">        if (c == 0)</a>
<a name="ln769">          continue;</a>
<a name="ln770"> </a>
<a name="ln771">        // Use the WF_RARE flag for a rare prefix.</a>
<a name="ln772">        if (c &amp; WF_RAREPFX)</a>
<a name="ln773">          flags |= WF_RARE;</a>
<a name="ln774">        prefix_found = true;</a>
<a name="ln775">      }</a>
<a name="ln776"> </a>
<a name="ln777">      if (slang-&gt;sl_nobreak) {</a>
<a name="ln778">        if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND)</a>
<a name="ln779">            &amp;&amp; (flags &amp; WF_BANNED) == 0) {</a>
<a name="ln780">          // NOBREAK: found a valid following word.  That's all we</a>
<a name="ln781">          // need to know, so return.</a>
<a name="ln782">          mip-&gt;mi_result = SP_OK;</a>
<a name="ln783">          break;</a>
<a name="ln784">        }</a>
<a name="ln785">      } else if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND</a>
<a name="ln786">                  || !word_ends)) {</a>
<a name="ln787">        // If there is no compound flag or the word is shorter than</a>
<a name="ln788">        // COMPOUNDMIN reject it quickly.</a>
<a name="ln789">        // Makes you wonder why someone puts a compound flag on a word</a>
<a name="ln790">        // that's too short...  Myspell compatibility requires this</a>
<a name="ln791">        // anyway.</a>
<a name="ln792">        if (((unsigned)flags &gt;&gt; 24) == 0</a>
<a name="ln793">            || wlen - mip-&gt;mi_compoff &lt; slang-&gt;sl_compminlen)</a>
<a name="ln794">          continue;</a>
<a name="ln795">        // For multi-byte chars check character length against</a>
<a name="ln796">        // COMPOUNDMIN.</a>
<a name="ln797">        if (slang-&gt;sl_compminlen &gt; 0</a>
<a name="ln798">            &amp;&amp; mb_charlen_len(mip-&gt;mi_word + mip-&gt;mi_compoff,</a>
<a name="ln799">                              wlen - mip-&gt;mi_compoff) &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln800">          continue;</a>
<a name="ln801">        }</a>
<a name="ln802"> </a>
<a name="ln803">        // Limit the number of compound words to COMPOUNDWORDMAX if no</a>
<a name="ln804">        // maximum for syllables is specified.</a>
<a name="ln805">        if (!word_ends &amp;&amp; mip-&gt;mi_complen + mip-&gt;mi_compextra + 2</a>
<a name="ln806">            &gt; slang-&gt;sl_compmax</a>
<a name="ln807">            &amp;&amp; slang-&gt;sl_compsylmax == MAXWLEN)</a>
<a name="ln808">          continue;</a>
<a name="ln809"> </a>
<a name="ln810">        // Don't allow compounding on a side where an affix was added,</a>
<a name="ln811">        // unless COMPOUNDPERMITFLAG was used.</a>
<a name="ln812">        if (mip-&gt;mi_complen &gt; 0 &amp;&amp; (flags &amp; WF_NOCOMPBEF))</a>
<a name="ln813">          continue;</a>
<a name="ln814">        if (!word_ends &amp;&amp; (flags &amp; WF_NOCOMPAFT))</a>
<a name="ln815">          continue;</a>
<a name="ln816"> </a>
<a name="ln817">        // Quickly check if compounding is possible with this flag.</a>
<a name="ln818">        if (!byte_in_str(mip-&gt;mi_complen == 0</a>
<a name="ln819">                ? slang-&gt;sl_compstartflags</a>
<a name="ln820">                : slang-&gt;sl_compallflags,</a>
<a name="ln821">                ((unsigned)flags &gt;&gt; 24)))</a>
<a name="ln822">          continue;</a>
<a name="ln823"> </a>
<a name="ln824">        // If there is a match with a CHECKCOMPOUNDPATTERN rule</a>
<a name="ln825">        // discard the compound word.</a>
<a name="ln826">        if (match_checkcompoundpattern(ptr, wlen, &amp;slang-&gt;sl_comppat))</a>
<a name="ln827">          continue;</a>
<a name="ln828"> </a>
<a name="ln829">        if (mode == FIND_COMPOUND) {</a>
<a name="ln830">          int capflags;</a>
<a name="ln831"> </a>
<a name="ln832">          // Need to check the caps type of the appended compound</a>
<a name="ln833">          // word.</a>
<a name="ln834">          if (STRNCMP(ptr, mip-&gt;mi_word, mip-&gt;mi_compoff) != 0) {</a>
<a name="ln835">            // case folding may have changed the length</a>
<a name="ln836">            p = mip-&gt;mi_word;</a>
<a name="ln837">            for (char_u *s = ptr; s &lt; ptr + mip-&gt;mi_compoff; MB_PTR_ADV(s)) {</a>
<a name="ln838">              MB_PTR_ADV(p);</a>
<a name="ln839">            }</a>
<a name="ln840">          } else {</a>
<a name="ln841">            p = mip-&gt;mi_word + mip-&gt;mi_compoff;</a>
<a name="ln842">          }</a>
<a name="ln843">          capflags = captype(p, mip-&gt;mi_word + wlen);</a>
<a name="ln844">          if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP</a>
<a name="ln845">                                         &amp;&amp; (flags &amp; WF_FIXCAP) != 0))</a>
<a name="ln846">            continue;</a>
<a name="ln847"> </a>
<a name="ln848">          if (capflags != WF_ALLCAP) {</a>
<a name="ln849">            // When the character before the word is a word</a>
<a name="ln850">            // character we do not accept a Onecap word.  We do</a>
<a name="ln851">            // accept a no-caps word, even when the dictionary</a>
<a name="ln852">            // word specifies ONECAP.</a>
<a name="ln853">            MB_PTR_BACK(mip-&gt;mi_word, p);</a>
<a name="ln854">            if (spell_iswordp_nmw(p, mip-&gt;mi_win)</a>
<a name="ln855">                ? capflags == WF_ONECAP</a>
<a name="ln856">                : (flags &amp; WF_ONECAP) != 0</a>
<a name="ln857">                &amp;&amp; capflags != WF_ONECAP) {</a>
<a name="ln858">              continue;</a>
<a name="ln859">            }</a>
<a name="ln860">          }</a>
<a name="ln861">        }</a>
<a name="ln862"> </a>
<a name="ln863">        // If the word ends the sequence of compound flags of the</a>
<a name="ln864">        // words must match with one of the COMPOUNDRULE items and</a>
<a name="ln865">        // the number of syllables must not be too large.</a>
<a name="ln866">        mip-&gt;mi_compflags[mip-&gt;mi_complen] = ((unsigned)flags &gt;&gt; 24);</a>
<a name="ln867">        mip-&gt;mi_compflags[mip-&gt;mi_complen + 1] = NUL;</a>
<a name="ln868">        if (word_ends) {</a>
<a name="ln869">          char_u fword[MAXWLEN] = { 0 };</a>
<a name="ln870"> </a>
<a name="ln871">          if (slang-&gt;sl_compsylmax &lt; MAXWLEN) {</a>
<a name="ln872">            // &quot;fword&quot; is only needed for checking syllables.</a>
<a name="ln873">            if (ptr == mip-&gt;mi_word) {</a>
<a name="ln874">              (void)spell_casefold(mip-&gt;mi_win, ptr, wlen, fword, MAXWLEN);</a>
<a name="ln875">            } else {</a>
<a name="ln876">              STRLCPY(fword, ptr, endlen[endidxcnt] + 1);</a>
<a name="ln877">            }</a>
<a name="ln878">          }</a>
<a name="ln879">          if (!can_compound(slang, fword, mip-&gt;mi_compflags))</a>
<a name="ln880">            continue;</a>
<a name="ln881">        } else if (slang-&gt;sl_comprules != NULL</a>
<a name="ln882">                   &amp;&amp; !match_compoundrule(slang, mip-&gt;mi_compflags))</a>
<a name="ln883">          // The compound flags collected so far do not match any</a>
<a name="ln884">          // COMPOUNDRULE, discard the compounded word.</a>
<a name="ln885">          continue;</a>
<a name="ln886">      }</a>
<a name="ln887">      // Check NEEDCOMPOUND: can't use word without compounding.</a>
<a name="ln888">      else if (flags &amp; WF_NEEDCOMP)</a>
<a name="ln889">        continue;</a>
<a name="ln890"> </a>
<a name="ln891">      int nobreak_result = SP_OK;</a>
<a name="ln892"> </a>
<a name="ln893">      if (!word_ends) {</a>
<a name="ln894">        int save_result = mip-&gt;mi_result;</a>
<a name="ln895">        char_u  *save_end = mip-&gt;mi_end;</a>
<a name="ln896">        langp_T *save_lp = mip-&gt;mi_lp;</a>
<a name="ln897"> </a>
<a name="ln898">        // Check that a valid word follows.  If there is one and we</a>
<a name="ln899">        // are compounding, it will set &quot;mi_result&quot;, thus we are</a>
<a name="ln900">        // always finished here.  For NOBREAK we only check that a</a>
<a name="ln901">        // valid word follows.</a>
<a name="ln902">        // Recursive!</a>
<a name="ln903">        if (slang-&gt;sl_nobreak)</a>
<a name="ln904">          mip-&gt;mi_result = SP_BAD;</a>
<a name="ln905"> </a>
<a name="ln906">        // Find following word in case-folded tree.</a>
<a name="ln907">        mip-&gt;mi_compoff = endlen[endidxcnt];</a>
<a name="ln908">        if (mode == FIND_KEEPWORD) {</a>
<a name="ln909">          // Compute byte length in case-folded word from &quot;wlen&quot;:</a>
<a name="ln910">          // byte length in keep-case word.  Length may change when</a>
<a name="ln911">          // folding case.  This can be slow, take a shortcut when</a>
<a name="ln912">          // the case-folded word is equal to the keep-case word.</a>
<a name="ln913">          p = mip-&gt;mi_fword;</a>
<a name="ln914">          if (STRNCMP(ptr, p, wlen) != 0) {</a>
<a name="ln915">            for (char_u *s = ptr; s &lt; ptr + wlen; MB_PTR_ADV(s)) {</a>
<a name="ln916">              MB_PTR_ADV(p);</a>
<a name="ln917">            }</a>
<a name="ln918">            mip-&gt;mi_compoff = (int)(p - mip-&gt;mi_fword);</a>
<a name="ln919">          }</a>
<a name="ln920">        }</a>
<a name="ln921">#if 0</a>
<a name="ln922">        c = mip-&gt;mi_compoff;</a>
<a name="ln923">#endif</a>
<a name="ln924">        ++mip-&gt;mi_complen;</a>
<a name="ln925">        if (flags &amp; WF_COMPROOT)</a>
<a name="ln926">          ++mip-&gt;mi_compextra;</a>
<a name="ln927"> </a>
<a name="ln928">        // For NOBREAK we need to try all NOBREAK languages, at least</a>
<a name="ln929">        // to find the &quot;.add&quot; file(s).</a>
<a name="ln930">        for (int lpi = 0; lpi &lt; mip-&gt;mi_win-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln931">          if (slang-&gt;sl_nobreak) {</a>
<a name="ln932">            mip-&gt;mi_lp = LANGP_ENTRY(mip-&gt;mi_win-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln933">            if (mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_fidxs == NULL</a>
<a name="ln934">                || !mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_nobreak)</a>
<a name="ln935">              continue;</a>
<a name="ln936">          }</a>
<a name="ln937"> </a>
<a name="ln938">          find_word(mip, FIND_COMPOUND);</a>
<a name="ln939"> </a>
<a name="ln940">          // When NOBREAK any word that matches is OK.  Otherwise we</a>
<a name="ln941">          // need to find the longest match, thus try with keep-case</a>
<a name="ln942">          // and prefix too.</a>
<a name="ln943">          if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD) {</a>
<a name="ln944">            // Find following word in keep-case tree.</a>
<a name="ln945">            mip-&gt;mi_compoff = wlen;</a>
<a name="ln946">            find_word(mip, FIND_KEEPCOMPOUND);</a>
<a name="ln947"> </a>
<a name="ln948">#if 0       // Disabled, a prefix must not appear halfway through a compound</a>
<a name="ln949">            // word, unless the COMPOUNDPERMITFLAG is used, in which case it</a>
<a name="ln950">            // can't be a postponed prefix.</a>
<a name="ln951">            if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD) {</a>
<a name="ln952">              // Check for following word with prefix.</a>
<a name="ln953">              mip-&gt;mi_compoff = c;</a>
<a name="ln954">              find_prefix(mip, FIND_COMPOUND);</a>
<a name="ln955">            }</a>
<a name="ln956">#endif</a>
<a name="ln957">          }</a>
<a name="ln958"> </a>
<a name="ln959">          if (!slang-&gt;sl_nobreak)</a>
<a name="ln960">            break;</a>
<a name="ln961">        }</a>
<a name="ln962">        --mip-&gt;mi_complen;</a>
<a name="ln963">        if (flags &amp; WF_COMPROOT)</a>
<a name="ln964">          --mip-&gt;mi_compextra;</a>
<a name="ln965">        mip-&gt;mi_lp = save_lp;</a>
<a name="ln966"> </a>
<a name="ln967">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln968">          nobreak_result = mip-&gt;mi_result;</a>
<a name="ln969">          mip-&gt;mi_result = save_result;</a>
<a name="ln970">          mip-&gt;mi_end = save_end;</a>
<a name="ln971">        } else {</a>
<a name="ln972">          if (mip-&gt;mi_result == SP_OK)</a>
<a name="ln973">            break;</a>
<a name="ln974">          continue;</a>
<a name="ln975">        }</a>
<a name="ln976">      }</a>
<a name="ln977"> </a>
<a name="ln978">      int res = SP_BAD;</a>
<a name="ln979">      if (flags &amp; WF_BANNED)</a>
<a name="ln980">        res = SP_BANNED;</a>
<a name="ln981">      else if (flags &amp; WF_REGION) {</a>
<a name="ln982">        // Check region.</a>
<a name="ln983">        if ((mip-&gt;mi_lp-&gt;lp_region &amp; (flags &gt;&gt; 16)) != 0)</a>
<a name="ln984">          res = SP_OK;</a>
<a name="ln985">        else</a>
<a name="ln986">          res = SP_LOCAL;</a>
<a name="ln987">      } else if (flags &amp; WF_RARE)</a>
<a name="ln988">        res = SP_RARE;</a>
<a name="ln989">      else</a>
<a name="ln990">        res = SP_OK;</a>
<a name="ln991"> </a>
<a name="ln992">      // Always use the longest match and the best result.  For NOBREAK</a>
<a name="ln993">      // we separately keep the longest match without a following good</a>
<a name="ln994">      // word as a fall-back.</a>
<a name="ln995">      if (nobreak_result == SP_BAD) {</a>
<a name="ln996">        if (mip-&gt;mi_result2 &gt; res) {</a>
<a name="ln997">          mip-&gt;mi_result2 = res;</a>
<a name="ln998">          mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</a>
<a name="ln999">        } else if (mip-&gt;mi_result2 == res</a>
<a name="ln1000">                   &amp;&amp; mip-&gt;mi_end2 &lt; mip-&gt;mi_word + wlen)</a>
<a name="ln1001">          mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</a>
<a name="ln1002">      } else if (mip-&gt;mi_result &gt; res) {</a>
<a name="ln1003">        mip-&gt;mi_result = res;</a>
<a name="ln1004">        mip-&gt;mi_end = mip-&gt;mi_word + wlen;</a>
<a name="ln1005">      } else if (mip-&gt;mi_result == res &amp;&amp; mip-&gt;mi_end &lt; mip-&gt;mi_word + wlen)</a>
<a name="ln1006">        mip-&gt;mi_end = mip-&gt;mi_word + wlen;</a>
<a name="ln1007"> </a>
<a name="ln1008">      if (mip-&gt;mi_result == SP_OK)</a>
<a name="ln1009">        break;</a>
<a name="ln1010">    }</a>
<a name="ln1011"> </a>
<a name="ln1012">    if (mip-&gt;mi_result == SP_OK)</a>
<a name="ln1013">      break;</a>
<a name="ln1014">  }</a>
<a name="ln1015">}</a>
<a name="ln1016"> </a>
<a name="ln1017">// Returns true if there is a match between the word ptr[wlen] and</a>
<a name="ln1018">// CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another</a>
<a name="ln1019">// word.</a>
<a name="ln1020">// A match means that the first part of CHECKCOMPOUNDPATTERN matches at the</a>
<a name="ln1021">// end of ptr[wlen] and the second part matches after it.</a>
<a name="ln1022">static bool</a>
<a name="ln1023">match_checkcompoundpattern (</a>
<a name="ln1024">    char_u *ptr,</a>
<a name="ln1025">    int wlen,</a>
<a name="ln1026">    garray_T *gap      // &amp;sl_comppat</a>
<a name="ln1027">)</a>
<a name="ln1028">{</a>
<a name="ln1029">  char_u      *p;</a>
<a name="ln1030">  int len;</a>
<a name="ln1031"> </a>
<a name="ln1032">  for (int i = 0; i + 1 &lt; gap-&gt;ga_len; i += 2) {</a>
<a name="ln1033">    p = ((char_u **)gap-&gt;ga_data)[i + 1];</a>
<a name="ln1034">    if (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0) {</a>
<a name="ln1035">      // Second part matches at start of following compound word, now</a>
<a name="ln1036">      // check if first part matches at end of previous word.</a>
<a name="ln1037">      p = ((char_u **)gap-&gt;ga_data)[i];</a>
<a name="ln1038">      len = (int)STRLEN(p);</a>
<a name="ln1039">      if (len &lt;= wlen &amp;&amp; STRNCMP(ptr + wlen - len, p, len) == 0)</a>
<a name="ln1040">        return true;</a>
<a name="ln1041">    }</a>
<a name="ln1042">  }</a>
<a name="ln1043">  return false;</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046">// Returns true if &quot;flags&quot; is a valid sequence of compound flags and &quot;word&quot;</a>
<a name="ln1047">// does not have too many syllables.</a>
<a name="ln1048">static bool can_compound(slang_T *slang, const char_u *word,</a>
<a name="ln1049">                         const char_u *flags)</a>
<a name="ln1050">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1051">{</a>
<a name="ln1052">  char_u uflags[MAXWLEN * 2] = { 0 };</a>
<a name="ln1053"> </a>
<a name="ln1054">  if (slang-&gt;sl_compprog == NULL) {</a>
<a name="ln1055">    return false;</a>
<a name="ln1056">  }</a>
<a name="ln1057">  // Need to convert the single byte flags to utf8 characters.</a>
<a name="ln1058">  char_u *p = uflags;</a>
<a name="ln1059">  for (int i = 0; flags[i] != NUL; i++) {</a>
<a name="ln1060">    p += utf_char2bytes(flags[i], p);</a>
<a name="ln1061">  }</a>
<a name="ln1062">  *p = NUL;</a>
<a name="ln1063">  p = uflags;</a>
<a name="ln1064">  if (!vim_regexec_prog(&amp;slang-&gt;sl_compprog, false, p, 0)) {</a>
<a name="ln1065">    return false;</a>
<a name="ln1066">  }</a>
<a name="ln1067"> </a>
<a name="ln1068">  // Count the number of syllables.  This may be slow, do it last.  If there</a>
<a name="ln1069">  // are too many syllables AND the number of compound words is above</a>
<a name="ln1070">  // COMPOUNDWORDMAX then compounding is not allowed.</a>
<a name="ln1071">  if (slang-&gt;sl_compsylmax &lt; MAXWLEN</a>
<a name="ln1072">      &amp;&amp; count_syllables(slang, word) &gt; slang-&gt;sl_compsylmax)</a>
<a name="ln1073">    return (int)STRLEN(flags) &lt; slang-&gt;sl_compmax;</a>
<a name="ln1074">  return true;</a>
<a name="ln1075">}</a>
<a name="ln1076"> </a>
<a name="ln1077">// Returns true when the sequence of flags in &quot;compflags&quot; plus &quot;flag&quot; can</a>
<a name="ln1078">// possibly form a valid compounded word.  This also checks the COMPOUNDRULE</a>
<a name="ln1079">// lines if they don't contain wildcards.</a>
<a name="ln1080">static bool can_be_compound(trystate_T *sp, slang_T *slang, char_u *compflags, int flag)</a>
<a name="ln1081">{</a>
<a name="ln1082">  // If the flag doesn't appear in sl_compstartflags or sl_compallflags</a>
<a name="ln1083">  // then it can't possibly compound.</a>
<a name="ln1084">  if (!byte_in_str(sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln1085">          ? slang-&gt;sl_compstartflags : slang-&gt;sl_compallflags, flag))</a>
<a name="ln1086">    return false;</a>
<a name="ln1087"> </a>
<a name="ln1088">  // If there are no wildcards, we can check if the flags collected so far</a>
<a name="ln1089">  // possibly can form a match with COMPOUNDRULE patterns.  This only</a>
<a name="ln1090">  // makes sense when we have two or more words.</a>
<a name="ln1091">  if (slang-&gt;sl_comprules != NULL &amp;&amp; sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit) {</a>
<a name="ln1092">    compflags[sp-&gt;ts_complen] = flag;</a>
<a name="ln1093">    compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln1094">    bool v = match_compoundrule(slang, compflags + sp-&gt;ts_compsplit);</a>
<a name="ln1095">    compflags[sp-&gt;ts_complen] = NUL;</a>
<a name="ln1096">    return v;</a>
<a name="ln1097">  }</a>
<a name="ln1098"> </a>
<a name="ln1099">  return true;</a>
<a name="ln1100">}</a>
<a name="ln1101"> </a>
<a name="ln1102">// Returns true if the compound flags in compflags[] match the start of any</a>
<a name="ln1103">// compound rule.  This is used to stop trying a compound if the flags</a>
<a name="ln1104">// collected so far can't possibly match any compound rule.</a>
<a name="ln1105">// Caller must check that slang-&gt;sl_comprules is not NULL.</a>
<a name="ln1106">static bool match_compoundrule(slang_T *slang, char_u *compflags)</a>
<a name="ln1107">{</a>
<a name="ln1108">  char_u      *p;</a>
<a name="ln1109">  int i;</a>
<a name="ln1110">  int c;</a>
<a name="ln1111"> </a>
<a name="ln1112">  // loop over all the COMPOUNDRULE entries</a>
<a name="ln1113">  for (p = slang-&gt;sl_comprules; *p != NUL; ++p) {</a>
<a name="ln1114">    // loop over the flags in the compound word we have made, match</a>
<a name="ln1115">    // them against the current rule entry</a>
<a name="ln1116">    for (i = 0;; ++i) {</a>
<a name="ln1117">      c = compflags[i];</a>
<a name="ln1118">      if (c == NUL)</a>
<a name="ln1119">        // found a rule that matches for the flags we have so far</a>
<a name="ln1120">        return true;</a>
<a name="ln1121">      if (*p == '/' || *p == NUL)</a>
<a name="ln1122">        break;          // end of rule, it's too short</a>
<a name="ln1123">      if (*p == '[') {</a>
<a name="ln1124">        bool match = false;</a>
<a name="ln1125"> </a>
<a name="ln1126">        // compare against all the flags in []</a>
<a name="ln1127">        ++p;</a>
<a name="ln1128">        while (*p != ']' &amp;&amp; *p != NUL)</a>
<a name="ln1129">          if (*p++ == c)</a>
<a name="ln1130">            match = true;</a>
<a name="ln1131">        if (!match)</a>
<a name="ln1132">          break;            // none matches</a>
<a name="ln1133">      } else if (*p != c)</a>
<a name="ln1134">        break;          // flag of word doesn't match flag in pattern</a>
<a name="ln1135">      ++p;</a>
<a name="ln1136">    }</a>
<a name="ln1137"> </a>
<a name="ln1138">    // Skip to the next &quot;/&quot;, where the next pattern starts.</a>
<a name="ln1139">    p = vim_strchr(p, '/');</a>
<a name="ln1140">    if (p == NULL)</a>
<a name="ln1141">      break;</a>
<a name="ln1142">  }</a>
<a name="ln1143"> </a>
<a name="ln1144">  // Checked all the rules and none of them match the flags, so there</a>
<a name="ln1145">  // can't possibly be a compound starting with these flags.</a>
<a name="ln1146">  return false;</a>
<a name="ln1147">}</a>
<a name="ln1148"> </a>
<a name="ln1149">// Return non-zero if the prefix indicated by &quot;arridx&quot; matches with the prefix</a>
<a name="ln1150">// ID in &quot;flags&quot; for the word &quot;word&quot;.</a>
<a name="ln1151">// The WF_RAREPFX flag is included in the return value for a rare prefix.</a>
<a name="ln1152">static int</a>
<a name="ln1153">valid_word_prefix (</a>
<a name="ln1154">    int totprefcnt,                 // nr of prefix IDs</a>
<a name="ln1155">    int arridx,                     // idx in sl_pidxs[]</a>
<a name="ln1156">    int flags,</a>
<a name="ln1157">    char_u *word,</a>
<a name="ln1158">    slang_T *slang,</a>
<a name="ln1159">    bool cond_req                   // only use prefixes with a condition</a>
<a name="ln1160">)</a>
<a name="ln1161">{</a>
<a name="ln1162">  int prefcnt;</a>
<a name="ln1163">  int pidx;</a>
<a name="ln1164">  int prefid;</a>
<a name="ln1165"> </a>
<a name="ln1166">  prefid = (unsigned)flags &gt;&gt; 24;</a>
<a name="ln1167">  for (prefcnt = totprefcnt - 1; prefcnt &gt;= 0; --prefcnt) {</a>
<a name="ln1168">    pidx = slang-&gt;sl_pidxs[arridx + prefcnt];</a>
<a name="ln1169"> </a>
<a name="ln1170">    // Check the prefix ID.</a>
<a name="ln1171">    if (prefid != (pidx &amp; 0xff))</a>
<a name="ln1172">      continue;</a>
<a name="ln1173"> </a>
<a name="ln1174">    // Check if the prefix doesn't combine and the word already has a</a>
<a name="ln1175">    // suffix.</a>
<a name="ln1176">    if ((flags &amp; WF_HAS_AFF) &amp;&amp; (pidx &amp; WF_PFX_NC))</a>
<a name="ln1177">      continue;</a>
<a name="ln1178"> </a>
<a name="ln1179">    // Check the condition, if there is one.  The condition index is</a>
<a name="ln1180">    // stored in the two bytes above the prefix ID byte.</a>
<a name="ln1181">    regprog_T **rp = &amp;slang-&gt;sl_prefprog[((unsigned)pidx &gt;&gt; 8) &amp; 0xffff];</a>
<a name="ln1182">    if (*rp != NULL) {</a>
<a name="ln1183">      if (!vim_regexec_prog(rp, false, word, 0)) {</a>
<a name="ln1184">        continue;</a>
<a name="ln1185">      }</a>
<a name="ln1186">    } else if (cond_req)</a>
<a name="ln1187">      continue;</a>
<a name="ln1188"> </a>
<a name="ln1189">    // It's a match!  Return the WF_ flags.</a>
<a name="ln1190">    return pidx;</a>
<a name="ln1191">  }</a>
<a name="ln1192">  return 0;</a>
<a name="ln1193">}</a>
<a name="ln1194"> </a>
<a name="ln1195">// Check if the word at &quot;mip-&gt;mi_word&quot; has a matching prefix.</a>
<a name="ln1196">// If it does, then check the following word.</a>
<a name="ln1197">//</a>
<a name="ln1198">// If &quot;mode&quot; is &quot;FIND_COMPOUND&quot; then do the same after another word, find a</a>
<a name="ln1199">// prefix in a compound word.</a>
<a name="ln1200">//</a>
<a name="ln1201">// For a match mip-&gt;mi_result is updated.</a>
<a name="ln1202">static void find_prefix(matchinf_T *mip, int mode)</a>
<a name="ln1203">{</a>
<a name="ln1204">  idx_T arridx = 0;</a>
<a name="ln1205">  int len;</a>
<a name="ln1206">  int wlen = 0;</a>
<a name="ln1207">  int flen;</a>
<a name="ln1208">  int c;</a>
<a name="ln1209">  char_u      *ptr;</a>
<a name="ln1210">  idx_T lo, hi, m;</a>
<a name="ln1211">  slang_T     *slang = mip-&gt;mi_lp-&gt;lp_slang;</a>
<a name="ln1212">  char_u      *byts;</a>
<a name="ln1213">  idx_T       *idxs;</a>
<a name="ln1214"> </a>
<a name="ln1215">  byts = slang-&gt;sl_pbyts;</a>
<a name="ln1216">  if (byts == NULL)</a>
<a name="ln1217">    return;                     // array is empty</a>
<a name="ln1218"> </a>
<a name="ln1219">  // We use the case-folded word here, since prefixes are always</a>
<a name="ln1220">  // case-folded.</a>
<a name="ln1221">  ptr = mip-&gt;mi_fword;</a>
<a name="ln1222">  flen = mip-&gt;mi_fwordlen;      // available case-folded bytes</a>
<a name="ln1223">  if (mode == FIND_COMPOUND) {</a>
<a name="ln1224">    // Skip over the previously found word(s).</a>
<a name="ln1225">    ptr += mip-&gt;mi_compoff;</a>
<a name="ln1226">    flen -= mip-&gt;mi_compoff;</a>
<a name="ln1227">  }</a>
<a name="ln1228">  idxs = slang-&gt;sl_pidxs;</a>
<a name="ln1229"> </a>
<a name="ln1230">  // Repeat advancing in the tree until:</a>
<a name="ln1231">  // - there is a byte that doesn't match,</a>
<a name="ln1232">  // - we reach the end of the tree,</a>
<a name="ln1233">  // - or we reach the end of the line.</a>
<a name="ln1234">  for (;; ) {</a>
<a name="ln1235">    if (flen == 0 &amp;&amp; *mip-&gt;mi_fend != NUL)</a>
<a name="ln1236">      flen = fold_more(mip);</a>
<a name="ln1237"> </a>
<a name="ln1238">    len = byts[arridx++];</a>
<a name="ln1239"> </a>
<a name="ln1240">    // If the first possible byte is a zero the prefix could end here.</a>
<a name="ln1241">    // Check if the following word matches and supports the prefix.</a>
<a name="ln1242">    if (byts[arridx] == 0) {</a>
<a name="ln1243">      // There can be several prefixes with different conditions.  We</a>
<a name="ln1244">      // try them all, since we don't know which one will give the</a>
<a name="ln1245">      // longest match.  The word is the same each time, pass the list</a>
<a name="ln1246">      // of possible prefixes to find_word().</a>
<a name="ln1247">      mip-&gt;mi_prefarridx = arridx;</a>
<a name="ln1248">      mip-&gt;mi_prefcnt = len;</a>
<a name="ln1249">      while (len &gt; 0 &amp;&amp; byts[arridx] == 0) {</a>
<a name="ln1250">        ++arridx;</a>
<a name="ln1251">        --len;</a>
<a name="ln1252">      }</a>
<a name="ln1253">      mip-&gt;mi_prefcnt -= len;</a>
<a name="ln1254"> </a>
<a name="ln1255">      // Find the word that comes after the prefix.</a>
<a name="ln1256">      mip-&gt;mi_prefixlen = wlen;</a>
<a name="ln1257">      if (mode == FIND_COMPOUND)</a>
<a name="ln1258">        // Skip over the previously found word(s).</a>
<a name="ln1259">        mip-&gt;mi_prefixlen += mip-&gt;mi_compoff;</a>
<a name="ln1260"> </a>
<a name="ln1261">      // Case-folded length may differ from original length.</a>
<a name="ln1262">      mip-&gt;mi_cprefixlen = nofold_len(mip-&gt;mi_fword, mip-&gt;mi_prefixlen,</a>
<a name="ln1263">                                      mip-&gt;mi_word);</a>
<a name="ln1264">      find_word(mip, FIND_PREFIX);</a>
<a name="ln1265"> </a>
<a name="ln1266"> </a>
<a name="ln1267">      if (len == 0)</a>
<a name="ln1268">        break;              // no children, word must end here</a>
<a name="ln1269">    }</a>
<a name="ln1270"> </a>
<a name="ln1271">    // Stop looking at end of the line.</a>
<a name="ln1272">    if (ptr[wlen] == NUL)</a>
<a name="ln1273">      break;</a>
<a name="ln1274"> </a>
<a name="ln1275">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln1276">    c = ptr[wlen];</a>
<a name="ln1277">    lo = arridx;</a>
<a name="ln1278">    hi = arridx + len - 1;</a>
<a name="ln1279">    while (lo &lt; hi) {</a>
<a name="ln1280">      m = (lo + hi) / 2;</a>
<a name="ln1281">      if (byts[m] &gt; c)</a>
<a name="ln1282">        hi = m - 1;</a>
<a name="ln1283">      else if (byts[m] &lt; c)</a>
<a name="ln1284">        lo = m + 1;</a>
<a name="ln1285">      else {</a>
<a name="ln1286">        lo = hi = m;</a>
<a name="ln1287">        break;</a>
<a name="ln1288">      }</a>
<a name="ln1289">    }</a>
<a name="ln1290"> </a>
<a name="ln1291">    // Stop if there is no matching byte.</a>
<a name="ln1292">    if (hi &lt; lo || byts[lo] != c)</a>
<a name="ln1293">      break;</a>
<a name="ln1294"> </a>
<a name="ln1295">    // Continue at the child (if there is one).</a>
<a name="ln1296">    arridx = idxs[lo];</a>
<a name="ln1297">    ++wlen;</a>
<a name="ln1298">    --flen;</a>
<a name="ln1299">  }</a>
<a name="ln1300">}</a>
<a name="ln1301"> </a>
<a name="ln1302">// Need to fold at least one more character.  Do until next non-word character</a>
<a name="ln1303">// for efficiency.  Include the non-word character too.</a>
<a name="ln1304">// Return the length of the folded chars in bytes.</a>
<a name="ln1305">static int fold_more(matchinf_T *mip)</a>
<a name="ln1306">{</a>
<a name="ln1307">  int flen;</a>
<a name="ln1308">  char_u      *p;</a>
<a name="ln1309"> </a>
<a name="ln1310">  p = mip-&gt;mi_fend;</a>
<a name="ln1311">  do {</a>
<a name="ln1312">    MB_PTR_ADV(mip-&gt;mi_fend);</a>
<a name="ln1313">  } while (*mip-&gt;mi_fend != NUL &amp;&amp; spell_iswordp(mip-&gt;mi_fend, mip-&gt;mi_win));</a>
<a name="ln1314"> </a>
<a name="ln1315">  // Include the non-word character so that we can check for the word end.</a>
<a name="ln1316">  if (*mip-&gt;mi_fend != NUL) {</a>
<a name="ln1317">    MB_PTR_ADV(mip-&gt;mi_fend);</a>
<a name="ln1318">  }</a>
<a name="ln1319"> </a>
<a name="ln1320">  (void)spell_casefold(mip-&gt;mi_win, p, (int)(mip-&gt;mi_fend - p),</a>
<a name="ln1321">                       mip-&gt;mi_fword + mip-&gt;mi_fwordlen,</a>
<a name="ln1322">                       MAXWLEN - mip-&gt;mi_fwordlen);</a>
<a name="ln1323">  flen = (int)STRLEN(mip-&gt;mi_fword + mip-&gt;mi_fwordlen);</a>
<a name="ln1324">  mip-&gt;mi_fwordlen += flen;</a>
<a name="ln1325">  return flen;</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328">/// Checks case flags for a word. Returns true, if the word has the requested</a>
<a name="ln1329">/// case.</a>
<a name="ln1330">///</a>
<a name="ln1331">/// @param wordflags Flags for the checked word.</a>
<a name="ln1332">/// @param treeflags Flags for the word in the spell tree.</a>
<a name="ln1333">static bool spell_valid_case(int wordflags, int treeflags)</a>
<a name="ln1334">{</a>
<a name="ln1335">  return (wordflags == WF_ALLCAP &amp;&amp; (treeflags &amp; WF_FIXCAP) == 0)</a>
<a name="ln1336">         || ((treeflags &amp; (WF_ALLCAP | WF_KEEPCAP)) == 0</a>
<a name="ln1337">             &amp;&amp; ((treeflags &amp; WF_ONECAP) == 0</a>
<a name="ln1338">                 || (wordflags &amp; WF_ONECAP) != 0));</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">// Returns true if spell checking is not enabled.</a>
<a name="ln1342">static bool no_spell_checking(win_T *wp)</a>
<a name="ln1343">{</a>
<a name="ln1344">  if (!wp-&gt;w_p_spell || *wp-&gt;w_s-&gt;b_p_spl == NUL</a>
<a name="ln1345">      || GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)) {</a>
<a name="ln1346">    EMSG(_(e_no_spell));</a>
<a name="ln1347">    return true;</a>
<a name="ln1348">  }</a>
<a name="ln1349">  return false;</a>
<a name="ln1350">}</a>
<a name="ln1351"> </a>
<a name="ln1352">// Moves to the next spell error.</a>
<a name="ln1353">// &quot;curline&quot; is false for &quot;[s&quot;, &quot;]s&quot;, &quot;[S&quot; and &quot;]S&quot;.</a>
<a name="ln1354">// &quot;curline&quot; is true to find word under/after cursor in the same line.</a>
<a name="ln1355">// For Insert mode completion &quot;dir&quot; is BACKWARD and &quot;curline&quot; is true: move</a>
<a name="ln1356">// to after badly spelled word before the cursor.</a>
<a name="ln1357">// Return 0 if not found, length of the badly spelled word otherwise.</a>
<a name="ln1358">size_t</a>
<a name="ln1359">spell_move_to (</a>
<a name="ln1360">    win_T *wp,</a>
<a name="ln1361">    int dir,                  // FORWARD or BACKWARD</a>
<a name="ln1362">    bool allwords,            // true for &quot;[s&quot;/&quot;]s&quot;, false for &quot;[S&quot;/&quot;]S&quot;</a>
<a name="ln1363">    bool curline,</a>
<a name="ln1364">    hlf_T *attrp              // return: attributes of bad word or NULL</a>
<a name="ln1365">                              // (only when &quot;dir&quot; is FORWARD)</a>
<a name="ln1366">)</a>
<a name="ln1367">{</a>
<a name="ln1368">  linenr_T lnum;</a>
<a name="ln1369">  pos_T found_pos;</a>
<a name="ln1370">  size_t found_len = 0;</a>
<a name="ln1371">  char_u      *line;</a>
<a name="ln1372">  char_u      *p;</a>
<a name="ln1373">  char_u      *endp;</a>
<a name="ln1374">  hlf_T attr = HLF_COUNT;</a>
<a name="ln1375">  size_t len;</a>
<a name="ln1376">  int has_syntax = syntax_present(wp);</a>
<a name="ln1377">  int col;</a>
<a name="ln1378">  bool can_spell;</a>
<a name="ln1379">  char_u      *buf = NULL;</a>
<a name="ln1380">  size_t buflen = 0;</a>
<a name="ln1381">  int skip = 0;</a>
<a name="ln1382">  int capcol = -1;</a>
<a name="ln1383">  bool found_one = false;</a>
<a name="ln1384">  bool wrapped = false;</a>
<a name="ln1385"> </a>
<a name="ln1386">  if (no_spell_checking(wp))</a>
<a name="ln1387">    return 0;</a>
<a name="ln1388"> </a>
<a name="ln1389">  // Start looking for bad word at the start of the line, because we can't</a>
<a name="ln1390">  // start halfway through a word, we don't know where it starts or ends.</a>
<a name="ln1391">  //</a>
<a name="ln1392">  // When searching backwards, we continue in the line to find the last</a>
<a name="ln1393">  // bad word (in the cursor line: before the cursor).</a>
<a name="ln1394">  //</a>
<a name="ln1395">  // We concatenate the start of the next line, so that wrapped words work</a>
<a name="ln1396">  // (e.g. &quot;et&lt;line-break&gt;cetera&quot;).  Doesn't work when searching backwards</a>
<a name="ln1397">  // though...</a>
<a name="ln1398">  lnum = wp-&gt;w_cursor.lnum;</a>
<a name="ln1399">  clearpos(&amp;found_pos);</a>
<a name="ln1400"> </a>
<a name="ln1401">  while (!got_int) {</a>
<a name="ln1402">    line = ml_get_buf(wp-&gt;w_buffer, lnum, FALSE);</a>
<a name="ln1403"> </a>
<a name="ln1404">    len = STRLEN(line);</a>
<a name="ln1405">    if (buflen &lt; len + MAXWLEN + 2) {</a>
<a name="ln1406">      xfree(buf);</a>
<a name="ln1407">      buflen = len + MAXWLEN + 2;</a>
<a name="ln1408">      buf = xmalloc(buflen);</a>
<a name="ln1409">    }</a>
<a name="ln1410">    assert(buf &amp;&amp; buflen &gt;= len + MAXWLEN + 2);</a>
<a name="ln1411"> </a>
<a name="ln1412">    // In first line check first word for Capital.</a>
<a name="ln1413">    if (lnum == 1)</a>
<a name="ln1414">      capcol = 0;</a>
<a name="ln1415"> </a>
<a name="ln1416">    // For checking first word with a capital skip white space.</a>
<a name="ln1417">    if (capcol == 0) {</a>
<a name="ln1418">      capcol = (int)getwhitecols(line);</a>
<a name="ln1419">    } else if (curline &amp;&amp; wp == curwin) {</a>
<a name="ln1420">      // For spellbadword(): check if first word needs a capital.</a>
<a name="ln1421">      col = (int)getwhitecols(line);</a>
<a name="ln1422">      if (check_need_cap(lnum, col)) {</a>
<a name="ln1423">        capcol = col;</a>
<a name="ln1424">      }</a>
<a name="ln1425"> </a>
<a name="ln1426">      // Need to get the line again, may have looked at the previous</a>
<a name="ln1427">      // one.</a>
<a name="ln1428">      line = ml_get_buf(wp-&gt;w_buffer, lnum, FALSE);</a>
<a name="ln1429">    }</a>
<a name="ln1430"> </a>
<a name="ln1431">    // Copy the line into &quot;buf&quot; and append the start of the next line if</a>
<a name="ln1432">    // possible.</a>
<a name="ln1433">    STRCPY(buf, line);</a>
<a name="ln1434">    if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count)</a>
<a name="ln1435">      spell_cat_line(buf + STRLEN(buf),</a>
<a name="ln1436">                     ml_get_buf(wp-&gt;w_buffer, lnum + 1, FALSE),</a>
<a name="ln1437">                     MAXWLEN);</a>
<a name="ln1438">    p = buf + skip;</a>
<a name="ln1439">    endp = buf + len;</a>
<a name="ln1440">    while (p &lt; endp) {</a>
<a name="ln1441">      // When searching backward don't search after the cursor.  Unless</a>
<a name="ln1442">      // we wrapped around the end of the buffer.</a>
<a name="ln1443">      if (dir == BACKWARD</a>
<a name="ln1444">          &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln1445">          &amp;&amp; !wrapped</a>
<a name="ln1446">          &amp;&amp; (colnr_T)(p - buf) &gt;= wp-&gt;w_cursor.col)</a>
<a name="ln1447">        break;</a>
<a name="ln1448"> </a>
<a name="ln1449">      // start of word</a>
<a name="ln1450">      attr = HLF_COUNT;</a>
<a name="ln1451">      len = spell_check(wp, p, &amp;attr, &amp;capcol, false);</a>
<a name="ln1452"> </a>
<a name="ln1453">      if (attr != HLF_COUNT) {</a>
<a name="ln1454">        // We found a bad word.  Check the attribute.</a>
<a name="ln1455">        if (allwords || attr == HLF_SPB) {</a>
<a name="ln1456">          // When searching forward only accept a bad word after</a>
<a name="ln1457">          // the cursor.</a>
<a name="ln1458">          if (dir == BACKWARD</a>
<a name="ln1459">              || lnum != wp-&gt;w_cursor.lnum</a>
<a name="ln1460">              || wrapped</a>
<a name="ln1461">              || ((colnr_T)(curline</a>
<a name="ln1462">                            ? p - buf + (ptrdiff_t)len</a>
<a name="ln1463">                            : p - buf) &gt; wp-&gt;w_cursor.col)) {</a>
<a name="ln1464">            if (has_syntax) {</a>
<a name="ln1465">              col = (int)(p - buf);</a>
<a name="ln1466">              (void)syn_get_id(wp, lnum, (colnr_T)col,</a>
<a name="ln1467">                  FALSE, &amp;can_spell, FALSE);</a>
<a name="ln1468">              if (!can_spell)</a>
<a name="ln1469">                attr = HLF_COUNT;</a>
<a name="ln1470">            } else</a>
<a name="ln1471">              can_spell = true;</a>
<a name="ln1472"> </a>
<a name="ln1473">            if (can_spell) {</a>
<a name="ln1474">              found_one = true;</a>
<a name="ln1475">              found_pos.lnum = lnum;</a>
<a name="ln1476">              found_pos.col = (int)(p - buf);</a>
<a name="ln1477">              found_pos.coladd = 0;</a>
<a name="ln1478">              if (dir == FORWARD) {</a>
<a name="ln1479">                // No need to search further.</a>
<a name="ln1480">                wp-&gt;w_cursor = found_pos;</a>
<a name="ln1481">                xfree(buf);</a>
<a name="ln1482">                if (attrp != NULL)</a>
<a name="ln1483">                  *attrp = attr;</a>
<a name="ln1484">                return len;</a>
<a name="ln1485">              } else if (curline) {</a>
<a name="ln1486">                // Insert mode completion: put cursor after</a>
<a name="ln1487">                // the bad word.</a>
<a name="ln1488">                assert(len &lt;= INT_MAX);</a>
<a name="ln1489">                found_pos.col += (int)len;</a>
<a name="ln1490">              }</a>
<a name="ln1491">              found_len = len;</a>
<a name="ln1492">            }</a>
<a name="ln1493">          } else</a>
<a name="ln1494">            found_one = true;</a>
<a name="ln1495">        }</a>
<a name="ln1496">      }</a>
<a name="ln1497"> </a>
<a name="ln1498">      // advance to character after the word</a>
<a name="ln1499">      p += len;</a>
<a name="ln1500">      assert(len &lt;= INT_MAX);</a>
<a name="ln1501">      capcol -= (int)len;</a>
<a name="ln1502">    }</a>
<a name="ln1503"> </a>
<a name="ln1504">    if (dir == BACKWARD &amp;&amp; found_pos.lnum != 0) {</a>
<a name="ln1505">      // Use the last match in the line (before the cursor).</a>
<a name="ln1506">      wp-&gt;w_cursor = found_pos;</a>
<a name="ln1507">      xfree(buf);</a>
<a name="ln1508">      return found_len;</a>
<a name="ln1509">    }</a>
<a name="ln1510"> </a>
<a name="ln1511">    if (curline) {</a>
<a name="ln1512">      break;            // only check cursor line</a>
<a name="ln1513">    }</a>
<a name="ln1514"> </a>
<a name="ln1515">    // If we are back at the starting line and searched it again there</a>
<a name="ln1516">    // is no match, give up.</a>
<a name="ln1517">    if (lnum == wp-&gt;w_cursor.lnum &amp;&amp; wrapped) {</a>
<a name="ln1518">      break;</a>
<a name="ln1519">    }</a>
<a name="ln1520"> </a>
<a name="ln1521">    // Advance to next line.</a>
<a name="ln1522">    if (dir == BACKWARD) {</a>
<a name="ln1523">      if (lnum &gt; 1) {</a>
<a name="ln1524">        lnum--;</a>
<a name="ln1525">      } else if (!p_ws) {</a>
<a name="ln1526">        break;              // at first line and 'nowrapscan'</a>
<a name="ln1527">      } else {</a>
<a name="ln1528">        // Wrap around to the end of the buffer.  May search the</a>
<a name="ln1529">        // starting line again and accept the last match.</a>
<a name="ln1530">        lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln1531">        wrapped = true;</a>
<a name="ln1532">        if (!shortmess(SHM_SEARCH))</a>
<a name="ln1533">          give_warning((char_u *)_(top_bot_msg), true);</a>
<a name="ln1534">      }</a>
<a name="ln1535">      capcol = -1;</a>
<a name="ln1536">    } else {</a>
<a name="ln1537">      if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count)</a>
<a name="ln1538">        ++lnum;</a>
<a name="ln1539">      else if (!p_ws)</a>
<a name="ln1540">        break;              // at first line and 'nowrapscan'</a>
<a name="ln1541">      else {</a>
<a name="ln1542">        // Wrap around to the start of the buffer.  May search the</a>
<a name="ln1543">        // starting line again and accept the first match.</a>
<a name="ln1544">        lnum = 1;</a>
<a name="ln1545">        wrapped = true;</a>
<a name="ln1546">        if (!shortmess(SHM_SEARCH))</a>
<a name="ln1547">          give_warning((char_u *)_(bot_top_msg), true);</a>
<a name="ln1548">      }</a>
<a name="ln1549"> </a>
<a name="ln1550">      // If we are back at the starting line and there is no match then</a>
<a name="ln1551">      // give up.</a>
<a name="ln1552">      if (lnum == wp-&gt;w_cursor.lnum &amp;&amp; !found_one) {</a>
<a name="ln1553">        break;</a>
<a name="ln1554">      }</a>
<a name="ln1555"> </a>
<a name="ln1556">      // Skip the characters at the start of the next line that were</a>
<a name="ln1557">      // included in a match crossing line boundaries.</a>
<a name="ln1558">      if (attr == HLF_COUNT)</a>
<a name="ln1559">        skip = (int)(p - endp);</a>
<a name="ln1560">      else</a>
<a name="ln1561">        skip = 0;</a>
<a name="ln1562"> </a>
<a name="ln1563">      // Capcol skips over the inserted space.</a>
<a name="ln1564">      --capcol;</a>
<a name="ln1565"> </a>
<a name="ln1566">      // But after empty line check first word in next line</a>
<a name="ln1567">      if (*skipwhite(line) == NUL)</a>
<a name="ln1568">        capcol = 0;</a>
<a name="ln1569">    }</a>
<a name="ln1570"> </a>
<a name="ln1571">    line_breakcheck();</a>
<a name="ln1572">  }</a>
<a name="ln1573"> </a>
<a name="ln1574">  xfree(buf);</a>
<a name="ln1575">  return 0;</a>
<a name="ln1576">}</a>
<a name="ln1577"> </a>
<a name="ln1578">// For spell checking: concatenate the start of the following line &quot;line&quot; into</a>
<a name="ln1579">// &quot;buf&quot;, blanking-out special characters.  Copy less then &quot;maxlen&quot; bytes.</a>
<a name="ln1580">// Keep the blanks at the start of the next line, this is used in win_line()</a>
<a name="ln1581">// to skip those bytes if the word was OK.</a>
<a name="ln1582">void spell_cat_line(char_u *buf, char_u *line, int maxlen)</a>
<a name="ln1583">{</a>
<a name="ln1584">  char_u      *p;</a>
<a name="ln1585">  int n;</a>
<a name="ln1586"> </a>
<a name="ln1587">  p = skipwhite(line);</a>
<a name="ln1588">  while (vim_strchr((char_u *)&quot;*#/\&quot;\t&quot;, *p) != NULL)</a>
<a name="ln1589">    p = skipwhite(p + 1);</a>
<a name="ln1590"> </a>
<a name="ln1591">  if (*p != NUL) {</a>
<a name="ln1592">    // Only worth concatenating if there is something else than spaces to</a>
<a name="ln1593">    // concatenate.</a>
<a name="ln1594">    n = (int)(p - line) + 1;</a>
<a name="ln1595">    if (n &lt; maxlen - 1) {</a>
<a name="ln1596">      memset(buf, ' ', n);</a>
<a name="ln1597">      STRLCPY(buf +  n, p, maxlen - n);</a>
<a name="ln1598">    }</a>
<a name="ln1599">  }</a>
<a name="ln1600">}</a>
<a name="ln1601"> </a>
<a name="ln1602">// Load word list(s) for &quot;lang&quot; from Vim spell file(s).</a>
<a name="ln1603">// &quot;lang&quot; must be the language without the region: e.g., &quot;en&quot;.</a>
<a name="ln1604">static void spell_load_lang(char_u *lang)</a>
<a name="ln1605">{</a>
<a name="ln1606">  char_u fname_enc[85];</a>
<a name="ln1607">  int r;</a>
<a name="ln1608">  spelload_T sl;</a>
<a name="ln1609">  int round;</a>
<a name="ln1610"> </a>
<a name="ln1611">  // Copy the language name to pass it to spell_load_cb() as a cookie.</a>
<a name="ln1612">  // It's truncated when an error is detected.</a>
<a name="ln1613">  STRCPY(sl.sl_lang, lang);</a>
<a name="ln1614">  sl.sl_slang = NULL;</a>
<a name="ln1615">  sl.sl_nobreak = false;</a>
<a name="ln1616"> </a>
<a name="ln1617">  // We may retry when no spell file is found for the language, an</a>
<a name="ln1618">  // autocommand may load it then.</a>
<a name="ln1619">  for (round = 1; round &lt;= 2; ++round) {</a>
<a name="ln1620">    // Find the first spell file for &quot;lang&quot; in 'runtimepath' and load it.</a>
<a name="ln1621">    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,</a>
<a name="ln1622">                 &quot;spell/%s.%s.spl&quot;, lang, spell_enc());</a>
<a name="ln1623">    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &amp;sl);</a>
<a name="ln1624"> </a>
<a name="ln1625">    if (r == FAIL &amp;&amp; *sl.sl_lang != NUL) {</a>
<a name="ln1626">      // Try loading the ASCII version.</a>
<a name="ln1627">      vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,</a>
<a name="ln1628">                   &quot;spell/%s.ascii.spl&quot;, lang);</a>
<a name="ln1629">      r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &amp;sl);</a>
<a name="ln1630"> </a>
<a name="ln1631">      if (r == FAIL &amp;&amp; *sl.sl_lang != NUL &amp;&amp; round == 1</a>
<a name="ln1632">          &amp;&amp; apply_autocmds(EVENT_SPELLFILEMISSING, lang,</a>
<a name="ln1633">              curbuf-&gt;b_fname, FALSE, curbuf))</a>
<a name="ln1634">        continue;</a>
<a name="ln1635">      break;</a>
<a name="ln1636">    }</a>
<a name="ln1637">    break;</a>
<a name="ln1638">  }</a>
<a name="ln1639"> </a>
<a name="ln1640">  if (r == FAIL) {</a>
<a name="ln1641">    if (starting) {</a>
<a name="ln1642">      // Prompt the user at VimEnter if spell files are missing. #3027</a>
<a name="ln1643">      // Plugins aren't loaded yet, so spellfile.vim cannot handle this case.</a>
<a name="ln1644">      char autocmd_buf[512] = { 0 };</a>
<a name="ln1645">      snprintf(autocmd_buf, sizeof(autocmd_buf),</a>
<a name="ln1646">               &quot;autocmd VimEnter * call spellfile#LoadFile('%s')|set spell&quot;,</a>
<a name="ln1647">               lang);</a>
<a name="ln1648">      do_cmdline_cmd(autocmd_buf);</a>
<a name="ln1649">    } else {</a>
<a name="ln1650">      smsg(</a>
<a name="ln1651">        _(&quot;Warning: Cannot find word list \&quot;%s.%s.spl\&quot; or \&quot;%s.ascii.spl\&quot;&quot;),</a>
<a name="ln1652">        lang, spell_enc(), lang);</a>
<a name="ln1653">    }</a>
<a name="ln1654">  } else if (sl.sl_slang != NULL) {</a>
<a name="ln1655">    // At least one file was loaded, now load ALL the additions.</a>
<a name="ln1656">    STRCPY(fname_enc + STRLEN(fname_enc) - 3, &quot;add.spl&quot;);</a>
<a name="ln1657">    do_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &amp;sl);</a>
<a name="ln1658">  }</a>
<a name="ln1659">}</a>
<a name="ln1660"> </a>
<a name="ln1661">// Return the encoding used for spell checking: Use 'encoding', except that we</a>
<a name="ln1662">// use &quot;latin1&quot; for &quot;latin9&quot;.  And limit to 60 characters (just in case).</a>
<a name="ln1663">char_u *spell_enc(void)</a>
<a name="ln1664">{</a>
<a name="ln1665"> </a>
<a name="ln1666">  if (STRLEN(p_enc) &lt; 60 &amp;&amp; STRCMP(p_enc, &quot;iso-8859-15&quot;) != 0)</a>
<a name="ln1667">    return p_enc;</a>
<a name="ln1668">  return (char_u *)&quot;latin1&quot;;</a>
<a name="ln1669">}</a>
<a name="ln1670"> </a>
<a name="ln1671">// Get the name of the .spl file for the internal wordlist into</a>
<a name="ln1672">// &quot;fname[MAXPATHL]&quot;.</a>
<a name="ln1673">static void int_wordlist_spl(char_u *fname)</a>
<a name="ln1674">{</a>
<a name="ln1675">  vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,</a>
<a name="ln1676">      int_wordlist, spell_enc());</a>
<a name="ln1677">}</a>
<a name="ln1678"> </a>
<a name="ln1679">// Allocate a new slang_T for language &quot;lang&quot;.  &quot;lang&quot; can be NULL.</a>
<a name="ln1680">// Caller must fill &quot;sl_next&quot;.</a>
<a name="ln1681">slang_T *slang_alloc(char_u *lang)</a>
<a name="ln1682">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln1683">{</a>
<a name="ln1684">  slang_T *lp = xcalloc(1, sizeof(slang_T));</a>
<a name="ln1685"> </a>
<a name="ln1686">  if (lang != NULL)</a>
<a name="ln1687">    lp-&gt;sl_name = vim_strsave(lang);</a>
<a name="ln1688">  ga_init(&amp;lp-&gt;sl_rep, sizeof(fromto_T), 10);</a>
<a name="ln1689">  ga_init(&amp;lp-&gt;sl_repsal, sizeof(fromto_T), 10);</a>
<a name="ln1690">  lp-&gt;sl_compmax = MAXWLEN;</a>
<a name="ln1691">  lp-&gt;sl_compsylmax = MAXWLEN;</a>
<a name="ln1692">  hash_init(&amp;lp-&gt;sl_wordcount);</a>
<a name="ln1693"> </a>
<a name="ln1694">  return lp;</a>
<a name="ln1695">}</a>
<a name="ln1696"> </a>
<a name="ln1697">// Free the contents of an slang_T and the structure itself.</a>
<a name="ln1698">void slang_free(slang_T *lp)</a>
<a name="ln1699">{</a>
<a name="ln1700">  xfree(lp-&gt;sl_name);</a>
<a name="ln1701">  xfree(lp-&gt;sl_fname);</a>
<a name="ln1702">  slang_clear(lp);</a>
<a name="ln1703">  xfree(lp);</a>
<a name="ln1704">}</a>
<a name="ln1705"> </a>
<a name="ln1706">/// Frees a salitem_T</a>
<a name="ln1707">static void free_salitem(salitem_T *smp) {</a>
<a name="ln1708">  xfree(smp-&gt;sm_lead);</a>
<a name="ln1709">  // Don't free sm_oneof and sm_rules, they point into sm_lead.</a>
<a name="ln1710">  xfree(smp-&gt;sm_to);</a>
<a name="ln1711">  xfree(smp-&gt;sm_lead_w);</a>
<a name="ln1712">  xfree(smp-&gt;sm_oneof_w);</a>
<a name="ln1713">  xfree(smp-&gt;sm_to_w);</a>
<a name="ln1714">}</a>
<a name="ln1715"> </a>
<a name="ln1716">/// Frees a fromto_T</a>
<a name="ln1717">static void free_fromto(fromto_T *ftp) {</a>
<a name="ln1718">  xfree(ftp-&gt;ft_from);</a>
<a name="ln1719">  xfree(ftp-&gt;ft_to);</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">// Clear an slang_T so that the file can be reloaded.</a>
<a name="ln1723">void slang_clear(slang_T *lp)</a>
<a name="ln1724">{</a>
<a name="ln1725">  garray_T    *gap;</a>
<a name="ln1726"> </a>
<a name="ln1727">  XFREE_CLEAR(lp-&gt;sl_fbyts);</a>
<a name="ln1728">  XFREE_CLEAR(lp-&gt;sl_kbyts);</a>
<a name="ln1729">  XFREE_CLEAR(lp-&gt;sl_pbyts);</a>
<a name="ln1730"> </a>
<a name="ln1731">  XFREE_CLEAR(lp-&gt;sl_fidxs);</a>
<a name="ln1732">  XFREE_CLEAR(lp-&gt;sl_kidxs);</a>
<a name="ln1733">  XFREE_CLEAR(lp-&gt;sl_pidxs);</a>
<a name="ln1734"> </a>
<a name="ln1735">  GA_DEEP_CLEAR(&amp;lp-&gt;sl_rep, fromto_T, free_fromto);</a>
<a name="ln1736">  GA_DEEP_CLEAR(&amp;lp-&gt;sl_repsal, fromto_T, free_fromto);</a>
<a name="ln1737"> </a>
<a name="ln1738">  gap = &amp;lp-&gt;sl_sal;</a>
<a name="ln1739">  if (lp-&gt;sl_sofo) {</a>
<a name="ln1740">    // &quot;ga_len&quot; is set to 1 without adding an item for latin1</a>
<a name="ln1741">    GA_DEEP_CLEAR_PTR(gap);</a>
<a name="ln1742">  } else {</a>
<a name="ln1743">    // SAL items: free salitem_T items</a>
<a name="ln1744">    GA_DEEP_CLEAR(gap, salitem_T, free_salitem);</a>
<a name="ln1745">  }</a>
<a name="ln1746"> </a>
<a name="ln1747">  for (int i = 0; i &lt; lp-&gt;sl_prefixcnt; ++i) {</a>
<a name="ln1748">    vim_regfree(lp-&gt;sl_prefprog[i]);</a>
<a name="ln1749">  }</a>
<a name="ln1750">  lp-&gt;sl_prefixcnt = 0;</a>
<a name="ln1751">  XFREE_CLEAR(lp-&gt;sl_prefprog);</a>
<a name="ln1752">  XFREE_CLEAR(lp-&gt;sl_info);</a>
<a name="ln1753">  XFREE_CLEAR(lp-&gt;sl_midword);</a>
<a name="ln1754"> </a>
<a name="ln1755">  vim_regfree(lp-&gt;sl_compprog);</a>
<a name="ln1756">  lp-&gt;sl_compprog = NULL;</a>
<a name="ln1757">  XFREE_CLEAR(lp-&gt;sl_comprules);</a>
<a name="ln1758">  XFREE_CLEAR(lp-&gt;sl_compstartflags);</a>
<a name="ln1759">  XFREE_CLEAR(lp-&gt;sl_compallflags);</a>
<a name="ln1760"> </a>
<a name="ln1761">  XFREE_CLEAR(lp-&gt;sl_syllable);</a>
<a name="ln1762">  ga_clear(&amp;lp-&gt;sl_syl_items);</a>
<a name="ln1763"> </a>
<a name="ln1764">  ga_clear_strings(&amp;lp-&gt;sl_comppat);</a>
<a name="ln1765"> </a>
<a name="ln1766">  hash_clear_all(&amp;lp-&gt;sl_wordcount, WC_KEY_OFF);</a>
<a name="ln1767">  hash_init(&amp;lp-&gt;sl_wordcount);</a>
<a name="ln1768"> </a>
<a name="ln1769">  hash_clear_all(&amp;lp-&gt;sl_map_hash, 0);</a>
<a name="ln1770"> </a>
<a name="ln1771">  // Clear info from .sug file.</a>
<a name="ln1772">  slang_clear_sug(lp);</a>
<a name="ln1773"> </a>
<a name="ln1774">  lp-&gt;sl_compmax = MAXWLEN;</a>
<a name="ln1775">  lp-&gt;sl_compminlen = 0;</a>
<a name="ln1776">  lp-&gt;sl_compsylmax = MAXWLEN;</a>
<a name="ln1777">  lp-&gt;sl_regions[0] = NUL;</a>
<a name="ln1778">}</a>
<a name="ln1779"> </a>
<a name="ln1780">// Clear the info from the .sug file in &quot;lp&quot;.</a>
<a name="ln1781">void slang_clear_sug(slang_T *lp)</a>
<a name="ln1782">{</a>
<a name="ln1783">  XFREE_CLEAR(lp-&gt;sl_sbyts);</a>
<a name="ln1784">  XFREE_CLEAR(lp-&gt;sl_sidxs);</a>
<a name="ln1785">  close_spellbuf(lp-&gt;sl_sugbuf);</a>
<a name="ln1786">  lp-&gt;sl_sugbuf = NULL;</a>
<a name="ln1787">  lp-&gt;sl_sugloaded = false;</a>
<a name="ln1788">  lp-&gt;sl_sugtime = 0;</a>
<a name="ln1789">}</a>
<a name="ln1790"> </a>
<a name="ln1791">// Load one spell file and store the info into a slang_T.</a>
<a name="ln1792">// Invoked through do_in_runtimepath().</a>
<a name="ln1793">static void spell_load_cb(char_u *fname, void *cookie)</a>
<a name="ln1794">{</a>
<a name="ln1795">  spelload_T  *slp = (spelload_T *)cookie;</a>
<a name="ln1796">  slang_T     *slang;</a>
<a name="ln1797"> </a>
<a name="ln1798">  slang = spell_load_file(fname, slp-&gt;sl_lang, NULL, false);</a>
<a name="ln1799">  if (slang != NULL) {</a>
<a name="ln1800">    // When a previously loaded file has NOBREAK also use it for the</a>
<a name="ln1801">    // &quot;.add&quot; files.</a>
<a name="ln1802">    if (slp-&gt;sl_nobreak &amp;&amp; slang-&gt;sl_add)</a>
<a name="ln1803">      slang-&gt;sl_nobreak = true;</a>
<a name="ln1804">    else if (slang-&gt;sl_nobreak)</a>
<a name="ln1805">      slp-&gt;sl_nobreak = true;</a>
<a name="ln1806"> </a>
<a name="ln1807">    slp-&gt;sl_slang = slang;</a>
<a name="ln1808">  }</a>
<a name="ln1809">}</a>
<a name="ln1810"> </a>
<a name="ln1811">/// Add a word to the hashtable of common words.</a>
<a name="ln1812">/// If it's already there then the counter is increased.</a>
<a name="ln1813">///</a>
<a name="ln1814">/// @param[in]  lp</a>
<a name="ln1815">/// @param[in]  word  added to common words hashtable</a>
<a name="ln1816">/// @param[in]  len  length of word or -1 for NUL terminated</a>
<a name="ln1817">/// @param[in]  count  1 to count once, 10 to init</a>
<a name="ln1818">void count_common_word(slang_T *lp, char_u *word, int len, int count)</a>
<a name="ln1819">{</a>
<a name="ln1820">  hash_T hash;</a>
<a name="ln1821">  hashitem_T  *hi;</a>
<a name="ln1822">  wordcount_T *wc;</a>
<a name="ln1823">  char_u buf[MAXWLEN];</a>
<a name="ln1824">  char_u      *p;</a>
<a name="ln1825"> </a>
<a name="ln1826">  if (len == -1) {</a>
<a name="ln1827">    p = word;</a>
<a name="ln1828">  } else if (len &gt;= MAXWLEN) {</a>
<a name="ln1829">    return;</a>
<a name="ln1830">  } else {</a>
<a name="ln1831">    STRLCPY(buf, word, len + 1);</a>
<a name="ln1832">    p = buf;</a>
<a name="ln1833">  }</a>
<a name="ln1834"> </a>
<a name="ln1835">  hash = hash_hash(p);</a>
<a name="ln1836">  const size_t p_len = STRLEN(p);</a>
<a name="ln1837">  hi = hash_lookup(&amp;lp-&gt;sl_wordcount, (const char *)p, p_len, hash);</a>
<a name="ln1838">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln1839">    wc = xmalloc(sizeof(wordcount_T) + p_len);</a>
<a name="ln1840">    memcpy(wc-&gt;wc_word, p, p_len + 1);</a>
<a name="ln1841">    wc-&gt;wc_count = count;</a>
<a name="ln1842">    hash_add_item(&amp;lp-&gt;sl_wordcount, hi, wc-&gt;wc_word, hash);</a>
<a name="ln1843">  } else {</a>
<a name="ln1844">    wc = HI2WC(hi);</a>
<a name="ln1845">    if ((wc-&gt;wc_count += count) &lt; (unsigned)count)      // check for overflow</a>
<a name="ln1846">      wc-&gt;wc_count = MAXWORDCOUNT;</a>
<a name="ln1847">  }</a>
<a name="ln1848">}</a>
<a name="ln1849"> </a>
<a name="ln1850">// Adjust the score of common words.</a>
<a name="ln1851">static int</a>
<a name="ln1852">score_wordcount_adj (</a>
<a name="ln1853">    slang_T *slang,</a>
<a name="ln1854">    int score,</a>
<a name="ln1855">    char_u *word,</a>
<a name="ln1856">    bool split                  // word was split, less bonus</a>
<a name="ln1857">)</a>
<a name="ln1858">{</a>
<a name="ln1859">  hashitem_T  *hi;</a>
<a name="ln1860">  wordcount_T *wc;</a>
<a name="ln1861">  int bonus;</a>
<a name="ln1862">  int newscore;</a>
<a name="ln1863"> </a>
<a name="ln1864">  hi = hash_find(&amp;slang-&gt;sl_wordcount, word);</a>
<a name="ln1865">  if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1866">    wc = HI2WC(hi);</a>
<a name="ln1867">    if (wc-&gt;wc_count &lt; SCORE_THRES2)</a>
<a name="ln1868">      bonus = SCORE_COMMON1;</a>
<a name="ln1869">    else if (wc-&gt;wc_count &lt; SCORE_THRES3)</a>
<a name="ln1870">      bonus = SCORE_COMMON2;</a>
<a name="ln1871">    else</a>
<a name="ln1872">      bonus = SCORE_COMMON3;</a>
<a name="ln1873">    if (split)</a>
<a name="ln1874">      newscore = score - bonus / 2;</a>
<a name="ln1875">    else</a>
<a name="ln1876">      newscore = score - bonus;</a>
<a name="ln1877">    if (newscore &lt; 0)</a>
<a name="ln1878">      return 0;</a>
<a name="ln1879">    return newscore;</a>
<a name="ln1880">  }</a>
<a name="ln1881">  return score;</a>
<a name="ln1882">}</a>
<a name="ln1883"> </a>
<a name="ln1884">// Returns true if byte &quot;n&quot; appears in &quot;str&quot;.</a>
<a name="ln1885">// Like strchr() but independent of locale.</a>
<a name="ln1886">bool byte_in_str(char_u *str, int n)</a>
<a name="ln1887">{</a>
<a name="ln1888">  char_u      *p;</a>
<a name="ln1889"> </a>
<a name="ln1890">  for (p = str; *p != NUL; ++p)</a>
<a name="ln1891">    if (*p == n)</a>
<a name="ln1892">      return true;</a>
<a name="ln1893">  return false;</a>
<a name="ln1894">}</a>
<a name="ln1895"> </a>
<a name="ln1896">// Truncate &quot;slang-&gt;sl_syllable&quot; at the first slash and put the following items</a>
<a name="ln1897">// in &quot;slang-&gt;sl_syl_items&quot;.</a>
<a name="ln1898">int init_syl_tab(slang_T *slang)</a>
<a name="ln1899">{</a>
<a name="ln1900">  char_u      *p;</a>
<a name="ln1901">  char_u      *s;</a>
<a name="ln1902">  int l;</a>
<a name="ln1903"> </a>
<a name="ln1904">  ga_init(&amp;slang-&gt;sl_syl_items, sizeof(syl_item_T), 4);</a>
<a name="ln1905">  p = vim_strchr(slang-&gt;sl_syllable, '/');</a>
<a name="ln1906">  while (p != NULL) {</a>
<a name="ln1907">    *p++ = NUL;</a>
<a name="ln1908">    if (*p == NUL)          // trailing slash</a>
<a name="ln1909">      break;</a>
<a name="ln1910">    s = p;</a>
<a name="ln1911">    p = vim_strchr(p, '/');</a>
<a name="ln1912">    if (p == NULL)</a>
<a name="ln1913">      l = (int)STRLEN(s);</a>
<a name="ln1914">    else</a>
<a name="ln1915">      l = (int)(p - s);</a>
<a name="ln1916">    if (l &gt;= SY_MAXLEN)</a>
<a name="ln1917">      return SP_FORMERROR;</a>
<a name="ln1918"> </a>
<a name="ln1919">    syl_item_T *syl = GA_APPEND_VIA_PTR(syl_item_T, &amp;slang-&gt;sl_syl_items);</a>
<a name="ln1920">    STRLCPY(syl-&gt;sy_chars, s, l + 1);</a>
<a name="ln1921">    syl-&gt;sy_len = l;</a>
<a name="ln1922">  }</a>
<a name="ln1923">  return OK;</a>
<a name="ln1924">}</a>
<a name="ln1925"> </a>
<a name="ln1926">// Count the number of syllables in &quot;word&quot;.</a>
<a name="ln1927">// When &quot;word&quot; contains spaces the syllables after the last space are counted.</a>
<a name="ln1928">// Returns zero if syllables are not defines.</a>
<a name="ln1929">static int count_syllables(slang_T *slang, const char_u *word)</a>
<a name="ln1930">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1931">{</a>
<a name="ln1932">  int cnt = 0;</a>
<a name="ln1933">  bool skip = false;</a>
<a name="ln1934">  int len;</a>
<a name="ln1935">  syl_item_T  *syl;</a>
<a name="ln1936">  int c;</a>
<a name="ln1937"> </a>
<a name="ln1938">  if (slang-&gt;sl_syllable == NULL)</a>
<a name="ln1939">    return 0;</a>
<a name="ln1940"> </a>
<a name="ln1941">  for (const char_u *p = word; *p != NUL; p += len) {</a>
<a name="ln1942">    // When running into a space reset counter.</a>
<a name="ln1943">    if (*p == ' ') {</a>
<a name="ln1944">      len = 1;</a>
<a name="ln1945">      cnt = 0;</a>
<a name="ln1946">      continue;</a>
<a name="ln1947">    }</a>
<a name="ln1948"> </a>
<a name="ln1949">    // Find longest match of syllable items.</a>
<a name="ln1950">    len = 0;</a>
<a name="ln1951">    for (int i = 0; i &lt; slang-&gt;sl_syl_items.ga_len; ++i) {</a>
<a name="ln1952">      syl = ((syl_item_T *)slang-&gt;sl_syl_items.ga_data) + i;</a>
<a name="ln1953">      if (syl-&gt;sy_len &gt; len</a>
<a name="ln1954">          &amp;&amp; STRNCMP(p, syl-&gt;sy_chars, syl-&gt;sy_len) == 0)</a>
<a name="ln1955">        len = syl-&gt;sy_len;</a>
<a name="ln1956">    }</a>
<a name="ln1957">    if (len != 0) {     // found a match, count syllable</a>
<a name="ln1958">      ++cnt;</a>
<a name="ln1959">      skip = false;</a>
<a name="ln1960">    } else {</a>
<a name="ln1961">      // No recognized syllable item, at least a syllable char then?</a>
<a name="ln1962">      c = utf_ptr2char(p);</a>
<a name="ln1963">      len = (*mb_ptr2len)(p);</a>
<a name="ln1964">      if (vim_strchr(slang-&gt;sl_syllable, c) == NULL)</a>
<a name="ln1965">        skip = false;               // No, search for next syllable</a>
<a name="ln1966">      else if (!skip) {</a>
<a name="ln1967">        ++cnt;                      // Yes, count it</a>
<a name="ln1968">        skip = true;                // don't count following syllable chars</a>
<a name="ln1969">      }</a>
<a name="ln1970">    }</a>
<a name="ln1971">  }</a>
<a name="ln1972">  return cnt;</a>
<a name="ln1973">}</a>
<a name="ln1974"> </a>
<a name="ln1975">// Parse 'spelllang' and set w_s-&gt;b_langp accordingly.</a>
<a name="ln1976">// Returns NULL if it's OK, an error message otherwise.</a>
<a name="ln1977">char_u *did_set_spelllang(win_T *wp)</a>
<a name="ln1978">{</a>
<a name="ln1979">  garray_T ga;</a>
<a name="ln1980">  char_u      *splp;</a>
<a name="ln1981">  char_u      *region;</a>
<a name="ln1982">  char_u region_cp[3];</a>
<a name="ln1983">  bool filename;</a>
<a name="ln1984">  int region_mask;</a>
<a name="ln1985">  slang_T     *slang;</a>
<a name="ln1986">  int c;</a>
<a name="ln1987">  char_u lang[MAXWLEN + 1];</a>
<a name="ln1988">  char_u spf_name[MAXPATHL];</a>
<a name="ln1989">  int len;</a>
<a name="ln1990">  char_u      *p;</a>
<a name="ln1991">  int round;</a>
<a name="ln1992">  char_u      *spf;</a>
<a name="ln1993">  char_u      *use_region = NULL;</a>
<a name="ln1994">  bool dont_use_region = false;</a>
<a name="ln1995">  bool nobreak = false;</a>
<a name="ln1996">  langp_T     *lp, *lp2;</a>
<a name="ln1997">  static bool recursive = false;</a>
<a name="ln1998">  char_u      *ret_msg = NULL;</a>
<a name="ln1999">  char_u      *spl_copy;</a>
<a name="ln2000"> </a>
<a name="ln2001">  bufref_T bufref;</a>
<a name="ln2002">  set_bufref(&amp;bufref, wp-&gt;w_buffer);</a>
<a name="ln2003"> </a>
<a name="ln2004">  // We don't want to do this recursively.  May happen when a language is</a>
<a name="ln2005">  // not available and the SpellFileMissing autocommand opens a new buffer</a>
<a name="ln2006">  // in which 'spell' is set.</a>
<a name="ln2007">  if (recursive)</a>
<a name="ln2008">    return NULL;</a>
<a name="ln2009">  recursive = true;</a>
<a name="ln2010"> </a>
<a name="ln2011">  ga_init(&amp;ga, sizeof(langp_T), 2);</a>
<a name="ln2012">  clear_midword(wp);</a>
<a name="ln2013"> </a>
<a name="ln2014">  // Make a copy of 'spelllang', the SpellFileMissing autocommands may change</a>
<a name="ln2015">  // it under our fingers.</a>
<a name="ln2016">  spl_copy = vim_strsave(wp-&gt;w_s-&gt;b_p_spl);</a>
<a name="ln2017"> </a>
<a name="ln2018">  wp-&gt;w_s-&gt;b_cjk = 0;</a>
<a name="ln2019"> </a>
<a name="ln2020">  // Loop over comma separated language names.</a>
<a name="ln2021">  for (splp = spl_copy; *splp != NUL; ) {</a>
<a name="ln2022">    // Get one language name.</a>
<a name="ln2023">    copy_option_part(&amp;splp, lang, MAXWLEN, &quot;,&quot;);</a>
<a name="ln2024">    region = NULL;</a>
<a name="ln2025">    len = (int)STRLEN(lang);</a>
<a name="ln2026"> </a>
<a name="ln2027">    if (!valid_spelllang(lang)) {</a>
<a name="ln2028">      continue;</a>
<a name="ln2029">    }</a>
<a name="ln2030"> </a>
<a name="ln2031">    if (STRCMP(lang, &quot;cjk&quot;) == 0) {</a>
<a name="ln2032">      wp-&gt;w_s-&gt;b_cjk = 1;</a>
<a name="ln2033">      continue;</a>
<a name="ln2034">    }</a>
<a name="ln2035"> </a>
<a name="ln2036">    // If the name ends in &quot;.spl&quot; use it as the name of the spell file.</a>
<a name="ln2037">    // If there is a region name let &quot;region&quot; point to it and remove it</a>
<a name="ln2038">    // from the name.</a>
<a name="ln2039">    if (len &gt; 4 &amp;&amp; fnamecmp(lang + len - 4, &quot;.spl&quot;) == 0) {</a>
<a name="ln2040">      filename = true;</a>
<a name="ln2041"> </a>
<a name="ln2042">      // Locate a region and remove it from the file name.</a>
<a name="ln2043">      p = vim_strchr(path_tail(lang), '_');</a>
<a name="ln2044">      if (p != NULL &amp;&amp; ASCII_ISALPHA(p[1]) &amp;&amp; ASCII_ISALPHA(p[2])</a>
<a name="ln2045">          &amp;&amp; !ASCII_ISALPHA(p[3])) {</a>
<a name="ln2046">        STRLCPY(region_cp, p + 1, 3);</a>
<a name="ln2047">        memmove(p, p + 3, len - (p - lang) - 2);</a>
<a name="ln2048">        region = region_cp;</a>
<a name="ln2049">      } else</a>
<a name="ln2050">        dont_use_region = true;</a>
<a name="ln2051"> </a>
<a name="ln2052">      // Check if we loaded this language before.</a>
<a name="ln2053">      for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2054">        if (path_full_compare(lang, slang-&gt;sl_fname, false, true)</a>
<a name="ln2055">            == kEqualFiles) {</a>
<a name="ln2056">          break;</a>
<a name="ln2057">        }</a>
<a name="ln2058">      }</a>
<a name="ln2059">    } else {</a>
<a name="ln2060">      filename = false;</a>
<a name="ln2061">      if (len &gt; 3 &amp;&amp; lang[len - 3] == '_') {</a>
<a name="ln2062">        region = lang + len - 2;</a>
<a name="ln2063">        lang[len - 3] = NUL;</a>
<a name="ln2064">      } else</a>
<a name="ln2065">        dont_use_region = true;</a>
<a name="ln2066"> </a>
<a name="ln2067">      // Check if we loaded this language before.</a>
<a name="ln2068">      for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next)</a>
<a name="ln2069">        if (STRICMP(lang, slang-&gt;sl_name) == 0)</a>
<a name="ln2070">          break;</a>
<a name="ln2071">    }</a>
<a name="ln2072"> </a>
<a name="ln2073">    if (region != NULL) {</a>
<a name="ln2074">      // If the region differs from what was used before then don't</a>
<a name="ln2075">      // use it for 'spellfile'.</a>
<a name="ln2076">      if (use_region != NULL &amp;&amp; STRCMP(region, use_region) != 0)</a>
<a name="ln2077">        dont_use_region = true;</a>
<a name="ln2078">      use_region = region;</a>
<a name="ln2079">    }</a>
<a name="ln2080"> </a>
<a name="ln2081">    // If not found try loading the language now.</a>
<a name="ln2082">    if (slang == NULL) {</a>
<a name="ln2083">      if (filename)</a>
<a name="ln2084">        (void)spell_load_file(lang, lang, NULL, false);</a>
<a name="ln2085">      else {</a>
<a name="ln2086">        spell_load_lang(lang);</a>
<a name="ln2087">        // SpellFileMissing autocommands may do anything, including</a>
<a name="ln2088">        // destroying the buffer we are using...</a>
<a name="ln2089">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2090">          ret_msg =</a>
<a name="ln2091">            (char_u *)N_(&quot;E797: SpellFileMissing autocommand deleted buffer&quot;);</a>
<a name="ln2092">          goto theend;</a>
<a name="ln2093">        }</a>
<a name="ln2094">      }</a>
<a name="ln2095">    }</a>
<a name="ln2096"> </a>
<a name="ln2097">    // Loop over the languages, there can be several files for &quot;lang&quot;.</a>
<a name="ln2098">    for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2099">      if (filename</a>
<a name="ln2100">          ? path_full_compare(lang, slang-&gt;sl_fname, false, true) == kEqualFiles</a>
<a name="ln2101">          : STRICMP(lang, slang-&gt;sl_name) == 0) {</a>
<a name="ln2102">        region_mask = REGION_ALL;</a>
<a name="ln2103">        if (!filename &amp;&amp; region != NULL) {</a>
<a name="ln2104">          // find region in sl_regions</a>
<a name="ln2105">          c = find_region(slang-&gt;sl_regions, region);</a>
<a name="ln2106">          if (c == REGION_ALL) {</a>
<a name="ln2107">            if (slang-&gt;sl_add) {</a>
<a name="ln2108">              if (*slang-&gt;sl_regions != NUL)</a>
<a name="ln2109">                // This addition file is for other regions.</a>
<a name="ln2110">                region_mask = 0;</a>
<a name="ln2111">            } else</a>
<a name="ln2112">              // This is probably an error.  Give a warning and</a>
<a name="ln2113">              // accept the words anyway.</a>
<a name="ln2114">              smsg(_(&quot;Warning: region %s not supported&quot;),</a>
<a name="ln2115">                   region);</a>
<a name="ln2116">          } else</a>
<a name="ln2117">            region_mask = 1 &lt;&lt; c;</a>
<a name="ln2118">        }</a>
<a name="ln2119"> </a>
<a name="ln2120">        if (region_mask != 0) {</a>
<a name="ln2121">          langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &amp;ga);</a>
<a name="ln2122">          p_-&gt;lp_slang = slang;</a>
<a name="ln2123">          p_-&gt;lp_region = region_mask;</a>
<a name="ln2124"> </a>
<a name="ln2125">          use_midword(slang, wp);</a>
<a name="ln2126">          if (slang-&gt;sl_nobreak)</a>
<a name="ln2127">            nobreak = true;</a>
<a name="ln2128">        }</a>
<a name="ln2129">      }</a>
<a name="ln2130">    }</a>
<a name="ln2131">  }</a>
<a name="ln2132"> </a>
<a name="ln2133">  // round 0: load int_wordlist, if possible.</a>
<a name="ln2134">  // round 1: load first name in 'spellfile'.</a>
<a name="ln2135">  // round 2: load second name in 'spellfile.</a>
<a name="ln2136">  // etc.</a>
<a name="ln2137">  spf = curwin-&gt;w_s-&gt;b_p_spf;</a>
<a name="ln2138">  for (round = 0; round == 0 || *spf != NUL; ++round) {</a>
<a name="ln2139">    if (round == 0) {</a>
<a name="ln2140">      // Internal wordlist, if there is one.</a>
<a name="ln2141">      if (int_wordlist == NULL)</a>
<a name="ln2142">        continue;</a>
<a name="ln2143">      int_wordlist_spl(spf_name);</a>
<a name="ln2144">    } else {</a>
<a name="ln2145">      // One entry in 'spellfile'.</a>
<a name="ln2146">      copy_option_part(&amp;spf, spf_name, MAXPATHL - 5, &quot;,&quot;);</a>
<a name="ln2147">      STRCAT(spf_name, &quot;.spl&quot;);</a>
<a name="ln2148"> </a>
<a name="ln2149">      // If it was already found above then skip it.</a>
<a name="ln2150">      for (c = 0; c &lt; ga.ga_len; ++c) {</a>
<a name="ln2151">        p = LANGP_ENTRY(ga, c)-&gt;lp_slang-&gt;sl_fname;</a>
<a name="ln2152">        if (p != NULL</a>
<a name="ln2153">            &amp;&amp; path_full_compare(spf_name, p, false, true) == kEqualFiles) {</a>
<a name="ln2154">          break;</a>
<a name="ln2155">        }</a>
<a name="ln2156">      }</a>
<a name="ln2157">      if (c &lt; ga.ga_len)</a>
<a name="ln2158">        continue;</a>
<a name="ln2159">    }</a>
<a name="ln2160"> </a>
<a name="ln2161">    // Check if it was loaded already.</a>
<a name="ln2162">    for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2163">      if (path_full_compare(spf_name, slang-&gt;sl_fname, false, true)</a>
<a name="ln2164">          == kEqualFiles) {</a>
<a name="ln2165">        break;</a>
<a name="ln2166">      }</a>
<a name="ln2167">    }</a>
<a name="ln2168">    if (slang == NULL) {</a>
<a name="ln2169">      // Not loaded, try loading it now.  The language name includes the</a>
<a name="ln2170">      // region name, the region is ignored otherwise.  for int_wordlist</a>
<a name="ln2171">      // use an arbitrary name.</a>
<a name="ln2172">      if (round == 0)</a>
<a name="ln2173">        STRCPY(lang, &quot;internal wordlist&quot;);</a>
<a name="ln2174">      else {</a>
<a name="ln2175">        STRLCPY(lang, path_tail(spf_name), MAXWLEN + 1);</a>
<a name="ln2176">        p = vim_strchr(lang, '.');</a>
<a name="ln2177">        if (p != NULL)</a>
<a name="ln2178">          *p = NUL;             // truncate at &quot;.encoding.add&quot;</a>
<a name="ln2179">      }</a>
<a name="ln2180">      slang = spell_load_file(spf_name, lang, NULL, true);</a>
<a name="ln2181"> </a>
<a name="ln2182">      // If one of the languages has NOBREAK we assume the addition</a>
<a name="ln2183">      // files also have this.</a>
<a name="ln2184">      if (slang != NULL &amp;&amp; nobreak)</a>
<a name="ln2185">        slang-&gt;sl_nobreak = true;</a>
<a name="ln2186">    }</a>
<a name="ln2187">    if (slang != NULL) {</a>
<a name="ln2188">      region_mask = REGION_ALL;</a>
<a name="ln2189">      if (use_region != NULL &amp;&amp; !dont_use_region) {</a>
<a name="ln2190">        // find region in sl_regions</a>
<a name="ln2191">        c = find_region(slang-&gt;sl_regions, use_region);</a>
<a name="ln2192">        if (c != REGION_ALL)</a>
<a name="ln2193">          region_mask = 1 &lt;&lt; c;</a>
<a name="ln2194">        else if (*slang-&gt;sl_regions != NUL)</a>
<a name="ln2195">          // This spell file is for other regions.</a>
<a name="ln2196">          region_mask = 0;</a>
<a name="ln2197">      }</a>
<a name="ln2198"> </a>
<a name="ln2199">      if (region_mask != 0) {</a>
<a name="ln2200">        langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &amp;ga);</a>
<a name="ln2201">        p_-&gt;lp_slang = slang;</a>
<a name="ln2202">        p_-&gt;lp_sallang = NULL;</a>
<a name="ln2203">        p_-&gt;lp_replang = NULL;</a>
<a name="ln2204">        p_-&gt;lp_region = region_mask;</a>
<a name="ln2205"> </a>
<a name="ln2206">        use_midword(slang, wp);</a>
<a name="ln2207">      }</a>
<a name="ln2208">    }</a>
<a name="ln2209">  }</a>
<a name="ln2210"> </a>
<a name="ln2211">  // Everything is fine, store the new b_langp value.</a>
<a name="ln2212">  ga_clear(&amp;wp-&gt;w_s-&gt;b_langp);</a>
<a name="ln2213">  wp-&gt;w_s-&gt;b_langp = ga;</a>
<a name="ln2214"> </a>
<a name="ln2215">  // For each language figure out what language to use for sound folding and</a>
<a name="ln2216">  // REP items.  If the language doesn't support it itself use another one</a>
<a name="ln2217">  // with the same name.  E.g. for &quot;en-math&quot; use &quot;en&quot;.</a>
<a name="ln2218">  for (int i = 0; i &lt; ga.ga_len; ++i) {</a>
<a name="ln2219">    lp = LANGP_ENTRY(ga, i);</a>
<a name="ln2220"> </a>
<a name="ln2221">    // sound folding</a>
<a name="ln2222">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal))</a>
<a name="ln2223">      // language does sound folding itself</a>
<a name="ln2224">      lp-&gt;lp_sallang = lp-&gt;lp_slang;</a>
<a name="ln2225">    else</a>
<a name="ln2226">      // find first similar language that does sound folding</a>
<a name="ln2227">      for (int j = 0; j &lt; ga.ga_len; ++j) {</a>
<a name="ln2228">        lp2 = LANGP_ENTRY(ga, j);</a>
<a name="ln2229">        if (!GA_EMPTY(&amp;lp2-&gt;lp_slang-&gt;sl_sal)</a>
<a name="ln2230">            &amp;&amp; STRNCMP(lp-&gt;lp_slang-&gt;sl_name,</a>
<a name="ln2231">                lp2-&gt;lp_slang-&gt;sl_name, 2) == 0) {</a>
<a name="ln2232">          lp-&gt;lp_sallang = lp2-&gt;lp_slang;</a>
<a name="ln2233">          break;</a>
<a name="ln2234">        }</a>
<a name="ln2235">      }</a>
<a name="ln2236"> </a>
<a name="ln2237">    // REP items</a>
<a name="ln2238">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_rep))</a>
<a name="ln2239">      // language has REP items itself</a>
<a name="ln2240">      lp-&gt;lp_replang = lp-&gt;lp_slang;</a>
<a name="ln2241">    else</a>
<a name="ln2242">      // find first similar language that has REP items</a>
<a name="ln2243">      for (int j = 0; j &lt; ga.ga_len; ++j) {</a>
<a name="ln2244">        lp2 = LANGP_ENTRY(ga, j);</a>
<a name="ln2245">        if (!GA_EMPTY(&amp;lp2-&gt;lp_slang-&gt;sl_rep)</a>
<a name="ln2246">            &amp;&amp; STRNCMP(lp-&gt;lp_slang-&gt;sl_name,</a>
<a name="ln2247">                lp2-&gt;lp_slang-&gt;sl_name, 2) == 0) {</a>
<a name="ln2248">          lp-&gt;lp_replang = lp2-&gt;lp_slang;</a>
<a name="ln2249">          break;</a>
<a name="ln2250">        }</a>
<a name="ln2251">      }</a>
<a name="ln2252">  }</a>
<a name="ln2253"> </a>
<a name="ln2254">theend:</a>
<a name="ln2255">  xfree(spl_copy);</a>
<a name="ln2256">  recursive = false;</a>
<a name="ln2257">  redraw_later(wp, NOT_VALID);</a>
<a name="ln2258">  return ret_msg;</a>
<a name="ln2259">}</a>
<a name="ln2260"> </a>
<a name="ln2261">// Clear the midword characters for buffer &quot;buf&quot;.</a>
<a name="ln2262">static void clear_midword(win_T *wp)</a>
<a name="ln2263">{</a>
<a name="ln2264">  memset(wp-&gt;w_s-&gt;b_spell_ismw, 0, 256);</a>
<a name="ln2265">  XFREE_CLEAR(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2266">}</a>
<a name="ln2267"> </a>
<a name="ln2268">// Use the &quot;sl_midword&quot; field of language &quot;lp&quot; for buffer &quot;buf&quot;.</a>
<a name="ln2269">// They add up to any currently used midword characters.</a>
<a name="ln2270">static void use_midword(slang_T *lp, win_T *wp)</a>
<a name="ln2271">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2272">{</a>
<a name="ln2273">  if (lp-&gt;sl_midword == NULL) {  // there aren't any</a>
<a name="ln2274">    return;</a>
<a name="ln2275">  }</a>
<a name="ln2276"> </a>
<a name="ln2277">  for (char_u *p = lp-&gt;sl_midword; *p != NUL; ) {</a>
<a name="ln2278">    const int c = utf_ptr2char(p);</a>
<a name="ln2279">    const int l = utfc_ptr2len(p);</a>
<a name="ln2280">    if (c &lt; 256 &amp;&amp; l &lt;= 2) {</a>
<a name="ln2281">      wp-&gt;w_s-&gt;b_spell_ismw[c] = true;</a>
<a name="ln2282">    } else if (wp-&gt;w_s-&gt;b_spell_ismw_mb == NULL) {</a>
<a name="ln2283">      // First multi-byte char in &quot;b_spell_ismw_mb&quot;.</a>
<a name="ln2284">      wp-&gt;w_s-&gt;b_spell_ismw_mb = vim_strnsave(p, l);</a>
<a name="ln2285">    } else {</a>
<a name="ln2286">      // Append multi-byte chars to &quot;b_spell_ismw_mb&quot;.</a>
<a name="ln2287">      const int n = (int)STRLEN(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2288">      char_u *bp = vim_strnsave(wp-&gt;w_s-&gt;b_spell_ismw_mb, n + l);</a>
<a name="ln2289">      xfree(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2290">      wp-&gt;w_s-&gt;b_spell_ismw_mb = bp;</a>
<a name="ln2291">      STRLCPY(bp + n, p, l + 1);</a>
<a name="ln2292">    }</a>
<a name="ln2293">    p += l;</a>
<a name="ln2294">  }</a>
<a name="ln2295">}</a>
<a name="ln2296"> </a>
<a name="ln2297">// Find the region &quot;region[2]&quot; in &quot;rp&quot; (points to &quot;sl_regions&quot;).</a>
<a name="ln2298">// Each region is simply stored as the two characters of its name.</a>
<a name="ln2299">// Returns the index if found (first is 0), REGION_ALL if not found.</a>
<a name="ln2300">static int find_region(char_u *rp, char_u *region)</a>
<a name="ln2301">{</a>
<a name="ln2302">  int i;</a>
<a name="ln2303"> </a>
<a name="ln2304">  for (i = 0;; i += 2) {</a>
<a name="ln2305">    if (rp[i] == NUL)</a>
<a name="ln2306">      return REGION_ALL;</a>
<a name="ln2307">    if (rp[i] == region[0] &amp;&amp; rp[i + 1] == region[1])</a>
<a name="ln2308">      break;</a>
<a name="ln2309">  }</a>
<a name="ln2310">  return i / 2;</a>
<a name="ln2311">}</a>
<a name="ln2312"> </a>
<a name="ln2313">/// Return case type of word:</a>
<a name="ln2314">/// w word       0</a>
<a name="ln2315">/// Word         WF_ONECAP</a>
<a name="ln2316">/// W WORD       WF_ALLCAP</a>
<a name="ln2317">/// WoRd wOrd    WF_KEEPCAP</a>
<a name="ln2318">///</a>
<a name="ln2319">/// @param[in]  word</a>
<a name="ln2320">/// @param[in]  end  End of word or NULL for NUL delimited string</a>
<a name="ln2321">///</a>
<a name="ln2322">/// @returns  Case type of word</a>
<a name="ln2323">int captype(char_u *word, char_u *end)</a>
<a name="ln2324">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2325">{</a>
<a name="ln2326">  char_u      *p;</a>
<a name="ln2327">  int firstcap;</a>
<a name="ln2328">  bool allcap;</a>
<a name="ln2329">  bool past_second = false;              // past second word char</a>
<a name="ln2330"> </a>
<a name="ln2331">  // find first letter</a>
<a name="ln2332">  for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p)) {</a>
<a name="ln2333">    if (end == NULL ? *p == NUL : p &gt;= end) {</a>
<a name="ln2334">      return 0;             // only non-word characters, illegal word</a>
<a name="ln2335">    }</a>
<a name="ln2336">  }</a>
<a name="ln2337">  int c = mb_ptr2char_adv((const char_u **)&amp;p);</a>
<a name="ln2338">  firstcap = allcap = SPELL_ISUPPER(c);</a>
<a name="ln2339"> </a>
<a name="ln2340">  // Need to check all letters to find a word with mixed upper/lower.</a>
<a name="ln2341">  // But a word with an upper char only at start is a ONECAP.</a>
<a name="ln2342">  for (; end == NULL ? *p != NUL : p &lt; end; MB_PTR_ADV(p)) {</a>
<a name="ln2343">    if (spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2344">      c = PTR2CHAR(p);</a>
<a name="ln2345">      if (!SPELL_ISUPPER(c)) {</a>
<a name="ln2346">        // UUl -&gt; KEEPCAP</a>
<a name="ln2347">        if (past_second &amp;&amp; allcap) {</a>
<a name="ln2348">          return WF_KEEPCAP;</a>
<a name="ln2349">        }</a>
<a name="ln2350">        allcap = false;</a>
<a name="ln2351">      } else if (!allcap) {</a>
<a name="ln2352">        // UlU -&gt; KEEPCAP</a>
<a name="ln2353">        return WF_KEEPCAP;</a>
<a name="ln2354">      }</a>
<a name="ln2355">      past_second = true;</a>
<a name="ln2356">    }</a>
<a name="ln2357">  }</a>
<a name="ln2358"> </a>
<a name="ln2359">  if (allcap)</a>
<a name="ln2360">    return WF_ALLCAP;</a>
<a name="ln2361">  if (firstcap)</a>
<a name="ln2362">    return WF_ONECAP;</a>
<a name="ln2363">  return 0;</a>
<a name="ln2364">}</a>
<a name="ln2365"> </a>
<a name="ln2366">// Like captype() but for a KEEPCAP word add ONECAP if the word starts with a</a>
<a name="ln2367">// capital.  So that make_case_word() can turn WOrd into Word.</a>
<a name="ln2368">// Add ALLCAP for &quot;WOrD&quot;.</a>
<a name="ln2369">static int badword_captype(char_u *word, char_u *end)</a>
<a name="ln2370">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2371">{</a>
<a name="ln2372">  int flags = captype(word, end);</a>
<a name="ln2373">  int c;</a>
<a name="ln2374">  int l, u;</a>
<a name="ln2375">  bool first;</a>
<a name="ln2376">  char_u      *p;</a>
<a name="ln2377"> </a>
<a name="ln2378">  if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln2379">    // Count the number of UPPER and lower case letters.</a>
<a name="ln2380">    l = u = 0;</a>
<a name="ln2381">    first = false;</a>
<a name="ln2382">    for (p = word; p &lt; end; MB_PTR_ADV(p)) {</a>
<a name="ln2383">      c = PTR2CHAR(p);</a>
<a name="ln2384">      if (SPELL_ISUPPER(c)) {</a>
<a name="ln2385">        ++u;</a>
<a name="ln2386">        if (p == word)</a>
<a name="ln2387">          first = true;</a>
<a name="ln2388">      } else</a>
<a name="ln2389">        ++l;</a>
<a name="ln2390">    }</a>
<a name="ln2391"> </a>
<a name="ln2392">    // If there are more UPPER than lower case letters suggest an</a>
<a name="ln2393">    // ALLCAP word.  Otherwise, if the first letter is UPPER then</a>
<a name="ln2394">    // suggest ONECAP.  Exception: &quot;ALl&quot; most likely should be &quot;All&quot;,</a>
<a name="ln2395">    // require three upper case letters.</a>
<a name="ln2396">    if (u &gt; l &amp;&amp; u &gt; 2)</a>
<a name="ln2397">      flags |= WF_ALLCAP;</a>
<a name="ln2398">    else if (first)</a>
<a name="ln2399">      flags |= WF_ONECAP;</a>
<a name="ln2400"> </a>
<a name="ln2401">    if (u &gt;= 2 &amp;&amp; l &gt;= 2)       // maCARONI maCAroni</a>
<a name="ln2402">      flags |= WF_MIXCAP;</a>
<a name="ln2403">  }</a>
<a name="ln2404">  return flags;</a>
<a name="ln2405">}</a>
<a name="ln2406"> </a>
<a name="ln2407">// Delete the internal wordlist and its .spl file.</a>
<a name="ln2408">void spell_delete_wordlist(void)</a>
<a name="ln2409">{</a>
<a name="ln2410">  char_u fname[MAXPATHL] = {0};</a>
<a name="ln2411"> </a>
<a name="ln2412">  if (int_wordlist != NULL) {</a>
<a name="ln2413">    os_remove((char *)int_wordlist);</a>
<a name="ln2414">    int_wordlist_spl(fname);</a>
<a name="ln2415">    os_remove((char *)fname);</a>
<a name="ln2416">    XFREE_CLEAR(int_wordlist);</a>
<a name="ln2417">  }</a>
<a name="ln2418">}</a>
<a name="ln2419"> </a>
<a name="ln2420">// Free all languages.</a>
<a name="ln2421">void spell_free_all(void)</a>
<a name="ln2422">{</a>
<a name="ln2423">  slang_T     *slang;</a>
<a name="ln2424"> </a>
<a name="ln2425">  // Go through all buffers and handle 'spelllang'. &lt;VN&gt;</a>
<a name="ln2426">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2427">    ga_clear(&amp;buf-&gt;b_s.b_langp);</a>
<a name="ln2428">  }</a>
<a name="ln2429"> </a>
<a name="ln2430">  while (first_lang != NULL) {</a>
<a name="ln2431">    slang = first_lang;</a>
<a name="ln2432">    first_lang = slang-&gt;sl_next;</a>
<a name="ln2433">    slang_free(slang);</a>
<a name="ln2434">  }</a>
<a name="ln2435"> </a>
<a name="ln2436">  spell_delete_wordlist();</a>
<a name="ln2437"> </a>
<a name="ln2438">  XFREE_CLEAR(repl_to);</a>
<a name="ln2439">  XFREE_CLEAR(repl_from);</a>
<a name="ln2440">}</a>
<a name="ln2441"> </a>
<a name="ln2442">// Clear all spelling tables and reload them.</a>
<a name="ln2443">// Used after 'encoding' is set and when &quot;:mkspell&quot; was used.</a>
<a name="ln2444">void spell_reload(void)</a>
<a name="ln2445">{</a>
<a name="ln2446">  // Initialize the table for spell_iswordp().</a>
<a name="ln2447">  init_spell_chartab();</a>
<a name="ln2448"> </a>
<a name="ln2449">  // Unload all allocated memory.</a>
<a name="ln2450">  spell_free_all();</a>
<a name="ln2451"> </a>
<a name="ln2452">  // Go through all buffers and handle 'spelllang'.</a>
<a name="ln2453">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln2454">    // Only load the wordlists when 'spelllang' is set and there is a</a>
<a name="ln2455">    // window for this buffer in which 'spell' is set.</a>
<a name="ln2456">    if (*wp-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln2457">      if (wp-&gt;w_p_spell) {</a>
<a name="ln2458">        (void)did_set_spelllang(wp);</a>
<a name="ln2459">        break;</a>
<a name="ln2460">      }</a>
<a name="ln2461">    }</a>
<a name="ln2462">  }</a>
<a name="ln2463">}</a>
<a name="ln2464"> </a>
<a name="ln2465"> </a>
<a name="ln2466">// Opposite of offset2bytes().</a>
<a name="ln2467">// &quot;pp&quot; points to the bytes and is advanced over it.</a>
<a name="ln2468">// Returns the offset.</a>
<a name="ln2469">static int bytes2offset(char_u **pp)</a>
<a name="ln2470">{</a>
<a name="ln2471">  char_u *p = *pp;</a>
<a name="ln2472">  int nr;</a>
<a name="ln2473">  int c;</a>
<a name="ln2474"> </a>
<a name="ln2475">  c = *p++;</a>
<a name="ln2476">  if ((c &amp; 0x80) == 0x00) {             // 1 byte</a>
<a name="ln2477">    nr = c - 1;</a>
<a name="ln2478">  } else if ((c &amp; 0xc0) == 0x80)   {    // 2 bytes</a>
<a name="ln2479">    nr = (c &amp; 0x3f) - 1;</a>
<a name="ln2480">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2481">  } else if ((c &amp; 0xe0) == 0xc0)   {    // 3 bytes</a>
<a name="ln2482">    nr = (c &amp; 0x1f) - 1;</a>
<a name="ln2483">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2484">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2485">  } else {                              // 4 bytes</a>
<a name="ln2486">    nr = (c &amp; 0x0f) - 1;</a>
<a name="ln2487">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2488">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2489">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2490">  }</a>
<a name="ln2491"> </a>
<a name="ln2492">  *pp = p;</a>
<a name="ln2493">  return nr;</a>
<a name="ln2494">}</a>
<a name="ln2495"> </a>
<a name="ln2496">// Open a spell buffer.  This is a nameless buffer that is not in the buffer</a>
<a name="ln2497">// list and only contains text lines.  Can use a swapfile to reduce memory</a>
<a name="ln2498">// use.</a>
<a name="ln2499">// Most other fields are invalid!  Esp. watch out for string options being</a>
<a name="ln2500">// NULL and there is no undo info.</a>
<a name="ln2501">buf_T *open_spellbuf(void)</a>
<a name="ln2502">{</a>
<a name="ln2503">  buf_T *buf = xcalloc(1, sizeof(buf_T));</a>
<a name="ln2504"> </a>
<a name="ln2505">  buf-&gt;b_spell = true;</a>
<a name="ln2506">  buf-&gt;b_p_swf = true;        // may create a swap file</a>
<a name="ln2507">  if (ml_open(buf) == FAIL) {</a>
<a name="ln2508">    ELOG(&quot;Error opening a new memline&quot;);</a>
<a name="ln2509">  }</a>
<a name="ln2510">  ml_open_file(buf);          // create swap file now</a>
<a name="ln2511"> </a>
<a name="ln2512">  return buf;</a>
<a name="ln2513">}</a>
<a name="ln2514"> </a>
<a name="ln2515">// Close the buffer used for spell info.</a>
<a name="ln2516">void close_spellbuf(buf_T *buf)</a>
<a name="ln2517">{</a>
<a name="ln2518">  if (buf != NULL) {</a>
<a name="ln2519">    ml_close(buf, TRUE);</a>
<a name="ln2520">    xfree(buf);</a>
<a name="ln2521">  }</a>
<a name="ln2522">}</a>
<a name="ln2523"> </a>
<a name="ln2524">// Init the chartab used for spelling for ASCII.</a>
<a name="ln2525">void clear_spell_chartab(spelltab_T *sp)</a>
<a name="ln2526">{</a>
<a name="ln2527">  int i;</a>
<a name="ln2528"> </a>
<a name="ln2529">  // Init everything to false.</a>
<a name="ln2530">  memset(sp-&gt;st_isw, false, sizeof(sp-&gt;st_isw));</a>
<a name="ln2531">  memset(sp-&gt;st_isu, false, sizeof(sp-&gt;st_isu));</a>
<a name="ln2532"> </a>
<a name="ln2533">  for (i = 0; i &lt; 256; ++i) {</a>
<a name="ln2534">    sp-&gt;st_fold[i] = i;</a>
<a name="ln2535">    sp-&gt;st_upper[i] = i;</a>
<a name="ln2536">  }</a>
<a name="ln2537"> </a>
<a name="ln2538">  // We include digits. A word shouldn't start with a digit, but handling</a>
<a name="ln2539">  // that is done separately.</a>
<a name="ln2540">  for (i = '0'; i &lt;= '9'; ++i)</a>
<a name="ln2541">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2542">  for (i = 'A'; i &lt;= 'Z'; ++i) {</a>
<a name="ln2543">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2544">    sp-&gt;st_isu[i] = true;</a>
<a name="ln2545">    sp-&gt;st_fold[i] = i + 0x20;</a>
<a name="ln2546">  }</a>
<a name="ln2547">  for (i = 'a'; i &lt;= 'z'; ++i) {</a>
<a name="ln2548">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2549">    sp-&gt;st_upper[i] = i - 0x20;</a>
<a name="ln2550">  }</a>
<a name="ln2551">}</a>
<a name="ln2552"> </a>
<a name="ln2553">// Init the chartab used for spelling. Called once while starting up.</a>
<a name="ln2554">// The default is to use isalpha(), but the spell file should define the word</a>
<a name="ln2555">// characters to make it possible that 'encoding' differs from the current</a>
<a name="ln2556">// locale.  For utf-8 we don't use isalpha() but our own functions.</a>
<a name="ln2557">void init_spell_chartab(void)</a>
<a name="ln2558">{</a>
<a name="ln2559">  int i;</a>
<a name="ln2560"> </a>
<a name="ln2561">  did_set_spelltab = false;</a>
<a name="ln2562">  clear_spell_chartab(&amp;spelltab);</a>
<a name="ln2563">  for (i = 128; i &lt; 256; i++) {</a>
<a name="ln2564">    int f = utf_fold(i);</a>
<a name="ln2565">    int u = mb_toupper(i);</a>
<a name="ln2566"> </a>
<a name="ln2567">    spelltab.st_isu[i] = mb_isupper(i);</a>
<a name="ln2568">    spelltab.st_isw[i] = spelltab.st_isu[i] || mb_islower(i);</a>
<a name="ln2569">    // The folded/upper-cased value is different between latin1 and</a>
<a name="ln2570">    // utf8 for 0xb5, causing E763 for no good reason.  Use the latin1</a>
<a name="ln2571">    // value for utf-8 to avoid this.</a>
<a name="ln2572">    spelltab.st_fold[i] = (f &lt; 256) ? f : i;</a>
<a name="ln2573">    spelltab.st_upper[i] = (u &lt; 256) ? u : i;</a>
<a name="ln2574">  }</a>
<a name="ln2575">}</a>
<a name="ln2576"> </a>
<a name="ln2577">/// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2578">/// As a special case we see &quot;midword&quot; characters as word character when it is</a>
<a name="ln2579">/// followed by a word character.  This finds they'there but not 'they there'.</a>
<a name="ln2580">/// Thus this only works properly when past the first character of the word.</a>
<a name="ln2581">///</a>
<a name="ln2582">/// @param wp Buffer used.</a>
<a name="ln2583">static bool spell_iswordp(const char_u *p, const win_T *wp)</a>
<a name="ln2584">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2585">{</a>
<a name="ln2586">  int c;</a>
<a name="ln2587"> </a>
<a name="ln2588">  const int l = utfc_ptr2len(p);</a>
<a name="ln2589">  const char_u *s = p;</a>
<a name="ln2590">  if (l == 1) {</a>
<a name="ln2591">    // be quick for ASCII</a>
<a name="ln2592">    if (wp-&gt;w_s-&gt;b_spell_ismw[*p]) {</a>
<a name="ln2593">      s = p + 1;                      // skip a mid-word character</a>
<a name="ln2594">    }</a>
<a name="ln2595">  } else {</a>
<a name="ln2596">    c = utf_ptr2char(p);</a>
<a name="ln2597">    if (c &lt; 256</a>
<a name="ln2598">        ? wp-&gt;w_s-&gt;b_spell_ismw[c]</a>
<a name="ln2599">        : (wp-&gt;w_s-&gt;b_spell_ismw_mb != NULL</a>
<a name="ln2600">           &amp;&amp; vim_strchr(wp-&gt;w_s-&gt;b_spell_ismw_mb, c) != NULL)) {</a>
<a name="ln2601">      s = p + l;</a>
<a name="ln2602">    }</a>
<a name="ln2603">  }</a>
<a name="ln2604"> </a>
<a name="ln2605">  c = utf_ptr2char(s);</a>
<a name="ln2606">  if (c &gt; 255) {</a>
<a name="ln2607">    return spell_mb_isword_class(mb_get_class(s), wp);</a>
<a name="ln2608">  }</a>
<a name="ln2609">  return spelltab.st_isw[c];</a>
<a name="ln2610">}</a>
<a name="ln2611"> </a>
<a name="ln2612">// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2613">// Unlike spell_iswordp() this doesn't check for &quot;midword&quot; characters.</a>
<a name="ln2614">bool spell_iswordp_nmw(const char_u *p, win_T *wp)</a>
<a name="ln2615">{</a>
<a name="ln2616">  int c = utf_ptr2char(p);</a>
<a name="ln2617">  if (c &gt; 255) {</a>
<a name="ln2618">    return spell_mb_isword_class(mb_get_class(p), wp);</a>
<a name="ln2619">  }</a>
<a name="ln2620">  return spelltab.st_isw[c];</a>
<a name="ln2621">}</a>
<a name="ln2622"> </a>
<a name="ln2623">// Returns true if word class indicates a word character.</a>
<a name="ln2624">// Only for characters above 255.</a>
<a name="ln2625">// Unicode subscript and superscript are not considered word characters.</a>
<a name="ln2626">// See also utf_class() in mbyte.c.</a>
<a name="ln2627">static bool spell_mb_isword_class(int cl, const win_T *wp)</a>
<a name="ln2628">  FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2629">{</a>
<a name="ln2630">  if (wp-&gt;w_s-&gt;b_cjk)</a>
<a name="ln2631">    // East Asian characters are not considered word characters.</a>
<a name="ln2632">    return cl == 2 || cl == 0x2800;</a>
<a name="ln2633">  return cl &gt;= 2 &amp;&amp; cl != 0x2070 &amp;&amp; cl != 0x2080 &amp;&amp; cl != 3;</a>
<a name="ln2634">}</a>
<a name="ln2635"> </a>
<a name="ln2636">// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2637">// Wide version of spell_iswordp().</a>
<a name="ln2638">static bool spell_iswordp_w(const int *p, const win_T *wp)</a>
<a name="ln2639">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2640">{</a>
<a name="ln2641">  const int *s;</a>
<a name="ln2642"> </a>
<a name="ln2643">  if (*p &lt; 256 ? wp-&gt;w_s-&gt;b_spell_ismw[*p]</a>
<a name="ln2644">      : (wp-&gt;w_s-&gt;b_spell_ismw_mb != NULL</a>
<a name="ln2645">         &amp;&amp; vim_strchr(wp-&gt;w_s-&gt;b_spell_ismw_mb, *p) != NULL))</a>
<a name="ln2646">    s = p + 1;</a>
<a name="ln2647">  else</a>
<a name="ln2648">    s = p;</a>
<a name="ln2649"> </a>
<a name="ln2650">  if (*s &gt; 255) {</a>
<a name="ln2651">    return spell_mb_isword_class(utf_class(*s), wp);</a>
<a name="ln2652">  }</a>
<a name="ln2653">  return spelltab.st_isw[*s];</a>
<a name="ln2654">}</a>
<a name="ln2655"> </a>
<a name="ln2656">// Case-fold &quot;str[len]&quot; into &quot;buf[buflen]&quot;.  The result is NUL terminated.</a>
<a name="ln2657">// Uses the character definitions from the .spl file.</a>
<a name="ln2658">// When using a multi-byte 'encoding' the length may change!</a>
<a name="ln2659">// Returns FAIL when something wrong.</a>
<a name="ln2660">int spell_casefold(const win_T *wp, char_u *str, int len, char_u *buf,</a>
<a name="ln2661">                   int buflen)</a>
<a name="ln2662">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2663">{</a>
<a name="ln2664">  if (len &gt;= buflen) {</a>
<a name="ln2665">    buf[0] = NUL;</a>
<a name="ln2666">    return FAIL;                // result will not fit</a>
<a name="ln2667">  }</a>
<a name="ln2668"> </a>
<a name="ln2669">  int outi = 0;</a>
<a name="ln2670"> </a>
<a name="ln2671">  // Fold one character at a time.</a>
<a name="ln2672">  for (char_u *p = str; p &lt; str + len; ) {</a>
<a name="ln2673">    if (outi + MB_MAXBYTES &gt; buflen) {</a>
<a name="ln2674">      buf[outi] = NUL;</a>
<a name="ln2675">      return FAIL;</a>
<a name="ln2676">    }</a>
<a name="ln2677">    int c = mb_cptr2char_adv((const char_u **)&amp;p);</a>
<a name="ln2678"> </a>
<a name="ln2679">    // Exception: greek capital sigma 0x03A3 folds to 0x03C3, except</a>
<a name="ln2680">    // when it is the last character in a word, then it folds to</a>
<a name="ln2681">    // 0x03C2.</a>
<a name="ln2682">    if (c == 0x03a3 || c == 0x03c2) {</a>
<a name="ln2683">      if (p == str + len || !spell_iswordp(p, wp)) {</a>
<a name="ln2684">        c = 0x03c2;</a>
<a name="ln2685">      } else {</a>
<a name="ln2686">        c = 0x03c3;</a>
<a name="ln2687">      }</a>
<a name="ln2688">    } else {</a>
<a name="ln2689">      c = SPELL_TOFOLD(c);</a>
<a name="ln2690">    }</a>
<a name="ln2691"> </a>
<a name="ln2692">    outi += utf_char2bytes(c, buf + outi);</a>
<a name="ln2693">  }</a>
<a name="ln2694">  buf[outi] = NUL;</a>
<a name="ln2695"> </a>
<a name="ln2696">  return OK;</a>
<a name="ln2697">}</a>
<a name="ln2698"> </a>
<a name="ln2699">// values for sps_flags</a>
<a name="ln2700">#define SPS_BEST    1</a>
<a name="ln2701">#define SPS_FAST    2</a>
<a name="ln2702">#define SPS_DOUBLE  4</a>
<a name="ln2703"> </a>
<a name="ln2704">static int sps_flags = SPS_BEST;        // flags from 'spellsuggest'</a>
<a name="ln2705">static int sps_limit = 9999;            // max nr of suggestions given</a>
<a name="ln2706"> </a>
<a name="ln2707">// Check the 'spellsuggest' option.  Return FAIL if it's wrong.</a>
<a name="ln2708">// Sets &quot;sps_flags&quot; and &quot;sps_limit&quot;.</a>
<a name="ln2709">int spell_check_sps(void)</a>
<a name="ln2710">{</a>
<a name="ln2711">  char_u      *p;</a>
<a name="ln2712">  char_u      *s;</a>
<a name="ln2713">  char_u buf[MAXPATHL];</a>
<a name="ln2714">  int f;</a>
<a name="ln2715"> </a>
<a name="ln2716">  sps_flags = 0;</a>
<a name="ln2717">  sps_limit = 9999;</a>
<a name="ln2718"> </a>
<a name="ln2719">  for (p = p_sps; *p != NUL; ) {</a>
<a name="ln2720">    copy_option_part(&amp;p, buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln2721"> </a>
<a name="ln2722">    f = 0;</a>
<a name="ln2723">    if (ascii_isdigit(*buf)) {</a>
<a name="ln2724">      s = buf;</a>
<a name="ln2725">      sps_limit = getdigits_int(&amp;s, true, 0);</a>
<a name="ln2726">      if (*s != NUL &amp;&amp; !ascii_isdigit(*s)) {</a>
<a name="ln2727">        f = -1;</a>
<a name="ln2728">      }</a>
<a name="ln2729">    } else if (STRCMP(buf, &quot;best&quot;) == 0) {</a>
<a name="ln2730">      f = SPS_BEST;</a>
<a name="ln2731">    } else if (STRCMP(buf, &quot;fast&quot;) == 0) {</a>
<a name="ln2732">      f = SPS_FAST;</a>
<a name="ln2733">    } else if (STRCMP(buf, &quot;double&quot;) == 0) {</a>
<a name="ln2734">      f = SPS_DOUBLE;</a>
<a name="ln2735">    } else if (STRNCMP(buf, &quot;expr:&quot;, 5) != 0</a>
<a name="ln2736">               &amp;&amp; STRNCMP(buf, &quot;file:&quot;, 5) != 0) {</a>
<a name="ln2737">      f = -1;</a>
<a name="ln2738">    }</a>
<a name="ln2739"> </a>
<a name="ln2740">    if (f == -1 || (sps_flags != 0 &amp;&amp; f != 0)) {</a>
<a name="ln2741">      sps_flags = SPS_BEST;</a>
<a name="ln2742">      sps_limit = 9999;</a>
<a name="ln2743">      return FAIL;</a>
<a name="ln2744">    }</a>
<a name="ln2745">    if (f != 0)</a>
<a name="ln2746">      sps_flags = f;</a>
<a name="ln2747">  }</a>
<a name="ln2748"> </a>
<a name="ln2749">  if (sps_flags == 0)</a>
<a name="ln2750">    sps_flags = SPS_BEST;</a>
<a name="ln2751"> </a>
<a name="ln2752">  return OK;</a>
<a name="ln2753">}</a>
<a name="ln2754"> </a>
<a name="ln2755">// &quot;z=&quot;: Find badly spelled word under or after the cursor.</a>
<a name="ln2756">// Give suggestions for the properly spelled word.</a>
<a name="ln2757">// In Visual mode use the highlighted word as the bad word.</a>
<a name="ln2758">// When &quot;count&quot; is non-zero use that suggestion.</a>
<a name="ln2759">void spell_suggest(int count)</a>
<a name="ln2760">{</a>
<a name="ln2761">  char_u      *line;</a>
<a name="ln2762">  pos_T prev_cursor = curwin-&gt;w_cursor;</a>
<a name="ln2763">  char_u wcopy[MAXWLEN + 2];</a>
<a name="ln2764">  char_u      *p;</a>
<a name="ln2765">  int c;</a>
<a name="ln2766">  suginfo_T sug;</a>
<a name="ln2767">  suggest_T   *stp;</a>
<a name="ln2768">  int mouse_used;</a>
<a name="ln2769">  int need_cap;</a>
<a name="ln2770">  int limit;</a>
<a name="ln2771">  int selected = count;</a>
<a name="ln2772">  int badlen = 0;</a>
<a name="ln2773">  int msg_scroll_save = msg_scroll;</a>
<a name="ln2774">  const int wo_spell_save = curwin-&gt;w_p_spell;</a>
<a name="ln2775"> </a>
<a name="ln2776">  if (!curwin-&gt;w_p_spell) {</a>
<a name="ln2777">    did_set_spelllang(curwin);</a>
<a name="ln2778">    curwin-&gt;w_p_spell = true;</a>
<a name="ln2779">  }</a>
<a name="ln2780"> </a>
<a name="ln2781">  if (*curwin-&gt;w_s-&gt;b_p_spl == NUL) {</a>
<a name="ln2782">    EMSG(_(e_no_spell));</a>
<a name="ln2783">    return;</a>
<a name="ln2784">  }</a>
<a name="ln2785"> </a>
<a name="ln2786">  if (VIsual_active) {</a>
<a name="ln2787">    // Use the Visually selected text as the bad word.  But reject</a>
<a name="ln2788">    // a multi-line selection.</a>
<a name="ln2789">    if (curwin-&gt;w_cursor.lnum != VIsual.lnum) {</a>
<a name="ln2790">      vim_beep(BO_SPELL);</a>
<a name="ln2791">      return;</a>
<a name="ln2792">    }</a>
<a name="ln2793">    badlen = (int)curwin-&gt;w_cursor.col - (int)VIsual.col;</a>
<a name="ln2794">    if (badlen &lt; 0) {</a>
<a name="ln2795">      badlen = -badlen;</a>
<a name="ln2796">    } else {</a>
<a name="ln2797">      curwin-&gt;w_cursor.col = VIsual.col;</a>
<a name="ln2798">    }</a>
<a name="ln2799">    badlen++;</a>
<a name="ln2800">    end_visual_mode();</a>
<a name="ln2801">  } else</a>
<a name="ln2802">  // Find the start of the badly spelled word.</a>
<a name="ln2803">  if (spell_move_to(curwin, FORWARD, true, true, NULL) == 0</a>
<a name="ln2804">      || curwin-&gt;w_cursor.col &gt; prev_cursor.col) {</a>
<a name="ln2805">    // No bad word or it starts after the cursor: use the word under the</a>
<a name="ln2806">    // cursor.</a>
<a name="ln2807">    curwin-&gt;w_cursor = prev_cursor;</a>
<a name="ln2808">    line = get_cursor_line_ptr();</a>
<a name="ln2809">    p = line + curwin-&gt;w_cursor.col;</a>
<a name="ln2810">    // Backup to before start of word.</a>
<a name="ln2811">    while (p &gt; line &amp;&amp; spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2812">      MB_PTR_BACK(line, p);</a>
<a name="ln2813">    }</a>
<a name="ln2814">    // Forward to start of word.</a>
<a name="ln2815">    while (*p != NUL &amp;&amp; !spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2816">      MB_PTR_ADV(p);</a>
<a name="ln2817">    }</a>
<a name="ln2818"> </a>
<a name="ln2819">    if (!spell_iswordp_nmw(p, curwin)) {                // No word found.</a>
<a name="ln2820">      beep_flush();</a>
<a name="ln2821">      return;</a>
<a name="ln2822">    }</a>
<a name="ln2823">    curwin-&gt;w_cursor.col = (colnr_T)(p - line);</a>
<a name="ln2824">  }</a>
<a name="ln2825"> </a>
<a name="ln2826">  // Get the word and its length.</a>
<a name="ln2827"> </a>
<a name="ln2828">  // Figure out if the word should be capitalised.</a>
<a name="ln2829">  need_cap = check_need_cap(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col);</a>
<a name="ln2830"> </a>
<a name="ln2831">  // Make a copy of current line since autocommands may free the line.</a>
<a name="ln2832">  line = vim_strsave(get_cursor_line_ptr());</a>
<a name="ln2833"> </a>
<a name="ln2834">  // Get the list of suggestions.  Limit to 'lines' - 2 or the number in</a>
<a name="ln2835">  // 'spellsuggest', whatever is smaller.</a>
<a name="ln2836">  if (sps_limit &gt; (int)Rows - 2)</a>
<a name="ln2837">    limit = (int)Rows - 2;</a>
<a name="ln2838">  else</a>
<a name="ln2839">    limit = sps_limit;</a>
<a name="ln2840">  spell_find_suggest(line + curwin-&gt;w_cursor.col, badlen, &amp;sug, limit,</a>
<a name="ln2841">      true, need_cap, true);</a>
<a name="ln2842"> </a>
<a name="ln2843">  if (GA_EMPTY(&amp;sug.su_ga))</a>
<a name="ln2844">    MSG(_(&quot;Sorry, no suggestions&quot;));</a>
<a name="ln2845">  else if (count &gt; 0) {</a>
<a name="ln2846">    if (count &gt; sug.su_ga.ga_len)</a>
<a name="ln2847">      smsg(_(&quot;Sorry, only %&quot; PRId64 &quot; suggestions&quot;),</a>
<a name="ln2848">           (int64_t)sug.su_ga.ga_len);</a>
<a name="ln2849">  } else {</a>
<a name="ln2850">    // When 'rightleft' is set the list is drawn right-left.</a>
<a name="ln2851">    cmdmsg_rl = curwin-&gt;w_p_rl;</a>
<a name="ln2852">    if (cmdmsg_rl)</a>
<a name="ln2853">      msg_col = Columns - 1;</a>
<a name="ln2854"> </a>
<a name="ln2855">    // List the suggestions.</a>
<a name="ln2856">    msg_start();</a>
<a name="ln2857">    msg_row = Rows - 1;         // for when 'cmdheight' &gt; 1</a>
<a name="ln2858">    lines_left = Rows;          // avoid more prompt</a>
<a name="ln2859">    vim_snprintf((char *)IObuff, IOSIZE, _(&quot;Change \&quot;%.*s\&quot; to:&quot;),</a>
<a name="ln2860">        sug.su_badlen, sug.su_badptr);</a>
<a name="ln2861">    if (cmdmsg_rl &amp;&amp; STRNCMP(IObuff, &quot;Change&quot;, 6) == 0) {</a>
<a name="ln2862">      // And now the rabbit from the high hat: Avoid showing the</a>
<a name="ln2863">      // untranslated message rightleft.</a>
<a name="ln2864">      vim_snprintf((char *)IObuff, IOSIZE, &quot;:ot \&quot;%.*s\&quot; egnahC&quot;,</a>
<a name="ln2865">          sug.su_badlen, sug.su_badptr);</a>
<a name="ln2866">    }</a>
<a name="ln2867">    msg_puts((const char *)IObuff);</a>
<a name="ln2868">    msg_clr_eos();</a>
<a name="ln2869">    msg_putchar('\n');</a>
<a name="ln2870"> </a>
<a name="ln2871">    msg_scroll = TRUE;</a>
<a name="ln2872">    for (int i = 0; i &lt; sug.su_ga.ga_len; ++i) {</a>
<a name="ln2873">      stp = &amp;SUG(sug.su_ga, i);</a>
<a name="ln2874"> </a>
<a name="ln2875">      // The suggested word may replace only part of the bad word, add</a>
<a name="ln2876">      // the not replaced part.</a>
<a name="ln2877">      STRLCPY(wcopy, stp-&gt;st_word, MAXWLEN + 1);</a>
<a name="ln2878">      if (sug.su_badlen &gt; stp-&gt;st_orglen)</a>
<a name="ln2879">        STRLCPY(wcopy + stp-&gt;st_wordlen,</a>
<a name="ln2880">            sug.su_badptr + stp-&gt;st_orglen,</a>
<a name="ln2881">            sug.su_badlen - stp-&gt;st_orglen + 1);</a>
<a name="ln2882">      vim_snprintf((char *)IObuff, IOSIZE, &quot;%2d&quot;, i + 1);</a>
<a name="ln2883">      if (cmdmsg_rl) {</a>
<a name="ln2884">        rl_mirror(IObuff);</a>
<a name="ln2885">      }</a>
<a name="ln2886">      msg_puts((const char *)IObuff);</a>
<a name="ln2887"> </a>
<a name="ln2888">      vim_snprintf((char *)IObuff, IOSIZE, &quot; \&quot;%s\&quot;&quot;, wcopy);</a>
<a name="ln2889">      msg_puts((const char *)IObuff);</a>
<a name="ln2890"> </a>
<a name="ln2891">      // The word may replace more than &quot;su_badlen&quot;.</a>
<a name="ln2892">      if (sug.su_badlen &lt; stp-&gt;st_orglen) {</a>
<a name="ln2893">        vim_snprintf((char *)IObuff, IOSIZE, _(&quot; &lt; \&quot;%.*s\&quot;&quot;),</a>
<a name="ln2894">                     stp-&gt;st_orglen, sug.su_badptr);</a>
<a name="ln2895">        msg_puts((const char *)IObuff);</a>
<a name="ln2896">      }</a>
<a name="ln2897"> </a>
<a name="ln2898">      if (p_verbose &gt; 0) {</a>
<a name="ln2899">        // Add the score.</a>
<a name="ln2900">        if (sps_flags &amp; (SPS_DOUBLE | SPS_BEST))</a>
<a name="ln2901">          vim_snprintf((char *)IObuff, IOSIZE, &quot; (%s%d - %d)&quot;,</a>
<a name="ln2902">              stp-&gt;st_salscore ? &quot;s &quot; : &quot;&quot;,</a>
<a name="ln2903">              stp-&gt;st_score, stp-&gt;st_altscore);</a>
<a name="ln2904">        else</a>
<a name="ln2905">          vim_snprintf((char *)IObuff, IOSIZE, &quot; (%d)&quot;,</a>
<a name="ln2906">              stp-&gt;st_score);</a>
<a name="ln2907">        if (cmdmsg_rl)</a>
<a name="ln2908">          // Mirror the numbers, but keep the leading space.</a>
<a name="ln2909">          rl_mirror(IObuff + 1);</a>
<a name="ln2910">        msg_advance(30);</a>
<a name="ln2911">        msg_puts((const char *)IObuff);</a>
<a name="ln2912">      }</a>
<a name="ln2913">      msg_putchar('\n');</a>
<a name="ln2914">    }</a>
<a name="ln2915"> </a>
<a name="ln2916">    cmdmsg_rl = FALSE;</a>
<a name="ln2917">    msg_col = 0;</a>
<a name="ln2918">    // Ask for choice.</a>
<a name="ln2919">    selected = prompt_for_number(&amp;mouse_used);</a>
<a name="ln2920"> </a>
<a name="ln2921">    if (ui_has(kUIMessages)) {</a>
<a name="ln2922">      ui_call_msg_clear();</a>
<a name="ln2923">    }</a>
<a name="ln2924"> </a>
<a name="ln2925">    if (mouse_used) {</a>
<a name="ln2926">      selected -= lines_left;</a>
<a name="ln2927">    }</a>
<a name="ln2928">    lines_left = Rows;                  // avoid more prompt</a>
<a name="ln2929">    // don't delay for 'smd' in normal_cmd()</a>
<a name="ln2930">    msg_scroll = msg_scroll_save;</a>
<a name="ln2931">  }</a>
<a name="ln2932"> </a>
<a name="ln2933">  if (selected &gt; 0 &amp;&amp; selected &lt;= sug.su_ga.ga_len &amp;&amp; u_save_cursor() == OK) {</a>
<a name="ln2934">    // Save the from and to text for :spellrepall.</a>
<a name="ln2935">    XFREE_CLEAR(repl_from);</a>
<a name="ln2936">    XFREE_CLEAR(repl_to);</a>
<a name="ln2937"> </a>
<a name="ln2938">    stp = &amp;SUG(sug.su_ga, selected - 1);</a>
<a name="ln2939">    if (sug.su_badlen &gt; stp-&gt;st_orglen) {</a>
<a name="ln2940">      // Replacing less than &quot;su_badlen&quot;, append the remainder to</a>
<a name="ln2941">      // repl_to.</a>
<a name="ln2942">      repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);</a>
<a name="ln2943">      vim_snprintf((char *)IObuff, IOSIZE, &quot;%s%.*s&quot;, stp-&gt;st_word,</a>
<a name="ln2944">          sug.su_badlen - stp-&gt;st_orglen,</a>
<a name="ln2945">          sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln2946">      repl_to = vim_strsave(IObuff);</a>
<a name="ln2947">    } else {</a>
<a name="ln2948">      // Replacing su_badlen or more, use the whole word.</a>
<a name="ln2949">      repl_from = vim_strnsave(sug.su_badptr, stp-&gt;st_orglen);</a>
<a name="ln2950">      repl_to = vim_strsave(stp-&gt;st_word);</a>
<a name="ln2951">    }</a>
<a name="ln2952"> </a>
<a name="ln2953">    // Replace the word.</a>
<a name="ln2954">    p = xmalloc(STRLEN(line) - stp-&gt;st_orglen + stp-&gt;st_wordlen + 1);</a>
<a name="ln2955">    c = (int)(sug.su_badptr - line);</a>
<a name="ln2956">    memmove(p, line, c);</a>
<a name="ln2957">    STRCPY(p + c, stp-&gt;st_word);</a>
<a name="ln2958">    STRCAT(p, sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln2959"> </a>
<a name="ln2960">    // For redo we use a change-word command.</a>
<a name="ln2961">    ResetRedobuff();</a>
<a name="ln2962">    AppendToRedobuff(&quot;ciw&quot;);</a>
<a name="ln2963">    AppendToRedobuffLit(p + c,</a>
<a name="ln2964">        stp-&gt;st_wordlen + sug.su_badlen - stp-&gt;st_orglen);</a>
<a name="ln2965">    AppendCharToRedobuff(ESC);</a>
<a name="ln2966"> </a>
<a name="ln2967">    // &quot;p&quot; may be freed here</a>
<a name="ln2968">    ml_replace(curwin-&gt;w_cursor.lnum, p, false);</a>
<a name="ln2969">    curwin-&gt;w_cursor.col = c;</a>
<a name="ln2970"> </a>
<a name="ln2971">    changed_bytes(curwin-&gt;w_cursor.lnum, c);</a>
<a name="ln2972">  } else</a>
<a name="ln2973">    curwin-&gt;w_cursor = prev_cursor;</a>
<a name="ln2974"> </a>
<a name="ln2975">  spell_find_cleanup(&amp;sug);</a>
<a name="ln2976">  xfree(line);</a>
<a name="ln2977">  curwin-&gt;w_p_spell = wo_spell_save;</a>
<a name="ln2978">}</a>
<a name="ln2979"> </a>
<a name="ln2980">// Check if the word at line &quot;lnum&quot; column &quot;col&quot; is required to start with a</a>
<a name="ln2981">// capital.  This uses 'spellcapcheck' of the current buffer.</a>
<a name="ln2982">static bool check_need_cap(linenr_T lnum, colnr_T col)</a>
<a name="ln2983">{</a>
<a name="ln2984">  bool need_cap = false;</a>
<a name="ln2985">  char_u      *line;</a>
<a name="ln2986">  char_u      *line_copy = NULL;</a>
<a name="ln2987">  char_u      *p;</a>
<a name="ln2988">  colnr_T endcol;</a>
<a name="ln2989">  regmatch_T regmatch;</a>
<a name="ln2990"> </a>
<a name="ln2991">  if (curwin-&gt;w_s-&gt;b_cap_prog == NULL)</a>
<a name="ln2992">    return false;</a>
<a name="ln2993"> </a>
<a name="ln2994">  line = get_cursor_line_ptr();</a>
<a name="ln2995">  endcol = 0;</a>
<a name="ln2996">  if (getwhitecols(line) &gt;= (int)col) {</a>
<a name="ln2997">    // At start of line, check if previous line is empty or sentence</a>
<a name="ln2998">    // ends there.</a>
<a name="ln2999">    if (lnum == 1)</a>
<a name="ln3000">      need_cap = true;</a>
<a name="ln3001">    else {</a>
<a name="ln3002">      line = ml_get(lnum - 1);</a>
<a name="ln3003">      if (*skipwhite(line) == NUL)</a>
<a name="ln3004">        need_cap = true;</a>
<a name="ln3005">      else {</a>
<a name="ln3006">        // Append a space in place of the line break.</a>
<a name="ln3007">        line_copy = concat_str(line, (char_u *)&quot; &quot;);</a>
<a name="ln3008">        line = line_copy;</a>
<a name="ln3009">        endcol = (colnr_T)STRLEN(line);</a>
<a name="ln3010">      }</a>
<a name="ln3011">    }</a>
<a name="ln3012">  } else {</a>
<a name="ln3013">    endcol = col;</a>
<a name="ln3014">  }</a>
<a name="ln3015"> </a>
<a name="ln3016">  if (endcol &gt; 0) {</a>
<a name="ln3017">    // Check if sentence ends before the bad word.</a>
<a name="ln3018">    regmatch.regprog = curwin-&gt;w_s-&gt;b_cap_prog;</a>
<a name="ln3019">    regmatch.rm_ic = FALSE;</a>
<a name="ln3020">    p = line + endcol;</a>
<a name="ln3021">    for (;; ) {</a>
<a name="ln3022">      MB_PTR_BACK(line, p);</a>
<a name="ln3023">      if (p == line || spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln3024">        break;</a>
<a name="ln3025">      }</a>
<a name="ln3026">      if (vim_regexec(&amp;regmatch, p, 0)</a>
<a name="ln3027">          &amp;&amp; regmatch.endp[0] == line + endcol) {</a>
<a name="ln3028">        need_cap = true;</a>
<a name="ln3029">        break;</a>
<a name="ln3030">      }</a>
<a name="ln3031">    }</a>
<a name="ln3032">    curwin-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</a>
<a name="ln3033">  }</a>
<a name="ln3034"> </a>
<a name="ln3035">  xfree(line_copy);</a>
<a name="ln3036"> </a>
<a name="ln3037">  return need_cap;</a>
<a name="ln3038">}</a>
<a name="ln3039"> </a>
<a name="ln3040"> </a>
<a name="ln3041">// &quot;:spellrepall&quot;</a>
<a name="ln3042">void ex_spellrepall(exarg_T *eap)</a>
<a name="ln3043">{</a>
<a name="ln3044">  pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln3045">  char_u      *frompat;</a>
<a name="ln3046">  int addlen;</a>
<a name="ln3047">  char_u      *line;</a>
<a name="ln3048">  char_u      *p;</a>
<a name="ln3049">  bool save_ws = p_ws;</a>
<a name="ln3050">  linenr_T prev_lnum = 0;</a>
<a name="ln3051"> </a>
<a name="ln3052">  if (repl_from == NULL || repl_to == NULL) {</a>
<a name="ln3053">    EMSG(_(&quot;E752: No previous spell replacement&quot;));</a>
<a name="ln3054">    return;</a>
<a name="ln3055">  }</a>
<a name="ln3056">  addlen = (int)(STRLEN(repl_to) - STRLEN(repl_from));</a>
<a name="ln3057"> </a>
<a name="ln3058">  frompat = xmalloc(STRLEN(repl_from) + 7);</a>
<a name="ln3059">  sprintf((char *)frompat, &quot;\\V\\&lt;%s\\&gt;&quot;, repl_from);</a>
<a name="ln3060">  p_ws = false;</a>
<a name="ln3061"> </a>
<a name="ln3062">  sub_nsubs = 0;</a>
<a name="ln3063">  sub_nlines = 0;</a>
<a name="ln3064">  curwin-&gt;w_cursor.lnum = 0;</a>
<a name="ln3065">  while (!got_int) {</a>
<a name="ln3066">    if (do_search(NULL, '/', '/', frompat, 1L, SEARCH_KEEP, NULL) == 0</a>
<a name="ln3067">        || u_save_cursor() == FAIL) {</a>
<a name="ln3068">      break;</a>
<a name="ln3069">    }</a>
<a name="ln3070"> </a>
<a name="ln3071">    // Only replace when the right word isn't there yet.  This happens</a>
<a name="ln3072">    // when changing &quot;etc&quot; to &quot;etc.&quot;.</a>
<a name="ln3073">    line = get_cursor_line_ptr();</a>
<a name="ln3074">    if (addlen &lt;= 0 || STRNCMP(line + curwin-&gt;w_cursor.col,</a>
<a name="ln3075">            repl_to, STRLEN(repl_to)) != 0) {</a>
<a name="ln3076">      p = xmalloc(STRLEN(line) + addlen + 1);</a>
<a name="ln3077">      memmove(p, line, curwin-&gt;w_cursor.col);</a>
<a name="ln3078">      STRCPY(p + curwin-&gt;w_cursor.col, repl_to);</a>
<a name="ln3079">      STRCAT(p, line + curwin-&gt;w_cursor.col + STRLEN(repl_from));</a>
<a name="ln3080">      ml_replace(curwin-&gt;w_cursor.lnum, p, false);</a>
<a name="ln3081">      changed_bytes(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col);</a>
<a name="ln3082"> </a>
<a name="ln3083">      if (curwin-&gt;w_cursor.lnum != prev_lnum) {</a>
<a name="ln3084">        ++sub_nlines;</a>
<a name="ln3085">        prev_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3086">      }</a>
<a name="ln3087">      ++sub_nsubs;</a>
<a name="ln3088">    }</a>
<a name="ln3089">    curwin-&gt;w_cursor.col += (colnr_T)STRLEN(repl_to);</a>
<a name="ln3090">  }</a>
<a name="ln3091"> </a>
<a name="ln3092">  p_ws = save_ws;</a>
<a name="ln3093">  curwin-&gt;w_cursor = pos;</a>
<a name="ln3094">  xfree(frompat);</a>
<a name="ln3095"> </a>
<a name="ln3096">  if (sub_nsubs == 0)</a>
<a name="ln3097">    EMSG2(_(&quot;E753: Not found: %s&quot;), repl_from);</a>
<a name="ln3098">  else</a>
<a name="ln3099">    do_sub_msg(false);</a>
<a name="ln3100">}</a>
<a name="ln3101"> </a>
<a name="ln3102">// Find spell suggestions for &quot;word&quot;.  Return them in the growarray &quot;*gap&quot; as</a>
<a name="ln3103">// a list of allocated strings.</a>
<a name="ln3104">void</a>
<a name="ln3105">spell_suggest_list (</a>
<a name="ln3106">    garray_T *gap,</a>
<a name="ln3107">    char_u *word,</a>
<a name="ln3108">    int maxcount,                   // maximum nr of suggestions</a>
<a name="ln3109">    bool need_cap,                  // 'spellcapcheck' matched</a>
<a name="ln3110">    bool interactive</a>
<a name="ln3111">)</a>
<a name="ln3112">{</a>
<a name="ln3113">  suginfo_T sug;</a>
<a name="ln3114">  suggest_T   *stp;</a>
<a name="ln3115">  char_u      *wcopy;</a>
<a name="ln3116"> </a>
<a name="ln3117">  spell_find_suggest(word, 0, &amp;sug, maxcount, false, need_cap, interactive);</a>
<a name="ln3118"> </a>
<a name="ln3119">  // Make room in &quot;gap&quot;.</a>
<a name="ln3120">  ga_init(gap, sizeof(char_u *), sug.su_ga.ga_len + 1);</a>
<a name="ln3121">  ga_grow(gap, sug.su_ga.ga_len);</a>
<a name="ln3122">  for (int i = 0; i &lt; sug.su_ga.ga_len; ++i) {</a>
<a name="ln3123">    stp = &amp;SUG(sug.su_ga, i);</a>
<a name="ln3124"> </a>
<a name="ln3125">    // The suggested word may replace only part of &quot;word&quot;, add the not</a>
<a name="ln3126">    // replaced part.</a>
<a name="ln3127">    wcopy = xmalloc(stp-&gt;st_wordlen</a>
<a name="ln3128">                    + STRLEN(sug.su_badptr + stp-&gt;st_orglen) + 1);</a>
<a name="ln3129">    STRCPY(wcopy, stp-&gt;st_word);</a>
<a name="ln3130">    STRCPY(wcopy + stp-&gt;st_wordlen, sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln3131">    ((char_u **)gap-&gt;ga_data)[gap-&gt;ga_len++] = wcopy;</a>
<a name="ln3132">  }</a>
<a name="ln3133"> </a>
<a name="ln3134">  spell_find_cleanup(&amp;sug);</a>
<a name="ln3135">}</a>
<a name="ln3136"> </a>
<a name="ln3137">// Find spell suggestions for the word at the start of &quot;badptr&quot;.</a>
<a name="ln3138">// Return the suggestions in &quot;su-&gt;su_ga&quot;.</a>
<a name="ln3139">// The maximum number of suggestions is &quot;maxcount&quot;.</a>
<a name="ln3140">// Note: does use info for the current window.</a>
<a name="ln3141">// This is based on the mechanisms of Aspell, but completely reimplemented.</a>
<a name="ln3142">static void</a>
<a name="ln3143">spell_find_suggest (</a>
<a name="ln3144">    char_u *badptr,</a>
<a name="ln3145">    int badlen,                     // length of bad word or 0 if unknown</a>
<a name="ln3146">    suginfo_T *su,</a>
<a name="ln3147">    int maxcount,</a>
<a name="ln3148">    bool banbadword,                 // don't include badword in suggestions</a>
<a name="ln3149">    bool need_cap,                  // word should start with capital</a>
<a name="ln3150">    bool interactive</a>
<a name="ln3151">)</a>
<a name="ln3152">{</a>
<a name="ln3153">  hlf_T attr = HLF_COUNT;</a>
<a name="ln3154">  char_u buf[MAXPATHL];</a>
<a name="ln3155">  char_u      *p;</a>
<a name="ln3156">  bool do_combine = false;</a>
<a name="ln3157">  char_u      *sps_copy;</a>
<a name="ln3158">  static bool expr_busy = false;</a>
<a name="ln3159">  int c;</a>
<a name="ln3160">  langp_T     *lp;</a>
<a name="ln3161">  bool did_intern = false;</a>
<a name="ln3162"> </a>
<a name="ln3163">  // Set the info in &quot;*su&quot;.</a>
<a name="ln3164">  memset(su, 0, sizeof(suginfo_T));</a>
<a name="ln3165">  ga_init(&amp;su-&gt;su_ga, (int)sizeof(suggest_T), 10);</a>
<a name="ln3166">  ga_init(&amp;su-&gt;su_sga, (int)sizeof(suggest_T), 10);</a>
<a name="ln3167">  if (*badptr == NUL)</a>
<a name="ln3168">    return;</a>
<a name="ln3169">  hash_init(&amp;su-&gt;su_banned);</a>
<a name="ln3170"> </a>
<a name="ln3171">  su-&gt;su_badptr = badptr;</a>
<a name="ln3172">  if (badlen != 0)</a>
<a name="ln3173">    su-&gt;su_badlen = badlen;</a>
<a name="ln3174">  else {</a>
<a name="ln3175">    size_t tmplen = spell_check(curwin, su-&gt;su_badptr, &amp;attr, NULL, false);</a>
<a name="ln3176">    assert(tmplen &lt;= INT_MAX);</a>
<a name="ln3177">    su-&gt;su_badlen = (int)tmplen;</a>
<a name="ln3178">  }</a>
<a name="ln3179">  su-&gt;su_maxcount = maxcount;</a>
<a name="ln3180">  su-&gt;su_maxscore = SCORE_MAXINIT;</a>
<a name="ln3181"> </a>
<a name="ln3182">  if (su-&gt;su_badlen &gt;= MAXWLEN)</a>
<a name="ln3183">    su-&gt;su_badlen = MAXWLEN - 1;        // just in case</a>
<a name="ln3184">  STRLCPY(su-&gt;su_badword, su-&gt;su_badptr, su-&gt;su_badlen + 1);</a>
<a name="ln3185">  (void)spell_casefold(curwin, su-&gt;su_badptr, su-&gt;su_badlen, su-&gt;su_fbadword,</a>
<a name="ln3186">                       MAXWLEN);</a>
<a name="ln3187"> </a>
<a name="ln3188">  // TODO(vim): make this work if the case-folded text is longer than the</a>
<a name="ln3189">  // original text. Currently an illegal byte causes wrong pointer</a>
<a name="ln3190">  // computations.</a>
<a name="ln3191">  su-&gt;su_fbadword[su-&gt;su_badlen] = NUL;</a>
<a name="ln3192"> </a>
<a name="ln3193">  // get caps flags for bad word</a>
<a name="ln3194">  su-&gt;su_badflags = badword_captype(su-&gt;su_badptr,</a>
<a name="ln3195">      su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln3196">  if (need_cap)</a>
<a name="ln3197">    su-&gt;su_badflags |= WF_ONECAP;</a>
<a name="ln3198"> </a>
<a name="ln3199">  // Find the default language for sound folding.  We simply use the first</a>
<a name="ln3200">  // one in 'spelllang' that supports sound folding.  That's good for when</a>
<a name="ln3201">  // using multiple files for one language, it's not that bad when mixing</a>
<a name="ln3202">  // languages (e.g., &quot;pl,en&quot;).</a>
<a name="ln3203">  for (int i = 0; i &lt; curbuf-&gt;b_s.b_langp.ga_len; ++i) {</a>
<a name="ln3204">    lp = LANGP_ENTRY(curbuf-&gt;b_s.b_langp, i);</a>
<a name="ln3205">    if (lp-&gt;lp_sallang != NULL) {</a>
<a name="ln3206">      su-&gt;su_sallang = lp-&gt;lp_sallang;</a>
<a name="ln3207">      break;</a>
<a name="ln3208">    }</a>
<a name="ln3209">  }</a>
<a name="ln3210"> </a>
<a name="ln3211">  // Soundfold the bad word with the default sound folding, so that we don't</a>
<a name="ln3212">  // have to do this many times.</a>
<a name="ln3213">  if (su-&gt;su_sallang != NULL)</a>
<a name="ln3214">    spell_soundfold(su-&gt;su_sallang, su-&gt;su_fbadword, true,</a>
<a name="ln3215">        su-&gt;su_sal_badword);</a>
<a name="ln3216"> </a>
<a name="ln3217">  // If the word is not capitalised and spell_check() doesn't consider the</a>
<a name="ln3218">  // word to be bad then it might need to be capitalised.  Add a suggestion</a>
<a name="ln3219">  // for that.</a>
<a name="ln3220">  c = PTR2CHAR(su-&gt;su_badptr);</a>
<a name="ln3221">  if (!SPELL_ISUPPER(c) &amp;&amp; attr == HLF_COUNT) {</a>
<a name="ln3222">    make_case_word(su-&gt;su_badword, buf, WF_ONECAP);</a>
<a name="ln3223">    add_suggestion(su, &amp;su-&gt;su_ga, buf, su-&gt;su_badlen, SCORE_ICASE,</a>
<a name="ln3224">        0, true, su-&gt;su_sallang, false);</a>
<a name="ln3225">  }</a>
<a name="ln3226"> </a>
<a name="ln3227">  // Ban the bad word itself.  It may appear in another region.</a>
<a name="ln3228">  if (banbadword)</a>
<a name="ln3229">    add_banned(su, su-&gt;su_badword);</a>
<a name="ln3230"> </a>
<a name="ln3231">  // Make a copy of 'spellsuggest', because the expression may change it.</a>
<a name="ln3232">  sps_copy = vim_strsave(p_sps);</a>
<a name="ln3233"> </a>
<a name="ln3234">  // Loop over the items in 'spellsuggest'.</a>
<a name="ln3235">  for (p = sps_copy; *p != NUL; ) {</a>
<a name="ln3236">    copy_option_part(&amp;p, buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln3237"> </a>
<a name="ln3238">    if (STRNCMP(buf, &quot;expr:&quot;, 5) == 0) {</a>
<a name="ln3239">      // Evaluate an expression.  Skip this when called recursively,</a>
<a name="ln3240">      // when using spellsuggest() in the expression.</a>
<a name="ln3241">      if (!expr_busy) {</a>
<a name="ln3242">        expr_busy = true;</a>
<a name="ln3243">        spell_suggest_expr(su, buf + 5);</a>
<a name="ln3244">        expr_busy = false;</a>
<a name="ln3245">      }</a>
<a name="ln3246">    } else if (STRNCMP(buf, &quot;file:&quot;, 5) == 0) {</a>
<a name="ln3247">      // Use list of suggestions in a file.</a>
<a name="ln3248">      spell_suggest_file(su, buf + 5);</a>
<a name="ln3249">    } else if (!did_intern) {</a>
<a name="ln3250">      // Use internal method once.</a>
<a name="ln3251">      spell_suggest_intern(su, interactive);</a>
<a name="ln3252">      if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln3253">        do_combine = true;</a>
<a name="ln3254">      }</a>
<a name="ln3255">      did_intern = true;</a>
<a name="ln3256">    }</a>
<a name="ln3257">  }</a>
<a name="ln3258"> </a>
<a name="ln3259">  xfree(sps_copy);</a>
<a name="ln3260"> </a>
<a name="ln3261">  if (do_combine)</a>
<a name="ln3262">    // Combine the two list of suggestions.  This must be done last,</a>
<a name="ln3263">    // because sorting changes the order again.</a>
<a name="ln3264">    score_combine(su);</a>
<a name="ln3265">}</a>
<a name="ln3266"> </a>
<a name="ln3267">// Find suggestions by evaluating expression &quot;expr&quot;.</a>
<a name="ln3268">static void spell_suggest_expr(suginfo_T *su, char_u *expr)</a>
<a name="ln3269">{</a>
<a name="ln3270">  int score;</a>
<a name="ln3271">  const char *p;</a>
<a name="ln3272"> </a>
<a name="ln3273">  // The work is split up in a few parts to avoid having to export</a>
<a name="ln3274">  // suginfo_T.</a>
<a name="ln3275">  // First evaluate the expression and get the resulting list.</a>
<a name="ln3276">  list_T *const list = eval_spell_expr(su-&gt;su_badword, expr);</a>
<a name="ln3277">  if (list != NULL) {</a>
<a name="ln3278">    // Loop over the items in the list.</a>
<a name="ln3279">    TV_LIST_ITER(list, li, {</a>
<a name="ln3280">      if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_LIST) {</a>
<a name="ln3281">        // Get the word and the score from the items.</a>
<a name="ln3282">        score = get_spellword(TV_LIST_ITEM_TV(li)-&gt;vval.v_list, &amp;p);</a>
<a name="ln3283">        if (score &gt;= 0 &amp;&amp; score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln3284">          add_suggestion(su, &amp;su-&gt;su_ga, (const char_u *)p, su-&gt;su_badlen,</a>
<a name="ln3285">                         score, 0, true, su-&gt;su_sallang, false);</a>
<a name="ln3286">        }</a>
<a name="ln3287">      }</a>
<a name="ln3288">    });</a>
<a name="ln3289">    tv_list_unref(list);</a>
<a name="ln3290">  }</a>
<a name="ln3291"> </a>
<a name="ln3292">  // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln3293">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln3294">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln3295">}</a>
<a name="ln3296"> </a>
<a name="ln3297">// Find suggestions in file &quot;fname&quot;.  Used for &quot;file:&quot; in 'spellsuggest'.</a>
<a name="ln3298">static void spell_suggest_file(suginfo_T *su, char_u *fname)</a>
<a name="ln3299">{</a>
<a name="ln3300">  FILE        *fd;</a>
<a name="ln3301">  char_u line[MAXWLEN * 2];</a>
<a name="ln3302">  char_u      *p;</a>
<a name="ln3303">  int len;</a>
<a name="ln3304">  char_u cword[MAXWLEN];</a>
<a name="ln3305"> </a>
<a name="ln3306">  // Open the file.</a>
<a name="ln3307">  fd = os_fopen((char *)fname, &quot;r&quot;);</a>
<a name="ln3308">  if (fd == NULL) {</a>
<a name="ln3309">    EMSG2(_(e_notopen), fname);</a>
<a name="ln3310">    return;</a>
<a name="ln3311">  }</a>
<a name="ln3312"> </a>
<a name="ln3313">  // Read it line by line.</a>
<a name="ln3314">  while (!vim_fgets(line, MAXWLEN * 2, fd) &amp;&amp; !got_int) {</a>
<a name="ln3315">    line_breakcheck();</a>
<a name="ln3316"> </a>
<a name="ln3317">    p = vim_strchr(line, '/');</a>
<a name="ln3318">    if (p == NULL)</a>
<a name="ln3319">      continue;             // No Tab found, just skip the line.</a>
<a name="ln3320">    *p++ = NUL;</a>
<a name="ln3321">    if (STRICMP(su-&gt;su_badword, line) == 0) {</a>
<a name="ln3322">      // Match!  Isolate the good word, until CR or NL.</a>
<a name="ln3323">      for (len = 0; p[len] &gt;= ' '; ++len)</a>
<a name="ln3324">        ;</a>
<a name="ln3325">      p[len] = NUL;</a>
<a name="ln3326"> </a>
<a name="ln3327">      // If the suggestion doesn't have specific case duplicate the case</a>
<a name="ln3328">      // of the bad word.</a>
<a name="ln3329">      if (captype(p, NULL) == 0) {</a>
<a name="ln3330">        make_case_word(p, cword, su-&gt;su_badflags);</a>
<a name="ln3331">        p = cword;</a>
<a name="ln3332">      }</a>
<a name="ln3333"> </a>
<a name="ln3334">      add_suggestion(su, &amp;su-&gt;su_ga, p, su-&gt;su_badlen,</a>
<a name="ln3335">          SCORE_FILE, 0, true, su-&gt;su_sallang, false);</a>
<a name="ln3336">    }</a>
<a name="ln3337">  }</a>
<a name="ln3338"> </a>
<a name="ln3339">  fclose(fd);</a>
<a name="ln3340"> </a>
<a name="ln3341">  // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln3342">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln3343">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln3344">}</a>
<a name="ln3345"> </a>
<a name="ln3346">// Find suggestions for the internal method indicated by &quot;sps_flags&quot;.</a>
<a name="ln3347">static void spell_suggest_intern(suginfo_T *su, bool interactive)</a>
<a name="ln3348">{</a>
<a name="ln3349">  // Load the .sug file(s) that are available and not done yet.</a>
<a name="ln3350">  suggest_load_files();</a>
<a name="ln3351"> </a>
<a name="ln3352">  // 1. Try special cases, such as repeating a word: &quot;the the&quot; -&gt; &quot;the&quot;.</a>
<a name="ln3353">  //</a>
<a name="ln3354">  // Set a maximum score to limit the combination of operations that is</a>
<a name="ln3355">  // tried.</a>
<a name="ln3356">  suggest_try_special(su);</a>
<a name="ln3357"> </a>
<a name="ln3358">  // 2. Try inserting/deleting/swapping/changing a letter, use REP entries</a>
<a name="ln3359">  //    from the .aff file and inserting a space (split the word).</a>
<a name="ln3360">  suggest_try_change(su);</a>
<a name="ln3361"> </a>
<a name="ln3362">  // For the resulting top-scorers compute the sound-a-like score.</a>
<a name="ln3363">  if (sps_flags &amp; SPS_DOUBLE)</a>
<a name="ln3364">    score_comp_sal(su);</a>
<a name="ln3365"> </a>
<a name="ln3366">  // 3. Try finding sound-a-like words.</a>
<a name="ln3367">  if ((sps_flags &amp; SPS_FAST) == 0) {</a>
<a name="ln3368">    if (sps_flags &amp; SPS_BEST)</a>
<a name="ln3369">      // Adjust the word score for the suggestions found so far for how</a>
<a name="ln3370">      // they sounds like.</a>
<a name="ln3371">      rescore_suggestions(su);</a>
<a name="ln3372"> </a>
<a name="ln3373">    // While going through the soundfold tree &quot;su_maxscore&quot; is the score</a>
<a name="ln3374">    // for the soundfold word, limits the changes that are being tried,</a>
<a name="ln3375">    // and &quot;su_sfmaxscore&quot; the rescored score, which is set by</a>
<a name="ln3376">    // cleanup_suggestions().</a>
<a name="ln3377">    // First find words with a small edit distance, because this is much</a>
<a name="ln3378">    // faster and often already finds the top-N suggestions.  If we didn't</a>
<a name="ln3379">    // find many suggestions try again with a higher edit distance.</a>
<a name="ln3380">    // &quot;sl_sounddone&quot; is used to avoid doing the same word twice.</a>
<a name="ln3381">    suggest_try_soundalike_prep();</a>
<a name="ln3382">    su-&gt;su_maxscore = SCORE_SFMAX1;</a>
<a name="ln3383">    su-&gt;su_sfmaxscore = SCORE_MAXINIT * 3;</a>
<a name="ln3384">    suggest_try_soundalike(su);</a>
<a name="ln3385">    if (su-&gt;su_ga.ga_len &lt; SUG_CLEAN_COUNT(su)) {</a>
<a name="ln3386">      // We didn't find enough matches, try again, allowing more</a>
<a name="ln3387">      // changes to the soundfold word.</a>
<a name="ln3388">      su-&gt;su_maxscore = SCORE_SFMAX2;</a>
<a name="ln3389">      suggest_try_soundalike(su);</a>
<a name="ln3390">      if (su-&gt;su_ga.ga_len &lt; SUG_CLEAN_COUNT(su)) {</a>
<a name="ln3391">        // Still didn't find enough matches, try again, allowing even</a>
<a name="ln3392">        // more changes to the soundfold word.</a>
<a name="ln3393">        su-&gt;su_maxscore = SCORE_SFMAX3;</a>
<a name="ln3394">        suggest_try_soundalike(su);</a>
<a name="ln3395">      }</a>
<a name="ln3396">    }</a>
<a name="ln3397">    su-&gt;su_maxscore = su-&gt;su_sfmaxscore;</a>
<a name="ln3398">    suggest_try_soundalike_finish();</a>
<a name="ln3399">  }</a>
<a name="ln3400"> </a>
<a name="ln3401">  // When CTRL-C was hit while searching do show the results.  Only clear</a>
<a name="ln3402">  // got_int when using a command, not for spellsuggest().</a>
<a name="ln3403">  os_breakcheck();</a>
<a name="ln3404">  if (interactive &amp;&amp; got_int) {</a>
<a name="ln3405">    (void)vgetc();</a>
<a name="ln3406">    got_int = FALSE;</a>
<a name="ln3407">  }</a>
<a name="ln3408"> </a>
<a name="ln3409">  if ((sps_flags &amp; SPS_DOUBLE) == 0 &amp;&amp; su-&gt;su_ga.ga_len != 0) {</a>
<a name="ln3410">    if (sps_flags &amp; SPS_BEST)</a>
<a name="ln3411">      // Adjust the word score for how it sounds like.</a>
<a name="ln3412">      rescore_suggestions(su);</a>
<a name="ln3413"> </a>
<a name="ln3414">    // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln3415">    check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln3416">    (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln3417">  }</a>
<a name="ln3418">}</a>
<a name="ln3419"> </a>
<a name="ln3420">// Free the info put in &quot;*su&quot; by spell_find_suggest().</a>
<a name="ln3421">static void spell_find_cleanup(suginfo_T *su)</a>
<a name="ln3422">{</a>
<a name="ln3423"># define FREE_SUG_WORD(sug) xfree(sug-&gt;st_word)</a>
<a name="ln3424">  // Free the suggestions.</a>
<a name="ln3425">  GA_DEEP_CLEAR(&amp;su-&gt;su_ga, suggest_T, FREE_SUG_WORD);</a>
<a name="ln3426">  GA_DEEP_CLEAR(&amp;su-&gt;su_sga, suggest_T, FREE_SUG_WORD);</a>
<a name="ln3427"> </a>
<a name="ln3428">  // Free the banned words.</a>
<a name="ln3429">  hash_clear_all(&amp;su-&gt;su_banned, 0);</a>
<a name="ln3430">}</a>
<a name="ln3431"> </a>
<a name="ln3432">/// Make a copy of &quot;word&quot;, with the first letter upper or lower cased, to</a>
<a name="ln3433">/// &quot;wcopy[MAXWLEN]&quot;.  &quot;word&quot; must not be empty.</a>
<a name="ln3434">/// The result is NUL terminated.</a>
<a name="ln3435">///</a>
<a name="ln3436">/// @param[in]  word  source string to copy</a>
<a name="ln3437">/// @param[in,out]  wcopy  copied string, with case of first letter changed</a>
<a name="ln3438">/// @param[in]  upper  True to upper case, otherwise lower case</a>
<a name="ln3439">void onecap_copy(char_u *word, char_u *wcopy, bool upper)</a>
<a name="ln3440">{</a>
<a name="ln3441">  char_u *p = word;</a>
<a name="ln3442">  int c = mb_cptr2char_adv((const char_u **)&amp;p);</a>
<a name="ln3443">  if (upper) {</a>
<a name="ln3444">    c = SPELL_TOUPPER(c);</a>
<a name="ln3445">  } else {</a>
<a name="ln3446">    c = SPELL_TOFOLD(c);</a>
<a name="ln3447">  }</a>
<a name="ln3448">  int l = utf_char2bytes(c, wcopy);</a>
<a name="ln3449">  STRLCPY(wcopy + l, p, MAXWLEN - l);</a>
<a name="ln3450">}</a>
<a name="ln3451"> </a>
<a name="ln3452">// Make a copy of &quot;word&quot; with all the letters upper cased into</a>
<a name="ln3453">// &quot;wcopy[MAXWLEN]&quot;.  The result is NUL terminated.</a>
<a name="ln3454">static void allcap_copy(char_u *word, char_u *wcopy)</a>
<a name="ln3455">{</a>
<a name="ln3456">  char_u *d = wcopy;</a>
<a name="ln3457">  for (char_u *s = word; *s != NUL; ) {</a>
<a name="ln3458">    int c = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln3459"> </a>
<a name="ln3460">    if (c == 0xdf) {</a>
<a name="ln3461">      c = 'S';</a>
<a name="ln3462">      if (d - wcopy &gt;= MAXWLEN - 1)</a>
<a name="ln3463">        break;</a>
<a name="ln3464">      *d++ = c;</a>
<a name="ln3465">    } else</a>
<a name="ln3466">      c = SPELL_TOUPPER(c);</a>
<a name="ln3467"> </a>
<a name="ln3468">    if (d - wcopy &gt;= MAXWLEN - MB_MAXBYTES) {</a>
<a name="ln3469">      break;</a>
<a name="ln3470">    }</a>
<a name="ln3471">    d += utf_char2bytes(c, d);</a>
<a name="ln3472">  }</a>
<a name="ln3473">  *d = NUL;</a>
<a name="ln3474">}</a>
<a name="ln3475"> </a>
<a name="ln3476">// Try finding suggestions by recognizing specific situations.</a>
<a name="ln3477">static void suggest_try_special(suginfo_T *su)</a>
<a name="ln3478">{</a>
<a name="ln3479">  char_u      *p;</a>
<a name="ln3480">  size_t len;</a>
<a name="ln3481">  int c;</a>
<a name="ln3482">  char_u word[MAXWLEN];</a>
<a name="ln3483"> </a>
<a name="ln3484">  // Recognize a word that is repeated: &quot;the the&quot;.</a>
<a name="ln3485">  p = skiptowhite(su-&gt;su_fbadword);</a>
<a name="ln3486">  len = p - su-&gt;su_fbadword;</a>
<a name="ln3487">  p = skipwhite(p);</a>
<a name="ln3488">  if (STRLEN(p) == len &amp;&amp; STRNCMP(su-&gt;su_fbadword, p, len) == 0) {</a>
<a name="ln3489">    // Include badflags: if the badword is onecap or allcap</a>
<a name="ln3490">    // use that for the goodword too: &quot;The the&quot; -&gt; &quot;The&quot;.</a>
<a name="ln3491">    c = su-&gt;su_fbadword[len];</a>
<a name="ln3492">    su-&gt;su_fbadword[len] = NUL;</a>
<a name="ln3493">    make_case_word(su-&gt;su_fbadword, word, su-&gt;su_badflags);</a>
<a name="ln3494">    su-&gt;su_fbadword[len] = c;</a>
<a name="ln3495"> </a>
<a name="ln3496">    // Give a soundalike score of 0, compute the score as if deleting one</a>
<a name="ln3497">    // character.</a>
<a name="ln3498">    add_suggestion(su, &amp;su-&gt;su_ga, word, su-&gt;su_badlen,</a>
<a name="ln3499">        RESCORE(SCORE_REP, 0), 0, true, su-&gt;su_sallang, false);</a>
<a name="ln3500">  }</a>
<a name="ln3501">}</a>
<a name="ln3502"> </a>
<a name="ln3503">// Measure how much time is spent in each state.</a>
<a name="ln3504">// Output is dumped in &quot;suggestprof&quot;.</a>
<a name="ln3505"> </a>
<a name="ln3506">#ifdef SUGGEST_PROFILE</a>
<a name="ln3507">proftime_T current;</a>
<a name="ln3508">proftime_T total;</a>
<a name="ln3509">proftime_T times[STATE_FINAL + 1];</a>
<a name="ln3510">long counts[STATE_FINAL + 1];</a>
<a name="ln3511"> </a>
<a name="ln3512">  static void</a>
<a name="ln3513">prof_init(void)</a>
<a name="ln3514">{</a>
<a name="ln3515">  for (int i = 0; i &lt;= STATE_FINAL; i++) {</a>
<a name="ln3516">    profile_zero(&amp;times[i]);</a>
<a name="ln3517">    counts[i] = 0;</a>
<a name="ln3518">  }</a>
<a name="ln3519">  profile_start(&amp;current);</a>
<a name="ln3520">  profile_start(&amp;total);</a>
<a name="ln3521">}</a>
<a name="ln3522"> </a>
<a name="ln3523">// call before changing state</a>
<a name="ln3524">  static void</a>
<a name="ln3525">prof_store(state_T state)</a>
<a name="ln3526">{</a>
<a name="ln3527">  profile_end(&amp;current);</a>
<a name="ln3528">  profile_add(&amp;times[state], &amp;current);</a>
<a name="ln3529">  counts[state]++;</a>
<a name="ln3530">  profile_start(&amp;current);</a>
<a name="ln3531">}</a>
<a name="ln3532"># define PROF_STORE(state) prof_store(state);</a>
<a name="ln3533"> </a>
<a name="ln3534">  static void</a>
<a name="ln3535">prof_report(char *name)</a>
<a name="ln3536">{</a>
<a name="ln3537">  FILE *fd = fopen(&quot;suggestprof&quot;, &quot;a&quot;);</a>
<a name="ln3538"> </a>
<a name="ln3539">  profile_end(&amp;total);</a>
<a name="ln3540">  fprintf(fd, &quot;-----------------------\n&quot;);</a>
<a name="ln3541">  fprintf(fd, &quot;%s: %s\n&quot;, name, profile_msg(&amp;total));</a>
<a name="ln3542">  for (int i = 0; i &lt;= STATE_FINAL; i++) {</a>
<a name="ln3543">    fprintf(fd, &quot;%d: %s (&quot;%&quot; PRId64)\n&quot;, i, profile_msg(&amp;times[i]), counts[i]);</a>
<a name="ln3544">  }</a>
<a name="ln3545">  fclose(fd);</a>
<a name="ln3546">}</a>
<a name="ln3547">#else</a>
<a name="ln3548"># define PROF_STORE(state)</a>
<a name="ln3549">#endif</a>
<a name="ln3550"> </a>
<a name="ln3551">// Try finding suggestions by adding/removing/swapping letters.</a>
<a name="ln3552"> </a>
<a name="ln3553">static void suggest_try_change(suginfo_T *su)</a>
<a name="ln3554">{</a>
<a name="ln3555">  char_u fword[MAXWLEN];            // copy of the bad word, case-folded</a>
<a name="ln3556">  int n;</a>
<a name="ln3557">  char_u      *p;</a>
<a name="ln3558">  langp_T     *lp;</a>
<a name="ln3559"> </a>
<a name="ln3560">  // We make a copy of the case-folded bad word, so that we can modify it</a>
<a name="ln3561">  // to find matches (esp. REP items).  Append some more text, changing</a>
<a name="ln3562">  // chars after the bad word may help.</a>
<a name="ln3563">  STRCPY(fword, su-&gt;su_fbadword);</a>
<a name="ln3564">  n = (int)STRLEN(fword);</a>
<a name="ln3565">  p = su-&gt;su_badptr + su-&gt;su_badlen;</a>
<a name="ln3566">  (void)spell_casefold(curwin, p, (int)STRLEN(p), fword + n, MAXWLEN - n);</a>
<a name="ln3567"> </a>
<a name="ln3568">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln3569">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln3570"> </a>
<a name="ln3571">    // If reloading a spell file fails it's still in the list but</a>
<a name="ln3572">    // everything has been cleared.</a>
<a name="ln3573">    if (lp-&gt;lp_slang-&gt;sl_fbyts == NULL)</a>
<a name="ln3574">      continue;</a>
<a name="ln3575"> </a>
<a name="ln3576">    // Try it for this language.  Will add possible suggestions.</a>
<a name="ln3577">    //</a>
<a name="ln3578">#ifdef SUGGEST_PROFILE</a>
<a name="ln3579">    prof_init();</a>
<a name="ln3580">#endif</a>
<a name="ln3581">    suggest_trie_walk(su, lp, fword, false);</a>
<a name="ln3582">#ifdef SUGGEST_PROFILE</a>
<a name="ln3583">    prof_report(&quot;try_change&quot;);</a>
<a name="ln3584">#endif</a>
<a name="ln3585">  }</a>
<a name="ln3586">}</a>
<a name="ln3587"> </a>
<a name="ln3588">// Check the maximum score, if we go over it we won't try this change.</a>
<a name="ln3589">#define TRY_DEEPER(su, stack, depth, add) \</a>
<a name="ln3590">  (stack[depth].ts_score + (add) &lt; su-&gt;su_maxscore)</a>
<a name="ln3591"> </a>
<a name="ln3592">// Try finding suggestions by adding/removing/swapping letters.</a>
<a name="ln3593">//</a>
<a name="ln3594">// This uses a state machine.  At each node in the tree we try various</a>
<a name="ln3595">// operations.  When trying if an operation works &quot;depth&quot; is increased and the</a>
<a name="ln3596">// stack[] is used to store info.  This allows combinations, thus insert one</a>
<a name="ln3597">// character, replace one and delete another.  The number of changes is</a>
<a name="ln3598">// limited by su-&gt;su_maxscore.</a>
<a name="ln3599">//</a>
<a name="ln3600">// After implementing this I noticed an article by Kemal Oflazer that</a>
<a name="ln3601">// describes something similar: &quot;Error-tolerant Finite State Recognition with</a>
<a name="ln3602">// Applications to Morphological Analysis and Spelling Correction&quot; (1996).</a>
<a name="ln3603">// The implementation in the article is simplified and requires a stack of</a>
<a name="ln3604">// unknown depth.  The implementation here only needs a stack depth equal to</a>
<a name="ln3605">// the length of the word.</a>
<a name="ln3606">//</a>
<a name="ln3607">// This is also used for the sound-folded word, &quot;soundfold&quot; is true then.</a>
<a name="ln3608">// The mechanism is the same, but we find a match with a sound-folded word</a>
<a name="ln3609">// that comes from one or more original words.  Each of these words may be</a>
<a name="ln3610">// added, this is done by add_sound_suggest().</a>
<a name="ln3611">// Don't use:</a>
<a name="ln3612">//      the prefix tree or the keep-case tree</a>
<a name="ln3613">//      &quot;su-&gt;su_badlen&quot;</a>
<a name="ln3614">//      anything to do with upper and lower case</a>
<a name="ln3615">//      anything to do with word or non-word characters (&quot;spell_iswordp()&quot;)</a>
<a name="ln3616">//      banned words</a>
<a name="ln3617">//      word flags (rare, region, compounding)</a>
<a name="ln3618">//      word splitting for now</a>
<a name="ln3619">//      &quot;similar_chars()&quot;</a>
<a name="ln3620">//      use &quot;slang-&gt;sl_repsal&quot; instead of &quot;lp-&gt;lp_replang-&gt;sl_rep&quot;</a>
<a name="ln3621">static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool soundfold)</a>
<a name="ln3622">{</a>
<a name="ln3623">  char_u tword[MAXWLEN];            // good word collected so far</a>
<a name="ln3624">  trystate_T stack[MAXWLEN];</a>
<a name="ln3625">  char_u preword[MAXWLEN * 3] = { 0 };  // word found with proper case;</a>
<a name="ln3626">                                    // concatenation of prefix compound</a>
<a name="ln3627">                                    // words and split word.  NUL terminated</a>
<a name="ln3628">                                    // when going deeper but not when coming</a>
<a name="ln3629">                                    // back.</a>
<a name="ln3630">  char_u compflags[MAXWLEN];        // compound flags, one for each word</a>
<a name="ln3631">  trystate_T  *sp;</a>
<a name="ln3632">  int newscore;</a>
<a name="ln3633">  int score;</a>
<a name="ln3634">  char_u      *byts, *fbyts, *pbyts;</a>
<a name="ln3635">  idx_T       *idxs, *fidxs, *pidxs;</a>
<a name="ln3636">  int depth;</a>
<a name="ln3637">  int c, c2, c3;</a>
<a name="ln3638">  int n = 0;</a>
<a name="ln3639">  int flags;</a>
<a name="ln3640">  garray_T    *gap;</a>
<a name="ln3641">  idx_T arridx;</a>
<a name="ln3642">  int len;</a>
<a name="ln3643">  char_u      *p;</a>
<a name="ln3644">  fromto_T    *ftp;</a>
<a name="ln3645">  int fl = 0, tl;</a>
<a name="ln3646">  int repextra = 0;                 // extra bytes in fword[] from REP item</a>
<a name="ln3647">  slang_T     *slang = lp-&gt;lp_slang;</a>
<a name="ln3648">  int fword_ends;</a>
<a name="ln3649">  bool goodword_ends;</a>
<a name="ln3650">#ifdef DEBUG_TRIEWALK</a>
<a name="ln3651">  // Stores the name of the change made at each level.</a>
<a name="ln3652">  char_u changename[MAXWLEN][80];</a>
<a name="ln3653">#endif</a>
<a name="ln3654">  int breakcheckcount = 1000;</a>
<a name="ln3655">  bool compound_ok;</a>
<a name="ln3656"> </a>
<a name="ln3657">  // Go through the whole case-fold tree, try changes at each node.</a>
<a name="ln3658">  // &quot;tword[]&quot; contains the word collected from nodes in the tree.</a>
<a name="ln3659">  // &quot;fword[]&quot; the word we are trying to match with (initially the bad</a>
<a name="ln3660">  // word).</a>
<a name="ln3661">  depth = 0;</a>
<a name="ln3662">  sp = &amp;stack[0];</a>
<a name="ln3663">  memset(sp, 0, sizeof(trystate_T));  // -V512</a>
<a name="ln3664">  sp-&gt;ts_curi = 1;</a>
<a name="ln3665"> </a>
<a name="ln3666">  if (soundfold) {</a>
<a name="ln3667">    // Going through the soundfold tree.</a>
<a name="ln3668">    byts = fbyts = slang-&gt;sl_sbyts;</a>
<a name="ln3669">    idxs = fidxs = slang-&gt;sl_sidxs;</a>
<a name="ln3670">    pbyts = NULL;</a>
<a name="ln3671">    pidxs = NULL;</a>
<a name="ln3672">    sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln3673">    sp-&gt;ts_state = STATE_START;</a>
<a name="ln3674">  } else {</a>
<a name="ln3675">    // When there are postponed prefixes we need to use these first.  At</a>
<a name="ln3676">    // the end of the prefix we continue in the case-fold tree.</a>
<a name="ln3677">    fbyts = slang-&gt;sl_fbyts;</a>
<a name="ln3678">    fidxs = slang-&gt;sl_fidxs;</a>
<a name="ln3679">    pbyts = slang-&gt;sl_pbyts;</a>
<a name="ln3680">    pidxs = slang-&gt;sl_pidxs;</a>
<a name="ln3681">    if (pbyts != NULL) {</a>
<a name="ln3682">      byts = pbyts;</a>
<a name="ln3683">      idxs = pidxs;</a>
<a name="ln3684">      sp-&gt;ts_prefixdepth = PFD_PREFIXTREE;</a>
<a name="ln3685">      sp-&gt;ts_state = STATE_NOPREFIX;            // try without prefix first</a>
<a name="ln3686">    } else {</a>
<a name="ln3687">      byts = fbyts;</a>
<a name="ln3688">      idxs = fidxs;</a>
<a name="ln3689">      sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln3690">      sp-&gt;ts_state = STATE_START;</a>
<a name="ln3691">    }</a>
<a name="ln3692">  }</a>
<a name="ln3693"> </a>
<a name="ln3694">  // Loop to find all suggestions.  At each round we either:</a>
<a name="ln3695">  // - For the current state try one operation, advance &quot;ts_curi&quot;,</a>
<a name="ln3696">  //   increase &quot;depth&quot;.</a>
<a name="ln3697">  // - When a state is done go to the next, set &quot;ts_state&quot;.</a>
<a name="ln3698">  // - When all states are tried decrease &quot;depth&quot;.</a>
<a name="ln3699">  while (depth &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln3700">    sp = &amp;stack[depth];</a>
<a name="ln3701">    switch (sp-&gt;ts_state) {</a>
<a name="ln3702">    case STATE_START:</a>
<a name="ln3703">    case STATE_NOPREFIX:</a>
<a name="ln3704">      // Start of node: Deal with NUL bytes, which means</a>
<a name="ln3705">      // tword[] may end here.</a>
<a name="ln3706">      arridx = sp-&gt;ts_arridx;               // current node in the tree</a>
<a name="ln3707">      len = byts[arridx];                   // bytes in this node</a>
<a name="ln3708">      arridx += sp-&gt;ts_curi;                // index of current byte</a>
<a name="ln3709"> </a>
<a name="ln3710">      if (sp-&gt;ts_prefixdepth == PFD_PREFIXTREE) {</a>
<a name="ln3711">        // Skip over the NUL bytes, we use them later.</a>
<a name="ln3712">        for (n = 0; n &lt; len &amp;&amp; byts[arridx + n] == 0; ++n)</a>
<a name="ln3713">          ;</a>
<a name="ln3714">        sp-&gt;ts_curi += n;</a>
<a name="ln3715"> </a>
<a name="ln3716">        // Always past NUL bytes now.</a>
<a name="ln3717">        n = (int)sp-&gt;ts_state;</a>
<a name="ln3718">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln3719">        sp-&gt;ts_state = STATE_ENDNUL;</a>
<a name="ln3720">        sp-&gt;ts_save_badflags = su-&gt;su_badflags;</a>
<a name="ln3721"> </a>
<a name="ln3722">        // At end of a prefix or at start of prefixtree: check for</a>
<a name="ln3723">        // following word.</a>
<a name="ln3724">        if (byts[arridx] == 0 || n == (int)STATE_NOPREFIX) {</a>
<a name="ln3725">          // Set su-&gt;su_badflags to the caps type at this position.</a>
<a name="ln3726">          // Use the caps type until here for the prefix itself.</a>
<a name="ln3727">          n = nofold_len(fword, sp-&gt;ts_fidx, su-&gt;su_badptr);</a>
<a name="ln3728">          flags = badword_captype(su-&gt;su_badptr, su-&gt;su_badptr + n);</a>
<a name="ln3729">          su-&gt;su_badflags = badword_captype(su-&gt;su_badptr + n,</a>
<a name="ln3730">              su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln3731">#ifdef DEBUG_TRIEWALK</a>
<a name="ln3732">          sprintf(changename[depth], &quot;prefix&quot;);</a>
<a name="ln3733">#endif</a>
<a name="ln3734">          go_deeper(stack, depth, 0);</a>
<a name="ln3735">          ++depth;</a>
<a name="ln3736">          sp = &amp;stack[depth];</a>
<a name="ln3737">          sp-&gt;ts_prefixdepth = depth - 1;</a>
<a name="ln3738">          byts = fbyts;</a>
<a name="ln3739">          idxs = fidxs;</a>
<a name="ln3740">          sp-&gt;ts_arridx = 0;</a>
<a name="ln3741"> </a>
<a name="ln3742">          // Move the prefix to preword[] with the right case</a>
<a name="ln3743">          // and make find_keepcap_word() works.</a>
<a name="ln3744">          tword[sp-&gt;ts_twordlen] = NUL;</a>
<a name="ln3745">          make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln3746">              preword + sp-&gt;ts_prewordlen, flags);</a>
<a name="ln3747">          sp-&gt;ts_prewordlen = (char_u)STRLEN(preword);</a>
<a name="ln3748">          sp-&gt;ts_splitoff = sp-&gt;ts_twordlen;</a>
<a name="ln3749">        }</a>
<a name="ln3750">        break;</a>
<a name="ln3751">      }</a>
<a name="ln3752"> </a>
<a name="ln3753">      if (sp-&gt;ts_curi &gt; len || byts[arridx] != 0) {</a>
<a name="ln3754">        // Past bytes in node and/or past NUL bytes.</a>
<a name="ln3755">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln3756">        sp-&gt;ts_state = STATE_ENDNUL;</a>
<a name="ln3757">        sp-&gt;ts_save_badflags = su-&gt;su_badflags;</a>
<a name="ln3758">        break;</a>
<a name="ln3759">      }</a>
<a name="ln3760"> </a>
<a name="ln3761">      // End of word in tree.</a>
<a name="ln3762">      ++sp-&gt;ts_curi;                    // eat one NUL byte</a>
<a name="ln3763"> </a>
<a name="ln3764">      flags = (int)idxs[arridx];</a>
<a name="ln3765"> </a>
<a name="ln3766">      // Skip words with the NOSUGGEST flag.</a>
<a name="ln3767">      if (flags &amp; WF_NOSUGGEST)</a>
<a name="ln3768">        break;</a>
<a name="ln3769"> </a>
<a name="ln3770">      fword_ends = (fword[sp-&gt;ts_fidx] == NUL</a>
<a name="ln3771">                    || (soundfold</a>
<a name="ln3772">                        ? ascii_iswhite(fword[sp-&gt;ts_fidx])</a>
<a name="ln3773">                        : !spell_iswordp(fword + sp-&gt;ts_fidx, curwin)));</a>
<a name="ln3774">      tword[sp-&gt;ts_twordlen] = NUL;</a>
<a name="ln3775"> </a>
<a name="ln3776">      if (sp-&gt;ts_prefixdepth &lt;= PFD_NOTSPECIAL</a>
<a name="ln3777">          &amp;&amp; (sp-&gt;ts_flags &amp; TSF_PREFIXOK) == 0</a>
<a name="ln3778">          &amp;&amp; pbyts != NULL) {</a>
<a name="ln3779">        // There was a prefix before the word.  Check that the prefix</a>
<a name="ln3780">        // can be used with this word.</a>
<a name="ln3781">        // Count the length of the NULs in the prefix.  If there are</a>
<a name="ln3782">        // none this must be the first try without a prefix.</a>
<a name="ln3783">        n = stack[sp-&gt;ts_prefixdepth].ts_arridx;</a>
<a name="ln3784">        len = pbyts[n++];</a>
<a name="ln3785">        for (c = 0; c &lt; len &amp;&amp; pbyts[n + c] == 0; ++c)</a>
<a name="ln3786">          ;</a>
<a name="ln3787">        if (c &gt; 0) {</a>
<a name="ln3788">          c = valid_word_prefix(c, n, flags,</a>
<a name="ln3789">              tword + sp-&gt;ts_splitoff, slang, false);</a>
<a name="ln3790">          if (c == 0)</a>
<a name="ln3791">            break;</a>
<a name="ln3792"> </a>
<a name="ln3793">          // Use the WF_RARE flag for a rare prefix.</a>
<a name="ln3794">          if (c &amp; WF_RAREPFX)</a>
<a name="ln3795">            flags |= WF_RARE;</a>
<a name="ln3796"> </a>
<a name="ln3797">          // Tricky: when checking for both prefix and compounding</a>
<a name="ln3798">          // we run into the prefix flag first.</a>
<a name="ln3799">          // Remember that it's OK, so that we accept the prefix</a>
<a name="ln3800">          // when arriving at a compound flag.</a>
<a name="ln3801">          sp-&gt;ts_flags |= TSF_PREFIXOK;</a>
<a name="ln3802">        }</a>
<a name="ln3803">      }</a>
<a name="ln3804"> </a>
<a name="ln3805">      // Check NEEDCOMPOUND: can't use word without compounding.  Do try</a>
<a name="ln3806">      // appending another compound word below.</a>
<a name="ln3807">      if (sp-&gt;ts_complen == sp-&gt;ts_compsplit &amp;&amp; fword_ends</a>
<a name="ln3808">          &amp;&amp; (flags &amp; WF_NEEDCOMP))</a>
<a name="ln3809">        goodword_ends = false;</a>
<a name="ln3810">      else</a>
<a name="ln3811">        goodword_ends = true;</a>
<a name="ln3812"> </a>
<a name="ln3813">      p = NULL;</a>
<a name="ln3814">      compound_ok = true;</a>
<a name="ln3815">      if (sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit) {</a>
<a name="ln3816">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln3817">          // There was a word before this word.  When there was no</a>
<a name="ln3818">          // change in this word (it was correct) add the first word</a>
<a name="ln3819">          // as a suggestion.  If this word was corrected too, we</a>
<a name="ln3820">          // need to check if a correct word follows.</a>
<a name="ln3821">          if (sp-&gt;ts_fidx - sp-&gt;ts_splitfidx</a>
<a name="ln3822">              == sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln3823">              &amp;&amp; STRNCMP(fword + sp-&gt;ts_splitfidx,</a>
<a name="ln3824">                  tword + sp-&gt;ts_splitoff,</a>
<a name="ln3825">                  sp-&gt;ts_fidx - sp-&gt;ts_splitfidx) == 0) {</a>
<a name="ln3826">            preword[sp-&gt;ts_prewordlen] = NUL;</a>
<a name="ln3827">            newscore = score_wordcount_adj(slang, sp-&gt;ts_score,</a>
<a name="ln3828">                preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3829">                sp-&gt;ts_prewordlen &gt; 0);</a>
<a name="ln3830">            // Add the suggestion if the score isn't too bad.</a>
<a name="ln3831">            if (newscore &lt;= su-&gt;su_maxscore)</a>
<a name="ln3832">              add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln3833">                  sp-&gt;ts_splitfidx - repextra,</a>
<a name="ln3834">                  newscore, 0, false,</a>
<a name="ln3835">                  lp-&gt;lp_sallang, false);</a>
<a name="ln3836">            break;</a>
<a name="ln3837">          }</a>
<a name="ln3838">        } else {</a>
<a name="ln3839">          // There was a compound word before this word.  If this</a>
<a name="ln3840">          // word does not support compounding then give up</a>
<a name="ln3841">          // (splitting is tried for the word without compound</a>
<a name="ln3842">          // flag).</a>
<a name="ln3843">          if (((unsigned)flags &gt;&gt; 24) == 0</a>
<a name="ln3844">              || sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln3845">              &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln3846">            break;</a>
<a name="ln3847">          }</a>
<a name="ln3848">          // For multi-byte chars check character length against</a>
<a name="ln3849">          // COMPOUNDMIN.</a>
<a name="ln3850">          if (slang-&gt;sl_compminlen &gt; 0</a>
<a name="ln3851">              &amp;&amp; mb_charlen(tword + sp-&gt;ts_splitoff)</a>
<a name="ln3852">              &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln3853">            break;</a>
<a name="ln3854">          }</a>
<a name="ln3855"> </a>
<a name="ln3856">          compflags[sp-&gt;ts_complen] = ((unsigned)flags &gt;&gt; 24);</a>
<a name="ln3857">          compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln3858">          STRLCPY(preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3859">              tword + sp-&gt;ts_splitoff,</a>
<a name="ln3860">              sp-&gt;ts_twordlen - sp-&gt;ts_splitoff + 1);</a>
<a name="ln3861"> </a>
<a name="ln3862">          // Verify CHECKCOMPOUNDPATTERN  rules.</a>
<a name="ln3863">          if (match_checkcompoundpattern(preword,  sp-&gt;ts_prewordlen,</a>
<a name="ln3864">                  &amp;slang-&gt;sl_comppat))</a>
<a name="ln3865">            compound_ok = false;</a>
<a name="ln3866"> </a>
<a name="ln3867">          if (compound_ok) {</a>
<a name="ln3868">            p = preword;</a>
<a name="ln3869">            while (*skiptowhite(p) != NUL)</a>
<a name="ln3870">              p = skipwhite(skiptowhite(p));</a>
<a name="ln3871">            if (fword_ends &amp;&amp; !can_compound(slang, p,</a>
<a name="ln3872">                    compflags + sp-&gt;ts_compsplit))</a>
<a name="ln3873">              // Compound is not allowed.  But it may still be</a>
<a name="ln3874">              // possible if we add another (short) word.</a>
<a name="ln3875">              compound_ok = false;</a>
<a name="ln3876">          }</a>
<a name="ln3877"> </a>
<a name="ln3878">          // Get pointer to last char of previous word.</a>
<a name="ln3879">          p = preword + sp-&gt;ts_prewordlen;</a>
<a name="ln3880">          MB_PTR_BACK(preword, p);</a>
<a name="ln3881">        }</a>
<a name="ln3882">      }</a>
<a name="ln3883"> </a>
<a name="ln3884">      // Form the word with proper case in preword.</a>
<a name="ln3885">      // If there is a word from a previous split, append.</a>
<a name="ln3886">      // For the soundfold tree don't change the case, simply append.</a>
<a name="ln3887">      if (soundfold)</a>
<a name="ln3888">        STRCPY(preword + sp-&gt;ts_prewordlen, tword + sp-&gt;ts_splitoff);</a>
<a name="ln3889">      else if (flags &amp; WF_KEEPCAP)</a>
<a name="ln3890">        // Must find the word in the keep-case tree.</a>
<a name="ln3891">        find_keepcap_word(slang, tword + sp-&gt;ts_splitoff,</a>
<a name="ln3892">            preword + sp-&gt;ts_prewordlen);</a>
<a name="ln3893">      else {</a>
<a name="ln3894">        // Include badflags: If the badword is onecap or allcap</a>
<a name="ln3895">        // use that for the goodword too.  But if the badword is</a>
<a name="ln3896">        // allcap and it's only one char long use onecap.</a>
<a name="ln3897">        c = su-&gt;su_badflags;</a>
<a name="ln3898">        if ((c &amp; WF_ALLCAP)</a>
<a name="ln3899">            &amp;&amp; su-&gt;su_badlen == (*mb_ptr2len)(su-&gt;su_badptr)</a>
<a name="ln3900">            )</a>
<a name="ln3901">          c = WF_ONECAP;</a>
<a name="ln3902">        c |= flags;</a>
<a name="ln3903"> </a>
<a name="ln3904">        // When appending a compound word after a word character don't</a>
<a name="ln3905">        // use Onecap.</a>
<a name="ln3906">        if (p != NULL &amp;&amp; spell_iswordp_nmw(p, curwin))</a>
<a name="ln3907">          c &amp;= ~WF_ONECAP;</a>
<a name="ln3908">        make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln3909">            preword + sp-&gt;ts_prewordlen, c);</a>
<a name="ln3910">      }</a>
<a name="ln3911"> </a>
<a name="ln3912">      if (!soundfold) {</a>
<a name="ln3913">        // Don't use a banned word.  It may appear again as a good</a>
<a name="ln3914">        // word, thus remember it.</a>
<a name="ln3915">        if (flags &amp; WF_BANNED) {</a>
<a name="ln3916">          add_banned(su, preword + sp-&gt;ts_prewordlen);</a>
<a name="ln3917">          break;</a>
<a name="ln3918">        }</a>
<a name="ln3919">        if ((sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln3920">             &amp;&amp; WAS_BANNED(su, preword + sp-&gt;ts_prewordlen))</a>
<a name="ln3921">            || WAS_BANNED(su, preword)) {</a>
<a name="ln3922">          if (slang-&gt;sl_compprog == NULL)</a>
<a name="ln3923">            break;</a>
<a name="ln3924">          // the word so far was banned but we may try compounding</a>
<a name="ln3925">          goodword_ends = false;</a>
<a name="ln3926">        }</a>
<a name="ln3927">      }</a>
<a name="ln3928"> </a>
<a name="ln3929">      newscore = 0;</a>
<a name="ln3930">      if (!soundfold) {         // soundfold words don't have flags</a>
<a name="ln3931">        if ((flags &amp; WF_REGION)</a>
<a name="ln3932">            &amp;&amp; (((unsigned)flags &gt;&gt; 16) &amp; lp-&gt;lp_region) == 0)</a>
<a name="ln3933">          newscore += SCORE_REGION;</a>
<a name="ln3934">        if (flags &amp; WF_RARE)</a>
<a name="ln3935">          newscore += SCORE_RARE;</a>
<a name="ln3936"> </a>
<a name="ln3937">        if (!spell_valid_case(su-&gt;su_badflags,</a>
<a name="ln3938">                captype(preword + sp-&gt;ts_prewordlen, NULL)))</a>
<a name="ln3939">          newscore += SCORE_ICASE;</a>
<a name="ln3940">      }</a>
<a name="ln3941"> </a>
<a name="ln3942">      // TODO: how about splitting in the soundfold tree?</a>
<a name="ln3943">      if (fword_ends</a>
<a name="ln3944">          &amp;&amp; goodword_ends</a>
<a name="ln3945">          &amp;&amp; sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry</a>
<a name="ln3946">          &amp;&amp; compound_ok) {</a>
<a name="ln3947">        // The badword also ends: add suggestions.</a>
<a name="ln3948">#ifdef DEBUG_TRIEWALK</a>
<a name="ln3949">        if (soundfold &amp;&amp; STRCMP(preword, &quot;smwrd&quot;) == 0) {</a>
<a name="ln3950">          int j;</a>
<a name="ln3951"> </a>
<a name="ln3952">          // print the stack of changes that brought us here</a>
<a name="ln3953">          smsg(&quot;------ %s -------&quot;, fword);</a>
<a name="ln3954">          for (j = 0; j &lt; depth; ++j)</a>
<a name="ln3955">            smsg(&quot;%s&quot;, changename[j]);</a>
<a name="ln3956">        }</a>
<a name="ln3957">#endif</a>
<a name="ln3958">        if (soundfold) {</a>
<a name="ln3959">          // For soundfolded words we need to find the original</a>
<a name="ln3960">          // words, the edit distance and then add them.</a>
<a name="ln3961">          add_sound_suggest(su, preword, sp-&gt;ts_score, lp);</a>
<a name="ln3962">        } else if (sp-&gt;ts_fidx &gt; 0)   {</a>
<a name="ln3963">          // Give a penalty when changing non-word char to word</a>
<a name="ln3964">          // char, e.g., &quot;thes,&quot; -&gt; &quot;these&quot;.</a>
<a name="ln3965">          p = fword + sp-&gt;ts_fidx;</a>
<a name="ln3966">          MB_PTR_BACK(fword, p);</a>
<a name="ln3967">          if (!spell_iswordp(p, curwin)) {</a>
<a name="ln3968">            p = preword + STRLEN(preword);</a>
<a name="ln3969">            MB_PTR_BACK(preword, p);</a>
<a name="ln3970">            if (spell_iswordp(p, curwin)) {</a>
<a name="ln3971">              newscore += SCORE_NONWORD;</a>
<a name="ln3972">            }</a>
<a name="ln3973">          }</a>
<a name="ln3974"> </a>
<a name="ln3975">          // Give a bonus to words seen before.</a>
<a name="ln3976">          score = score_wordcount_adj(slang,</a>
<a name="ln3977">              sp-&gt;ts_score + newscore,</a>
<a name="ln3978">              preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3979">              sp-&gt;ts_prewordlen &gt; 0);</a>
<a name="ln3980"> </a>
<a name="ln3981">          // Add the suggestion if the score isn't too bad.</a>
<a name="ln3982">          if (score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln3983">            add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln3984">                sp-&gt;ts_fidx - repextra,</a>
<a name="ln3985">                score, 0, false, lp-&gt;lp_sallang, false);</a>
<a name="ln3986"> </a>
<a name="ln3987">            if (su-&gt;su_badflags &amp; WF_MIXCAP) {</a>
<a name="ln3988">              // We really don't know if the word should be</a>
<a name="ln3989">              // upper or lower case, add both.</a>
<a name="ln3990">              c = captype(preword, NULL);</a>
<a name="ln3991">              if (c == 0 || c == WF_ALLCAP) {</a>
<a name="ln3992">                make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln3993">                    preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3994">                    c == 0 ? WF_ALLCAP : 0);</a>
<a name="ln3995"> </a>
<a name="ln3996">                add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln3997">                    sp-&gt;ts_fidx - repextra,</a>
<a name="ln3998">                    score + SCORE_ICASE, 0, false,</a>
<a name="ln3999">                    lp-&gt;lp_sallang, false);</a>
<a name="ln4000">              }</a>
<a name="ln4001">            }</a>
<a name="ln4002">          }</a>
<a name="ln4003">        }</a>
<a name="ln4004">      }</a>
<a name="ln4005"> </a>
<a name="ln4006">      // Try word split and/or compounding.</a>
<a name="ln4007">      if ((sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry || fword_ends)</a>
<a name="ln4008">          // Don't split in the middle of a character</a>
<a name="ln4009">          &amp;&amp; (sp-&gt;ts_tcharlen == 0)</a>
<a name="ln4010">          ) {</a>
<a name="ln4011">        bool try_compound;</a>
<a name="ln4012">        int try_split;</a>
<a name="ln4013"> </a>
<a name="ln4014">        // If past the end of the bad word don't try a split.</a>
<a name="ln4015">        // Otherwise try changing the next word.  E.g., find</a>
<a name="ln4016">        // suggestions for &quot;the the&quot; where the second &quot;the&quot; is</a>
<a name="ln4017">        // different.  It's done like a split.</a>
<a name="ln4018">        // TODO: word split for soundfold words</a>
<a name="ln4019">        try_split = (sp-&gt;ts_fidx - repextra &lt; su-&gt;su_badlen)</a>
<a name="ln4020">                    &amp;&amp; !soundfold;</a>
<a name="ln4021"> </a>
<a name="ln4022">        // Get here in several situations:</a>
<a name="ln4023">        // 1. The word in the tree ends:</a>
<a name="ln4024">        //    If the word allows compounding try that.  Otherwise try</a>
<a name="ln4025">        //    a split by inserting a space.  For both check that a</a>
<a name="ln4026">        //    valid words starts at fword[sp-&gt;ts_fidx].</a>
<a name="ln4027">        //    For NOBREAK do like compounding to be able to check if</a>
<a name="ln4028">        //    the next word is valid.</a>
<a name="ln4029">        // 2. The badword does end, but it was due to a change (e.g.,</a>
<a name="ln4030">        //    a swap).  No need to split, but do check that the</a>
<a name="ln4031">        //    following word is valid.</a>
<a name="ln4032">        // 3. The badword and the word in the tree end.  It may still</a>
<a name="ln4033">        //    be possible to compound another (short) word.</a>
<a name="ln4034">        try_compound = false;</a>
<a name="ln4035">        if (!soundfold</a>
<a name="ln4036">            &amp;&amp; !slang-&gt;sl_nocompoundsugs</a>
<a name="ln4037">            &amp;&amp; slang-&gt;sl_compprog != NULL</a>
<a name="ln4038">            &amp;&amp; ((unsigned)flags &gt;&gt; 24) != 0</a>
<a name="ln4039">            &amp;&amp; sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln4040">            &gt;= slang-&gt;sl_compminlen</a>
<a name="ln4041">            &amp;&amp; (slang-&gt;sl_compminlen == 0</a>
<a name="ln4042">                || mb_charlen(tword + sp-&gt;ts_splitoff)</a>
<a name="ln4043">                &gt;= slang-&gt;sl_compminlen)</a>
<a name="ln4044">            &amp;&amp; (slang-&gt;sl_compsylmax &lt; MAXWLEN</a>
<a name="ln4045">                || sp-&gt;ts_complen + 1 - sp-&gt;ts_compsplit</a>
<a name="ln4046">                &lt; slang-&gt;sl_compmax)</a>
<a name="ln4047">            &amp;&amp; (can_be_compound(sp, slang,</a>
<a name="ln4048">                    compflags, ((unsigned)flags &gt;&gt; 24)))) {</a>
<a name="ln4049">          try_compound = true;</a>
<a name="ln4050">          compflags[sp-&gt;ts_complen] = ((unsigned)flags &gt;&gt; 24);</a>
<a name="ln4051">          compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln4052">        }</a>
<a name="ln4053"> </a>
<a name="ln4054">        // For NOBREAK we never try splitting, it won't make any word</a>
<a name="ln4055">        // valid.</a>
<a name="ln4056">        if (slang-&gt;sl_nobreak &amp;&amp; !slang-&gt;sl_nocompoundsugs) {</a>
<a name="ln4057">          try_compound = true;</a>
<a name="ln4058">        } else if (!fword_ends</a>
<a name="ln4059">                   &amp;&amp; try_compound</a>
<a name="ln4060">                   &amp;&amp; (sp-&gt;ts_flags &amp; TSF_DIDSPLIT) == 0) {</a>
<a name="ln4061">          // If we could add a compound word, and it's also possible to</a>
<a name="ln4062">          // split at this point, do the split first and set</a>
<a name="ln4063">          // TSF_DIDSPLIT to avoid doing it again.</a>
<a name="ln4064">          try_compound = false;</a>
<a name="ln4065">          sp-&gt;ts_flags |= TSF_DIDSPLIT;</a>
<a name="ln4066">          --sp-&gt;ts_curi;                    // do the same NUL again</a>
<a name="ln4067">          compflags[sp-&gt;ts_complen] = NUL;</a>
<a name="ln4068">        } else {</a>
<a name="ln4069">          sp-&gt;ts_flags &amp;= ~TSF_DIDSPLIT;</a>
<a name="ln4070">        }</a>
<a name="ln4071"> </a>
<a name="ln4072">        if (try_split || try_compound) {</a>
<a name="ln4073">          if (!try_compound &amp;&amp; (!fword_ends || !goodword_ends)) {</a>
<a name="ln4074">            // If we're going to split need to check that the</a>
<a name="ln4075">            // words so far are valid for compounding.  If there</a>
<a name="ln4076">            // is only one word it must not have the NEEDCOMPOUND</a>
<a name="ln4077">            // flag.</a>
<a name="ln4078">            if (sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln4079">                &amp;&amp; (flags &amp; WF_NEEDCOMP))</a>
<a name="ln4080">              break;</a>
<a name="ln4081">            p = preword;</a>
<a name="ln4082">            while (*skiptowhite(p) != NUL)</a>
<a name="ln4083">              p = skipwhite(skiptowhite(p));</a>
<a name="ln4084">            if (sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit</a>
<a name="ln4085">                &amp;&amp; !can_compound(slang, p,</a>
<a name="ln4086">                    compflags + sp-&gt;ts_compsplit))</a>
<a name="ln4087">              break;</a>
<a name="ln4088"> </a>
<a name="ln4089">            if (slang-&gt;sl_nosplitsugs)</a>
<a name="ln4090">              newscore += SCORE_SPLIT_NO;</a>
<a name="ln4091">            else</a>
<a name="ln4092">              newscore += SCORE_SPLIT;</a>
<a name="ln4093"> </a>
<a name="ln4094">            // Give a bonus to words seen before.</a>
<a name="ln4095">            newscore = score_wordcount_adj(slang, newscore,</a>
<a name="ln4096">                preword + sp-&gt;ts_prewordlen, true);</a>
<a name="ln4097">          }</a>
<a name="ln4098"> </a>
<a name="ln4099">          if (TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4100">            go_deeper(stack, depth, newscore);</a>
<a name="ln4101">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4102">            if (!try_compound &amp;&amp; !fword_ends)</a>
<a name="ln4103">              sprintf(changename[depth], &quot;%.*s-%s: split&quot;,</a>
<a name="ln4104">                  sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx);</a>
<a name="ln4105">            else</a>
<a name="ln4106">              sprintf(changename[depth], &quot;%.*s-%s: compound&quot;,</a>
<a name="ln4107">                  sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx);</a>
<a name="ln4108">#endif</a>
<a name="ln4109">            // Save things to be restored at STATE_SPLITUNDO.</a>
<a name="ln4110">            sp-&gt;ts_save_badflags = su-&gt;su_badflags;</a>
<a name="ln4111">            PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4112">            sp-&gt;ts_state = STATE_SPLITUNDO;</a>
<a name="ln4113"> </a>
<a name="ln4114">            ++depth;</a>
<a name="ln4115">            sp = &amp;stack[depth];</a>
<a name="ln4116"> </a>
<a name="ln4117">            // Append a space to preword when splitting.</a>
<a name="ln4118">            if (!try_compound &amp;&amp; !fword_ends)</a>
<a name="ln4119">              STRCAT(preword, &quot; &quot;);</a>
<a name="ln4120">            sp-&gt;ts_prewordlen = (char_u)STRLEN(preword);</a>
<a name="ln4121">            sp-&gt;ts_splitoff = sp-&gt;ts_twordlen;</a>
<a name="ln4122">            sp-&gt;ts_splitfidx = sp-&gt;ts_fidx;</a>
<a name="ln4123"> </a>
<a name="ln4124">            // If the badword has a non-word character at this</a>
<a name="ln4125">            // position skip it.  That means replacing the</a>
<a name="ln4126">            // non-word character with a space.  Always skip a</a>
<a name="ln4127">            // character when the word ends.  But only when the</a>
<a name="ln4128">            // good word can end.</a>
<a name="ln4129">            if (((!try_compound &amp;&amp; !spell_iswordp_nmw(fword</a>
<a name="ln4130">                      + sp-&gt;ts_fidx,</a>
<a name="ln4131">                      curwin))</a>
<a name="ln4132">                 || fword_ends)</a>
<a name="ln4133">                &amp;&amp; fword[sp-&gt;ts_fidx] != NUL</a>
<a name="ln4134">                &amp;&amp; goodword_ends) {</a>
<a name="ln4135">              int l;</a>
<a name="ln4136"> </a>
<a name="ln4137">              l = utfc_ptr2len(fword + sp-&gt;ts_fidx);</a>
<a name="ln4138">              if (fword_ends) {</a>
<a name="ln4139">                // Copy the skipped character to preword.</a>
<a name="ln4140">                memmove(preword + sp-&gt;ts_prewordlen,</a>
<a name="ln4141">                    fword + sp-&gt;ts_fidx, l);</a>
<a name="ln4142">                sp-&gt;ts_prewordlen += l;</a>
<a name="ln4143">                preword[sp-&gt;ts_prewordlen] = NUL;</a>
<a name="ln4144">              } else</a>
<a name="ln4145">                sp-&gt;ts_score -= SCORE_SPLIT - SCORE_SUBST;</a>
<a name="ln4146">              sp-&gt;ts_fidx += l;</a>
<a name="ln4147">            }</a>
<a name="ln4148"> </a>
<a name="ln4149">            // When compounding include compound flag in</a>
<a name="ln4150">            // compflags[] (already set above).  When splitting we</a>
<a name="ln4151">            // may start compounding over again.</a>
<a name="ln4152">            if (try_compound)</a>
<a name="ln4153">              ++sp-&gt;ts_complen;</a>
<a name="ln4154">            else</a>
<a name="ln4155">              sp-&gt;ts_compsplit = sp-&gt;ts_complen;</a>
<a name="ln4156">            sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln4157"> </a>
<a name="ln4158">            // set su-&gt;su_badflags to the caps type at this</a>
<a name="ln4159">            // position</a>
<a name="ln4160">            n = nofold_len(fword, sp-&gt;ts_fidx, su-&gt;su_badptr);</a>
<a name="ln4161">            su-&gt;su_badflags = badword_captype(su-&gt;su_badptr + n,</a>
<a name="ln4162">                su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln4163"> </a>
<a name="ln4164">            // Restart at top of the tree.</a>
<a name="ln4165">            sp-&gt;ts_arridx = 0;</a>
<a name="ln4166"> </a>
<a name="ln4167">            // If there are postponed prefixes, try these too.</a>
<a name="ln4168">            if (pbyts != NULL) {</a>
<a name="ln4169">              byts = pbyts;</a>
<a name="ln4170">              idxs = pidxs;</a>
<a name="ln4171">              sp-&gt;ts_prefixdepth = PFD_PREFIXTREE;</a>
<a name="ln4172">              PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4173">              sp-&gt;ts_state = STATE_NOPREFIX;</a>
<a name="ln4174">            }</a>
<a name="ln4175">          }</a>
<a name="ln4176">        }</a>
<a name="ln4177">      }</a>
<a name="ln4178">      break;</a>
<a name="ln4179"> </a>
<a name="ln4180">    case STATE_SPLITUNDO:</a>
<a name="ln4181">      // Undo the changes done for word split or compound word.</a>
<a name="ln4182">      su-&gt;su_badflags = sp-&gt;ts_save_badflags;</a>
<a name="ln4183"> </a>
<a name="ln4184">      // Continue looking for NUL bytes.</a>
<a name="ln4185">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4186">      sp-&gt;ts_state = STATE_START;</a>
<a name="ln4187"> </a>
<a name="ln4188">      // In case we went into the prefix tree.</a>
<a name="ln4189">      byts = fbyts;</a>
<a name="ln4190">      idxs = fidxs;</a>
<a name="ln4191">      break;</a>
<a name="ln4192"> </a>
<a name="ln4193">    case STATE_ENDNUL:</a>
<a name="ln4194">      // Past the NUL bytes in the node.</a>
<a name="ln4195">      su-&gt;su_badflags = sp-&gt;ts_save_badflags;</a>
<a name="ln4196">      if (fword[sp-&gt;ts_fidx] == NUL</a>
<a name="ln4197">          &amp;&amp; sp-&gt;ts_tcharlen == 0</a>
<a name="ln4198">          ) {</a>
<a name="ln4199">        // The badword ends, can't use STATE_PLAIN.</a>
<a name="ln4200">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4201">        sp-&gt;ts_state = STATE_DEL;</a>
<a name="ln4202">        break;</a>
<a name="ln4203">      }</a>
<a name="ln4204">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4205">      sp-&gt;ts_state = STATE_PLAIN;</a>
<a name="ln4206">      FALLTHROUGH;</a>
<a name="ln4207"> </a>
<a name="ln4208">    case STATE_PLAIN:</a>
<a name="ln4209">      // Go over all possible bytes at this node, add each to tword[]</a>
<a name="ln4210">      // and use child node.  &quot;ts_curi&quot; is the index.</a>
<a name="ln4211">      arridx = sp-&gt;ts_arridx;</a>
<a name="ln4212">      if (sp-&gt;ts_curi &gt; byts[arridx]) {</a>
<a name="ln4213">        // Done all bytes at this node, do next state.  When still at</a>
<a name="ln4214">        // already changed bytes skip the other tricks.</a>
<a name="ln4215">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4216">        if (sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry) {</a>
<a name="ln4217">          sp-&gt;ts_state = STATE_DEL;</a>
<a name="ln4218">        } else {</a>
<a name="ln4219">          sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4220">        }</a>
<a name="ln4221">      } else {</a>
<a name="ln4222">        arridx += sp-&gt;ts_curi++;</a>
<a name="ln4223">        c = byts[arridx];</a>
<a name="ln4224"> </a>
<a name="ln4225">        // Normal byte, go one level deeper.  If it's not equal to the</a>
<a name="ln4226">        // byte in the bad word adjust the score.  But don't even try</a>
<a name="ln4227">        // when the byte was already changed.  And don't try when we</a>
<a name="ln4228">        // just deleted this byte, accepting it is always cheaper than</a>
<a name="ln4229">        // delete + substitute.</a>
<a name="ln4230">        if (c == fword[sp-&gt;ts_fidx]</a>
<a name="ln4231">            || (sp-&gt;ts_tcharlen &gt; 0 &amp;&amp; sp-&gt;ts_isdiff != DIFF_NONE)</a>
<a name="ln4232">            )</a>
<a name="ln4233">          newscore = 0;</a>
<a name="ln4234">        else</a>
<a name="ln4235">          newscore = SCORE_SUBST;</a>
<a name="ln4236">        if ((newscore == 0</a>
<a name="ln4237">             || (sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry</a>
<a name="ln4238">                 &amp;&amp; ((sp-&gt;ts_flags &amp; TSF_DIDDEL) == 0</a>
<a name="ln4239">                     || c != fword[sp-&gt;ts_delidx])))</a>
<a name="ln4240">            &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4241">          go_deeper(stack, depth, newscore);</a>
<a name="ln4242">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4243">          if (newscore &gt; 0)</a>
<a name="ln4244">            sprintf(changename[depth], &quot;%.*s-%s: subst %c to %c&quot;,</a>
<a name="ln4245">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4246">                fword[sp-&gt;ts_fidx], c);</a>
<a name="ln4247">          else</a>
<a name="ln4248">            sprintf(changename[depth], &quot;%.*s-%s: accept %c&quot;,</a>
<a name="ln4249">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4250">                fword[sp-&gt;ts_fidx]);</a>
<a name="ln4251">#endif</a>
<a name="ln4252">          ++depth;</a>
<a name="ln4253">          sp = &amp;stack[depth];</a>
<a name="ln4254">          ++sp-&gt;ts_fidx;</a>
<a name="ln4255">          tword[sp-&gt;ts_twordlen++] = c;</a>
<a name="ln4256">          sp-&gt;ts_arridx = idxs[arridx];</a>
<a name="ln4257">          if (newscore == SCORE_SUBST) {</a>
<a name="ln4258">            sp-&gt;ts_isdiff = DIFF_YES;</a>
<a name="ln4259">          }</a>
<a name="ln4260">          // Multi-byte characters are a bit complicated to</a>
<a name="ln4261">          // handle: They differ when any of the bytes differ</a>
<a name="ln4262">          // and then their length may also differ.</a>
<a name="ln4263">          if (sp-&gt;ts_tcharlen == 0) {</a>
<a name="ln4264">            // First byte.</a>
<a name="ln4265">            sp-&gt;ts_tcharidx = 0;</a>
<a name="ln4266">            sp-&gt;ts_tcharlen = MB_BYTE2LEN(c);</a>
<a name="ln4267">            sp-&gt;ts_fcharstart = sp-&gt;ts_fidx - 1;</a>
<a name="ln4268">            sp-&gt;ts_isdiff = (newscore != 0)</a>
<a name="ln4269">                            ? DIFF_YES : DIFF_NONE;</a>
<a name="ln4270">          } else if (sp-&gt;ts_isdiff == DIFF_INSERT) {</a>
<a name="ln4271">            // When inserting trail bytes don't advance in the</a>
<a name="ln4272">            // bad word.</a>
<a name="ln4273">            sp-&gt;ts_fidx--;</a>
<a name="ln4274">          }</a>
<a name="ln4275">          if (++sp-&gt;ts_tcharidx == sp-&gt;ts_tcharlen) {</a>
<a name="ln4276">            // Last byte of character.</a>
<a name="ln4277">            if (sp-&gt;ts_isdiff == DIFF_YES) {</a>
<a name="ln4278">              // Correct ts_fidx for the byte length of the</a>
<a name="ln4279">              // character (we didn't check that before).</a>
<a name="ln4280">              sp-&gt;ts_fidx = sp-&gt;ts_fcharstart</a>
<a name="ln4281">                            + utfc_ptr2len(fword + sp-&gt;ts_fcharstart);</a>
<a name="ln4282"> </a>
<a name="ln4283">              // For changing a composing character adjust</a>
<a name="ln4284">              // the score from SCORE_SUBST to</a>
<a name="ln4285">              // SCORE_SUBCOMP.</a>
<a name="ln4286">              if (utf_iscomposing(utf_ptr2char(tword + sp-&gt;ts_twordlen</a>
<a name="ln4287">                                               - sp-&gt;ts_tcharlen))</a>
<a name="ln4288">                  &amp;&amp; utf_iscomposing(utf_ptr2char(fword</a>
<a name="ln4289">                                                  + sp-&gt;ts_fcharstart))) {</a>
<a name="ln4290">                sp-&gt;ts_score -= SCORE_SUBST - SCORE_SUBCOMP;</a>
<a name="ln4291">              } else if (</a>
<a name="ln4292">                  !soundfold</a>
<a name="ln4293">                  &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln4294">                  &amp;&amp; similar_chars(</a>
<a name="ln4295">                      slang,</a>
<a name="ln4296">                      utf_ptr2char(tword + sp-&gt;ts_twordlen - sp-&gt;ts_tcharlen),</a>
<a name="ln4297">                      utf_ptr2char(fword + sp-&gt;ts_fcharstart))) {</a>
<a name="ln4298">                // For a similar character adjust score from</a>
<a name="ln4299">                // SCORE_SUBST to SCORE_SIMILAR.</a>
<a name="ln4300">                sp-&gt;ts_score -= SCORE_SUBST - SCORE_SIMILAR;</a>
<a name="ln4301">              }</a>
<a name="ln4302">            } else if (sp-&gt;ts_isdiff == DIFF_INSERT</a>
<a name="ln4303">                       &amp;&amp; sp-&gt;ts_twordlen &gt; sp-&gt;ts_tcharlen) {</a>
<a name="ln4304">              p = tword + sp-&gt;ts_twordlen - sp-&gt;ts_tcharlen;</a>
<a name="ln4305">              c = utf_ptr2char(p);</a>
<a name="ln4306">              if (utf_iscomposing(c)) {</a>
<a name="ln4307">                // Inserting a composing char doesn't</a>
<a name="ln4308">                // count that much.</a>
<a name="ln4309">                sp-&gt;ts_score -= SCORE_INS - SCORE_INSCOMP;</a>
<a name="ln4310">              } else {</a>
<a name="ln4311">                // If the previous character was the same,</a>
<a name="ln4312">                // thus doubling a character, give a bonus</a>
<a name="ln4313">                // to the score.  Also for the soundfold</a>
<a name="ln4314">                // tree (might seem illogical but does</a>
<a name="ln4315">                // give better scores).</a>
<a name="ln4316">                MB_PTR_BACK(tword, p);</a>
<a name="ln4317">                if (c == utf_ptr2char(p)) {</a>
<a name="ln4318">                  sp-&gt;ts_score -= SCORE_INS - SCORE_INSDUP;</a>
<a name="ln4319">                }</a>
<a name="ln4320">              }</a>
<a name="ln4321">            }</a>
<a name="ln4322"> </a>
<a name="ln4323">            // Starting a new char, reset the length.</a>
<a name="ln4324">            sp-&gt;ts_tcharlen = 0;</a>
<a name="ln4325">          }</a>
<a name="ln4326">        }</a>
<a name="ln4327">      }</a>
<a name="ln4328">      break;</a>
<a name="ln4329"> </a>
<a name="ln4330">    case STATE_DEL:</a>
<a name="ln4331">      // When past the first byte of a multi-byte char don't try</a>
<a name="ln4332">      // delete/insert/swap a character.</a>
<a name="ln4333">      if (sp-&gt;ts_tcharlen &gt; 0) {</a>
<a name="ln4334">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4335">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4336">        break;</a>
<a name="ln4337">      }</a>
<a name="ln4338">      // Try skipping one character in the bad word (delete it).</a>
<a name="ln4339">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4340">      sp-&gt;ts_state = STATE_INS_PREP;</a>
<a name="ln4341">      sp-&gt;ts_curi = 1;</a>
<a name="ln4342">      if (soundfold &amp;&amp; sp-&gt;ts_fidx == 0 &amp;&amp; fword[sp-&gt;ts_fidx] == '*')</a>
<a name="ln4343">        // Deleting a vowel at the start of a word counts less, see</a>
<a name="ln4344">        // soundalike_score().</a>
<a name="ln4345">        newscore = 2 * SCORE_DEL / 3;</a>
<a name="ln4346">      else</a>
<a name="ln4347">        newscore = SCORE_DEL;</a>
<a name="ln4348">      if (fword[sp-&gt;ts_fidx] != NUL</a>
<a name="ln4349">          &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4350">        go_deeper(stack, depth, newscore);</a>
<a name="ln4351">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4352">        sprintf(changename[depth], &quot;%.*s-%s: delete %c&quot;,</a>
<a name="ln4353">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4354">            fword[sp-&gt;ts_fidx]);</a>
<a name="ln4355">#endif</a>
<a name="ln4356">        ++depth;</a>
<a name="ln4357"> </a>
<a name="ln4358">        // Remember what character we deleted, so that we can avoid</a>
<a name="ln4359">        // inserting it again.</a>
<a name="ln4360">        stack[depth].ts_flags |= TSF_DIDDEL;</a>
<a name="ln4361">        stack[depth].ts_delidx = sp-&gt;ts_fidx;</a>
<a name="ln4362"> </a>
<a name="ln4363">        // Advance over the character in fword[].  Give a bonus to the</a>
<a name="ln4364">        // score if the same character is following &quot;nn&quot; -&gt; &quot;n&quot;.  It's</a>
<a name="ln4365">        // a bit illogical for soundfold tree but it does give better</a>
<a name="ln4366">        // results.</a>
<a name="ln4367">        c = utf_ptr2char(fword + sp-&gt;ts_fidx);</a>
<a name="ln4368">        stack[depth].ts_fidx += utfc_ptr2len(fword + sp-&gt;ts_fidx);</a>
<a name="ln4369">        if (utf_iscomposing(c)) {</a>
<a name="ln4370">          stack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;</a>
<a name="ln4371">        } else if (c == utf_ptr2char(fword + stack[depth].ts_fidx)) {</a>
<a name="ln4372">          stack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;</a>
<a name="ln4373">        }</a>
<a name="ln4374"> </a>
<a name="ln4375">        break;</a>
<a name="ln4376">      }</a>
<a name="ln4377">      FALLTHROUGH;</a>
<a name="ln4378"> </a>
<a name="ln4379">    case STATE_INS_PREP:</a>
<a name="ln4380">      if (sp-&gt;ts_flags &amp; TSF_DIDDEL) {</a>
<a name="ln4381">        // If we just deleted a byte then inserting won't make sense,</a>
<a name="ln4382">        // a substitute is always cheaper.</a>
<a name="ln4383">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4384">        sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln4385">        break;</a>
<a name="ln4386">      }</a>
<a name="ln4387"> </a>
<a name="ln4388">      // skip over NUL bytes</a>
<a name="ln4389">      n = sp-&gt;ts_arridx;</a>
<a name="ln4390">      for (;; ) {</a>
<a name="ln4391">        if (sp-&gt;ts_curi &gt; byts[n]) {</a>
<a name="ln4392">          // Only NUL bytes at this node, go to next state.</a>
<a name="ln4393">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4394">          sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln4395">          break;</a>
<a name="ln4396">        }</a>
<a name="ln4397">        if (byts[n + sp-&gt;ts_curi] != NUL) {</a>
<a name="ln4398">          // Found a byte to insert.</a>
<a name="ln4399">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4400">          sp-&gt;ts_state = STATE_INS;</a>
<a name="ln4401">          break;</a>
<a name="ln4402">        }</a>
<a name="ln4403">        ++sp-&gt;ts_curi;</a>
<a name="ln4404">      }</a>
<a name="ln4405">      break;</a>
<a name="ln4406"> </a>
<a name="ln4407">    case STATE_INS:</a>
<a name="ln4408">      // Insert one byte.  Repeat this for each possible byte at this</a>
<a name="ln4409">      // node.</a>
<a name="ln4410">      n = sp-&gt;ts_arridx;</a>
<a name="ln4411">      if (sp-&gt;ts_curi &gt; byts[n]) {</a>
<a name="ln4412">        // Done all bytes at this node, go to next state.</a>
<a name="ln4413">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4414">        sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln4415">        break;</a>
<a name="ln4416">      }</a>
<a name="ln4417"> </a>
<a name="ln4418">      // Do one more byte at this node, but:</a>
<a name="ln4419">      // - Skip NUL bytes.</a>
<a name="ln4420">      // - Skip the byte if it's equal to the byte in the word,</a>
<a name="ln4421">      //   accepting that byte is always better.</a>
<a name="ln4422">      n += sp-&gt;ts_curi++;</a>
<a name="ln4423">      c = byts[n];</a>
<a name="ln4424">      if (soundfold &amp;&amp; sp-&gt;ts_twordlen == 0 &amp;&amp; c == '*')</a>
<a name="ln4425">        // Inserting a vowel at the start of a word counts less,</a>
<a name="ln4426">        // see soundalike_score().</a>
<a name="ln4427">        newscore = 2 * SCORE_INS / 3;</a>
<a name="ln4428">      else</a>
<a name="ln4429">        newscore = SCORE_INS;</a>
<a name="ln4430">      if (c != fword[sp-&gt;ts_fidx]</a>
<a name="ln4431">          &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4432">        go_deeper(stack, depth, newscore);</a>
<a name="ln4433">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4434">        sprintf(changename[depth], &quot;%.*s-%s: insert %c&quot;,</a>
<a name="ln4435">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4436">            c);</a>
<a name="ln4437">#endif</a>
<a name="ln4438">        ++depth;</a>
<a name="ln4439">        sp = &amp;stack[depth];</a>
<a name="ln4440">        tword[sp-&gt;ts_twordlen++] = c;</a>
<a name="ln4441">        sp-&gt;ts_arridx = idxs[n];</a>
<a name="ln4442">        fl = MB_BYTE2LEN(c);</a>
<a name="ln4443">        if (fl &gt; 1) {</a>
<a name="ln4444">          // There are following bytes for the same character.</a>
<a name="ln4445">          // We must find all bytes before trying</a>
<a name="ln4446">          // delete/insert/swap/etc.</a>
<a name="ln4447">          sp-&gt;ts_tcharlen = fl;</a>
<a name="ln4448">          sp-&gt;ts_tcharidx = 1;</a>
<a name="ln4449">          sp-&gt;ts_isdiff = DIFF_INSERT;</a>
<a name="ln4450">        }</a>
<a name="ln4451">        if (fl == 1) {</a>
<a name="ln4452">          // If the previous character was the same, thus doubling a</a>
<a name="ln4453">          // character, give a bonus to the score.  Also for</a>
<a name="ln4454">          // soundfold words (illogical but does give a better</a>
<a name="ln4455">          // score).</a>
<a name="ln4456">          if (sp-&gt;ts_twordlen &gt;= 2</a>
<a name="ln4457">              &amp;&amp; tword[sp-&gt;ts_twordlen - 2] == c)</a>
<a name="ln4458">            sp-&gt;ts_score -= SCORE_INS - SCORE_INSDUP;</a>
<a name="ln4459">        }</a>
<a name="ln4460">      }</a>
<a name="ln4461">      break;</a>
<a name="ln4462"> </a>
<a name="ln4463">    case STATE_SWAP:</a>
<a name="ln4464">      // Swap two bytes in the bad word: &quot;12&quot; -&gt; &quot;21&quot;.</a>
<a name="ln4465">      // We change &quot;fword&quot; here, it's changed back afterwards at</a>
<a name="ln4466">      // STATE_UNSWAP.</a>
<a name="ln4467">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4468">      c = *p;</a>
<a name="ln4469">      if (c == NUL) {</a>
<a name="ln4470">        // End of word, can't swap or replace.</a>
<a name="ln4471">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4472">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4473">        break;</a>
<a name="ln4474">      }</a>
<a name="ln4475"> </a>
<a name="ln4476">      // Don't swap if the first character is not a word character.</a>
<a name="ln4477">      // SWAP3 etc. also don't make sense then.</a>
<a name="ln4478">      if (!soundfold &amp;&amp; !spell_iswordp(p, curwin)) {</a>
<a name="ln4479">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4480">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4481">        break;</a>
<a name="ln4482">      }</a>
<a name="ln4483"> </a>
<a name="ln4484">      n = MB_CPTR2LEN(p);</a>
<a name="ln4485">      c = utf_ptr2char(p);</a>
<a name="ln4486">      if (p[n] == NUL) {</a>
<a name="ln4487">        c2 = NUL;</a>
<a name="ln4488">      } else if (!soundfold &amp;&amp; !spell_iswordp(p + n, curwin)) {</a>
<a name="ln4489">        c2 = c;  // don't swap non-word char</a>
<a name="ln4490">      } else {</a>
<a name="ln4491">        c2 = utf_ptr2char(p + n);</a>
<a name="ln4492">      }</a>
<a name="ln4493"> </a>
<a name="ln4494">      // When the second character is NUL we can't swap.</a>
<a name="ln4495">      if (c2 == NUL) {</a>
<a name="ln4496">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4497">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4498">        break;</a>
<a name="ln4499">      }</a>
<a name="ln4500"> </a>
<a name="ln4501">      // When characters are identical, swap won't do anything.</a>
<a name="ln4502">      // Also get here if the second char is not a word character.</a>
<a name="ln4503">      if (c == c2) {</a>
<a name="ln4504">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4505">        sp-&gt;ts_state = STATE_SWAP3;</a>
<a name="ln4506">        break;</a>
<a name="ln4507">      }</a>
<a name="ln4508">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP)) {</a>
<a name="ln4509">        go_deeper(stack, depth, SCORE_SWAP);</a>
<a name="ln4510">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4511">        snprintf(changename[depth], sizeof(changename[0]),</a>
<a name="ln4512">                 &quot;%.*s-%s: swap %c and %c&quot;,</a>
<a name="ln4513">                 sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4514">                 c, c2);</a>
<a name="ln4515">#endif</a>
<a name="ln4516">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4517">        sp-&gt;ts_state = STATE_UNSWAP;</a>
<a name="ln4518">        depth++;</a>
<a name="ln4519">        fl = mb_char2len(c2);</a>
<a name="ln4520">        memmove(p, p + n, fl);</a>
<a name="ln4521">        utf_char2bytes(c, p + fl);</a>
<a name="ln4522">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + fl;</a>
<a name="ln4523">      } else {</a>
<a name="ln4524">        // If this swap doesn't work then SWAP3 won't either.</a>
<a name="ln4525">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4526">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4527">      }</a>
<a name="ln4528">      break;</a>
<a name="ln4529"> </a>
<a name="ln4530">    case STATE_UNSWAP:</a>
<a name="ln4531">      // Undo the STATE_SWAP swap: &quot;21&quot; -&gt; &quot;12&quot;.</a>
<a name="ln4532">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4533">      n = utfc_ptr2len(p);</a>
<a name="ln4534">      c = utf_ptr2char(p + n);</a>
<a name="ln4535">      memmove(p + utfc_ptr2len(p + n), p, n);</a>
<a name="ln4536">      utf_char2bytes(c, p);</a>
<a name="ln4537"> </a>
<a name="ln4538">      FALLTHROUGH;</a>
<a name="ln4539"> </a>
<a name="ln4540">    case STATE_SWAP3:</a>
<a name="ln4541">      // Swap two bytes, skipping one: &quot;123&quot; -&gt; &quot;321&quot;.  We change</a>
<a name="ln4542">      // &quot;fword&quot; here, it's changed back afterwards at STATE_UNSWAP3.</a>
<a name="ln4543">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4544">      n = MB_CPTR2LEN(p);</a>
<a name="ln4545">      c = utf_ptr2char(p);</a>
<a name="ln4546">      fl = MB_CPTR2LEN(p + n);</a>
<a name="ln4547">      c2 = utf_ptr2char(p + n);</a>
<a name="ln4548">      if (!soundfold &amp;&amp; !spell_iswordp(p + n + fl, curwin)) {</a>
<a name="ln4549">        c3 = c;  // don't swap non-word char</a>
<a name="ln4550">      } else {</a>
<a name="ln4551">        c3 = utf_ptr2char(p + n + fl);</a>
<a name="ln4552">      }</a>
<a name="ln4553"> </a>
<a name="ln4554">      // When characters are identical: &quot;121&quot; then SWAP3 result is</a>
<a name="ln4555">      // identical, ROT3L result is same as SWAP: &quot;211&quot;, ROT3L result is</a>
<a name="ln4556">      // same as SWAP on next char: &quot;112&quot;.  Thus skip all swapping.</a>
<a name="ln4557">      // Also skip when c3 is NUL.</a>
<a name="ln4558">      // Also get here when the third character is not a word character.</a>
<a name="ln4559">      // Second character may any char: &quot;a.b&quot; -&gt; &quot;b.a&quot;</a>
<a name="ln4560">      if (c == c3 || c3 == NUL) {</a>
<a name="ln4561">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4562">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4563">        break;</a>
<a name="ln4564">      }</a>
<a name="ln4565">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln4566">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln4567">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4568">        sprintf(changename[depth], &quot;%.*s-%s: swap3 %c and %c&quot;,</a>
<a name="ln4569">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4570">            c, c3);</a>
<a name="ln4571">#endif</a>
<a name="ln4572">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4573">        sp-&gt;ts_state = STATE_UNSWAP3;</a>
<a name="ln4574">        depth++;</a>
<a name="ln4575">        tl = mb_char2len(c3);</a>
<a name="ln4576">        memmove(p, p + n + fl, tl);</a>
<a name="ln4577">        utf_char2bytes(c2, p + tl);</a>
<a name="ln4578">        utf_char2bytes(c, p + fl + tl);</a>
<a name="ln4579">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + fl + tl;</a>
<a name="ln4580">      } else {</a>
<a name="ln4581">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4582">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4583">      }</a>
<a name="ln4584">      break;</a>
<a name="ln4585"> </a>
<a name="ln4586">    case STATE_UNSWAP3:</a>
<a name="ln4587">      // Undo STATE_SWAP3: &quot;321&quot; -&gt; &quot;123&quot;</a>
<a name="ln4588">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4589">      n = utfc_ptr2len(p);</a>
<a name="ln4590">      c2 = utf_ptr2char(p + n);</a>
<a name="ln4591">      fl = utfc_ptr2len(p + n);</a>
<a name="ln4592">      c = utf_ptr2char(p + n + fl);</a>
<a name="ln4593">      tl = utfc_ptr2len(p + n + fl);</a>
<a name="ln4594">      memmove(p + fl + tl, p, n);</a>
<a name="ln4595">      utf_char2bytes(c, p);</a>
<a name="ln4596">      utf_char2bytes(c2, p + tl);</a>
<a name="ln4597">      p = p + tl;</a>
<a name="ln4598"> </a>
<a name="ln4599">      if (!soundfold &amp;&amp; !spell_iswordp(p, curwin)) {</a>
<a name="ln4600">        // Middle char is not a word char, skip the rotate.  First and</a>
<a name="ln4601">        // third char were already checked at swap and swap3.</a>
<a name="ln4602">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4603">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4604">        break;</a>
<a name="ln4605">      }</a>
<a name="ln4606"> </a>
<a name="ln4607">      // Rotate three characters left: &quot;123&quot; -&gt; &quot;231&quot;.  We change</a>
<a name="ln4608">      // &quot;fword&quot; here, it's changed back afterwards at STATE_UNROT3L.</a>
<a name="ln4609">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln4610">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln4611">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4612">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4613">        sprintf(changename[depth], &quot;%.*s-%s: rotate left %c%c%c&quot;,</a>
<a name="ln4614">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4615">            p[0], p[1], p[2]);</a>
<a name="ln4616">#endif</a>
<a name="ln4617">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4618">        sp-&gt;ts_state = STATE_UNROT3L;</a>
<a name="ln4619">        ++depth;</a>
<a name="ln4620">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4621">        n = MB_CPTR2LEN(p);</a>
<a name="ln4622">        c = utf_ptr2char(p);</a>
<a name="ln4623">        fl = MB_CPTR2LEN(p + n);</a>
<a name="ln4624">        fl += MB_CPTR2LEN(p + n + fl);</a>
<a name="ln4625">        memmove(p, p + n, fl);</a>
<a name="ln4626">        utf_char2bytes(c, p + fl);</a>
<a name="ln4627">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + fl;</a>
<a name="ln4628">      } else {</a>
<a name="ln4629">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4630">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4631">      }</a>
<a name="ln4632">      break;</a>
<a name="ln4633"> </a>
<a name="ln4634">    case STATE_UNROT3L:</a>
<a name="ln4635">      // Undo ROT3L: &quot;231&quot; -&gt; &quot;123&quot;</a>
<a name="ln4636">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4637">      n = utfc_ptr2len(p);</a>
<a name="ln4638">      n += utfc_ptr2len(p + n);</a>
<a name="ln4639">      c = utf_ptr2char(p + n);</a>
<a name="ln4640">      tl = utfc_ptr2len(p + n);</a>
<a name="ln4641">      memmove(p + tl, p, n);</a>
<a name="ln4642">      utf_char2bytes(c, p);</a>
<a name="ln4643"> </a>
<a name="ln4644">      // Rotate three bytes right: &quot;123&quot; -&gt; &quot;312&quot;.  We change &quot;fword&quot;</a>
<a name="ln4645">      // here, it's changed back afterwards at STATE_UNROT3R.</a>
<a name="ln4646">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln4647">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln4648">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4649">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4650">        sprintf(changename[depth], &quot;%.*s-%s: rotate right %c%c%c&quot;,</a>
<a name="ln4651">            sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4652">            p[0], p[1], p[2]);</a>
<a name="ln4653">#endif</a>
<a name="ln4654">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4655">        sp-&gt;ts_state = STATE_UNROT3R;</a>
<a name="ln4656">        ++depth;</a>
<a name="ln4657">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4658">        n = MB_CPTR2LEN(p);</a>
<a name="ln4659">        n += MB_CPTR2LEN(p + n);</a>
<a name="ln4660">        c = utf_ptr2char(p + n);</a>
<a name="ln4661">        tl = MB_CPTR2LEN(p + n);</a>
<a name="ln4662">        memmove(p + tl, p, n);</a>
<a name="ln4663">        utf_char2bytes(c, p);</a>
<a name="ln4664">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + tl;</a>
<a name="ln4665">      } else {</a>
<a name="ln4666">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4667">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4668">      }</a>
<a name="ln4669">      break;</a>
<a name="ln4670"> </a>
<a name="ln4671">    case STATE_UNROT3R:</a>
<a name="ln4672">      // Undo ROT3R: &quot;312&quot; -&gt; &quot;123&quot;</a>
<a name="ln4673">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4674">      c = utf_ptr2char(p);</a>
<a name="ln4675">      tl = utfc_ptr2len(p);</a>
<a name="ln4676">      n = utfc_ptr2len(p + tl);</a>
<a name="ln4677">      n += utfc_ptr2len(p + tl + n);</a>
<a name="ln4678">      memmove(p, p + tl, n);</a>
<a name="ln4679">      utf_char2bytes(c, p + n);</a>
<a name="ln4680"> </a>
<a name="ln4681">      FALLTHROUGH;</a>
<a name="ln4682"> </a>
<a name="ln4683">    case STATE_REP_INI:</a>
<a name="ln4684">      // Check if matching with REP items from the .aff file would work.</a>
<a name="ln4685">      // Quickly skip if:</a>
<a name="ln4686">      // - there are no REP items and we are not in the soundfold trie</a>
<a name="ln4687">      // - the score is going to be too high anyway</a>
<a name="ln4688">      // - already applied a REP item or swapped here</a>
<a name="ln4689">      if ((lp-&gt;lp_replang == NULL &amp;&amp; !soundfold)</a>
<a name="ln4690">          || sp-&gt;ts_score + SCORE_REP &gt;= su-&gt;su_maxscore</a>
<a name="ln4691">          || sp-&gt;ts_fidx &lt; sp-&gt;ts_fidxtry) {</a>
<a name="ln4692">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4693">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4694">        break;</a>
<a name="ln4695">      }</a>
<a name="ln4696"> </a>
<a name="ln4697">      // Use the first byte to quickly find the first entry that may</a>
<a name="ln4698">      // match.  If the index is -1 there is none.</a>
<a name="ln4699">      if (soundfold)</a>
<a name="ln4700">        sp-&gt;ts_curi = slang-&gt;sl_repsal_first[fword[sp-&gt;ts_fidx]];</a>
<a name="ln4701">      else</a>
<a name="ln4702">        sp-&gt;ts_curi = lp-&gt;lp_replang-&gt;sl_rep_first[fword[sp-&gt;ts_fidx]];</a>
<a name="ln4703"> </a>
<a name="ln4704">      if (sp-&gt;ts_curi &lt; 0) {</a>
<a name="ln4705">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4706">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4707">        break;</a>
<a name="ln4708">      }</a>
<a name="ln4709"> </a>
<a name="ln4710">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4711">      sp-&gt;ts_state = STATE_REP;</a>
<a name="ln4712">      FALLTHROUGH;</a>
<a name="ln4713"> </a>
<a name="ln4714">    case STATE_REP:</a>
<a name="ln4715">      // Try matching with REP items from the .aff file.  For each match</a>
<a name="ln4716">      // replace the characters and check if the resulting word is</a>
<a name="ln4717">      // valid.</a>
<a name="ln4718">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4719"> </a>
<a name="ln4720">      if (soundfold)</a>
<a name="ln4721">        gap = &amp;slang-&gt;sl_repsal;</a>
<a name="ln4722">      else</a>
<a name="ln4723">        gap = &amp;lp-&gt;lp_replang-&gt;sl_rep;</a>
<a name="ln4724">      while (sp-&gt;ts_curi &lt; gap-&gt;ga_len) {</a>
<a name="ln4725">        ftp = (fromto_T *)gap-&gt;ga_data + sp-&gt;ts_curi++;</a>
<a name="ln4726">        if (*ftp-&gt;ft_from != *p) {</a>
<a name="ln4727">          // past possible matching entries</a>
<a name="ln4728">          sp-&gt;ts_curi = gap-&gt;ga_len;</a>
<a name="ln4729">          break;</a>
<a name="ln4730">        }</a>
<a name="ln4731">        if (STRNCMP(ftp-&gt;ft_from, p, STRLEN(ftp-&gt;ft_from)) == 0</a>
<a name="ln4732">            &amp;&amp; TRY_DEEPER(su, stack, depth, SCORE_REP)) {</a>
<a name="ln4733">          go_deeper(stack, depth, SCORE_REP);</a>
<a name="ln4734">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4735">          sprintf(changename[depth], &quot;%.*s-%s: replace %s with %s&quot;,</a>
<a name="ln4736">              sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4737">              ftp-&gt;ft_from, ftp-&gt;ft_to);</a>
<a name="ln4738">#endif</a>
<a name="ln4739">          // Need to undo this afterwards.</a>
<a name="ln4740">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4741">          sp-&gt;ts_state = STATE_REP_UNDO;</a>
<a name="ln4742"> </a>
<a name="ln4743">          // Change the &quot;from&quot; to the &quot;to&quot; string.</a>
<a name="ln4744">          ++depth;</a>
<a name="ln4745">          fl = (int)STRLEN(ftp-&gt;ft_from);</a>
<a name="ln4746">          tl = (int)STRLEN(ftp-&gt;ft_to);</a>
<a name="ln4747">          if (fl != tl) {</a>
<a name="ln4748">            STRMOVE(p + tl, p + fl);</a>
<a name="ln4749">            repextra += tl - fl;</a>
<a name="ln4750">          }</a>
<a name="ln4751">          memmove(p, ftp-&gt;ft_to, tl);</a>
<a name="ln4752">          stack[depth].ts_fidxtry = sp-&gt;ts_fidx + tl;</a>
<a name="ln4753">          stack[depth].ts_tcharlen = 0;</a>
<a name="ln4754">          break;</a>
<a name="ln4755">        }</a>
<a name="ln4756">      }</a>
<a name="ln4757"> </a>
<a name="ln4758">      if (sp-&gt;ts_curi &gt;= gap-&gt;ga_len &amp;&amp; sp-&gt;ts_state == STATE_REP)</a>
<a name="ln4759">        // No (more) matches.</a>
<a name="ln4760">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4761">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4762"> </a>
<a name="ln4763">      break;</a>
<a name="ln4764"> </a>
<a name="ln4765">    case STATE_REP_UNDO:</a>
<a name="ln4766">      // Undo a REP replacement and continue with the next one.</a>
<a name="ln4767">      if (soundfold)</a>
<a name="ln4768">        gap = &amp;slang-&gt;sl_repsal;</a>
<a name="ln4769">      else</a>
<a name="ln4770">        gap = &amp;lp-&gt;lp_replang-&gt;sl_rep;</a>
<a name="ln4771">      ftp = (fromto_T *)gap-&gt;ga_data + sp-&gt;ts_curi - 1;</a>
<a name="ln4772">      fl = (int)STRLEN(ftp-&gt;ft_from);</a>
<a name="ln4773">      tl = (int)STRLEN(ftp-&gt;ft_to);</a>
<a name="ln4774">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4775">      if (fl != tl) {</a>
<a name="ln4776">        STRMOVE(p + fl, p + tl);</a>
<a name="ln4777">        repextra -= tl - fl;</a>
<a name="ln4778">      }</a>
<a name="ln4779">      memmove(p, ftp-&gt;ft_from, fl);</a>
<a name="ln4780">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4781">      sp-&gt;ts_state = STATE_REP;</a>
<a name="ln4782">      break;</a>
<a name="ln4783"> </a>
<a name="ln4784">    default:</a>
<a name="ln4785">      // Did all possible states at this level, go up one level.</a>
<a name="ln4786">      --depth;</a>
<a name="ln4787"> </a>
<a name="ln4788">      if (depth &gt;= 0 &amp;&amp; stack[depth].ts_prefixdepth == PFD_PREFIXTREE) {</a>
<a name="ln4789">        // Continue in or go back to the prefix tree.</a>
<a name="ln4790">        byts = pbyts;</a>
<a name="ln4791">        idxs = pidxs;</a>
<a name="ln4792">      }</a>
<a name="ln4793"> </a>
<a name="ln4794">      // Don't check for CTRL-C too often, it takes time.</a>
<a name="ln4795">      if (--breakcheckcount == 0) {</a>
<a name="ln4796">        os_breakcheck();</a>
<a name="ln4797">        breakcheckcount = 1000;</a>
<a name="ln4798">      }</a>
<a name="ln4799">    }</a>
<a name="ln4800">  }</a>
<a name="ln4801">}</a>
<a name="ln4802"> </a>
<a name="ln4803"> </a>
<a name="ln4804">// Go one level deeper in the tree.</a>
<a name="ln4805">static void go_deeper(trystate_T *stack, int depth, int score_add)</a>
<a name="ln4806">{</a>
<a name="ln4807">  stack[depth + 1] = stack[depth];</a>
<a name="ln4808">  stack[depth + 1].ts_state = STATE_START;</a>
<a name="ln4809">  stack[depth + 1].ts_score = stack[depth].ts_score + score_add;</a>
<a name="ln4810">  stack[depth + 1].ts_curi = 1;         // start just after length byte</a>
<a name="ln4811">  stack[depth + 1].ts_flags = 0;</a>
<a name="ln4812">}</a>
<a name="ln4813"> </a>
<a name="ln4814">// Case-folding may change the number of bytes: Count nr of chars in</a>
<a name="ln4815">// fword[flen] and return the byte length of that many chars in &quot;word&quot;.</a>
<a name="ln4816">static int nofold_len(char_u *fword, int flen, char_u *word)</a>
<a name="ln4817">{</a>
<a name="ln4818">  char_u      *p;</a>
<a name="ln4819">  int i = 0;</a>
<a name="ln4820"> </a>
<a name="ln4821">  for (p = fword; p &lt; fword + flen; MB_PTR_ADV(p)) {</a>
<a name="ln4822">    i++;</a>
<a name="ln4823">  }</a>
<a name="ln4824">  for (p = word; i &gt; 0; MB_PTR_ADV(p)) {</a>
<a name="ln4825">    i--;</a>
<a name="ln4826">  }</a>
<a name="ln4827">  return (int)(p - word);</a>
<a name="ln4828">}</a>
<a name="ln4829"> </a>
<a name="ln4830">// &quot;fword&quot; is a good word with case folded.  Find the matching keep-case</a>
<a name="ln4831">// words and put it in &quot;kword&quot;.</a>
<a name="ln4832">// Theoretically there could be several keep-case words that result in the</a>
<a name="ln4833">// same case-folded word, but we only find one...</a>
<a name="ln4834">static void find_keepcap_word(slang_T *slang, char_u *fword, char_u *kword)</a>
<a name="ln4835">{</a>
<a name="ln4836">  char_u uword[MAXWLEN];                // &quot;fword&quot; in upper-case</a>
<a name="ln4837">  int depth;</a>
<a name="ln4838">  idx_T tryidx;</a>
<a name="ln4839"> </a>
<a name="ln4840">  // The following arrays are used at each depth in the tree.</a>
<a name="ln4841">  idx_T arridx[MAXWLEN];</a>
<a name="ln4842">  int round[MAXWLEN];</a>
<a name="ln4843">  int fwordidx[MAXWLEN];</a>
<a name="ln4844">  int uwordidx[MAXWLEN];</a>
<a name="ln4845">  int kwordlen[MAXWLEN];</a>
<a name="ln4846"> </a>
<a name="ln4847">  int flen, ulen;</a>
<a name="ln4848">  int l;</a>
<a name="ln4849">  int len;</a>
<a name="ln4850">  int c;</a>
<a name="ln4851">  idx_T lo, hi, m;</a>
<a name="ln4852">  char_u      *p;</a>
<a name="ln4853">  char_u      *byts = slang-&gt;sl_kbyts;      // array with bytes of the words</a>
<a name="ln4854">  idx_T       *idxs = slang-&gt;sl_kidxs;      // array with indexes</a>
<a name="ln4855"> </a>
<a name="ln4856">  if (byts == NULL) {</a>
<a name="ln4857">    // array is empty: &quot;cannot happen&quot;</a>
<a name="ln4858">    *kword = NUL;</a>
<a name="ln4859">    return;</a>
<a name="ln4860">  }</a>
<a name="ln4861"> </a>
<a name="ln4862">  // Make an all-cap version of &quot;fword&quot;.</a>
<a name="ln4863">  allcap_copy(fword, uword);</a>
<a name="ln4864"> </a>
<a name="ln4865">  // Each character needs to be tried both case-folded and upper-case.</a>
<a name="ln4866">  // All this gets very complicated if we keep in mind that changing case</a>
<a name="ln4867">  // may change the byte length of a multi-byte character...</a>
<a name="ln4868">  depth = 0;</a>
<a name="ln4869">  arridx[0] = 0;</a>
<a name="ln4870">  round[0] = 0;</a>
<a name="ln4871">  fwordidx[0] = 0;</a>
<a name="ln4872">  uwordidx[0] = 0;</a>
<a name="ln4873">  kwordlen[0] = 0;</a>
<a name="ln4874">  while (depth &gt;= 0) {</a>
<a name="ln4875">    if (fword[fwordidx[depth]] == NUL) {</a>
<a name="ln4876">      // We are at the end of &quot;fword&quot;.  If the tree allows a word to end</a>
<a name="ln4877">      // here we have found a match.</a>
<a name="ln4878">      if (byts[arridx[depth] + 1] == 0) {</a>
<a name="ln4879">        kword[kwordlen[depth]] = NUL;</a>
<a name="ln4880">        return;</a>
<a name="ln4881">      }</a>
<a name="ln4882"> </a>
<a name="ln4883">      // kword is getting too long, continue one level up</a>
<a name="ln4884">      --depth;</a>
<a name="ln4885">    } else if (++round[depth] &gt; 2)   {</a>
<a name="ln4886">      // tried both fold-case and upper-case character, continue one</a>
<a name="ln4887">      // level up</a>
<a name="ln4888">      --depth;</a>
<a name="ln4889">    } else {</a>
<a name="ln4890">      // round[depth] == 1: Try using the folded-case character.</a>
<a name="ln4891">      // round[depth] == 2: Try using the upper-case character.</a>
<a name="ln4892">      flen = MB_CPTR2LEN(fword + fwordidx[depth]);</a>
<a name="ln4893">      ulen = MB_CPTR2LEN(uword + uwordidx[depth]);</a>
<a name="ln4894">      if (round[depth] == 1) {</a>
<a name="ln4895">        p = fword + fwordidx[depth];</a>
<a name="ln4896">        l = flen;</a>
<a name="ln4897">      } else {</a>
<a name="ln4898">        p = uword + uwordidx[depth];</a>
<a name="ln4899">        l = ulen;</a>
<a name="ln4900">      }</a>
<a name="ln4901"> </a>
<a name="ln4902">      for (tryidx = arridx[depth]; l &gt; 0; --l) {</a>
<a name="ln4903">        // Perform a binary search in the list of accepted bytes.</a>
<a name="ln4904">        len = byts[tryidx++];</a>
<a name="ln4905">        c = *p++;</a>
<a name="ln4906">        lo = tryidx;</a>
<a name="ln4907">        hi = tryidx + len - 1;</a>
<a name="ln4908">        while (lo &lt; hi) {</a>
<a name="ln4909">          m = (lo + hi) / 2;</a>
<a name="ln4910">          if (byts[m] &gt; c)</a>
<a name="ln4911">            hi = m - 1;</a>
<a name="ln4912">          else if (byts[m] &lt; c)</a>
<a name="ln4913">            lo = m + 1;</a>
<a name="ln4914">          else {</a>
<a name="ln4915">            lo = hi = m;</a>
<a name="ln4916">            break;</a>
<a name="ln4917">          }</a>
<a name="ln4918">        }</a>
<a name="ln4919"> </a>
<a name="ln4920">        // Stop if there is no matching byte.</a>
<a name="ln4921">        if (hi &lt; lo || byts[lo] != c)</a>
<a name="ln4922">          break;</a>
<a name="ln4923"> </a>
<a name="ln4924">        // Continue at the child (if there is one).</a>
<a name="ln4925">        tryidx = idxs[lo];</a>
<a name="ln4926">      }</a>
<a name="ln4927"> </a>
<a name="ln4928">      if (l == 0) {</a>
<a name="ln4929">        // Found the matching char.  Copy it to &quot;kword&quot; and go a</a>
<a name="ln4930">        // level deeper.</a>
<a name="ln4931">        if (round[depth] == 1) {</a>
<a name="ln4932">          STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],</a>
<a name="ln4933">              flen);</a>
<a name="ln4934">          kwordlen[depth + 1] = kwordlen[depth] + flen;</a>
<a name="ln4935">        } else {</a>
<a name="ln4936">          STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],</a>
<a name="ln4937">              ulen);</a>
<a name="ln4938">          kwordlen[depth + 1] = kwordlen[depth] + ulen;</a>
<a name="ln4939">        }</a>
<a name="ln4940">        fwordidx[depth + 1] = fwordidx[depth] + flen;</a>
<a name="ln4941">        uwordidx[depth + 1] = uwordidx[depth] + ulen;</a>
<a name="ln4942"> </a>
<a name="ln4943">        ++depth;</a>
<a name="ln4944">        arridx[depth] = tryidx;</a>
<a name="ln4945">        round[depth] = 0;</a>
<a name="ln4946">      }</a>
<a name="ln4947">    }</a>
<a name="ln4948">  }</a>
<a name="ln4949"> </a>
<a name="ln4950">  // Didn't find it: &quot;cannot happen&quot;.</a>
<a name="ln4951">  *kword = NUL;</a>
<a name="ln4952">}</a>
<a name="ln4953"> </a>
<a name="ln4954">// Compute the sound-a-like score for suggestions in su-&gt;su_ga and add them to</a>
<a name="ln4955">// su-&gt;su_sga.</a>
<a name="ln4956">static void score_comp_sal(suginfo_T *su)</a>
<a name="ln4957">{</a>
<a name="ln4958">  langp_T     *lp;</a>
<a name="ln4959">  char_u badsound[MAXWLEN];</a>
<a name="ln4960">  int i;</a>
<a name="ln4961">  suggest_T   *stp;</a>
<a name="ln4962">  suggest_T   *sstp;</a>
<a name="ln4963">  int score;</a>
<a name="ln4964"> </a>
<a name="ln4965">  ga_grow(&amp;su-&gt;su_sga, su-&gt;su_ga.ga_len);</a>
<a name="ln4966"> </a>
<a name="ln4967">  // Use the sound-folding of the first language that supports it.</a>
<a name="ln4968">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln4969">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln4970">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln4971">      // soundfold the bad word</a>
<a name="ln4972">      spell_soundfold(lp-&gt;lp_slang, su-&gt;su_fbadword, true, badsound);</a>
<a name="ln4973"> </a>
<a name="ln4974">      for (i = 0; i &lt; su-&gt;su_ga.ga_len; ++i) {</a>
<a name="ln4975">        stp = &amp;SUG(su-&gt;su_ga, i);</a>
<a name="ln4976"> </a>
<a name="ln4977">        // Case-fold the suggested word, sound-fold it and compute the</a>
<a name="ln4978">        // sound-a-like score.</a>
<a name="ln4979">        score = stp_sal_score(stp, su, lp-&gt;lp_slang, badsound);</a>
<a name="ln4980">        if (score &lt; SCORE_MAXMAX) {</a>
<a name="ln4981">          // Add the suggestion.</a>
<a name="ln4982">          sstp = &amp;SUG(su-&gt;su_sga, su-&gt;su_sga.ga_len);</a>
<a name="ln4983">          sstp-&gt;st_word = vim_strsave(stp-&gt;st_word);</a>
<a name="ln4984">          sstp-&gt;st_wordlen = stp-&gt;st_wordlen;</a>
<a name="ln4985">          sstp-&gt;st_score = score;</a>
<a name="ln4986">          sstp-&gt;st_altscore = 0;</a>
<a name="ln4987">          sstp-&gt;st_orglen = stp-&gt;st_orglen;</a>
<a name="ln4988">          ++su-&gt;su_sga.ga_len;</a>
<a name="ln4989">        }</a>
<a name="ln4990">      }</a>
<a name="ln4991">      break;</a>
<a name="ln4992">    }</a>
<a name="ln4993">  }</a>
<a name="ln4994">}</a>
<a name="ln4995"> </a>
<a name="ln4996">// Combine the list of suggestions in su-&gt;su_ga and su-&gt;su_sga.</a>
<a name="ln4997">// They are entwined.</a>
<a name="ln4998">static void score_combine(suginfo_T *su)</a>
<a name="ln4999">{</a>
<a name="ln5000">  garray_T ga;</a>
<a name="ln5001">  garray_T    *gap;</a>
<a name="ln5002">  langp_T     *lp;</a>
<a name="ln5003">  suggest_T   *stp;</a>
<a name="ln5004">  char_u      *p;</a>
<a name="ln5005">  char_u badsound[MAXWLEN];</a>
<a name="ln5006">  int round;</a>
<a name="ln5007">  slang_T     *slang = NULL;</a>
<a name="ln5008"> </a>
<a name="ln5009">  // Add the alternate score to su_ga.</a>
<a name="ln5010">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5011">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5012">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln5013">      // soundfold the bad word</a>
<a name="ln5014">      slang = lp-&gt;lp_slang;</a>
<a name="ln5015">      spell_soundfold(slang, su-&gt;su_fbadword, true, badsound);</a>
<a name="ln5016"> </a>
<a name="ln5017">      for (int i = 0; i &lt; su-&gt;su_ga.ga_len; ++i) {</a>
<a name="ln5018">        stp = &amp;SUG(su-&gt;su_ga, i);</a>
<a name="ln5019">        stp-&gt;st_altscore = stp_sal_score(stp, su, slang, badsound);</a>
<a name="ln5020">        if (stp-&gt;st_altscore == SCORE_MAXMAX)</a>
<a name="ln5021">          stp-&gt;st_score = (stp-&gt;st_score * 3 + SCORE_BIG) / 4;</a>
<a name="ln5022">        else</a>
<a name="ln5023">          stp-&gt;st_score = (stp-&gt;st_score * 3</a>
<a name="ln5024">                           + stp-&gt;st_altscore) / 4;</a>
<a name="ln5025">        stp-&gt;st_salscore = false;</a>
<a name="ln5026">      }</a>
<a name="ln5027">      break;</a>
<a name="ln5028">    }</a>
<a name="ln5029">  }</a>
<a name="ln5030"> </a>
<a name="ln5031">  if (slang == NULL) {  // Using &quot;double&quot; without sound folding.</a>
<a name="ln5032">    (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore,</a>
<a name="ln5033">        su-&gt;su_maxcount);</a>
<a name="ln5034">    return;</a>
<a name="ln5035">  }</a>
<a name="ln5036"> </a>
<a name="ln5037">  // Add the alternate score to su_sga.</a>
<a name="ln5038">  for (int i = 0; i &lt; su-&gt;su_sga.ga_len; ++i) {</a>
<a name="ln5039">    stp = &amp;SUG(su-&gt;su_sga, i);</a>
<a name="ln5040">    stp-&gt;st_altscore = spell_edit_score(slang,</a>
<a name="ln5041">        su-&gt;su_badword, stp-&gt;st_word);</a>
<a name="ln5042">    if (stp-&gt;st_score == SCORE_MAXMAX)</a>
<a name="ln5043">      stp-&gt;st_score = (SCORE_BIG * 7 + stp-&gt;st_altscore) / 8;</a>
<a name="ln5044">    else</a>
<a name="ln5045">      stp-&gt;st_score = (stp-&gt;st_score * 7 + stp-&gt;st_altscore) / 8;</a>
<a name="ln5046">    stp-&gt;st_salscore = true;</a>
<a name="ln5047">  }</a>
<a name="ln5048"> </a>
<a name="ln5049">  // Remove bad suggestions, sort the suggestions and truncate at &quot;maxcount&quot;</a>
<a name="ln5050">  // for both lists.</a>
<a name="ln5051">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln5052">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln5053">  check_suggestions(su, &amp;su-&gt;su_sga);</a>
<a name="ln5054">  (void)cleanup_suggestions(&amp;su-&gt;su_sga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln5055"> </a>
<a name="ln5056">  ga_init(&amp;ga, (int)sizeof(suginfo_T), 1);</a>
<a name="ln5057">  ga_grow(&amp;ga, su-&gt;su_ga.ga_len + su-&gt;su_sga.ga_len);</a>
<a name="ln5058"> </a>
<a name="ln5059">  stp = &amp;SUG(ga, 0);</a>
<a name="ln5060">  for (int i = 0; i &lt; su-&gt;su_ga.ga_len || i &lt; su-&gt;su_sga.ga_len; ++i) {</a>
<a name="ln5061">    // round 1: get a suggestion from su_ga</a>
<a name="ln5062">    // round 2: get a suggestion from su_sga</a>
<a name="ln5063">    for (round = 1; round &lt;= 2; ++round) {</a>
<a name="ln5064">      gap = round == 1 ? &amp;su-&gt;su_ga : &amp;su-&gt;su_sga;</a>
<a name="ln5065">      if (i &lt; gap-&gt;ga_len) {</a>
<a name="ln5066">        // Don't add a word if it's already there.</a>
<a name="ln5067">        p = SUG(*gap, i).st_word;</a>
<a name="ln5068">        int j;</a>
<a name="ln5069">        for (j = 0; j &lt; ga.ga_len; ++j)</a>
<a name="ln5070">          if (STRCMP(stp[j].st_word, p) == 0)</a>
<a name="ln5071">            break;</a>
<a name="ln5072">        if (j == ga.ga_len)</a>
<a name="ln5073">          stp[ga.ga_len++] = SUG(*gap, i);</a>
<a name="ln5074">        else</a>
<a name="ln5075">          xfree(p);</a>
<a name="ln5076">      }</a>
<a name="ln5077">    }</a>
<a name="ln5078">  }</a>
<a name="ln5079"> </a>
<a name="ln5080">  ga_clear(&amp;su-&gt;su_ga);</a>
<a name="ln5081">  ga_clear(&amp;su-&gt;su_sga);</a>
<a name="ln5082"> </a>
<a name="ln5083">  // Truncate the list to the number of suggestions that will be displayed.</a>
<a name="ln5084">  if (ga.ga_len &gt; su-&gt;su_maxcount) {</a>
<a name="ln5085">    for (int i = su-&gt;su_maxcount; i &lt; ga.ga_len; ++i) {</a>
<a name="ln5086">      xfree(stp[i].st_word);</a>
<a name="ln5087">    }</a>
<a name="ln5088">    ga.ga_len = su-&gt;su_maxcount;</a>
<a name="ln5089">  }</a>
<a name="ln5090"> </a>
<a name="ln5091">  su-&gt;su_ga = ga;</a>
<a name="ln5092">}</a>
<a name="ln5093"> </a>
<a name="ln5094">// For the goodword in &quot;stp&quot; compute the soundalike score compared to the</a>
<a name="ln5095">// badword.</a>
<a name="ln5096">static int</a>
<a name="ln5097">stp_sal_score (</a>
<a name="ln5098">    suggest_T *stp,</a>
<a name="ln5099">    suginfo_T *su,</a>
<a name="ln5100">    slang_T *slang,</a>
<a name="ln5101">    char_u *badsound          // sound-folded badword</a>
<a name="ln5102">)</a>
<a name="ln5103">{</a>
<a name="ln5104">  char_u      *p;</a>
<a name="ln5105">  char_u      *pbad;</a>
<a name="ln5106">  char_u      *pgood;</a>
<a name="ln5107">  char_u badsound2[MAXWLEN];</a>
<a name="ln5108">  char_u fword[MAXWLEN];</a>
<a name="ln5109">  char_u goodsound[MAXWLEN];</a>
<a name="ln5110">  char_u goodword[MAXWLEN];</a>
<a name="ln5111">  int lendiff;</a>
<a name="ln5112"> </a>
<a name="ln5113">  lendiff = su-&gt;su_badlen - stp-&gt;st_orglen;</a>
<a name="ln5114">  if (lendiff &gt;= 0)</a>
<a name="ln5115">    pbad = badsound;</a>
<a name="ln5116">  else {</a>
<a name="ln5117">    // soundfold the bad word with more characters following</a>
<a name="ln5118">    (void)spell_casefold(curwin, su-&gt;su_badptr, stp-&gt;st_orglen, fword, MAXWLEN);</a>
<a name="ln5119"> </a>
<a name="ln5120">    // When joining two words the sound often changes a lot.  E.g., &quot;t he&quot;</a>
<a name="ln5121">    // sounds like &quot;t h&quot; while &quot;the&quot; sounds like &quot;@&quot;.  Avoid that by</a>
<a name="ln5122">    // removing the space.  Don't do it when the good word also contains a</a>
<a name="ln5123">    // space.</a>
<a name="ln5124">    if (ascii_iswhite(su-&gt;su_badptr[su-&gt;su_badlen])</a>
<a name="ln5125">        &amp;&amp; *skiptowhite(stp-&gt;st_word) == NUL)</a>
<a name="ln5126">      for (p = fword; *(p = skiptowhite(p)) != NUL; )</a>
<a name="ln5127">        STRMOVE(p, p + 1);</a>
<a name="ln5128"> </a>
<a name="ln5129">    spell_soundfold(slang, fword, true, badsound2);</a>
<a name="ln5130">    pbad = badsound2;</a>
<a name="ln5131">  }</a>
<a name="ln5132"> </a>
<a name="ln5133">  if (lendiff &gt; 0 &amp;&amp; stp-&gt;st_wordlen + lendiff &lt; MAXWLEN) {</a>
<a name="ln5134">    // Add part of the bad word to the good word, so that we soundfold</a>
<a name="ln5135">    // what replaces the bad word.</a>
<a name="ln5136">    STRCPY(goodword, stp-&gt;st_word);</a>
<a name="ln5137">    STRLCPY(goodword + stp-&gt;st_wordlen,</a>
<a name="ln5138">        su-&gt;su_badptr + su-&gt;su_badlen - lendiff, lendiff + 1);</a>
<a name="ln5139">    pgood = goodword;</a>
<a name="ln5140">  } else</a>
<a name="ln5141">    pgood = stp-&gt;st_word;</a>
<a name="ln5142"> </a>
<a name="ln5143">  // Sound-fold the word and compute the score for the difference.</a>
<a name="ln5144">  spell_soundfold(slang, pgood, false, goodsound);</a>
<a name="ln5145"> </a>
<a name="ln5146">  return soundalike_score(goodsound, pbad);</a>
<a name="ln5147">}</a>
<a name="ln5148"> </a>
<a name="ln5149">static sftword_T dumsft;</a>
<a name="ln5150">#define HIKEY2SFT(p)  ((sftword_T *)(p - (dumsft.sft_word - (char_u *)&amp;dumsft)))</a>
<a name="ln5151">#define HI2SFT(hi)     HIKEY2SFT((hi)-&gt;hi_key)</a>
<a name="ln5152"> </a>
<a name="ln5153">// Prepare for calling suggest_try_soundalike().</a>
<a name="ln5154">static void suggest_try_soundalike_prep(void)</a>
<a name="ln5155">{</a>
<a name="ln5156">  langp_T     *lp;</a>
<a name="ln5157">  slang_T     *slang;</a>
<a name="ln5158"> </a>
<a name="ln5159">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln5160">  // .sug file has been loaded.</a>
<a name="ln5161">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5162">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5163">    slang = lp-&gt;lp_slang;</a>
<a name="ln5164">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL)</a>
<a name="ln5165">      // prepare the hashtable used by add_sound_suggest()</a>
<a name="ln5166">      hash_init(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln5167">  }</a>
<a name="ln5168">}</a>
<a name="ln5169"> </a>
<a name="ln5170">// Find suggestions by comparing the word in a sound-a-like form.</a>
<a name="ln5171">// Note: This doesn't support postponed prefixes.</a>
<a name="ln5172">static void suggest_try_soundalike(suginfo_T *su)</a>
<a name="ln5173">{</a>
<a name="ln5174">  char_u salword[MAXWLEN];</a>
<a name="ln5175">  langp_T     *lp;</a>
<a name="ln5176">  slang_T     *slang;</a>
<a name="ln5177"> </a>
<a name="ln5178">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln5179">  // .sug file has been loaded.</a>
<a name="ln5180">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5181">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5182">    slang = lp-&gt;lp_slang;</a>
<a name="ln5183">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln5184">      // soundfold the bad word</a>
<a name="ln5185">      spell_soundfold(slang, su-&gt;su_fbadword, true, salword);</a>
<a name="ln5186"> </a>
<a name="ln5187">      // try all kinds of inserts/deletes/swaps/etc.</a>
<a name="ln5188">      // TODO: also soundfold the next words, so that we can try joining</a>
<a name="ln5189">      // and splitting</a>
<a name="ln5190">#ifdef SUGGEST_PROFILE</a>
<a name="ln5191">      prof_init();</a>
<a name="ln5192">#endif</a>
<a name="ln5193">      suggest_trie_walk(su, lp, salword, true);</a>
<a name="ln5194">#ifdef SUGGEST_PROFILE</a>
<a name="ln5195">      prof_report(&quot;soundalike&quot;);</a>
<a name="ln5196">#endif</a>
<a name="ln5197">    }</a>
<a name="ln5198">  }</a>
<a name="ln5199">}</a>
<a name="ln5200"> </a>
<a name="ln5201">// Finish up after calling suggest_try_soundalike().</a>
<a name="ln5202">static void suggest_try_soundalike_finish(void)</a>
<a name="ln5203">{</a>
<a name="ln5204">  langp_T     *lp;</a>
<a name="ln5205">  slang_T     *slang;</a>
<a name="ln5206">  int todo;</a>
<a name="ln5207">  hashitem_T  *hi;</a>
<a name="ln5208"> </a>
<a name="ln5209">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln5210">  // .sug file has been loaded.</a>
<a name="ln5211">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5212">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5213">    slang = lp-&gt;lp_slang;</a>
<a name="ln5214">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln5215">      // Free the info about handled words.</a>
<a name="ln5216">      todo = (int)slang-&gt;sl_sounddone.ht_used;</a>
<a name="ln5217">      for (hi = slang-&gt;sl_sounddone.ht_array; todo &gt; 0; ++hi)</a>
<a name="ln5218">        if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln5219">          xfree(HI2SFT(hi));</a>
<a name="ln5220">          --todo;</a>
<a name="ln5221">        }</a>
<a name="ln5222"> </a>
<a name="ln5223">      // Clear the hashtable, it may also be used by another region.</a>
<a name="ln5224">      hash_clear(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln5225">      hash_init(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln5226">    }</a>
<a name="ln5227">  }</a>
<a name="ln5228">}</a>
<a name="ln5229"> </a>
<a name="ln5230">// A match with a soundfolded word is found.  Add the good word(s) that</a>
<a name="ln5231">// produce this soundfolded word.</a>
<a name="ln5232">static void</a>
<a name="ln5233">add_sound_suggest (</a>
<a name="ln5234">    suginfo_T *su,</a>
<a name="ln5235">    char_u *goodword,</a>
<a name="ln5236">    int score,                      // soundfold score</a>
<a name="ln5237">    langp_T *lp</a>
<a name="ln5238">)</a>
<a name="ln5239">{</a>
<a name="ln5240">  slang_T     *slang = lp-&gt;lp_slang;    // language for sound folding</a>
<a name="ln5241">  int sfwordnr;</a>
<a name="ln5242">  char_u      *nrline;</a>
<a name="ln5243">  int orgnr;</a>
<a name="ln5244">  char_u theword[MAXWLEN];</a>
<a name="ln5245">  int i;</a>
<a name="ln5246">  int wlen;</a>
<a name="ln5247">  char_u      *byts;</a>
<a name="ln5248">  idx_T       *idxs;</a>
<a name="ln5249">  int n;</a>
<a name="ln5250">  int wordcount;</a>
<a name="ln5251">  int wc;</a>
<a name="ln5252">  int goodscore;</a>
<a name="ln5253">  hash_T hash;</a>
<a name="ln5254">  hashitem_T  *hi;</a>
<a name="ln5255">  sftword_T   *sft;</a>
<a name="ln5256">  int bc, gc;</a>
<a name="ln5257">  int limit;</a>
<a name="ln5258"> </a>
<a name="ln5259">  // It's very well possible that the same soundfold word is found several</a>
<a name="ln5260">  // times with different scores.  Since the following is quite slow only do</a>
<a name="ln5261">  // the words that have a better score than before.  Use a hashtable to</a>
<a name="ln5262">  // remember the words that have been done.</a>
<a name="ln5263">  hash = hash_hash(goodword);</a>
<a name="ln5264">  const size_t goodword_len = STRLEN(goodword);</a>
<a name="ln5265">  hi = hash_lookup(&amp;slang-&gt;sl_sounddone, (const char *)goodword, goodword_len,</a>
<a name="ln5266">                   hash);</a>
<a name="ln5267">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5268">    sft = xmalloc(sizeof(sftword_T) + goodword_len);</a>
<a name="ln5269">    sft-&gt;sft_score = score;</a>
<a name="ln5270">    memcpy(sft-&gt;sft_word, goodword, goodword_len + 1);</a>
<a name="ln5271">    hash_add_item(&amp;slang-&gt;sl_sounddone, hi, sft-&gt;sft_word, hash);</a>
<a name="ln5272">  } else {</a>
<a name="ln5273">    sft = HI2SFT(hi);</a>
<a name="ln5274">    if (score &gt;= sft-&gt;sft_score)</a>
<a name="ln5275">      return;</a>
<a name="ln5276">    sft-&gt;sft_score = score;</a>
<a name="ln5277">  }</a>
<a name="ln5278"> </a>
<a name="ln5279">  // Find the word nr in the soundfold tree.</a>
<a name="ln5280">  sfwordnr = soundfold_find(slang, goodword);</a>
<a name="ln5281">  if (sfwordnr &lt; 0) {</a>
<a name="ln5282">    internal_error(&quot;add_sound_suggest()&quot;);</a>
<a name="ln5283">    return;</a>
<a name="ln5284">  }</a>
<a name="ln5285"> </a>
<a name="ln5286">  // Go over the list of good words that produce this soundfold word</a>
<a name="ln5287">  nrline = ml_get_buf(slang-&gt;sl_sugbuf, (linenr_T)sfwordnr + 1, false);</a>
<a name="ln5288">  orgnr = 0;</a>
<a name="ln5289">  while (*nrline != NUL) {</a>
<a name="ln5290">    // The wordnr was stored in a minimal nr of bytes as an offset to the</a>
<a name="ln5291">    // previous wordnr.</a>
<a name="ln5292">    orgnr += bytes2offset(&amp;nrline);</a>
<a name="ln5293"> </a>
<a name="ln5294">    byts = slang-&gt;sl_fbyts;</a>
<a name="ln5295">    idxs = slang-&gt;sl_fidxs;</a>
<a name="ln5296"> </a>
<a name="ln5297">    // Lookup the word &quot;orgnr&quot; one of the two tries.</a>
<a name="ln5298">    n = 0;</a>
<a name="ln5299">    wordcount = 0;</a>
<a name="ln5300">    for (wlen = 0; wlen &lt; MAXWLEN - 3; ++wlen) {</a>
<a name="ln5301">      i = 1;</a>
<a name="ln5302">      if (wordcount == orgnr &amp;&amp; byts[n + 1] == NUL)</a>
<a name="ln5303">        break;          // found end of word</a>
<a name="ln5304"> </a>
<a name="ln5305">      if (byts[n + 1] == NUL)</a>
<a name="ln5306">        ++wordcount;</a>
<a name="ln5307"> </a>
<a name="ln5308">      // skip over the NUL bytes</a>
<a name="ln5309">      for (; byts[n + i] == NUL; ++i)</a>
<a name="ln5310">        if (i &gt; byts[n]) {              // safety check</a>
<a name="ln5311">          STRCPY(theword + wlen, &quot;BAD&quot;);</a>
<a name="ln5312">          wlen += 3;</a>
<a name="ln5313">          goto badword;</a>
<a name="ln5314">        }</a>
<a name="ln5315"> </a>
<a name="ln5316">      // One of the siblings must have the word.</a>
<a name="ln5317">      for (; i &lt; byts[n]; ++i) {</a>
<a name="ln5318">        wc = idxs[idxs[n + i]];         // nr of words under this byte</a>
<a name="ln5319">        if (wordcount + wc &gt; orgnr)</a>
<a name="ln5320">          break;</a>
<a name="ln5321">        wordcount += wc;</a>
<a name="ln5322">      }</a>
<a name="ln5323"> </a>
<a name="ln5324">      theword[wlen] = byts[n + i];</a>
<a name="ln5325">      n = idxs[n + i];</a>
<a name="ln5326">    }</a>
<a name="ln5327">badword:</a>
<a name="ln5328">    theword[wlen] = NUL;</a>
<a name="ln5329"> </a>
<a name="ln5330">    // Go over the possible flags and regions.</a>
<a name="ln5331">    for (; i &lt;= byts[n] &amp;&amp; byts[n + i] == NUL; ++i) {</a>
<a name="ln5332">      char_u cword[MAXWLEN];</a>
<a name="ln5333">      char_u      *p;</a>
<a name="ln5334">      int flags = (int)idxs[n + i];</a>
<a name="ln5335"> </a>
<a name="ln5336">      // Skip words with the NOSUGGEST flag</a>
<a name="ln5337">      if (flags &amp; WF_NOSUGGEST)</a>
<a name="ln5338">        continue;</a>
<a name="ln5339"> </a>
<a name="ln5340">      if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln5341">        // Must find the word in the keep-case tree.</a>
<a name="ln5342">        find_keepcap_word(slang, theword, cword);</a>
<a name="ln5343">        p = cword;</a>
<a name="ln5344">      } else {</a>
<a name="ln5345">        flags |= su-&gt;su_badflags;</a>
<a name="ln5346">        if ((flags &amp; WF_CAPMASK) != 0) {</a>
<a name="ln5347">          // Need to fix case according to &quot;flags&quot;.</a>
<a name="ln5348">          make_case_word(theword, cword, flags);</a>
<a name="ln5349">          p = cword;</a>
<a name="ln5350">        } else</a>
<a name="ln5351">          p = theword;</a>
<a name="ln5352">      }</a>
<a name="ln5353"> </a>
<a name="ln5354">      // Add the suggestion.</a>
<a name="ln5355">      if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln5356">        // Add the suggestion if the score isn't too bad.</a>
<a name="ln5357">        if (score &lt;= su-&gt;su_maxscore)</a>
<a name="ln5358">          add_suggestion(su, &amp;su-&gt;su_sga, p, su-&gt;su_badlen,</a>
<a name="ln5359">              score, 0, false, slang, false);</a>
<a name="ln5360">      } else {</a>
<a name="ln5361">        // Add a penalty for words in another region.</a>
<a name="ln5362">        if ((flags &amp; WF_REGION)</a>
<a name="ln5363">            &amp;&amp; (((unsigned)flags &gt;&gt; 16) &amp; lp-&gt;lp_region) == 0)</a>
<a name="ln5364">          goodscore = SCORE_REGION;</a>
<a name="ln5365">        else</a>
<a name="ln5366">          goodscore = 0;</a>
<a name="ln5367"> </a>
<a name="ln5368">        // Add a small penalty for changing the first letter from</a>
<a name="ln5369">        // lower to upper case.  Helps for &quot;tath&quot; -&gt; &quot;Kath&quot;, which is</a>
<a name="ln5370">        // less common than &quot;tath&quot; -&gt; &quot;path&quot;.  Don't do it when the</a>
<a name="ln5371">        // letter is the same, that has already been counted.</a>
<a name="ln5372">        gc = PTR2CHAR(p);</a>
<a name="ln5373">        if (SPELL_ISUPPER(gc)) {</a>
<a name="ln5374">          bc = PTR2CHAR(su-&gt;su_badword);</a>
<a name="ln5375">          if (!SPELL_ISUPPER(bc)</a>
<a name="ln5376">              &amp;&amp; SPELL_TOFOLD(bc) != SPELL_TOFOLD(gc))</a>
<a name="ln5377">            goodscore += SCORE_ICASE / 2;</a>
<a name="ln5378">        }</a>
<a name="ln5379"> </a>
<a name="ln5380">        // Compute the score for the good word.  This only does letter</a>
<a name="ln5381">        // insert/delete/swap/replace.  REP items are not considered,</a>
<a name="ln5382">        // which may make the score a bit higher.</a>
<a name="ln5383">        // Use a limit for the score to make it work faster.  Use</a>
<a name="ln5384">        // MAXSCORE(), because RESCORE() will change the score.</a>
<a name="ln5385">        // If the limit is very high then the iterative method is</a>
<a name="ln5386">        // inefficient, using an array is quicker.</a>
<a name="ln5387">        limit = MAXSCORE(su-&gt;su_sfmaxscore - goodscore, score);</a>
<a name="ln5388">        if (limit &gt; SCORE_LIMITMAX)</a>
<a name="ln5389">          goodscore += spell_edit_score(slang, su-&gt;su_badword, p);</a>
<a name="ln5390">        else</a>
<a name="ln5391">          goodscore += spell_edit_score_limit(slang, su-&gt;su_badword,</a>
<a name="ln5392">              p, limit);</a>
<a name="ln5393"> </a>
<a name="ln5394">        // When going over the limit don't bother to do the rest.</a>
<a name="ln5395">        if (goodscore &lt; SCORE_MAXMAX) {</a>
<a name="ln5396">          // Give a bonus to words seen before.</a>
<a name="ln5397">          goodscore = score_wordcount_adj(slang, goodscore, p, false);</a>
<a name="ln5398"> </a>
<a name="ln5399">          // Add the suggestion if the score isn't too bad.</a>
<a name="ln5400">          goodscore = RESCORE(goodscore, score);</a>
<a name="ln5401">          if (goodscore &lt;= su-&gt;su_sfmaxscore)</a>
<a name="ln5402">            add_suggestion(su, &amp;su-&gt;su_ga, p, su-&gt;su_badlen,</a>
<a name="ln5403">                goodscore, score, true, slang, true);</a>
<a name="ln5404">        }</a>
<a name="ln5405">      }</a>
<a name="ln5406">    }</a>
<a name="ln5407">  }</a>
<a name="ln5408">}</a>
<a name="ln5409"> </a>
<a name="ln5410">// Find word &quot;word&quot; in fold-case tree for &quot;slang&quot; and return the word number.</a>
<a name="ln5411">static int soundfold_find(slang_T *slang, char_u *word)</a>
<a name="ln5412">{</a>
<a name="ln5413">  idx_T arridx = 0;</a>
<a name="ln5414">  int len;</a>
<a name="ln5415">  int wlen = 0;</a>
<a name="ln5416">  int c;</a>
<a name="ln5417">  char_u      *ptr = word;</a>
<a name="ln5418">  char_u      *byts;</a>
<a name="ln5419">  idx_T       *idxs;</a>
<a name="ln5420">  int wordnr = 0;</a>
<a name="ln5421"> </a>
<a name="ln5422">  byts = slang-&gt;sl_sbyts;</a>
<a name="ln5423">  idxs = slang-&gt;sl_sidxs;</a>
<a name="ln5424"> </a>
<a name="ln5425">  for (;; ) {</a>
<a name="ln5426">    // First byte is the number of possible bytes.</a>
<a name="ln5427">    len = byts[arridx++];</a>
<a name="ln5428"> </a>
<a name="ln5429">    // If the first possible byte is a zero the word could end here.</a>
<a name="ln5430">    // If the word ends we found the word.  If not skip the NUL bytes.</a>
<a name="ln5431">    c = ptr[wlen];</a>
<a name="ln5432">    if (byts[arridx] == NUL) {</a>
<a name="ln5433">      if (c == NUL)</a>
<a name="ln5434">        break;</a>
<a name="ln5435"> </a>
<a name="ln5436">      // Skip over the zeros, there can be several.</a>
<a name="ln5437">      while (len &gt; 0 &amp;&amp; byts[arridx] == NUL) {</a>
<a name="ln5438">        ++arridx;</a>
<a name="ln5439">        --len;</a>
<a name="ln5440">      }</a>
<a name="ln5441">      if (len == 0)</a>
<a name="ln5442">        return -1;            // no children, word should have ended here</a>
<a name="ln5443">      ++wordnr;</a>
<a name="ln5444">    }</a>
<a name="ln5445"> </a>
<a name="ln5446">    // If the word ends we didn't find it.</a>
<a name="ln5447">    if (c == NUL)</a>
<a name="ln5448">      return -1;</a>
<a name="ln5449"> </a>
<a name="ln5450">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln5451">    if (c == TAB)           // &lt;Tab&gt; is handled like &lt;Space&gt;</a>
<a name="ln5452">      c = ' ';</a>
<a name="ln5453">    while (byts[arridx] &lt; c) {</a>
<a name="ln5454">      // The word count is in the first idxs[] entry of the child.</a>
<a name="ln5455">      wordnr += idxs[idxs[arridx]];</a>
<a name="ln5456">      ++arridx;</a>
<a name="ln5457">      if (--len == 0)           // end of the bytes, didn't find it</a>
<a name="ln5458">        return -1;</a>
<a name="ln5459">    }</a>
<a name="ln5460">    if (byts[arridx] != c)      // didn't find the byte</a>
<a name="ln5461">      return -1;</a>
<a name="ln5462"> </a>
<a name="ln5463">    // Continue at the child (if there is one).</a>
<a name="ln5464">    arridx = idxs[arridx];</a>
<a name="ln5465">    ++wlen;</a>
<a name="ln5466"> </a>
<a name="ln5467">    // One space in the good word may stand for several spaces in the</a>
<a name="ln5468">    // checked word.</a>
<a name="ln5469">    if (c == ' ')</a>
<a name="ln5470">      while (ptr[wlen] == ' ' || ptr[wlen] == TAB)</a>
<a name="ln5471">        ++wlen;</a>
<a name="ln5472">  }</a>
<a name="ln5473"> </a>
<a name="ln5474">  return wordnr;</a>
<a name="ln5475">}</a>
<a name="ln5476"> </a>
<a name="ln5477">// Copy &quot;fword&quot; to &quot;cword&quot;, fixing case according to &quot;flags&quot;.</a>
<a name="ln5478">static void make_case_word(char_u *fword, char_u *cword, int flags)</a>
<a name="ln5479">{</a>
<a name="ln5480">  if (flags &amp; WF_ALLCAP)</a>
<a name="ln5481">    // Make it all upper-case</a>
<a name="ln5482">    allcap_copy(fword, cword);</a>
<a name="ln5483">  else if (flags &amp; WF_ONECAP)</a>
<a name="ln5484">    // Make the first letter upper-case</a>
<a name="ln5485">    onecap_copy(fword, cword, true);</a>
<a name="ln5486">  else</a>
<a name="ln5487">    // Use goodword as-is.</a>
<a name="ln5488">    STRCPY(cword, fword);</a>
<a name="ln5489">}</a>
<a name="ln5490"> </a>
<a name="ln5491">// Returns true if &quot;c1&quot; and &quot;c2&quot; are similar characters according to the MAP</a>
<a name="ln5492">// lines in the .aff file.</a>
<a name="ln5493">static bool similar_chars(slang_T *slang, int c1, int c2)</a>
<a name="ln5494">{</a>
<a name="ln5495">  int m1, m2;</a>
<a name="ln5496">  char_u buf[MB_MAXBYTES + 1];</a>
<a name="ln5497">  hashitem_T  *hi;</a>
<a name="ln5498"> </a>
<a name="ln5499">  if (c1 &gt;= 256) {</a>
<a name="ln5500">    buf[utf_char2bytes(c1, buf)] = 0;</a>
<a name="ln5501">    hi = hash_find(&amp;slang-&gt;sl_map_hash, buf);</a>
<a name="ln5502">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5503">      m1 = 0;</a>
<a name="ln5504">    } else {</a>
<a name="ln5505">      m1 = utf_ptr2char(hi-&gt;hi_key + STRLEN(hi-&gt;hi_key) + 1);</a>
<a name="ln5506">    }</a>
<a name="ln5507">  } else {</a>
<a name="ln5508">    m1 = slang-&gt;sl_map_array[c1];</a>
<a name="ln5509">  }</a>
<a name="ln5510">  if (m1 == 0) {</a>
<a name="ln5511">    return false;</a>
<a name="ln5512">  }</a>
<a name="ln5513"> </a>
<a name="ln5514">  if (c2 &gt;= 256) {</a>
<a name="ln5515">    buf[utf_char2bytes(c2, buf)] = 0;</a>
<a name="ln5516">    hi = hash_find(&amp;slang-&gt;sl_map_hash, buf);</a>
<a name="ln5517">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5518">      m2 = 0;</a>
<a name="ln5519">    } else {</a>
<a name="ln5520">      m2 = utf_ptr2char(hi-&gt;hi_key + STRLEN(hi-&gt;hi_key) + 1);</a>
<a name="ln5521">    }</a>
<a name="ln5522">  } else {</a>
<a name="ln5523">    m2 = slang-&gt;sl_map_array[c2];</a>
<a name="ln5524">  }</a>
<a name="ln5525"> </a>
<a name="ln5526">  return m1 == m2;</a>
<a name="ln5527">}</a>
<a name="ln5528"> </a>
<a name="ln5529">// Adds a suggestion to the list of suggestions.</a>
<a name="ln5530">// For a suggestion that is already in the list the lowest score is remembered.</a>
<a name="ln5531">static void</a>
<a name="ln5532">add_suggestion (</a>
<a name="ln5533">    suginfo_T *su,</a>
<a name="ln5534">    garray_T *gap,              // either su_ga or su_sga</a>
<a name="ln5535">    const char_u *goodword,</a>
<a name="ln5536">    int badlenarg,              // len of bad word replaced with &quot;goodword&quot;</a>
<a name="ln5537">    int score,</a>
<a name="ln5538">    int altscore,</a>
<a name="ln5539">    bool had_bonus,             // value for st_had_bonus</a>
<a name="ln5540">    slang_T *slang,             // language for sound folding</a>
<a name="ln5541">    bool maxsf                  // su_maxscore applies to soundfold score,</a>
<a name="ln5542">                                // su_sfmaxscore to the total score.</a>
<a name="ln5543">)</a>
<a name="ln5544">{</a>
<a name="ln5545">  int goodlen;                  // len of goodword changed</a>
<a name="ln5546">  int badlen;                   // len of bad word changed</a>
<a name="ln5547">  suggest_T   *stp;</a>
<a name="ln5548">  suggest_T new_sug;</a>
<a name="ln5549"> </a>
<a name="ln5550">  // Minimize &quot;badlen&quot; for consistency.  Avoids that changing &quot;the the&quot; to</a>
<a name="ln5551">  // &quot;thee the&quot; is added next to changing the first &quot;the&quot; the &quot;thee&quot;.</a>
<a name="ln5552">  const char_u *pgood = goodword + STRLEN(goodword);</a>
<a name="ln5553">  char_u *pbad = su-&gt;su_badptr + badlenarg;</a>
<a name="ln5554">  for (;; ) {</a>
<a name="ln5555">    goodlen = (int)(pgood - goodword);</a>
<a name="ln5556">    badlen = (int)(pbad - su-&gt;su_badptr);</a>
<a name="ln5557">    if (goodlen &lt;= 0 || badlen &lt;= 0)</a>
<a name="ln5558">      break;</a>
<a name="ln5559">    MB_PTR_BACK(goodword, pgood);</a>
<a name="ln5560">    MB_PTR_BACK(su-&gt;su_badptr, pbad);</a>
<a name="ln5561">    if (utf_ptr2char(pgood) != utf_ptr2char(pbad)) {</a>
<a name="ln5562">      break;</a>
<a name="ln5563">    }</a>
<a name="ln5564">  }</a>
<a name="ln5565"> </a>
<a name="ln5566">  if (badlen == 0 &amp;&amp; goodlen == 0)</a>
<a name="ln5567">    // goodword doesn't change anything; may happen for &quot;the the&quot; changing</a>
<a name="ln5568">    // the first &quot;the&quot; to itself.</a>
<a name="ln5569">    return;</a>
<a name="ln5570"> </a>
<a name="ln5571">  int i;</a>
<a name="ln5572">  if (GA_EMPTY(gap)) {</a>
<a name="ln5573">    i = -1;</a>
<a name="ln5574">  } else {</a>
<a name="ln5575">    // Check if the word is already there.  Also check the length that is</a>
<a name="ln5576">    // being replaced &quot;thes,&quot; -&gt; &quot;these&quot; is a different suggestion from</a>
<a name="ln5577">    // &quot;thes&quot; -&gt; &quot;these&quot;.</a>
<a name="ln5578">    stp = &amp;SUG(*gap, 0);</a>
<a name="ln5579">    for (i = gap-&gt;ga_len; --i &gt;= 0; ++stp) {</a>
<a name="ln5580">      if (stp-&gt;st_wordlen == goodlen</a>
<a name="ln5581">          &amp;&amp; stp-&gt;st_orglen == badlen</a>
<a name="ln5582">          &amp;&amp; STRNCMP(stp-&gt;st_word, goodword, goodlen) == 0) {</a>
<a name="ln5583">        // Found it.  Remember the word with the lowest score.</a>
<a name="ln5584">        if (stp-&gt;st_slang == NULL)</a>
<a name="ln5585">          stp-&gt;st_slang = slang;</a>
<a name="ln5586"> </a>
<a name="ln5587">        new_sug.st_score = score;</a>
<a name="ln5588">        new_sug.st_altscore = altscore;</a>
<a name="ln5589">        new_sug.st_had_bonus = had_bonus;</a>
<a name="ln5590"> </a>
<a name="ln5591">        if (stp-&gt;st_had_bonus != had_bonus) {</a>
<a name="ln5592">          // Only one of the two had the soundalike score computed.</a>
<a name="ln5593">          // Need to do that for the other one now, otherwise the</a>
<a name="ln5594">          // scores can't be compared.  This happens because</a>
<a name="ln5595">          // suggest_try_change() doesn't compute the soundalike</a>
<a name="ln5596">          // word to keep it fast, while some special methods set</a>
<a name="ln5597">          // the soundalike score to zero.</a>
<a name="ln5598">          if (had_bonus)</a>
<a name="ln5599">            rescore_one(su, stp);</a>
<a name="ln5600">          else {</a>
<a name="ln5601">            new_sug.st_word = stp-&gt;st_word;</a>
<a name="ln5602">            new_sug.st_wordlen = stp-&gt;st_wordlen;</a>
<a name="ln5603">            new_sug.st_slang = stp-&gt;st_slang;</a>
<a name="ln5604">            new_sug.st_orglen = badlen;</a>
<a name="ln5605">            rescore_one(su, &amp;new_sug);</a>
<a name="ln5606">          }</a>
<a name="ln5607">        }</a>
<a name="ln5608"> </a>
<a name="ln5609">        if (stp-&gt;st_score &gt; new_sug.st_score) {</a>
<a name="ln5610">          stp-&gt;st_score = new_sug.st_score;</a>
<a name="ln5611">          stp-&gt;st_altscore = new_sug.st_altscore;</a>
<a name="ln5612">          stp-&gt;st_had_bonus = new_sug.st_had_bonus;</a>
<a name="ln5613">        }</a>
<a name="ln5614">        break;</a>
<a name="ln5615">      }</a>
<a name="ln5616">    }</a>
<a name="ln5617">  }</a>
<a name="ln5618"> </a>
<a name="ln5619">  if (i &lt; 0) {</a>
<a name="ln5620">    // Add a suggestion.</a>
<a name="ln5621">    stp = GA_APPEND_VIA_PTR(suggest_T, gap);</a>
<a name="ln5622">    stp-&gt;st_word = vim_strnsave(goodword, goodlen);</a>
<a name="ln5623">    stp-&gt;st_wordlen = goodlen;</a>
<a name="ln5624">    stp-&gt;st_score = score;</a>
<a name="ln5625">    stp-&gt;st_altscore = altscore;</a>
<a name="ln5626">    stp-&gt;st_had_bonus = had_bonus;</a>
<a name="ln5627">    stp-&gt;st_orglen = badlen;</a>
<a name="ln5628">    stp-&gt;st_slang = slang;</a>
<a name="ln5629"> </a>
<a name="ln5630">    // If we have too many suggestions now, sort the list and keep</a>
<a name="ln5631">    // the best suggestions.</a>
<a name="ln5632">    if (gap-&gt;ga_len &gt; SUG_MAX_COUNT(su)) {</a>
<a name="ln5633">      if (maxsf)</a>
<a name="ln5634">        su-&gt;su_sfmaxscore = cleanup_suggestions(gap,</a>
<a name="ln5635">            su-&gt;su_sfmaxscore, SUG_CLEAN_COUNT(su));</a>
<a name="ln5636">      else</a>
<a name="ln5637">        su-&gt;su_maxscore = cleanup_suggestions(gap,</a>
<a name="ln5638">            su-&gt;su_maxscore, SUG_CLEAN_COUNT(su));</a>
<a name="ln5639">    }</a>
<a name="ln5640">  }</a>
<a name="ln5641">}</a>
<a name="ln5642"> </a>
<a name="ln5643">// Suggestions may in fact be flagged as errors.  Esp. for banned words and</a>
<a name="ln5644">// for split words, such as &quot;the the&quot;.  Remove these from the list here.</a>
<a name="ln5645">static void</a>
<a name="ln5646">check_suggestions (</a>
<a name="ln5647">    suginfo_T *su,</a>
<a name="ln5648">    garray_T *gap                   // either su_ga or su_sga</a>
<a name="ln5649">)</a>
<a name="ln5650">{</a>
<a name="ln5651">  suggest_T   *stp;</a>
<a name="ln5652">  char_u longword[MAXWLEN + 1];</a>
<a name="ln5653">  int len;</a>
<a name="ln5654">  hlf_T attr;</a>
<a name="ln5655"> </a>
<a name="ln5656">  if (gap-&gt;ga_len == 0) {</a>
<a name="ln5657">    return;</a>
<a name="ln5658">  }</a>
<a name="ln5659">  stp = &amp;SUG(*gap, 0);</a>
<a name="ln5660">  for (int i = gap-&gt;ga_len - 1; i &gt;= 0; --i) {</a>
<a name="ln5661">    // Need to append what follows to check for &quot;the the&quot;.</a>
<a name="ln5662">    STRLCPY(longword, stp[i].st_word, MAXWLEN + 1);</a>
<a name="ln5663">    len = stp[i].st_wordlen;</a>
<a name="ln5664">    STRLCPY(longword + len, su-&gt;su_badptr + stp[i].st_orglen,</a>
<a name="ln5665">        MAXWLEN - len + 1);</a>
<a name="ln5666">    attr = HLF_COUNT;</a>
<a name="ln5667">    (void)spell_check(curwin, longword, &amp;attr, NULL, false);</a>
<a name="ln5668">    if (attr != HLF_COUNT) {</a>
<a name="ln5669">      // Remove this entry.</a>
<a name="ln5670">      xfree(stp[i].st_word);</a>
<a name="ln5671">      --gap-&gt;ga_len;</a>
<a name="ln5672">      if (i &lt; gap-&gt;ga_len)</a>
<a name="ln5673">        memmove(stp + i, stp + i + 1,</a>
<a name="ln5674">            sizeof(suggest_T) * (gap-&gt;ga_len - i));</a>
<a name="ln5675">    }</a>
<a name="ln5676">  }</a>
<a name="ln5677">}</a>
<a name="ln5678"> </a>
<a name="ln5679"> </a>
<a name="ln5680">// Add a word to be banned.</a>
<a name="ln5681">static void add_banned(suginfo_T *su, char_u *word)</a>
<a name="ln5682">{</a>
<a name="ln5683">  char_u      *s;</a>
<a name="ln5684">  hash_T hash;</a>
<a name="ln5685">  hashitem_T  *hi;</a>
<a name="ln5686"> </a>
<a name="ln5687">  hash = hash_hash(word);</a>
<a name="ln5688">  const size_t word_len = STRLEN(word);</a>
<a name="ln5689">  hi = hash_lookup(&amp;su-&gt;su_banned, (const char *)word, word_len, hash);</a>
<a name="ln5690">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5691">    s = xmemdupz(word, word_len);</a>
<a name="ln5692">    hash_add_item(&amp;su-&gt;su_banned, hi, s, hash);</a>
<a name="ln5693">  }</a>
<a name="ln5694">}</a>
<a name="ln5695"> </a>
<a name="ln5696">// Recompute the score for all suggestions if sound-folding is possible.  This</a>
<a name="ln5697">// is slow, thus only done for the final results.</a>
<a name="ln5698">static void rescore_suggestions(suginfo_T *su)</a>
<a name="ln5699">{</a>
<a name="ln5700">  if (su-&gt;su_sallang != NULL) {</a>
<a name="ln5701">    for (int i = 0; i &lt; su-&gt;su_ga.ga_len; ++i) {</a>
<a name="ln5702">      rescore_one(su, &amp;SUG(su-&gt;su_ga, i));</a>
<a name="ln5703">    }</a>
<a name="ln5704">  }</a>
<a name="ln5705">}</a>
<a name="ln5706"> </a>
<a name="ln5707">// Recompute the score for one suggestion if sound-folding is possible.</a>
<a name="ln5708">static void rescore_one(suginfo_T *su, suggest_T *stp)</a>
<a name="ln5709">{</a>
<a name="ln5710">  slang_T     *slang = stp-&gt;st_slang;</a>
<a name="ln5711">  char_u sal_badword[MAXWLEN];</a>
<a name="ln5712">  char_u      *p;</a>
<a name="ln5713"> </a>
<a name="ln5714">  // Only rescore suggestions that have no sal score yet and do have a</a>
<a name="ln5715">  // language.</a>
<a name="ln5716">  if (slang != NULL &amp;&amp; !GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; !stp-&gt;st_had_bonus) {</a>
<a name="ln5717">    if (slang == su-&gt;su_sallang)</a>
<a name="ln5718">      p = su-&gt;su_sal_badword;</a>
<a name="ln5719">    else {</a>
<a name="ln5720">      spell_soundfold(slang, su-&gt;su_fbadword, true, sal_badword);</a>
<a name="ln5721">      p = sal_badword;</a>
<a name="ln5722">    }</a>
<a name="ln5723"> </a>
<a name="ln5724">    stp-&gt;st_altscore = stp_sal_score(stp, su, slang, p);</a>
<a name="ln5725">    if (stp-&gt;st_altscore == SCORE_MAXMAX)</a>
<a name="ln5726">      stp-&gt;st_altscore = SCORE_BIG;</a>
<a name="ln5727">    stp-&gt;st_score = RESCORE(stp-&gt;st_score, stp-&gt;st_altscore);</a>
<a name="ln5728">    stp-&gt;st_had_bonus = true;</a>
<a name="ln5729">  }</a>
<a name="ln5730">}</a>
<a name="ln5731"> </a>
<a name="ln5732"> </a>
<a name="ln5733">// Function given to qsort() to sort the suggestions on st_score.</a>
<a name="ln5734">// First on &quot;st_score&quot;, then &quot;st_altscore&quot; then alphabetically.</a>
<a name="ln5735">static int sug_compare(const void *s1, const void *s2)</a>
<a name="ln5736">{</a>
<a name="ln5737">  suggest_T   *p1 = (suggest_T *)s1;</a>
<a name="ln5738">  suggest_T   *p2 = (suggest_T *)s2;</a>
<a name="ln5739">  int n = p1-&gt;st_score - p2-&gt;st_score;</a>
<a name="ln5740"> </a>
<a name="ln5741">  if (n == 0) {</a>
<a name="ln5742">    n = p1-&gt;st_altscore - p2-&gt;st_altscore;</a>
<a name="ln5743">    if (n == 0)</a>
<a name="ln5744">      n = STRICMP(p1-&gt;st_word, p2-&gt;st_word);</a>
<a name="ln5745">  }</a>
<a name="ln5746">  return n;</a>
<a name="ln5747">}</a>
<a name="ln5748"> </a>
<a name="ln5749">// Cleanup the suggestions:</a>
<a name="ln5750">// - Sort on score.</a>
<a name="ln5751">// - Remove words that won't be displayed.</a>
<a name="ln5752">// Returns the maximum score in the list or &quot;maxscore&quot; unmodified.</a>
<a name="ln5753">static int</a>
<a name="ln5754">cleanup_suggestions (</a>
<a name="ln5755">    garray_T *gap,</a>
<a name="ln5756">    int maxscore,</a>
<a name="ln5757">    int keep                       // nr of suggestions to keep</a>
<a name="ln5758">)</a>
<a name="ln5759">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5760">{</a>
<a name="ln5761">  if (gap-&gt;ga_len &gt; 0) {</a>
<a name="ln5762">    // Sort the list.</a>
<a name="ln5763">    qsort(gap-&gt;ga_data, (size_t)gap-&gt;ga_len, sizeof(suggest_T), sug_compare);</a>
<a name="ln5764"> </a>
<a name="ln5765">    // Truncate the list to the number of suggestions that will be displayed.</a>
<a name="ln5766">    if (gap-&gt;ga_len &gt; keep) {</a>
<a name="ln5767">      suggest_T *const stp = &amp;SUG(*gap, 0);</a>
<a name="ln5768"> </a>
<a name="ln5769">      for (int i = keep; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln5770">        xfree(stp[i].st_word);</a>
<a name="ln5771">      }</a>
<a name="ln5772">      gap-&gt;ga_len = keep;</a>
<a name="ln5773">      if (keep &gt;= 1) {</a>
<a name="ln5774">        return stp[keep - 1].st_score;</a>
<a name="ln5775">      }</a>
<a name="ln5776">    }</a>
<a name="ln5777">  }</a>
<a name="ln5778">  return maxscore;</a>
<a name="ln5779">}</a>
<a name="ln5780"> </a>
<a name="ln5781">/// Soundfold a string, for soundfold()</a>
<a name="ln5782">///</a>
<a name="ln5783">/// @param[in]  word  Word to soundfold.</a>
<a name="ln5784">///</a>
<a name="ln5785">/// @return [allocated] soundfolded string or NULL in case of error. May return</a>
<a name="ln5786">///                     copy of the input string if soundfolding is not</a>
<a name="ln5787">///                     supported by any of the languages in &amp;spellang.</a>
<a name="ln5788">char *eval_soundfold(const char *const word)</a>
<a name="ln5789">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5790">{</a>
<a name="ln5791">  if (curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln5792">    // Use the sound-folding of the first language that supports it.</a>
<a name="ln5793">    for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln5794">      langp_T *const lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5795">      if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln5796">        // soundfold the word</a>
<a name="ln5797">        char_u sound[MAXWLEN];</a>
<a name="ln5798">        spell_soundfold(lp-&gt;lp_slang, (char_u *)word, false, sound);</a>
<a name="ln5799">        return xstrdup((const char *)sound);</a>
<a name="ln5800">      }</a>
<a name="ln5801">    }</a>
<a name="ln5802">  }</a>
<a name="ln5803"> </a>
<a name="ln5804">  // No language with sound folding, return word as-is.</a>
<a name="ln5805">  return xstrdup(word);</a>
<a name="ln5806">}</a>
<a name="ln5807"> </a>
<a name="ln5808">/// Turn &quot;inword&quot; into its sound-a-like equivalent in &quot;res[MAXWLEN]&quot;.</a>
<a name="ln5809">///</a>
<a name="ln5810">/// There are many ways to turn a word into a sound-a-like representation.  The</a>
<a name="ln5811">/// oldest is Soundex (1918!).   A nice overview can be found in &quot;Approximate</a>
<a name="ln5812">/// swedish name matching - survey and test of different algorithms&quot; by Klas</a>
<a name="ln5813">/// Erikson.</a>
<a name="ln5814">///</a>
<a name="ln5815">/// We support two methods:</a>
<a name="ln5816">/// 1. SOFOFROM/SOFOTO do a simple character mapping.</a>
<a name="ln5817">/// 2. SAL items define a more advanced sound-folding (and much slower).</a>
<a name="ln5818">///</a>
<a name="ln5819">/// @param[in]  slang</a>
<a name="ln5820">/// @param[in]  inword  word to soundfold</a>
<a name="ln5821">/// @param[in]  folded  whether inword is already case-folded</a>
<a name="ln5822">/// @param[in,out]  res  destination for soundfolded word</a>
<a name="ln5823">void spell_soundfold(slang_T *slang, char_u *inword, bool folded, char_u *res)</a>
<a name="ln5824">{</a>
<a name="ln5825">  char_u fword[MAXWLEN];</a>
<a name="ln5826">  char_u      *word;</a>
<a name="ln5827"> </a>
<a name="ln5828">  if (slang-&gt;sl_sofo)</a>
<a name="ln5829">    // SOFOFROM and SOFOTO used</a>
<a name="ln5830">    spell_soundfold_sofo(slang, inword, res);</a>
<a name="ln5831">  else {</a>
<a name="ln5832">    // SAL items used.  Requires the word to be case-folded.</a>
<a name="ln5833">    if (folded) {</a>
<a name="ln5834">      word = inword;</a>
<a name="ln5835">    } else {</a>
<a name="ln5836">      (void)spell_casefold(curwin, inword, (int)STRLEN(inword), fword, MAXWLEN);</a>
<a name="ln5837">      word = fword;</a>
<a name="ln5838">    }</a>
<a name="ln5839"> </a>
<a name="ln5840">    spell_soundfold_wsal(slang, word, res);</a>
<a name="ln5841">  }</a>
<a name="ln5842">}</a>
<a name="ln5843"> </a>
<a name="ln5844">// Perform sound folding of &quot;inword&quot; into &quot;res&quot; according to SOFOFROM and</a>
<a name="ln5845">// SOFOTO lines.</a>
<a name="ln5846">static void spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res)</a>
<a name="ln5847">{</a>
<a name="ln5848">  int ri = 0;</a>
<a name="ln5849"> </a>
<a name="ln5850">  int prevc = 0;</a>
<a name="ln5851"> </a>
<a name="ln5852">  // The sl_sal_first[] table contains the translation for chars up to</a>
<a name="ln5853">  // 255, sl_sal the rest.</a>
<a name="ln5854">  for (char_u *s = inword; *s != NUL; ) {</a>
<a name="ln5855">    int c = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln5856">    if (utf_class(c) == 0) {</a>
<a name="ln5857">      c = ' ';</a>
<a name="ln5858">    } else if (c &lt; 256) {</a>
<a name="ln5859">      c = slang-&gt;sl_sal_first[c];</a>
<a name="ln5860">    } else {</a>
<a name="ln5861">      int *ip = ((int **)slang-&gt;sl_sal.ga_data)[c &amp; 0xff];</a>
<a name="ln5862">      if (ip == NULL) {               // empty list, can't match</a>
<a name="ln5863">        c = NUL;</a>
<a name="ln5864">      } else {</a>
<a name="ln5865">        for (;; ) {                   // find &quot;c&quot; in the list</a>
<a name="ln5866">          if (*ip == 0) {             // not found</a>
<a name="ln5867">            c = NUL;</a>
<a name="ln5868">            break;</a>
<a name="ln5869">          }</a>
<a name="ln5870">          if (*ip == c) {             // match!</a>
<a name="ln5871">            c = ip[1];</a>
<a name="ln5872">            break;</a>
<a name="ln5873">          }</a>
<a name="ln5874">          ip += 2;</a>
<a name="ln5875">        }</a>
<a name="ln5876">      }</a>
<a name="ln5877">    }</a>
<a name="ln5878"> </a>
<a name="ln5879">    if (c != NUL &amp;&amp; c != prevc) {</a>
<a name="ln5880">      ri += utf_char2bytes(c, res + ri);</a>
<a name="ln5881">      if (ri + MB_MAXBYTES &gt; MAXWLEN) {</a>
<a name="ln5882">        break;</a>
<a name="ln5883">      }</a>
<a name="ln5884">      prevc = c;</a>
<a name="ln5885">    }</a>
<a name="ln5886">  }</a>
<a name="ln5887"> </a>
<a name="ln5888">  res[ri] = NUL;</a>
<a name="ln5889">}</a>
<a name="ln5890"> </a>
<a name="ln5891">// Turn &quot;inword&quot; into its sound-a-like equivalent in &quot;res[MAXWLEN]&quot;.</a>
<a name="ln5892">// Multi-byte version of spell_soundfold().</a>
<a name="ln5893">static void spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)</a>
<a name="ln5894">{</a>
<a name="ln5895">  salitem_T   *smp = (salitem_T *)slang-&gt;sl_sal.ga_data;</a>
<a name="ln5896">  int word[MAXWLEN] = { 0 };</a>
<a name="ln5897">  int wres[MAXWLEN] = { 0 };</a>
<a name="ln5898">  int l;</a>
<a name="ln5899">  int         *ws;</a>
<a name="ln5900">  int         *pf;</a>
<a name="ln5901">  int i, j, z;</a>
<a name="ln5902">  int reslen;</a>
<a name="ln5903">  int n, k = 0;</a>
<a name="ln5904">  int z0;</a>
<a name="ln5905">  int k0;</a>
<a name="ln5906">  int n0;</a>
<a name="ln5907">  int c;</a>
<a name="ln5908">  int pri;</a>
<a name="ln5909">  int p0 = -333;</a>
<a name="ln5910">  int c0;</a>
<a name="ln5911">  bool did_white = false;</a>
<a name="ln5912">  int wordlen;</a>
<a name="ln5913"> </a>
<a name="ln5914"> </a>
<a name="ln5915">  // Convert the multi-byte string to a wide-character string.</a>
<a name="ln5916">  // Remove accents, if wanted.  We actually remove all non-word characters.</a>
<a name="ln5917">  // But keep white space.</a>
<a name="ln5918">  wordlen = 0;</a>
<a name="ln5919">  for (const char_u *s = inword; *s != NUL; ) {</a>
<a name="ln5920">    const char_u *t = s;</a>
<a name="ln5921">    c = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln5922">    if (slang-&gt;sl_rem_accents) {</a>
<a name="ln5923">      if (utf_class(c) == 0) {</a>
<a name="ln5924">        if (did_white) {</a>
<a name="ln5925">          continue;</a>
<a name="ln5926">        }</a>
<a name="ln5927">        c = ' ';</a>
<a name="ln5928">        did_white = true;</a>
<a name="ln5929">      } else {</a>
<a name="ln5930">        did_white = false;</a>
<a name="ln5931">        if (!spell_iswordp_nmw(t, curwin)) {</a>
<a name="ln5932">          continue;</a>
<a name="ln5933">        }</a>
<a name="ln5934">      }</a>
<a name="ln5935">    }</a>
<a name="ln5936">    word[wordlen++] = c;</a>
<a name="ln5937">  }</a>
<a name="ln5938">  word[wordlen] = NUL;</a>
<a name="ln5939"> </a>
<a name="ln5940">  // This algorithm comes from Aspell phonet.cpp.</a>
<a name="ln5941">  // Converted from C++ to C.  Added support for multi-byte chars.</a>
<a name="ln5942">  // Changed to keep spaces.</a>
<a name="ln5943">  i = reslen = z = 0;</a>
<a name="ln5944">  while ((c = word[i]) != NUL) {</a>
<a name="ln5945">    // Start with the first rule that has the character in the word.</a>
<a name="ln5946">    n = slang-&gt;sl_sal_first[c &amp; 0xff];</a>
<a name="ln5947">    z0 = 0;</a>
<a name="ln5948"> </a>
<a name="ln5949">    if (n &gt;= 0) {</a>
<a name="ln5950">      // Check all rules for the same index byte.</a>
<a name="ln5951">      // If c is 0x300 need extra check for the end of the array, as</a>
<a name="ln5952">      // (c &amp; 0xff) is NUL.</a>
<a name="ln5953">      for (; ((ws = smp[n].sm_lead_w)[0] &amp; 0xff) == (c &amp; 0xff)</a>
<a name="ln5954">           &amp;&amp; ws[0] != NUL; ++n) {</a>
<a name="ln5955">        // Quickly skip entries that don't match the word.  Most</a>
<a name="ln5956">        // entries are less then three chars, optimize for that.</a>
<a name="ln5957">        if (c != ws[0])</a>
<a name="ln5958">          continue;</a>
<a name="ln5959">        k = smp[n].sm_leadlen;</a>
<a name="ln5960">        if (k &gt; 1) {</a>
<a name="ln5961">          if (word[i + 1] != ws[1])</a>
<a name="ln5962">            continue;</a>
<a name="ln5963">          if (k &gt; 2) {</a>
<a name="ln5964">            for (j = 2; j &lt; k; ++j)</a>
<a name="ln5965">              if (word[i + j] != ws[j])</a>
<a name="ln5966">                break;</a>
<a name="ln5967">            if (j &lt; k)</a>
<a name="ln5968">              continue;</a>
<a name="ln5969">          }</a>
<a name="ln5970">        }</a>
<a name="ln5971"> </a>
<a name="ln5972">        if ((pf = smp[n].sm_oneof_w) != NULL) {</a>
<a name="ln5973">          // Check for match with one of the chars in &quot;sm_oneof&quot;.</a>
<a name="ln5974">          while (*pf != NUL &amp;&amp; *pf != word[i + k])</a>
<a name="ln5975">            ++pf;</a>
<a name="ln5976">          if (*pf == NUL)</a>
<a name="ln5977">            continue;</a>
<a name="ln5978">          ++k;</a>
<a name="ln5979">        }</a>
<a name="ln5980">        char_u *s = smp[n].sm_rules;</a>
<a name="ln5981">        pri = 5;            // default priority</a>
<a name="ln5982"> </a>
<a name="ln5983">        p0 = *s;</a>
<a name="ln5984">        k0 = k;</a>
<a name="ln5985">        while (*s == '-' &amp;&amp; k &gt; 1) {</a>
<a name="ln5986">          k--;</a>
<a name="ln5987">          s++;</a>
<a name="ln5988">        }</a>
<a name="ln5989">        if (*s == '&lt;')</a>
<a name="ln5990">          s++;</a>
<a name="ln5991">        if (ascii_isdigit(*s)) {</a>
<a name="ln5992">          // determine priority</a>
<a name="ln5993">          pri = *s - '0';</a>
<a name="ln5994">          s++;</a>
<a name="ln5995">        }</a>
<a name="ln5996">        if (*s == '^' &amp;&amp; *(s + 1) == '^')</a>
<a name="ln5997">          s++;</a>
<a name="ln5998"> </a>
<a name="ln5999">        if (*s == NUL</a>
<a name="ln6000">            || (*s == '^'</a>
<a name="ln6001">                &amp;&amp; (i == 0 || !(word[i - 1] == ' '</a>
<a name="ln6002">                                || spell_iswordp_w(word + i - 1, curwin)))</a>
<a name="ln6003">                &amp;&amp; (*(s + 1) != '$'</a>
<a name="ln6004">                    || (!spell_iswordp_w(word + i + k0, curwin))))</a>
<a name="ln6005">            || (*s == '$' &amp;&amp; i &gt; 0</a>
<a name="ln6006">                &amp;&amp; spell_iswordp_w(word + i - 1, curwin)</a>
<a name="ln6007">                &amp;&amp; (!spell_iswordp_w(word + i + k0, curwin)))) {</a>
<a name="ln6008">          // search for followup rules, if:</a>
<a name="ln6009">          // followup and k &gt; 1  and  NO '-' in searchstring</a>
<a name="ln6010">          c0 = word[i + k - 1];</a>
<a name="ln6011">          n0 = slang-&gt;sl_sal_first[c0 &amp; 0xff];</a>
<a name="ln6012"> </a>
<a name="ln6013">          if (slang-&gt;sl_followup &amp;&amp; k &gt; 1 &amp;&amp; n0 &gt;= 0</a>
<a name="ln6014">              &amp;&amp; p0 != '-' &amp;&amp; word[i + k] != NUL) {</a>
<a name="ln6015">            // Test follow-up rule for &quot;word[i + k]&quot;; loop over</a>
<a name="ln6016">            // all entries with the same index byte.</a>
<a name="ln6017">            for (; ((ws = smp[n0].sm_lead_w)[0] &amp; 0xff)</a>
<a name="ln6018">                 == (c0 &amp; 0xff); ++n0) {</a>
<a name="ln6019">              // Quickly skip entries that don't match the word.</a>
<a name="ln6020">              if (c0 != ws[0])</a>
<a name="ln6021">                continue;</a>
<a name="ln6022">              k0 = smp[n0].sm_leadlen;</a>
<a name="ln6023">              if (k0 &gt; 1) {</a>
<a name="ln6024">                if (word[i + k] != ws[1])</a>
<a name="ln6025">                  continue;</a>
<a name="ln6026">                if (k0 &gt; 2) {</a>
<a name="ln6027">                  pf = word + i + k + 1;</a>
<a name="ln6028">                  for (j = 2; j &lt; k0; ++j)</a>
<a name="ln6029">                    if (*pf++ != ws[j])</a>
<a name="ln6030">                      break;</a>
<a name="ln6031">                  if (j &lt; k0)</a>
<a name="ln6032">                    continue;</a>
<a name="ln6033">                }</a>
<a name="ln6034">              }</a>
<a name="ln6035">              k0 += k - 1;</a>
<a name="ln6036"> </a>
<a name="ln6037">              if ((pf = smp[n0].sm_oneof_w) != NULL) {</a>
<a name="ln6038">                // Check for match with one of the chars in</a>
<a name="ln6039">                // &quot;sm_oneof&quot;.</a>
<a name="ln6040">                while (*pf != NUL &amp;&amp; *pf != word[i + k0])</a>
<a name="ln6041">                  ++pf;</a>
<a name="ln6042">                if (*pf == NUL)</a>
<a name="ln6043">                  continue;</a>
<a name="ln6044">                ++k0;</a>
<a name="ln6045">              }</a>
<a name="ln6046"> </a>
<a name="ln6047">              p0 = 5;</a>
<a name="ln6048">              s = smp[n0].sm_rules;</a>
<a name="ln6049">              while (*s == '-') {</a>
<a name="ln6050">                // &quot;k0&quot; gets NOT reduced because</a>
<a name="ln6051">                // &quot;if (k0 == k)&quot;</a>
<a name="ln6052">                s++;</a>
<a name="ln6053">              }</a>
<a name="ln6054">              if (*s == '&lt;')</a>
<a name="ln6055">                s++;</a>
<a name="ln6056">              if (ascii_isdigit(*s)) {</a>
<a name="ln6057">                p0 = *s - '0';</a>
<a name="ln6058">                s++;</a>
<a name="ln6059">              }</a>
<a name="ln6060"> </a>
<a name="ln6061">              if (*s == NUL</a>
<a name="ln6062">                  // *s == '^' cuts</a>
<a name="ln6063">                  || (*s == '$'</a>
<a name="ln6064">                      &amp;&amp; !spell_iswordp_w(word + i + k0,</a>
<a name="ln6065">                          curwin))) {</a>
<a name="ln6066">                if (k0 == k)</a>
<a name="ln6067">                  // this is just a piece of the string</a>
<a name="ln6068">                  continue;</a>
<a name="ln6069"> </a>
<a name="ln6070">                if (p0 &lt; pri)</a>
<a name="ln6071">                  // priority too low</a>
<a name="ln6072">                  continue;</a>
<a name="ln6073">                // rule fits; stop search</a>
<a name="ln6074">                break;</a>
<a name="ln6075">              }</a>
<a name="ln6076">            }</a>
<a name="ln6077"> </a>
<a name="ln6078">            if (p0 &gt;= pri &amp;&amp; (smp[n0].sm_lead_w[0] &amp; 0xff)</a>
<a name="ln6079">                == (c0 &amp; 0xff))</a>
<a name="ln6080">              continue;</a>
<a name="ln6081">          }</a>
<a name="ln6082"> </a>
<a name="ln6083">          // replace string</a>
<a name="ln6084">          ws = smp[n].sm_to_w;</a>
<a name="ln6085">          s = smp[n].sm_rules;</a>
<a name="ln6086">          p0 = (vim_strchr(s, '&lt;') != NULL) ? 1 : 0;</a>
<a name="ln6087">          if (p0 == 1 &amp;&amp; z == 0) {</a>
<a name="ln6088">            // rule with '&lt;' is used</a>
<a name="ln6089">            if (reslen &gt; 0 &amp;&amp; ws != NULL &amp;&amp; *ws != NUL</a>
<a name="ln6090">                &amp;&amp; (wres[reslen - 1] == c</a>
<a name="ln6091">                    || wres[reslen - 1] == *ws))</a>
<a name="ln6092">              reslen--;</a>
<a name="ln6093">            z0 = 1;</a>
<a name="ln6094">            z = 1;</a>
<a name="ln6095">            k0 = 0;</a>
<a name="ln6096">            if (ws != NULL)</a>
<a name="ln6097">              while (*ws != NUL &amp;&amp; word[i + k0] != NUL) {</a>
<a name="ln6098">                word[i + k0] = *ws;</a>
<a name="ln6099">                k0++;</a>
<a name="ln6100">                ws++;</a>
<a name="ln6101">              }</a>
<a name="ln6102">            if (k &gt; k0)</a>
<a name="ln6103">              memmove(word + i + k0, word + i + k,</a>
<a name="ln6104">                  sizeof(int) * (wordlen - (i + k) + 1));</a>
<a name="ln6105"> </a>
<a name="ln6106">            // new &quot;actual letter&quot;</a>
<a name="ln6107">            c = word[i];</a>
<a name="ln6108">          } else {</a>
<a name="ln6109">            // no '&lt;' rule used</a>
<a name="ln6110">            i += k - 1;</a>
<a name="ln6111">            z = 0;</a>
<a name="ln6112">            if (ws != NULL)</a>
<a name="ln6113">              while (*ws != NUL &amp;&amp; ws[1] != NUL</a>
<a name="ln6114">                     &amp;&amp; reslen &lt; MAXWLEN) {</a>
<a name="ln6115">                if (reslen == 0 || wres[reslen - 1] != *ws)</a>
<a name="ln6116">                  wres[reslen++] = *ws;</a>
<a name="ln6117">                ws++;</a>
<a name="ln6118">              }</a>
<a name="ln6119">            // new &quot;actual letter&quot;</a>
<a name="ln6120">            if (ws == NULL)</a>
<a name="ln6121">              c = NUL;</a>
<a name="ln6122">            else</a>
<a name="ln6123">              c = *ws;</a>
<a name="ln6124">            if (strstr((char *)s, &quot;^^&quot;) != NULL) {</a>
<a name="ln6125">              if (c != NUL)</a>
<a name="ln6126">                wres[reslen++] = c;</a>
<a name="ln6127">              memmove(word, word + i + 1,</a>
<a name="ln6128">                  sizeof(int) * (wordlen - (i + 1) + 1));</a>
<a name="ln6129">              i = 0;</a>
<a name="ln6130">              z0 = 1;</a>
<a name="ln6131">            }</a>
<a name="ln6132">          }</a>
<a name="ln6133">          break;</a>
<a name="ln6134">        }</a>
<a name="ln6135">      }</a>
<a name="ln6136">    } else if (ascii_iswhite(c))   {</a>
<a name="ln6137">      c = ' ';</a>
<a name="ln6138">      k = 1;</a>
<a name="ln6139">    }</a>
<a name="ln6140"> </a>
<a name="ln6141">    if (z0 == 0) {</a>
<a name="ln6142">      if (k &amp;&amp; !p0 &amp;&amp; reslen &lt; MAXWLEN &amp;&amp; c != NUL</a>
<a name="ln6143">          &amp;&amp; (!slang-&gt;sl_collapse || reslen == 0</a>
<a name="ln6144">              || wres[reslen - 1] != c))</a>
<a name="ln6145">        // condense only double letters</a>
<a name="ln6146">        wres[reslen++] = c;</a>
<a name="ln6147"> </a>
<a name="ln6148">      i++;</a>
<a name="ln6149">      z = 0;</a>
<a name="ln6150">      k = 0;</a>
<a name="ln6151">    }</a>
<a name="ln6152">  }</a>
<a name="ln6153"> </a>
<a name="ln6154">  // Convert wide characters in &quot;wres&quot; to a multi-byte string in &quot;res&quot;.</a>
<a name="ln6155">  l = 0;</a>
<a name="ln6156">  for (n = 0; n &lt; reslen; n++) {</a>
<a name="ln6157">    l += utf_char2bytes(wres[n], res + l);</a>
<a name="ln6158">    if (l + MB_MAXBYTES &gt; MAXWLEN) {</a>
<a name="ln6159">      break;</a>
<a name="ln6160">    }</a>
<a name="ln6161">  }</a>
<a name="ln6162">  res[l] = NUL;</a>
<a name="ln6163">}</a>
<a name="ln6164"> </a>
<a name="ln6165">// Compute a score for two sound-a-like words.</a>
<a name="ln6166">// This permits up to two inserts/deletes/swaps/etc. to keep things fast.</a>
<a name="ln6167">// Instead of a generic loop we write out the code.  That keeps it fast by</a>
<a name="ln6168">// avoiding checks that will not be possible.</a>
<a name="ln6169">static int</a>
<a name="ln6170">soundalike_score (</a>
<a name="ln6171">    char_u *goodstart,         // sound-folded good word</a>
<a name="ln6172">    char_u *badstart          // sound-folded bad word</a>
<a name="ln6173">)</a>
<a name="ln6174">{</a>
<a name="ln6175">  char_u      *goodsound = goodstart;</a>
<a name="ln6176">  char_u      *badsound = badstart;</a>
<a name="ln6177">  int goodlen;</a>
<a name="ln6178">  int badlen;</a>
<a name="ln6179">  int n;</a>
<a name="ln6180">  char_u      *pl, *ps;</a>
<a name="ln6181">  char_u      *pl2, *ps2;</a>
<a name="ln6182">  int score = 0;</a>
<a name="ln6183"> </a>
<a name="ln6184">  // Adding/inserting &quot;*&quot; at the start (word starts with vowel) shouldn't be</a>
<a name="ln6185">  // counted so much, vowels in the middle of the word aren't counted at all.</a>
<a name="ln6186">  if ((*badsound == '*' || *goodsound == '*') &amp;&amp; *badsound != *goodsound) {</a>
<a name="ln6187">    if ((badsound[0] == NUL &amp;&amp; goodsound[1] == NUL)</a>
<a name="ln6188">        || (goodsound[0] == NUL &amp;&amp; badsound[1] == NUL))</a>
<a name="ln6189">      // changing word with vowel to word without a sound</a>
<a name="ln6190">      return SCORE_DEL;</a>
<a name="ln6191">    if (badsound[0] == NUL || goodsound[0] == NUL)</a>
<a name="ln6192">      // more than two changes</a>
<a name="ln6193">      return SCORE_MAXMAX;</a>
<a name="ln6194"> </a>
<a name="ln6195">    if (badsound[1] == goodsound[1]</a>
<a name="ln6196">        || (badsound[1] != NUL</a>
<a name="ln6197">            &amp;&amp; goodsound[1] != NUL</a>
<a name="ln6198">            &amp;&amp; badsound[2] == goodsound[2])) {</a>
<a name="ln6199">      // handle like a substitute</a>
<a name="ln6200">    } else {</a>
<a name="ln6201">      score = 2 * SCORE_DEL / 3;</a>
<a name="ln6202">      if (*badsound == '*')</a>
<a name="ln6203">        ++badsound;</a>
<a name="ln6204">      else</a>
<a name="ln6205">        ++goodsound;</a>
<a name="ln6206">    }</a>
<a name="ln6207">  }</a>
<a name="ln6208"> </a>
<a name="ln6209">  goodlen = (int)STRLEN(goodsound);</a>
<a name="ln6210">  badlen = (int)STRLEN(badsound);</a>
<a name="ln6211"> </a>
<a name="ln6212">  // Return quickly if the lengths are too different to be fixed by two</a>
<a name="ln6213">  // changes.</a>
<a name="ln6214">  n = goodlen - badlen;</a>
<a name="ln6215">  if (n &lt; -2 || n &gt; 2)</a>
<a name="ln6216">    return SCORE_MAXMAX;</a>
<a name="ln6217"> </a>
<a name="ln6218">  if (n &gt; 0) {</a>
<a name="ln6219">    pl = goodsound;         // goodsound is longest</a>
<a name="ln6220">    ps = badsound;</a>
<a name="ln6221">  } else {</a>
<a name="ln6222">    pl = badsound;          // badsound is longest</a>
<a name="ln6223">    ps = goodsound;</a>
<a name="ln6224">  }</a>
<a name="ln6225"> </a>
<a name="ln6226">  // Skip over the identical part.</a>
<a name="ln6227">  while (*pl == *ps &amp;&amp; *pl != NUL) {</a>
<a name="ln6228">    ++pl;</a>
<a name="ln6229">    ++ps;</a>
<a name="ln6230">  }</a>
<a name="ln6231"> </a>
<a name="ln6232">  switch (n) {</a>
<a name="ln6233">  case -2:</a>
<a name="ln6234">  case 2:</a>
<a name="ln6235">    // Must delete two characters from &quot;pl&quot;.</a>
<a name="ln6236">    ++pl;               // first delete</a>
<a name="ln6237">    while (*pl == *ps) {</a>
<a name="ln6238">      ++pl;</a>
<a name="ln6239">      ++ps;</a>
<a name="ln6240">    }</a>
<a name="ln6241">    // strings must be equal after second delete</a>
<a name="ln6242">    if (STRCMP(pl + 1, ps) == 0)</a>
<a name="ln6243">      return score + SCORE_DEL * 2;</a>
<a name="ln6244"> </a>
<a name="ln6245">    // Failed to compare.</a>
<a name="ln6246">    break;</a>
<a name="ln6247"> </a>
<a name="ln6248">  case -1:</a>
<a name="ln6249">  case 1:</a>
<a name="ln6250">    // Minimal one delete from &quot;pl&quot; required.</a>
<a name="ln6251"> </a>
<a name="ln6252">    // 1: delete</a>
<a name="ln6253">    pl2 = pl + 1;</a>
<a name="ln6254">    ps2 = ps;</a>
<a name="ln6255">    while (*pl2 == *ps2) {</a>
<a name="ln6256">      if (*pl2 == NUL)                  // reached the end</a>
<a name="ln6257">        return score + SCORE_DEL;</a>
<a name="ln6258">      ++pl2;</a>
<a name="ln6259">      ++ps2;</a>
<a name="ln6260">    }</a>
<a name="ln6261"> </a>
<a name="ln6262">    // 2: delete then swap, then rest must be equal</a>
<a name="ln6263">    if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln6264">        &amp;&amp; STRCMP(pl2 + 2, ps2 + 2) == 0)</a>
<a name="ln6265">      return score + SCORE_DEL + SCORE_SWAP;</a>
<a name="ln6266"> </a>
<a name="ln6267">    // 3: delete then substitute, then the rest must be equal</a>
<a name="ln6268">    if (STRCMP(pl2 + 1, ps2 + 1) == 0)</a>
<a name="ln6269">      return score + SCORE_DEL + SCORE_SUBST;</a>
<a name="ln6270"> </a>
<a name="ln6271">    // 4: first swap then delete</a>
<a name="ln6272">    if (pl[0] == ps[1] &amp;&amp; pl[1] == ps[0]) {</a>
<a name="ln6273">      pl2 = pl + 2;                 // swap, skip two chars</a>
<a name="ln6274">      ps2 = ps + 2;</a>
<a name="ln6275">      while (*pl2 == *ps2) {</a>
<a name="ln6276">        ++pl2;</a>
<a name="ln6277">        ++ps2;</a>
<a name="ln6278">      }</a>
<a name="ln6279">      // delete a char and then strings must be equal</a>
<a name="ln6280">      if (STRCMP(pl2 + 1, ps2) == 0)</a>
<a name="ln6281">        return score + SCORE_SWAP + SCORE_DEL;</a>
<a name="ln6282">    }</a>
<a name="ln6283"> </a>
<a name="ln6284">    // 5: first substitute then delete</a>
<a name="ln6285">    pl2 = pl + 1;                   // substitute, skip one char</a>
<a name="ln6286">    ps2 = ps + 1;</a>
<a name="ln6287">    while (*pl2 == *ps2) {</a>
<a name="ln6288">      ++pl2;</a>
<a name="ln6289">      ++ps2;</a>
<a name="ln6290">    }</a>
<a name="ln6291">    // delete a char and then strings must be equal</a>
<a name="ln6292">    if (STRCMP(pl2 + 1, ps2) == 0)</a>
<a name="ln6293">      return score + SCORE_SUBST + SCORE_DEL;</a>
<a name="ln6294"> </a>
<a name="ln6295">    // Failed to compare.</a>
<a name="ln6296">    break;</a>
<a name="ln6297"> </a>
<a name="ln6298">  case 0:</a>
<a name="ln6299">    // Lengths are equal, thus changes must result in same length: An</a>
<a name="ln6300">    // insert is only possible in combination with a delete.</a>
<a name="ln6301">    // 1: check if for identical strings</a>
<a name="ln6302">    if (*pl == NUL)</a>
<a name="ln6303">      return score;</a>
<a name="ln6304"> </a>
<a name="ln6305">    // 2: swap</a>
<a name="ln6306">    if (pl[0] == ps[1] &amp;&amp; pl[1] == ps[0]) {</a>
<a name="ln6307">      pl2 = pl + 2;                 // swap, skip two chars</a>
<a name="ln6308">      ps2 = ps + 2;</a>
<a name="ln6309">      while (*pl2 == *ps2) {</a>
<a name="ln6310">        if (*pl2 == NUL)                // reached the end</a>
<a name="ln6311">          return score + SCORE_SWAP;</a>
<a name="ln6312">        ++pl2;</a>
<a name="ln6313">        ++ps2;</a>
<a name="ln6314">      }</a>
<a name="ln6315">      // 3: swap and swap again</a>
<a name="ln6316">      if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln6317">          &amp;&amp; STRCMP(pl2 + 2, ps2 + 2) == 0)</a>
<a name="ln6318">        return score + SCORE_SWAP + SCORE_SWAP;</a>
<a name="ln6319"> </a>
<a name="ln6320">      // 4: swap and substitute</a>
<a name="ln6321">      if (STRCMP(pl2 + 1, ps2 + 1) == 0)</a>
<a name="ln6322">        return score + SCORE_SWAP + SCORE_SUBST;</a>
<a name="ln6323">    }</a>
<a name="ln6324"> </a>
<a name="ln6325">    // 5: substitute</a>
<a name="ln6326">    pl2 = pl + 1;</a>
<a name="ln6327">    ps2 = ps + 1;</a>
<a name="ln6328">    while (*pl2 == *ps2) {</a>
<a name="ln6329">      if (*pl2 == NUL)                  // reached the end</a>
<a name="ln6330">        return score + SCORE_SUBST;</a>
<a name="ln6331">      ++pl2;</a>
<a name="ln6332">      ++ps2;</a>
<a name="ln6333">    }</a>
<a name="ln6334"> </a>
<a name="ln6335">    // 6: substitute and swap</a>
<a name="ln6336">    if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln6337">        &amp;&amp; STRCMP(pl2 + 2, ps2 + 2) == 0)</a>
<a name="ln6338">      return score + SCORE_SUBST + SCORE_SWAP;</a>
<a name="ln6339"> </a>
<a name="ln6340">    // 7: substitute and substitute</a>
<a name="ln6341">    if (STRCMP(pl2 + 1, ps2 + 1) == 0)</a>
<a name="ln6342">      return score + SCORE_SUBST + SCORE_SUBST;</a>
<a name="ln6343"> </a>
<a name="ln6344">    // 8: insert then delete</a>
<a name="ln6345">    pl2 = pl;</a>
<a name="ln6346">    ps2 = ps + 1;</a>
<a name="ln6347">    while (*pl2 == *ps2) {</a>
<a name="ln6348">      ++pl2;</a>
<a name="ln6349">      ++ps2;</a>
<a name="ln6350">    }</a>
<a name="ln6351">    if (STRCMP(pl2 + 1, ps2) == 0)</a>
<a name="ln6352">      return score + SCORE_INS + SCORE_DEL;</a>
<a name="ln6353"> </a>
<a name="ln6354">    // 9: delete then insert</a>
<a name="ln6355">    pl2 = pl + 1;</a>
<a name="ln6356">    ps2 = ps;</a>
<a name="ln6357">    while (*pl2 == *ps2) {</a>
<a name="ln6358">      ++pl2;</a>
<a name="ln6359">      ++ps2;</a>
<a name="ln6360">    }</a>
<a name="ln6361">    if (STRCMP(pl2, ps2 + 1) == 0)</a>
<a name="ln6362">      return score + SCORE_INS + SCORE_DEL;</a>
<a name="ln6363"> </a>
<a name="ln6364">    // Failed to compare.</a>
<a name="ln6365">    break;</a>
<a name="ln6366">  }</a>
<a name="ln6367"> </a>
<a name="ln6368">  return SCORE_MAXMAX;</a>
<a name="ln6369">}</a>
<a name="ln6370"> </a>
<a name="ln6371">// Compute the &quot;edit distance&quot; to turn &quot;badword&quot; into &quot;goodword&quot;.  The less</a>
<a name="ln6372">// deletes/inserts/substitutes/swaps are required the lower the score.</a>
<a name="ln6373">//</a>
<a name="ln6374">// The algorithm is described by Du and Chang, 1992.</a>
<a name="ln6375">// The implementation of the algorithm comes from Aspell editdist.cpp,</a>
<a name="ln6376">// edit_distance().  It has been converted from C++ to C and modified to</a>
<a name="ln6377">// support multi-byte characters.</a>
<a name="ln6378">static int spell_edit_score(slang_T *slang, char_u *badword, char_u *goodword)</a>
<a name="ln6379">{</a>
<a name="ln6380">  int *cnt;</a>
<a name="ln6381">  int j, i;</a>
<a name="ln6382">  int t;</a>
<a name="ln6383">  int bc, gc;</a>
<a name="ln6384">  int pbc, pgc;</a>
<a name="ln6385">  int wbadword[MAXWLEN];</a>
<a name="ln6386">  int wgoodword[MAXWLEN];</a>
<a name="ln6387"> </a>
<a name="ln6388">  // Lengths with NUL.</a>
<a name="ln6389">  int badlen;</a>
<a name="ln6390">  int goodlen;</a>
<a name="ln6391">  {</a>
<a name="ln6392">    // Get the characters from the multi-byte strings and put them in an</a>
<a name="ln6393">    // int array for easy access.</a>
<a name="ln6394">    badlen = 0;</a>
<a name="ln6395">    for (const char_u *p = badword; *p != NUL; ) {</a>
<a name="ln6396">      wbadword[badlen++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6397">    }</a>
<a name="ln6398">    wbadword[badlen++] = 0;</a>
<a name="ln6399">    goodlen = 0;</a>
<a name="ln6400">    for (const char_u *p = goodword; *p != NUL; ) {</a>
<a name="ln6401">      wgoodword[goodlen++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6402">    }</a>
<a name="ln6403">    wgoodword[goodlen++] = 0;</a>
<a name="ln6404">  }</a>
<a name="ln6405"> </a>
<a name="ln6406">  // We use &quot;cnt&quot; as an array: CNT(badword_idx, goodword_idx).</a>
<a name="ln6407">#define CNT(a, b)   cnt[(a) + (b) * (badlen + 1)]</a>
<a name="ln6408">  cnt = xmalloc(sizeof(int) * (badlen + 1) * (goodlen + 1));</a>
<a name="ln6409"> </a>
<a name="ln6410">  CNT(0, 0) = 0;</a>
<a name="ln6411">  for (j = 1; j &lt;= goodlen; ++j)</a>
<a name="ln6412">    CNT(0, j) = CNT(0, j - 1) + SCORE_INS;</a>
<a name="ln6413"> </a>
<a name="ln6414">  for (i = 1; i &lt;= badlen; ++i) {</a>
<a name="ln6415">    CNT(i, 0) = CNT(i - 1, 0) + SCORE_DEL;</a>
<a name="ln6416">    for (j = 1; j &lt;= goodlen; j++) {</a>
<a name="ln6417">      bc = wbadword[i - 1];</a>
<a name="ln6418">      gc = wgoodword[j - 1];</a>
<a name="ln6419">      if (bc == gc) {</a>
<a name="ln6420">        CNT(i, j) = CNT(i - 1, j - 1);</a>
<a name="ln6421">      } else {</a>
<a name="ln6422">        // Use a better score when there is only a case difference.</a>
<a name="ln6423">        if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))</a>
<a name="ln6424">          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);</a>
<a name="ln6425">        else {</a>
<a name="ln6426">          // For a similar character use SCORE_SIMILAR.</a>
<a name="ln6427">          if (slang != NULL</a>
<a name="ln6428">              &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln6429">              &amp;&amp; similar_chars(slang, gc, bc))</a>
<a name="ln6430">            CNT(i, j) = SCORE_SIMILAR + CNT(i - 1, j - 1);</a>
<a name="ln6431">          else</a>
<a name="ln6432">            CNT(i, j) = SCORE_SUBST + CNT(i - 1, j - 1);</a>
<a name="ln6433">        }</a>
<a name="ln6434"> </a>
<a name="ln6435">        if (i &gt; 1 &amp;&amp; j &gt; 1) {</a>
<a name="ln6436">          pbc = wbadword[i - 2];</a>
<a name="ln6437">          pgc = wgoodword[j - 2];</a>
<a name="ln6438">          if (bc == pgc &amp;&amp; pbc == gc) {</a>
<a name="ln6439">            t = SCORE_SWAP + CNT(i - 2, j - 2);</a>
<a name="ln6440">            if (t &lt; CNT(i, j))</a>
<a name="ln6441">              CNT(i, j) = t;</a>
<a name="ln6442">          }</a>
<a name="ln6443">        }</a>
<a name="ln6444">        t = SCORE_DEL + CNT(i - 1, j);</a>
<a name="ln6445">        if (t &lt; CNT(i, j))</a>
<a name="ln6446">          CNT(i, j) = t;</a>
<a name="ln6447">        t = SCORE_INS + CNT(i, j - 1);</a>
<a name="ln6448">        if (t &lt; CNT(i, j))</a>
<a name="ln6449">          CNT(i, j) = t;</a>
<a name="ln6450">      }</a>
<a name="ln6451">    }</a>
<a name="ln6452">  }</a>
<a name="ln6453"> </a>
<a name="ln6454">  i = CNT(badlen - 1, goodlen - 1);</a>
<a name="ln6455">  xfree(cnt);</a>
<a name="ln6456">  return i;</a>
<a name="ln6457">}</a>
<a name="ln6458"> </a>
<a name="ln6459">// Like spell_edit_score(), but with a limit on the score to make it faster.</a>
<a name="ln6460">// May return SCORE_MAXMAX when the score is higher than &quot;limit&quot;.</a>
<a name="ln6461">//</a>
<a name="ln6462">// This uses a stack for the edits still to be tried.</a>
<a name="ln6463">// The idea comes from Aspell leditdist.cpp.  Rewritten in C and added support</a>
<a name="ln6464">// for multi-byte characters.</a>
<a name="ln6465">static int spell_edit_score_limit(slang_T *slang, char_u *badword, char_u *goodword, int limit)</a>
<a name="ln6466">{</a>
<a name="ln6467">  return spell_edit_score_limit_w(slang, badword, goodword, limit);</a>
<a name="ln6468">}</a>
<a name="ln6469"> </a>
<a name="ln6470">// Multi-byte version of spell_edit_score_limit().</a>
<a name="ln6471">// Keep it in sync with the above!</a>
<a name="ln6472">static int spell_edit_score_limit_w(slang_T *slang, char_u *badword, char_u *goodword, int limit)</a>
<a name="ln6473">{</a>
<a name="ln6474">  limitscore_T stack[10];               // allow for over 3 * 2 edits</a>
<a name="ln6475">  int stackidx;</a>
<a name="ln6476">  int bi, gi;</a>
<a name="ln6477">  int bi2, gi2;</a>
<a name="ln6478">  int bc, gc;</a>
<a name="ln6479">  int score;</a>
<a name="ln6480">  int score_off;</a>
<a name="ln6481">  int minscore;</a>
<a name="ln6482">  int round;</a>
<a name="ln6483">  int wbadword[MAXWLEN];</a>
<a name="ln6484">  int wgoodword[MAXWLEN];</a>
<a name="ln6485"> </a>
<a name="ln6486">  // Get the characters from the multi-byte strings and put them in an</a>
<a name="ln6487">  // int array for easy access.</a>
<a name="ln6488">  bi = 0;</a>
<a name="ln6489">  for (const char_u *p = badword; *p != NUL; ) {</a>
<a name="ln6490">    wbadword[bi++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6491">  }</a>
<a name="ln6492">  wbadword[bi++] = 0;</a>
<a name="ln6493">  gi = 0;</a>
<a name="ln6494">  for (const char_u *p = goodword; *p != NUL; ) {</a>
<a name="ln6495">    wgoodword[gi++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6496">  }</a>
<a name="ln6497">  wgoodword[gi++] = 0;</a>
<a name="ln6498"> </a>
<a name="ln6499">  // The idea is to go from start to end over the words.  So long as</a>
<a name="ln6500">  // characters are equal just continue, this always gives the lowest score.</a>
<a name="ln6501">  // When there is a difference try several alternatives.  Each alternative</a>
<a name="ln6502">  // increases &quot;score&quot; for the edit distance.  Some of the alternatives are</a>
<a name="ln6503">  // pushed unto a stack and tried later, some are tried right away.  At the</a>
<a name="ln6504">  // end of the word the score for one alternative is known.  The lowest</a>
<a name="ln6505">  // possible score is stored in &quot;minscore&quot;.</a>
<a name="ln6506">  stackidx = 0;</a>
<a name="ln6507">  bi = 0;</a>
<a name="ln6508">  gi = 0;</a>
<a name="ln6509">  score = 0;</a>
<a name="ln6510">  minscore = limit + 1;</a>
<a name="ln6511"> </a>
<a name="ln6512">  for (;; ) {</a>
<a name="ln6513">    // Skip over an equal part, score remains the same.</a>
<a name="ln6514">    for (;; ) {</a>
<a name="ln6515">      bc = wbadword[bi];</a>
<a name="ln6516">      gc = wgoodword[gi];</a>
<a name="ln6517"> </a>
<a name="ln6518">      if (bc != gc)             // stop at a char that's different</a>
<a name="ln6519">        break;</a>
<a name="ln6520">      if (bc == NUL) {          // both words end</a>
<a name="ln6521">        if (score &lt; minscore)</a>
<a name="ln6522">          minscore = score;</a>
<a name="ln6523">        goto pop;               // do next alternative</a>
<a name="ln6524">      }</a>
<a name="ln6525">      ++bi;</a>
<a name="ln6526">      ++gi;</a>
<a name="ln6527">    }</a>
<a name="ln6528"> </a>
<a name="ln6529">    if (gc == NUL) {      // goodword ends, delete badword chars</a>
<a name="ln6530">      do {</a>
<a name="ln6531">        if ((score += SCORE_DEL) &gt;= minscore)</a>
<a name="ln6532">          goto pop;                 // do next alternative</a>
<a name="ln6533">      } while (wbadword[++bi] != NUL);</a>
<a name="ln6534">      minscore = score;</a>
<a name="ln6535">    } else if (bc == NUL)   { // badword ends, insert badword chars</a>
<a name="ln6536">      do {</a>
<a name="ln6537">        if ((score += SCORE_INS) &gt;= minscore)</a>
<a name="ln6538">          goto pop;                 // do next alternative</a>
<a name="ln6539">      } while (wgoodword[++gi] != NUL);</a>
<a name="ln6540">      minscore = score;</a>
<a name="ln6541">    } else {                  // both words continue</a>
<a name="ln6542">      // If not close to the limit, perform a change.  Only try changes</a>
<a name="ln6543">      // that may lead to a lower score than &quot;minscore&quot;.</a>
<a name="ln6544">      // round 0: try deleting a char from badword</a>
<a name="ln6545">      // round 1: try inserting a char in badword</a>
<a name="ln6546">      for (round = 0; round &lt;= 1; ++round) {</a>
<a name="ln6547">        score_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);</a>
<a name="ln6548">        if (score_off &lt; minscore) {</a>
<a name="ln6549">          if (score_off + SCORE_EDIT_MIN &gt;= minscore) {</a>
<a name="ln6550">            // Near the limit, rest of the words must match.  We</a>
<a name="ln6551">            // can check that right now, no need to push an item</a>
<a name="ln6552">            // onto the stack.</a>
<a name="ln6553">            bi2 = bi + 1 - round;</a>
<a name="ln6554">            gi2 = gi + round;</a>
<a name="ln6555">            while (wgoodword[gi2] == wbadword[bi2]) {</a>
<a name="ln6556">              if (wgoodword[gi2] == NUL) {</a>
<a name="ln6557">                minscore = score_off;</a>
<a name="ln6558">                break;</a>
<a name="ln6559">              }</a>
<a name="ln6560">              ++bi2;</a>
<a name="ln6561">              ++gi2;</a>
<a name="ln6562">            }</a>
<a name="ln6563">          } else {</a>
<a name="ln6564">            // try deleting a character from badword later</a>
<a name="ln6565">            stack[stackidx].badi = bi + 1 - round;</a>
<a name="ln6566">            stack[stackidx].goodi = gi + round;</a>
<a name="ln6567">            stack[stackidx].score = score_off;</a>
<a name="ln6568">            ++stackidx;</a>
<a name="ln6569">          }</a>
<a name="ln6570">        }</a>
<a name="ln6571">      }</a>
<a name="ln6572"> </a>
<a name="ln6573">      if (score + SCORE_SWAP &lt; minscore) {</a>
<a name="ln6574">        // If swapping two characters makes a match then the</a>
<a name="ln6575">        // substitution is more expensive, thus there is no need to</a>
<a name="ln6576">        // try both.</a>
<a name="ln6577">        if (gc == wbadword[bi + 1] &amp;&amp; bc == wgoodword[gi + 1]) {</a>
<a name="ln6578">          // Swap two characters, that is: skip them.</a>
<a name="ln6579">          gi += 2;</a>
<a name="ln6580">          bi += 2;</a>
<a name="ln6581">          score += SCORE_SWAP;</a>
<a name="ln6582">          continue;</a>
<a name="ln6583">        }</a>
<a name="ln6584">      }</a>
<a name="ln6585"> </a>
<a name="ln6586">      // Substitute one character for another which is the same</a>
<a name="ln6587">      // thing as deleting a character from both goodword and badword.</a>
<a name="ln6588">      // Use a better score when there is only a case difference.</a>
<a name="ln6589">      if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc))</a>
<a name="ln6590">        score += SCORE_ICASE;</a>
<a name="ln6591">      else {</a>
<a name="ln6592">        // For a similar character use SCORE_SIMILAR.</a>
<a name="ln6593">        if (slang != NULL</a>
<a name="ln6594">            &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln6595">            &amp;&amp; similar_chars(slang, gc, bc))</a>
<a name="ln6596">          score += SCORE_SIMILAR;</a>
<a name="ln6597">        else</a>
<a name="ln6598">          score += SCORE_SUBST;</a>
<a name="ln6599">      }</a>
<a name="ln6600"> </a>
<a name="ln6601">      if (score &lt; minscore) {</a>
<a name="ln6602">        // Do the substitution.</a>
<a name="ln6603">        ++gi;</a>
<a name="ln6604">        ++bi;</a>
<a name="ln6605">        continue;</a>
<a name="ln6606">      }</a>
<a name="ln6607">    }</a>
<a name="ln6608">pop:</a>
<a name="ln6609">    // Get here to try the next alternative, pop it from the stack.</a>
<a name="ln6610">    if (stackidx == 0)                  // stack is empty, finished</a>
<a name="ln6611">      break;</a>
<a name="ln6612"> </a>
<a name="ln6613">    // pop an item from the stack</a>
<a name="ln6614">    --stackidx;</a>
<a name="ln6615">    gi = stack[stackidx].goodi;</a>
<a name="ln6616">    bi = stack[stackidx].badi;</a>
<a name="ln6617">    score = stack[stackidx].score;</a>
<a name="ln6618">  }</a>
<a name="ln6619"> </a>
<a name="ln6620">  // When the score goes over &quot;limit&quot; it may actually be much higher.</a>
<a name="ln6621">  // Return a very large number to avoid going below the limit when giving a</a>
<a name="ln6622">  // bonus.</a>
<a name="ln6623">  if (minscore &gt; limit)</a>
<a name="ln6624">    return SCORE_MAXMAX;</a>
<a name="ln6625">  return minscore;</a>
<a name="ln6626">}</a>
<a name="ln6627"> </a>
<a name="ln6628">// &quot;:spellinfo&quot;</a>
<a name="ln6629">void ex_spellinfo(exarg_T *eap)</a>
<a name="ln6630">{</a>
<a name="ln6631">  if (no_spell_checking(curwin)) {</a>
<a name="ln6632">    return;</a>
<a name="ln6633">  }</a>
<a name="ln6634"> </a>
<a name="ln6635">  msg_start();</a>
<a name="ln6636">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len &amp;&amp; !got_int; lpi++) {</a>
<a name="ln6637">    langp_T *const lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln6638">    msg_puts(&quot;file: &quot;);</a>
<a name="ln6639">    msg_puts((const char *)lp-&gt;lp_slang-&gt;sl_fname);</a>
<a name="ln6640">    msg_putchar('\n');</a>
<a name="ln6641">    const char *const p = (const char *)lp-&gt;lp_slang-&gt;sl_info;</a>
<a name="ln6642">    if (p != NULL) {</a>
<a name="ln6643">      msg_puts(p);</a>
<a name="ln6644">      msg_putchar('\n');</a>
<a name="ln6645">    }</a>
<a name="ln6646">  }</a>
<a name="ln6647">  msg_end();</a>
<a name="ln6648">}</a>
<a name="ln6649"> </a>
<a name="ln6650">#define DUMPFLAG_KEEPCASE   1   // round 2: keep-case tree</a>
<a name="ln6651">#define DUMPFLAG_COUNT      2   // include word count</a>
<a name="ln6652">#define DUMPFLAG_ICASE      4   // ignore case when finding matches</a>
<a name="ln6653">#define DUMPFLAG_ONECAP     8   // pattern starts with capital</a>
<a name="ln6654">#define DUMPFLAG_ALLCAP     16  // pattern is all capitals</a>
<a name="ln6655"> </a>
<a name="ln6656">// &quot;:spelldump&quot;</a>
<a name="ln6657">void ex_spelldump(exarg_T *eap)</a>
<a name="ln6658">{</a>
<a name="ln6659">  char_u  *spl;</a>
<a name="ln6660">  long dummy;</a>
<a name="ln6661"> </a>
<a name="ln6662">  if (no_spell_checking(curwin)) {</a>
<a name="ln6663">    return;</a>
<a name="ln6664">  }</a>
<a name="ln6665">  get_option_value(&quot;spl&quot;, &amp;dummy, &amp;spl, OPT_LOCAL);</a>
<a name="ln6666"> </a>
<a name="ln6667">  // Create a new empty buffer in a new window.</a>
<a name="ln6668">  do_cmdline_cmd(&quot;new&quot;);</a>
<a name="ln6669"> </a>
<a name="ln6670">  // enable spelling locally in the new window</a>
<a name="ln6671">  set_option_value(&quot;spell&quot;, true, &quot;&quot;, OPT_LOCAL);</a>
<a name="ln6672">  set_option_value(&quot;spl&quot;,  dummy, (char *)spl, OPT_LOCAL);</a>
<a name="ln6673">  xfree(spl);</a>
<a name="ln6674"> </a>
<a name="ln6675">  if (!BUFEMPTY()) {</a>
<a name="ln6676">    return;</a>
<a name="ln6677">  }</a>
<a name="ln6678"> </a>
<a name="ln6679">  spell_dump_compl(NULL, 0, NULL, eap-&gt;forceit ? DUMPFLAG_COUNT : 0);</a>
<a name="ln6680"> </a>
<a name="ln6681">  // Delete the empty line that we started with.</a>
<a name="ln6682">  if (curbuf-&gt;b_ml.ml_line_count &gt; 1) {</a>
<a name="ln6683">    ml_delete(curbuf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln6684">  }</a>
<a name="ln6685">  redraw_later(curwin, NOT_VALID);</a>
<a name="ln6686">}</a>
<a name="ln6687"> </a>
<a name="ln6688">// Go through all possible words and:</a>
<a name="ln6689">// 1. When &quot;pat&quot; is NULL: dump a list of all words in the current buffer.</a>
<a name="ln6690">//      &quot;ic&quot; and &quot;dir&quot; are not used.</a>
<a name="ln6691">// 2. When &quot;pat&quot; is not NULL: add matching words to insert mode completion.</a>
<a name="ln6692">void</a>
<a name="ln6693">spell_dump_compl (</a>
<a name="ln6694">    char_u *pat,           // leading part of the word</a>
<a name="ln6695">    int ic,                     // ignore case</a>
<a name="ln6696">    Direction *dir,        // direction for adding matches</a>
<a name="ln6697">    int dumpflags_arg              // DUMPFLAG_*</a>
<a name="ln6698">)</a>
<a name="ln6699">{</a>
<a name="ln6700">  langp_T     *lp;</a>
<a name="ln6701">  slang_T     *slang;</a>
<a name="ln6702">  idx_T arridx[MAXWLEN];</a>
<a name="ln6703">  int curi[MAXWLEN];</a>
<a name="ln6704">  char_u word[MAXWLEN];</a>
<a name="ln6705">  int c;</a>
<a name="ln6706">  char_u      *byts;</a>
<a name="ln6707">  idx_T       *idxs;</a>
<a name="ln6708">  linenr_T lnum = 0;</a>
<a name="ln6709">  int round;</a>
<a name="ln6710">  int depth;</a>
<a name="ln6711">  int n;</a>
<a name="ln6712">  int flags;</a>
<a name="ln6713">  char_u      *region_names = NULL;         // region names being used</a>
<a name="ln6714">  bool do_region = true;                    // dump region names and numbers</a>
<a name="ln6715">  char_u      *p;</a>
<a name="ln6716">  int dumpflags = dumpflags_arg;</a>
<a name="ln6717">  int patlen;</a>
<a name="ln6718"> </a>
<a name="ln6719">  // When ignoring case or when the pattern starts with capital pass this on</a>
<a name="ln6720">  // to dump_word().</a>
<a name="ln6721">  if (pat != NULL) {</a>
<a name="ln6722">    if (ic)</a>
<a name="ln6723">      dumpflags |= DUMPFLAG_ICASE;</a>
<a name="ln6724">    else {</a>
<a name="ln6725">      n = captype(pat, NULL);</a>
<a name="ln6726">      if (n == WF_ONECAP)</a>
<a name="ln6727">        dumpflags |= DUMPFLAG_ONECAP;</a>
<a name="ln6728">      else if (n == WF_ALLCAP</a>
<a name="ln6729">               &amp;&amp; (int)STRLEN(pat) &gt; mb_ptr2len(pat)</a>
<a name="ln6730">               )</a>
<a name="ln6731">        dumpflags |= DUMPFLAG_ALLCAP;</a>
<a name="ln6732">    }</a>
<a name="ln6733">  }</a>
<a name="ln6734"> </a>
<a name="ln6735">  // Find out if we can support regions: All languages must support the same</a>
<a name="ln6736">  // regions or none at all.</a>
<a name="ln6737">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln6738">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln6739">    p = lp-&gt;lp_slang-&gt;sl_regions;</a>
<a name="ln6740">    if (p[0] != 0) {</a>
<a name="ln6741">      if (region_names == NULL)             // first language with regions</a>
<a name="ln6742">        region_names = p;</a>
<a name="ln6743">      else if (STRCMP(region_names, p) != 0) {</a>
<a name="ln6744">        do_region = false;                  // region names are different</a>
<a name="ln6745">        break;</a>
<a name="ln6746">      }</a>
<a name="ln6747">    }</a>
<a name="ln6748">  }</a>
<a name="ln6749"> </a>
<a name="ln6750">  if (do_region &amp;&amp; region_names != NULL) {</a>
<a name="ln6751">    if (pat == NULL) {</a>
<a name="ln6752">      vim_snprintf((char *)IObuff, IOSIZE, &quot;/regions=%s&quot;, region_names);</a>
<a name="ln6753">      ml_append(lnum++, IObuff, (colnr_T)0, false);</a>
<a name="ln6754">    }</a>
<a name="ln6755">  } else</a>
<a name="ln6756">    do_region = false;</a>
<a name="ln6757"> </a>
<a name="ln6758">  // Loop over all files loaded for the entries in 'spelllang'.</a>
<a name="ln6759">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln6760">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln6761">    slang = lp-&gt;lp_slang;</a>
<a name="ln6762">    if (slang-&gt;sl_fbyts == NULL)            // reloading failed</a>
<a name="ln6763">      continue;</a>
<a name="ln6764"> </a>
<a name="ln6765">    if (pat == NULL) {</a>
<a name="ln6766">      vim_snprintf((char *)IObuff, IOSIZE, &quot;# file: %s&quot;, slang-&gt;sl_fname);</a>
<a name="ln6767">      ml_append(lnum++, IObuff, (colnr_T)0, false);</a>
<a name="ln6768">    }</a>
<a name="ln6769"> </a>
<a name="ln6770">    // When matching with a pattern and there are no prefixes only use</a>
<a name="ln6771">    // parts of the tree that match &quot;pat&quot;.</a>
<a name="ln6772">    if (pat != NULL &amp;&amp; slang-&gt;sl_pbyts == NULL)</a>
<a name="ln6773">      patlen = (int)STRLEN(pat);</a>
<a name="ln6774">    else</a>
<a name="ln6775">      patlen = -1;</a>
<a name="ln6776"> </a>
<a name="ln6777">    // round 1: case-folded tree</a>
<a name="ln6778">    // round 2: keep-case tree</a>
<a name="ln6779">    for (round = 1; round &lt;= 2; ++round) {</a>
<a name="ln6780">      if (round == 1) {</a>
<a name="ln6781">        dumpflags &amp;= ~DUMPFLAG_KEEPCASE;</a>
<a name="ln6782">        byts = slang-&gt;sl_fbyts;</a>
<a name="ln6783">        idxs = slang-&gt;sl_fidxs;</a>
<a name="ln6784">      } else {</a>
<a name="ln6785">        dumpflags |= DUMPFLAG_KEEPCASE;</a>
<a name="ln6786">        byts = slang-&gt;sl_kbyts;</a>
<a name="ln6787">        idxs = slang-&gt;sl_kidxs;</a>
<a name="ln6788">      }</a>
<a name="ln6789">      if (byts == NULL)</a>
<a name="ln6790">        continue;                       // array is empty</a>
<a name="ln6791"> </a>
<a name="ln6792">      depth = 0;</a>
<a name="ln6793">      arridx[0] = 0;</a>
<a name="ln6794">      curi[0] = 1;</a>
<a name="ln6795">      while (depth &gt;= 0 &amp;&amp; !got_int</a>
<a name="ln6796">             &amp;&amp; (pat == NULL || !compl_interrupted)) {</a>
<a name="ln6797">        if (curi[depth] &gt; byts[arridx[depth]]) {</a>
<a name="ln6798">          // Done all bytes at this node, go up one level.</a>
<a name="ln6799">          --depth;</a>
<a name="ln6800">          line_breakcheck();</a>
<a name="ln6801">          ins_compl_check_keys(50, false);</a>
<a name="ln6802">        } else {</a>
<a name="ln6803">          // Do one more byte at this node.</a>
<a name="ln6804">          n = arridx[depth] + curi[depth];</a>
<a name="ln6805">          ++curi[depth];</a>
<a name="ln6806">          c = byts[n];</a>
<a name="ln6807">          if (c == 0) {</a>
<a name="ln6808">            // End of word, deal with the word.</a>
<a name="ln6809">            // Don't use keep-case words in the fold-case tree,</a>
<a name="ln6810">            // they will appear in the keep-case tree.</a>
<a name="ln6811">            // Only use the word when the region matches.</a>
<a name="ln6812">            flags = (int)idxs[n];</a>
<a name="ln6813">            if ((round == 2 || (flags &amp; WF_KEEPCAP) == 0)</a>
<a name="ln6814">                &amp;&amp; (flags &amp; WF_NEEDCOMP) == 0</a>
<a name="ln6815">                &amp;&amp; (do_region</a>
<a name="ln6816">                    || (flags &amp; WF_REGION) == 0</a>
<a name="ln6817">                    || (((unsigned)flags &gt;&gt; 16)</a>
<a name="ln6818">                        &amp; lp-&gt;lp_region) != 0)) {</a>
<a name="ln6819">              word[depth] = NUL;</a>
<a name="ln6820">              if (!do_region)</a>
<a name="ln6821">                flags &amp;= ~WF_REGION;</a>
<a name="ln6822"> </a>
<a name="ln6823">              // Dump the basic word if there is no prefix or</a>
<a name="ln6824">              // when it's the first one.</a>
<a name="ln6825">              c = (unsigned)flags &gt;&gt; 24;</a>
<a name="ln6826">              if (c == 0 || curi[depth] == 2) {</a>
<a name="ln6827">                dump_word(slang, word, pat, dir,</a>
<a name="ln6828">                    dumpflags, flags, lnum);</a>
<a name="ln6829">                if (pat == NULL)</a>
<a name="ln6830">                  ++lnum;</a>
<a name="ln6831">              }</a>
<a name="ln6832"> </a>
<a name="ln6833">              // Apply the prefix, if there is one.</a>
<a name="ln6834">              if (c != 0)</a>
<a name="ln6835">                lnum = dump_prefixes(slang, word, pat, dir,</a>
<a name="ln6836">                    dumpflags, flags, lnum);</a>
<a name="ln6837">            }</a>
<a name="ln6838">          } else {</a>
<a name="ln6839">            // Normal char, go one level deeper.</a>
<a name="ln6840">            word[depth++] = c;</a>
<a name="ln6841">            arridx[depth] = idxs[n];</a>
<a name="ln6842">            curi[depth] = 1;</a>
<a name="ln6843"> </a>
<a name="ln6844">            // Check if this characters matches with the pattern.</a>
<a name="ln6845">            // If not skip the whole tree below it.</a>
<a name="ln6846">            // Always ignore case here, dump_word() will check</a>
<a name="ln6847">            // proper case later.  This isn't exactly right when</a>
<a name="ln6848">            // length changes for multi-byte characters with</a>
<a name="ln6849">            // ignore case...</a>
<a name="ln6850">            assert(depth &gt;= 0);</a>
<a name="ln6851">            if (depth &lt;= patlen</a>
<a name="ln6852">                &amp;&amp; mb_strnicmp(word, pat, (size_t)depth) != 0)</a>
<a name="ln6853">              --depth;</a>
<a name="ln6854">          }</a>
<a name="ln6855">        }</a>
<a name="ln6856">      }</a>
<a name="ln6857">    }</a>
<a name="ln6858">  }</a>
<a name="ln6859">}</a>
<a name="ln6860"> </a>
<a name="ln6861">// Dumps one word: apply case modifications and append a line to the buffer.</a>
<a name="ln6862">// When &quot;lnum&quot; is zero add insert mode completion.</a>
<a name="ln6863">static void dump_word(slang_T *slang, char_u *word, char_u *pat,</a>
<a name="ln6864">                      Direction *dir, int dumpflags, int wordflags,</a>
<a name="ln6865">                      linenr_T lnum)</a>
<a name="ln6866">{</a>
<a name="ln6867">  bool keepcap = false;</a>
<a name="ln6868">  char_u      *p;</a>
<a name="ln6869">  char_u      *tw;</a>
<a name="ln6870">  char_u cword[MAXWLEN];</a>
<a name="ln6871">  char_u badword[MAXWLEN + 10];</a>
<a name="ln6872">  int i;</a>
<a name="ln6873">  int flags = wordflags;</a>
<a name="ln6874"> </a>
<a name="ln6875">  if (dumpflags &amp; DUMPFLAG_ONECAP)</a>
<a name="ln6876">    flags |= WF_ONECAP;</a>
<a name="ln6877">  if (dumpflags &amp; DUMPFLAG_ALLCAP)</a>
<a name="ln6878">    flags |= WF_ALLCAP;</a>
<a name="ln6879"> </a>
<a name="ln6880">  if ((dumpflags &amp; DUMPFLAG_KEEPCASE) == 0 &amp;&amp; (flags &amp; WF_CAPMASK) != 0) {</a>
<a name="ln6881">    // Need to fix case according to &quot;flags&quot;.</a>
<a name="ln6882">    make_case_word(word, cword, flags);</a>
<a name="ln6883">    p = cword;</a>
<a name="ln6884">  } else {</a>
<a name="ln6885">    p = word;</a>
<a name="ln6886">    if ((dumpflags &amp; DUMPFLAG_KEEPCASE)</a>
<a name="ln6887">        &amp;&amp; ((captype(word, NULL) &amp; WF_KEEPCAP) == 0</a>
<a name="ln6888">            || (flags &amp; WF_FIXCAP) != 0))</a>
<a name="ln6889">      keepcap = true;</a>
<a name="ln6890">  }</a>
<a name="ln6891">  tw = p;</a>
<a name="ln6892"> </a>
<a name="ln6893">  if (pat == NULL) {</a>
<a name="ln6894">    // Add flags and regions after a slash.</a>
<a name="ln6895">    if ((flags &amp; (WF_BANNED | WF_RARE | WF_REGION)) || keepcap) {</a>
<a name="ln6896">      STRCPY(badword, p);</a>
<a name="ln6897">      STRCAT(badword, &quot;/&quot;);</a>
<a name="ln6898">      if (keepcap) {</a>
<a name="ln6899">        STRCAT(badword, &quot;=&quot;);</a>
<a name="ln6900">      }</a>
<a name="ln6901">      if (flags &amp; WF_BANNED) {</a>
<a name="ln6902">        STRCAT(badword, &quot;!&quot;);</a>
<a name="ln6903">      } else if (flags &amp; WF_RARE) {</a>
<a name="ln6904">        STRCAT(badword, &quot;?&quot;);</a>
<a name="ln6905">      }</a>
<a name="ln6906">      if (flags &amp; WF_REGION) {</a>
<a name="ln6907">        for (i = 0; i &lt; 7; i++) {</a>
<a name="ln6908">          if (flags &amp; (0x10000 &lt;&lt; i)) {</a>
<a name="ln6909">            const size_t badword_len = STRLEN(badword);</a>
<a name="ln6910">            snprintf((char *)badword + badword_len,</a>
<a name="ln6911">                     sizeof(badword) - badword_len,</a>
<a name="ln6912">                     &quot;%d&quot;, i + 1);</a>
<a name="ln6913">          }</a>
<a name="ln6914">        }</a>
<a name="ln6915">      }</a>
<a name="ln6916">      p = badword;</a>
<a name="ln6917">    }</a>
<a name="ln6918"> </a>
<a name="ln6919">    if (dumpflags &amp; DUMPFLAG_COUNT) {</a>
<a name="ln6920">      hashitem_T  *hi;</a>
<a name="ln6921"> </a>
<a name="ln6922">      // Include the word count for &quot;:spelldump!&quot;.</a>
<a name="ln6923">      hi = hash_find(&amp;slang-&gt;sl_wordcount, tw);</a>
<a name="ln6924">      if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln6925">        vim_snprintf((char *)IObuff, IOSIZE, &quot;%s\t%d&quot;,</a>
<a name="ln6926">            tw, HI2WC(hi)-&gt;wc_count);</a>
<a name="ln6927">        p = IObuff;</a>
<a name="ln6928">      }</a>
<a name="ln6929">    }</a>
<a name="ln6930"> </a>
<a name="ln6931">    ml_append(lnum, p, (colnr_T)0, false);</a>
<a name="ln6932">  } else if (((dumpflags &amp; DUMPFLAG_ICASE)</a>
<a name="ln6933">              ? mb_strnicmp(p, pat, STRLEN(pat)) == 0</a>
<a name="ln6934">              : STRNCMP(p, pat, STRLEN(pat)) == 0)</a>
<a name="ln6935">             &amp;&amp; ins_compl_add_infercase(p, (int)STRLEN(p),</a>
<a name="ln6936">                                        p_ic, NULL, *dir, false) == OK) {</a>
<a name="ln6937">    // if dir was BACKWARD then honor it just once</a>
<a name="ln6938">    *dir = FORWARD;</a>
<a name="ln6939">  }</a>
<a name="ln6940">}</a>
<a name="ln6941"> </a>
<a name="ln6942">// For &quot;:spelldump&quot;: Find matching prefixes for &quot;word&quot;.  Prepend each to</a>
<a name="ln6943">// &quot;word&quot; and append a line to the buffer.</a>
<a name="ln6944">// When &quot;lnum&quot; is zero add insert mode completion.</a>
<a name="ln6945">// Return the updated line number.</a>
<a name="ln6946">static linenr_T</a>
<a name="ln6947">dump_prefixes (</a>
<a name="ln6948">    slang_T *slang,</a>
<a name="ln6949">    char_u *word,          // case-folded word</a>
<a name="ln6950">    char_u *pat,</a>
<a name="ln6951">    Direction *dir,</a>
<a name="ln6952">    int dumpflags,</a>
<a name="ln6953">    int flags,                  // flags with prefix ID</a>
<a name="ln6954">    linenr_T startlnum</a>
<a name="ln6955">)</a>
<a name="ln6956">{</a>
<a name="ln6957">  idx_T arridx[MAXWLEN];</a>
<a name="ln6958">  int curi[MAXWLEN];</a>
<a name="ln6959">  char_u prefix[MAXWLEN];</a>
<a name="ln6960">  char_u word_up[MAXWLEN];</a>
<a name="ln6961">  bool has_word_up = false;</a>
<a name="ln6962">  int c;</a>
<a name="ln6963">  char_u      *byts;</a>
<a name="ln6964">  idx_T       *idxs;</a>
<a name="ln6965">  linenr_T lnum = startlnum;</a>
<a name="ln6966">  int depth;</a>
<a name="ln6967">  int n;</a>
<a name="ln6968">  int len;</a>
<a name="ln6969">  int i;</a>
<a name="ln6970"> </a>
<a name="ln6971">  // If the word starts with a lower-case letter make the word with an</a>
<a name="ln6972">  // upper-case letter in word_up[].</a>
<a name="ln6973">  c = PTR2CHAR(word);</a>
<a name="ln6974">  if (SPELL_TOUPPER(c) != c) {</a>
<a name="ln6975">    onecap_copy(word, word_up, true);</a>
<a name="ln6976">    has_word_up = true;</a>
<a name="ln6977">  }</a>
<a name="ln6978"> </a>
<a name="ln6979">  byts = slang-&gt;sl_pbyts;</a>
<a name="ln6980">  idxs = slang-&gt;sl_pidxs;</a>
<a name="ln6981">  if (byts != NULL) {           // array not is empty</a>
<a name="ln6982">    // Loop over all prefixes, building them byte-by-byte in prefix[].</a>
<a name="ln6983">    // When at the end of a prefix check that it supports &quot;flags&quot;.</a>
<a name="ln6984">    depth = 0;</a>
<a name="ln6985">    arridx[0] = 0;</a>
<a name="ln6986">    curi[0] = 1;</a>
<a name="ln6987">    while (depth &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln6988">      n = arridx[depth];</a>
<a name="ln6989">      len = byts[n];</a>
<a name="ln6990">      if (curi[depth] &gt; len) {</a>
<a name="ln6991">        // Done all bytes at this node, go up one level.</a>
<a name="ln6992">        --depth;</a>
<a name="ln6993">        line_breakcheck();</a>
<a name="ln6994">      } else {</a>
<a name="ln6995">        // Do one more byte at this node.</a>
<a name="ln6996">        n += curi[depth];</a>
<a name="ln6997">        ++curi[depth];</a>
<a name="ln6998">        c = byts[n];</a>
<a name="ln6999">        if (c == 0) {</a>
<a name="ln7000">          // End of prefix, find out how many IDs there are.</a>
<a name="ln7001">          for (i = 1; i &lt; len; ++i)</a>
<a name="ln7002">            if (byts[n + i] != 0)</a>
<a name="ln7003">              break;</a>
<a name="ln7004">          curi[depth] += i - 1;</a>
<a name="ln7005"> </a>
<a name="ln7006">          c = valid_word_prefix(i, n, flags, word, slang, false);</a>
<a name="ln7007">          if (c != 0) {</a>
<a name="ln7008">            STRLCPY(prefix + depth, word, MAXWLEN - depth);</a>
<a name="ln7009">            dump_word(slang, prefix, pat, dir, dumpflags,</a>
<a name="ln7010">                (c &amp; WF_RAREPFX) ? (flags | WF_RARE)</a>
<a name="ln7011">                : flags, lnum);</a>
<a name="ln7012">            if (lnum != 0)</a>
<a name="ln7013">              ++lnum;</a>
<a name="ln7014">          }</a>
<a name="ln7015"> </a>
<a name="ln7016">          // Check for prefix that matches the word when the</a>
<a name="ln7017">          // first letter is upper-case, but only if the prefix has</a>
<a name="ln7018">          // a condition.</a>
<a name="ln7019">          if (has_word_up) {</a>
<a name="ln7020">            c = valid_word_prefix(i, n, flags, word_up, slang,</a>
<a name="ln7021">                true);</a>
<a name="ln7022">            if (c != 0) {</a>
<a name="ln7023">              STRLCPY(prefix + depth, word_up, MAXWLEN - depth);</a>
<a name="ln7024">              dump_word(slang, prefix, pat, dir, dumpflags,</a>
<a name="ln7025">                  (c &amp; WF_RAREPFX) ? (flags | WF_RARE)</a>
<a name="ln7026">                  : flags, lnum);</a>
<a name="ln7027">              if (lnum != 0)</a>
<a name="ln7028">                ++lnum;</a>
<a name="ln7029">            }</a>
<a name="ln7030">          }</a>
<a name="ln7031">        } else {</a>
<a name="ln7032">          // Normal char, go one level deeper.</a>
<a name="ln7033">          prefix[depth++] = c;</a>
<a name="ln7034">          arridx[depth] = idxs[n];</a>
<a name="ln7035">          curi[depth] = 1;</a>
<a name="ln7036">        }</a>
<a name="ln7037">      }</a>
<a name="ln7038">    }</a>
<a name="ln7039">  }</a>
<a name="ln7040"> </a>
<a name="ln7041">  return lnum;</a>
<a name="ln7042">}</a>
<a name="ln7043"> </a>
<a name="ln7044">// Move &quot;p&quot; to the end of word &quot;start&quot;.</a>
<a name="ln7045">// Uses the spell-checking word characters.</a>
<a name="ln7046">char_u *spell_to_word_end(char_u *start, win_T *win)</a>
<a name="ln7047">{</a>
<a name="ln7048">  char_u  *p = start;</a>
<a name="ln7049"> </a>
<a name="ln7050">  while (*p != NUL &amp;&amp; spell_iswordp(p, win)) {</a>
<a name="ln7051">    MB_PTR_ADV(p);</a>
<a name="ln7052">  }</a>
<a name="ln7053">  return p;</a>
<a name="ln7054">}</a>
<a name="ln7055"> </a>
<a name="ln7056">// For Insert mode completion CTRL-X s:</a>
<a name="ln7057">// Find start of the word in front of column &quot;startcol&quot;.</a>
<a name="ln7058">// We don't check if it is badly spelled, with completion we can only change</a>
<a name="ln7059">// the word in front of the cursor.</a>
<a name="ln7060">// Returns the column number of the word.</a>
<a name="ln7061">int spell_word_start(int startcol)</a>
<a name="ln7062">{</a>
<a name="ln7063">  char_u      *line;</a>
<a name="ln7064">  char_u      *p;</a>
<a name="ln7065">  int col = 0;</a>
<a name="ln7066"> </a>
<a name="ln7067">  if (no_spell_checking(curwin)) {</a>
<a name="ln7068">    return startcol;</a>
<a name="ln7069">  }</a>
<a name="ln7070"> </a>
<a name="ln7071">  // Find a word character before &quot;startcol&quot;.</a>
<a name="ln7072">  line = get_cursor_line_ptr();</a>
<a name="ln7073">  for (p = line + startcol; p &gt; line; ) {</a>
<a name="ln7074">    MB_PTR_BACK(line, p);</a>
<a name="ln7075">    if (spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln7076">      break;</a>
<a name="ln7077">    }</a>
<a name="ln7078">  }</a>
<a name="ln7079"> </a>
<a name="ln7080">  // Go back to start of the word.</a>
<a name="ln7081">  while (p &gt; line) {</a>
<a name="ln7082">    col = (int)(p - line);</a>
<a name="ln7083">    MB_PTR_BACK(line, p);</a>
<a name="ln7084">    if (!spell_iswordp(p, curwin)) {</a>
<a name="ln7085">      break;</a>
<a name="ln7086">    }</a>
<a name="ln7087">    col = 0;</a>
<a name="ln7088">  }</a>
<a name="ln7089"> </a>
<a name="ln7090">  return col;</a>
<a name="ln7091">}</a>
<a name="ln7092"> </a>
<a name="ln7093">// Need to check for 'spellcapcheck' now, the word is removed before</a>
<a name="ln7094">// expand_spelling() is called.  Therefore the ugly global variable.</a>
<a name="ln7095">static bool spell_expand_need_cap;</a>
<a name="ln7096"> </a>
<a name="ln7097">void spell_expand_check_cap(colnr_T col)</a>
<a name="ln7098">{</a>
<a name="ln7099">  spell_expand_need_cap = check_need_cap(curwin-&gt;w_cursor.lnum, col);</a>
<a name="ln7100">}</a>
<a name="ln7101"> </a>
<a name="ln7102">// Get list of spelling suggestions.</a>
<a name="ln7103">// Used for Insert mode completion CTRL-X ?.</a>
<a name="ln7104">// Returns the number of matches.  The matches are in &quot;matchp[]&quot;, array of</a>
<a name="ln7105">// allocated strings.</a>
<a name="ln7106">int expand_spelling(linenr_T lnum, char_u *pat, char_u ***matchp)</a>
<a name="ln7107">{</a>
<a name="ln7108">  garray_T ga;</a>
<a name="ln7109"> </a>
<a name="ln7110">  spell_suggest_list(&amp;ga, pat, 100, spell_expand_need_cap, true);</a>
<a name="ln7111">  *matchp = ga.ga_data;</a>
<a name="ln7112">  return ga.ga_len;</a>
<a name="ln7113">}</a>

</code></pre>
<div class="balloon" rel="450"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array underrun is possible. The value of 'mi.mi_fwordlen - 1' index could reach -1.</p></div>
<div class="balloon" rel="5999"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v781/" target="_blank">V781</a> The value of the 'i' index is checked after it was used. Perhaps there is a mistake in program logic.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
