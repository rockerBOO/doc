
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_cmds.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * ex_cmds.c: some functions for command line commands</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;float.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;inttypes.h&gt;</a>
<a name="ln14">#include &lt;math.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln18">#include &quot;nvim/api/buffer.h&quot;</a>
<a name="ln19">#include &quot;nvim/log.h&quot;</a>
<a name="ln20">#include &quot;nvim/vim.h&quot;</a>
<a name="ln21">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln22">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln23">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln24">#include &quot;nvim/change.h&quot;</a>
<a name="ln25">#include &quot;nvim/charset.h&quot;</a>
<a name="ln26">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln27">#include &quot;nvim/diff.h&quot;</a>
<a name="ln28">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln29">#include &quot;nvim/edit.h&quot;</a>
<a name="ln30">#include &quot;nvim/eval.h&quot;</a>
<a name="ln31">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln32">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln33">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln34">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln35">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln36">#include &quot;nvim/fold.h&quot;</a>
<a name="ln37">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln38">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln39">#include &quot;nvim/indent.h&quot;</a>
<a name="ln40">#include &quot;nvim/buffer_updates.h&quot;</a>
<a name="ln41">#include &quot;nvim/main.h&quot;</a>
<a name="ln42">#include &quot;nvim/mark.h&quot;</a>
<a name="ln43">#include &quot;nvim/extmark.h&quot;</a>
<a name="ln44">#include &quot;nvim/decoration.h&quot;</a>
<a name="ln45">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln46">#include &quot;nvim/memline.h&quot;</a>
<a name="ln47">#include &quot;nvim/message.h&quot;</a>
<a name="ln48">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln49">#include &quot;nvim/garray.h&quot;</a>
<a name="ln50">#include &quot;nvim/memory.h&quot;</a>
<a name="ln51">#include &quot;nvim/move.h&quot;</a>
<a name="ln52">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln53">#include &quot;nvim/normal.h&quot;</a>
<a name="ln54">#include &quot;nvim/ops.h&quot;</a>
<a name="ln55">#include &quot;nvim/option.h&quot;</a>
<a name="ln56">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln57">#include &quot;nvim/path.h&quot;</a>
<a name="ln58">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln59">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln60">#include &quot;nvim/screen.h&quot;</a>
<a name="ln61">#include &quot;nvim/search.h&quot;</a>
<a name="ln62">#include &quot;nvim/spell.h&quot;</a>
<a name="ln63">#include &quot;nvim/strings.h&quot;</a>
<a name="ln64">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln65">#include &quot;nvim/tag.h&quot;</a>
<a name="ln66">#include &quot;nvim/ui.h&quot;</a>
<a name="ln67">#include &quot;nvim/undo.h&quot;</a>
<a name="ln68">#include &quot;nvim/window.h&quot;</a>
<a name="ln69">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln70">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln71">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln72">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75">/// Case matching style to use for :substitute</a>
<a name="ln76">typedef enum {</a>
<a name="ln77">  kSubHonorOptions = 0,  ///&lt; Honor the user's 'ignorecase'/'smartcase' options</a>
<a name="ln78">  kSubIgnoreCase,        ///&lt; Ignore case of the search</a>
<a name="ln79">  kSubMatchCase,         ///&lt; Match case of the search</a>
<a name="ln80">} SubIgnoreType;</a>
<a name="ln81"> </a>
<a name="ln82">/// Flags kept between calls to :substitute.</a>
<a name="ln83">typedef struct {</a>
<a name="ln84">  bool do_all;          ///&lt; do multiple substitutions per line</a>
<a name="ln85">  bool do_ask;          ///&lt; ask for confirmation</a>
<a name="ln86">  bool do_count;        ///&lt; count only</a>
<a name="ln87">  bool do_error;        ///&lt; if false, ignore errors</a>
<a name="ln88">  bool do_print;        ///&lt; print last line with subs</a>
<a name="ln89">  bool do_list;         ///&lt; list last line with subs</a>
<a name="ln90">  bool do_number;       ///&lt; list last line with line nr</a>
<a name="ln91">  SubIgnoreType do_ic;  ///&lt; ignore case flag</a>
<a name="ln92">} subflags_T;</a>
<a name="ln93"> </a>
<a name="ln94">/// Partial result of a substitution during :substitute.</a>
<a name="ln95">/// Numbers refer to the buffer _after_ substitution</a>
<a name="ln96">typedef struct {</a>
<a name="ln97">  lpos_T start;  // start of the match</a>
<a name="ln98">  lpos_T end;    // end of the match</a>
<a name="ln99">  linenr_T pre_match;  // where to begin showing lines before the match</a>
<a name="ln100">} SubResult;</a>
<a name="ln101"> </a>
<a name="ln102">// Collected results of a substitution for showing them in</a>
<a name="ln103">// the preview window</a>
<a name="ln104">typedef struct {</a>
<a name="ln105">  kvec_t(SubResult) subresults;</a>
<a name="ln106">  linenr_T lines_needed;  // lines neede in the preview window</a>
<a name="ln107">} PreviewLines;</a>
<a name="ln108"> </a>
<a name="ln109">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln110"># include &quot;ex_cmds.c.generated.h&quot;</a>
<a name="ln111">#endif</a>
<a name="ln112"> </a>
<a name="ln113">static int preview_bufnr = 0;</a>
<a name="ln114"> </a>
<a name="ln115">/// &quot;:ascii&quot; and &quot;ga&quot; implementation</a>
<a name="ln116">void do_ascii(const exarg_T *const eap)</a>
<a name="ln117">{</a>
<a name="ln118">  char_u *dig;</a>
<a name="ln119">  int cc[MAX_MCO];</a>
<a name="ln120">  int c = utfc_ptr2char(get_cursor_pos_ptr(), cc);</a>
<a name="ln121">  if (c == NUL) {</a>
<a name="ln122">    MSG(&quot;NUL&quot;);</a>
<a name="ln123">    return;</a>
<a name="ln124">  }</a>
<a name="ln125"> </a>
<a name="ln126">  size_t iobuff_len = 0;</a>
<a name="ln127"> </a>
<a name="ln128">  int ci = 0;</a>
<a name="ln129">  if (c &lt; 0x80) {</a>
<a name="ln130">    if (c == NL) {  // NUL is stored as NL.</a>
<a name="ln131">      c = NUL;</a>
<a name="ln132">    }</a>
<a name="ln133">    const int cval = (c == CAR &amp;&amp; get_fileformat(curbuf) == EOL_MAC</a>
<a name="ln134">                      ? NL  // NL is stored as CR.</a>
<a name="ln135">                      : c);</a>
<a name="ln136">    char buf1[20];</a>
<a name="ln137">    if (vim_isprintc_strict(c) &amp;&amp; (c &lt; ' ' || c &gt; '~')) {</a>
<a name="ln138">      char_u buf3[7];</a>
<a name="ln139">      transchar_nonprint(curbuf, buf3, c);</a>
<a name="ln140">      vim_snprintf(buf1, sizeof(buf1), &quot;  &lt;%s&gt;&quot;, (char *)buf3);</a>
<a name="ln141">    } else {</a>
<a name="ln142">      buf1[0] = NUL;</a>
<a name="ln143">    }</a>
<a name="ln144">    char buf2[20];</a>
<a name="ln145">    buf2[0] = NUL;</a>
<a name="ln146"> </a>
<a name="ln147">    dig = get_digraph_for_char(cval);</a>
<a name="ln148">    if (dig != NULL) {</a>
<a name="ln149">        iobuff_len += (</a>
<a name="ln150">            vim_snprintf((char *)IObuff + iobuff_len,</a>
<a name="ln151">                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln152">                         _(&quot;&lt;%s&gt;%s%s  %d,  Hex %02x,  Oct %03o, Digr %s&quot;),</a>
<a name="ln153">                         transchar(c), buf1, buf2, cval, cval, cval, dig));</a>
<a name="ln154">    } else {</a>
<a name="ln155">        iobuff_len += (</a>
<a name="ln156">            vim_snprintf((char *)IObuff + iobuff_len,</a>
<a name="ln157">                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln158">                         _(&quot;&lt;%s&gt;%s%s  %d,  Hex %02x,  Octal %03o&quot;),</a>
<a name="ln159">                         transchar(c), buf1, buf2, cval, cval, cval));</a>
<a name="ln160">    }</a>
<a name="ln161"> </a>
<a name="ln162">    c = cc[ci++];</a>
<a name="ln163">  }</a>
<a name="ln164"> </a>
<a name="ln165">#define SPACE_FOR_DESC (1 + 1 + 1 + MB_MAXBYTES + 16 + 4 + 3 + 3 + 1)</a>
<a name="ln166">  // Space for description:</a>
<a name="ln167">  // - 1 byte for separator (starting from second entry)</a>
<a name="ln168">  // - 1 byte for &quot;&lt;&quot;</a>
<a name="ln169">  // - 1 byte for space to draw composing character on (optional, but really</a>
<a name="ln170">  //   mostly required)</a>
<a name="ln171">  // - up to MB_MAXBYTES bytes for character itself</a>
<a name="ln172">  // - 16 bytes for raw text (&quot;&gt; , Hex , Octal &quot;).</a>
<a name="ln173">  // - at least 4 bytes for hexadecimal representation</a>
<a name="ln174">  // - at least 3 bytes for decimal representation</a>
<a name="ln175">  // - at least 3 bytes for octal representation</a>
<a name="ln176">  // - 1 byte for NUL</a>
<a name="ln177">  //</a>
<a name="ln178">  // Taking into account MAX_MCO and characters which need 8 bytes for</a>
<a name="ln179">  // hexadecimal representation, but not taking translation into account:</a>
<a name="ln180">  // resulting string will occupy less then 400 bytes (conservative estimate).</a>
<a name="ln181">  //</a>
<a name="ln182">  // Less then 1000 bytes if translation multiplies number of bytes needed for</a>
<a name="ln183">  // raw text by 6, so it should always fit into 1025 bytes reserved for IObuff.</a>
<a name="ln184"> </a>
<a name="ln185">  // Repeat for combining characters, also handle multiby here.</a>
<a name="ln186">  while (c &gt;= 0x80 &amp;&amp; iobuff_len &lt; sizeof(IObuff) - SPACE_FOR_DESC) {</a>
<a name="ln187">    // This assumes every multi-byte char is printable...</a>
<a name="ln188">    if (iobuff_len &gt; 0) {</a>
<a name="ln189">      IObuff[iobuff_len++] = ' ';</a>
<a name="ln190">    }</a>
<a name="ln191">    IObuff[iobuff_len++] = '&lt;';</a>
<a name="ln192">    if (utf_iscomposing(c)) {</a>
<a name="ln193">      IObuff[iobuff_len++] = ' ';  // Draw composing char on top of a space.</a>
<a name="ln194">    }</a>
<a name="ln195">    iobuff_len += utf_char2bytes(c, IObuff + iobuff_len);</a>
<a name="ln196"> </a>
<a name="ln197">    dig = get_digraph_for_char(c);</a>
<a name="ln198">    if (dig != NULL) {</a>
<a name="ln199">        iobuff_len += (</a>
<a name="ln200">            vim_snprintf((char *)IObuff + iobuff_len,</a>
<a name="ln201">                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln202">                         (c &lt; 0x10000</a>
<a name="ln203">                          ? _(&quot;&gt; %d, Hex %04x, Oct %o, Digr %s&quot;)</a>
<a name="ln204">                          : _(&quot;&gt; %d, Hex %08x, Oct %o, Digr %s&quot;)),</a>
<a name="ln205">                         c, c, c, dig));</a>
<a name="ln206">    } else {</a>
<a name="ln207">        iobuff_len += (</a>
<a name="ln208">            vim_snprintf((char *)IObuff + iobuff_len,</a>
<a name="ln209">                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln210">                         (c &lt; 0x10000</a>
<a name="ln211">                          ? _(&quot;&gt; %d, Hex %04x, Octal %o&quot;)</a>
<a name="ln212">                          : _(&quot;&gt; %d, Hex %08x, Octal %o&quot;)),</a>
<a name="ln213">                         c, c, c));</a>
<a name="ln214">    }</a>
<a name="ln215">    if (ci == MAX_MCO) {</a>
<a name="ln216">      break;</a>
<a name="ln217">    }</a>
<a name="ln218">    c = cc[ci++];</a>
<a name="ln219">  }</a>
<a name="ln220">  if (ci != MAX_MCO &amp;&amp; c != 0) {</a>
<a name="ln221">    xstrlcpy((char *)IObuff + iobuff_len, &quot; ...&quot;, sizeof(IObuff) - iobuff_len);</a>
<a name="ln222">  }</a>
<a name="ln223"> </a>
<a name="ln224">  msg(IObuff);</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">/*</a>
<a name="ln228"> * &quot;:left&quot;, &quot;:center&quot; and &quot;:right&quot;: align text.</a>
<a name="ln229"> */</a>
<a name="ln230">void ex_align(exarg_T *eap)</a>
<a name="ln231">{</a>
<a name="ln232">  pos_T save_curpos;</a>
<a name="ln233">  int len;</a>
<a name="ln234">  int indent = 0;</a>
<a name="ln235">  int new_indent;</a>
<a name="ln236">  int has_tab;</a>
<a name="ln237">  int width;</a>
<a name="ln238"> </a>
<a name="ln239">  if (curwin-&gt;w_p_rl) {</a>
<a name="ln240">    /* switch left and right aligning */</a>
<a name="ln241">    if (eap-&gt;cmdidx == CMD_right)</a>
<a name="ln242">      eap-&gt;cmdidx = CMD_left;</a>
<a name="ln243">    else if (eap-&gt;cmdidx == CMD_left)</a>
<a name="ln244">      eap-&gt;cmdidx = CMD_right;</a>
<a name="ln245">  }</a>
<a name="ln246"> </a>
<a name="ln247">  width = atoi((char *)eap-&gt;arg);</a>
<a name="ln248">  save_curpos = curwin-&gt;w_cursor;</a>
<a name="ln249">  if (eap-&gt;cmdidx == CMD_left) {    /* width is used for new indent */</a>
<a name="ln250">    if (width &gt;= 0)</a>
<a name="ln251">      indent = width;</a>
<a name="ln252">  } else {</a>
<a name="ln253">    /*</a>
<a name="ln254">     * if 'textwidth' set, use it</a>
<a name="ln255">     * else if 'wrapmargin' set, use it</a>
<a name="ln256">     * if invalid value, use 80</a>
<a name="ln257">     */</a>
<a name="ln258">    if (width &lt;= 0)</a>
<a name="ln259">      width = curbuf-&gt;b_p_tw;</a>
<a name="ln260">    if (width == 0 &amp;&amp; curbuf-&gt;b_p_wm &gt; 0) {</a>
<a name="ln261">      width = curwin-&gt;w_width_inner - curbuf-&gt;b_p_wm;</a>
<a name="ln262">    }</a>
<a name="ln263">    if (width &lt;= 0) {</a>
<a name="ln264">      width = 80;</a>
<a name="ln265">    }</a>
<a name="ln266">  }</a>
<a name="ln267"> </a>
<a name="ln268">  if (u_save((linenr_T)(eap-&gt;line1 - 1), (linenr_T)(eap-&gt;line2 + 1)) == FAIL)</a>
<a name="ln269">    return;</a>
<a name="ln270"> </a>
<a name="ln271">  for (curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln272">       curwin-&gt;w_cursor.lnum &lt;= eap-&gt;line2; ++curwin-&gt;w_cursor.lnum) {</a>
<a name="ln273">    if (eap-&gt;cmdidx == CMD_left)                /* left align */</a>
<a name="ln274">      new_indent = indent;</a>
<a name="ln275">    else {</a>
<a name="ln276">      has_tab = FALSE;          /* avoid uninit warnings */</a>
<a name="ln277">      len = linelen(eap-&gt;cmdidx == CMD_right ? &amp;has_tab</a>
<a name="ln278">          : NULL) - get_indent();</a>
<a name="ln279"> </a>
<a name="ln280">      if (len &lt;= 0)                             /* skip blank lines */</a>
<a name="ln281">        continue;</a>
<a name="ln282"> </a>
<a name="ln283">      if (eap-&gt;cmdidx == CMD_center)</a>
<a name="ln284">        new_indent = (width - len) / 2;</a>
<a name="ln285">      else {</a>
<a name="ln286">        new_indent = width - len;               /* right align */</a>
<a name="ln287"> </a>
<a name="ln288">        /*</a>
<a name="ln289">         * Make sure that embedded TABs don't make the text go too far</a>
<a name="ln290">         * to the right.</a>
<a name="ln291">         */</a>
<a name="ln292">        if (has_tab)</a>
<a name="ln293">          while (new_indent &gt; 0) {</a>
<a name="ln294">            (void)set_indent(new_indent, 0);</a>
<a name="ln295">            if (linelen(NULL) &lt;= width) {</a>
<a name="ln296">              /*</a>
<a name="ln297">               * Now try to move the line as much as possible to</a>
<a name="ln298">               * the right.  Stop when it moves too far.</a>
<a name="ln299">               */</a>
<a name="ln300">              do</a>
<a name="ln301">                (void)set_indent(++new_indent, 0);</a>
<a name="ln302">              while (linelen(NULL) &lt;= width);</a>
<a name="ln303">              --new_indent;</a>
<a name="ln304">              break;</a>
<a name="ln305">            }</a>
<a name="ln306">            --new_indent;</a>
<a name="ln307">          }</a>
<a name="ln308">      }</a>
<a name="ln309">    }</a>
<a name="ln310">    if (new_indent &lt; 0)</a>
<a name="ln311">      new_indent = 0;</a>
<a name="ln312">    (void)set_indent(new_indent, 0);                    /* set indent */</a>
<a name="ln313">  }</a>
<a name="ln314">  changed_lines(eap-&gt;line1, 0, eap-&gt;line2 + 1, 0L, true);</a>
<a name="ln315">  curwin-&gt;w_cursor = save_curpos;</a>
<a name="ln316">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">/*</a>
<a name="ln320"> * Get the length of the current line, excluding trailing white space.</a>
<a name="ln321"> */</a>
<a name="ln322">static int linelen(int *has_tab)</a>
<a name="ln323">{</a>
<a name="ln324">  char_u  *line;</a>
<a name="ln325">  char_u  *first;</a>
<a name="ln326">  char_u  *last;</a>
<a name="ln327">  int save;</a>
<a name="ln328">  int len;</a>
<a name="ln329"> </a>
<a name="ln330">  // Get the line.  If it's empty bail out early (could be the empty string</a>
<a name="ln331">  // for an unloaded buffer).</a>
<a name="ln332">  line = get_cursor_line_ptr();</a>
<a name="ln333">  if (*line == NUL) {</a>
<a name="ln334">    return 0;</a>
<a name="ln335">  }</a>
<a name="ln336">  // find the first non-blank character</a>
<a name="ln337">  first = skipwhite(line);</a>
<a name="ln338"> </a>
<a name="ln339">  // find the character after the last non-blank character</a>
<a name="ln340">  for (last = first + STRLEN(first);</a>
<a name="ln341">       last &gt; first &amp;&amp; ascii_iswhite(last[-1]); last--) {</a>
<a name="ln342">  }</a>
<a name="ln343">  save = *last;</a>
<a name="ln344">  *last = NUL;</a>
<a name="ln345">  // Get line length.</a>
<a name="ln346">  len = linetabsize(line);</a>
<a name="ln347">  // Check for embedded TAB.</a>
<a name="ln348">  if (has_tab != NULL) {</a>
<a name="ln349">    *has_tab = vim_strchr(first, TAB) != NULL;</a>
<a name="ln350">  }</a>
<a name="ln351">  *last = save;</a>
<a name="ln352"> </a>
<a name="ln353">  return len;</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">/* Buffer for two lines used during sorting.  They are allocated to</a>
<a name="ln357"> * contain the longest line being sorted. */</a>
<a name="ln358">static char_u   *sortbuf1;</a>
<a name="ln359">static char_u   *sortbuf2;</a>
<a name="ln360"> </a>
<a name="ln361">static int sort_lc;       ///&lt; sort using locale</a>
<a name="ln362">static int sort_ic;       ///&lt; ignore case</a>
<a name="ln363">static int sort_nr;       ///&lt; sort on number</a>
<a name="ln364">static int sort_rx;       ///&lt; sort on regex instead of skipping it</a>
<a name="ln365">static int sort_flt;      ///&lt; sort on floating number</a>
<a name="ln366"> </a>
<a name="ln367">static int sort_abort;    ///&lt; flag to indicate if sorting has been interrupted</a>
<a name="ln368"> </a>
<a name="ln369">/// Struct to store info to be sorted.</a>
<a name="ln370">typedef struct {</a>
<a name="ln371">  linenr_T lnum;          ///&lt; line number</a>
<a name="ln372">  union {</a>
<a name="ln373">    struct {</a>
<a name="ln374">      varnumber_T start_col_nr;  ///&lt; starting column number</a>
<a name="ln375">      varnumber_T end_col_nr;    ///&lt; ending column number</a>
<a name="ln376">    } line;</a>
<a name="ln377">    struct {</a>
<a name="ln378">      varnumber_T value;         ///&lt; value if sorting by integer</a>
<a name="ln379">      bool is_number;            ///&lt; true when line contains a number</a>
<a name="ln380">    } num;</a>
<a name="ln381">    float_T value_flt;    ///&lt; value if sorting by float</a>
<a name="ln382">  } st_u;</a>
<a name="ln383">} sorti_T;</a>
<a name="ln384"> </a>
<a name="ln385">static int string_compare(const void *s1, const void *s2) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln386">{</a>
<a name="ln387">  if (sort_lc) {</a>
<a name="ln388">    return strcoll((char *)s1, (char *)s2);</a>
<a name="ln389">  }</a>
<a name="ln390">  return sort_ic ? STRICMP(s1, s2) : STRCMP(s1, s2);</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">static int sort_compare(const void *s1, const void *s2)</a>
<a name="ln394">{</a>
<a name="ln395">  sorti_T l1 = *(sorti_T *)s1;</a>
<a name="ln396">  sorti_T l2 = *(sorti_T *)s2;</a>
<a name="ln397">  int result = 0;</a>
<a name="ln398"> </a>
<a name="ln399">  /* If the user interrupts, there's no way to stop qsort() immediately, but</a>
<a name="ln400">   * if we return 0 every time, qsort will assume it's done sorting and</a>
<a name="ln401">   * exit. */</a>
<a name="ln402">  if (sort_abort)</a>
<a name="ln403">    return 0;</a>
<a name="ln404">  fast_breakcheck();</a>
<a name="ln405">  if (got_int)</a>
<a name="ln406">    sort_abort = TRUE;</a>
<a name="ln407"> </a>
<a name="ln408">  // When sorting numbers &quot;start_col_nr&quot; is the number, not the column</a>
<a name="ln409">  // number.</a>
<a name="ln410">  if (sort_nr) {</a>
<a name="ln411">    if (l1.st_u.num.is_number != l2.st_u.num.is_number) {</a>
<a name="ln412">      result = l1.st_u.num.is_number - l2.st_u.num.is_number;</a>
<a name="ln413">    } else {</a>
<a name="ln414">      result = l1.st_u.num.value == l2.st_u.num.value</a>
<a name="ln415">        ? 0</a>
<a name="ln416">        : l1.st_u.num.value &gt; l2.st_u.num.value</a>
<a name="ln417">          ? 1</a>
<a name="ln418">          : -1;</a>
<a name="ln419">    }</a>
<a name="ln420">  } else if (sort_flt) {</a>
<a name="ln421">    result = l1.st_u.value_flt == l2.st_u.value_flt</a>
<a name="ln422">             ? 0 : l1.st_u.value_flt &gt; l2.st_u.value_flt</a>
<a name="ln423">             ? 1 : -1;</a>
<a name="ln424">  } else {</a>
<a name="ln425">    // We need to copy one line into &quot;sortbuf1&quot;, because there is no</a>
<a name="ln426">    // guarantee that the first pointer becomes invalid when obtaining the</a>
<a name="ln427">    // second one.</a>
<a name="ln428">    memcpy(sortbuf1, ml_get(l1.lnum) + l1.st_u.line.start_col_nr,</a>
<a name="ln429">           l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr + 1);</a>
<a name="ln430">    sortbuf1[l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr] = NUL;</a>
<a name="ln431">    memcpy(sortbuf2, ml_get(l2.lnum) + l2.st_u.line.start_col_nr,</a>
<a name="ln432">           l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr + 1);</a>
<a name="ln433">    sortbuf2[l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr] = NUL;</a>
<a name="ln434"> </a>
<a name="ln435">    result = string_compare(sortbuf1, sortbuf2);</a>
<a name="ln436">  }</a>
<a name="ln437"> </a>
<a name="ln438">  /* If two lines have the same value, preserve the original line order. */</a>
<a name="ln439">  if (result == 0)</a>
<a name="ln440">    return (int)(l1.lnum - l2.lnum);</a>
<a name="ln441">  return result;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">// &quot;:sort&quot;.</a>
<a name="ln445">void ex_sort(exarg_T *eap)</a>
<a name="ln446">{</a>
<a name="ln447">  regmatch_T regmatch;</a>
<a name="ln448">  int len;</a>
<a name="ln449">  linenr_T lnum;</a>
<a name="ln450">  long maxlen = 0;</a>
<a name="ln451">  size_t count = (size_t)(eap-&gt;line2 - eap-&gt;line1 + 1);</a>
<a name="ln452">  size_t i;</a>
<a name="ln453">  char_u      *p;</a>
<a name="ln454">  char_u      *s;</a>
<a name="ln455">  char_u      *s2;</a>
<a name="ln456">  char_u c;                             // temporary character storage</a>
<a name="ln457">  bool unique = false;</a>
<a name="ln458">  long deleted;</a>
<a name="ln459">  colnr_T start_col;</a>
<a name="ln460">  colnr_T end_col;</a>
<a name="ln461">  int sort_what = 0;</a>
<a name="ln462"> </a>
<a name="ln463">  // Sorting one line is really quick!</a>
<a name="ln464">  if (count &lt;= 1) {</a>
<a name="ln465">    return;</a>
<a name="ln466">  }</a>
<a name="ln467"> </a>
<a name="ln468">  if (u_save((linenr_T)(eap-&gt;line1 - 1), (linenr_T)(eap-&gt;line2 + 1)) == FAIL) {</a>
<a name="ln469">    return;</a>
<a name="ln470">  }</a>
<a name="ln471">  sortbuf1 = NULL;</a>
<a name="ln472">  sortbuf2 = NULL;</a>
<a name="ln473">  regmatch.regprog = NULL;</a>
<a name="ln474">  sorti_T *nrs = xmalloc(count * sizeof(sorti_T));</a>
<a name="ln475"> </a>
<a name="ln476">  sort_abort = sort_ic = sort_lc = sort_rx = sort_nr = sort_flt = 0;</a>
<a name="ln477">  size_t format_found = 0;</a>
<a name="ln478">  bool change_occurred = false;   // Buffer contents changed.</a>
<a name="ln479"> </a>
<a name="ln480">  for (p = eap-&gt;arg; *p != NUL; ++p) {</a>
<a name="ln481">    if (ascii_iswhite(*p)) {</a>
<a name="ln482">    } else if (*p == 'i') {</a>
<a name="ln483">      sort_ic = true;</a>
<a name="ln484">    } else if (*p == 'l') {</a>
<a name="ln485">      sort_lc = true;</a>
<a name="ln486">    } else if (*p == 'r') {</a>
<a name="ln487">      sort_rx = true;</a>
<a name="ln488">    } else if (*p == 'n') {</a>
<a name="ln489">      sort_nr = 1;</a>
<a name="ln490">      format_found++;</a>
<a name="ln491">    } else if (*p == 'f') {</a>
<a name="ln492">      sort_flt = 1;</a>
<a name="ln493">      format_found++;</a>
<a name="ln494">    } else if (*p == 'b') {</a>
<a name="ln495">      sort_what = STR2NR_BIN + STR2NR_FORCE;</a>
<a name="ln496">      format_found++;</a>
<a name="ln497">    } else if (*p == 'o') {</a>
<a name="ln498">      sort_what = STR2NR_OCT + STR2NR_FORCE;</a>
<a name="ln499">      format_found++;</a>
<a name="ln500">    } else if (*p == 'x') {</a>
<a name="ln501">      sort_what = STR2NR_HEX + STR2NR_FORCE;</a>
<a name="ln502">      format_found++;</a>
<a name="ln503">    } else if (*p == 'u') {</a>
<a name="ln504">      unique = true;</a>
<a name="ln505">    } else if (*p == '&quot;') {</a>
<a name="ln506">      // comment start</a>
<a name="ln507">      break;</a>
<a name="ln508">    } else if (check_nextcmd(p) != NULL) {</a>
<a name="ln509">      eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln510">      break;</a>
<a name="ln511">    } else if (!ASCII_ISALPHA(*p) &amp;&amp; regmatch.regprog == NULL) {</a>
<a name="ln512">      s = skip_regexp(p + 1, *p, true, NULL);</a>
<a name="ln513">      if (*s != *p) {</a>
<a name="ln514">        EMSG(_(e_invalpat));</a>
<a name="ln515">        goto sortend;</a>
<a name="ln516">      }</a>
<a name="ln517">      *s = NUL;</a>
<a name="ln518">      // Use last search pattern if sort pattern is empty.</a>
<a name="ln519">      if (s == p + 1) {</a>
<a name="ln520">        if (last_search_pat() == NULL) {</a>
<a name="ln521">          EMSG(_(e_noprevre));</a>
<a name="ln522">          goto sortend;</a>
<a name="ln523">        }</a>
<a name="ln524">        regmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);</a>
<a name="ln525">      } else {</a>
<a name="ln526">        regmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);</a>
<a name="ln527">      }</a>
<a name="ln528">      if (regmatch.regprog == NULL) {</a>
<a name="ln529">        goto sortend;</a>
<a name="ln530">      }</a>
<a name="ln531">      p = s;                    // continue after the regexp</a>
<a name="ln532">      regmatch.rm_ic = p_ic;</a>
<a name="ln533">    } else {</a>
<a name="ln534">      EMSG2(_(e_invarg2), p);</a>
<a name="ln535">      goto sortend;</a>
<a name="ln536">    }</a>
<a name="ln537">  }</a>
<a name="ln538"> </a>
<a name="ln539">  // Can only have one of 'n', 'b', 'o' and 'x'.</a>
<a name="ln540">  if (format_found &gt; 1) {</a>
<a name="ln541">    EMSG(_(e_invarg));</a>
<a name="ln542">    goto sortend;</a>
<a name="ln543">  }</a>
<a name="ln544"> </a>
<a name="ln545">  // From here on &quot;sort_nr&quot; is used as a flag for any integer number</a>
<a name="ln546">  // sorting.</a>
<a name="ln547">  sort_nr += sort_what;</a>
<a name="ln548"> </a>
<a name="ln549">  // Make an array with all line numbers.  This avoids having to copy all</a>
<a name="ln550">  // the lines into allocated memory.</a>
<a name="ln551">  // When sorting on strings &quot;start_col_nr&quot; is the offset in the line, for</a>
<a name="ln552">  // numbers sorting it's the number to sort on.  This means the pattern</a>
<a name="ln553">  // matching and number conversion only has to be done once per line.</a>
<a name="ln554">  // Also get the longest line length for allocating &quot;sortbuf&quot;.</a>
<a name="ln555">  for (lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2; ++lnum) {</a>
<a name="ln556">    s = ml_get(lnum);</a>
<a name="ln557">    len = (int)STRLEN(s);</a>
<a name="ln558">    if (maxlen &lt; len) {</a>
<a name="ln559">      maxlen = len;</a>
<a name="ln560">    }</a>
<a name="ln561"> </a>
<a name="ln562">    start_col = 0;</a>
<a name="ln563">    end_col = len;</a>
<a name="ln564">    if (regmatch.regprog != NULL &amp;&amp; vim_regexec(&amp;regmatch, s, 0)) {</a>
<a name="ln565">      if (sort_rx) {</a>
<a name="ln566">        start_col = (colnr_T)(regmatch.startp[0] - s);</a>
<a name="ln567">        end_col = (colnr_T)(regmatch.endp[0] - s);</a>
<a name="ln568">      } else {</a>
<a name="ln569">        start_col = (colnr_T)(regmatch.endp[0] - s);</a>
<a name="ln570">      }</a>
<a name="ln571">    } else if (regmatch.regprog != NULL) {</a>
<a name="ln572">      end_col = 0;</a>
<a name="ln573">    }</a>
<a name="ln574"> </a>
<a name="ln575">    if (sort_nr || sort_flt) {</a>
<a name="ln576">      // Make sure vim_str2nr doesn't read any digits past the end</a>
<a name="ln577">      // of the match, by temporarily terminating the string there</a>
<a name="ln578">      s2 = s + end_col;</a>
<a name="ln579">      c = *s2;</a>
<a name="ln580">      *s2 = NUL;</a>
<a name="ln581">      // Sorting on number: Store the number itself.</a>
<a name="ln582">      p = s + start_col;</a>
<a name="ln583">      if (sort_nr) {</a>
<a name="ln584">        if (sort_what &amp; STR2NR_HEX) {</a>
<a name="ln585">          s = skiptohex(p);</a>
<a name="ln586">        } else if (sort_what &amp; STR2NR_BIN) {</a>
<a name="ln587">          s = (char_u *)skiptobin((char *)p);</a>
<a name="ln588">        } else {</a>
<a name="ln589">          s = skiptodigit(p);</a>
<a name="ln590">        }</a>
<a name="ln591">        if (s &gt; p &amp;&amp; s[-1] == '-') {</a>
<a name="ln592">          s--;  // include preceding negative sign</a>
<a name="ln593">        }</a>
<a name="ln594">        if (*s == NUL) {</a>
<a name="ln595">          // line without number should sort before any number</a>
<a name="ln596">          nrs[lnum - eap-&gt;line1].st_u.num.is_number = false;</a>
<a name="ln597">          nrs[lnum - eap-&gt;line1].st_u.num.value = 0;</a>
<a name="ln598">        } else {</a>
<a name="ln599">          nrs[lnum - eap-&gt;line1].st_u.num.is_number = true;</a>
<a name="ln600">          vim_str2nr(s, NULL, NULL, sort_what,</a>
<a name="ln601">                     &amp;nrs[lnum - eap-&gt;line1].st_u.num.value, NULL, 0);</a>
<a name="ln602">        }</a>
<a name="ln603">      } else {</a>
<a name="ln604">        s = skipwhite(p);</a>
<a name="ln605">        if (*s == '+') {</a>
<a name="ln606">          s = skipwhite(s + 1);</a>
<a name="ln607">        }</a>
<a name="ln608"> </a>
<a name="ln609">        if (*s == NUL) {</a>
<a name="ln610">          // empty line should sort before any number</a>
<a name="ln611">          nrs[lnum - eap-&gt;line1].st_u.value_flt = -DBL_MAX;</a>
<a name="ln612">        } else {</a>
<a name="ln613">          nrs[lnum - eap-&gt;line1].st_u.value_flt = strtod((char *)s, NULL);</a>
<a name="ln614">        }</a>
<a name="ln615">      }</a>
<a name="ln616">      *s2 = c;</a>
<a name="ln617">    } else {</a>
<a name="ln618">      // Store the column to sort at.</a>
<a name="ln619">      nrs[lnum - eap-&gt;line1].st_u.line.start_col_nr = start_col;</a>
<a name="ln620">      nrs[lnum - eap-&gt;line1].st_u.line.end_col_nr = end_col;</a>
<a name="ln621">    }</a>
<a name="ln622"> </a>
<a name="ln623">    nrs[lnum - eap-&gt;line1].lnum = lnum;</a>
<a name="ln624"> </a>
<a name="ln625">    if (regmatch.regprog != NULL)</a>
<a name="ln626">      fast_breakcheck();</a>
<a name="ln627">    if (got_int)</a>
<a name="ln628">      goto sortend;</a>
<a name="ln629">  }</a>
<a name="ln630"> </a>
<a name="ln631">  // Allocate a buffer that can hold the longest line.</a>
<a name="ln632">  sortbuf1 = xmalloc(maxlen + 1);</a>
<a name="ln633">  sortbuf2 = xmalloc(maxlen + 1);</a>
<a name="ln634"> </a>
<a name="ln635">  // Sort the array of line numbers.  Note: can't be interrupted!</a>
<a name="ln636">  qsort((void *)nrs, count, sizeof(sorti_T), sort_compare);</a>
<a name="ln637"> </a>
<a name="ln638">  if (sort_abort)</a>
<a name="ln639">    goto sortend;</a>
<a name="ln640"> </a>
<a name="ln641">  bcount_t old_count = 0, new_count = 0;</a>
<a name="ln642"> </a>
<a name="ln643">  // Insert the lines in the sorted order below the last one.</a>
<a name="ln644">  lnum = eap-&gt;line2;</a>
<a name="ln645">  for (i = 0; i &lt; count; i++) {</a>
<a name="ln646">    const linenr_T get_lnum = nrs[eap-&gt;forceit ? count - i - 1 : i].lnum;</a>
<a name="ln647"> </a>
<a name="ln648">    // If the original line number of the line being placed is not the same</a>
<a name="ln649">    // as &quot;lnum&quot; (accounting for offset), we know that the buffer changed.</a>
<a name="ln650">    if (get_lnum + ((linenr_T)count - 1) != lnum) {</a>
<a name="ln651">      change_occurred = true;</a>
<a name="ln652">    }</a>
<a name="ln653"> </a>
<a name="ln654">    s = ml_get(get_lnum);</a>
<a name="ln655">    size_t bytelen = STRLEN(s) + 1;  // include EOL in bytelen</a>
<a name="ln656">    old_count += bytelen;</a>
<a name="ln657">    if (!unique || i == 0 || string_compare(s, sortbuf1) != 0) {</a>
<a name="ln658">      // Copy the line into a buffer, it may become invalid in</a>
<a name="ln659">      // ml_append(). And it's needed for &quot;unique&quot;.</a>
<a name="ln660">      STRCPY(sortbuf1, s);</a>
<a name="ln661">      if (ml_append(lnum++, sortbuf1, (colnr_T)0, false) == FAIL) {</a>
<a name="ln662">        break;</a>
<a name="ln663">      }</a>
<a name="ln664">      new_count += bytelen;</a>
<a name="ln665">    }</a>
<a name="ln666">    fast_breakcheck();</a>
<a name="ln667">    if (got_int)</a>
<a name="ln668">      goto sortend;</a>
<a name="ln669">  }</a>
<a name="ln670"> </a>
<a name="ln671">  // delete the original lines if appending worked</a>
<a name="ln672">  if (i == count) {</a>
<a name="ln673">    for (i = 0; i &lt; count; ++i) {</a>
<a name="ln674">      ml_delete(eap-&gt;line1, false);</a>
<a name="ln675">    }</a>
<a name="ln676">  } else {</a>
<a name="ln677">    count = 0;</a>
<a name="ln678">  }</a>
<a name="ln679"> </a>
<a name="ln680">  // Adjust marks for deleted (or added) lines and prepare for displaying.</a>
<a name="ln681">  deleted = (long)(count - (lnum - eap-&gt;line2));</a>
<a name="ln682">  if (deleted &gt; 0) {</a>
<a name="ln683">    mark_adjust(eap-&gt;line2 - deleted, eap-&gt;line2, (long)MAXLNUM, -deleted,</a>
<a name="ln684">                kExtmarkNOOP);</a>
<a name="ln685">    msgmore(-deleted);</a>
<a name="ln686">  } else if (deleted &lt; 0) {</a>
<a name="ln687">    mark_adjust(eap-&gt;line2, MAXLNUM, -deleted, 0L, kExtmarkNOOP);</a>
<a name="ln688">  }</a>
<a name="ln689"> </a>
<a name="ln690">  extmark_splice(curbuf, eap-&gt;line1-1, 0,</a>
<a name="ln691">                 count, 0, old_count,</a>
<a name="ln692">                 lnum - eap-&gt;line2, 0, new_count, kExtmarkUndo);</a>
<a name="ln693"> </a>
<a name="ln694">  if (change_occurred || deleted != 0) {</a>
<a name="ln695">    changed_lines(eap-&gt;line1, 0, eap-&gt;line2 + 1, -deleted, true);</a>
<a name="ln696">  }</a>
<a name="ln697"> </a>
<a name="ln698">  curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln699">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln700"> </a>
<a name="ln701">sortend:</a>
<a name="ln702">  xfree(nrs);</a>
<a name="ln703">  xfree(sortbuf1);</a>
<a name="ln704">  xfree(sortbuf2);</a>
<a name="ln705">  vim_regfree(regmatch.regprog);</a>
<a name="ln706">  if (got_int) {</a>
<a name="ln707">    EMSG(_(e_interr));</a>
<a name="ln708">  }</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">/*</a>
<a name="ln712"> * &quot;:retab&quot;.</a>
<a name="ln713"> */</a>
<a name="ln714">void ex_retab(exarg_T *eap)</a>
<a name="ln715">{</a>
<a name="ln716">  linenr_T lnum;</a>
<a name="ln717">  int got_tab = FALSE;</a>
<a name="ln718">  long num_spaces = 0;</a>
<a name="ln719">  long num_tabs;</a>
<a name="ln720">  long len;</a>
<a name="ln721">  long col;</a>
<a name="ln722">  long vcol;</a>
<a name="ln723">  long start_col = 0;                   // For start of white-space string</a>
<a name="ln724">  long start_vcol = 0;                  // For start of white-space string</a>
<a name="ln725">  long old_len;</a>
<a name="ln726">  char_u      *ptr;</a>
<a name="ln727">  char_u      *new_line = (char_u *)1;  // init to non-NULL</a>
<a name="ln728">  int did_undo;                         // called u_save for current line</a>
<a name="ln729">  long *new_vts_array = NULL;</a>
<a name="ln730">  char_u *new_ts_str;  // string value of tab argument</a>
<a name="ln731"> </a>
<a name="ln732">  int save_list;</a>
<a name="ln733">  linenr_T first_line = 0;              /* first changed line */</a>
<a name="ln734">  linenr_T last_line = 0;               /* last changed line */</a>
<a name="ln735"> </a>
<a name="ln736">  save_list = curwin-&gt;w_p_list;</a>
<a name="ln737">  curwin-&gt;w_p_list = 0;             /* don't want list mode here */</a>
<a name="ln738"> </a>
<a name="ln739">  new_ts_str = eap-&gt;arg;</a>
<a name="ln740">  if (!tabstop_set(eap-&gt;arg, &amp;new_vts_array)) {</a>
<a name="ln741">    return;</a>
<a name="ln742">  }</a>
<a name="ln743">  while (ascii_isdigit(*(eap-&gt;arg)) || *(eap-&gt;arg) == ',') {</a>
<a name="ln744">    (eap-&gt;arg)++;</a>
<a name="ln745">  }</a>
<a name="ln746"> </a>
<a name="ln747">  // This ensures that either new_vts_array and new_ts_str are freshly</a>
<a name="ln748">  // allocated, or new_vts_array points to an existing array and new_ts_str</a>
<a name="ln749">  // is null.</a>
<a name="ln750">  if (new_vts_array == NULL) {</a>
<a name="ln751">    new_vts_array = curbuf-&gt;b_p_vts_array;</a>
<a name="ln752">    new_ts_str = NULL;</a>
<a name="ln753">  } else {</a>
<a name="ln754">    new_ts_str = vim_strnsave(new_ts_str, eap-&gt;arg - new_ts_str);</a>
<a name="ln755">  }</a>
<a name="ln756">  for (lnum = eap-&gt;line1; !got_int &amp;&amp; lnum &lt;= eap-&gt;line2; lnum++) {</a>
<a name="ln757">    ptr = ml_get(lnum);</a>
<a name="ln758">    col = 0;</a>
<a name="ln759">    vcol = 0;</a>
<a name="ln760">    did_undo = FALSE;</a>
<a name="ln761">    for (;; ) {</a>
<a name="ln762">      if (ascii_iswhite(ptr[col])) {</a>
<a name="ln763">        if (!got_tab &amp;&amp; num_spaces == 0) {</a>
<a name="ln764">          /* First consecutive white-space */</a>
<a name="ln765">          start_vcol = vcol;</a>
<a name="ln766">          start_col = col;</a>
<a name="ln767">        }</a>
<a name="ln768">        if (ptr[col] == ' ')</a>
<a name="ln769">          num_spaces++;</a>
<a name="ln770">        else</a>
<a name="ln771">          got_tab = TRUE;</a>
<a name="ln772">      } else {</a>
<a name="ln773">        if (got_tab || (eap-&gt;forceit &amp;&amp; num_spaces &gt; 1)) {</a>
<a name="ln774">          /* Retabulate this string of white-space */</a>
<a name="ln775"> </a>
<a name="ln776">          /* len is virtual length of white string */</a>
<a name="ln777">          len = num_spaces = vcol - start_vcol;</a>
<a name="ln778">          num_tabs = 0;</a>
<a name="ln779">          if (!curbuf-&gt;b_p_et) {</a>
<a name="ln780">            int t, s;</a>
<a name="ln781"> </a>
<a name="ln782">            tabstop_fromto(start_vcol, vcol,</a>
<a name="ln783">                           curbuf-&gt;b_p_ts, new_vts_array, &amp;t, &amp;s);</a>
<a name="ln784">            num_tabs = t;</a>
<a name="ln785">            num_spaces = s;</a>
<a name="ln786">          }</a>
<a name="ln787">          if (curbuf-&gt;b_p_et || got_tab</a>
<a name="ln788">              || (num_spaces + num_tabs &lt; len)) {</a>
<a name="ln789">            if (did_undo == false) {</a>
<a name="ln790">              did_undo = true;</a>
<a name="ln791">              if (u_save((linenr_T)(lnum - 1),</a>
<a name="ln792">                         (linenr_T)(lnum + 1)) == FAIL) {</a>
<a name="ln793">                new_line = NULL;  // flag out-of-memory</a>
<a name="ln794">                break;</a>
<a name="ln795">              }</a>
<a name="ln796">            }</a>
<a name="ln797"> </a>
<a name="ln798">            /* len is actual number of white characters used */</a>
<a name="ln799">            len = num_spaces + num_tabs;</a>
<a name="ln800">            old_len = (long)STRLEN(ptr);</a>
<a name="ln801">            long new_len = old_len - col + start_col + len + 1;</a>
<a name="ln802">            new_line = xmalloc(new_len);</a>
<a name="ln803"> </a>
<a name="ln804">            if (start_col &gt; 0)</a>
<a name="ln805">              memmove(new_line, ptr, (size_t)start_col);</a>
<a name="ln806">            memmove(new_line + start_col + len,</a>
<a name="ln807">                ptr + col, (size_t)(old_len - col + 1));</a>
<a name="ln808">            ptr = new_line + start_col;</a>
<a name="ln809">            for (col = 0; col &lt; len; col++) {</a>
<a name="ln810">              ptr[col] = (col &lt; num_tabs) ? '\t' : ' ';</a>
<a name="ln811">            }</a>
<a name="ln812">            if (ml_replace(lnum, new_line, false) == OK) {</a>
<a name="ln813">              // &quot;new_line&quot; may have been copied</a>
<a name="ln814">              new_line = curbuf-&gt;b_ml.ml_line_ptr;</a>
<a name="ln815">              extmark_splice_cols(curbuf, lnum - 1, 0, (colnr_T)old_len,</a>
<a name="ln816">                                  (colnr_T)new_len - 1, kExtmarkUndo);</a>
<a name="ln817">            }</a>
<a name="ln818">            if (first_line == 0) {</a>
<a name="ln819">              first_line = lnum;</a>
<a name="ln820">            }</a>
<a name="ln821">            last_line = lnum;</a>
<a name="ln822">            ptr = new_line;</a>
<a name="ln823">            col = start_col + len;</a>
<a name="ln824">          }</a>
<a name="ln825">        }</a>
<a name="ln826">        got_tab = FALSE;</a>
<a name="ln827">        num_spaces = 0;</a>
<a name="ln828">      }</a>
<a name="ln829">      if (ptr[col] == NUL)</a>
<a name="ln830">        break;</a>
<a name="ln831">      vcol += chartabsize(ptr + col, (colnr_T)vcol);</a>
<a name="ln832">      col += utfc_ptr2len(ptr + col);</a>
<a name="ln833">    }</a>
<a name="ln834">    if (new_line == NULL)                   /* out of memory */</a>
<a name="ln835">      break;</a>
<a name="ln836">    line_breakcheck();</a>
<a name="ln837">  }</a>
<a name="ln838">  if (got_int)</a>
<a name="ln839">    EMSG(_(e_interr));</a>
<a name="ln840"> </a>
<a name="ln841">  // If a single value was given then it can be considered equal to</a>
<a name="ln842">  // either the value of 'tabstop' or the value of 'vartabstop'.</a>
<a name="ln843">  if (tabstop_count(curbuf-&gt;b_p_vts_array) == 0</a>
<a name="ln844">      &amp;&amp; tabstop_count(new_vts_array) == 1</a>
<a name="ln845">      &amp;&amp; curbuf-&gt;b_p_ts == tabstop_first(new_vts_array)) {</a>
<a name="ln846">    // not changed</a>
<a name="ln847">  } else if (tabstop_count(curbuf-&gt;b_p_vts_array) &gt; 0</a>
<a name="ln848">             &amp;&amp; tabstop_eq(curbuf-&gt;b_p_vts_array, new_vts_array)) {</a>
<a name="ln849">    // not changed</a>
<a name="ln850">  } else {</a>
<a name="ln851">    redraw_curbuf_later(NOT_VALID);</a>
<a name="ln852">  }</a>
<a name="ln853">  if (first_line != 0) {</a>
<a name="ln854">    changed_lines(first_line, 0, last_line + 1, 0L, true);</a>
<a name="ln855">  }</a>
<a name="ln856"> </a>
<a name="ln857">  curwin-&gt;w_p_list = save_list;         /* restore 'list' */</a>
<a name="ln858"> </a>
<a name="ln859">  if (new_ts_str != NULL) {  // set the new tabstop</a>
<a name="ln860">    // If 'vartabstop' is in use or if the value given to retab has more</a>
<a name="ln861">    // than one tabstop then update 'vartabstop'.</a>
<a name="ln862">    long *old_vts_ary = curbuf-&gt;b_p_vts_array;</a>
<a name="ln863"> </a>
<a name="ln864">    if (tabstop_count(old_vts_ary) &gt; 0 || tabstop_count(new_vts_array) &gt; 1) {</a>
<a name="ln865">      set_string_option_direct(&quot;vts&quot;, -1, new_ts_str,</a>
<a name="ln866">                               OPT_FREE | OPT_LOCAL, 0);</a>
<a name="ln867">      curbuf-&gt;b_p_vts_array = new_vts_array;</a>
<a name="ln868">      xfree(old_vts_ary);</a>
<a name="ln869">    } else {</a>
<a name="ln870">      // 'vartabstop' wasn't in use and a single value was given to</a>
<a name="ln871">      // retab then update 'tabstop'.</a>
<a name="ln872">      curbuf-&gt;b_p_ts = tabstop_first(new_vts_array);</a>
<a name="ln873">      xfree(new_vts_array);</a>
<a name="ln874">    }</a>
<a name="ln875">    xfree(new_ts_str);</a>
<a name="ln876">  }</a>
<a name="ln877">  coladvance(curwin-&gt;w_curswant);</a>
<a name="ln878"> </a>
<a name="ln879">  u_clearline();</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">/*</a>
<a name="ln883"> * :move command - move lines line1-line2 to line dest</a>
<a name="ln884"> *</a>
<a name="ln885"> * return FAIL for failure, OK otherwise</a>
<a name="ln886"> */</a>
<a name="ln887">int do_move(linenr_T line1, linenr_T line2, linenr_T dest)</a>
<a name="ln888">{</a>
<a name="ln889">  char_u      *str;</a>
<a name="ln890">  linenr_T l;</a>
<a name="ln891">  linenr_T extra;      // Num lines added before line1</a>
<a name="ln892">  linenr_T num_lines;  // Num lines moved</a>
<a name="ln893">  linenr_T last_line;  // Last line in file after adding new text</a>
<a name="ln894"> </a>
<a name="ln895">  if (dest &gt;= line1 &amp;&amp; dest &lt; line2) {</a>
<a name="ln896">    EMSG(_(&quot;E134: Cannot move a range of lines into itself&quot;));</a>
<a name="ln897">    return FAIL;</a>
<a name="ln898">  }</a>
<a name="ln899"> </a>
<a name="ln900">  // Do nothing if we are not actually moving any lines.  This will prevent</a>
<a name="ln901">  // the 'modified' flag from being set without cause.</a>
<a name="ln902">  if (dest == line1 - 1 || dest == line2) {</a>
<a name="ln903">    // Move the cursor as if lines were moved (see below) to be backwards</a>
<a name="ln904">    // compatible.</a>
<a name="ln905">    if (dest &gt;= line1) {</a>
<a name="ln906">      curwin-&gt;w_cursor.lnum = dest;</a>
<a name="ln907">    } else {</a>
<a name="ln908">      curwin-&gt;w_cursor.lnum = dest + (line2 - line1) + 1;</a>
<a name="ln909">    }</a>
<a name="ln910">    return OK;</a>
<a name="ln911">  }</a>
<a name="ln912"> </a>
<a name="ln913">  bcount_t start_byte = ml_find_line_or_offset(curbuf, line1, NULL, true);</a>
<a name="ln914">  bcount_t end_byte = ml_find_line_or_offset(curbuf, line2+1, NULL, true);</a>
<a name="ln915">  bcount_t extent_byte = end_byte-start_byte;</a>
<a name="ln916">  bcount_t dest_byte = ml_find_line_or_offset(curbuf, dest+1, NULL, true);</a>
<a name="ln917"> </a>
<a name="ln918">  num_lines = line2 - line1 + 1;</a>
<a name="ln919"> </a>
<a name="ln920">  /*</a>
<a name="ln921">   * First we copy the old text to its new location -- webb</a>
<a name="ln922">   * Also copy the flag that &quot;:global&quot; command uses.</a>
<a name="ln923">   */</a>
<a name="ln924">  if (u_save(dest, dest + 1) == FAIL)</a>
<a name="ln925">    return FAIL;</a>
<a name="ln926">  for (extra = 0, l = line1; l &lt;= line2; l++) {</a>
<a name="ln927">    str = vim_strsave(ml_get(l + extra));</a>
<a name="ln928">    ml_append(dest + l - line1, str, (colnr_T)0, false);</a>
<a name="ln929">    xfree(str);</a>
<a name="ln930">    if (dest &lt; line1)</a>
<a name="ln931">      extra++;</a>
<a name="ln932">  }</a>
<a name="ln933"> </a>
<a name="ln934">  /*</a>
<a name="ln935">   * Now we must be careful adjusting our marks so that we don't overlap our</a>
<a name="ln936">   * mark_adjust() calls.</a>
<a name="ln937">   *</a>
<a name="ln938">   * We adjust the marks within the old text so that they refer to the</a>
<a name="ln939">   * last lines of the file (temporarily), because we know no other marks</a>
<a name="ln940">   * will be set there since these line numbers did not exist until we added</a>
<a name="ln941">   * our new lines.</a>
<a name="ln942">   *</a>
<a name="ln943">   * Then we adjust the marks on lines between the old and new text positions</a>
<a name="ln944">   * (either forwards or backwards).</a>
<a name="ln945">   *</a>
<a name="ln946">   * And Finally we adjust the marks we put at the end of the file back to</a>
<a name="ln947">   * their final destination at the new text position -- webb</a>
<a name="ln948">   */</a>
<a name="ln949">  last_line = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln950">  mark_adjust_nofold(line1, line2, last_line - line2, 0L, kExtmarkNOOP);</a>
<a name="ln951">  changed_lines(last_line - num_lines + 1, 0, last_line + 1, num_lines, false);</a>
<a name="ln952">  int line_off = 0;</a>
<a name="ln953">  bcount_t byte_off = 0;</a>
<a name="ln954">  if (dest &gt;= line2) {</a>
<a name="ln955">    mark_adjust_nofold(line2 + 1, dest, -num_lines, 0L, kExtmarkNOOP);</a>
<a name="ln956">    FOR_ALL_TAB_WINDOWS(tab, win) {</a>
<a name="ln957">      if (win-&gt;w_buffer == curbuf) {</a>
<a name="ln958">        foldMoveRange(win, &amp;win-&gt;w_folds, line1, line2, dest);</a>
<a name="ln959">      }</a>
<a name="ln960">    }</a>
<a name="ln961">    curbuf-&gt;b_op_start.lnum = dest - num_lines + 1;</a>
<a name="ln962">    curbuf-&gt;b_op_end.lnum = dest;</a>
<a name="ln963">    line_off = -num_lines;</a>
<a name="ln964">    byte_off = -extent_byte;</a>
<a name="ln965">  } else {</a>
<a name="ln966">    mark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L, kExtmarkNOOP);</a>
<a name="ln967">    FOR_ALL_TAB_WINDOWS(tab, win) {</a>
<a name="ln968">      if (win-&gt;w_buffer == curbuf) {</a>
<a name="ln969">        foldMoveRange(win, &amp;win-&gt;w_folds, dest + 1, line1 - 1, line2);</a>
<a name="ln970">      }</a>
<a name="ln971">    }</a>
<a name="ln972">    curbuf-&gt;b_op_start.lnum = dest + 1;</a>
<a name="ln973">    curbuf-&gt;b_op_end.lnum = dest + num_lines;</a>
<a name="ln974">  }</a>
<a name="ln975">  curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln976">  mark_adjust_nofold(last_line - num_lines + 1, last_line,</a>
<a name="ln977">                     -(last_line - dest - extra), 0L, kExtmarkNOOP);</a>
<a name="ln978"> </a>
<a name="ln979">  changed_lines(last_line - num_lines + 1, 0, last_line + 1, -extra, false);</a>
<a name="ln980"> </a>
<a name="ln981">  // send update regarding the new lines that were added</a>
<a name="ln982">  buf_updates_send_changes(curbuf, dest + 1, num_lines, 0, true);</a>
<a name="ln983"> </a>
<a name="ln984">  /*</a>
<a name="ln985">   * Now we delete the original text -- webb</a>
<a name="ln986">   */</a>
<a name="ln987">  if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL)</a>
<a name="ln988">    return FAIL;</a>
<a name="ln989"> </a>
<a name="ln990">  for (l = line1; l &lt;= line2; l++) {</a>
<a name="ln991">    ml_delete(line1 + extra, true);</a>
<a name="ln992">  }</a>
<a name="ln993">  if (!global_busy &amp;&amp; num_lines &gt; p_report) {</a>
<a name="ln994">    if (num_lines == 1)</a>
<a name="ln995">      MSG(_(&quot;1 line moved&quot;));</a>
<a name="ln996">    else</a>
<a name="ln997">      smsg(_(&quot;%&quot; PRId64 &quot; lines moved&quot;), (int64_t)num_lines);</a>
<a name="ln998">  }</a>
<a name="ln999"> </a>
<a name="ln1000">  extmark_move_region(curbuf, line1-1, 0, start_byte,</a>
<a name="ln1001">                      line2-line1+1, 0, extent_byte,</a>
<a name="ln1002">                      dest+line_off, 0, dest_byte+byte_off,</a>
<a name="ln1003">                      kExtmarkUndo);</a>
<a name="ln1004"> </a>
<a name="ln1005">  /*</a>
<a name="ln1006">   * Leave the cursor on the last of the moved lines.</a>
<a name="ln1007">   */</a>
<a name="ln1008">  if (dest &gt;= line1)</a>
<a name="ln1009">    curwin-&gt;w_cursor.lnum = dest;</a>
<a name="ln1010">  else</a>
<a name="ln1011">    curwin-&gt;w_cursor.lnum = dest + (line2 - line1) + 1;</a>
<a name="ln1012"> </a>
<a name="ln1013">  if (line1 &lt; dest) {</a>
<a name="ln1014">    dest += num_lines + 1;</a>
<a name="ln1015">    last_line = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1016">    if (dest &gt; last_line + 1)</a>
<a name="ln1017">      dest = last_line + 1;</a>
<a name="ln1018">    changed_lines(line1, 0, dest, 0L, false);</a>
<a name="ln1019">  } else {</a>
<a name="ln1020">    changed_lines(dest + 1, 0, line1 + num_lines, 0L, false);</a>
<a name="ln1021">  }</a>
<a name="ln1022"> </a>
<a name="ln1023">  // send nvim_buf_lines_event regarding lines that were deleted</a>
<a name="ln1024">  buf_updates_send_changes(curbuf, line1 + extra, 0, num_lines, true);</a>
<a name="ln1025"> </a>
<a name="ln1026">  return OK;</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029">/*</a>
<a name="ln1030"> * &quot;:copy&quot;</a>
<a name="ln1031"> */</a>
<a name="ln1032">void ex_copy(linenr_T line1, linenr_T line2, linenr_T n)</a>
<a name="ln1033">{</a>
<a name="ln1034">  linenr_T count;</a>
<a name="ln1035">  char_u      *p;</a>
<a name="ln1036"> </a>
<a name="ln1037">  count = line2 - line1 + 1;</a>
<a name="ln1038">  curbuf-&gt;b_op_start.lnum = n + 1;</a>
<a name="ln1039">  curbuf-&gt;b_op_end.lnum = n + count;</a>
<a name="ln1040">  curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln1041"> </a>
<a name="ln1042">  /*</a>
<a name="ln1043">   * there are three situations:</a>
<a name="ln1044">   * 1. destination is above line1</a>
<a name="ln1045">   * 2. destination is between line1 and line2</a>
<a name="ln1046">   * 3. destination is below line2</a>
<a name="ln1047">   *</a>
<a name="ln1048">   * n = destination (when starting)</a>
<a name="ln1049">   * curwin-&gt;w_cursor.lnum = destination (while copying)</a>
<a name="ln1050">   * line1 = start of source (while copying)</a>
<a name="ln1051">   * line2 = end of source (while copying)</a>
<a name="ln1052">   */</a>
<a name="ln1053">  if (u_save(n, n + 1) == FAIL)</a>
<a name="ln1054">    return;</a>
<a name="ln1055"> </a>
<a name="ln1056">  curwin-&gt;w_cursor.lnum = n;</a>
<a name="ln1057">  while (line1 &lt;= line2) {</a>
<a name="ln1058">    /* need to use vim_strsave() because the line will be unlocked within</a>
<a name="ln1059">     * ml_append() */</a>
<a name="ln1060">    p = vim_strsave(ml_get(line1));</a>
<a name="ln1061">    ml_append(curwin-&gt;w_cursor.lnum, p, (colnr_T)0, false);</a>
<a name="ln1062">    xfree(p);</a>
<a name="ln1063"> </a>
<a name="ln1064">    /* situation 2: skip already copied lines */</a>
<a name="ln1065">    if (line1 == n)</a>
<a name="ln1066">      line1 = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1067">    ++line1;</a>
<a name="ln1068">    if (curwin-&gt;w_cursor.lnum &lt; line1)</a>
<a name="ln1069">      ++line1;</a>
<a name="ln1070">    if (curwin-&gt;w_cursor.lnum &lt; line2)</a>
<a name="ln1071">      ++line2;</a>
<a name="ln1072">    ++curwin-&gt;w_cursor.lnum;</a>
<a name="ln1073">  }</a>
<a name="ln1074"> </a>
<a name="ln1075">  appended_lines_mark(n, count);</a>
<a name="ln1076"> </a>
<a name="ln1077">  msgmore((long)count);</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">static char_u   *prevcmd = NULL;        /* the previous command */</a>
<a name="ln1081"> </a>
<a name="ln1082">#if defined(EXITFREE)</a>
<a name="ln1083">void free_prev_shellcmd(void)</a>
<a name="ln1084">{</a>
<a name="ln1085">  xfree(prevcmd);</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088">#endif</a>
<a name="ln1089"> </a>
<a name="ln1090">/*</a>
<a name="ln1091"> * Handle the &quot;:!cmd&quot; command.	Also for &quot;:r !cmd&quot; and &quot;:w !cmd&quot;</a>
<a name="ln1092"> * Bangs in the argument are replaced with the previously entered command.</a>
<a name="ln1093"> * Remember the argument.</a>
<a name="ln1094"> */</a>
<a name="ln1095">void do_bang(int addr_count, exarg_T *eap, bool forceit,</a>
<a name="ln1096">             bool do_in, bool do_out)</a>
<a name="ln1097">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1098">{</a>
<a name="ln1099">  char_u *arg = eap-&gt;arg;             // command</a>
<a name="ln1100">  linenr_T line1 = eap-&gt;line1;        // start of range</a>
<a name="ln1101">  linenr_T line2 = eap-&gt;line2;        // end of range</a>
<a name="ln1102">  char_u *newcmd = NULL;              // the new command</a>
<a name="ln1103">  bool free_newcmd = false;           // need to free() newcmd</a>
<a name="ln1104">  char_u              *t;</a>
<a name="ln1105">  char_u              *p;</a>
<a name="ln1106">  char_u              *trailarg;</a>
<a name="ln1107">  int len;</a>
<a name="ln1108">  int scroll_save = msg_scroll;</a>
<a name="ln1109"> </a>
<a name="ln1110">  //</a>
<a name="ln1111">  // Disallow shell commands from .exrc and .vimrc in current directory for</a>
<a name="ln1112">  // security reasons.</a>
<a name="ln1113">  //</a>
<a name="ln1114">  if (check_secure()) {</a>
<a name="ln1115">    return;</a>
<a name="ln1116">  }</a>
<a name="ln1117"> </a>
<a name="ln1118">  if (addr_count == 0) {                /* :! */</a>
<a name="ln1119">    msg_scroll = FALSE;             /* don't scroll here */</a>
<a name="ln1120">    autowrite_all();</a>
<a name="ln1121">    msg_scroll = scroll_save;</a>
<a name="ln1122">  }</a>
<a name="ln1123"> </a>
<a name="ln1124">  /*</a>
<a name="ln1125">   * Try to find an embedded bang, like in :!&lt;cmd&gt; ! [args]</a>
<a name="ln1126">   * (:!! is indicated by the 'forceit' variable)</a>
<a name="ln1127">   */</a>
<a name="ln1128">  bool ins_prevcmd = forceit;</a>
<a name="ln1129">  trailarg = arg;</a>
<a name="ln1130">  do {</a>
<a name="ln1131">    len = (int)STRLEN(trailarg) + 1;</a>
<a name="ln1132">    if (newcmd != NULL)</a>
<a name="ln1133">      len += (int)STRLEN(newcmd);</a>
<a name="ln1134">    if (ins_prevcmd) {</a>
<a name="ln1135">      if (prevcmd == NULL) {</a>
<a name="ln1136">        EMSG(_(e_noprev));</a>
<a name="ln1137">        xfree(newcmd);</a>
<a name="ln1138">        return;</a>
<a name="ln1139">      }</a>
<a name="ln1140">      len += (int)STRLEN(prevcmd);</a>
<a name="ln1141">    }</a>
<a name="ln1142">    t = xmalloc(len);</a>
<a name="ln1143">    *t = NUL;</a>
<a name="ln1144">    if (newcmd != NULL)</a>
<a name="ln1145">      STRCAT(t, newcmd);</a>
<a name="ln1146">    if (ins_prevcmd)</a>
<a name="ln1147">      STRCAT(t, prevcmd);</a>
<a name="ln1148">    p = t + STRLEN(t);</a>
<a name="ln1149">    STRCAT(t, trailarg);</a>
<a name="ln1150">    xfree(newcmd);</a>
<a name="ln1151">    newcmd = t;</a>
<a name="ln1152"> </a>
<a name="ln1153">    /*</a>
<a name="ln1154">     * Scan the rest of the argument for '!', which is replaced by the</a>
<a name="ln1155">     * previous command.  &quot;\!&quot; is replaced by &quot;!&quot; (this is vi compatible).</a>
<a name="ln1156">     */</a>
<a name="ln1157">    trailarg = NULL;</a>
<a name="ln1158">    while (*p) {</a>
<a name="ln1159">      if (*p == '!') {</a>
<a name="ln1160">        if (p &gt; newcmd &amp;&amp; p[-1] == '\\')</a>
<a name="ln1161">          STRMOVE(p - 1, p);</a>
<a name="ln1162">        else {</a>
<a name="ln1163">          trailarg = p;</a>
<a name="ln1164">          *trailarg++ = NUL;</a>
<a name="ln1165">          ins_prevcmd = true;</a>
<a name="ln1166">          break;</a>
<a name="ln1167">        }</a>
<a name="ln1168">      }</a>
<a name="ln1169">      ++p;</a>
<a name="ln1170">    }</a>
<a name="ln1171">  } while (trailarg != NULL);</a>
<a name="ln1172"> </a>
<a name="ln1173">  xfree(prevcmd);</a>
<a name="ln1174">  prevcmd = newcmd;</a>
<a name="ln1175"> </a>
<a name="ln1176">  if (bangredo) { /* put cmd in redo buffer for ! command */</a>
<a name="ln1177">    /* If % or # appears in the command, it must have been escaped.</a>
<a name="ln1178">     * Reescape them, so that redoing them does not substitute them by the</a>
<a name="ln1179">     * buffername. */</a>
<a name="ln1180">    char_u *cmd = vim_strsave_escaped(prevcmd, (char_u *)&quot;%#&quot;);</a>
<a name="ln1181"> </a>
<a name="ln1182">    AppendToRedobuffLit(cmd, -1);</a>
<a name="ln1183">    xfree(cmd);</a>
<a name="ln1184">    AppendToRedobuff(&quot;\n&quot;);</a>
<a name="ln1185">    bangredo = false;</a>
<a name="ln1186">  }</a>
<a name="ln1187">  /*</a>
<a name="ln1188">   * Add quotes around the command, for shells that need them.</a>
<a name="ln1189">   */</a>
<a name="ln1190">  if (*p_shq != NUL) {</a>
<a name="ln1191">    newcmd = xmalloc(STRLEN(prevcmd) + 2 * STRLEN(p_shq) + 1);</a>
<a name="ln1192">    STRCPY(newcmd, p_shq);</a>
<a name="ln1193">    STRCAT(newcmd, prevcmd);</a>
<a name="ln1194">    STRCAT(newcmd, p_shq);</a>
<a name="ln1195">    free_newcmd = true;</a>
<a name="ln1196">  }</a>
<a name="ln1197">  if (addr_count == 0) {                /* :! */</a>
<a name="ln1198">    /* echo the command */</a>
<a name="ln1199">    msg_start();</a>
<a name="ln1200">    msg_putchar(':');</a>
<a name="ln1201">    msg_putchar('!');</a>
<a name="ln1202">    msg_outtrans(newcmd);</a>
<a name="ln1203">    msg_clr_eos();</a>
<a name="ln1204">    ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln1205"> </a>
<a name="ln1206">    do_shell(newcmd, 0);</a>
<a name="ln1207">  } else {                            /* :range! */</a>
<a name="ln1208">    /* Careful: This may recursively call do_bang() again! (because of</a>
<a name="ln1209">     * autocommands) */</a>
<a name="ln1210">    do_filter(line1, line2, eap, newcmd, do_in, do_out);</a>
<a name="ln1211">    apply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, FALSE, curbuf);</a>
<a name="ln1212">  }</a>
<a name="ln1213">  if (free_newcmd)</a>
<a name="ln1214">    xfree(newcmd);</a>
<a name="ln1215">}</a>
<a name="ln1216"> </a>
<a name="ln1217">// do_filter: filter lines through a command given by the user</a>
<a name="ln1218">//</a>
<a name="ln1219">// We mostly use temp files and the call_shell() routine here. This would</a>
<a name="ln1220">// normally be done using pipes on a Unix system, but this is more portable</a>
<a name="ln1221">// to non-Unix systems. The call_shell() routine needs to be able</a>
<a name="ln1222">// to deal with redirection somehow, and should handle things like looking</a>
<a name="ln1223">// at the PATH env. variable, and adding reasonable extensions to the</a>
<a name="ln1224">// command name given by the user. All reasonable versions of call_shell()</a>
<a name="ln1225">// do this.</a>
<a name="ln1226">// Alternatively, if on Unix and redirecting input or output, but not both,</a>
<a name="ln1227">// and the 'shelltemp' option isn't set, use pipes.</a>
<a name="ln1228">// We use input redirection if do_in is true.</a>
<a name="ln1229">// We use output redirection if do_out is true.</a>
<a name="ln1230">static void do_filter(</a>
<a name="ln1231">    linenr_T line1,</a>
<a name="ln1232">    linenr_T line2,</a>
<a name="ln1233">    exarg_T *eap,               /* for forced 'ff' and 'fenc' */</a>
<a name="ln1234">    char_u *cmd,</a>
<a name="ln1235">    bool do_in,</a>
<a name="ln1236">    bool do_out)</a>
<a name="ln1237">{</a>
<a name="ln1238">  char_u      *itmp = NULL;</a>
<a name="ln1239">  char_u      *otmp = NULL;</a>
<a name="ln1240">  linenr_T linecount;</a>
<a name="ln1241">  linenr_T read_linecount;</a>
<a name="ln1242">  pos_T cursor_save;</a>
<a name="ln1243">  char_u      *cmd_buf;</a>
<a name="ln1244">  buf_T       *old_curbuf = curbuf;</a>
<a name="ln1245">  int shell_flags = 0;</a>
<a name="ln1246">  const int stmp = p_stmp;</a>
<a name="ln1247"> </a>
<a name="ln1248">  if (*cmd == NUL)          /* no filter command */</a>
<a name="ln1249">    return;</a>
<a name="ln1250"> </a>
<a name="ln1251"> </a>
<a name="ln1252">  cursor_save = curwin-&gt;w_cursor;</a>
<a name="ln1253">  linecount = line2 - line1 + 1;</a>
<a name="ln1254">  curwin-&gt;w_cursor.lnum = line1;</a>
<a name="ln1255">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1256">  changed_line_abv_curs();</a>
<a name="ln1257">  invalidate_botline();</a>
<a name="ln1258"> </a>
<a name="ln1259">  /*</a>
<a name="ln1260">   * When using temp files:</a>
<a name="ln1261">   * 1. * Form temp file names</a>
<a name="ln1262">   * 2. * Write the lines to a temp file</a>
<a name="ln1263">   * 3.   Run the filter command on the temp file</a>
<a name="ln1264">   * 4. * Read the output of the command into the buffer</a>
<a name="ln1265">   * 5. * Delete the original lines to be filtered</a>
<a name="ln1266">   * 6. * Remove the temp files</a>
<a name="ln1267">   *</a>
<a name="ln1268">   * When writing the input with a pipe or when catching the output with a</a>
<a name="ln1269">   * pipe only need to do 3.</a>
<a name="ln1270">   */</a>
<a name="ln1271"> </a>
<a name="ln1272">  if (do_out)</a>
<a name="ln1273">    shell_flags |= kShellOptDoOut;</a>
<a name="ln1274"> </a>
<a name="ln1275">  if (!do_in &amp;&amp; do_out &amp;&amp; !stmp) {</a>
<a name="ln1276">    // Use a pipe to fetch stdout of the command, do not use a temp file.</a>
<a name="ln1277">    shell_flags |= kShellOptRead;</a>
<a name="ln1278">    curwin-&gt;w_cursor.lnum = line2;</a>
<a name="ln1279">  } else if (do_in &amp;&amp; !do_out &amp;&amp; !stmp) {</a>
<a name="ln1280">    // Use a pipe to write stdin of the command, do not use a temp file.</a>
<a name="ln1281">    shell_flags |= kShellOptWrite;</a>
<a name="ln1282">    curbuf-&gt;b_op_start.lnum = line1;</a>
<a name="ln1283">    curbuf-&gt;b_op_end.lnum = line2;</a>
<a name="ln1284">  } else if (do_in &amp;&amp; do_out &amp;&amp; !stmp) {</a>
<a name="ln1285">    // Use a pipe to write stdin and fetch stdout of the command, do not</a>
<a name="ln1286">    // use a temp file.</a>
<a name="ln1287">    shell_flags |= kShellOptRead | kShellOptWrite;</a>
<a name="ln1288">    curbuf-&gt;b_op_start.lnum = line1;</a>
<a name="ln1289">    curbuf-&gt;b_op_end.lnum = line2;</a>
<a name="ln1290">    curwin-&gt;w_cursor.lnum = line2;</a>
<a name="ln1291">  } else if ((do_in &amp;&amp; (itmp = vim_tempname()) == NULL)</a>
<a name="ln1292">      || (do_out &amp;&amp; (otmp = vim_tempname()) == NULL)) {</a>
<a name="ln1293">    EMSG(_(e_notmp));</a>
<a name="ln1294">    goto filterend;</a>
<a name="ln1295">  }</a>
<a name="ln1296"> </a>
<a name="ln1297">  /*</a>
<a name="ln1298">   * The writing and reading of temp files will not be shown.</a>
<a name="ln1299">   * Vi also doesn't do this and the messages are not very informative.</a>
<a name="ln1300">   */</a>
<a name="ln1301">  ++no_wait_return;             /* don't call wait_return() while busy */</a>
<a name="ln1302">  if (itmp != NULL &amp;&amp; buf_write(curbuf, itmp, NULL, line1, line2, eap,</a>
<a name="ln1303">                                false, false, false, true) == FAIL) {</a>
<a name="ln1304">    msg_putchar('\n');  // Keep message from buf_write().</a>
<a name="ln1305">    no_wait_return--;</a>
<a name="ln1306">    if (!aborting()) {</a>
<a name="ln1307">      EMSG2(_(&quot;E482: Can't create file %s&quot;), itmp);  // Will call wait_return.</a>
<a name="ln1308">    }</a>
<a name="ln1309">    goto filterend;</a>
<a name="ln1310">  }</a>
<a name="ln1311">  if (curbuf != old_curbuf)</a>
<a name="ln1312">    goto filterend;</a>
<a name="ln1313"> </a>
<a name="ln1314">  if (!do_out)</a>
<a name="ln1315">    msg_putchar('\n');</a>
<a name="ln1316"> </a>
<a name="ln1317">  /* Create the shell command in allocated memory. */</a>
<a name="ln1318">  cmd_buf = make_filter_cmd(cmd, itmp, otmp);</a>
<a name="ln1319">  ui_cursor_goto(Rows - 1, 0);</a>
<a name="ln1320"> </a>
<a name="ln1321">  if (do_out) {</a>
<a name="ln1322">    if (u_save((linenr_T)(line2), (linenr_T)(line2 + 1)) == FAIL) {</a>
<a name="ln1323">      xfree(cmd_buf);</a>
<a name="ln1324">      goto error;</a>
<a name="ln1325">    }</a>
<a name="ln1326">    redraw_curbuf_later(VALID);</a>
<a name="ln1327">  }</a>
<a name="ln1328">  read_linecount = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1329"> </a>
<a name="ln1330">  // Pass on the kShellOptDoOut flag when the output is being redirected.</a>
<a name="ln1331">  call_shell(cmd_buf, kShellOptFilter | shell_flags, NULL);</a>
<a name="ln1332">  xfree(cmd_buf);</a>
<a name="ln1333"> </a>
<a name="ln1334">  did_check_timestamps = FALSE;</a>
<a name="ln1335">  need_check_timestamps = TRUE;</a>
<a name="ln1336"> </a>
<a name="ln1337">  /* When interrupting the shell command, it may still have produced some</a>
<a name="ln1338">   * useful output.  Reset got_int here, so that readfile() won't cancel</a>
<a name="ln1339">   * reading. */</a>
<a name="ln1340">  os_breakcheck();</a>
<a name="ln1341">  got_int = FALSE;</a>
<a name="ln1342"> </a>
<a name="ln1343">  if (do_out) {</a>
<a name="ln1344">    if (otmp != NULL) {</a>
<a name="ln1345">      if (readfile(otmp, NULL, line2, (linenr_T)0, (linenr_T)MAXLNUM, eap,</a>
<a name="ln1346">                   READ_FILTER) != OK) {</a>
<a name="ln1347">        if (!aborting()) {</a>
<a name="ln1348">          msg_putchar('\n');</a>
<a name="ln1349">          EMSG2(_(e_notread), otmp);</a>
<a name="ln1350">        }</a>
<a name="ln1351">        goto error;</a>
<a name="ln1352">      }</a>
<a name="ln1353">      if (curbuf != old_curbuf)</a>
<a name="ln1354">        goto filterend;</a>
<a name="ln1355">    }</a>
<a name="ln1356"> </a>
<a name="ln1357">    read_linecount = curbuf-&gt;b_ml.ml_line_count - read_linecount;</a>
<a name="ln1358"> </a>
<a name="ln1359">    if (shell_flags &amp; kShellOptRead) {</a>
<a name="ln1360">      curbuf-&gt;b_op_start.lnum = line2 + 1;</a>
<a name="ln1361">      curbuf-&gt;b_op_end.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1362">      appended_lines_mark(line2, read_linecount);</a>
<a name="ln1363">    }</a>
<a name="ln1364"> </a>
<a name="ln1365">    if (do_in) {</a>
<a name="ln1366">      if (cmdmod.keepmarks || vim_strchr(p_cpo, CPO_REMMARK) == NULL) {</a>
<a name="ln1367">        // TODO(bfredl): Currently not active for extmarks. What would we</a>
<a name="ln1368">        // do if columns don't match, assume added/deleted bytes at the</a>
<a name="ln1369">        // end of each line?</a>
<a name="ln1370">        if (read_linecount &gt;= linecount) {</a>
<a name="ln1371">          // move all marks from old lines to new lines</a>
<a name="ln1372">          mark_adjust(line1, line2, linecount, 0L, kExtmarkNOOP);</a>
<a name="ln1373">        } else {</a>
<a name="ln1374">          // move marks from old lines to new lines, delete marks</a>
<a name="ln1375">          // that are in deleted lines</a>
<a name="ln1376">          mark_adjust(line1, line1 + read_linecount - 1, linecount, 0L,</a>
<a name="ln1377">                      kExtmarkNOOP);</a>
<a name="ln1378">          mark_adjust(line1 + read_linecount, line2, MAXLNUM, 0L,</a>
<a name="ln1379">                      kExtmarkNOOP);</a>
<a name="ln1380">        }</a>
<a name="ln1381">      }</a>
<a name="ln1382"> </a>
<a name="ln1383">      /*</a>
<a name="ln1384">       * Put cursor on first filtered line for &quot;:range!cmd&quot;.</a>
<a name="ln1385">       * Adjust '[ and '] (set by buf_write()).</a>
<a name="ln1386">       */</a>
<a name="ln1387">      curwin-&gt;w_cursor.lnum = line1;</a>
<a name="ln1388">      del_lines(linecount, TRUE);</a>
<a name="ln1389">      curbuf-&gt;b_op_start.lnum -= linecount;             /* adjust '[ */</a>
<a name="ln1390">      curbuf-&gt;b_op_end.lnum -= linecount;               /* adjust '] */</a>
<a name="ln1391">      write_lnum_adjust(-linecount);                    /* adjust last line</a>
<a name="ln1392">                                                           for next write */</a>
<a name="ln1393">      foldUpdate(curwin, curbuf-&gt;b_op_start.lnum, curbuf-&gt;b_op_end.lnum);</a>
<a name="ln1394">    } else {</a>
<a name="ln1395">      /*</a>
<a name="ln1396">       * Put cursor on last new line for &quot;:r !cmd&quot;.</a>
<a name="ln1397">       */</a>
<a name="ln1398">      linecount = curbuf-&gt;b_op_end.lnum - curbuf-&gt;b_op_start.lnum + 1;</a>
<a name="ln1399">      curwin-&gt;w_cursor.lnum = curbuf-&gt;b_op_end.lnum;</a>
<a name="ln1400">    }</a>
<a name="ln1401"> </a>
<a name="ln1402">    beginline(BL_WHITE | BL_FIX);           /* cursor on first non-blank */</a>
<a name="ln1403">    --no_wait_return;</a>
<a name="ln1404"> </a>
<a name="ln1405">    if (linecount &gt; p_report) {</a>
<a name="ln1406">      if (do_in) {</a>
<a name="ln1407">        vim_snprintf((char *)msg_buf, sizeof(msg_buf),</a>
<a name="ln1408">            _(&quot;%&quot; PRId64 &quot; lines filtered&quot;), (int64_t)linecount);</a>
<a name="ln1409">        if (msg(msg_buf) &amp;&amp; !msg_scroll)</a>
<a name="ln1410">          /* save message to display it after redraw */</a>
<a name="ln1411">          set_keep_msg(msg_buf, 0);</a>
<a name="ln1412">      } else</a>
<a name="ln1413">        msgmore((long)linecount);</a>
<a name="ln1414">    }</a>
<a name="ln1415">  } else {</a>
<a name="ln1416">error:</a>
<a name="ln1417">    /* put cursor back in same position for &quot;:w !cmd&quot; */</a>
<a name="ln1418">    curwin-&gt;w_cursor = cursor_save;</a>
<a name="ln1419">    --no_wait_return;</a>
<a name="ln1420">    wait_return(FALSE);</a>
<a name="ln1421">  }</a>
<a name="ln1422"> </a>
<a name="ln1423">filterend:</a>
<a name="ln1424"> </a>
<a name="ln1425">  if (curbuf != old_curbuf) {</a>
<a name="ln1426">    --no_wait_return;</a>
<a name="ln1427">    EMSG(_(&quot;E135: *Filter* Autocommands must not change current buffer&quot;));</a>
<a name="ln1428">  }</a>
<a name="ln1429">  if (itmp != NULL)</a>
<a name="ln1430">    os_remove((char *)itmp);</a>
<a name="ln1431">  if (otmp != NULL)</a>
<a name="ln1432">    os_remove((char *)otmp);</a>
<a name="ln1433">  xfree(itmp);</a>
<a name="ln1434">  xfree(otmp);</a>
<a name="ln1435">}</a>
<a name="ln1436"> </a>
<a name="ln1437">// Call a shell to execute a command.</a>
<a name="ln1438">// When &quot;cmd&quot; is NULL start an interactive shell.</a>
<a name="ln1439">void</a>
<a name="ln1440">do_shell(</a>
<a name="ln1441">    char_u *cmd,</a>
<a name="ln1442">    int flags             // may be SHELL_DOOUT when output is redirected</a>
<a name="ln1443">)</a>
<a name="ln1444">{</a>
<a name="ln1445">  // Disallow shell commands from .exrc and .vimrc in current directory for</a>
<a name="ln1446">  // security reasons.</a>
<a name="ln1447">  if (check_secure()) {</a>
<a name="ln1448">    msg_end();</a>
<a name="ln1449">    return;</a>
<a name="ln1450">  }</a>
<a name="ln1451"> </a>
<a name="ln1452"> </a>
<a name="ln1453">  /*</a>
<a name="ln1454">   * For autocommands we want to get the output on the current screen, to</a>
<a name="ln1455">   * avoid having to type return below.</a>
<a name="ln1456">   */</a>
<a name="ln1457">  msg_putchar('\r');                    // put cursor at start of line</a>
<a name="ln1458">  msg_putchar('\n');                    // may shift screen one line up</a>
<a name="ln1459"> </a>
<a name="ln1460">  // warning message before calling the shell</a>
<a name="ln1461">  if (p_warn</a>
<a name="ln1462">      &amp;&amp; !autocmd_busy</a>
<a name="ln1463">      &amp;&amp; msg_silent == 0) {</a>
<a name="ln1464">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1465">      if (bufIsChanged(buf)) {</a>
<a name="ln1466">        MSG_PUTS(_(&quot;[No write since last change]\n&quot;));</a>
<a name="ln1467">        break;</a>
<a name="ln1468">      }</a>
<a name="ln1469">    }</a>
<a name="ln1470">  }</a>
<a name="ln1471"> </a>
<a name="ln1472">  // This ui_cursor_goto is required for when the '\n' resulted in a &quot;delete line</a>
<a name="ln1473">  // 1&quot; command to the terminal.</a>
<a name="ln1474">  ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln1475">  (void)call_shell(cmd, flags, NULL);</a>
<a name="ln1476">  msg_didout = true;</a>
<a name="ln1477">  did_check_timestamps = false;</a>
<a name="ln1478">  need_check_timestamps = true;</a>
<a name="ln1479"> </a>
<a name="ln1480">  // put the message cursor at the end of the screen, avoids wait_return()</a>
<a name="ln1481">  // to overwrite the text that the external command showed</a>
<a name="ln1482">  msg_row = Rows - 1;</a>
<a name="ln1483">  msg_col = 0;</a>
<a name="ln1484"> </a>
<a name="ln1485">  apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, FALSE, curbuf);</a>
<a name="ln1486">}</a>
<a name="ln1487"> </a>
<a name="ln1488">#if !defined(UNIX)</a>
<a name="ln1489">static char *find_pipe(const char *cmd)</a>
<a name="ln1490">{</a>
<a name="ln1491">  bool inquote = false;</a>
<a name="ln1492"> </a>
<a name="ln1493">  for (const char *p = cmd; *p != NUL; p++) {</a>
<a name="ln1494">    if (!inquote &amp;&amp; *p == '|') {</a>
<a name="ln1495">      return p;</a>
<a name="ln1496">    }</a>
<a name="ln1497">    if (*p == '&quot;') {</a>
<a name="ln1498">      inquote = !inquote;</a>
<a name="ln1499">    } else if (rem_backslash((const char_u *)p)) {</a>
<a name="ln1500">      p++;</a>
<a name="ln1501">    }</a>
<a name="ln1502">  }</a>
<a name="ln1503">  return NULL;</a>
<a name="ln1504">}</a>
<a name="ln1505">#endif</a>
<a name="ln1506"> </a>
<a name="ln1507">/// Create a shell command from a command string, input redirection file and</a>
<a name="ln1508">/// output redirection file.</a>
<a name="ln1509">///</a>
<a name="ln1510">/// @param cmd  Command to execute.</a>
<a name="ln1511">/// @param itmp NULL or the input file.</a>
<a name="ln1512">/// @param otmp NULL or the output file.</a>
<a name="ln1513">/// @returns an allocated string with the shell command.</a>
<a name="ln1514">char_u *make_filter_cmd(char_u *cmd, char_u *itmp, char_u *otmp)</a>
<a name="ln1515">{</a>
<a name="ln1516">  bool is_fish_shell =</a>
<a name="ln1517">#if defined(UNIX)</a>
<a name="ln1518">    STRNCMP(invocation_path_tail(p_sh, NULL), &quot;fish&quot;, 4) == 0;</a>
<a name="ln1519">#else</a>
<a name="ln1520">    false;</a>
<a name="ln1521">#endif</a>
<a name="ln1522"> </a>
<a name="ln1523">  size_t len = STRLEN(cmd) + 1;  // At least enough space for cmd + NULL.</a>
<a name="ln1524"> </a>
<a name="ln1525">  len += is_fish_shell ?  sizeof(&quot;begin; &quot;&quot;; end&quot;) - 1</a>
<a name="ln1526">                       :  sizeof(&quot;(&quot;&quot;)&quot;) - 1;</a>
<a name="ln1527"> </a>
<a name="ln1528">  if (itmp != NULL) {</a>
<a name="ln1529">    len += STRLEN(itmp) + sizeof(&quot; { &quot;&quot; &lt; &quot;&quot; } &quot;) - 1;</a>
<a name="ln1530">  }</a>
<a name="ln1531">  if (otmp != NULL) {</a>
<a name="ln1532">    len += STRLEN(otmp) + STRLEN(p_srr) + 2;  // two extra spaces (&quot;  &quot;),</a>
<a name="ln1533">  }</a>
<a name="ln1534">  char *const buf = xmalloc(len);</a>
<a name="ln1535"> </a>
<a name="ln1536">#if defined(UNIX)</a>
<a name="ln1537">  // Put delimiters around the command (for concatenated commands) when</a>
<a name="ln1538">  // redirecting input and/or output.</a>
<a name="ln1539">  if (itmp != NULL || otmp != NULL) {</a>
<a name="ln1540">    char *fmt = is_fish_shell ? &quot;begin; %s; end&quot;</a>
<a name="ln1541">                              :       &quot;(%s)&quot;;</a>
<a name="ln1542">    vim_snprintf(buf, len, fmt, (char *)cmd);</a>
<a name="ln1543">  } else {</a>
<a name="ln1544">    xstrlcpy(buf, (char *)cmd, len);</a>
<a name="ln1545">  }</a>
<a name="ln1546"> </a>
<a name="ln1547">  if (itmp != NULL) {</a>
<a name="ln1548">    xstrlcat(buf, &quot; &lt; &quot;, len - 1);</a>
<a name="ln1549">    xstrlcat(buf, (const char *)itmp, len - 1);</a>
<a name="ln1550">  }</a>
<a name="ln1551">#else</a>
<a name="ln1552">  // For shells that don't understand braces around commands, at least allow</a>
<a name="ln1553">  // the use of commands in a pipe.</a>
<a name="ln1554">  xstrlcpy(buf, (char *)cmd, len);</a>
<a name="ln1555">  if (itmp != NULL) {</a>
<a name="ln1556">    // If there is a pipe, we have to put the '&lt;' in front of it.</a>
<a name="ln1557">    // Don't do this when 'shellquote' is not empty, otherwise the</a>
<a name="ln1558">    // redirection would be inside the quotes.</a>
<a name="ln1559">    if (*p_shq == NUL) {</a>
<a name="ln1560">      char *const p = find_pipe(buf);</a>
<a name="ln1561">      if (p != NULL) {</a>
<a name="ln1562">        *p = NUL;</a>
<a name="ln1563">      }</a>
<a name="ln1564">    }</a>
<a name="ln1565">    xstrlcat(buf, &quot; &lt; &quot;, len);</a>
<a name="ln1566">    xstrlcat(buf, (const char *)itmp, len);</a>
<a name="ln1567">    if (*p_shq == NUL) {</a>
<a name="ln1568">      const char *const p = find_pipe((const char *)cmd);</a>
<a name="ln1569">      if (p != NULL) {</a>
<a name="ln1570">        xstrlcat(buf, &quot; &quot;, len - 1);  // Insert a space before the '|' for DOS</a>
<a name="ln1571">        xstrlcat(buf, p, len - 1);</a>
<a name="ln1572">      }</a>
<a name="ln1573">    }</a>
<a name="ln1574">  }</a>
<a name="ln1575">#endif</a>
<a name="ln1576">  if (otmp != NULL) {</a>
<a name="ln1577">    append_redir(buf, len, (char *) p_srr, (char *) otmp);</a>
<a name="ln1578">  }</a>
<a name="ln1579">  return (char_u *) buf;</a>
<a name="ln1580">}</a>
<a name="ln1581"> </a>
<a name="ln1582">/// Append output redirection for the given file to the end of the buffer</a>
<a name="ln1583">///</a>
<a name="ln1584">/// @param[out]  buf  Buffer to append to.</a>
<a name="ln1585">/// @param[in]  buflen  Buffer length.</a>
<a name="ln1586">/// @param[in]  opt  Separator or format string to append: will append</a>
<a name="ln1587">///                  `printf(' ' . opt, fname)` if `%s` is found in `opt` or</a>
<a name="ln1588">///                  a space, opt, a space and then fname if `%s` is not found</a>
<a name="ln1589">///                  there.</a>
<a name="ln1590">/// @param[in]  fname  File name to append.</a>
<a name="ln1591">void append_redir(char *const buf, const size_t buflen,</a>
<a name="ln1592">                  const char *const opt, const char *const fname)</a>
<a name="ln1593">{</a>
<a name="ln1594">  char *const end = buf + strlen(buf);</a>
<a name="ln1595">  // find &quot;%s&quot;</a>
<a name="ln1596">  const char *p = opt;</a>
<a name="ln1597">  for (; (p = strchr(p, '%')) != NULL; p++) {</a>
<a name="ln1598">    if (p[1] == 's') {  // found %s</a>
<a name="ln1599">      break;</a>
<a name="ln1600">    } else if (p[1] == '%') {  // skip %%</a>
<a name="ln1601">      p++;</a>
<a name="ln1602">    }</a>
<a name="ln1603">  }</a>
<a name="ln1604">  if (p != NULL) {</a>
<a name="ln1605">    *end = ' ';  // not really needed? Not with sh, ksh or bash</a>
<a name="ln1606">    vim_snprintf(end + 1, (size_t) (buflen - (end + 1 - buf)), opt, fname);</a>
<a name="ln1607">  } else {</a>
<a name="ln1608">    vim_snprintf(end, (size_t) (buflen - (end - buf)), &quot; %s %s&quot;, opt, fname);</a>
<a name="ln1609">  }</a>
<a name="ln1610">}</a>
<a name="ln1611"> </a>
<a name="ln1612">void print_line_no_prefix(linenr_T lnum, int use_number, int list)</a>
<a name="ln1613">{</a>
<a name="ln1614">  char numbuf[30];</a>
<a name="ln1615"> </a>
<a name="ln1616">  if (curwin-&gt;w_p_nu || use_number) {</a>
<a name="ln1617">    vim_snprintf(numbuf, sizeof(numbuf), &quot;%*&quot; PRIdLINENR &quot; &quot;,</a>
<a name="ln1618">                 number_width(curwin), lnum);</a>
<a name="ln1619">    msg_puts_attr(numbuf, HL_ATTR(HLF_N));  // Highlight line nrs.</a>
<a name="ln1620">  }</a>
<a name="ln1621">  msg_prt_line(ml_get(lnum), list);</a>
<a name="ln1622">}</a>
<a name="ln1623"> </a>
<a name="ln1624">/*</a>
<a name="ln1625"> * Print a text line.  Also in silent mode (&quot;ex -s&quot;).</a>
<a name="ln1626"> */</a>
<a name="ln1627">void print_line(linenr_T lnum, int use_number, int list)</a>
<a name="ln1628">{</a>
<a name="ln1629">  int save_silent = silent_mode;</a>
<a name="ln1630"> </a>
<a name="ln1631">  // apply :filter /pat/</a>
<a name="ln1632">  if (message_filtered(ml_get(lnum))) {</a>
<a name="ln1633">    return;</a>
<a name="ln1634">  }</a>
<a name="ln1635"> </a>
<a name="ln1636">  msg_start();</a>
<a name="ln1637">  silent_mode = FALSE;</a>
<a name="ln1638">  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */</a>
<a name="ln1639">  print_line_no_prefix(lnum, use_number, list);</a>
<a name="ln1640">  if (save_silent) {</a>
<a name="ln1641">    msg_putchar('\n');</a>
<a name="ln1642">    ui_flush();</a>
<a name="ln1643">    silent_mode = save_silent;</a>
<a name="ln1644">  }</a>
<a name="ln1645">  info_message = FALSE;</a>
<a name="ln1646">}</a>
<a name="ln1647"> </a>
<a name="ln1648">int rename_buffer(char_u *new_fname)</a>
<a name="ln1649">{</a>
<a name="ln1650">  char_u      *fname, *sfname, *xfname;</a>
<a name="ln1651">  buf_T       *buf;</a>
<a name="ln1652"> </a>
<a name="ln1653">  buf = curbuf;</a>
<a name="ln1654">  apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);</a>
<a name="ln1655">  /* buffer changed, don't change name now */</a>
<a name="ln1656">  if (buf != curbuf)</a>
<a name="ln1657">    return FAIL;</a>
<a name="ln1658">  if (aborting())           /* autocmds may abort script processing */</a>
<a name="ln1659">    return FAIL;</a>
<a name="ln1660">  /*</a>
<a name="ln1661">   * The name of the current buffer will be changed.</a>
<a name="ln1662">   * A new (unlisted) buffer entry needs to be made to hold the old file</a>
<a name="ln1663">   * name, which will become the alternate file name.</a>
<a name="ln1664">   * But don't set the alternate file name if the buffer didn't have a</a>
<a name="ln1665">   * name.</a>
<a name="ln1666">   */</a>
<a name="ln1667">  fname = curbuf-&gt;b_ffname;</a>
<a name="ln1668">  sfname = curbuf-&gt;b_sfname;</a>
<a name="ln1669">  xfname = curbuf-&gt;b_fname;</a>
<a name="ln1670">  curbuf-&gt;b_ffname = NULL;</a>
<a name="ln1671">  curbuf-&gt;b_sfname = NULL;</a>
<a name="ln1672">  if (setfname(curbuf, new_fname, NULL, true) == FAIL) {</a>
<a name="ln1673">    curbuf-&gt;b_ffname = fname;</a>
<a name="ln1674">    curbuf-&gt;b_sfname = sfname;</a>
<a name="ln1675">    return FAIL;</a>
<a name="ln1676">  }</a>
<a name="ln1677">  curbuf-&gt;b_flags |= BF_NOTEDITED;</a>
<a name="ln1678">  if (xfname != NULL &amp;&amp; *xfname != NUL) {</a>
<a name="ln1679">    buf = buflist_new(fname, xfname, curwin-&gt;w_cursor.lnum, 0);</a>
<a name="ln1680">    if (buf != NULL &amp;&amp; !cmdmod.keepalt) {</a>
<a name="ln1681">      curwin-&gt;w_alt_fnum = buf-&gt;b_fnum;</a>
<a name="ln1682">    }</a>
<a name="ln1683">  }</a>
<a name="ln1684">  xfree(fname);</a>
<a name="ln1685">  xfree(sfname);</a>
<a name="ln1686">  apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);</a>
<a name="ln1687">  /* Change directories when the 'acd' option is set. */</a>
<a name="ln1688">  do_autochdir();</a>
<a name="ln1689">  return OK;</a>
<a name="ln1690">}</a>
<a name="ln1691"> </a>
<a name="ln1692">/*</a>
<a name="ln1693"> * &quot;:file[!] [fname]&quot;.</a>
<a name="ln1694"> */</a>
<a name="ln1695">void ex_file(exarg_T *eap)</a>
<a name="ln1696">{</a>
<a name="ln1697">  /* &quot;:0file&quot; removes the file name.  Check for illegal uses &quot;:3file&quot;,</a>
<a name="ln1698">   * &quot;0file name&quot;, etc. */</a>
<a name="ln1699">  if (eap-&gt;addr_count &gt; 0</a>
<a name="ln1700">      &amp;&amp; (*eap-&gt;arg != NUL</a>
<a name="ln1701">          || eap-&gt;line2 &gt; 0</a>
<a name="ln1702">          || eap-&gt;addr_count &gt; 1)) {</a>
<a name="ln1703">    EMSG(_(e_invarg));</a>
<a name="ln1704">    return;</a>
<a name="ln1705">  }</a>
<a name="ln1706"> </a>
<a name="ln1707">  if (*eap-&gt;arg != NUL || eap-&gt;addr_count == 1) {</a>
<a name="ln1708">    if (rename_buffer(eap-&gt;arg) == FAIL) {</a>
<a name="ln1709">      return;</a>
<a name="ln1710">    }</a>
<a name="ln1711">    redraw_tabline = true;</a>
<a name="ln1712">  }</a>
<a name="ln1713"> </a>
<a name="ln1714">  // print file name if no argument or 'F' is not in 'shortmess'</a>
<a name="ln1715">  if (*eap-&gt;arg == NUL || !shortmess(SHM_FILEINFO)) {</a>
<a name="ln1716">    fileinfo(false, false, eap-&gt;forceit);</a>
<a name="ln1717">  }</a>
<a name="ln1718">}</a>
<a name="ln1719"> </a>
<a name="ln1720">/*</a>
<a name="ln1721"> * &quot;:update&quot;.</a>
<a name="ln1722"> */</a>
<a name="ln1723">void ex_update(exarg_T *eap)</a>
<a name="ln1724">{</a>
<a name="ln1725">  if (curbufIsChanged())</a>
<a name="ln1726">    (void)do_write(eap);</a>
<a name="ln1727">}</a>
<a name="ln1728"> </a>
<a name="ln1729">/*</a>
<a name="ln1730"> * &quot;:write&quot; and &quot;:saveas&quot;.</a>
<a name="ln1731"> */</a>
<a name="ln1732">void ex_write(exarg_T *eap)</a>
<a name="ln1733">{</a>
<a name="ln1734">  if (eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1735">    // :saveas does not take a range, uses all lines.</a>
<a name="ln1736">    eap-&gt;line1 = 1;</a>
<a name="ln1737">    eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1738">  }</a>
<a name="ln1739"> </a>
<a name="ln1740">  if (eap-&gt;usefilter) {  // input lines to shell command</a>
<a name="ln1741">    do_bang(1, eap, false, true, false);</a>
<a name="ln1742">  } else {</a>
<a name="ln1743">    (void)do_write(eap);</a>
<a name="ln1744">  }</a>
<a name="ln1745">}</a>
<a name="ln1746"> </a>
<a name="ln1747">/*</a>
<a name="ln1748"> * write current buffer to file 'eap-&gt;arg'</a>
<a name="ln1749"> * if 'eap-&gt;append' is TRUE, append to the file</a>
<a name="ln1750"> *</a>
<a name="ln1751"> * if *eap-&gt;arg == NUL write to current file</a>
<a name="ln1752"> *</a>
<a name="ln1753"> * return FAIL for failure, OK otherwise</a>
<a name="ln1754"> */</a>
<a name="ln1755">int do_write(exarg_T *eap)</a>
<a name="ln1756">{</a>
<a name="ln1757">  int other;</a>
<a name="ln1758">  char_u      *fname = NULL;            /* init to shut up gcc */</a>
<a name="ln1759">  char_u      *ffname;</a>
<a name="ln1760">  int retval = FAIL;</a>
<a name="ln1761">  char_u      *free_fname = NULL;</a>
<a name="ln1762">  buf_T       *alt_buf = NULL;</a>
<a name="ln1763">  int          name_was_missing;</a>
<a name="ln1764"> </a>
<a name="ln1765">  if (not_writing())            /* check 'write' option */</a>
<a name="ln1766">    return FAIL;</a>
<a name="ln1767"> </a>
<a name="ln1768">  ffname = eap-&gt;arg;</a>
<a name="ln1769">  if (*ffname == NUL) {</a>
<a name="ln1770">    if (eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1771">      EMSG(_(e_argreq));</a>
<a name="ln1772">      goto theend;</a>
<a name="ln1773">    }</a>
<a name="ln1774">    other = FALSE;</a>
<a name="ln1775">  } else {</a>
<a name="ln1776">    fname = ffname;</a>
<a name="ln1777">    free_fname = (char_u *)fix_fname((char *)ffname);</a>
<a name="ln1778">    /*</a>
<a name="ln1779">     * When out-of-memory, keep unexpanded file name, because we MUST be</a>
<a name="ln1780">     * able to write the file in this situation.</a>
<a name="ln1781">     */</a>
<a name="ln1782">    if (free_fname != NULL)</a>
<a name="ln1783">      ffname = free_fname;</a>
<a name="ln1784">    other = otherfile(ffname);</a>
<a name="ln1785">  }</a>
<a name="ln1786"> </a>
<a name="ln1787">  /*</a>
<a name="ln1788">   * If we have a new file, put its name in the list of alternate file names.</a>
<a name="ln1789">   */</a>
<a name="ln1790">  if (other) {</a>
<a name="ln1791">    if (vim_strchr(p_cpo, CPO_ALTWRITE) != NULL</a>
<a name="ln1792">        || eap-&gt;cmdidx == CMD_saveas)</a>
<a name="ln1793">      alt_buf = setaltfname(ffname, fname, (linenr_T)1);</a>
<a name="ln1794">    else</a>
<a name="ln1795">      alt_buf = buflist_findname(ffname);</a>
<a name="ln1796">    if (alt_buf != NULL &amp;&amp; alt_buf-&gt;b_ml.ml_mfp != NULL) {</a>
<a name="ln1797">      /* Overwriting a file that is loaded in another buffer is not a</a>
<a name="ln1798">       * good idea. */</a>
<a name="ln1799">      EMSG(_(e_bufloaded));</a>
<a name="ln1800">      goto theend;</a>
<a name="ln1801">    }</a>
<a name="ln1802">  }</a>
<a name="ln1803"> </a>
<a name="ln1804">  // Writing to the current file is not allowed in readonly mode</a>
<a name="ln1805">  // and a file name is required.</a>
<a name="ln1806">  // &quot;nofile&quot; and &quot;nowrite&quot; buffers cannot be written implicitly either.</a>
<a name="ln1807">  if (!other &amp;&amp; (bt_dontwrite_msg(curbuf)</a>
<a name="ln1808">                 || check_fname() == FAIL</a>
<a name="ln1809">                 || check_readonly(&amp;eap-&gt;forceit, curbuf))) {</a>
<a name="ln1810">    goto theend;</a>
<a name="ln1811">  }</a>
<a name="ln1812"> </a>
<a name="ln1813">  if (!other) {</a>
<a name="ln1814">    ffname = curbuf-&gt;b_ffname;</a>
<a name="ln1815">    fname = curbuf-&gt;b_fname;</a>
<a name="ln1816">    /*</a>
<a name="ln1817">     * Not writing the whole file is only allowed with '!'.</a>
<a name="ln1818">     */</a>
<a name="ln1819">    if (       (eap-&gt;line1 != 1</a>
<a name="ln1820">                || eap-&gt;line2 != curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln1821">               &amp;&amp; !eap-&gt;forceit</a>
<a name="ln1822">               &amp;&amp; !eap-&gt;append</a>
<a name="ln1823">               &amp;&amp; !p_wa) {</a>
<a name="ln1824">      if (p_confirm || cmdmod.confirm) {</a>
<a name="ln1825">        if (vim_dialog_yesno(VIM_QUESTION, NULL,</a>
<a name="ln1826">                (char_u *)_(&quot;Write partial file?&quot;), 2) != VIM_YES)</a>
<a name="ln1827">          goto theend;</a>
<a name="ln1828">        eap-&gt;forceit = TRUE;</a>
<a name="ln1829">      } else {</a>
<a name="ln1830">        EMSG(_(&quot;E140: Use ! to write partial buffer&quot;));</a>
<a name="ln1831">        goto theend;</a>
<a name="ln1832">      }</a>
<a name="ln1833">    }</a>
<a name="ln1834">  }</a>
<a name="ln1835"> </a>
<a name="ln1836">  if (check_overwrite(eap, curbuf, fname, ffname, other) == OK) {</a>
<a name="ln1837">    if (eap-&gt;cmdidx == CMD_saveas &amp;&amp; alt_buf != NULL) {</a>
<a name="ln1838">      buf_T       *was_curbuf = curbuf;</a>
<a name="ln1839"> </a>
<a name="ln1840">      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);</a>
<a name="ln1841">      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, alt_buf);</a>
<a name="ln1842">      if (curbuf != was_curbuf || aborting()) {</a>
<a name="ln1843">        /* buffer changed, don't change name now */</a>
<a name="ln1844">        retval = FAIL;</a>
<a name="ln1845">        goto theend;</a>
<a name="ln1846">      }</a>
<a name="ln1847">      /* Exchange the file names for the current and the alternate</a>
<a name="ln1848">       * buffer.  This makes it look like we are now editing the buffer</a>
<a name="ln1849">       * under the new name.  Must be done before buf_write(), because</a>
<a name="ln1850">       * if there is no file name and 'cpo' contains 'F', it will set</a>
<a name="ln1851">       * the file name. */</a>
<a name="ln1852">      fname = alt_buf-&gt;b_fname;</a>
<a name="ln1853">      alt_buf-&gt;b_fname = curbuf-&gt;b_fname;</a>
<a name="ln1854">      curbuf-&gt;b_fname = fname;</a>
<a name="ln1855">      fname = alt_buf-&gt;b_ffname;</a>
<a name="ln1856">      alt_buf-&gt;b_ffname = curbuf-&gt;b_ffname;</a>
<a name="ln1857">      curbuf-&gt;b_ffname = fname;</a>
<a name="ln1858">      fname = alt_buf-&gt;b_sfname;</a>
<a name="ln1859">      alt_buf-&gt;b_sfname = curbuf-&gt;b_sfname;</a>
<a name="ln1860">      curbuf-&gt;b_sfname = fname;</a>
<a name="ln1861">      buf_name_changed(curbuf);</a>
<a name="ln1862">      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);</a>
<a name="ln1863">      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, alt_buf);</a>
<a name="ln1864">      if (!alt_buf-&gt;b_p_bl) {</a>
<a name="ln1865">        alt_buf-&gt;b_p_bl = TRUE;</a>
<a name="ln1866">        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);</a>
<a name="ln1867">      }</a>
<a name="ln1868">      if (curbuf != was_curbuf || aborting()) {</a>
<a name="ln1869">        /* buffer changed, don't write the file */</a>
<a name="ln1870">        retval = FAIL;</a>
<a name="ln1871">        goto theend;</a>
<a name="ln1872">      }</a>
<a name="ln1873"> </a>
<a name="ln1874">      // If 'filetype' was empty try detecting it now.</a>
<a name="ln1875">      if (*curbuf-&gt;b_p_ft == NUL) {</a>
<a name="ln1876">        if (au_has_group((char_u *)&quot;filetypedetect&quot;)) {</a>
<a name="ln1877">          (void)do_doautocmd((char_u *)&quot;filetypedetect BufRead&quot;, true, NULL);</a>
<a name="ln1878">        }</a>
<a name="ln1879">        do_modelines(0);</a>
<a name="ln1880">      }</a>
<a name="ln1881"> </a>
<a name="ln1882">      /* Autocommands may have changed buffer names, esp. when</a>
<a name="ln1883">       * 'autochdir' is set. */</a>
<a name="ln1884">      fname = curbuf-&gt;b_sfname;</a>
<a name="ln1885">    }</a>
<a name="ln1886"> </a>
<a name="ln1887">    name_was_missing = curbuf-&gt;b_ffname == NULL;</a>
<a name="ln1888">    retval = buf_write(curbuf, ffname, fname, eap-&gt;line1, eap-&gt;line2,</a>
<a name="ln1889">        eap, eap-&gt;append, eap-&gt;forceit, TRUE, FALSE);</a>
<a name="ln1890"> </a>
<a name="ln1891">    /* After &quot;:saveas fname&quot; reset 'readonly'. */</a>
<a name="ln1892">    if (eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1893">      if (retval == OK) {</a>
<a name="ln1894">        curbuf-&gt;b_p_ro = FALSE;</a>
<a name="ln1895">        redraw_tabline = TRUE;</a>
<a name="ln1896">      }</a>
<a name="ln1897">    }</a>
<a name="ln1898"> </a>
<a name="ln1899">    // Change directories when the 'acd' option is set and the file name</a>
<a name="ln1900">    // got changed or set.</a>
<a name="ln1901">    if (eap-&gt;cmdidx == CMD_saveas || name_was_missing) {</a>
<a name="ln1902">      do_autochdir();</a>
<a name="ln1903">    }</a>
<a name="ln1904">  }</a>
<a name="ln1905"> </a>
<a name="ln1906">theend:</a>
<a name="ln1907">  xfree(free_fname);</a>
<a name="ln1908">  return retval;</a>
<a name="ln1909">}</a>
<a name="ln1910"> </a>
<a name="ln1911">/*</a>
<a name="ln1912"> * Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,</a>
<a name="ln1913"> * BF_NEW or BF_READERR, check for overwriting current file.</a>
<a name="ln1914"> * May set eap-&gt;forceit if a dialog says it's OK to overwrite.</a>
<a name="ln1915"> * Return OK if it's OK, FAIL if it is not.</a>
<a name="ln1916"> */</a>
<a name="ln1917">int</a>
<a name="ln1918">check_overwrite(</a>
<a name="ln1919">    exarg_T *eap,</a>
<a name="ln1920">    buf_T *buf,</a>
<a name="ln1921">    char_u *fname,         // file name to be used (can differ from</a>
<a name="ln1922">                           //   buf-&gt;ffname)</a>
<a name="ln1923">    char_u *ffname,        // full path version of fname</a>
<a name="ln1924">    int other              // writing under other name</a>
<a name="ln1925">)</a>
<a name="ln1926">{</a>
<a name="ln1927">  /*</a>
<a name="ln1928">   * write to other file or b_flags set or not writing the whole file:</a>
<a name="ln1929">   * overwriting only allowed with '!'</a>
<a name="ln1930">   */</a>
<a name="ln1931">  if ((other</a>
<a name="ln1932">       || (buf-&gt;b_flags &amp; BF_NOTEDITED)</a>
<a name="ln1933">       || ((buf-&gt;b_flags &amp; BF_NEW)</a>
<a name="ln1934">           &amp;&amp; vim_strchr(p_cpo, CPO_OVERNEW) == NULL)</a>
<a name="ln1935">       || (buf-&gt;b_flags &amp; BF_READERR))</a>
<a name="ln1936">      &amp;&amp; !p_wa</a>
<a name="ln1937">      &amp;&amp; !bt_nofile(buf)</a>
<a name="ln1938">      &amp;&amp; os_path_exists(ffname)) {</a>
<a name="ln1939">    if (!eap-&gt;forceit &amp;&amp; !eap-&gt;append) {</a>
<a name="ln1940">#ifdef UNIX</a>
<a name="ln1941">      // It is possible to open a directory on Unix.</a>
<a name="ln1942">      if (os_isdir(ffname)) {</a>
<a name="ln1943">        EMSG2(_(e_isadir2), ffname);</a>
<a name="ln1944">        return FAIL;</a>
<a name="ln1945">      }</a>
<a name="ln1946">#endif</a>
<a name="ln1947">      if (p_confirm || cmdmod.confirm) {</a>
<a name="ln1948">        char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln1949"> </a>
<a name="ln1950">        dialog_msg(buff, _(&quot;Overwrite existing file \&quot;%s\&quot;?&quot;), fname);</a>
<a name="ln1951">        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES)</a>
<a name="ln1952">          return FAIL;</a>
<a name="ln1953">        eap-&gt;forceit = TRUE;</a>
<a name="ln1954">      } else {</a>
<a name="ln1955">        EMSG(_(e_exists));</a>
<a name="ln1956">        return FAIL;</a>
<a name="ln1957">      }</a>
<a name="ln1958">    }</a>
<a name="ln1959"> </a>
<a name="ln1960">    /* For &quot;:w! filename&quot; check that no swap file exists for &quot;filename&quot;. */</a>
<a name="ln1961">    if (other &amp;&amp; !emsg_silent) {</a>
<a name="ln1962">      char_u      *dir;</a>
<a name="ln1963">      char_u      *p;</a>
<a name="ln1964">      char_u      *swapname;</a>
<a name="ln1965"> </a>
<a name="ln1966">      /* We only try the first entry in 'directory', without checking if</a>
<a name="ln1967">       * it's writable.  If the &quot;.&quot; directory is not writable the write</a>
<a name="ln1968">       * will probably fail anyway.</a>
<a name="ln1969">       * Use 'shortname' of the current buffer, since there is no buffer</a>
<a name="ln1970">       * for the written file. */</a>
<a name="ln1971">      if (*p_dir == NUL) {</a>
<a name="ln1972">        dir = xmalloc(5);</a>
<a name="ln1973">        STRCPY(dir, &quot;.&quot;);</a>
<a name="ln1974">      } else {</a>
<a name="ln1975">        dir = xmalloc(MAXPATHL);</a>
<a name="ln1976">        p = p_dir;</a>
<a name="ln1977">        copy_option_part(&amp;p, dir, MAXPATHL, &quot;,&quot;);</a>
<a name="ln1978">      }</a>
<a name="ln1979">      swapname = makeswapname(fname, ffname, curbuf, dir);</a>
<a name="ln1980">      xfree(dir);</a>
<a name="ln1981">      if (os_path_exists(swapname)) {</a>
<a name="ln1982">        if (p_confirm || cmdmod.confirm) {</a>
<a name="ln1983">          char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln1984"> </a>
<a name="ln1985">          dialog_msg(buff,</a>
<a name="ln1986">              _(&quot;Swap file \&quot;%s\&quot; exists, overwrite anyway?&quot;),</a>
<a name="ln1987">              swapname);</a>
<a name="ln1988">          if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2)</a>
<a name="ln1989">              != VIM_YES) {</a>
<a name="ln1990">            xfree(swapname);</a>
<a name="ln1991">            return FAIL;</a>
<a name="ln1992">          }</a>
<a name="ln1993">          eap-&gt;forceit = TRUE;</a>
<a name="ln1994">        } else {</a>
<a name="ln1995">          EMSG2(_(&quot;E768: Swap file exists: %s (:silent! overrides)&quot;),</a>
<a name="ln1996">              swapname);</a>
<a name="ln1997">          xfree(swapname);</a>
<a name="ln1998">          return FAIL;</a>
<a name="ln1999">        }</a>
<a name="ln2000">      }</a>
<a name="ln2001">      xfree(swapname);</a>
<a name="ln2002">    }</a>
<a name="ln2003">  }</a>
<a name="ln2004">  return OK;</a>
<a name="ln2005">}</a>
<a name="ln2006"> </a>
<a name="ln2007">/*</a>
<a name="ln2008"> * Handle &quot;:wnext&quot;, &quot;:wNext&quot; and &quot;:wprevious&quot; commands.</a>
<a name="ln2009"> */</a>
<a name="ln2010">void ex_wnext(exarg_T *eap)</a>
<a name="ln2011">{</a>
<a name="ln2012">  int i;</a>
<a name="ln2013"> </a>
<a name="ln2014">  if (eap-&gt;cmd[1] == 'n')</a>
<a name="ln2015">    i = curwin-&gt;w_arg_idx + (int)eap-&gt;line2;</a>
<a name="ln2016">  else</a>
<a name="ln2017">    i = curwin-&gt;w_arg_idx - (int)eap-&gt;line2;</a>
<a name="ln2018">  eap-&gt;line1 = 1;</a>
<a name="ln2019">  eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2020">  if (do_write(eap) != FAIL)</a>
<a name="ln2021">    do_argfile(eap, i);</a>
<a name="ln2022">}</a>
<a name="ln2023"> </a>
<a name="ln2024">/*</a>
<a name="ln2025"> * &quot;:wall&quot;, &quot;:wqall&quot; and &quot;:xall&quot;: Write all changed files (and exit).</a>
<a name="ln2026"> */</a>
<a name="ln2027">void do_wqall(exarg_T *eap)</a>
<a name="ln2028">{</a>
<a name="ln2029">  int error = 0;</a>
<a name="ln2030">  int save_forceit = eap-&gt;forceit;</a>
<a name="ln2031"> </a>
<a name="ln2032">  if (eap-&gt;cmdidx == CMD_xall || eap-&gt;cmdidx == CMD_wqall) {</a>
<a name="ln2033">    exiting = true;</a>
<a name="ln2034">  }</a>
<a name="ln2035"> </a>
<a name="ln2036">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2037">    if (exiting</a>
<a name="ln2038">        &amp;&amp; buf-&gt;terminal</a>
<a name="ln2039">        &amp;&amp; channel_job_running((uint64_t)buf-&gt;b_p_channel)) {</a>
<a name="ln2040">      no_write_message_nobang(buf);</a>
<a name="ln2041">      error++;</a>
<a name="ln2042">    } else if (!bufIsChanged(buf) || bt_dontwrite(buf)) {</a>
<a name="ln2043">      continue;</a>
<a name="ln2044">    }</a>
<a name="ln2045">    /*</a>
<a name="ln2046">     * Check if there is a reason the buffer cannot be written:</a>
<a name="ln2047">     * 1. if the 'write' option is set</a>
<a name="ln2048">     * 2. if there is no file name (even after browsing)</a>
<a name="ln2049">     * 3. if the 'readonly' is set (even after a dialog)</a>
<a name="ln2050">     * 4. if overwriting is allowed (even after a dialog)</a>
<a name="ln2051">     */</a>
<a name="ln2052">    if (not_writing()) {</a>
<a name="ln2053">      ++error;</a>
<a name="ln2054">      break;</a>
<a name="ln2055">    }</a>
<a name="ln2056">    if (buf-&gt;b_ffname == NULL) {</a>
<a name="ln2057">      EMSGN(_(&quot;E141: No file name for buffer %&quot; PRId64), buf-&gt;b_fnum);</a>
<a name="ln2058">      ++error;</a>
<a name="ln2059">    } else if (check_readonly(&amp;eap-&gt;forceit, buf)</a>
<a name="ln2060">               || check_overwrite(eap, buf, buf-&gt;b_fname, buf-&gt;b_ffname,</a>
<a name="ln2061">                   FALSE) == FAIL) {</a>
<a name="ln2062">      ++error;</a>
<a name="ln2063">    } else {</a>
<a name="ln2064">      bufref_T bufref;</a>
<a name="ln2065">      set_bufref(&amp;bufref, buf);</a>
<a name="ln2066">      if (buf_write_all(buf, eap-&gt;forceit) == FAIL) {</a>
<a name="ln2067">        error++;</a>
<a name="ln2068">      }</a>
<a name="ln2069">      // An autocommand may have deleted the buffer.</a>
<a name="ln2070">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2071">        buf = firstbuf;</a>
<a name="ln2072">      }</a>
<a name="ln2073">    }</a>
<a name="ln2074">    eap-&gt;forceit = save_forceit;          /* check_overwrite() may set it */</a>
<a name="ln2075">  }</a>
<a name="ln2076">  if (exiting) {</a>
<a name="ln2077">    if (!error)</a>
<a name="ln2078">      getout(0);                /* exit Vim */</a>
<a name="ln2079">    not_exiting();</a>
<a name="ln2080">  }</a>
<a name="ln2081">}</a>
<a name="ln2082"> </a>
<a name="ln2083">/*</a>
<a name="ln2084"> * Check the 'write' option.</a>
<a name="ln2085"> * Return TRUE and give a message when it's not st.</a>
<a name="ln2086"> */</a>
<a name="ln2087">int not_writing(void)</a>
<a name="ln2088">{</a>
<a name="ln2089">  if (p_write)</a>
<a name="ln2090">    return FALSE;</a>
<a name="ln2091">  EMSG(_(&quot;E142: File not written: Writing is disabled by 'write' option&quot;));</a>
<a name="ln2092">  return TRUE;</a>
<a name="ln2093">}</a>
<a name="ln2094"> </a>
<a name="ln2095">/*</a>
<a name="ln2096"> * Check if a buffer is read-only (either 'readonly' option is set or file is</a>
<a name="ln2097"> * read-only). Ask for overruling in a dialog. Return TRUE and give an error</a>
<a name="ln2098"> * message when the buffer is readonly.</a>
<a name="ln2099"> */</a>
<a name="ln2100">static int check_readonly(int *forceit, buf_T *buf)</a>
<a name="ln2101">{</a>
<a name="ln2102">  /* Handle a file being readonly when the 'readonly' option is set or when</a>
<a name="ln2103">   * the file exists and permissions are read-only. */</a>
<a name="ln2104">  if (!*forceit &amp;&amp; (buf-&gt;b_p_ro</a>
<a name="ln2105">                    || (os_path_exists(buf-&gt;b_ffname)</a>
<a name="ln2106">                        &amp;&amp; !os_file_is_writable((char *)buf-&gt;b_ffname)))) {</a>
<a name="ln2107">    if ((p_confirm || cmdmod.confirm) &amp;&amp; buf-&gt;b_fname != NULL) {</a>
<a name="ln2108">      char_u buff[DIALOG_MSG_SIZE];</a>
<a name="ln2109"> </a>
<a name="ln2110">      if (buf-&gt;b_p_ro)</a>
<a name="ln2111">        dialog_msg(buff,</a>
<a name="ln2112">            _(</a>
<a name="ln2113">                &quot;'readonly' option is set for \&quot;%s\&quot;.\nDo you wish to write anyway?&quot;),</a>
<a name="ln2114">            buf-&gt;b_fname);</a>
<a name="ln2115">      else</a>
<a name="ln2116">        dialog_msg(buff,</a>
<a name="ln2117">            _(</a>
<a name="ln2118">                &quot;File permissions of \&quot;%s\&quot; are read-only.\nIt may still be possible to write it.\nDo you wish to try?&quot;),</a>
<a name="ln2119">            buf-&gt;b_fname);</a>
<a name="ln2120"> </a>
<a name="ln2121">      if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES) {</a>
<a name="ln2122">        /* Set forceit, to force the writing of a readonly file */</a>
<a name="ln2123">        *forceit = TRUE;</a>
<a name="ln2124">        return FALSE;</a>
<a name="ln2125">      } else</a>
<a name="ln2126">        return TRUE;</a>
<a name="ln2127">    } else if (buf-&gt;b_p_ro)</a>
<a name="ln2128">      EMSG(_(e_readonly));</a>
<a name="ln2129">    else</a>
<a name="ln2130">      EMSG2(_(&quot;E505: \&quot;%s\&quot; is read-only (add ! to override)&quot;),</a>
<a name="ln2131">          buf-&gt;b_fname);</a>
<a name="ln2132">    return TRUE;</a>
<a name="ln2133">  }</a>
<a name="ln2134"> </a>
<a name="ln2135">  return FALSE;</a>
<a name="ln2136">}</a>
<a name="ln2137"> </a>
<a name="ln2138">// Try to abandon the current file and edit a new or existing file.</a>
<a name="ln2139">// &quot;fnum&quot; is the number of the file, if zero use &quot;ffname_arg&quot;/&quot;sfname_arg&quot;.</a>
<a name="ln2140">// &quot;lnum&quot; is the line number for the cursor in the new file (if non-zero).</a>
<a name="ln2141">//</a>
<a name="ln2142">// Return:</a>
<a name="ln2143">// GETFILE_ERROR for &quot;normal&quot; error,</a>
<a name="ln2144">// GETFILE_NOT_WRITTEN for &quot;not written&quot; error,</a>
<a name="ln2145">// GETFILE_SAME_FILE for success</a>
<a name="ln2146">// GETFILE_OPEN_OTHER for successfully opening another file.</a>
<a name="ln2147">int getfile(int fnum, char_u *ffname_arg, char_u *sfname_arg, int setpm,</a>
<a name="ln2148">            linenr_T lnum, int forceit)</a>
<a name="ln2149">{</a>
<a name="ln2150">  char_u *ffname = ffname_arg;</a>
<a name="ln2151">  char_u *sfname = sfname_arg;</a>
<a name="ln2152">  int other;</a>
<a name="ln2153">  int retval;</a>
<a name="ln2154">  char_u      *free_me = NULL;</a>
<a name="ln2155"> </a>
<a name="ln2156">  if (text_locked()) {</a>
<a name="ln2157">    return GETFILE_ERROR;</a>
<a name="ln2158">  }</a>
<a name="ln2159">  if (curbuf_locked()) {</a>
<a name="ln2160">    return GETFILE_ERROR;</a>
<a name="ln2161">  }</a>
<a name="ln2162"> </a>
<a name="ln2163">  if (fnum == 0) {</a>
<a name="ln2164">    /* make ffname full path, set sfname */</a>
<a name="ln2165">    fname_expand(curbuf, &amp;ffname, &amp;sfname);</a>
<a name="ln2166">    other = otherfile(ffname);</a>
<a name="ln2167">    free_me = ffname;                   /* has been allocated, free() later */</a>
<a name="ln2168">  } else</a>
<a name="ln2169">    other = (fnum != curbuf-&gt;b_fnum);</a>
<a name="ln2170"> </a>
<a name="ln2171">  if (other) {</a>
<a name="ln2172">    no_wait_return++;               // don't wait for autowrite message</a>
<a name="ln2173">  }</a>
<a name="ln2174">  if (other &amp;&amp; !forceit &amp;&amp; curbuf-&gt;b_nwindows == 1 &amp;&amp; !buf_hide(curbuf)</a>
<a name="ln2175">      &amp;&amp; curbufIsChanged() &amp;&amp; autowrite(curbuf, forceit) == FAIL) {</a>
<a name="ln2176">    if (p_confirm &amp;&amp; p_write) {</a>
<a name="ln2177">      dialog_changed(curbuf, false);</a>
<a name="ln2178">    }</a>
<a name="ln2179">    if (curbufIsChanged()) {</a>
<a name="ln2180">      no_wait_return--;</a>
<a name="ln2181">      no_write_message();</a>
<a name="ln2182">      retval = GETFILE_NOT_WRITTEN;     // File has been changed.</a>
<a name="ln2183">      goto theend;</a>
<a name="ln2184">    }</a>
<a name="ln2185">  }</a>
<a name="ln2186">  if (other)</a>
<a name="ln2187">    --no_wait_return;</a>
<a name="ln2188">  if (setpm)</a>
<a name="ln2189">    setpcmark();</a>
<a name="ln2190">  if (!other) {</a>
<a name="ln2191">    if (lnum != 0) {</a>
<a name="ln2192">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln2193">    }</a>
<a name="ln2194">    check_cursor_lnum();</a>
<a name="ln2195">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln2196">    retval = GETFILE_SAME_FILE;     // it's in the same file</a>
<a name="ln2197">  } else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,</a>
<a name="ln2198">                     (buf_hide(curbuf) ? ECMD_HIDE : 0)</a>
<a name="ln2199">                     + (forceit ? ECMD_FORCEIT : 0), curwin) == OK) {</a>
<a name="ln2200">    retval = GETFILE_OPEN_OTHER;    // opened another file</a>
<a name="ln2201">  } else {</a>
<a name="ln2202">    retval = GETFILE_ERROR;         // error encountered</a>
<a name="ln2203">  }</a>
<a name="ln2204"> </a>
<a name="ln2205">theend:</a>
<a name="ln2206">  xfree(free_me);</a>
<a name="ln2207">  return retval;</a>
<a name="ln2208">}</a>
<a name="ln2209"> </a>
<a name="ln2210">/// start editing a new file</a>
<a name="ln2211">///</a>
<a name="ln2212">/// @param fnum     file number; if zero use ffname/sfname</a>
<a name="ln2213">/// @param ffname   the file name</a>
<a name="ln2214">///                 - full path if sfname used,</a>
<a name="ln2215">///                 - any file name if sfname is NULL</a>
<a name="ln2216">///                 - empty string to re-edit with the same file name (but may</a>
<a name="ln2217">///                   be in a different directory)</a>
<a name="ln2218">///                 - NULL to start an empty buffer</a>
<a name="ln2219">/// @param sfname   the short file name (or NULL)</a>
<a name="ln2220">/// @param eap      contains the command to be executed after loading the file</a>
<a name="ln2221">///                 and forced 'ff' and 'fenc'</a>
<a name="ln2222">/// @param newlnum  if &gt; 0: put cursor on this line number (if possible)</a>
<a name="ln2223">///                 ECMD_LASTL: use last position in loaded file</a>
<a name="ln2224">///                 ECMD_LAST: use last position in all files</a>
<a name="ln2225">///                 ECMD_ONE: use first line</a>
<a name="ln2226">/// @param flags    ECMD_HIDE: if TRUE don't free the current buffer</a>
<a name="ln2227">///                 ECMD_SET_HELP: set b_help flag of (new) buffer before</a>
<a name="ln2228">///                 opening file</a>
<a name="ln2229">///                 ECMD_OLDBUF: use existing buffer if it exists</a>
<a name="ln2230">///                 ECMD_FORCEIT: ! used for Ex command</a>
<a name="ln2231">///                 ECMD_ADDBUF: don't edit, just add to buffer list</a>
<a name="ln2232">///                 ECMD_ALTBUF: like ECMD_ADDBUF and also set the alternate</a>
<a name="ln2233">///                 file</a>
<a name="ln2234">/// @param oldwin   Should be &quot;curwin&quot; when editing a new buffer in the current</a>
<a name="ln2235">///                 window, NULL when splitting the window first.  When not NULL</a>
<a name="ln2236">///                 info of the previous buffer for &quot;oldwin&quot; is stored.</a>
<a name="ln2237">///</a>
<a name="ln2238">/// @return FAIL for failure, OK otherwise</a>
<a name="ln2239">int do_ecmd(</a>
<a name="ln2240">    int fnum,</a>
<a name="ln2241">    char_u *ffname,</a>
<a name="ln2242">    char_u *sfname,</a>
<a name="ln2243">    exarg_T *eap,                       /* can be NULL! */</a>
<a name="ln2244">    linenr_T newlnum,</a>
<a name="ln2245">    int flags,</a>
<a name="ln2246">    win_T *oldwin</a>
<a name="ln2247">)</a>
<a name="ln2248">{</a>
<a name="ln2249">  int other_file;                       /* TRUE if editing another file */</a>
<a name="ln2250">  int oldbuf;                           /* TRUE if using existing buffer */</a>
<a name="ln2251">  int auto_buf = FALSE;                 /* TRUE if autocommands brought us</a>
<a name="ln2252">                                           into the buffer unexpectedly */</a>
<a name="ln2253">  char_u      *new_name = NULL;</a>
<a name="ln2254">  int did_set_swapcommand = FALSE;</a>
<a name="ln2255">  buf_T       *buf;</a>
<a name="ln2256">  bufref_T     bufref;</a>
<a name="ln2257">  bufref_T     old_curbuf;</a>
<a name="ln2258">  char_u      *free_fname = NULL;</a>
<a name="ln2259">  int retval = FAIL;</a>
<a name="ln2260">  long n;</a>
<a name="ln2261">  pos_T orig_pos;</a>
<a name="ln2262">  linenr_T topline = 0;</a>
<a name="ln2263">  int newcol = -1;</a>
<a name="ln2264">  int solcol = -1;</a>
<a name="ln2265">  pos_T       *pos;</a>
<a name="ln2266">  char_u      *command = NULL;</a>
<a name="ln2267">  int did_get_winopts = FALSE;</a>
<a name="ln2268">  int readfile_flags = 0;</a>
<a name="ln2269">  bool did_inc_redrawing_disabled = false;</a>
<a name="ln2270">  long *so_ptr = curwin-&gt;w_p_so &gt;= 0 ? &amp;curwin-&gt;w_p_so : &amp;p_so;</a>
<a name="ln2271"> </a>
<a name="ln2272">  if (eap != NULL)</a>
<a name="ln2273">    command = eap-&gt;do_ecmd_cmd;</a>
<a name="ln2274"> </a>
<a name="ln2275">  set_bufref(&amp;old_curbuf, curbuf);</a>
<a name="ln2276"> </a>
<a name="ln2277">  if (fnum != 0) {</a>
<a name="ln2278">    if (fnum == curbuf-&gt;b_fnum)         /* file is already being edited */</a>
<a name="ln2279">      return OK;                        /* nothing to do */</a>
<a name="ln2280">    other_file = TRUE;</a>
<a name="ln2281">  } else {</a>
<a name="ln2282">    /* if no short name given, use ffname for short name */</a>
<a name="ln2283">    if (sfname == NULL)</a>
<a name="ln2284">      sfname = ffname;</a>
<a name="ln2285">#ifdef USE_FNAME_CASE</a>
<a name="ln2286">    if (sfname != NULL)</a>
<a name="ln2287">      path_fix_case(sfname);             // set correct case for sfname</a>
<a name="ln2288">#endif</a>
<a name="ln2289"> </a>
<a name="ln2290">    if ((flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF))</a>
<a name="ln2291">        &amp;&amp; (ffname == NULL || *ffname == NUL)) {</a>
<a name="ln2292">      goto theend;</a>
<a name="ln2293">    }</a>
<a name="ln2294"> </a>
<a name="ln2295">    if (ffname == NULL)</a>
<a name="ln2296">      other_file = TRUE;</a>
<a name="ln2297">    /* there is no file name */</a>
<a name="ln2298">    else if (*ffname == NUL &amp;&amp; curbuf-&gt;b_ffname == NULL)</a>
<a name="ln2299">      other_file = FALSE;</a>
<a name="ln2300">    else {</a>
<a name="ln2301">      if (*ffname == NUL) {                 /* re-edit with same file name */</a>
<a name="ln2302">        ffname = curbuf-&gt;b_ffname;</a>
<a name="ln2303">        sfname = curbuf-&gt;b_fname;</a>
<a name="ln2304">      }</a>
<a name="ln2305">      free_fname = (char_u *)fix_fname((char *)ffname);       /* may expand to full path name */</a>
<a name="ln2306">      if (free_fname != NULL)</a>
<a name="ln2307">        ffname = free_fname;</a>
<a name="ln2308">      other_file = otherfile(ffname);</a>
<a name="ln2309">    }</a>
<a name="ln2310">  }</a>
<a name="ln2311"> </a>
<a name="ln2312">  // Re-editing a terminal buffer: skip most buffer re-initialization.</a>
<a name="ln2313">  if (!other_file &amp;&amp; curbuf-&gt;terminal) {</a>
<a name="ln2314">    check_arg_idx(curwin);  // Needed when called from do_argfile().</a>
<a name="ln2315">    maketitle();            // Title may show the arg index, e.g. &quot;(2 of 5)&quot;.</a>
<a name="ln2316">    retval = OK;</a>
<a name="ln2317">    goto theend;</a>
<a name="ln2318">  }</a>
<a name="ln2319"> </a>
<a name="ln2320">  // If the file was changed we may not be allowed to abandon it:</a>
<a name="ln2321">  // - if we are going to re-edit the same file</a>
<a name="ln2322">  // - or if we are the only window on this file and if ECMD_HIDE is FALSE</a>
<a name="ln2323">  if (((!other_file &amp;&amp; !(flags &amp; ECMD_OLDBUF))</a>
<a name="ln2324">       || (curbuf-&gt;b_nwindows == 1</a>
<a name="ln2325">           &amp;&amp; !(flags &amp; (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))</a>
<a name="ln2326">      &amp;&amp; check_changed(curbuf, (p_awa ? CCGD_AW : 0)</a>
<a name="ln2327">                       | (other_file ? 0 : CCGD_MULTWIN)</a>
<a name="ln2328">                       | ((flags &amp; ECMD_FORCEIT) ? CCGD_FORCEIT : 0)</a>
<a name="ln2329">                       | (eap == NULL ? 0 : CCGD_EXCMD))) {</a>
<a name="ln2330">    if (fnum == 0 &amp;&amp; other_file &amp;&amp; ffname != NULL) {</a>
<a name="ln2331">      (void)setaltfname(ffname, sfname, newlnum &lt; 0 ? 0 : newlnum);</a>
<a name="ln2332">    }</a>
<a name="ln2333">    goto theend;</a>
<a name="ln2334">  }</a>
<a name="ln2335"> </a>
<a name="ln2336">  /*</a>
<a name="ln2337">   * End Visual mode before switching to another buffer, so the text can be</a>
<a name="ln2338">   * copied into the GUI selection buffer.</a>
<a name="ln2339">   */</a>
<a name="ln2340">  reset_VIsual();</a>
<a name="ln2341"> </a>
<a name="ln2342">  if ((command != NULL || newlnum &gt; (linenr_T)0)</a>
<a name="ln2343">      &amp;&amp; *get_vim_var_str(VV_SWAPCOMMAND) == NUL) {</a>
<a name="ln2344">    // Set v:swapcommand for the SwapExists autocommands.</a>
<a name="ln2345">    const size_t len = (command != NULL) ? STRLEN(command) + 3 : 30;</a>
<a name="ln2346">    char *const p = xmalloc(len);</a>
<a name="ln2347">    if (command != NULL) {</a>
<a name="ln2348">      vim_snprintf(p, len, &quot;:%s\r&quot;, command);</a>
<a name="ln2349">    } else {</a>
<a name="ln2350">      vim_snprintf(p, len, &quot;%&quot; PRId64 &quot;G&quot;, (int64_t)newlnum);</a>
<a name="ln2351">    }</a>
<a name="ln2352">    set_vim_var_string(VV_SWAPCOMMAND, p, -1);</a>
<a name="ln2353">    did_set_swapcommand = TRUE;</a>
<a name="ln2354">    xfree(p);</a>
<a name="ln2355">  }</a>
<a name="ln2356"> </a>
<a name="ln2357">  /*</a>
<a name="ln2358">   * If we are starting to edit another file, open a (new) buffer.</a>
<a name="ln2359">   * Otherwise we re-use the current buffer.</a>
<a name="ln2360">   */</a>
<a name="ln2361">  if (other_file) {</a>
<a name="ln2362">    if (!(flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF))) {</a>
<a name="ln2363">      if (!cmdmod.keepalt) {</a>
<a name="ln2364">        curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln2365">      }</a>
<a name="ln2366">      if (oldwin != NULL) {</a>
<a name="ln2367">        buflist_altfpos(oldwin);</a>
<a name="ln2368">      }</a>
<a name="ln2369">    }</a>
<a name="ln2370"> </a>
<a name="ln2371">    if (fnum) {</a>
<a name="ln2372">      buf = buflist_findnr(fnum);</a>
<a name="ln2373">    } else {</a>
<a name="ln2374">      if (flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF)) {</a>
<a name="ln2375">        // Default the line number to zero to avoid that a wininfo item</a>
<a name="ln2376">        // is added for the current window.</a>
<a name="ln2377">        linenr_T tlnum = 0;</a>
<a name="ln2378"> </a>
<a name="ln2379">        if (command != NULL) {</a>
<a name="ln2380">          tlnum = atol((char *)command);</a>
<a name="ln2381">          if (tlnum &lt;= 0)</a>
<a name="ln2382">            tlnum = 1L;</a>
<a name="ln2383">        }</a>
<a name="ln2384">        // Add BLN_NOCURWIN to avoid a new wininfo items are associated</a>
<a name="ln2385">        // with the current window.</a>
<a name="ln2386">        const buf_T *const newbuf</a>
<a name="ln2387">            = buflist_new(ffname, sfname, tlnum, BLN_LISTED | BLN_NOCURWIN);</a>
<a name="ln2388">        if (newbuf != NULL &amp;&amp; (flags &amp; ECMD_ALTBUF)) {</a>
<a name="ln2389">          curwin-&gt;w_alt_fnum = newbuf-&gt;b_fnum;</a>
<a name="ln2390">        }</a>
<a name="ln2391">        goto theend;</a>
<a name="ln2392">      }</a>
<a name="ln2393">      buf = buflist_new(ffname, sfname, 0L,</a>
<a name="ln2394">                        BLN_CURBUF | (flags &amp; ECMD_SET_HELP ? 0 : BLN_LISTED));</a>
<a name="ln2395">      // Autocmds may change curwin and curbuf.</a>
<a name="ln2396">      if (oldwin != NULL) {</a>
<a name="ln2397">        oldwin = curwin;</a>
<a name="ln2398">      }</a>
<a name="ln2399">      set_bufref(&amp;old_curbuf, curbuf);</a>
<a name="ln2400">    }</a>
<a name="ln2401">    if (buf == NULL)</a>
<a name="ln2402">      goto theend;</a>
<a name="ln2403">    if (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2404">      // No memfile yet.</a>
<a name="ln2405">      oldbuf = false;</a>
<a name="ln2406">    } else {</a>
<a name="ln2407">      // Existing memfile.</a>
<a name="ln2408">      oldbuf = true;</a>
<a name="ln2409">      set_bufref(&amp;bufref, buf);</a>
<a name="ln2410">      (void)buf_check_timestamp(buf);</a>
<a name="ln2411">      // Check if autocommands made buffer invalid or changed the current</a>
<a name="ln2412">      // buffer.</a>
<a name="ln2413">      if (!bufref_valid(&amp;bufref) || curbuf != old_curbuf.br_buf) {</a>
<a name="ln2414">        goto theend;</a>
<a name="ln2415">      }</a>
<a name="ln2416">      if (aborting()) {</a>
<a name="ln2417">        // Autocmds may abort script processing.</a>
<a name="ln2418">        goto theend;</a>
<a name="ln2419">      }</a>
<a name="ln2420">    }</a>
<a name="ln2421"> </a>
<a name="ln2422">    /* May jump to last used line number for a loaded buffer or when asked</a>
<a name="ln2423">     * for explicitly */</a>
<a name="ln2424">    if ((oldbuf &amp;&amp; newlnum == ECMD_LASTL) || newlnum == ECMD_LAST) {</a>
<a name="ln2425">      pos = buflist_findfpos(buf);</a>
<a name="ln2426">      newlnum = pos-&gt;lnum;</a>
<a name="ln2427">      solcol = pos-&gt;col;</a>
<a name="ln2428">    }</a>
<a name="ln2429"> </a>
<a name="ln2430">    /*</a>
<a name="ln2431">     * Make the (new) buffer the one used by the current window.</a>
<a name="ln2432">     * If the old buffer becomes unused, free it if ECMD_HIDE is FALSE.</a>
<a name="ln2433">     * If the current buffer was empty and has no file name, curbuf</a>
<a name="ln2434">     * is returned by buflist_new(), nothing to do here.</a>
<a name="ln2435">     */</a>
<a name="ln2436">    if (buf != curbuf) {</a>
<a name="ln2437">      const int save_cmdwin_type = cmdwin_type;</a>
<a name="ln2438"> </a>
<a name="ln2439">      // BufLeave applies to the old buffer.</a>
<a name="ln2440">      cmdwin_type = 0;</a>
<a name="ln2441"> </a>
<a name="ln2442">      // Be careful: The autocommands may delete any buffer and change</a>
<a name="ln2443">      // the current buffer.</a>
<a name="ln2444">      // - If the buffer we are going to edit is deleted, give up.</a>
<a name="ln2445">      // - If the current buffer is deleted, prefer to load the new</a>
<a name="ln2446">      //   buffer when loading a buffer is required.  This avoids</a>
<a name="ln2447">      //   loading another buffer which then must be closed again.</a>
<a name="ln2448">      // - If we ended up in the new buffer already, need to skip a few</a>
<a name="ln2449">      //         things, set auto_buf.</a>
<a name="ln2450">      if (buf-&gt;b_fname != NULL) {</a>
<a name="ln2451">        new_name = vim_strsave(buf-&gt;b_fname);</a>
<a name="ln2452">      }</a>
<a name="ln2453">      set_bufref(&amp;au_new_curbuf, buf);</a>
<a name="ln2454">      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln2455">      cmdwin_type = save_cmdwin_type;</a>
<a name="ln2456">      if (!bufref_valid(&amp;au_new_curbuf)) {</a>
<a name="ln2457">        // New buffer has been deleted.</a>
<a name="ln2458">        delbuf_msg(new_name);  // Frees new_name.</a>
<a name="ln2459">        goto theend;</a>
<a name="ln2460">      }</a>
<a name="ln2461">      if (aborting()) {             /* autocmds may abort script processing */</a>
<a name="ln2462">        xfree(new_name);</a>
<a name="ln2463">        goto theend;</a>
<a name="ln2464">      }</a>
<a name="ln2465">      if (buf == curbuf) {  // already in new buffer</a>
<a name="ln2466">        auto_buf = true;</a>
<a name="ln2467">      } else {</a>
<a name="ln2468">        win_T *the_curwin = curwin;</a>
<a name="ln2469">        buf_T *was_curbuf = curbuf;</a>
<a name="ln2470"> </a>
<a name="ln2471">        // Set w_closing to avoid that autocommands close the window.</a>
<a name="ln2472">        // Set b_locked for the same reason.</a>
<a name="ln2473">        the_curwin-&gt;w_closing = true;</a>
<a name="ln2474">        buf-&gt;b_locked++;</a>
<a name="ln2475"> </a>
<a name="ln2476">        if (curbuf == old_curbuf.br_buf) {</a>
<a name="ln2477">          buf_copy_options(buf, BCO_ENTER);</a>
<a name="ln2478">        }</a>
<a name="ln2479"> </a>
<a name="ln2480">        // Close the link to the current buffer. This will set</a>
<a name="ln2481">        // oldwin-&gt;w_buffer to NULL.</a>
<a name="ln2482">        u_sync(false);</a>
<a name="ln2483">        const bool did_decrement = close_buffer(</a>
<a name="ln2484">            oldwin, curbuf,</a>
<a name="ln2485">            (flags &amp; ECMD_HIDE) || curbuf-&gt;terminal ? 0 : DOBUF_UNLOAD,</a>
<a name="ln2486">            false);</a>
<a name="ln2487"> </a>
<a name="ln2488">        // Autocommands may have closed the window.</a>
<a name="ln2489">        if (win_valid(the_curwin)) {</a>
<a name="ln2490">          the_curwin-&gt;w_closing = false;</a>
<a name="ln2491">        }</a>
<a name="ln2492">        buf-&gt;b_locked--;</a>
<a name="ln2493"> </a>
<a name="ln2494">        // autocmds may abort script processing</a>
<a name="ln2495">        if (aborting() &amp;&amp; curwin-&gt;w_buffer != NULL) {</a>
<a name="ln2496">          xfree(new_name);</a>
<a name="ln2497">          goto theend;</a>
<a name="ln2498">        }</a>
<a name="ln2499">        // Be careful again, like above.</a>
<a name="ln2500">        if (!bufref_valid(&amp;au_new_curbuf)) {</a>
<a name="ln2501">          // New buffer has been deleted.</a>
<a name="ln2502">          delbuf_msg(new_name);  // Frees new_name.</a>
<a name="ln2503">          goto theend;</a>
<a name="ln2504">        }</a>
<a name="ln2505">        if (buf == curbuf) {  // already in new buffer</a>
<a name="ln2506">          // close_buffer() has decremented the window count,</a>
<a name="ln2507">          // increment it again here and restore w_buffer.</a>
<a name="ln2508">          if (did_decrement &amp;&amp; buf_valid(was_curbuf)) {</a>
<a name="ln2509">            was_curbuf-&gt;b_nwindows++;</a>
<a name="ln2510">          }</a>
<a name="ln2511">          if (win_valid_any_tab(oldwin) &amp;&amp; oldwin-&gt;w_buffer == NULL) {</a>
<a name="ln2512">            oldwin-&gt;w_buffer = was_curbuf;</a>
<a name="ln2513">          }</a>
<a name="ln2514">          auto_buf = true;</a>
<a name="ln2515">        } else {</a>
<a name="ln2516">          // &lt;VN&gt; We could instead free the synblock</a>
<a name="ln2517">          // and re-attach to buffer, perhaps.</a>
<a name="ln2518">          if (curwin-&gt;w_buffer == NULL</a>
<a name="ln2519">              || curwin-&gt;w_s == &amp;(curwin-&gt;w_buffer-&gt;b_s)) {</a>
<a name="ln2520">            curwin-&gt;w_s = &amp;(buf-&gt;b_s);</a>
<a name="ln2521">          }</a>
<a name="ln2522"> </a>
<a name="ln2523">          curwin-&gt;w_buffer = buf;</a>
<a name="ln2524">          curbuf = buf;</a>
<a name="ln2525">          ++curbuf-&gt;b_nwindows;</a>
<a name="ln2526"> </a>
<a name="ln2527">          /* Set 'fileformat', 'binary' and 'fenc' when forced. */</a>
<a name="ln2528">          if (!oldbuf &amp;&amp; eap != NULL) {</a>
<a name="ln2529">            set_file_options(TRUE, eap);</a>
<a name="ln2530">            set_forced_fenc(eap);</a>
<a name="ln2531">          }</a>
<a name="ln2532">        }</a>
<a name="ln2533"> </a>
<a name="ln2534">        /* May get the window options from the last time this buffer</a>
<a name="ln2535">         * was in this window (or another window).  If not used</a>
<a name="ln2536">         * before, reset the local window options to the global</a>
<a name="ln2537">         * values.  Also restores old folding stuff. */</a>
<a name="ln2538">        get_winopts(curbuf);</a>
<a name="ln2539">        did_get_winopts = TRUE;</a>
<a name="ln2540"> </a>
<a name="ln2541">      }</a>
<a name="ln2542">      xfree(new_name);</a>
<a name="ln2543">      au_new_curbuf.br_buf = NULL;</a>
<a name="ln2544">      au_new_curbuf.br_buf_free_count = 0;</a>
<a name="ln2545">    }</a>
<a name="ln2546"> </a>
<a name="ln2547">    curwin-&gt;w_pcmark.lnum = 1;</a>
<a name="ln2548">    curwin-&gt;w_pcmark.col = 0;</a>
<a name="ln2549">  } else {  // !other_file</a>
<a name="ln2550">    if ((flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL) {</a>
<a name="ln2551">      goto theend;</a>
<a name="ln2552">    }</a>
<a name="ln2553">    oldbuf = (flags &amp; ECMD_OLDBUF);</a>
<a name="ln2554">  }</a>
<a name="ln2555"> </a>
<a name="ln2556">  // Don't redraw until the cursor is in the right line, otherwise</a>
<a name="ln2557">  // autocommands may cause ml_get errors.</a>
<a name="ln2558">  RedrawingDisabled++;</a>
<a name="ln2559">  did_inc_redrawing_disabled = true;</a>
<a name="ln2560"> </a>
<a name="ln2561">  buf = curbuf;</a>
<a name="ln2562">  if ((flags &amp; ECMD_SET_HELP) || keep_help_flag) {</a>
<a name="ln2563">    prepare_help_buffer();</a>
<a name="ln2564">  } else if (!curbuf-&gt;b_help) {</a>
<a name="ln2565">    // Don't make a buffer listed if it's a help buffer.  Useful when using</a>
<a name="ln2566">    // CTRL-O to go back to a help file.</a>
<a name="ln2567">    set_buflisted(TRUE);</a>
<a name="ln2568">  }</a>
<a name="ln2569"> </a>
<a name="ln2570">  /* If autocommands change buffers under our fingers, forget about</a>
<a name="ln2571">   * editing the file. */</a>
<a name="ln2572">  if (buf != curbuf)</a>
<a name="ln2573">    goto theend;</a>
<a name="ln2574">  if (aborting())           /* autocmds may abort script processing */</a>
<a name="ln2575">    goto theend;</a>
<a name="ln2576"> </a>
<a name="ln2577">  /* Since we are starting to edit a file, consider the filetype to be</a>
<a name="ln2578">   * unset.  Helps for when an autocommand changes files and expects syntax</a>
<a name="ln2579">   * highlighting to work in the other file. */</a>
<a name="ln2580">  did_filetype = FALSE;</a>
<a name="ln2581"> </a>
<a name="ln2582">  /*</a>
<a name="ln2583">   * other_file	oldbuf</a>
<a name="ln2584">   *  FALSE	FALSE	    re-edit same file, buffer is re-used</a>
<a name="ln2585">   *  FALSE	TRUE	    re-edit same file, nothing changes</a>
<a name="ln2586">   *  TRUE	FALSE	    start editing new file, new buffer</a>
<a name="ln2587">   *  TRUE	TRUE	    start editing in existing buffer (nothing to do)</a>
<a name="ln2588">   */</a>
<a name="ln2589">  if (!other_file &amp;&amp; !oldbuf) {         /* re-use the buffer */</a>
<a name="ln2590">    set_last_cursor(curwin);            /* may set b_last_cursor */</a>
<a name="ln2591">    if (newlnum == ECMD_LAST || newlnum == ECMD_LASTL) {</a>
<a name="ln2592">      newlnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2593">      solcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2594">    }</a>
<a name="ln2595">    buf = curbuf;</a>
<a name="ln2596">    if (buf-&gt;b_fname != NULL) {</a>
<a name="ln2597">      new_name = vim_strsave(buf-&gt;b_fname);</a>
<a name="ln2598">    } else {</a>
<a name="ln2599">      new_name = NULL;</a>
<a name="ln2600">    }</a>
<a name="ln2601">    set_bufref(&amp;bufref, buf);</a>
<a name="ln2602"> </a>
<a name="ln2603">    // If the buffer was used before, store the current contents so that</a>
<a name="ln2604">    // the reload can be undone.  Do not do this if the (empty) buffer is</a>
<a name="ln2605">    // being re-used for another file.</a>
<a name="ln2606">    if (!(curbuf-&gt;b_flags &amp; BF_NEVERLOADED)</a>
<a name="ln2607">        &amp;&amp; (p_ur &lt; 0 || curbuf-&gt;b_ml.ml_line_count &lt;= p_ur)) {</a>
<a name="ln2608">      // Sync first so that this is a separate undo-able action.</a>
<a name="ln2609">      u_sync(false);</a>
<a name="ln2610">      if (u_savecommon(0, curbuf-&gt;b_ml.ml_line_count + 1, 0, true)</a>
<a name="ln2611">          == FAIL) {</a>
<a name="ln2612">        xfree(new_name);</a>
<a name="ln2613">        goto theend;</a>
<a name="ln2614">      }</a>
<a name="ln2615">      u_unchanged(curbuf);</a>
<a name="ln2616">      buf_updates_unload(curbuf, false);</a>
<a name="ln2617">      buf_freeall(curbuf, BFA_KEEP_UNDO);</a>
<a name="ln2618"> </a>
<a name="ln2619">      // Tell readfile() not to clear or reload undo info.</a>
<a name="ln2620">      readfile_flags = READ_KEEP_UNDO;</a>
<a name="ln2621">    } else {</a>
<a name="ln2622">      buf_updates_unload(curbuf, false);</a>
<a name="ln2623">      buf_freeall(curbuf, 0);  // Free all things for buffer.</a>
<a name="ln2624">    }</a>
<a name="ln2625">    // If autocommands deleted the buffer we were going to re-edit, give</a>
<a name="ln2626">    // up and jump to the end.</a>
<a name="ln2627">    if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2628">      delbuf_msg(new_name);  // Frees new_name.</a>
<a name="ln2629">      goto theend;</a>
<a name="ln2630">    }</a>
<a name="ln2631">    xfree(new_name);</a>
<a name="ln2632"> </a>
<a name="ln2633">    /* If autocommands change buffers under our fingers, forget about</a>
<a name="ln2634">     * re-editing the file.  Should do the buf_clear_file(), but perhaps</a>
<a name="ln2635">     * the autocommands changed the buffer... */</a>
<a name="ln2636">    if (buf != curbuf)</a>
<a name="ln2637">      goto theend;</a>
<a name="ln2638">    if (aborting())         /* autocmds may abort script processing */</a>
<a name="ln2639">      goto theend;</a>
<a name="ln2640">    buf_clear_file(curbuf);</a>
<a name="ln2641">    curbuf-&gt;b_op_start.lnum = 0;        /* clear '[ and '] marks */</a>
<a name="ln2642">    curbuf-&gt;b_op_end.lnum = 0;</a>
<a name="ln2643">  }</a>
<a name="ln2644"> </a>
<a name="ln2645">  /*</a>
<a name="ln2646">   * If we get here we are sure to start editing</a>
<a name="ln2647">   */</a>
<a name="ln2648"> </a>
<a name="ln2649">  /* Assume success now */</a>
<a name="ln2650">  retval = OK;</a>
<a name="ln2651"> </a>
<a name="ln2652">  /*</a>
<a name="ln2653">   * Check if we are editing the w_arg_idx file in the argument list.</a>
<a name="ln2654">   */</a>
<a name="ln2655">  check_arg_idx(curwin);</a>
<a name="ln2656"> </a>
<a name="ln2657">  if (!auto_buf) {</a>
<a name="ln2658">    /*</a>
<a name="ln2659">     * Set cursor and init window before reading the file and executing</a>
<a name="ln2660">     * autocommands.  This allows for the autocommands to position the</a>
<a name="ln2661">     * cursor.</a>
<a name="ln2662">     */</a>
<a name="ln2663">    curwin_init();</a>
<a name="ln2664"> </a>
<a name="ln2665">    /* It's possible that all lines in the buffer changed.  Need to update</a>
<a name="ln2666">     * automatic folding for all windows where it's used. */</a>
<a name="ln2667">    FOR_ALL_TAB_WINDOWS(tp, win) {</a>
<a name="ln2668">      if (win-&gt;w_buffer == curbuf) {</a>
<a name="ln2669">        foldUpdateAll(win);</a>
<a name="ln2670">      }</a>
<a name="ln2671">    }</a>
<a name="ln2672"> </a>
<a name="ln2673">    /* Change directories when the 'acd' option is set. */</a>
<a name="ln2674">    do_autochdir();</a>
<a name="ln2675"> </a>
<a name="ln2676">    /*</a>
<a name="ln2677">     * Careful: open_buffer() and apply_autocmds() may change the current</a>
<a name="ln2678">     * buffer and window.</a>
<a name="ln2679">     */</a>
<a name="ln2680">    orig_pos = curwin-&gt;w_cursor;</a>
<a name="ln2681">    topline = curwin-&gt;w_topline;</a>
<a name="ln2682">    if (!oldbuf) {                          /* need to read the file */</a>
<a name="ln2683">      swap_exists_action = SEA_DIALOG;</a>
<a name="ln2684">      curbuf-&gt;b_flags |= BF_CHECK_RO;       /* set/reset 'ro' flag */</a>
<a name="ln2685"> </a>
<a name="ln2686">      /*</a>
<a name="ln2687">       * Open the buffer and read the file.</a>
<a name="ln2688">       */</a>
<a name="ln2689">      if (should_abort(open_buffer(FALSE, eap, readfile_flags)))</a>
<a name="ln2690">        retval = FAIL;</a>
<a name="ln2691"> </a>
<a name="ln2692">      if (swap_exists_action == SEA_QUIT)</a>
<a name="ln2693">        retval = FAIL;</a>
<a name="ln2694">      handle_swap_exists(&amp;old_curbuf);</a>
<a name="ln2695">    } else {</a>
<a name="ln2696">      /* Read the modelines, but only to set window-local options.  Any</a>
<a name="ln2697">       * buffer-local options have already been set and may have been</a>
<a name="ln2698">       * changed by the user. */</a>
<a name="ln2699">      do_modelines(OPT_WINONLY);</a>
<a name="ln2700"> </a>
<a name="ln2701">      apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,</a>
<a name="ln2702">          &amp;retval);</a>
<a name="ln2703">      apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,</a>
<a name="ln2704">          &amp;retval);</a>
<a name="ln2705">    }</a>
<a name="ln2706">    check_arg_idx(curwin);</a>
<a name="ln2707"> </a>
<a name="ln2708">    // If autocommands change the cursor position or topline, we should</a>
<a name="ln2709">    // keep it.  Also when it moves within a line. But not when it moves</a>
<a name="ln2710">    // to the first non-blank.</a>
<a name="ln2711">    if (!equalpos(curwin-&gt;w_cursor, orig_pos)) {</a>
<a name="ln2712">      const char_u *text = get_cursor_line_ptr();</a>
<a name="ln2713"> </a>
<a name="ln2714">      if (curwin-&gt;w_cursor.lnum != orig_pos.lnum</a>
<a name="ln2715">          || curwin-&gt;w_cursor.col != (int)(skipwhite(text) - text)) {</a>
<a name="ln2716">        newlnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2717">        newcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2718">      }</a>
<a name="ln2719">    }</a>
<a name="ln2720">    if (curwin-&gt;w_topline == topline)</a>
<a name="ln2721">      topline = 0;</a>
<a name="ln2722"> </a>
<a name="ln2723">    /* Even when cursor didn't move we need to recompute topline. */</a>
<a name="ln2724">    changed_line_abv_curs();</a>
<a name="ln2725"> </a>
<a name="ln2726">    maketitle();</a>
<a name="ln2727">  }</a>
<a name="ln2728"> </a>
<a name="ln2729">  /* Tell the diff stuff that this buffer is new and/or needs updating.</a>
<a name="ln2730">   * Also needed when re-editing the same buffer, because unloading will</a>
<a name="ln2731">   * have removed it as a diff buffer. */</a>
<a name="ln2732">  if (curwin-&gt;w_p_diff) {</a>
<a name="ln2733">    diff_buf_add(curbuf);</a>
<a name="ln2734">    diff_invalidate(curbuf);</a>
<a name="ln2735">  }</a>
<a name="ln2736"> </a>
<a name="ln2737">  /* If the window options were changed may need to set the spell language.</a>
<a name="ln2738">   * Can only do this after the buffer has been properly setup. */</a>
<a name="ln2739">  if (did_get_winopts &amp;&amp; curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL)</a>
<a name="ln2740">    (void)did_set_spelllang(curwin);</a>
<a name="ln2741"> </a>
<a name="ln2742">  if (command == NULL) {</a>
<a name="ln2743">    if (newcol &gt;= 0) {          /* position set by autocommands */</a>
<a name="ln2744">      curwin-&gt;w_cursor.lnum = newlnum;</a>
<a name="ln2745">      curwin-&gt;w_cursor.col = newcol;</a>
<a name="ln2746">      check_cursor();</a>
<a name="ln2747">    } else if (newlnum &gt; 0) { /* line number from caller or old position */</a>
<a name="ln2748">      curwin-&gt;w_cursor.lnum = newlnum;</a>
<a name="ln2749">      check_cursor_lnum();</a>
<a name="ln2750">      if (solcol &gt;= 0 &amp;&amp; !p_sol) {</a>
<a name="ln2751">        /* 'sol' is off: Use last known column. */</a>
<a name="ln2752">        curwin-&gt;w_cursor.col = solcol;</a>
<a name="ln2753">        check_cursor_col();</a>
<a name="ln2754">        curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2755">        curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln2756">      } else</a>
<a name="ln2757">        beginline(BL_SOL | BL_FIX);</a>
<a name="ln2758">    } else {                  /* no line number, go to last line in Ex mode */</a>
<a name="ln2759">      if (exmode_active)</a>
<a name="ln2760">        curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2761">      beginline(BL_WHITE | BL_FIX);</a>
<a name="ln2762">    }</a>
<a name="ln2763">  }</a>
<a name="ln2764"> </a>
<a name="ln2765">  /* Check if cursors in other windows on the same buffer are still valid */</a>
<a name="ln2766">  check_lnums(FALSE);</a>
<a name="ln2767"> </a>
<a name="ln2768">  /*</a>
<a name="ln2769">   * Did not read the file, need to show some info about the file.</a>
<a name="ln2770">   * Do this after setting the cursor.</a>
<a name="ln2771">   */</a>
<a name="ln2772">  if (oldbuf</a>
<a name="ln2773">      &amp;&amp; !auto_buf</a>
<a name="ln2774">      ) {</a>
<a name="ln2775">    int msg_scroll_save = msg_scroll;</a>
<a name="ln2776"> </a>
<a name="ln2777">    /* Obey the 'O' flag in 'cpoptions': overwrite any previous file</a>
<a name="ln2778">     * message. */</a>
<a name="ln2779">    if (shortmess(SHM_OVERALL) &amp;&amp; !exiting &amp;&amp; p_verbose == 0)</a>
<a name="ln2780">      msg_scroll = FALSE;</a>
<a name="ln2781">    if (!msg_scroll)            /* wait a bit when overwriting an error msg */</a>
<a name="ln2782">      check_for_delay(FALSE);</a>
<a name="ln2783">    msg_start();</a>
<a name="ln2784">    msg_scroll = msg_scroll_save;</a>
<a name="ln2785">    msg_scrolled_ign = TRUE;</a>
<a name="ln2786"> </a>
<a name="ln2787">    if (!shortmess(SHM_FILEINFO)) {</a>
<a name="ln2788">      fileinfo(false, true, false);</a>
<a name="ln2789">    }</a>
<a name="ln2790"> </a>
<a name="ln2791">    msg_scrolled_ign = FALSE;</a>
<a name="ln2792">  }</a>
<a name="ln2793"> </a>
<a name="ln2794">  curbuf-&gt;b_last_used = time(NULL);</a>
<a name="ln2795"> </a>
<a name="ln2796">  if (command != NULL)</a>
<a name="ln2797">    do_cmdline(command, NULL, NULL, DOCMD_VERBOSE);</a>
<a name="ln2798"> </a>
<a name="ln2799">  if (curbuf-&gt;b_kmap_state &amp; KEYMAP_INIT)</a>
<a name="ln2800">    (void)keymap_init();</a>
<a name="ln2801"> </a>
<a name="ln2802">  RedrawingDisabled--;</a>
<a name="ln2803">  did_inc_redrawing_disabled = false;</a>
<a name="ln2804">  if (!skip_redraw) {</a>
<a name="ln2805">    n = *so_ptr;</a>
<a name="ln2806">    if (topline == 0 &amp;&amp; command == NULL) {</a>
<a name="ln2807">      *so_ptr = 999;    // force cursor to be vertically centered in the window</a>
<a name="ln2808">    }</a>
<a name="ln2809">    update_topline(curwin);</a>
<a name="ln2810">    curwin-&gt;w_scbind_pos = curwin-&gt;w_topline;</a>
<a name="ln2811">    *so_ptr = n;</a>
<a name="ln2812">    redraw_curbuf_later(NOT_VALID);     // redraw this buffer later</a>
<a name="ln2813">  }</a>
<a name="ln2814"> </a>
<a name="ln2815">  if (p_im)</a>
<a name="ln2816">    need_start_insertmode = TRUE;</a>
<a name="ln2817"> </a>
<a name="ln2818">  /* Change directories when the 'acd' option is set. */</a>
<a name="ln2819">  do_autochdir();</a>
<a name="ln2820"> </a>
<a name="ln2821"> </a>
<a name="ln2822">theend:</a>
<a name="ln2823">  if (bufref_valid(&amp;old_curbuf) &amp;&amp; old_curbuf.br_buf-&gt;terminal != NULL) {</a>
<a name="ln2824">    terminal_check_size(old_curbuf.br_buf-&gt;terminal);</a>
<a name="ln2825">  }</a>
<a name="ln2826"> </a>
<a name="ln2827">  if (did_inc_redrawing_disabled) {</a>
<a name="ln2828">    RedrawingDisabled--;</a>
<a name="ln2829">  }</a>
<a name="ln2830">  if (did_set_swapcommand) {</a>
<a name="ln2831">    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);</a>
<a name="ln2832">  }</a>
<a name="ln2833">  xfree(free_fname);</a>
<a name="ln2834">  return retval;</a>
<a name="ln2835">}</a>
<a name="ln2836"> </a>
<a name="ln2837">static void delbuf_msg(char_u *name)</a>
<a name="ln2838">{</a>
<a name="ln2839">  EMSG2(_(&quot;E143: Autocommands unexpectedly deleted new buffer %s&quot;),</a>
<a name="ln2840">      name == NULL ? (char_u *)&quot;&quot; : name);</a>
<a name="ln2841">  xfree(name);</a>
<a name="ln2842">  au_new_curbuf.br_buf = NULL;</a>
<a name="ln2843">  au_new_curbuf.br_buf_free_count = 0;</a>
<a name="ln2844">}</a>
<a name="ln2845"> </a>
<a name="ln2846">static int append_indent = 0;       /* autoindent for first line */</a>
<a name="ln2847"> </a>
<a name="ln2848">/*</a>
<a name="ln2849"> * &quot;:insert&quot; and &quot;:append&quot;, also used by &quot;:change&quot;</a>
<a name="ln2850"> */</a>
<a name="ln2851">void ex_append(exarg_T *eap)</a>
<a name="ln2852">{</a>
<a name="ln2853">  char_u      *theline;</a>
<a name="ln2854">  bool did_undo = false;</a>
<a name="ln2855">  linenr_T lnum = eap-&gt;line2;</a>
<a name="ln2856">  int indent = 0;</a>
<a name="ln2857">  char_u      *p;</a>
<a name="ln2858">  int vcol;</a>
<a name="ln2859">  int empty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln2860"> </a>
<a name="ln2861">  /* the ! flag toggles autoindent */</a>
<a name="ln2862">  if (eap-&gt;forceit)</a>
<a name="ln2863">    curbuf-&gt;b_p_ai = !curbuf-&gt;b_p_ai;</a>
<a name="ln2864"> </a>
<a name="ln2865">  /* First autoindent comes from the line we start on */</a>
<a name="ln2866">  if (eap-&gt;cmdidx != CMD_change &amp;&amp; curbuf-&gt;b_p_ai &amp;&amp; lnum &gt; 0)</a>
<a name="ln2867">    append_indent = get_indent_lnum(lnum);</a>
<a name="ln2868"> </a>
<a name="ln2869">  if (eap-&gt;cmdidx != CMD_append)</a>
<a name="ln2870">    --lnum;</a>
<a name="ln2871"> </a>
<a name="ln2872">  // when the buffer is empty need to delete the dummy line</a>
<a name="ln2873">  if (empty &amp;&amp; lnum == 1)</a>
<a name="ln2874">    lnum = 0;</a>
<a name="ln2875"> </a>
<a name="ln2876">  State = INSERT;                   /* behave like in Insert mode */</a>
<a name="ln2877">  if (curbuf-&gt;b_p_iminsert == B_IMODE_LMAP)</a>
<a name="ln2878">    State |= LANGMAP;</a>
<a name="ln2879"> </a>
<a name="ln2880">  for (;; ) {</a>
<a name="ln2881">    msg_scroll = TRUE;</a>
<a name="ln2882">    need_wait_return = FALSE;</a>
<a name="ln2883">    if (curbuf-&gt;b_p_ai) {</a>
<a name="ln2884">      if (append_indent &gt;= 0) {</a>
<a name="ln2885">        indent = append_indent;</a>
<a name="ln2886">        append_indent = -1;</a>
<a name="ln2887">      } else if (lnum &gt; 0)</a>
<a name="ln2888">        indent = get_indent_lnum(lnum);</a>
<a name="ln2889">    }</a>
<a name="ln2890">    ex_keep_indent = FALSE;</a>
<a name="ln2891">    if (eap-&gt;getline == NULL) {</a>
<a name="ln2892">      /* No getline() function, use the lines that follow. This ends</a>
<a name="ln2893">       * when there is no more. */</a>
<a name="ln2894">      if (eap-&gt;nextcmd == NULL || *eap-&gt;nextcmd == NUL)</a>
<a name="ln2895">        break;</a>
<a name="ln2896">      p = vim_strchr(eap-&gt;nextcmd, NL);</a>
<a name="ln2897">      if (p == NULL)</a>
<a name="ln2898">        p = eap-&gt;nextcmd + STRLEN(eap-&gt;nextcmd);</a>
<a name="ln2899">      theline = vim_strnsave(eap-&gt;nextcmd, p - eap-&gt;nextcmd);</a>
<a name="ln2900">      if (*p != NUL) {</a>
<a name="ln2901">        p++;</a>
<a name="ln2902">      }</a>
<a name="ln2903">      eap-&gt;nextcmd = p;</a>
<a name="ln2904">    } else {</a>
<a name="ln2905">      // Set State to avoid the cursor shape to be set to INSERT mode</a>
<a name="ln2906">      // when getline() returns.</a>
<a name="ln2907">      int save_State = State;</a>
<a name="ln2908">      State = CMDLINE;</a>
<a name="ln2909">      theline = eap-&gt;getline(</a>
<a name="ln2910">          eap-&gt;cstack-&gt;cs_looplevel &gt; 0 ? -1 :</a>
<a name="ln2911">          NUL, eap-&gt;cookie, indent, true);</a>
<a name="ln2912">      State = save_State;</a>
<a name="ln2913">    }</a>
<a name="ln2914">    lines_left = Rows - 1;</a>
<a name="ln2915">    if (theline == NULL)</a>
<a name="ln2916">      break;</a>
<a name="ln2917"> </a>
<a name="ln2918">    /* Using ^ CTRL-D in getexmodeline() makes us repeat the indent. */</a>
<a name="ln2919">    if (ex_keep_indent)</a>
<a name="ln2920">      append_indent = indent;</a>
<a name="ln2921"> </a>
<a name="ln2922">    /* Look for the &quot;.&quot; after automatic indent. */</a>
<a name="ln2923">    vcol = 0;</a>
<a name="ln2924">    for (p = theline; indent &gt; vcol; ++p) {</a>
<a name="ln2925">      if (*p == ' ')</a>
<a name="ln2926">        ++vcol;</a>
<a name="ln2927">      else if (*p == TAB)</a>
<a name="ln2928">        vcol += 8 - vcol % 8;</a>
<a name="ln2929">      else</a>
<a name="ln2930">        break;</a>
<a name="ln2931">    }</a>
<a name="ln2932">    if ((p[0] == '.' &amp;&amp; p[1] == NUL)</a>
<a name="ln2933">        || (!did_undo &amp;&amp; u_save(lnum, lnum + 1 + (empty ? 1 : 0))</a>
<a name="ln2934">            == FAIL)) {</a>
<a name="ln2935">      xfree(theline);</a>
<a name="ln2936">      break;</a>
<a name="ln2937">    }</a>
<a name="ln2938"> </a>
<a name="ln2939">    /* don't use autoindent if nothing was typed. */</a>
<a name="ln2940">    if (p[0] == NUL)</a>
<a name="ln2941">      theline[0] = NUL;</a>
<a name="ln2942"> </a>
<a name="ln2943">    did_undo = true;</a>
<a name="ln2944">    ml_append(lnum, theline, (colnr_T)0, false);</a>
<a name="ln2945">    appended_lines_mark(lnum + (empty ? 1 : 0), 1L);</a>
<a name="ln2946"> </a>
<a name="ln2947">    xfree(theline);</a>
<a name="ln2948">    ++lnum;</a>
<a name="ln2949"> </a>
<a name="ln2950">    if (empty) {</a>
<a name="ln2951">      ml_delete(2L, false);</a>
<a name="ln2952">      empty = 0;</a>
<a name="ln2953">    }</a>
<a name="ln2954">  }</a>
<a name="ln2955">  State = NORMAL;</a>
<a name="ln2956"> </a>
<a name="ln2957">  if (eap-&gt;forceit)</a>
<a name="ln2958">    curbuf-&gt;b_p_ai = !curbuf-&gt;b_p_ai;</a>
<a name="ln2959"> </a>
<a name="ln2960">  /* &quot;start&quot; is set to eap-&gt;line2+1 unless that position is invalid (when</a>
<a name="ln2961">   * eap-&gt;line2 pointed to the end of the buffer and nothing was appended)</a>
<a name="ln2962">   * &quot;end&quot; is set to lnum when something has been appended, otherwise</a>
<a name="ln2963">   * it is the same than &quot;start&quot;  -- Acevedo */</a>
<a name="ln2964">  curbuf-&gt;b_op_start.lnum = (eap-&gt;line2 &lt; curbuf-&gt;b_ml.ml_line_count) ?</a>
<a name="ln2965">                            eap-&gt;line2 + 1 : curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2966">  if (eap-&gt;cmdidx != CMD_append)</a>
<a name="ln2967">    --curbuf-&gt;b_op_start.lnum;</a>
<a name="ln2968">  curbuf-&gt;b_op_end.lnum = (eap-&gt;line2 &lt; lnum)</a>
<a name="ln2969">                          ? lnum : curbuf-&gt;b_op_start.lnum;</a>
<a name="ln2970">  curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln2971">  curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln2972">  check_cursor_lnum();</a>
<a name="ln2973">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln2974"> </a>
<a name="ln2975">  need_wait_return = FALSE;     /* don't use wait_return() now */</a>
<a name="ln2976">  ex_no_reprint = TRUE;</a>
<a name="ln2977">}</a>
<a name="ln2978"> </a>
<a name="ln2979">/*</a>
<a name="ln2980"> * &quot;:change&quot;</a>
<a name="ln2981"> */</a>
<a name="ln2982">void ex_change(exarg_T *eap)</a>
<a name="ln2983">{</a>
<a name="ln2984">  linenr_T lnum;</a>
<a name="ln2985"> </a>
<a name="ln2986">  if (eap-&gt;line2 &gt;= eap-&gt;line1</a>
<a name="ln2987">      &amp;&amp; u_save(eap-&gt;line1 - 1, eap-&gt;line2 + 1) == FAIL)</a>
<a name="ln2988">    return;</a>
<a name="ln2989"> </a>
<a name="ln2990">  /* the ! flag toggles autoindent */</a>
<a name="ln2991">  if (eap-&gt;forceit ? !curbuf-&gt;b_p_ai : curbuf-&gt;b_p_ai)</a>
<a name="ln2992">    append_indent = get_indent_lnum(eap-&gt;line1);</a>
<a name="ln2993"> </a>
<a name="ln2994">  for (lnum = eap-&gt;line2; lnum &gt;= eap-&gt;line1; --lnum) {</a>
<a name="ln2995">    if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)           /* nothing to delete */</a>
<a name="ln2996">      break;</a>
<a name="ln2997">    ml_delete(eap-&gt;line1, false);</a>
<a name="ln2998">  }</a>
<a name="ln2999"> </a>
<a name="ln3000">  /* make sure the cursor is not beyond the end of the file now */</a>
<a name="ln3001">  check_cursor_lnum();</a>
<a name="ln3002">  deleted_lines_mark(eap-&gt;line1, (long)(eap-&gt;line2 - lnum));</a>
<a name="ln3003"> </a>
<a name="ln3004">  /* &quot;:append&quot; on the line above the deleted lines. */</a>
<a name="ln3005">  eap-&gt;line2 = eap-&gt;line1;</a>
<a name="ln3006">  ex_append(eap);</a>
<a name="ln3007">}</a>
<a name="ln3008"> </a>
<a name="ln3009">void ex_z(exarg_T *eap)</a>
<a name="ln3010">{</a>
<a name="ln3011">  char_u      *x;</a>
<a name="ln3012">  int64_t     bigness;</a>
<a name="ln3013">  char_u      *kind;</a>
<a name="ln3014">  int minus = 0;</a>
<a name="ln3015">  linenr_T start, end, curs, i;</a>
<a name="ln3016">  int j;</a>
<a name="ln3017">  linenr_T lnum = eap-&gt;line2;</a>
<a name="ln3018"> </a>
<a name="ln3019">  // Vi compatible: &quot;:z!&quot; uses display height, without a count uses</a>
<a name="ln3020">  // 'scroll'</a>
<a name="ln3021">  if (eap-&gt;forceit) {</a>
<a name="ln3022">    bigness = curwin-&gt;w_height_inner;</a>
<a name="ln3023">  } else if (ONE_WINDOW) {</a>
<a name="ln3024">    bigness = curwin-&gt;w_p_scr * 2;</a>
<a name="ln3025">  } else {</a>
<a name="ln3026">    bigness = curwin-&gt;w_height_inner - 3;</a>
<a name="ln3027">  }</a>
<a name="ln3028">  if (bigness &lt; 1) {</a>
<a name="ln3029">    bigness = 1;</a>
<a name="ln3030">  }</a>
<a name="ln3031"> </a>
<a name="ln3032">  x = eap-&gt;arg;</a>
<a name="ln3033">  kind = x;</a>
<a name="ln3034">  if (*kind == '-' || *kind == '+' || *kind == '='</a>
<a name="ln3035">      || *kind == '^' || *kind == '.')</a>
<a name="ln3036">    ++x;</a>
<a name="ln3037">  while (*x == '-' || *x == '+')</a>
<a name="ln3038">    ++x;</a>
<a name="ln3039"> </a>
<a name="ln3040">  if (*x != 0) {</a>
<a name="ln3041">    if (!ascii_isdigit(*x)) {</a>
<a name="ln3042">      EMSG(_(&quot;E144: non-numeric argument to :z&quot;));</a>
<a name="ln3043">      return;</a>
<a name="ln3044">    }</a>
<a name="ln3045">    bigness = atol((char *)x);</a>
<a name="ln3046"> </a>
<a name="ln3047">    // bigness could be &lt; 0 if atol(x) overflows.</a>
<a name="ln3048">    if (bigness &gt; 2 * curbuf-&gt;b_ml.ml_line_count || bigness &lt; 0) {</a>
<a name="ln3049">      bigness = 2 * curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3050">    }</a>
<a name="ln3051"> </a>
<a name="ln3052">    p_window = bigness;</a>
<a name="ln3053">    if (*kind == '=') {</a>
<a name="ln3054">      bigness += 2;</a>
<a name="ln3055">    }</a>
<a name="ln3056">  }</a>
<a name="ln3057"> </a>
<a name="ln3058">  /* the number of '-' and '+' multiplies the distance */</a>
<a name="ln3059">  if (*kind == '-' || *kind == '+')</a>
<a name="ln3060">    for (x = kind + 1; *x == *kind; ++x)</a>
<a name="ln3061">      ;</a>
<a name="ln3062"> </a>
<a name="ln3063">  switch (*kind) {</a>
<a name="ln3064">  case '-':</a>
<a name="ln3065">    start = lnum - bigness * (linenr_T)(x - kind) + 1;</a>
<a name="ln3066">    end = start + bigness - 1;</a>
<a name="ln3067">    curs = end;</a>
<a name="ln3068">    break;</a>
<a name="ln3069"> </a>
<a name="ln3070">  case '=':</a>
<a name="ln3071">    start = lnum - (bigness + 1) / 2 + 1;</a>
<a name="ln3072">    end = lnum + (bigness + 1) / 2 - 1;</a>
<a name="ln3073">    curs = lnum;</a>
<a name="ln3074">    minus = 1;</a>
<a name="ln3075">    break;</a>
<a name="ln3076"> </a>
<a name="ln3077">  case '^':</a>
<a name="ln3078">    start = lnum - bigness * 2;</a>
<a name="ln3079">    end = lnum - bigness;</a>
<a name="ln3080">    curs = lnum - bigness;</a>
<a name="ln3081">    break;</a>
<a name="ln3082"> </a>
<a name="ln3083">  case '.':</a>
<a name="ln3084">    start = lnum - (bigness + 1) / 2 + 1;</a>
<a name="ln3085">    end = lnum + (bigness + 1) / 2 - 1;</a>
<a name="ln3086">    curs = end;</a>
<a name="ln3087">    break;</a>
<a name="ln3088"> </a>
<a name="ln3089">  default:        /* '+' */</a>
<a name="ln3090">    start = lnum;</a>
<a name="ln3091">    if (*kind == '+')</a>
<a name="ln3092">      start += bigness * (linenr_T)(x - kind - 1) + 1;</a>
<a name="ln3093">    else if (eap-&gt;addr_count == 0)</a>
<a name="ln3094">      ++start;</a>
<a name="ln3095">    end = start + bigness - 1;</a>
<a name="ln3096">    curs = end;</a>
<a name="ln3097">    break;</a>
<a name="ln3098">  }</a>
<a name="ln3099"> </a>
<a name="ln3100">  if (start &lt; 1)</a>
<a name="ln3101">    start = 1;</a>
<a name="ln3102"> </a>
<a name="ln3103">  if (end &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln3104">    end = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3105"> </a>
<a name="ln3106">  if (curs &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3107">    curs = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3108">  } else if (curs &lt; 1) {</a>
<a name="ln3109">    curs = 1;</a>
<a name="ln3110">  }</a>
<a name="ln3111"> </a>
<a name="ln3112">  for (i = start; i &lt;= end; i++) {</a>
<a name="ln3113">    if (minus &amp;&amp; i == lnum) {</a>
<a name="ln3114">      msg_putchar('\n');</a>
<a name="ln3115"> </a>
<a name="ln3116">      for (j = 1; j &lt; Columns; j++)</a>
<a name="ln3117">        msg_putchar('-');</a>
<a name="ln3118">    }</a>
<a name="ln3119"> </a>
<a name="ln3120">    print_line(i, eap-&gt;flags &amp; EXFLAG_NR, eap-&gt;flags &amp; EXFLAG_LIST);</a>
<a name="ln3121"> </a>
<a name="ln3122">    if (minus &amp;&amp; i == lnum) {</a>
<a name="ln3123">      msg_putchar('\n');</a>
<a name="ln3124"> </a>
<a name="ln3125">      for (j = 1; j &lt; Columns; j++)</a>
<a name="ln3126">        msg_putchar('-');</a>
<a name="ln3127">    }</a>
<a name="ln3128">  }</a>
<a name="ln3129"> </a>
<a name="ln3130">  if (curwin-&gt;w_cursor.lnum != curs) {</a>
<a name="ln3131">    curwin-&gt;w_cursor.lnum = curs;</a>
<a name="ln3132">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3133">  }</a>
<a name="ln3134">  ex_no_reprint = true;</a>
<a name="ln3135">}</a>
<a name="ln3136"> </a>
<a name="ln3137">/*</a>
<a name="ln3138"> * Check if the secure flag is set (.exrc or .vimrc in current directory).</a>
<a name="ln3139"> * If so, give an error message and return TRUE.</a>
<a name="ln3140"> * Otherwise, return FALSE.</a>
<a name="ln3141"> */</a>
<a name="ln3142">int check_secure(void)</a>
<a name="ln3143">{</a>
<a name="ln3144">  if (secure) {</a>
<a name="ln3145">    secure = 2;</a>
<a name="ln3146">    EMSG(_(e_curdir));</a>
<a name="ln3147">    return TRUE;</a>
<a name="ln3148">  }</a>
<a name="ln3149"> </a>
<a name="ln3150">  // In the sandbox more things are not allowed, including the things</a>
<a name="ln3151">  // disallowed in secure mode.</a>
<a name="ln3152">  if (sandbox != 0) {</a>
<a name="ln3153">    EMSG(_(e_sandbox));</a>
<a name="ln3154">    return TRUE;</a>
<a name="ln3155">  }</a>
<a name="ln3156">  return FALSE;</a>
<a name="ln3157">}</a>
<a name="ln3158"> </a>
<a name="ln3159">/// Previous substitute replacement string</a>
<a name="ln3160">static SubReplacementString old_sub = {NULL, 0, NULL};</a>
<a name="ln3161"> </a>
<a name="ln3162">static int global_need_beginline;       // call beginline() after &quot;:g&quot;</a>
<a name="ln3163"> </a>
<a name="ln3164">/// Get old substitute replacement string</a>
<a name="ln3165">///</a>
<a name="ln3166">/// @param[out]  ret_sub    Location where old string will be saved.</a>
<a name="ln3167">void sub_get_replacement(SubReplacementString *const ret_sub)</a>
<a name="ln3168">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3169">{</a>
<a name="ln3170">  *ret_sub = old_sub;</a>
<a name="ln3171">}</a>
<a name="ln3172"> </a>
<a name="ln3173">/// Set substitute string and timestamp</a>
<a name="ln3174">///</a>
<a name="ln3175">/// @warning `sub` must be in allocated memory. It is not copied.</a>
<a name="ln3176">///</a>
<a name="ln3177">/// @param[in]  sub  New replacement string.</a>
<a name="ln3178">void sub_set_replacement(SubReplacementString sub)</a>
<a name="ln3179">{</a>
<a name="ln3180">  xfree(old_sub.sub);</a>
<a name="ln3181">  if (sub.additional_elements != old_sub.additional_elements) {</a>
<a name="ln3182">    tv_list_unref(old_sub.additional_elements);</a>
<a name="ln3183">  }</a>
<a name="ln3184">  old_sub = sub;</a>
<a name="ln3185">}</a>
<a name="ln3186"> </a>
<a name="ln3187">/// Recognize &quot;:%s/\n//&quot; and turn it into a join command, which is much</a>
<a name="ln3188">/// more efficient.</a>
<a name="ln3189">///</a>
<a name="ln3190">/// @param[in]  eap  Ex arguments</a>
<a name="ln3191">/// @param[in]  pat  Search pattern</a>
<a name="ln3192">/// @param[in]  sub  Replacement string</a>
<a name="ln3193">/// @param[in]  cmd  Command from :s_flags</a>
<a name="ln3194">/// @param[in]  save Save pattern to options, history</a>
<a name="ln3195">///</a>
<a name="ln3196">/// @returns true if :substitute can be replaced with a join command</a>
<a name="ln3197">static bool sub_joining_lines(exarg_T *eap, char_u *pat, char_u *sub,</a>
<a name="ln3198">                              char_u *cmd, bool save)</a>
<a name="ln3199">  FUNC_ATTR_NONNULL_ARG(1, 3, 4)</a>
<a name="ln3200">{</a>
<a name="ln3201">  // TODO(vim): find a generic solution to make line-joining operations more</a>
<a name="ln3202">  // efficient, avoid allocating a string that grows in size.</a>
<a name="ln3203">  if (pat != NULL</a>
<a name="ln3204">      &amp;&amp; strcmp((const char *)pat, &quot;\\n&quot;) == 0</a>
<a name="ln3205">      &amp;&amp; *sub == NUL</a>
<a name="ln3206">      &amp;&amp; (*cmd == NUL || (cmd[1] == NUL</a>
<a name="ln3207">                          &amp;&amp; (*cmd == 'g'</a>
<a name="ln3208">                              || *cmd == 'l'</a>
<a name="ln3209">                              || *cmd == 'p'</a>
<a name="ln3210">                              || *cmd == '#')))) {</a>
<a name="ln3211">    if (eap-&gt;skip) {</a>
<a name="ln3212">      return true;</a>
<a name="ln3213">    }</a>
<a name="ln3214">    curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln3215">    if (*cmd == 'l') {</a>
<a name="ln3216">      eap-&gt;flags = EXFLAG_LIST;</a>
<a name="ln3217">    } else if (*cmd == '#') {</a>
<a name="ln3218">      eap-&gt;flags = EXFLAG_NR;</a>
<a name="ln3219">    } else if (*cmd == 'p') {</a>
<a name="ln3220">      eap-&gt;flags = EXFLAG_PRINT;</a>
<a name="ln3221">    }</a>
<a name="ln3222"> </a>
<a name="ln3223">    // The number of lines joined is the number of lines in the range</a>
<a name="ln3224">    linenr_T joined_lines_count = eap-&gt;line2 - eap-&gt;line1 + 1</a>
<a name="ln3225">      // plus one extra line if not at the end of file.</a>
<a name="ln3226">      + (eap-&gt;line2 &lt; curbuf-&gt;b_ml.ml_line_count ? 1 : 0);</a>
<a name="ln3227">    if (joined_lines_count &gt; 1) {</a>
<a name="ln3228">      do_join(joined_lines_count, FALSE, TRUE, FALSE, true);</a>
<a name="ln3229">      sub_nsubs = joined_lines_count - 1;</a>
<a name="ln3230">      sub_nlines = 1;</a>
<a name="ln3231">      do_sub_msg(false);</a>
<a name="ln3232">      ex_may_print(eap);</a>
<a name="ln3233">    }</a>
<a name="ln3234"> </a>
<a name="ln3235">    if (save) {</a>
<a name="ln3236">      if (!cmdmod.keeppatterns) {</a>
<a name="ln3237">        save_re_pat(RE_SUBST, pat, p_magic);</a>
<a name="ln3238">      }</a>
<a name="ln3239">      add_to_history(HIST_SEARCH, pat, true, NUL);</a>
<a name="ln3240">    }</a>
<a name="ln3241"> </a>
<a name="ln3242">    return true;</a>
<a name="ln3243">  }</a>
<a name="ln3244"> </a>
<a name="ln3245">  return false;</a>
<a name="ln3246">}</a>
<a name="ln3247"> </a>
<a name="ln3248">/// Allocate memory to store the replacement text for :substitute.</a>
<a name="ln3249">///</a>
<a name="ln3250">/// Slightly more memory that is strictly necessary is allocated to reduce the</a>
<a name="ln3251">/// frequency of memory (re)allocation.</a>
<a name="ln3252">///</a>
<a name="ln3253">/// @param[in,out]  new_start   pointer to the memory for the replacement text</a>
<a name="ln3254">/// @param[in]      needed_len  amount of memory needed</a>
<a name="ln3255">///</a>
<a name="ln3256">/// @returns pointer to the end of the allocated memory</a>
<a name="ln3257">static char_u *sub_grow_buf(char_u **new_start, int needed_len)</a>
<a name="ln3258">  FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_NONNULL_RET</a>
<a name="ln3259">{</a>
<a name="ln3260">  int new_start_len = 0;</a>
<a name="ln3261">  char_u *new_end;</a>
<a name="ln3262">  if (*new_start == NULL) {</a>
<a name="ln3263">    // Get some space for a temporary buffer to do the</a>
<a name="ln3264">    // substitution into (and some extra space to avoid</a>
<a name="ln3265">    // too many calls to xmalloc()/free()).</a>
<a name="ln3266">    new_start_len = needed_len + 50;</a>
<a name="ln3267">    *new_start = xmalloc(new_start_len);</a>
<a name="ln3268">    **new_start = NUL;</a>
<a name="ln3269">    new_end = *new_start;</a>
<a name="ln3270">  } else {</a>
<a name="ln3271">    // Check if the temporary buffer is long enough to do the</a>
<a name="ln3272">    // substitution into.  If not, make it larger (with a bit</a>
<a name="ln3273">    // extra to avoid too many calls to xmalloc()/free()).</a>
<a name="ln3274">    size_t len = STRLEN(*new_start);</a>
<a name="ln3275">    needed_len += len;</a>
<a name="ln3276">    if (needed_len &gt; new_start_len) {</a>
<a name="ln3277">      new_start_len = needed_len + 50;</a>
<a name="ln3278">      *new_start = xrealloc(*new_start, new_start_len);</a>
<a name="ln3279">    }</a>
<a name="ln3280">    new_end = *new_start + len;</a>
<a name="ln3281">  }</a>
<a name="ln3282"> </a>
<a name="ln3283">  return new_end;</a>
<a name="ln3284">}</a>
<a name="ln3285"> </a>
<a name="ln3286">/// Parse cmd string for :substitute's {flags} and update subflags accordingly</a>
<a name="ln3287">///</a>
<a name="ln3288">/// @param[in]      cmd  command string</a>
<a name="ln3289">/// @param[in,out]  subflags  current flags defined for the :substitute command</a>
<a name="ln3290">/// @param[in,out]  which_pat  pattern type from which to get default search</a>
<a name="ln3291">///</a>
<a name="ln3292">/// @returns pointer to the end of the flags, which may be the end of the string</a>
<a name="ln3293">static char_u *sub_parse_flags(char_u *cmd, subflags_T *subflags,</a>
<a name="ln3294">                               int *which_pat)</a>
<a name="ln3295">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln3296">{</a>
<a name="ln3297">  // Find trailing options.  When '&amp;' is used, keep old options.</a>
<a name="ln3298">  if (*cmd == '&amp;') {</a>
<a name="ln3299">    cmd++;</a>
<a name="ln3300">  } else {</a>
<a name="ln3301">    subflags-&gt;do_all = p_gd;</a>
<a name="ln3302">    subflags-&gt;do_ask = false;</a>
<a name="ln3303">    subflags-&gt;do_error = true;</a>
<a name="ln3304">    subflags-&gt;do_print = false;</a>
<a name="ln3305">    subflags-&gt;do_list = false;</a>
<a name="ln3306">    subflags-&gt;do_count = false;</a>
<a name="ln3307">    subflags-&gt;do_number = false;</a>
<a name="ln3308">    subflags-&gt;do_ic = kSubHonorOptions;</a>
<a name="ln3309">  }</a>
<a name="ln3310">  while (*cmd) {</a>
<a name="ln3311">    // Note that 'g' and 'c' are always inverted.</a>
<a name="ln3312">    // 'r' is never inverted.</a>
<a name="ln3313">    if (*cmd == 'g') {</a>
<a name="ln3314">      subflags-&gt;do_all = !subflags-&gt;do_all;</a>
<a name="ln3315">    } else if (*cmd == 'c') {</a>
<a name="ln3316">      subflags-&gt;do_ask = !subflags-&gt;do_ask;</a>
<a name="ln3317">    } else if (*cmd == 'n') {</a>
<a name="ln3318">      subflags-&gt;do_count = true;</a>
<a name="ln3319">    } else if (*cmd == 'e') {</a>
<a name="ln3320">      subflags-&gt;do_error = !subflags-&gt;do_error;</a>
<a name="ln3321">    } else if (*cmd == 'r') {  // use last used regexp</a>
<a name="ln3322">      *which_pat = RE_LAST;</a>
<a name="ln3323">    } else if (*cmd == 'p') {</a>
<a name="ln3324">      subflags-&gt;do_print = true;</a>
<a name="ln3325">    } else if (*cmd == '#') {</a>
<a name="ln3326">      subflags-&gt;do_print = true;</a>
<a name="ln3327">      subflags-&gt;do_number = true;</a>
<a name="ln3328">    } else if (*cmd == 'l') {</a>
<a name="ln3329">      subflags-&gt;do_print = true;</a>
<a name="ln3330">      subflags-&gt;do_list = true;</a>
<a name="ln3331">    } else if (*cmd == 'i') {  // ignore case</a>
<a name="ln3332">      subflags-&gt;do_ic = kSubIgnoreCase;</a>
<a name="ln3333">    } else if (*cmd == 'I') {  // don't ignore case</a>
<a name="ln3334">      subflags-&gt;do_ic = kSubMatchCase;</a>
<a name="ln3335">    } else {</a>
<a name="ln3336">      break;</a>
<a name="ln3337">    }</a>
<a name="ln3338">    cmd++;</a>
<a name="ln3339">  }</a>
<a name="ln3340">  if (subflags-&gt;do_count) {</a>
<a name="ln3341">    subflags-&gt;do_ask = false;</a>
<a name="ln3342">  }</a>
<a name="ln3343"> </a>
<a name="ln3344">  return cmd;</a>
<a name="ln3345">}</a>
<a name="ln3346"> </a>
<a name="ln3347">static int check_regexp_delim(int c)</a>
<a name="ln3348">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3349">{</a>
<a name="ln3350">  if (isalpha(c)) {</a>
<a name="ln3351">    EMSG(_(&quot;E146: Regular expressions can't be delimited by letters&quot;));</a>
<a name="ln3352">    return FAIL;</a>
<a name="ln3353">  }</a>
<a name="ln3354">  return OK;</a>
<a name="ln3355">}</a>
<a name="ln3356"> </a>
<a name="ln3357">/// Perform a substitution from line eap-&gt;line1 to line eap-&gt;line2 using the</a>
<a name="ln3358">/// command pointed to by eap-&gt;arg which should be of the form:</a>
<a name="ln3359">///</a>
<a name="ln3360">/// /pattern/substitution/{flags}</a>
<a name="ln3361">///</a>
<a name="ln3362">/// The usual escapes are supported as described in the regexp docs.</a>
<a name="ln3363">///</a>
<a name="ln3364">/// @param do_buf_event If `true`, send buffer updates.</a>
<a name="ln3365">/// @return buffer used for 'inccommand' preview</a>
<a name="ln3366">static buf_T *do_sub(exarg_T *eap, proftime_T timeout,</a>
<a name="ln3367">                     bool do_buf_event, handle_T bufnr)</a>
<a name="ln3368">{</a>
<a name="ln3369">  long i = 0;</a>
<a name="ln3370">  regmmatch_T regmatch;</a>
<a name="ln3371">  static subflags_T subflags = {</a>
<a name="ln3372">    .do_all = false,</a>
<a name="ln3373">    .do_ask = false,</a>
<a name="ln3374">    .do_count = false,</a>
<a name="ln3375">    .do_error = true,</a>
<a name="ln3376">    .do_print = false,</a>
<a name="ln3377">    .do_list = false,</a>
<a name="ln3378">    .do_number = false,</a>
<a name="ln3379">    .do_ic = kSubHonorOptions</a>
<a name="ln3380">  };</a>
<a name="ln3381">  char_u *pat = NULL, *sub = NULL;  // init for GCC</a>
<a name="ln3382">  int delimiter;</a>
<a name="ln3383">  bool has_second_delim = false;</a>
<a name="ln3384">  int sublen;</a>
<a name="ln3385">  int got_quit = false;</a>
<a name="ln3386">  int got_match = false;</a>
<a name="ln3387">  int which_pat;</a>
<a name="ln3388">  char_u *cmd = eap-&gt;arg;</a>
<a name="ln3389">  linenr_T first_line = 0;  // first changed line</a>
<a name="ln3390">  linenr_T last_line= 0;    // below last changed line AFTER the change</a>
<a name="ln3391">  linenr_T old_line_count = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3392">  char_u *sub_firstline;    // allocated copy of first sub line</a>
<a name="ln3393">  bool endcolumn = false;   // cursor in last column when done</a>
<a name="ln3394">  PreviewLines preview_lines = { KV_INITIAL_VALUE, 0 };</a>
<a name="ln3395">  static int pre_src_id = 0;  // Source id for the preview highlight</a>
<a name="ln3396">  static int pre_hl_id = 0;</a>
<a name="ln3397">  buf_T *orig_buf = curbuf;  // save to reset highlighting</a>
<a name="ln3398">  pos_T old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln3399">  int start_nsubs;</a>
<a name="ln3400">  int save_ma = 0;</a>
<a name="ln3401">  int save_b_changed = curbuf-&gt;b_changed;</a>
<a name="ln3402">  bool preview = (State &amp; CMDPREVIEW);</a>
<a name="ln3403"> </a>
<a name="ln3404">  bool did_save = false;</a>
<a name="ln3405"> </a>
<a name="ln3406">  if (!global_busy) {</a>
<a name="ln3407">    sub_nsubs = 0;</a>
<a name="ln3408">    sub_nlines = 0;</a>
<a name="ln3409">  }</a>
<a name="ln3410">  start_nsubs = sub_nsubs;</a>
<a name="ln3411"> </a>
<a name="ln3412">  if (eap-&gt;cmdidx == CMD_tilde)</a>
<a name="ln3413">    which_pat = RE_LAST;        /* use last used regexp */</a>
<a name="ln3414">  else</a>
<a name="ln3415">    which_pat = RE_SUBST;       /* use last substitute regexp */</a>
<a name="ln3416"> </a>
<a name="ln3417">  /* new pattern and substitution */</a>
<a name="ln3418">  if (eap-&gt;cmd[0] == 's' &amp;&amp; *cmd != NUL &amp;&amp; !ascii_iswhite(*cmd)</a>
<a name="ln3419">      &amp;&amp; vim_strchr((char_u *)&quot;0123456789cegriIp|\&quot;&quot;, *cmd) == NULL) {</a>
<a name="ln3420">    // don't accept alphanumeric for separator</a>
<a name="ln3421">    if (check_regexp_delim(*cmd) == FAIL) {</a>
<a name="ln3422">      return NULL;</a>
<a name="ln3423">    }</a>
<a name="ln3424"> </a>
<a name="ln3425">    // undocumented vi feature:</a>
<a name="ln3426">    //  &quot;\/sub/&quot; and &quot;\?sub?&quot; use last used search pattern (almost like</a>
<a name="ln3427">    //  //sub/r).  &quot;\&amp;sub&amp;&quot; use last substitute pattern (like //sub/).</a>
<a name="ln3428">    if (*cmd == '\\') {</a>
<a name="ln3429">      ++cmd;</a>
<a name="ln3430">      if (vim_strchr((char_u *)&quot;/?&amp;&quot;, *cmd) == NULL) {</a>
<a name="ln3431">        EMSG(_(e_backslash));</a>
<a name="ln3432">        return NULL;</a>
<a name="ln3433">      }</a>
<a name="ln3434">      if (*cmd != '&amp;') {</a>
<a name="ln3435">        which_pat = RE_SEARCH;              // use last '/' pattern</a>
<a name="ln3436">      }</a>
<a name="ln3437">      pat = (char_u *)&quot;&quot;;                   // empty search pattern</a>
<a name="ln3438">      delimiter = *cmd++;                   // remember delimiter character</a>
<a name="ln3439">      has_second_delim = true;</a>
<a name="ln3440">    } else {          // find the end of the regexp</a>
<a name="ln3441">      which_pat = RE_LAST;                  // use last used regexp</a>
<a name="ln3442">      delimiter = *cmd++;                   // remember delimiter character</a>
<a name="ln3443">      pat = cmd;                            // remember start of search pat</a>
<a name="ln3444">      cmd = skip_regexp(cmd, delimiter, p_magic, &amp;eap-&gt;arg);</a>
<a name="ln3445">      if (cmd[0] == delimiter) {            // end delimiter found</a>
<a name="ln3446">        *cmd++ = NUL;                       // replace it with a NUL</a>
<a name="ln3447">        has_second_delim = true;</a>
<a name="ln3448">      }</a>
<a name="ln3449">    }</a>
<a name="ln3450"> </a>
<a name="ln3451">    /*</a>
<a name="ln3452">     * Small incompatibility: vi sees '\n' as end of the command, but in</a>
<a name="ln3453">     * Vim we want to use '\n' to find/substitute a NUL.</a>
<a name="ln3454">     */</a>
<a name="ln3455">    sub = cmd;              /* remember the start of the substitution */</a>
<a name="ln3456"> </a>
<a name="ln3457">    while (cmd[0]) {</a>
<a name="ln3458">      if (cmd[0] == delimiter) {                /* end delimiter found */</a>
<a name="ln3459">        *cmd++ = NUL;                           /* replace it with a NUL */</a>
<a name="ln3460">        break;</a>
<a name="ln3461">      }</a>
<a name="ln3462">      if (cmd[0] == '\\' &amp;&amp; cmd[1] != 0) {      // skip escaped characters</a>
<a name="ln3463">        cmd++;</a>
<a name="ln3464">      }</a>
<a name="ln3465">      MB_PTR_ADV(cmd);</a>
<a name="ln3466">    }</a>
<a name="ln3467"> </a>
<a name="ln3468">    if (!eap-&gt;skip &amp;&amp; !preview) {</a>
<a name="ln3469">      sub_set_replacement((SubReplacementString) {</a>
<a name="ln3470">        .sub = xstrdup((char *) sub),</a>
<a name="ln3471">        .timestamp = os_time(),</a>
<a name="ln3472">        .additional_elements = NULL,</a>
<a name="ln3473">      });</a>
<a name="ln3474">    }</a>
<a name="ln3475">  } else if (!eap-&gt;skip) {    /* use previous pattern and substitution */</a>
<a name="ln3476">    if (old_sub.sub == NULL) {      /* there is no previous command */</a>
<a name="ln3477">      EMSG(_(e_nopresub));</a>
<a name="ln3478">      return NULL;</a>
<a name="ln3479">    }</a>
<a name="ln3480">    pat = NULL;                 /* search_regcomp() will use previous pattern */</a>
<a name="ln3481">    sub = (char_u *) old_sub.sub;</a>
<a name="ln3482"> </a>
<a name="ln3483">    /* Vi compatibility quirk: repeating with &quot;:s&quot; keeps the cursor in the</a>
<a name="ln3484">     * last column after using &quot;$&quot;. */</a>
<a name="ln3485">    endcolumn = (curwin-&gt;w_curswant == MAXCOL);</a>
<a name="ln3486">  }</a>
<a name="ln3487"> </a>
<a name="ln3488">  if (sub != NULL &amp;&amp; sub_joining_lines(eap, pat, sub, cmd, !preview)) {</a>
<a name="ln3489">    return NULL;</a>
<a name="ln3490">  }</a>
<a name="ln3491"> </a>
<a name="ln3492">  cmd = sub_parse_flags(cmd, &amp;subflags, &amp;which_pat);</a>
<a name="ln3493"> </a>
<a name="ln3494">  bool save_do_all = subflags.do_all;  // remember user specified 'g' flag</a>
<a name="ln3495">  bool save_do_ask = subflags.do_ask;  // remember user specified 'c' flag</a>
<a name="ln3496"> </a>
<a name="ln3497">  // check for a trailing count</a>
<a name="ln3498">  cmd = skipwhite(cmd);</a>
<a name="ln3499">  if (ascii_isdigit(*cmd)) {</a>
<a name="ln3500">    i = getdigits_long(&amp;cmd, true, 0);</a>
<a name="ln3501">    if (i &lt;= 0 &amp;&amp; !eap-&gt;skip &amp;&amp; subflags.do_error) {</a>
<a name="ln3502">      EMSG(_(e_zerocount));</a>
<a name="ln3503">      return NULL;</a>
<a name="ln3504">    }</a>
<a name="ln3505">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln3506">    eap-&gt;line2 += i - 1;</a>
<a name="ln3507">    if (eap-&gt;line2 &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln3508">      eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3509">  }</a>
<a name="ln3510"> </a>
<a name="ln3511">  /*</a>
<a name="ln3512">   * check for trailing command or garbage</a>
<a name="ln3513">   */</a>
<a name="ln3514">  cmd = skipwhite(cmd);</a>
<a name="ln3515">  if (*cmd &amp;&amp; *cmd != '&quot;') {        /* if not end-of-line or comment */</a>
<a name="ln3516">    eap-&gt;nextcmd = check_nextcmd(cmd);</a>
<a name="ln3517">    if (eap-&gt;nextcmd == NULL) {</a>
<a name="ln3518">      EMSG(_(e_trailing));</a>
<a name="ln3519">      return NULL;</a>
<a name="ln3520">    }</a>
<a name="ln3521">  }</a>
<a name="ln3522"> </a>
<a name="ln3523">  if (eap-&gt;skip) {          // not executing commands, only parsing</a>
<a name="ln3524">    return NULL;</a>
<a name="ln3525">  }</a>
<a name="ln3526"> </a>
<a name="ln3527">  if (!subflags.do_count &amp;&amp; !MODIFIABLE(curbuf)) {</a>
<a name="ln3528">    // Substitution is not allowed in non-'modifiable' buffer</a>
<a name="ln3529">    EMSG(_(e_modifiable));</a>
<a name="ln3530">    return NULL;</a>
<a name="ln3531">  }</a>
<a name="ln3532"> </a>
<a name="ln3533">  if (search_regcomp(pat, RE_SUBST, which_pat, (preview ? 0 : SEARCH_HIS),</a>
<a name="ln3534">                     &amp;regmatch) == FAIL) {</a>
<a name="ln3535">    if (subflags.do_error) {</a>
<a name="ln3536">      EMSG(_(e_invcmd));</a>
<a name="ln3537">    }</a>
<a name="ln3538">    return NULL;</a>
<a name="ln3539">  }</a>
<a name="ln3540"> </a>
<a name="ln3541">  // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'</a>
<a name="ln3542">  if (subflags.do_ic == kSubIgnoreCase) {</a>
<a name="ln3543">    regmatch.rmm_ic = true;</a>
<a name="ln3544">  } else if (subflags.do_ic == kSubMatchCase) {</a>
<a name="ln3545">    regmatch.rmm_ic = false;</a>
<a name="ln3546">  }</a>
<a name="ln3547"> </a>
<a name="ln3548">  sub_firstline = NULL;</a>
<a name="ln3549"> </a>
<a name="ln3550">  // ~ in the substitute pattern is replaced with the old pattern.</a>
<a name="ln3551">  // We do it here once to avoid it to be replaced over and over again.</a>
<a name="ln3552">  // But don't do it when it starts with &quot;\=&quot;, then it's an expression.</a>
<a name="ln3553">  assert(sub != NULL);</a>
<a name="ln3554">  if (!(sub[0] == '\\' &amp;&amp; sub[1] == '=')) {</a>
<a name="ln3555">    sub = regtilde(sub, p_magic);</a>
<a name="ln3556">  }</a>
<a name="ln3557"> </a>
<a name="ln3558">  // Check for a match on each line.</a>
<a name="ln3559">  // If preview: limit to max('cmdwinheight', viewport).</a>
<a name="ln3560">  linenr_T line2 = eap-&gt;line2;</a>
<a name="ln3561"> </a>
<a name="ln3562">  for (linenr_T lnum = eap-&gt;line1;</a>
<a name="ln3563">       lnum &lt;= line2 &amp;&amp; !got_quit &amp;&amp; !aborting()</a>
<a name="ln3564">       &amp;&amp; (!preview || preview_lines.lines_needed &lt;= (linenr_T)p_cwh</a>
<a name="ln3565">           || lnum &lt;= curwin-&gt;w_botline);</a>
<a name="ln3566">       lnum++) {</a>
<a name="ln3567">    long nmatch = vim_regexec_multi(&amp;regmatch, curwin, curbuf, lnum,</a>
<a name="ln3568">                                    (colnr_T)0, NULL, NULL);</a>
<a name="ln3569">    if (nmatch) {</a>
<a name="ln3570">      colnr_T copycol;</a>
<a name="ln3571">      colnr_T matchcol;</a>
<a name="ln3572">      colnr_T prev_matchcol = MAXCOL;</a>
<a name="ln3573">      char_u      *new_end, *new_start = NULL;</a>
<a name="ln3574">      char_u      *p1;</a>
<a name="ln3575">      int did_sub = FALSE;</a>
<a name="ln3576">      int lastone;</a>
<a name="ln3577">      long nmatch_tl = 0;               // nr of lines matched below lnum</a>
<a name="ln3578">      int do_again;                     // do it again after joining lines</a>
<a name="ln3579">      bool skip_match = false;</a>
<a name="ln3580">      linenr_T sub_firstlnum;           // nr of first sub line</a>
<a name="ln3581"> </a>
<a name="ln3582">      /*</a>
<a name="ln3583">       * The new text is build up step by step, to avoid too much</a>
<a name="ln3584">       * copying.  There are these pieces:</a>
<a name="ln3585">       * sub_firstline	The old text, unmodified.</a>
<a name="ln3586">       * copycol		Column in the old text where we started</a>
<a name="ln3587">       *			looking for a match; from here old text still</a>
<a name="ln3588">       *			needs to be copied to the new text.</a>
<a name="ln3589">       * matchcol		Column number of the old text where to look</a>
<a name="ln3590">       *			for the next match.  It's just after the</a>
<a name="ln3591">       *			previous match or one further.</a>
<a name="ln3592">       * prev_matchcol	Column just after the previous match (if any).</a>
<a name="ln3593">       *			Mostly equal to matchcol, except for the first</a>
<a name="ln3594">       *			match and after skipping an empty match.</a>
<a name="ln3595">       * regmatch.*pos	Where the pattern matched in the old text.</a>
<a name="ln3596">       * new_start	The new text, all that has been produced so</a>
<a name="ln3597">       *			far.</a>
<a name="ln3598">       * new_end		The new text, where to append new text.</a>
<a name="ln3599">       *</a>
<a name="ln3600">       * lnum		The line number where we found the start of</a>
<a name="ln3601">       *			the match.  Can be below the line we searched</a>
<a name="ln3602">       *			when there is a \n before a \zs in the</a>
<a name="ln3603">       *			pattern.</a>
<a name="ln3604">       * sub_firstlnum	The line number in the buffer where to look</a>
<a name="ln3605">       *			for a match.  Can be different from &quot;lnum&quot;</a>
<a name="ln3606">       *			when the pattern or substitute string contains</a>
<a name="ln3607">       *			line breaks.</a>
<a name="ln3608">       *</a>
<a name="ln3609">       * Special situations:</a>
<a name="ln3610">       * - When the substitute string contains a line break, the part up</a>
<a name="ln3611">       *   to the line break is inserted in the text, but the copy of</a>
<a name="ln3612">       *   the original line is kept.  &quot;sub_firstlnum&quot; is adjusted for</a>
<a name="ln3613">       *   the inserted lines.</a>
<a name="ln3614">       * - When the matched pattern contains a line break, the old line</a>
<a name="ln3615">       *   is taken from the line at the end of the pattern.  The lines</a>
<a name="ln3616">       *   in the match are deleted later, &quot;sub_firstlnum&quot; is adjusted</a>
<a name="ln3617">       *   accordingly.</a>
<a name="ln3618">       *</a>
<a name="ln3619">       * The new text is built up in new_start[].  It has some extra</a>
<a name="ln3620">       * room to avoid using xmalloc()/free() too often.</a>
<a name="ln3621">       *</a>
<a name="ln3622">       * Make a copy of the old line, so it won't be taken away when</a>
<a name="ln3623">       * updating the screen or handling a multi-line match.  The &quot;old_&quot;</a>
<a name="ln3624">       * pointers point into this copy.</a>
<a name="ln3625">       */</a>
<a name="ln3626">      sub_firstlnum = lnum;</a>
<a name="ln3627">      copycol = 0;</a>
<a name="ln3628">      matchcol = 0;</a>
<a name="ln3629"> </a>
<a name="ln3630">      /* At first match, remember current cursor position. */</a>
<a name="ln3631">      if (!got_match) {</a>
<a name="ln3632">        setpcmark();</a>
<a name="ln3633">        got_match = TRUE;</a>
<a name="ln3634">      }</a>
<a name="ln3635"> </a>
<a name="ln3636">      /*</a>
<a name="ln3637">       * Loop until nothing more to replace in this line.</a>
<a name="ln3638">       * 1. Handle match with empty string.</a>
<a name="ln3639">       * 2. If subflags.do_ask is set, ask for confirmation.</a>
<a name="ln3640">       * 3. substitute the string.</a>
<a name="ln3641">       * 4. if subflags.do_all is set, find next match</a>
<a name="ln3642">       * 5. break if there isn't another match in this line</a>
<a name="ln3643">       */</a>
<a name="ln3644">      for (;; ) {</a>
<a name="ln3645">        SubResult current_match = {</a>
<a name="ln3646">          .start = { 0, 0 },</a>
<a name="ln3647">          .end   = { 0, 0 },</a>
<a name="ln3648">          .pre_match = 0,</a>
<a name="ln3649">        };</a>
<a name="ln3650">        // lnum is where the match start, but maybe not the pattern match,</a>
<a name="ln3651">        // since we can have \n before \zs in the pattern</a>
<a name="ln3652"> </a>
<a name="ln3653">        // Advance &quot;lnum&quot; to the line where the match starts.  The</a>
<a name="ln3654">        // match does not start in the first line when there is a line</a>
<a name="ln3655">        // break before \zs.</a>
<a name="ln3656">        if (regmatch.startpos[0].lnum &gt; 0) {</a>
<a name="ln3657">          current_match.pre_match = lnum;</a>
<a name="ln3658">          lnum += regmatch.startpos[0].lnum;</a>
<a name="ln3659">          sub_firstlnum += regmatch.startpos[0].lnum;</a>
<a name="ln3660">          nmatch -= regmatch.startpos[0].lnum;</a>
<a name="ln3661">          XFREE_CLEAR(sub_firstline);</a>
<a name="ln3662">        }</a>
<a name="ln3663"> </a>
<a name="ln3664">        // Now we're at the line where the pattern match starts</a>
<a name="ln3665">        // Note: If not first match on a line, column can't be known here</a>
<a name="ln3666">        current_match.start.lnum = sub_firstlnum;</a>
<a name="ln3667"> </a>
<a name="ln3668">        // Match might be after the last line for &quot;\n\zs&quot; matching at</a>
<a name="ln3669">        // the end of the last line.</a>
<a name="ln3670">        if (lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3671">          break;</a>
<a name="ln3672">        }</a>
<a name="ln3673">        if (sub_firstline == NULL) {</a>
<a name="ln3674">          sub_firstline = vim_strsave(ml_get(sub_firstlnum));</a>
<a name="ln3675">        }</a>
<a name="ln3676"> </a>
<a name="ln3677">        /* Save the line number of the last change for the final</a>
<a name="ln3678">         * cursor position (just like Vi). */</a>
<a name="ln3679">        curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3680">        do_again = FALSE;</a>
<a name="ln3681"> </a>
<a name="ln3682">        /*</a>
<a name="ln3683">         * 1. Match empty string does not count, except for first</a>
<a name="ln3684">         * match.  This reproduces the strange vi behaviour.</a>
<a name="ln3685">         * This also catches endless loops.</a>
<a name="ln3686">         */</a>
<a name="ln3687">        if (matchcol == prev_matchcol</a>
<a name="ln3688">            &amp;&amp; regmatch.endpos[0].lnum == 0</a>
<a name="ln3689">            &amp;&amp; matchcol == regmatch.endpos[0].col) {</a>
<a name="ln3690">          if (sub_firstline[matchcol] == NUL) {</a>
<a name="ln3691">            // We already were at the end of the line.  Don't look</a>
<a name="ln3692">            // for a match in this line again.</a>
<a name="ln3693">            skip_match = true;</a>
<a name="ln3694">          } else {</a>
<a name="ln3695">            // search for a match at next column</a>
<a name="ln3696">            matchcol += mb_ptr2len(sub_firstline + matchcol);</a>
<a name="ln3697">          }</a>
<a name="ln3698">          // match will be pushed to preview_lines, bring it into a proper state</a>
<a name="ln3699">          current_match.start.col = matchcol;</a>
<a name="ln3700">          current_match.end.lnum = sub_firstlnum;</a>
<a name="ln3701">          current_match.end.col = matchcol;</a>
<a name="ln3702">          goto skip;</a>
<a name="ln3703">        }</a>
<a name="ln3704"> </a>
<a name="ln3705">        /* Normally we continue searching for a match just after the</a>
<a name="ln3706">         * previous match. */</a>
<a name="ln3707">        matchcol = regmatch.endpos[0].col;</a>
<a name="ln3708">        prev_matchcol = matchcol;</a>
<a name="ln3709"> </a>
<a name="ln3710">        // 2. If subflags.do_count is set only increase the counter.</a>
<a name="ln3711">        //    If do_ask is set, ask for confirmation.</a>
<a name="ln3712">        if (subflags.do_count) {</a>
<a name="ln3713">          // For a multi-line match, put matchcol at the NUL at</a>
<a name="ln3714">          // the end of the line and set nmatch to one, so that</a>
<a name="ln3715">          // we continue looking for a match on the next line.</a>
<a name="ln3716">          // Avoids that &quot;:s/\nB\@=//gc&quot; get stuck.</a>
<a name="ln3717">          if (nmatch &gt; 1) {</a>
<a name="ln3718">            matchcol = (colnr_T)STRLEN(sub_firstline);</a>
<a name="ln3719">            nmatch = 1;</a>
<a name="ln3720">            skip_match = true;</a>
<a name="ln3721">          }</a>
<a name="ln3722">          sub_nsubs++;</a>
<a name="ln3723">          did_sub = TRUE;</a>
<a name="ln3724">          /* Skip the substitution, unless an expression is used,</a>
<a name="ln3725">           * then it is evaluated in the sandbox. */</a>
<a name="ln3726">          if (!(sub[0] == '\\' &amp;&amp; sub[1] == '='))</a>
<a name="ln3727">            goto skip;</a>
<a name="ln3728">        }</a>
<a name="ln3729"> </a>
<a name="ln3730">        if (subflags.do_ask &amp;&amp; !preview) {</a>
<a name="ln3731">          int typed = 0;</a>
<a name="ln3732"> </a>
<a name="ln3733">          /* change State to CONFIRM, so that the mouse works</a>
<a name="ln3734">           * properly */</a>
<a name="ln3735">          int save_State = State;</a>
<a name="ln3736">          State = CONFIRM;</a>
<a name="ln3737">          setmouse();                   /* disable mouse in xterm */</a>
<a name="ln3738">          curwin-&gt;w_cursor.col = regmatch.startpos[0].col;</a>
<a name="ln3739"> </a>
<a name="ln3740">          if (curwin-&gt;w_p_crb) {</a>
<a name="ln3741">            do_check_cursorbind();</a>
<a name="ln3742">          }</a>
<a name="ln3743"> </a>
<a name="ln3744">          /* When 'cpoptions' contains &quot;u&quot; don't sync undo when</a>
<a name="ln3745">           * asking for confirmation. */</a>
<a name="ln3746">          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)</a>
<a name="ln3747">            ++no_u_sync;</a>
<a name="ln3748"> </a>
<a name="ln3749">          /*</a>
<a name="ln3750">           * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.</a>
<a name="ln3751">           */</a>
<a name="ln3752">          while (subflags.do_ask) {</a>
<a name="ln3753">            if (exmode_active) {</a>
<a name="ln3754">              char_u      *resp;</a>
<a name="ln3755">              colnr_T sc, ec;</a>
<a name="ln3756"> </a>
<a name="ln3757">              print_line_no_prefix(lnum, subflags.do_number, subflags.do_list);</a>
<a name="ln3758"> </a>
<a name="ln3759">              getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;sc, NULL, NULL);</a>
<a name="ln3760">              curwin-&gt;w_cursor.col = regmatch.endpos[0].col - 1;</a>
<a name="ln3761">              if (curwin-&gt;w_cursor.col &lt; 0) {</a>
<a name="ln3762">                curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3763">              }</a>
<a name="ln3764">              getvcol(curwin, &amp;curwin-&gt;w_cursor, NULL, NULL, &amp;ec);</a>
<a name="ln3765">              if (subflags.do_number || curwin-&gt;w_p_nu) {</a>
<a name="ln3766">                int numw = number_width(curwin) + 1;</a>
<a name="ln3767">                sc += numw;</a>
<a name="ln3768">                ec += numw;</a>
<a name="ln3769">              }</a>
<a name="ln3770">              msg_start();</a>
<a name="ln3771">              for (i = 0; i &lt; (long)sc; ++i)</a>
<a name="ln3772">                msg_putchar(' ');</a>
<a name="ln3773">              for (; i &lt;= (long)ec; ++i)</a>
<a name="ln3774">                msg_putchar('^');</a>
<a name="ln3775"> </a>
<a name="ln3776">              resp = getexmodeline('?', NULL, 0, true);</a>
<a name="ln3777">              if (resp != NULL) {</a>
<a name="ln3778">                typed = *resp;</a>
<a name="ln3779">                xfree(resp);</a>
<a name="ln3780">              }</a>
<a name="ln3781">            } else {</a>
<a name="ln3782">              char_u *orig_line = NULL;</a>
<a name="ln3783">              int len_change = 0;</a>
<a name="ln3784">              const bool save_p_lz = p_lz;</a>
<a name="ln3785">              int save_p_fen = curwin-&gt;w_p_fen;</a>
<a name="ln3786"> </a>
<a name="ln3787">              curwin-&gt;w_p_fen = FALSE;</a>
<a name="ln3788">              /* Invert the matched string.</a>
<a name="ln3789">               * Remove the inversion afterwards. */</a>
<a name="ln3790">              int temp = RedrawingDisabled;</a>
<a name="ln3791">              RedrawingDisabled = 0;</a>
<a name="ln3792"> </a>
<a name="ln3793">              // avoid calling update_screen() in vgetorpeek()</a>
<a name="ln3794">              p_lz = false;</a>
<a name="ln3795"> </a>
<a name="ln3796">              if (new_start != NULL) {</a>
<a name="ln3797">                /* There already was a substitution, we would</a>
<a name="ln3798">                 * like to show this to the user.  We cannot</a>
<a name="ln3799">                 * really update the line, it would change</a>
<a name="ln3800">                 * what matches.  Temporarily replace the line</a>
<a name="ln3801">                 * and change it back afterwards. */</a>
<a name="ln3802">                orig_line = vim_strsave(ml_get(lnum));</a>
<a name="ln3803">                char_u *new_line = concat_str(new_start, sub_firstline + copycol);</a>
<a name="ln3804"> </a>
<a name="ln3805">                // Position the cursor relative to the end of the line, the</a>
<a name="ln3806">                // previous substitute may have inserted or deleted characters</a>
<a name="ln3807">                // before the cursor.</a>
<a name="ln3808">                len_change = (int)STRLEN(new_line) - (int)STRLEN(orig_line);</a>
<a name="ln3809">                curwin-&gt;w_cursor.col += len_change;</a>
<a name="ln3810">                ml_replace(lnum, new_line, false);</a>
<a name="ln3811">              }</a>
<a name="ln3812"> </a>
<a name="ln3813">              search_match_lines = regmatch.endpos[0].lnum</a>
<a name="ln3814">                                   - regmatch.startpos[0].lnum;</a>
<a name="ln3815">              search_match_endcol = regmatch.endpos[0].col</a>
<a name="ln3816">                                    + len_change;</a>
<a name="ln3817">              highlight_match = TRUE;</a>
<a name="ln3818"> </a>
<a name="ln3819">              update_topline(curwin);</a>
<a name="ln3820">              validate_cursor();</a>
<a name="ln3821">              update_screen(SOME_VALID);</a>
<a name="ln3822">              highlight_match = false;</a>
<a name="ln3823">              redraw_later(curwin, SOME_VALID);</a>
<a name="ln3824"> </a>
<a name="ln3825">              curwin-&gt;w_p_fen = save_p_fen;</a>
<a name="ln3826">              if (msg_row == Rows - 1)</a>
<a name="ln3827">                msg_didout = FALSE;                     /* avoid a scroll-up */</a>
<a name="ln3828">              msg_starthere();</a>
<a name="ln3829">              i = msg_scroll;</a>
<a name="ln3830">              msg_scroll = 0;                           /* truncate msg when</a>
<a name="ln3831">                                                           needed */</a>
<a name="ln3832">              msg_no_more = true;</a>
<a name="ln3833">              msg_ext_set_kind(&quot;confirm_sub&quot;);</a>
<a name="ln3834">              smsg_attr(HL_ATTR(HLF_R),  // Same highlight as wait_return().</a>
<a name="ln3835">                        _(&quot;replace with %s (y/n/a/q/l/^E/^Y)?&quot;), sub);</a>
<a name="ln3836">              msg_no_more = FALSE;</a>
<a name="ln3837">              msg_scroll = i;</a>
<a name="ln3838">              showruler(TRUE);</a>
<a name="ln3839">              ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln3840">              RedrawingDisabled = temp;</a>
<a name="ln3841"> </a>
<a name="ln3842">              no_mapping++;                     // don't map this key</a>
<a name="ln3843">              typed = plain_vgetc();</a>
<a name="ln3844">              no_mapping--;</a>
<a name="ln3845"> </a>
<a name="ln3846">              /* clear the question */</a>
<a name="ln3847">              msg_didout = FALSE;               /* don't scroll up */</a>
<a name="ln3848">              msg_col = 0;</a>
<a name="ln3849">              gotocmdline(true);</a>
<a name="ln3850">              p_lz = save_p_lz;</a>
<a name="ln3851"> </a>
<a name="ln3852">              // restore the line</a>
<a name="ln3853">              if (orig_line != NULL) {</a>
<a name="ln3854">                ml_replace(lnum, orig_line, false);</a>
<a name="ln3855">              }</a>
<a name="ln3856">            }</a>
<a name="ln3857"> </a>
<a name="ln3858">            need_wait_return = false;             // no hit-return prompt</a>
<a name="ln3859">            if (typed == 'q' || typed == ESC || typed == Ctrl_C) {</a>
<a name="ln3860">              got_quit = true;</a>
<a name="ln3861">              break;</a>
<a name="ln3862">            }</a>
<a name="ln3863">            if (typed == 'n')</a>
<a name="ln3864">              break;</a>
<a name="ln3865">            if (typed == 'y')</a>
<a name="ln3866">              break;</a>
<a name="ln3867">            if (typed == 'l') {</a>
<a name="ln3868">              // last: replace and then stop</a>
<a name="ln3869">              subflags.do_all = false;</a>
<a name="ln3870">              line2 = lnum;</a>
<a name="ln3871">              break;</a>
<a name="ln3872">            }</a>
<a name="ln3873">            if (typed == 'a') {</a>
<a name="ln3874">              subflags.do_ask = false;</a>
<a name="ln3875">              break;</a>
<a name="ln3876">            }</a>
<a name="ln3877">            if (typed == Ctrl_E)</a>
<a name="ln3878">              scrollup_clamp();</a>
<a name="ln3879">            else if (typed == Ctrl_Y)</a>
<a name="ln3880">              scrolldown_clamp();</a>
<a name="ln3881">          }</a>
<a name="ln3882">          State = save_State;</a>
<a name="ln3883">          setmouse();</a>
<a name="ln3884">          if (vim_strchr(p_cpo, CPO_UNDO) != NULL)</a>
<a name="ln3885">            --no_u_sync;</a>
<a name="ln3886"> </a>
<a name="ln3887">          if (typed == 'n') {</a>
<a name="ln3888">            /* For a multi-line match, put matchcol at the NUL at</a>
<a name="ln3889">             * the end of the line and set nmatch to one, so that</a>
<a name="ln3890">             * we continue looking for a match on the next line.</a>
<a name="ln3891">             * Avoids that &quot;:%s/\nB\@=//gc&quot; and &quot;:%s/\n/,\r/gc&quot;</a>
<a name="ln3892">             * get stuck when pressing 'n'. */</a>
<a name="ln3893">            if (nmatch &gt; 1) {</a>
<a name="ln3894">              matchcol = (colnr_T)STRLEN(sub_firstline);</a>
<a name="ln3895">              skip_match = true;</a>
<a name="ln3896">            }</a>
<a name="ln3897">            goto skip;</a>
<a name="ln3898">          }</a>
<a name="ln3899">          if (got_quit)</a>
<a name="ln3900">            goto skip;</a>
<a name="ln3901">        }</a>
<a name="ln3902"> </a>
<a name="ln3903">        /* Move the cursor to the start of the match, so that we can</a>
<a name="ln3904">         * use &quot;\=col(&quot;.&quot;). */</a>
<a name="ln3905">        curwin-&gt;w_cursor.col = regmatch.startpos[0].col;</a>
<a name="ln3906"> </a>
<a name="ln3907">        // When the match included the &quot;$&quot; of the last line it may</a>
<a name="ln3908">        // go beyond the last line of the buffer.</a>
<a name="ln3909">        if (nmatch &gt; curbuf-&gt;b_ml.ml_line_count - sub_firstlnum + 1) {</a>
<a name="ln3910">          nmatch = curbuf-&gt;b_ml.ml_line_count - sub_firstlnum + 1;</a>
<a name="ln3911">          current_match.end.lnum = sub_firstlnum + nmatch;</a>
<a name="ln3912">          skip_match = true;</a>
<a name="ln3913">        }</a>
<a name="ln3914"> </a>
<a name="ln3915">#define ADJUST_SUB_FIRSTLNUM() \</a>
<a name="ln3916">        do { \</a>
<a name="ln3917">          /* For a multi-line match, make a copy of the last matched */ \</a>
<a name="ln3918">          /* line and continue in that one. */ \</a>
<a name="ln3919">          if (nmatch &gt; 1) { \</a>
<a name="ln3920">            sub_firstlnum += nmatch - 1; \</a>
<a name="ln3921">            xfree(sub_firstline); \</a>
<a name="ln3922">            sub_firstline = vim_strsave(ml_get(sub_firstlnum)); \</a>
<a name="ln3923">            /* When going beyond the last line, stop substituting. */ \</a>
<a name="ln3924">            if (sub_firstlnum &lt;= line2) { \</a>
<a name="ln3925">              do_again = true; \</a>
<a name="ln3926">            } else { \</a>
<a name="ln3927">              subflags.do_all = false; \</a>
<a name="ln3928">            } \</a>
<a name="ln3929">          } \</a>
<a name="ln3930">          if (skip_match) { \</a>
<a name="ln3931">            /* Already hit end of the buffer, sub_firstlnum is one */ \</a>
<a name="ln3932">            /* less than what it ought to be. */ \</a>
<a name="ln3933">            xfree(sub_firstline); \</a>
<a name="ln3934">            sub_firstline = vim_strsave((char_u *)&quot;&quot;); \</a>
<a name="ln3935">            copycol = 0; \</a>
<a name="ln3936">          } \</a>
<a name="ln3937">        } while (0)</a>
<a name="ln3938"> </a>
<a name="ln3939">        // Save the line numbers for the preview buffer</a>
<a name="ln3940">        // NOTE: If the pattern matches a final newline, the next line will</a>
<a name="ln3941">        // be shown also, but should not be highlighted. Intentional for now.</a>
<a name="ln3942">        if (preview &amp;&amp; !has_second_delim) {</a>
<a name="ln3943">          current_match.start.col = regmatch.startpos[0].col;</a>
<a name="ln3944">          if (current_match.end.lnum == 0) {</a>
<a name="ln3945">            current_match.end.lnum = sub_firstlnum + nmatch - 1;</a>
<a name="ln3946">          }</a>
<a name="ln3947">          current_match.end.col  = regmatch.endpos[0].col;</a>
<a name="ln3948"> </a>
<a name="ln3949">          ADJUST_SUB_FIRSTLNUM();</a>
<a name="ln3950">          lnum += nmatch - 1;</a>
<a name="ln3951"> </a>
<a name="ln3952">          goto skip;</a>
<a name="ln3953">        }</a>
<a name="ln3954"> </a>
<a name="ln3955"> </a>
<a name="ln3956">        // 3. Substitute the string. During 'inccommand' preview only do this if</a>
<a name="ln3957">        //    there is a replace pattern.</a>
<a name="ln3958">        if (!preview || has_second_delim) {</a>
<a name="ln3959">          long lnum_start = lnum;  // save the start lnum</a>
<a name="ln3960">          save_ma = curbuf-&gt;b_p_ma;</a>
<a name="ln3961">          if (subflags.do_count) {</a>
<a name="ln3962">            // prevent accidentally changing the buffer by a function</a>
<a name="ln3963">            curbuf-&gt;b_p_ma = false;</a>
<a name="ln3964">            sandbox++;</a>
<a name="ln3965">          }</a>
<a name="ln3966">          // Save flags for recursion.  They can change for e.g.</a>
<a name="ln3967">          // :s/^/\=execute(&quot;s#^##gn&quot;)</a>
<a name="ln3968">          subflags_T subflags_save = subflags;</a>
<a name="ln3969">          // get length of substitution part</a>
<a name="ln3970">          sublen = vim_regsub_multi(&amp;regmatch,</a>
<a name="ln3971">                                    sub_firstlnum - regmatch.startpos[0].lnum,</a>
<a name="ln3972">                                    sub, sub_firstline, false, p_magic, true);</a>
<a name="ln3973">          // If getting the substitute string caused an error, don't do</a>
<a name="ln3974">          // the replacement.</a>
<a name="ln3975">          // Don't keep flags set by a recursive call</a>
<a name="ln3976">          subflags = subflags_save;</a>
<a name="ln3977">          if (aborting() || subflags.do_count) {</a>
<a name="ln3978">            curbuf-&gt;b_p_ma = save_ma;</a>
<a name="ln3979">            if (sandbox &gt; 0) {</a>
<a name="ln3980">              sandbox--;</a>
<a name="ln3981">            }</a>
<a name="ln3982">            goto skip;</a>
<a name="ln3983">          }</a>
<a name="ln3984"> </a>
<a name="ln3985">          // Need room for:</a>
<a name="ln3986">          // - result so far in new_start (not for first sub in line)</a>
<a name="ln3987">          // - original text up to match</a>
<a name="ln3988">          // - length of substituted part</a>
<a name="ln3989">          // - original text after match</a>
<a name="ln3990">          if (nmatch == 1) {</a>
<a name="ln3991">            p1 = sub_firstline;</a>
<a name="ln3992">          } else {</a>
<a name="ln3993">            p1 = ml_get(sub_firstlnum + nmatch - 1);</a>
<a name="ln3994">            nmatch_tl += nmatch - 1;</a>
<a name="ln3995">          }</a>
<a name="ln3996">          size_t copy_len = regmatch.startpos[0].col - copycol;</a>
<a name="ln3997">          new_end = sub_grow_buf(&amp;new_start,</a>
<a name="ln3998">                                 (STRLEN(p1) - regmatch.endpos[0].col)</a>
<a name="ln3999">                                 + copy_len + sublen + 1);</a>
<a name="ln4000"> </a>
<a name="ln4001">          // copy the text up to the part that matched</a>
<a name="ln4002">          memmove(new_end, sub_firstline + copycol, (size_t)copy_len);</a>
<a name="ln4003">          new_end += copy_len;</a>
<a name="ln4004"> </a>
<a name="ln4005">          // Finally, at this point we can know where the match actually will</a>
<a name="ln4006">          // start in the new text</a>
<a name="ln4007">          int start_col = new_end - new_start;</a>
<a name="ln4008">          current_match.start.col = start_col;</a>
<a name="ln4009"> </a>
<a name="ln4010">          (void)vim_regsub_multi(&amp;regmatch,</a>
<a name="ln4011">                                 sub_firstlnum - regmatch.startpos[0].lnum,</a>
<a name="ln4012">                                 sub, new_end, true, p_magic, true);</a>
<a name="ln4013">          sub_nsubs++;</a>
<a name="ln4014">          did_sub = true;</a>
<a name="ln4015"> </a>
<a name="ln4016">          // Move the cursor to the start of the line, to avoid that it</a>
<a name="ln4017">          // is beyond the end of the line after the substitution.</a>
<a name="ln4018">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln4019"> </a>
<a name="ln4020">          // Remember next character to be copied.</a>
<a name="ln4021">          copycol = regmatch.endpos[0].col;</a>
<a name="ln4022"> </a>
<a name="ln4023">          ADJUST_SUB_FIRSTLNUM();</a>
<a name="ln4024"> </a>
<a name="ln4025">          // TODO(bfredl): this has some robustness issues, look into later.</a>
<a name="ln4026">          bcount_t replaced_bytes = 0;</a>
<a name="ln4027">          lpos_T start = regmatch.startpos[0], end = regmatch.endpos[0];</a>
<a name="ln4028">          for (i = 0; i &lt; nmatch-1; i++) {</a>
<a name="ln4029">            replaced_bytes += STRLEN(ml_get(lnum_start+i)) + 1;</a>
<a name="ln4030">          }</a>
<a name="ln4031">          replaced_bytes += end.col - start.col;</a>
<a name="ln4032"> </a>
<a name="ln4033"> </a>
<a name="ln4034">          // Now the trick is to replace CTRL-M chars with a real line</a>
<a name="ln4035">          // break.  This would make it impossible to insert a CTRL-M in</a>
<a name="ln4036">          // the text.  The line break can be avoided by preceding the</a>
<a name="ln4037">          // CTRL-M with a backslash.  To be able to insert a backslash,</a>
<a name="ln4038">          // they must be doubled in the string and are halved here.</a>
<a name="ln4039">          // That is Vi compatible.</a>
<a name="ln4040">          for (p1 = new_end; *p1; p1++) {</a>
<a name="ln4041">            if (p1[0] == '\\' &amp;&amp; p1[1] != NUL) {            // remove backslash</a>
<a name="ln4042">              STRMOVE(p1, p1 + 1);</a>
<a name="ln4043">            } else if (*p1 == CAR) {</a>
<a name="ln4044">              if (u_inssub(lnum) == OK) {             // prepare for undo</a>
<a name="ln4045">                *p1 = NUL;                            // truncate up to the CR</a>
<a name="ln4046">                ml_append(lnum - 1, new_start,</a>
<a name="ln4047">                          (colnr_T)(p1 - new_start + 1), false);</a>
<a name="ln4048">                mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L, kExtmarkNOOP);</a>
<a name="ln4049"> </a>
<a name="ln4050">                if (subflags.do_ask) {</a>
<a name="ln4051">                  appended_lines(lnum - 1, 1L);</a>
<a name="ln4052">                } else {</a>
<a name="ln4053">                  if (first_line == 0) {</a>
<a name="ln4054">                    first_line = lnum;</a>
<a name="ln4055">                  }</a>
<a name="ln4056">                  last_line = lnum + 1;</a>
<a name="ln4057">                }</a>
<a name="ln4058">                // All line numbers increase.</a>
<a name="ln4059">                sub_firstlnum++;</a>
<a name="ln4060">                lnum++;</a>
<a name="ln4061">                line2++;</a>
<a name="ln4062">                // move the cursor to the new line, like Vi</a>
<a name="ln4063">                curwin-&gt;w_cursor.lnum++;</a>
<a name="ln4064">                // copy the rest</a>
<a name="ln4065">                STRMOVE(new_start, p1 + 1);</a>
<a name="ln4066">                p1 = new_start - 1;</a>
<a name="ln4067">              }</a>
<a name="ln4068">            } else {</a>
<a name="ln4069">              p1 += utfc_ptr2len(p1) - 1;</a>
<a name="ln4070">            }</a>
<a name="ln4071">          }</a>
<a name="ln4072">          size_t new_endcol = STRLEN(new_start);</a>
<a name="ln4073">          current_match.end.col = new_endcol;</a>
<a name="ln4074">          current_match.end.lnum = lnum;</a>
<a name="ln4075"> </a>
<a name="ln4076">          int matchcols = end.col - ((end.lnum == start.lnum)</a>
<a name="ln4077">                                     ? start.col : 0);</a>
<a name="ln4078">          int subcols = new_endcol - ((lnum == lnum_start) ? start_col : 0);</a>
<a name="ln4079">          if (!did_save) {</a>
<a name="ln4080">            // Required for Undo to work for extmarks.</a>
<a name="ln4081">            u_save_cursor();</a>
<a name="ln4082">            did_save = true;</a>
<a name="ln4083">          }</a>
<a name="ln4084">          extmark_splice(curbuf, lnum_start-1, start_col,</a>
<a name="ln4085">                         end.lnum-start.lnum, matchcols, replaced_bytes,</a>
<a name="ln4086">                         lnum-lnum_start, subcols, sublen-1, kExtmarkUndo);</a>
<a name="ln4087">        }</a>
<a name="ln4088"> </a>
<a name="ln4089"> </a>
<a name="ln4090">        // 4. If subflags.do_all is set, find next match.</a>
<a name="ln4091">        // Prevent endless loop with patterns that match empty</a>
<a name="ln4092">        // strings, e.g. :s/$/pat/g or :s/[a-z]* /(&amp;)/g.</a>
<a name="ln4093">        // But &quot;:s/\n/#/&quot; is OK.</a>
<a name="ln4094">skip:</a>
<a name="ln4095">        /* We already know that we did the last subst when we are at</a>
<a name="ln4096">         * the end of the line, except that a pattern like</a>
<a name="ln4097">         * &quot;bar\|\nfoo&quot; may match at the NUL.  &quot;lnum&quot; can be below</a>
<a name="ln4098">         * &quot;line2&quot; when there is a \zs in the pattern after a line</a>
<a name="ln4099">         * break. */</a>
<a name="ln4100">        lastone = (skip_match</a>
<a name="ln4101">                   || got_int</a>
<a name="ln4102">                   || got_quit</a>
<a name="ln4103">                   || lnum &gt; line2</a>
<a name="ln4104">                   || !(subflags.do_all || do_again)</a>
<a name="ln4105">                   || (sub_firstline[matchcol] == NUL &amp;&amp; nmatch &lt;= 1</a>
<a name="ln4106">                       &amp;&amp; !re_multiline(regmatch.regprog)));</a>
<a name="ln4107">        nmatch = -1;</a>
<a name="ln4108"> </a>
<a name="ln4109">        /*</a>
<a name="ln4110">         * Replace the line in the buffer when needed.  This is</a>
<a name="ln4111">         * skipped when there are more matches.</a>
<a name="ln4112">         * The check for nmatch_tl is needed for when multi-line</a>
<a name="ln4113">         * matching must replace the lines before trying to do another</a>
<a name="ln4114">         * match, otherwise &quot;\@&lt;=&quot; won't work.</a>
<a name="ln4115">         * When the match starts below where we start searching also</a>
<a name="ln4116">         * need to replace the line first (using \zs after \n).</a>
<a name="ln4117">         */</a>
<a name="ln4118">        if (lastone</a>
<a name="ln4119">            || nmatch_tl &gt; 0</a>
<a name="ln4120">            || (nmatch = vim_regexec_multi(&amp;regmatch, curwin,</a>
<a name="ln4121">                                           curbuf, sub_firstlnum,</a>
<a name="ln4122">                                           matchcol, NULL, NULL)) == 0</a>
<a name="ln4123">            || regmatch.startpos[0].lnum &gt; 0) {</a>
<a name="ln4124">          if (new_start != NULL) {</a>
<a name="ln4125">            /*</a>
<a name="ln4126">             * Copy the rest of the line, that didn't match.</a>
<a name="ln4127">             * &quot;matchcol&quot; has to be adjusted, we use the end of</a>
<a name="ln4128">             * the line as reference, because the substitute may</a>
<a name="ln4129">             * have changed the number of characters.  Same for</a>
<a name="ln4130">             * &quot;prev_matchcol&quot;.</a>
<a name="ln4131">             */</a>
<a name="ln4132">            STRCAT(new_start, sub_firstline + copycol);</a>
<a name="ln4133">            matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;</a>
<a name="ln4134">            prev_matchcol = (colnr_T)STRLEN(sub_firstline)</a>
<a name="ln4135">                            - prev_matchcol;</a>
<a name="ln4136"> </a>
<a name="ln4137">            if (u_savesub(lnum) != OK) {</a>
<a name="ln4138">              break;</a>
<a name="ln4139">            }</a>
<a name="ln4140">            ml_replace(lnum, new_start, true);</a>
<a name="ln4141"> </a>
<a name="ln4142">            if (nmatch_tl &gt; 0) {</a>
<a name="ln4143">              /*</a>
<a name="ln4144">               * Matched lines have now been substituted and are</a>
<a name="ln4145">               * useless, delete them.  The part after the match</a>
<a name="ln4146">               * has been appended to new_start, we don't need</a>
<a name="ln4147">               * it in the buffer.</a>
<a name="ln4148">               */</a>
<a name="ln4149">              ++lnum;</a>
<a name="ln4150">              if (u_savedel(lnum, nmatch_tl) != OK)</a>
<a name="ln4151">                break;</a>
<a name="ln4152">              for (i = 0; i &lt; nmatch_tl; i++) {</a>
<a name="ln4153">                ml_delete(lnum, false);</a>
<a name="ln4154">              }</a>
<a name="ln4155">              mark_adjust(lnum, lnum + nmatch_tl - 1,</a>
<a name="ln4156">                          (long)MAXLNUM, -nmatch_tl, kExtmarkNOOP);</a>
<a name="ln4157">              if (subflags.do_ask) {</a>
<a name="ln4158">                deleted_lines(lnum, nmatch_tl);</a>
<a name="ln4159">              }</a>
<a name="ln4160">              lnum--;</a>
<a name="ln4161">              line2 -= nmatch_tl;  // nr of lines decreases</a>
<a name="ln4162">              nmatch_tl = 0;</a>
<a name="ln4163">            }</a>
<a name="ln4164"> </a>
<a name="ln4165">            /* When asking, undo is saved each time, must also set</a>
<a name="ln4166">             * changed flag each time. */</a>
<a name="ln4167">            if (subflags.do_ask) {</a>
<a name="ln4168">              changed_bytes(lnum, 0);</a>
<a name="ln4169">            } else {</a>
<a name="ln4170">              if (first_line == 0) {</a>
<a name="ln4171">                first_line = lnum;</a>
<a name="ln4172">              }</a>
<a name="ln4173">              last_line = lnum + 1;</a>
<a name="ln4174">            }</a>
<a name="ln4175"> </a>
<a name="ln4176">            sub_firstlnum = lnum;</a>
<a name="ln4177">            xfree(sub_firstline);                /* free the temp buffer */</a>
<a name="ln4178">            sub_firstline = new_start;</a>
<a name="ln4179">            new_start = NULL;</a>
<a name="ln4180">            matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;</a>
<a name="ln4181">            prev_matchcol = (colnr_T)STRLEN(sub_firstline)</a>
<a name="ln4182">                            - prev_matchcol;</a>
<a name="ln4183">            copycol = 0;</a>
<a name="ln4184">          }</a>
<a name="ln4185">          if (nmatch == -1 &amp;&amp; !lastone)</a>
<a name="ln4186">            nmatch = vim_regexec_multi(&amp;regmatch, curwin, curbuf,</a>
<a name="ln4187">                                       sub_firstlnum, matchcol, NULL, NULL);</a>
<a name="ln4188"> </a>
<a name="ln4189">          /*</a>
<a name="ln4190">           * 5. break if there isn't another match in this line</a>
<a name="ln4191">           */</a>
<a name="ln4192">          if (nmatch &lt;= 0) {</a>
<a name="ln4193">            /* If the match found didn't start where we were</a>
<a name="ln4194">             * searching, do the next search in the line where we</a>
<a name="ln4195">             * found the match. */</a>
<a name="ln4196">            if (nmatch == -1)</a>
<a name="ln4197">              lnum -= regmatch.startpos[0].lnum;</a>
<a name="ln4198"> </a>
<a name="ln4199">#define PUSH_PREVIEW_LINES() \</a>
<a name="ln4200">            do { \</a>
<a name="ln4201">              linenr_T match_lines = current_match.end.lnum \</a>
<a name="ln4202">                                     - current_match.start.lnum +1; \</a>
<a name="ln4203">              if (preview_lines.subresults.size &gt; 0) { \</a>
<a name="ln4204">                linenr_T last = kv_last(preview_lines.subresults).end.lnum; \</a>
<a name="ln4205">                if (last == current_match.start.lnum) { \</a>
<a name="ln4206">                  preview_lines.lines_needed += match_lines - 1; \</a>
<a name="ln4207">                } \</a>
<a name="ln4208">              } else { \</a>
<a name="ln4209">                preview_lines.lines_needed += match_lines; \</a>
<a name="ln4210">              } \</a>
<a name="ln4211">              kv_push(preview_lines.subresults, current_match); \</a>
<a name="ln4212">            } while (0)</a>
<a name="ln4213"> </a>
<a name="ln4214">            // Push the match to preview_lines.</a>
<a name="ln4215">            PUSH_PREVIEW_LINES();</a>
<a name="ln4216"> </a>
<a name="ln4217">            break;</a>
<a name="ln4218">          }</a>
<a name="ln4219">        }</a>
<a name="ln4220">        // Push the match to preview_lines.</a>
<a name="ln4221">        PUSH_PREVIEW_LINES();</a>
<a name="ln4222"> </a>
<a name="ln4223">        line_breakcheck();</a>
<a name="ln4224">      }</a>
<a name="ln4225"> </a>
<a name="ln4226">      if (did_sub) {</a>
<a name="ln4227">        sub_nlines++;</a>
<a name="ln4228">      }</a>
<a name="ln4229">      xfree(new_start);              // for when substitute was cancelled</a>
<a name="ln4230">      XFREE_CLEAR(sub_firstline);    // free the copy of the original line</a>
<a name="ln4231">    }</a>
<a name="ln4232"> </a>
<a name="ln4233">    line_breakcheck();</a>
<a name="ln4234"> </a>
<a name="ln4235">    if (profile_passed_limit(timeout)) {</a>
<a name="ln4236">      got_quit = true;</a>
<a name="ln4237">    }</a>
<a name="ln4238">  }</a>
<a name="ln4239"> </a>
<a name="ln4240">  curbuf-&gt;deleted_bytes2 = 0;</a>
<a name="ln4241"> </a>
<a name="ln4242">  if (first_line != 0) {</a>
<a name="ln4243">    /* Need to subtract the number of added lines from &quot;last_line&quot; to get</a>
<a name="ln4244">     * the line number before the change (same as adding the number of</a>
<a name="ln4245">     * deleted lines). */</a>
<a name="ln4246">    i = curbuf-&gt;b_ml.ml_line_count - old_line_count;</a>
<a name="ln4247">    changed_lines(first_line, 0, last_line - i, i, false);</a>
<a name="ln4248"> </a>
<a name="ln4249">    int64_t num_added = last_line - first_line;</a>
<a name="ln4250">    int64_t num_removed = num_added - i;</a>
<a name="ln4251">    buf_updates_send_changes(curbuf, first_line, num_added, num_removed,</a>
<a name="ln4252">                             do_buf_event);</a>
<a name="ln4253">  }</a>
<a name="ln4254"> </a>
<a name="ln4255">  xfree(sub_firstline);   /* may have to free allocated copy of the line */</a>
<a name="ln4256"> </a>
<a name="ln4257">  // &quot;:s/pat//n&quot; doesn't move the cursor</a>
<a name="ln4258">  if (subflags.do_count) {</a>
<a name="ln4259">    curwin-&gt;w_cursor = old_cursor;</a>
<a name="ln4260">  }</a>
<a name="ln4261"> </a>
<a name="ln4262">  if (sub_nsubs &gt; start_nsubs) {</a>
<a name="ln4263">    /* Set the '[ and '] marks. */</a>
<a name="ln4264">    curbuf-&gt;b_op_start.lnum = eap-&gt;line1;</a>
<a name="ln4265">    curbuf-&gt;b_op_end.lnum = line2;</a>
<a name="ln4266">    curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln4267"> </a>
<a name="ln4268">    if (!global_busy) {</a>
<a name="ln4269">      // when interactive leave cursor on the match</a>
<a name="ln4270">      if (!subflags.do_ask) {</a>
<a name="ln4271">        if (endcolumn) {</a>
<a name="ln4272">          coladvance(MAXCOL);</a>
<a name="ln4273">        } else {</a>
<a name="ln4274">          beginline(BL_WHITE | BL_FIX);</a>
<a name="ln4275">        }</a>
<a name="ln4276">      }</a>
<a name="ln4277">      if (!preview &amp;&amp; !do_sub_msg(subflags.do_count) &amp;&amp; subflags.do_ask) {</a>
<a name="ln4278">        MSG(&quot;&quot;);</a>
<a name="ln4279">      }</a>
<a name="ln4280">    } else {</a>
<a name="ln4281">      global_need_beginline = true;</a>
<a name="ln4282">    }</a>
<a name="ln4283">    if (subflags.do_print) {</a>
<a name="ln4284">      print_line(curwin-&gt;w_cursor.lnum, subflags.do_number, subflags.do_list);</a>
<a name="ln4285">    }</a>
<a name="ln4286">  } else if (!global_busy) {</a>
<a name="ln4287">    if (got_int) {</a>
<a name="ln4288">      // interrupted</a>
<a name="ln4289">      EMSG(_(e_interr));</a>
<a name="ln4290">    } else if (got_match) {</a>
<a name="ln4291">      // did find something but nothing substituted</a>
<a name="ln4292">      MSG(&quot;&quot;);</a>
<a name="ln4293">    } else if (subflags.do_error) {</a>
<a name="ln4294">      // nothing found</a>
<a name="ln4295">      EMSG2(_(e_patnotf2), get_search_pat());</a>
<a name="ln4296">    }</a>
<a name="ln4297">  }</a>
<a name="ln4298"> </a>
<a name="ln4299">  if (subflags.do_ask &amp;&amp; hasAnyFolding(curwin)) {</a>
<a name="ln4300">    // Cursor position may require updating</a>
<a name="ln4301">    changed_window_setting();</a>
<a name="ln4302">  }</a>
<a name="ln4303"> </a>
<a name="ln4304">  vim_regfree(regmatch.regprog);</a>
<a name="ln4305"> </a>
<a name="ln4306">  // Restore the flag values, they can be used for &quot;:&amp;&amp;&quot;.</a>
<a name="ln4307">  subflags.do_all = save_do_all;</a>
<a name="ln4308">  subflags.do_ask = save_do_ask;</a>
<a name="ln4309"> </a>
<a name="ln4310">  // Show 'inccommand' preview if there are matched lines.</a>
<a name="ln4311">  buf_T *preview_buf = NULL;</a>
<a name="ln4312">  size_t subsize = preview_lines.subresults.size;</a>
<a name="ln4313">  if (preview &amp;&amp; !aborting()) {</a>
<a name="ln4314">    if (got_quit || profile_passed_limit(timeout)) {  // Too slow, disable.</a>
<a name="ln4315">      set_string_option_direct(&quot;icm&quot;, -1, (char_u *)&quot;&quot;, OPT_FREE,</a>
<a name="ln4316">                               SID_NONE);</a>
<a name="ln4317">    } else if (*p_icm != NUL &amp;&amp;  pat != NULL) {</a>
<a name="ln4318">      if (pre_src_id == 0) {</a>
<a name="ln4319">        // Get a unique new src_id, saved in a static</a>
<a name="ln4320">        pre_src_id = (int)nvim_create_namespace((String)STRING_INIT);</a>
<a name="ln4321">      }</a>
<a name="ln4322">      if (pre_hl_id == 0) {</a>
<a name="ln4323">        pre_hl_id = syn_check_group((char_u *)S_LEN(&quot;Substitute&quot;));</a>
<a name="ln4324">      }</a>
<a name="ln4325">      curbuf-&gt;b_changed = save_b_changed;  // preserve 'modified' during preview</a>
<a name="ln4326">      preview_buf = show_sub(eap, old_cursor, &amp;preview_lines,</a>
<a name="ln4327">                             pre_hl_id, pre_src_id, bufnr);</a>
<a name="ln4328">      if (subsize &gt; 0) {</a>
<a name="ln4329">        extmark_clear(orig_buf, pre_src_id, eap-&gt;line1-1, 0,</a>
<a name="ln4330">                      kv_last(preview_lines.subresults).end.lnum-1, MAXCOL);</a>
<a name="ln4331">      }</a>
<a name="ln4332">    }</a>
<a name="ln4333">  }</a>
<a name="ln4334"> </a>
<a name="ln4335">  kv_destroy(preview_lines.subresults);</a>
<a name="ln4336"> </a>
<a name="ln4337">  return preview_buf;</a>
<a name="ln4338">#undef ADJUST_SUB_FIRSTLNUM</a>
<a name="ln4339">#undef PUSH_PREVIEW_LINES</a>
<a name="ln4340">}  // NOLINT(readability/fn_size)</a>
<a name="ln4341"> </a>
<a name="ln4342">/*</a>
<a name="ln4343"> * Give message for number of substitutions.</a>
<a name="ln4344"> * Can also be used after a &quot;:global&quot; command.</a>
<a name="ln4345"> * Return TRUE if a message was given.</a>
<a name="ln4346"> */</a>
<a name="ln4347">bool</a>
<a name="ln4348">do_sub_msg (</a>
<a name="ln4349">    bool count_only                /* used 'n' flag for &quot;:s&quot; */</a>
<a name="ln4350">)</a>
<a name="ln4351">{</a>
<a name="ln4352">  /*</a>
<a name="ln4353">   * Only report substitutions when:</a>
<a name="ln4354">   * - more than 'report' substitutions</a>
<a name="ln4355">   * - command was typed by user, or number of changed lines &gt; 'report'</a>
<a name="ln4356">   * - giving messages is not disabled by 'lazyredraw'</a>
<a name="ln4357">   */</a>
<a name="ln4358">  if (((sub_nsubs &gt; p_report &amp;&amp; (KeyTyped || sub_nlines &gt; 1 || p_report &lt; 1))</a>
<a name="ln4359">       || count_only)</a>
<a name="ln4360">      &amp;&amp; messaging()) {</a>
<a name="ln4361">    if (got_int)</a>
<a name="ln4362">      STRCPY(msg_buf, _(&quot;(Interrupted) &quot;));</a>
<a name="ln4363">    else</a>
<a name="ln4364">      *msg_buf = NUL;</a>
<a name="ln4365">    if (sub_nsubs == 1)</a>
<a name="ln4366">      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),</a>
<a name="ln4367">          &quot;%s&quot;, count_only ? _(&quot;1 match&quot;) : _(&quot;1 substitution&quot;));</a>
<a name="ln4368">    else</a>
<a name="ln4369">      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),</a>
<a name="ln4370">          count_only ? _(&quot;%&quot; PRId64 &quot; matches&quot;)</a>
<a name="ln4371">                     : _(&quot;%&quot; PRId64 &quot; substitutions&quot;),</a>
<a name="ln4372">          (int64_t)sub_nsubs);</a>
<a name="ln4373">    if (sub_nlines == 1)</a>
<a name="ln4374">      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),</a>
<a name="ln4375">          &quot;%s&quot;, _(&quot; on 1 line&quot;));</a>
<a name="ln4376">    else</a>
<a name="ln4377">      vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),</a>
<a name="ln4378">          _(&quot; on %&quot; PRId64 &quot; lines&quot;), (int64_t)sub_nlines);</a>
<a name="ln4379">    if (msg(msg_buf))</a>
<a name="ln4380">      /* save message to display it after redraw */</a>
<a name="ln4381">      set_keep_msg(msg_buf, 0);</a>
<a name="ln4382">    return true;</a>
<a name="ln4383">  }</a>
<a name="ln4384">  if (got_int) {</a>
<a name="ln4385">    EMSG(_(e_interr));</a>
<a name="ln4386">    return true;</a>
<a name="ln4387">  }</a>
<a name="ln4388">  return false;</a>
<a name="ln4389">}</a>
<a name="ln4390"> </a>
<a name="ln4391">static void global_exe_one(char_u *const cmd, const linenr_T lnum)</a>
<a name="ln4392">{</a>
<a name="ln4393">  curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln4394">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln4395">  if (*cmd == NUL || *cmd == '\n') {</a>
<a name="ln4396">    do_cmdline((char_u *)&quot;p&quot;, NULL, NULL, DOCMD_NOWAIT);</a>
<a name="ln4397">  } else {</a>
<a name="ln4398">    do_cmdline(cmd, NULL, NULL, DOCMD_NOWAIT);</a>
<a name="ln4399">  }</a>
<a name="ln4400">}</a>
<a name="ln4401"> </a>
<a name="ln4402">/*</a>
<a name="ln4403"> * Execute a global command of the form:</a>
<a name="ln4404"> *</a>
<a name="ln4405"> * g/pattern/X : execute X on all lines where pattern matches</a>
<a name="ln4406"> * v/pattern/X : execute X on all lines where pattern does not match</a>
<a name="ln4407"> *</a>
<a name="ln4408"> * where 'X' is an EX command</a>
<a name="ln4409"> *</a>
<a name="ln4410"> * The command character (as well as the trailing slash) is optional, and</a>
<a name="ln4411"> * is assumed to be 'p' if missing.</a>
<a name="ln4412"> *</a>
<a name="ln4413"> * This is implemented in two passes: first we scan the file for the pattern and</a>
<a name="ln4414"> * set a mark for each line that (not) matches. Secondly we execute the command</a>
<a name="ln4415"> * for each line that has a mark. This is required because after deleting</a>
<a name="ln4416"> * lines we do not know where to search for the next match.</a>
<a name="ln4417"> */</a>
<a name="ln4418">void ex_global(exarg_T *eap)</a>
<a name="ln4419">{</a>
<a name="ln4420">  linenr_T lnum;                /* line number according to old situation */</a>
<a name="ln4421">  int ndone = 0;</a>
<a name="ln4422">  int type;                     /* first char of cmd: 'v' or 'g' */</a>
<a name="ln4423">  char_u      *cmd;             /* command argument */</a>
<a name="ln4424"> </a>
<a name="ln4425">  char_u delim;                 /* delimiter, normally '/' */</a>
<a name="ln4426">  char_u      *pat;</a>
<a name="ln4427">  regmmatch_T regmatch;</a>
<a name="ln4428">  int match;</a>
<a name="ln4429">  int which_pat;</a>
<a name="ln4430"> </a>
<a name="ln4431">  // When nesting the command works on one line.  This allows for</a>
<a name="ln4432">  // &quot;:g/found/v/notfound/command&quot;.</a>
<a name="ln4433">  if (global_busy &amp;&amp; (eap-&gt;line1 != 1</a>
<a name="ln4434">                      || eap-&gt;line2 != curbuf-&gt;b_ml.ml_line_count)) {</a>
<a name="ln4435">    // will increment global_busy to break out of the loop</a>
<a name="ln4436">    EMSG(_(&quot;E147: Cannot do :global recursive with a range&quot;));</a>
<a name="ln4437">    return;</a>
<a name="ln4438">  }</a>
<a name="ln4439"> </a>
<a name="ln4440">  if (eap-&gt;forceit)                 /* &quot;:global!&quot; is like &quot;:vglobal&quot; */</a>
<a name="ln4441">    type = 'v';</a>
<a name="ln4442">  else</a>
<a name="ln4443">    type = *eap-&gt;cmd;</a>
<a name="ln4444">  cmd = eap-&gt;arg;</a>
<a name="ln4445">  which_pat = RE_LAST;              /* default: use last used regexp */</a>
<a name="ln4446"> </a>
<a name="ln4447">  /*</a>
<a name="ln4448">   * undocumented vi feature:</a>
<a name="ln4449">   *	&quot;\/&quot; and &quot;\?&quot;: use previous search pattern.</a>
<a name="ln4450">   *		 &quot;\&amp;&quot;: use previous substitute pattern.</a>
<a name="ln4451">   */</a>
<a name="ln4452">  if (*cmd == '\\') {</a>
<a name="ln4453">    ++cmd;</a>
<a name="ln4454">    if (vim_strchr((char_u *)&quot;/?&amp;&quot;, *cmd) == NULL) {</a>
<a name="ln4455">      EMSG(_(e_backslash));</a>
<a name="ln4456">      return;</a>
<a name="ln4457">    }</a>
<a name="ln4458">    if (*cmd == '&amp;')</a>
<a name="ln4459">      which_pat = RE_SUBST;             /* use previous substitute pattern */</a>
<a name="ln4460">    else</a>
<a name="ln4461">      which_pat = RE_SEARCH;            /* use previous search pattern */</a>
<a name="ln4462">    ++cmd;</a>
<a name="ln4463">    pat = (char_u *)&quot;&quot;;</a>
<a name="ln4464">  } else if (*cmd == NUL) {</a>
<a name="ln4465">    EMSG(_(&quot;E148: Regular expression missing from global&quot;));</a>
<a name="ln4466">    return;</a>
<a name="ln4467">  } else if (check_regexp_delim(*cmd) == FAIL) {</a>
<a name="ln4468">    return;</a>
<a name="ln4469">  } else {</a>
<a name="ln4470">    delim = *cmd;               /* get the delimiter */</a>
<a name="ln4471">    if (delim)</a>
<a name="ln4472">      ++cmd;                    /* skip delimiter if there is one */</a>
<a name="ln4473">    pat = cmd;                  /* remember start of pattern */</a>
<a name="ln4474">    cmd = skip_regexp(cmd, delim, p_magic, &amp;eap-&gt;arg);</a>
<a name="ln4475">    if (cmd[0] == delim)                    /* end delimiter found */</a>
<a name="ln4476">      *cmd++ = NUL;                         /* replace it with a NUL */</a>
<a name="ln4477">  }</a>
<a name="ln4478"> </a>
<a name="ln4479">  if (search_regcomp(pat, RE_BOTH, which_pat, SEARCH_HIS, &amp;regmatch) == FAIL) {</a>
<a name="ln4480">    EMSG(_(e_invcmd));</a>
<a name="ln4481">    return;</a>
<a name="ln4482">  }</a>
<a name="ln4483"> </a>
<a name="ln4484">  if (global_busy) {</a>
<a name="ln4485">    lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4486">    match = vim_regexec_multi(&amp;regmatch, curwin, curbuf, lnum,</a>
<a name="ln4487">                              (colnr_T)0, NULL, NULL);</a>
<a name="ln4488">    if ((type == 'g' &amp;&amp; match) || (type == 'v' &amp;&amp; !match)) {</a>
<a name="ln4489">      global_exe_one(cmd, lnum);</a>
<a name="ln4490">    }</a>
<a name="ln4491">  } else {</a>
<a name="ln4492">    // pass 1: set marks for each (not) matching line</a>
<a name="ln4493">    for (lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2 &amp;&amp; !got_int; lnum++) {</a>
<a name="ln4494">      // a match on this line?</a>
<a name="ln4495">      match = vim_regexec_multi(&amp;regmatch, curwin, curbuf, lnum,</a>
<a name="ln4496">                                (colnr_T)0, NULL, NULL);</a>
<a name="ln4497">      if ((type == 'g' &amp;&amp; match) || (type == 'v' &amp;&amp; !match)) {</a>
<a name="ln4498">        ml_setmarked(lnum);</a>
<a name="ln4499">        ndone++;</a>
<a name="ln4500">      }</a>
<a name="ln4501">      line_breakcheck();</a>
<a name="ln4502">    }</a>
<a name="ln4503"> </a>
<a name="ln4504">    // pass 2: execute the command for each line that has been marked</a>
<a name="ln4505">    if (got_int) {</a>
<a name="ln4506">      MSG(_(e_interr));</a>
<a name="ln4507">    } else if (ndone == 0) {</a>
<a name="ln4508">      if (type == 'v') {</a>
<a name="ln4509">        smsg(_(&quot;Pattern found in every line: %s&quot;), pat);</a>
<a name="ln4510">      } else {</a>
<a name="ln4511">        smsg(_(&quot;Pattern not found: %s&quot;), pat);</a>
<a name="ln4512">      }</a>
<a name="ln4513">    } else {</a>
<a name="ln4514">      global_exe(cmd);</a>
<a name="ln4515">    }</a>
<a name="ln4516">    ml_clearmarked();         // clear rest of the marks</a>
<a name="ln4517">  }</a>
<a name="ln4518">  vim_regfree(regmatch.regprog);</a>
<a name="ln4519">}</a>
<a name="ln4520"> </a>
<a name="ln4521">/// Execute `cmd` on lines marked with ml_setmarked().</a>
<a name="ln4522">void global_exe(char_u *cmd)</a>
<a name="ln4523">{</a>
<a name="ln4524">  linenr_T old_lcount;      // b_ml.ml_line_count before the command</a>
<a name="ln4525">  buf_T *old_buf = curbuf;  // remember what buffer we started in</a>
<a name="ln4526">  linenr_T lnum;            // line number according to old situation</a>
<a name="ln4527">  int save_mapped_ctrl_c = mapped_ctrl_c;</a>
<a name="ln4528"> </a>
<a name="ln4529">  // Set current position only once for a global command.</a>
<a name="ln4530">  // If global_busy is set, setpcmark() will not do anything.</a>
<a name="ln4531">  // If there is an error, global_busy will be incremented.</a>
<a name="ln4532">  setpcmark();</a>
<a name="ln4533"> </a>
<a name="ln4534">  // When the command writes a message, don't overwrite the command.</a>
<a name="ln4535">  msg_didout = true;</a>
<a name="ln4536">  // Disable CTRL-C mapping, let it interrupt (potentially long output).</a>
<a name="ln4537">  mapped_ctrl_c = 0;</a>
<a name="ln4538"> </a>
<a name="ln4539">  sub_nsubs = 0;</a>
<a name="ln4540">  sub_nlines = 0;</a>
<a name="ln4541">  global_need_beginline = false;</a>
<a name="ln4542">  global_busy = 1;</a>
<a name="ln4543">  old_lcount = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4544"> </a>
<a name="ln4545">  while (!got_int &amp;&amp; (lnum = ml_firstmarked()) != 0 &amp;&amp; global_busy == 1) {</a>
<a name="ln4546">    global_exe_one(cmd, lnum);</a>
<a name="ln4547">    os_breakcheck();</a>
<a name="ln4548">  }</a>
<a name="ln4549"> </a>
<a name="ln4550">  mapped_ctrl_c = save_mapped_ctrl_c;</a>
<a name="ln4551">  global_busy = 0;</a>
<a name="ln4552">  if (global_need_beginline) {</a>
<a name="ln4553">    beginline(BL_WHITE | BL_FIX);</a>
<a name="ln4554">  } else {</a>
<a name="ln4555">    check_cursor();  // cursor may be beyond the end of the line</a>
<a name="ln4556">  }</a>
<a name="ln4557"> </a>
<a name="ln4558">  // the cursor may not have moved in the text but a change in a previous</a>
<a name="ln4559">  // line may move it on the screen</a>
<a name="ln4560">  changed_line_abv_curs();</a>
<a name="ln4561"> </a>
<a name="ln4562">  // If it looks like no message was written, allow overwriting the</a>
<a name="ln4563">  // command with the report for number of changes.</a>
<a name="ln4564">  if (msg_col == 0 &amp;&amp; msg_scrolled == 0) {</a>
<a name="ln4565">    msg_didout = false;</a>
<a name="ln4566">  }</a>
<a name="ln4567"> </a>
<a name="ln4568">  // If substitutes done, report number of substitutes, otherwise report</a>
<a name="ln4569">  // number of extra or deleted lines.</a>
<a name="ln4570">  // Don't report extra or deleted lines in the edge case where the buffer</a>
<a name="ln4571">  // we are in after execution is different from the buffer we started in.</a>
<a name="ln4572">  if (!do_sub_msg(false) &amp;&amp; curbuf == old_buf) {</a>
<a name="ln4573">    msgmore(curbuf-&gt;b_ml.ml_line_count - old_lcount);</a>
<a name="ln4574">  }</a>
<a name="ln4575">}</a>
<a name="ln4576"> </a>
<a name="ln4577">#if defined(EXITFREE)</a>
<a name="ln4578">void free_old_sub(void)</a>
<a name="ln4579">{</a>
<a name="ln4580">  sub_set_replacement((SubReplacementString) {NULL, 0, NULL});</a>
<a name="ln4581">}</a>
<a name="ln4582"> </a>
<a name="ln4583">#endif</a>
<a name="ln4584"> </a>
<a name="ln4585">/*</a>
<a name="ln4586"> * Set up for a tagpreview.</a>
<a name="ln4587"> * Return TRUE when it was created.</a>
<a name="ln4588"> */</a>
<a name="ln4589">bool</a>
<a name="ln4590">prepare_tagpreview (</a>
<a name="ln4591">    bool undo_sync                  /* sync undo when leaving the window */</a>
<a name="ln4592">)</a>
<a name="ln4593">{</a>
<a name="ln4594">  /*</a>
<a name="ln4595">   * If there is already a preview window open, use that one.</a>
<a name="ln4596">   */</a>
<a name="ln4597">  if (!curwin-&gt;w_p_pvw) {</a>
<a name="ln4598">    bool found_win = false;</a>
<a name="ln4599">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4600">      if (wp-&gt;w_p_pvw) {</a>
<a name="ln4601">        win_enter(wp, undo_sync);</a>
<a name="ln4602">        found_win = true;</a>
<a name="ln4603">        break;</a>
<a name="ln4604">      }</a>
<a name="ln4605">    }</a>
<a name="ln4606">    if (!found_win) {</a>
<a name="ln4607">      /*</a>
<a name="ln4608">       * There is no preview window open yet.  Create one.</a>
<a name="ln4609">       */</a>
<a name="ln4610">      if (win_split(g_do_tagpreview &gt; 0 ? g_do_tagpreview : 0, 0)</a>
<a name="ln4611">          == FAIL)</a>
<a name="ln4612">        return false;</a>
<a name="ln4613">      curwin-&gt;w_p_pvw = TRUE;</a>
<a name="ln4614">      curwin-&gt;w_p_wfh = TRUE;</a>
<a name="ln4615">      RESET_BINDING(curwin);                /* don't take over 'scrollbind'</a>
<a name="ln4616">                                               and 'cursorbind' */</a>
<a name="ln4617">      curwin-&gt;w_p_diff = false;             // no 'diff'</a>
<a name="ln4618">      set_string_option_direct(&quot;fdc&quot;, -1,     // no 'foldcolumn'</a>
<a name="ln4619">                               (char_u *)&quot;0&quot;, OPT_FREE, SID_NONE);</a>
<a name="ln4620">      return true;</a>
<a name="ln4621">    }</a>
<a name="ln4622">  }</a>
<a name="ln4623">  return false;</a>
<a name="ln4624">}</a>
<a name="ln4625"> </a>
<a name="ln4626"> </a>
<a name="ln4627"> </a>
<a name="ln4628">/*</a>
<a name="ln4629"> * &quot;:help&quot;: open a read-only window on a help file</a>
<a name="ln4630"> */</a>
<a name="ln4631">void ex_help(exarg_T *eap)</a>
<a name="ln4632">{</a>
<a name="ln4633">  char_u      *arg;</a>
<a name="ln4634">  char_u      *tag;</a>
<a name="ln4635">  FILE        *helpfd;          /* file descriptor of help file */</a>
<a name="ln4636">  int n;</a>
<a name="ln4637">  int i;</a>
<a name="ln4638">  win_T       *wp;</a>
<a name="ln4639">  int num_matches;</a>
<a name="ln4640">  char_u      **matches;</a>
<a name="ln4641">  char_u      *p;</a>
<a name="ln4642">  int empty_fnum = 0;</a>
<a name="ln4643">  int alt_fnum = 0;</a>
<a name="ln4644">  buf_T       *buf;</a>
<a name="ln4645">  int len;</a>
<a name="ln4646">  char_u      *lang;</a>
<a name="ln4647">  const bool old_KeyTyped = KeyTyped;</a>
<a name="ln4648"> </a>
<a name="ln4649">  if (eap != NULL) {</a>
<a name="ln4650">    /*</a>
<a name="ln4651">     * A &quot;:help&quot; command ends at the first LF, or at a '|' that is</a>
<a name="ln4652">     * followed by some text.  Set nextcmd to the following command.</a>
<a name="ln4653">     */</a>
<a name="ln4654">    for (arg = eap-&gt;arg; *arg; ++arg) {</a>
<a name="ln4655">      if (*arg == '\n' || *arg == '\r'</a>
<a name="ln4656">          || (*arg == '|' &amp;&amp; arg[1] != NUL &amp;&amp; arg[1] != '|')) {</a>
<a name="ln4657">        *arg++ = NUL;</a>
<a name="ln4658">        eap-&gt;nextcmd = arg;</a>
<a name="ln4659">        break;</a>
<a name="ln4660">      }</a>
<a name="ln4661">    }</a>
<a name="ln4662">    arg = eap-&gt;arg;</a>
<a name="ln4663"> </a>
<a name="ln4664">    if (eap-&gt;forceit &amp;&amp; *arg == NUL &amp;&amp; !curbuf-&gt;b_help) {</a>
<a name="ln4665">      EMSG(_(&quot;E478: Don't panic!&quot;));</a>
<a name="ln4666">      return;</a>
<a name="ln4667">    }</a>
<a name="ln4668"> </a>
<a name="ln4669">    if (eap-&gt;skip)          /* not executing commands */</a>
<a name="ln4670">      return;</a>
<a name="ln4671">  } else</a>
<a name="ln4672">    arg = (char_u *)&quot;&quot;;</a>
<a name="ln4673"> </a>
<a name="ln4674">  /* remove trailing blanks */</a>
<a name="ln4675">  p = arg + STRLEN(arg) - 1;</a>
<a name="ln4676">  while (p &gt; arg &amp;&amp; ascii_iswhite(*p) &amp;&amp; p[-1] != '\\')</a>
<a name="ln4677">    *p-- = NUL;</a>
<a name="ln4678"> </a>
<a name="ln4679">  /* Check for a specified language */</a>
<a name="ln4680">  lang = check_help_lang(arg);</a>
<a name="ln4681"> </a>
<a name="ln4682">  /* When no argument given go to the index. */</a>
<a name="ln4683">  if (*arg == NUL)</a>
<a name="ln4684">    arg = (char_u *)&quot;help.txt&quot;;</a>
<a name="ln4685"> </a>
<a name="ln4686">  /*</a>
<a name="ln4687">   * Check if there is a match for the argument.</a>
<a name="ln4688">   */</a>
<a name="ln4689">  n = find_help_tags(arg, &amp;num_matches, &amp;matches,</a>
<a name="ln4690">      eap != NULL &amp;&amp; eap-&gt;forceit);</a>
<a name="ln4691"> </a>
<a name="ln4692">  i = 0;</a>
<a name="ln4693">  if (n != FAIL &amp;&amp; lang != NULL)</a>
<a name="ln4694">    /* Find first item with the requested language. */</a>
<a name="ln4695">    for (i = 0; i &lt; num_matches; ++i) {</a>
<a name="ln4696">      len = (int)STRLEN(matches[i]);</a>
<a name="ln4697">      if (len &gt; 3 &amp;&amp; matches[i][len - 3] == '@'</a>
<a name="ln4698">          &amp;&amp; STRICMP(matches[i] + len - 2, lang) == 0)</a>
<a name="ln4699">        break;</a>
<a name="ln4700">    }</a>
<a name="ln4701">  if (i &gt;= num_matches || n == FAIL) {</a>
<a name="ln4702">    if (lang != NULL)</a>
<a name="ln4703">      EMSG3(_(&quot;E661: Sorry, no '%s' help for %s&quot;), lang, arg);</a>
<a name="ln4704">    else</a>
<a name="ln4705">      EMSG2(_(&quot;E149: Sorry, no help for %s&quot;), arg);</a>
<a name="ln4706">    if (n != FAIL)</a>
<a name="ln4707">      FreeWild(num_matches, matches);</a>
<a name="ln4708">    return;</a>
<a name="ln4709">  }</a>
<a name="ln4710"> </a>
<a name="ln4711">  /* The first match (in the requested language) is the best match. */</a>
<a name="ln4712">  tag = vim_strsave(matches[i]);</a>
<a name="ln4713">  FreeWild(num_matches, matches);</a>
<a name="ln4714"> </a>
<a name="ln4715">  /*</a>
<a name="ln4716">   * Re-use an existing help window or open a new one.</a>
<a name="ln4717">   * Always open a new one for &quot;:tab help&quot;.</a>
<a name="ln4718">   */</a>
<a name="ln4719">  if (!bt_help(curwin-&gt;w_buffer)</a>
<a name="ln4720">      || cmdmod.tab != 0</a>
<a name="ln4721">      ) {</a>
<a name="ln4722">    if (cmdmod.tab != 0) {</a>
<a name="ln4723">      wp = NULL;</a>
<a name="ln4724">    } else {</a>
<a name="ln4725">      wp = NULL;</a>
<a name="ln4726">      FOR_ALL_WINDOWS_IN_TAB(wp2, curtab) {</a>
<a name="ln4727">        if (bt_help(wp2-&gt;w_buffer)) {</a>
<a name="ln4728">          wp = wp2;</a>
<a name="ln4729">          break;</a>
<a name="ln4730">        }</a>
<a name="ln4731">      }</a>
<a name="ln4732">    }</a>
<a name="ln4733">    if (wp != NULL &amp;&amp; wp-&gt;w_buffer-&gt;b_nwindows &gt; 0) {</a>
<a name="ln4734">      win_enter(wp, true);</a>
<a name="ln4735">    } else {</a>
<a name="ln4736">      // There is no help window yet.</a>
<a name="ln4737">      // Try to open the file specified by the &quot;helpfile&quot; option.</a>
<a name="ln4738">      if ((helpfd = os_fopen((char *)p_hf, READBIN)) == NULL) {</a>
<a name="ln4739">        smsg(_(&quot;Sorry, help file \&quot;%s\&quot; not found&quot;), p_hf);</a>
<a name="ln4740">        goto erret;</a>
<a name="ln4741">      }</a>
<a name="ln4742">      fclose(helpfd);</a>
<a name="ln4743"> </a>
<a name="ln4744">      /* Split off help window; put it at far top if no position</a>
<a name="ln4745">       * specified, the current window is vertically split and</a>
<a name="ln4746">       * narrow. */</a>
<a name="ln4747">      n = WSP_HELP;</a>
<a name="ln4748">      if (cmdmod.split == 0 &amp;&amp; curwin-&gt;w_width != Columns</a>
<a name="ln4749">          &amp;&amp; curwin-&gt;w_width &lt; 80)</a>
<a name="ln4750">        n |= WSP_TOP;</a>
<a name="ln4751">      if (win_split(0, n) == FAIL)</a>
<a name="ln4752">        goto erret;</a>
<a name="ln4753"> </a>
<a name="ln4754">      if (curwin-&gt;w_height &lt; p_hh)</a>
<a name="ln4755">        win_setheight((int)p_hh);</a>
<a name="ln4756"> </a>
<a name="ln4757">      /*</a>
<a name="ln4758">       * Open help file (do_ecmd() will set b_help flag, readfile() will</a>
<a name="ln4759">       * set b_p_ro flag).</a>
<a name="ln4760">       * Set the alternate file to the previously edited file.</a>
<a name="ln4761">       */</a>
<a name="ln4762">      alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln4763">      (void)do_ecmd(0, NULL, NULL, NULL, ECMD_LASTL,</a>
<a name="ln4764">          ECMD_HIDE + ECMD_SET_HELP,</a>
<a name="ln4765">          NULL                  /* buffer is still open, don't store info */</a>
<a name="ln4766">          );</a>
<a name="ln4767">      if (!cmdmod.keepalt)</a>
<a name="ln4768">        curwin-&gt;w_alt_fnum = alt_fnum;</a>
<a name="ln4769">      empty_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln4770">    }</a>
<a name="ln4771">  }</a>
<a name="ln4772"> </a>
<a name="ln4773">  if (!p_im)</a>
<a name="ln4774">    restart_edit = 0;               /* don't want insert mode in help file */</a>
<a name="ln4775"> </a>
<a name="ln4776">  /* Restore KeyTyped, setting 'filetype=help' may reset it.</a>
<a name="ln4777">   * It is needed for do_tag top open folds under the cursor. */</a>
<a name="ln4778">  KeyTyped = old_KeyTyped;</a>
<a name="ln4779"> </a>
<a name="ln4780">  do_tag(tag, DT_HELP, 1, FALSE, TRUE);</a>
<a name="ln4781"> </a>
<a name="ln4782">  /* Delete the empty buffer if we're not using it.  Careful: autocommands</a>
<a name="ln4783">   * may have jumped to another window, check that the buffer is not in a</a>
<a name="ln4784">   * window. */</a>
<a name="ln4785">  if (empty_fnum != 0 &amp;&amp; curbuf-&gt;b_fnum != empty_fnum) {</a>
<a name="ln4786">    buf = buflist_findnr(empty_fnum);</a>
<a name="ln4787">    if (buf != NULL &amp;&amp; buf-&gt;b_nwindows == 0) {</a>
<a name="ln4788">      wipe_buffer(buf, true);</a>
<a name="ln4789">    }</a>
<a name="ln4790">  }</a>
<a name="ln4791"> </a>
<a name="ln4792">  /* keep the previous alternate file */</a>
<a name="ln4793">  if (alt_fnum != 0 &amp;&amp; curwin-&gt;w_alt_fnum == empty_fnum &amp;&amp; !cmdmod.keepalt)</a>
<a name="ln4794">    curwin-&gt;w_alt_fnum = alt_fnum;</a>
<a name="ln4795"> </a>
<a name="ln4796">erret:</a>
<a name="ln4797">  xfree(tag);</a>
<a name="ln4798">}</a>
<a name="ln4799"> </a>
<a name="ln4800"> </a>
<a name="ln4801">/*</a>
<a name="ln4802"> * In an argument search for a language specifiers in the form &quot;@xx&quot;.</a>
<a name="ln4803"> * Changes the &quot;@&quot; to NUL if found, and returns a pointer to &quot;xx&quot;.</a>
<a name="ln4804"> * Returns NULL if not found.</a>
<a name="ln4805"> */</a>
<a name="ln4806">char_u *check_help_lang(char_u *arg)</a>
<a name="ln4807">{</a>
<a name="ln4808">  int len = (int)STRLEN(arg);</a>
<a name="ln4809"> </a>
<a name="ln4810">  if (len &gt;= 3 &amp;&amp; arg[len - 3] == '@' &amp;&amp; ASCII_ISALPHA(arg[len - 2])</a>
<a name="ln4811">      &amp;&amp; ASCII_ISALPHA(arg[len - 1])) {</a>
<a name="ln4812">    arg[len - 3] = NUL;                 /* remove the '@' */</a>
<a name="ln4813">    return arg + len - 2;</a>
<a name="ln4814">  }</a>
<a name="ln4815">  return NULL;</a>
<a name="ln4816">}</a>
<a name="ln4817"> </a>
<a name="ln4818">/*</a>
<a name="ln4819"> * Return a heuristic indicating how well the given string matches.  The</a>
<a name="ln4820"> * smaller the number, the better the match.  This is the order of priorities,</a>
<a name="ln4821"> * from best match to worst match:</a>
<a name="ln4822"> *	- Match with least alpha-numeric characters is better.</a>
<a name="ln4823"> *	- Match with least total characters is better.</a>
<a name="ln4824"> *	- Match towards the start is better.</a>
<a name="ln4825"> *	- Match starting with &quot;+&quot; is worse (feature instead of command)</a>
<a name="ln4826"> * Assumption is made that the matched_string passed has already been found to</a>
<a name="ln4827"> * match some string for which help is requested.  webb.</a>
<a name="ln4828"> */</a>
<a name="ln4829">int</a>
<a name="ln4830">help_heuristic(</a>
<a name="ln4831">    char_u *matched_string,</a>
<a name="ln4832">    int offset,                             // offset for match</a>
<a name="ln4833">    int wrong_case                          // no matching case</a>
<a name="ln4834">)</a>
<a name="ln4835">{</a>
<a name="ln4836">  int num_letters;</a>
<a name="ln4837">  char_u      *p;</a>
<a name="ln4838"> </a>
<a name="ln4839">  num_letters = 0;</a>
<a name="ln4840">  for (p = matched_string; *p; p++)</a>
<a name="ln4841">    if (ASCII_ISALNUM(*p))</a>
<a name="ln4842">      num_letters++;</a>
<a name="ln4843"> </a>
<a name="ln4844">  /*</a>
<a name="ln4845">   * Multiply the number of letters by 100 to give it a much bigger</a>
<a name="ln4846">   * weighting than the number of characters.</a>
<a name="ln4847">   * If there only is a match while ignoring case, add 5000.</a>
<a name="ln4848">   * If the match starts in the middle of a word, add 10000 to put it</a>
<a name="ln4849">   * somewhere in the last half.</a>
<a name="ln4850">   * If the match is more than 2 chars from the start, multiply by 200 to</a>
<a name="ln4851">   * put it after matches at the start.</a>
<a name="ln4852">   */</a>
<a name="ln4853">  if (offset &gt; 0</a>
<a name="ln4854">      &amp;&amp; ASCII_ISALNUM(matched_string[offset])</a>
<a name="ln4855">      &amp;&amp; ASCII_ISALNUM(matched_string[offset - 1])) {</a>
<a name="ln4856">    offset += 10000;</a>
<a name="ln4857">  } else if (offset &gt; 2) {</a>
<a name="ln4858">    offset *= 200;</a>
<a name="ln4859">  }</a>
<a name="ln4860">  if (wrong_case) {</a>
<a name="ln4861">    offset += 5000;</a>
<a name="ln4862">  }</a>
<a name="ln4863">  // Features are less interesting than the subjects themselves, but &quot;+&quot;</a>
<a name="ln4864">  // alone is not a feature.</a>
<a name="ln4865">  if (matched_string[0] == '+' &amp;&amp; matched_string[1] != NUL) {</a>
<a name="ln4866">    offset += 100;</a>
<a name="ln4867">  }</a>
<a name="ln4868">  return (int)(100 * num_letters + STRLEN(matched_string) + offset);</a>
<a name="ln4869">}</a>
<a name="ln4870"> </a>
<a name="ln4871">/*</a>
<a name="ln4872"> * Compare functions for qsort() below, that checks the help heuristics number</a>
<a name="ln4873"> * that has been put after the tagname by find_tags().</a>
<a name="ln4874"> */</a>
<a name="ln4875">static int help_compare(const void *s1, const void *s2)</a>
<a name="ln4876">{</a>
<a name="ln4877">  char    *p1;</a>
<a name="ln4878">  char    *p2;</a>
<a name="ln4879"> </a>
<a name="ln4880">  p1 = *(char **)s1 + strlen(*(char **)s1) + 1;</a>
<a name="ln4881">  p2 = *(char **)s2 + strlen(*(char **)s2) + 1;</a>
<a name="ln4882">  return strcmp(p1, p2);</a>
<a name="ln4883">}</a>
<a name="ln4884"> </a>
<a name="ln4885">// Find all help tags matching &quot;arg&quot;, sort them and return in matches[], with</a>
<a name="ln4886">// the number of matches in num_matches.</a>
<a name="ln4887">// The matches will be sorted with a &quot;best&quot; match algorithm.</a>
<a name="ln4888">// When &quot;keep_lang&quot; is true try keeping the language of the current buffer.</a>
<a name="ln4889">int find_help_tags(const char_u *arg, int *num_matches, char_u ***matches,</a>
<a name="ln4890">                   bool keep_lang)</a>
<a name="ln4891">{</a>
<a name="ln4892">  int i;</a>
<a name="ln4893">  static const char *(mtable[]) = {</a>
<a name="ln4894">      &quot;*&quot;, &quot;g*&quot;, &quot;[*&quot;, &quot;]*&quot;,</a>
<a name="ln4895">      &quot;/*&quot;, &quot;/\\*&quot;, &quot;\&quot;*&quot;, &quot;**&quot;,</a>
<a name="ln4896">      &quot;/\\(\\)&quot;, &quot;/\\%(\\)&quot;,</a>
<a name="ln4897">      &quot;?&quot;, &quot;:?&quot;, &quot;?&lt;CR&gt;&quot;, &quot;g?&quot;, &quot;g?g?&quot;, &quot;g??&quot;,</a>
<a name="ln4898">      &quot;-?&quot;, &quot;q?&quot;, &quot;v_g?&quot;,</a>
<a name="ln4899">      &quot;/\\?&quot;, &quot;/\\z(\\)&quot;, &quot;\\=&quot;, &quot;:s\\=&quot;,</a>
<a name="ln4900">      &quot;[count]&quot;, &quot;[quotex]&quot;,</a>
<a name="ln4901">      &quot;[range]&quot;, &quot;:[range]&quot;,</a>
<a name="ln4902">      &quot;[pattern]&quot;, &quot;\\|&quot;, &quot;\\%$&quot;,</a>
<a name="ln4903">      &quot;s/\\~&quot;, &quot;s/\\U&quot;, &quot;s/\\L&quot;,</a>
<a name="ln4904">      &quot;s/\\1&quot;, &quot;s/\\2&quot;, &quot;s/\\3&quot;, &quot;s/\\9&quot;</a>
<a name="ln4905">  };</a>
<a name="ln4906">  static const char *(rtable[]) = {</a>
<a name="ln4907">      &quot;star&quot;, &quot;gstar&quot;, &quot;[star&quot;, &quot;]star&quot;,</a>
<a name="ln4908">      &quot;/star&quot;, &quot;/\\\\star&quot;, &quot;quotestar&quot;, &quot;starstar&quot;,</a>
<a name="ln4909">      &quot;/\\\\(\\\\)&quot;, &quot;/\\\\%(\\\\)&quot;,</a>
<a name="ln4910">      &quot;?&quot;, &quot;:?&quot;, &quot;?&lt;CR&gt;&quot;, &quot;g?&quot;, &quot;g?g?&quot;, &quot;g??&quot;,</a>
<a name="ln4911">      &quot;-?&quot;, &quot;q?&quot;, &quot;v_g?&quot;,</a>
<a name="ln4912">      &quot;/\\\\?&quot;, &quot;/\\\\z(\\\\)&quot;, &quot;\\\\=&quot;, &quot;:s\\\\=&quot;,</a>
<a name="ln4913">      &quot;\\[count]&quot;, &quot;\\[quotex]&quot;,</a>
<a name="ln4914">      &quot;\\[range]&quot;, &quot;:\\[range]&quot;,</a>
<a name="ln4915">      &quot;\\[pattern]&quot;, &quot;\\\\bar&quot;, &quot;/\\\\%\\$&quot;,</a>
<a name="ln4916">      &quot;s/\\\\\\~&quot;, &quot;s/\\\\U&quot;, &quot;s/\\\\L&quot;,</a>
<a name="ln4917">      &quot;s/\\\\1&quot;, &quot;s/\\\\2&quot;, &quot;s/\\\\3&quot;, &quot;s/\\\\9&quot;</a>
<a name="ln4918">  };</a>
<a name="ln4919">  static const char *(expr_table[]) = {</a>
<a name="ln4920">      &quot;!=?&quot;, &quot;!~?&quot;, &quot;&lt;=?&quot;, &quot;&lt;?&quot;, &quot;==?&quot;, &quot;=~?&quot;,</a>
<a name="ln4921">      &quot;&gt;=?&quot;, &quot;&gt;?&quot;, &quot;is?&quot;, &quot;isnot?&quot;</a>
<a name="ln4922">  };</a>
<a name="ln4923">  char_u *d = IObuff;       // assume IObuff is long enough!</a>
<a name="ln4924"> </a>
<a name="ln4925">  if (STRNICMP(arg, &quot;expr-&quot;, 5) == 0) {</a>
<a name="ln4926">    // When the string starting with &quot;expr-&quot; and containing '?' and matches</a>
<a name="ln4927">    // the table, it is taken literally (but ~ is escaped).  Otherwise '?'</a>
<a name="ln4928">    // is recognized as a wildcard.</a>
<a name="ln4929">    for (i = (int)ARRAY_SIZE(expr_table); --i &gt;= 0; ) {</a>
<a name="ln4930">      if (STRCMP(arg + 5, expr_table[i]) == 0) {</a>
<a name="ln4931">        for (int si = 0, di = 0; ; si++) {</a>
<a name="ln4932">          if (arg[si] == '~') {</a>
<a name="ln4933">            d[di++] = '\\';</a>
<a name="ln4934">          }</a>
<a name="ln4935">          d[di++] = arg[si];</a>
<a name="ln4936">          if (arg[si] == NUL) {</a>
<a name="ln4937">            break;</a>
<a name="ln4938">          }</a>
<a name="ln4939">        }</a>
<a name="ln4940">        break;</a>
<a name="ln4941">      }</a>
<a name="ln4942">    }</a>
<a name="ln4943">  } else {</a>
<a name="ln4944">    // Recognize a few exceptions to the rule.  Some strings that contain</a>
<a name="ln4945">    // '*' with &quot;star&quot;.  Otherwise '*' is recognized as a wildcard.</a>
<a name="ln4946">    for (i = (int)ARRAY_SIZE(mtable); --i &gt;= 0; ) {</a>
<a name="ln4947">      if (STRCMP(arg, mtable[i]) == 0) {</a>
<a name="ln4948">        STRCPY(d, rtable[i]);</a>
<a name="ln4949">        break;</a>
<a name="ln4950">      }</a>
<a name="ln4951">    }</a>
<a name="ln4952">  }</a>
<a name="ln4953"> </a>
<a name="ln4954">  if (i &lt; 0) {  /* no match in table */</a>
<a name="ln4955">    /* Replace &quot;\S&quot; with &quot;/\\S&quot;, etc.  Otherwise every tag is matched.</a>
<a name="ln4956">     * Also replace &quot;\%^&quot; and &quot;\%(&quot;, they match every tag too.</a>
<a name="ln4957">     * Also &quot;\zs&quot;, &quot;\z1&quot;, etc.</a>
<a name="ln4958">     * Also &quot;\@&lt;&quot;, &quot;\@=&quot;, &quot;\@&lt;=&quot;, etc.</a>
<a name="ln4959">     * And also &quot;\_$&quot; and &quot;\_^&quot;. */</a>
<a name="ln4960">    if (arg[0] == '\\'</a>
<a name="ln4961">        &amp;&amp; ((arg[1] != NUL &amp;&amp; arg[2] == NUL)</a>
<a name="ln4962">            || (vim_strchr((char_u *)&quot;%_z@&quot;, arg[1]) != NULL</a>
<a name="ln4963">                &amp;&amp; arg[2] != NUL))) {</a>
<a name="ln4964">      STRCPY(d, &quot;/\\\\&quot;);</a>
<a name="ln4965">      STRCPY(d + 3, arg + 1);</a>
<a name="ln4966">      /* Check for &quot;/\\_$&quot;, should be &quot;/\\_\$&quot; */</a>
<a name="ln4967">      if (d[3] == '_' &amp;&amp; d[4] == '$')</a>
<a name="ln4968">        STRCPY(d + 4, &quot;\\$&quot;);</a>
<a name="ln4969">    } else {</a>
<a name="ln4970">      /* Replace:</a>
<a name="ln4971">       * &quot;[:...:]&quot; with &quot;\[:...:]&quot;</a>
<a name="ln4972">       * &quot;[++...]&quot; with &quot;\[++...]&quot;</a>
<a name="ln4973">       * &quot;\{&quot; with &quot;\\{&quot;               -- matching &quot;} \}&quot;</a>
<a name="ln4974">       */</a>
<a name="ln4975">      if ((arg[0] == '[' &amp;&amp; (arg[1] == ':'</a>
<a name="ln4976">                             || (arg[1] == '+' &amp;&amp; arg[2] == '+')))</a>
<a name="ln4977">          || (arg[0] == '\\' &amp;&amp; arg[1] == '{'))</a>
<a name="ln4978">        *d++ = '\\';</a>
<a name="ln4979"> </a>
<a name="ln4980">      // If tag starts with &quot;('&quot;, skip the &quot;(&quot;. Fixes CTRL-] on ('option'.</a>
<a name="ln4981">      if (*arg == '(' &amp;&amp; arg[1] == '\'') {</a>
<a name="ln4982">          arg++;</a>
<a name="ln4983">      }</a>
<a name="ln4984">      for (const char_u *s = arg; *s; s++) {</a>
<a name="ln4985">        // Replace &quot;|&quot; with &quot;bar&quot; and '&quot;' with &quot;quote&quot; to match the name of</a>
<a name="ln4986">        // the tags for these commands.</a>
<a name="ln4987">        // Replace &quot;*&quot; with &quot;.*&quot; and &quot;?&quot; with &quot;.&quot; to match command line</a>
<a name="ln4988">        // completion.</a>
<a name="ln4989">        // Insert a backslash before '~', '$' and '.' to avoid their</a>
<a name="ln4990">        // special meaning.</a>
<a name="ln4991">        if (d - IObuff &gt; IOSIZE - 10) {           // getting too long!?</a>
<a name="ln4992">          break;</a>
<a name="ln4993">        }</a>
<a name="ln4994">        switch (*s) {</a>
<a name="ln4995">        case '|':   STRCPY(d, &quot;bar&quot;);</a>
<a name="ln4996">          d += 3;</a>
<a name="ln4997">          continue;</a>
<a name="ln4998">        case '&quot;':   STRCPY(d, &quot;quote&quot;);</a>
<a name="ln4999">          d += 5;</a>
<a name="ln5000">          continue;</a>
<a name="ln5001">        case '*':   *d++ = '.';</a>
<a name="ln5002">          break;</a>
<a name="ln5003">        case '?':   *d++ = '.';</a>
<a name="ln5004">          continue;</a>
<a name="ln5005">        case '$':</a>
<a name="ln5006">        case '.':</a>
<a name="ln5007">        case '~':   *d++ = '\\';</a>
<a name="ln5008">          break;</a>
<a name="ln5009">        }</a>
<a name="ln5010"> </a>
<a name="ln5011">        /*</a>
<a name="ln5012">         * Replace &quot;^x&quot; by &quot;CTRL-X&quot;. Don't do this for &quot;^_&quot; to make</a>
<a name="ln5013">         * &quot;:help i_^_CTRL-D&quot; work.</a>
<a name="ln5014">         * Insert '-' before and after &quot;CTRL-X&quot; when applicable.</a>
<a name="ln5015">         */</a>
<a name="ln5016">        if (*s &lt; ' ' || (*s == '^' &amp;&amp; s[1] &amp;&amp; (ASCII_ISALPHA(s[1])</a>
<a name="ln5017">                                               || vim_strchr((char_u *)</a>
<a name="ln5018">                                                   &quot;?@[\\]^&quot;,</a>
<a name="ln5019">                                                   s[1]) != NULL))) {</a>
<a name="ln5020">          if (d &gt; IObuff &amp;&amp; d[-1] != '_' &amp;&amp; d[-1] != '\\')</a>
<a name="ln5021">            *d++ = '_';                 /* prepend a '_' to make x_CTRL-x */</a>
<a name="ln5022">          STRCPY(d, &quot;CTRL-&quot;);</a>
<a name="ln5023">          d += 5;</a>
<a name="ln5024">          if (*s &lt; ' ') {</a>
<a name="ln5025">            *d++ = *s + '@';</a>
<a name="ln5026">            if (d[-1] == '\\')</a>
<a name="ln5027">              *d++ = '\\';              /* double a backslash */</a>
<a name="ln5028">          } else</a>
<a name="ln5029">            *d++ = *++s;</a>
<a name="ln5030">          if (s[1] != NUL &amp;&amp; s[1] != '_')</a>
<a name="ln5031">            *d++ = '_';                 /* append a '_' */</a>
<a name="ln5032">          continue;</a>
<a name="ln5033">        } else if (*s == '^')           /* &quot;^&quot; or &quot;CTRL-^&quot; or &quot;^_&quot; */</a>
<a name="ln5034">          *d++ = '\\';</a>
<a name="ln5035"> </a>
<a name="ln5036">        /*</a>
<a name="ln5037">         * Insert a backslash before a backslash after a slash, for search</a>
<a name="ln5038">         * pattern tags: &quot;/\|&quot; --&gt; &quot;/\\|&quot;.</a>
<a name="ln5039">         */</a>
<a name="ln5040">        else if (s[0] == '\\' &amp;&amp; s[1] != '\\'</a>
<a name="ln5041">                 &amp;&amp; *arg == '/' &amp;&amp; s == arg + 1)</a>
<a name="ln5042">          *d++ = '\\';</a>
<a name="ln5043"> </a>
<a name="ln5044">        /* &quot;CTRL-\_&quot; -&gt; &quot;CTRL-\\_&quot; to avoid the special meaning of &quot;\_&quot; in</a>
<a name="ln5045">         * &quot;CTRL-\_CTRL-N&quot; */</a>
<a name="ln5046">        if (STRNICMP(s, &quot;CTRL-\\_&quot;, 7) == 0) {</a>
<a name="ln5047">          STRCPY(d, &quot;CTRL-\\\\&quot;);</a>
<a name="ln5048">          d += 7;</a>
<a name="ln5049">          s += 6;</a>
<a name="ln5050">        }</a>
<a name="ln5051"> </a>
<a name="ln5052">        *d++ = *s;</a>
<a name="ln5053"> </a>
<a name="ln5054">        // If tag contains &quot;({&quot; or &quot;([&quot;, tag terminates at the &quot;(&quot;.</a>
<a name="ln5055">        // This is for help on functions, e.g.: abs({expr}).</a>
<a name="ln5056">        if (*s == '(' &amp;&amp; (s[1] == '{' || s[1] =='[')) {</a>
<a name="ln5057">          break;</a>
<a name="ln5058">        }</a>
<a name="ln5059"> </a>
<a name="ln5060">        // If tag starts with ', toss everything after a second '. Fixes</a>
<a name="ln5061">        // CTRL-] on 'option'. (would include the trailing '.').</a>
<a name="ln5062">        if (*s == '\'' &amp;&amp; s &gt; arg &amp;&amp; *arg == '\'') {</a>
<a name="ln5063">          break;</a>
<a name="ln5064">        }</a>
<a name="ln5065">        // Also '{' and '}'. Fixes CTRL-] on '{address}'.</a>
<a name="ln5066">        if (*s == '}' &amp;&amp; s &gt; arg &amp;&amp; *arg == '{') {</a>
<a name="ln5067">          break;</a>
<a name="ln5068">        }</a>
<a name="ln5069">      }</a>
<a name="ln5070">      *d = NUL;</a>
<a name="ln5071"> </a>
<a name="ln5072">      if (*IObuff == '`') {</a>
<a name="ln5073">        if (d &gt; IObuff + 2 &amp;&amp; d[-1] == '`') {</a>
<a name="ln5074">          /* remove the backticks from `command` */</a>
<a name="ln5075">          memmove(IObuff, IObuff + 1, STRLEN(IObuff));</a>
<a name="ln5076">          d[-2] = NUL;</a>
<a name="ln5077">        } else if (d &gt; IObuff + 3 &amp;&amp; d[-2] == '`' &amp;&amp; d[-1] == ',') {</a>
<a name="ln5078">          /* remove the backticks and comma from `command`, */</a>
<a name="ln5079">          memmove(IObuff, IObuff + 1, STRLEN(IObuff));</a>
<a name="ln5080">          d[-3] = NUL;</a>
<a name="ln5081">        } else if (d &gt; IObuff + 4 &amp;&amp; d[-3] == '`'</a>
<a name="ln5082">                   &amp;&amp; d[-2] == '\\' &amp;&amp; d[-1] == '.') {</a>
<a name="ln5083">          /* remove the backticks and dot from `command`\. */</a>
<a name="ln5084">          memmove(IObuff, IObuff + 1, STRLEN(IObuff));</a>
<a name="ln5085">          d[-4] = NUL;</a>
<a name="ln5086">        }</a>
<a name="ln5087">      }</a>
<a name="ln5088">    }</a>
<a name="ln5089">  }</a>
<a name="ln5090"> </a>
<a name="ln5091">  *matches = NULL;</a>
<a name="ln5092">  *num_matches = 0;</a>
<a name="ln5093">  int flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;</a>
<a name="ln5094">  if (keep_lang) {</a>
<a name="ln5095">    flags |= TAG_KEEP_LANG;</a>
<a name="ln5096">  }</a>
<a name="ln5097">  if (find_tags(IObuff, num_matches, matches, flags, MAXCOL, NULL) == OK</a>
<a name="ln5098">      &amp;&amp; *num_matches &gt; 0) {</a>
<a name="ln5099">    /* Sort the matches found on the heuristic number that is after the</a>
<a name="ln5100">     * tag name. */</a>
<a name="ln5101">    qsort((void *)*matches, (size_t)*num_matches,</a>
<a name="ln5102">        sizeof(char_u *), help_compare);</a>
<a name="ln5103">    /* Delete more than TAG_MANY to reduce the size of the listing. */</a>
<a name="ln5104">    while (*num_matches &gt; TAG_MANY)</a>
<a name="ln5105">      xfree((*matches)[--*num_matches]);</a>
<a name="ln5106">  }</a>
<a name="ln5107">  return OK;</a>
<a name="ln5108">}</a>
<a name="ln5109"> </a>
<a name="ln5110">/// Called when starting to edit a buffer for a help file.</a>
<a name="ln5111">static void prepare_help_buffer(void)</a>
<a name="ln5112">{</a>
<a name="ln5113">  curbuf-&gt;b_help = true;</a>
<a name="ln5114">  set_string_option_direct(&quot;buftype&quot;, -1, (char_u *)&quot;help&quot;,</a>
<a name="ln5115">                           OPT_FREE|OPT_LOCAL, 0);</a>
<a name="ln5116"> </a>
<a name="ln5117">  // Always set these options after jumping to a help tag, because the</a>
<a name="ln5118">  // user may have an autocommand that gets in the way.</a>
<a name="ln5119">  // Accept all ASCII chars for keywords, except ' ', '*', '&quot;', '|', and</a>
<a name="ln5120">  // latin1 word characters (for translated help files).</a>
<a name="ln5121">  // Only set it when needed, buf_init_chartab() is some work.</a>
<a name="ln5122">  char_u *p = (char_u *)&quot;!-~,^*,^|,^\&quot;,192-255&quot;;</a>
<a name="ln5123">  if (STRCMP(curbuf-&gt;b_p_isk, p) != 0) {</a>
<a name="ln5124">    set_string_option_direct(&quot;isk&quot;, -1, p, OPT_FREE|OPT_LOCAL, 0);</a>
<a name="ln5125">    check_buf_options(curbuf);</a>
<a name="ln5126">    (void)buf_init_chartab(curbuf, FALSE);</a>
<a name="ln5127">  }</a>
<a name="ln5128"> </a>
<a name="ln5129">  // Don't use the global foldmethod.</a>
<a name="ln5130">  set_string_option_direct(&quot;fdm&quot;, -1, (char_u *)&quot;manual&quot;,</a>
<a name="ln5131">                           OPT_FREE|OPT_LOCAL, 0);</a>
<a name="ln5132"> </a>
<a name="ln5133">  curbuf-&gt;b_p_ts = 8;         // 'tabstop' is 8.</a>
<a name="ln5134">  curwin-&gt;w_p_list = FALSE;   // No list mode.</a>
<a name="ln5135"> </a>
<a name="ln5136">  curbuf-&gt;b_p_ma = FALSE;     // Not modifiable.</a>
<a name="ln5137">  curbuf-&gt;b_p_bin = FALSE;    // Reset 'bin' before reading file.</a>
<a name="ln5138">  curwin-&gt;w_p_nu = 0;         // No line numbers.</a>
<a name="ln5139">  curwin-&gt;w_p_rnu = 0;        // No relative line numbers.</a>
<a name="ln5140">  RESET_BINDING(curwin);      // No scroll or cursor binding.</a>
<a name="ln5141">  curwin-&gt;w_p_arab = FALSE;   // No arabic mode.</a>
<a name="ln5142">  curwin-&gt;w_p_rl  = FALSE;    // Help window is left-to-right.</a>
<a name="ln5143">  curwin-&gt;w_p_fen = FALSE;    // No folding in the help window.</a>
<a name="ln5144">  curwin-&gt;w_p_diff = FALSE;   // No 'diff'.</a>
<a name="ln5145">  curwin-&gt;w_p_spell = FALSE;  // No spell checking.</a>
<a name="ln5146"> </a>
<a name="ln5147">  set_buflisted(FALSE);</a>
<a name="ln5148">}</a>
<a name="ln5149"> </a>
<a name="ln5150">/*</a>
<a name="ln5151"> * After reading a help file: May cleanup a help buffer when syntax</a>
<a name="ln5152"> * highlighting is not used.</a>
<a name="ln5153"> */</a>
<a name="ln5154">void fix_help_buffer(void)</a>
<a name="ln5155">{</a>
<a name="ln5156">  linenr_T lnum;</a>
<a name="ln5157">  char_u      *line;</a>
<a name="ln5158">  bool in_example = false;</a>
<a name="ln5159"> </a>
<a name="ln5160">  // Set filetype to &quot;help&quot;.</a>
<a name="ln5161">  if (STRCMP(curbuf-&gt;b_p_ft, &quot;help&quot;) != 0) {</a>
<a name="ln5162">    curbuf_lock++;</a>
<a name="ln5163">    set_option_value(&quot;ft&quot;, 0L, &quot;help&quot;, OPT_LOCAL);</a>
<a name="ln5164">    curbuf_lock--;</a>
<a name="ln5165">  }</a>
<a name="ln5166"> </a>
<a name="ln5167">  if (!syntax_present(curwin)) {</a>
<a name="ln5168">    for (lnum = 1; lnum &lt;= curbuf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln5169">      line = ml_get_buf(curbuf, lnum, false);</a>
<a name="ln5170">      const size_t len = STRLEN(line);</a>
<a name="ln5171">      if (in_example &amp;&amp; len &gt; 0 &amp;&amp; !ascii_iswhite(line[0])) {</a>
<a name="ln5172">        /* End of example: non-white or '&lt;' in first column. */</a>
<a name="ln5173">        if (line[0] == '&lt;') {</a>
<a name="ln5174">          /* blank-out a '&lt;' in the first column */</a>
<a name="ln5175">          line = ml_get_buf(curbuf, lnum, TRUE);</a>
<a name="ln5176">          line[0] = ' ';</a>
<a name="ln5177">        }</a>
<a name="ln5178">        in_example = false;</a>
<a name="ln5179">      }</a>
<a name="ln5180">      if (!in_example &amp;&amp; len &gt; 0) {</a>
<a name="ln5181">        if (line[len - 1] == '&gt;' &amp;&amp; (len == 1 || line[len - 2] == ' ')) {</a>
<a name="ln5182">          /* blank-out a '&gt;' in the last column (start of example) */</a>
<a name="ln5183">          line = ml_get_buf(curbuf, lnum, TRUE);</a>
<a name="ln5184">          line[len - 1] = ' ';</a>
<a name="ln5185">          in_example = true;</a>
<a name="ln5186">        } else if (line[len - 1] == '~') {</a>
<a name="ln5187">          /* blank-out a '~' at the end of line (header marker) */</a>
<a name="ln5188">          line = ml_get_buf(curbuf, lnum, TRUE);</a>
<a name="ln5189">          line[len - 1] = ' ';</a>
<a name="ln5190">        }</a>
<a name="ln5191">      }</a>
<a name="ln5192">    }</a>
<a name="ln5193">  }</a>
<a name="ln5194"> </a>
<a name="ln5195">  /*</a>
<a name="ln5196">   * In the &quot;help.txt&quot; and &quot;help.abx&quot; file, add the locally added help</a>
<a name="ln5197">   * files.  This uses the very first line in the help file.</a>
<a name="ln5198">   */</a>
<a name="ln5199">  char_u *const fname = path_tail(curbuf-&gt;b_fname);</a>
<a name="ln5200">  if (fnamecmp(fname, &quot;help.txt&quot;) == 0</a>
<a name="ln5201">      || (fnamencmp(fname, &quot;help.&quot;, 5) == 0</a>
<a name="ln5202">          &amp;&amp; ASCII_ISALPHA(fname[5])</a>
<a name="ln5203">          &amp;&amp; ASCII_ISALPHA(fname[6])</a>
<a name="ln5204">          &amp;&amp; TOLOWER_ASC(fname[7]) == 'x'</a>
<a name="ln5205">          &amp;&amp; fname[8] == NUL)</a>
<a name="ln5206">      ) {</a>
<a name="ln5207">    for (lnum = 1; lnum &lt; curbuf-&gt;b_ml.ml_line_count; ++lnum) {</a>
<a name="ln5208">      line = ml_get_buf(curbuf, lnum, FALSE);</a>
<a name="ln5209">      if (strstr((char *)line, &quot;*local-additions*&quot;) == NULL)</a>
<a name="ln5210">        continue;</a>
<a name="ln5211"> </a>
<a name="ln5212">      /* Go through all directories in 'runtimepath', skipping</a>
<a name="ln5213">       * $VIMRUNTIME. */</a>
<a name="ln5214">      char_u *p = p_rtp;</a>
<a name="ln5215">      while (*p != NUL) {</a>
<a name="ln5216">        copy_option_part(&amp;p, NameBuff, MAXPATHL, &quot;,&quot;);</a>
<a name="ln5217">        char_u *const rt = (char_u *)vim_getenv(&quot;VIMRUNTIME&quot;);</a>
<a name="ln5218">        if (rt != NULL</a>
<a name="ln5219">            &amp;&amp; path_full_compare(rt, NameBuff, false, true) != kEqualFiles) {</a>
<a name="ln5220">          int fcount;</a>
<a name="ln5221">          char_u      **fnames;</a>
<a name="ln5222">          char_u      *s;</a>
<a name="ln5223">          vimconv_T vc;</a>
<a name="ln5224">          char_u      *cp;</a>
<a name="ln5225"> </a>
<a name="ln5226">          // Find all &quot;doc/ *.txt&quot; files in this directory.</a>
<a name="ln5227">          if (!add_pathsep((char *)NameBuff)</a>
<a name="ln5228">              || STRLCAT(NameBuff, &quot;doc/*.??[tx]&quot;,</a>
<a name="ln5229">                         sizeof(NameBuff)) &gt;= MAXPATHL) {</a>
<a name="ln5230">            EMSG(_(e_fnametoolong));</a>
<a name="ln5231">            continue;</a>
<a name="ln5232">          }</a>
<a name="ln5233"> </a>
<a name="ln5234">          // Note: We cannot just do `&amp;NameBuff` because it is a statically sized array</a>
<a name="ln5235">          //       so `NameBuff == &amp;NameBuff` according to C semantics.</a>
<a name="ln5236">          char_u *buff_list[1] = {NameBuff};</a>
<a name="ln5237">          if (gen_expand_wildcards(1, buff_list, &amp;fcount,</a>
<a name="ln5238">                  &amp;fnames, EW_FILE|EW_SILENT) == OK</a>
<a name="ln5239">              &amp;&amp; fcount &gt; 0) {</a>
<a name="ln5240">            // If foo.abx is found use it instead of foo.txt in</a>
<a name="ln5241">            // the same directory.</a>
<a name="ln5242">            for (int i1 = 0; i1 &lt; fcount; i1++) {</a>
<a name="ln5243">              for (int i2 = 0; i2 &lt; fcount; i2++) {</a>
<a name="ln5244">                if (i1 == i2) {</a>
<a name="ln5245">                  continue;</a>
<a name="ln5246">                }</a>
<a name="ln5247">                if (fnames[i1] == NULL || fnames[i2] == NULL) {</a>
<a name="ln5248">                  continue;</a>
<a name="ln5249">                }</a>
<a name="ln5250">                const char_u *const f1 = fnames[i1];</a>
<a name="ln5251">                const char_u *const f2 = fnames[i2];</a>
<a name="ln5252">                const char_u *const t1 = path_tail(f1);</a>
<a name="ln5253">                const char_u *const t2 = path_tail(f2);</a>
<a name="ln5254">                const char_u *const e1 = STRRCHR(t1, '.');</a>
<a name="ln5255">                const char_u *const e2 = STRRCHR(t2, '.');</a>
<a name="ln5256">                if (e1 == NULL || e2 == NULL) {</a>
<a name="ln5257">                  continue;</a>
<a name="ln5258">                }</a>
<a name="ln5259">                if (fnamecmp(e1, &quot;.txt&quot;) != 0</a>
<a name="ln5260">                    &amp;&amp; fnamecmp(e1, fname + 4) != 0) {</a>
<a name="ln5261">                  // Not .txt and not .abx, remove it.</a>
<a name="ln5262">                  XFREE_CLEAR(fnames[i1]);</a>
<a name="ln5263">                  continue;</a>
<a name="ln5264">                }</a>
<a name="ln5265">                if (e1 - f1 != e2 - f2</a>
<a name="ln5266">                    || fnamencmp(f1, f2, e1 - f1) != 0) {</a>
<a name="ln5267">                  continue;</a>
<a name="ln5268">                }</a>
<a name="ln5269">                if (fnamecmp(e1, &quot;.txt&quot;) == 0</a>
<a name="ln5270">                    &amp;&amp; fnamecmp(e2, fname + 4) == 0) {</a>
<a name="ln5271">                  // use .abx instead of .txt</a>
<a name="ln5272">                  XFREE_CLEAR(fnames[i1]);</a>
<a name="ln5273">                }</a>
<a name="ln5274">              }</a>
<a name="ln5275">            }</a>
<a name="ln5276">            for (int fi = 0; fi &lt; fcount; fi++) {</a>
<a name="ln5277">              if (fnames[fi] == NULL) {</a>
<a name="ln5278">                continue;</a>
<a name="ln5279">              }</a>
<a name="ln5280"> </a>
<a name="ln5281">              FILE *const fd = os_fopen((char *)fnames[fi], &quot;r&quot;);</a>
<a name="ln5282">              if (fd == NULL) {</a>
<a name="ln5283">                continue;</a>
<a name="ln5284">              }</a>
<a name="ln5285">              vim_fgets(IObuff, IOSIZE, fd);</a>
<a name="ln5286">              if (IObuff[0] == '*'</a>
<a name="ln5287">                  &amp;&amp; (s = vim_strchr(IObuff + 1, '*'))</a>
<a name="ln5288">                  != NULL) {</a>
<a name="ln5289">                TriState this_utf = kNone;</a>
<a name="ln5290">                // Change tag definition to a</a>
<a name="ln5291">                // reference and remove &lt;CR&gt;/&lt;NL&gt;.</a>
<a name="ln5292">                IObuff[0] = '|';</a>
<a name="ln5293">                *s = '|';</a>
<a name="ln5294">                while (*s != NUL) {</a>
<a name="ln5295">                  if (*s == '\r' || *s == '\n')</a>
<a name="ln5296">                    *s = NUL;</a>
<a name="ln5297">                  /* The text is utf-8 when a byte</a>
<a name="ln5298">                   * above 127 is found and no</a>
<a name="ln5299">                   * illegal byte sequence is found.</a>
<a name="ln5300">                   */</a>
<a name="ln5301">                  if (*s &gt;= 0x80 &amp;&amp; this_utf != kFalse) {</a>
<a name="ln5302">                    this_utf = kTrue;</a>
<a name="ln5303">                    const int l = utf_ptr2len(s);</a>
<a name="ln5304">                    if (l == 1) {</a>
<a name="ln5305">                      this_utf = kFalse;</a>
<a name="ln5306">                    }</a>
<a name="ln5307">                    s += l - 1;</a>
<a name="ln5308">                  }</a>
<a name="ln5309">                  ++s;</a>
<a name="ln5310">                }</a>
<a name="ln5311">                /* The help file is latin1 or utf-8;</a>
<a name="ln5312">                 * conversion to the current</a>
<a name="ln5313">                 * 'encoding' may be required. */</a>
<a name="ln5314">                vc.vc_type = CONV_NONE;</a>
<a name="ln5315">                convert_setup(</a>
<a name="ln5316">                    &amp;vc,</a>
<a name="ln5317">                    (char_u *)(this_utf == kTrue ? &quot;utf-8&quot; : &quot;latin1&quot;),</a>
<a name="ln5318">                    p_enc);</a>
<a name="ln5319">                if (vc.vc_type == CONV_NONE) {</a>
<a name="ln5320">                  // No conversion needed.</a>
<a name="ln5321">                  cp = IObuff;</a>
<a name="ln5322">                } else {</a>
<a name="ln5323">                  // Do the conversion.  If it fails</a>
<a name="ln5324">                  // use the unconverted text.</a>
<a name="ln5325">                  cp = string_convert(&amp;vc, IObuff, NULL);</a>
<a name="ln5326">                  if (cp == NULL) {</a>
<a name="ln5327">                    cp = IObuff;</a>
<a name="ln5328">                  }</a>
<a name="ln5329">                }</a>
<a name="ln5330">                convert_setup(&amp;vc, NULL, NULL);</a>
<a name="ln5331"> </a>
<a name="ln5332">                ml_append(lnum, cp, (colnr_T)0, false);</a>
<a name="ln5333">                if (cp != IObuff) {</a>
<a name="ln5334">                  xfree(cp);</a>
<a name="ln5335">                }</a>
<a name="ln5336">                lnum++;</a>
<a name="ln5337">              }</a>
<a name="ln5338">              fclose(fd);</a>
<a name="ln5339">            }</a>
<a name="ln5340">            FreeWild(fcount, fnames);</a>
<a name="ln5341">          }</a>
<a name="ln5342">        }</a>
<a name="ln5343">        xfree(rt);</a>
<a name="ln5344">      }</a>
<a name="ln5345">      break;</a>
<a name="ln5346">    }</a>
<a name="ln5347">  }</a>
<a name="ln5348">}</a>
<a name="ln5349"> </a>
<a name="ln5350">/*</a>
<a name="ln5351"> * &quot;:exusage&quot;</a>
<a name="ln5352"> */</a>
<a name="ln5353">void ex_exusage(exarg_T *eap)</a>
<a name="ln5354">{</a>
<a name="ln5355">  do_cmdline_cmd(&quot;help ex-cmd-index&quot;);</a>
<a name="ln5356">}</a>
<a name="ln5357"> </a>
<a name="ln5358">/*</a>
<a name="ln5359"> * &quot;:viusage&quot;</a>
<a name="ln5360"> */</a>
<a name="ln5361">void ex_viusage(exarg_T *eap)</a>
<a name="ln5362">{</a>
<a name="ln5363">  do_cmdline_cmd(&quot;help normal-index&quot;);</a>
<a name="ln5364">}</a>
<a name="ln5365"> </a>
<a name="ln5366"> </a>
<a name="ln5367">/// Generate tags in one help directory</a>
<a name="ln5368">///</a>
<a name="ln5369">/// @param dir  Path to the doc directory</a>
<a name="ln5370">/// @param ext  Suffix of the help files (&quot;.txt&quot;, &quot;.itx&quot;, &quot;.frx&quot;, etc.)</a>
<a name="ln5371">/// @param tagname  Name of the tags file (&quot;tags&quot; for English, &quot;tags-fr&quot; for</a>
<a name="ln5372">///                 French)</a>
<a name="ln5373">/// @param add_help_tags  Whether to add the &quot;help-tags&quot; tag</a>
<a name="ln5374">/// @param ignore_writeerr  ignore write error</a>
<a name="ln5375">static void helptags_one(char_u *dir, const char_u *ext, const char_u *tagfname,</a>
<a name="ln5376">                         bool add_help_tags, bool ignore_writeerr)</a>
<a name="ln5377">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5378">{</a>
<a name="ln5379">  garray_T ga;</a>
<a name="ln5380">  int filecount;</a>
<a name="ln5381">  char_u      **files;</a>
<a name="ln5382">  char_u      *p1, *p2;</a>
<a name="ln5383">  char_u      *s;</a>
<a name="ln5384">  TriState utf8 = kNone;</a>
<a name="ln5385">  bool mix = false;             // detected mixed encodings</a>
<a name="ln5386"> </a>
<a name="ln5387">  // Find all *.txt files.</a>
<a name="ln5388">  size_t dirlen = STRLCPY(NameBuff, dir, sizeof(NameBuff));</a>
<a name="ln5389">  if (dirlen &gt;= MAXPATHL</a>
<a name="ln5390">      || STRLCAT(NameBuff, &quot;/**/*&quot;, sizeof(NameBuff)) &gt;= MAXPATHL  // NOLINT</a>
<a name="ln5391">      || STRLCAT(NameBuff, ext, sizeof(NameBuff)) &gt;= MAXPATHL) {</a>
<a name="ln5392">    EMSG(_(e_fnametoolong));</a>
<a name="ln5393">    return;</a>
<a name="ln5394">  }</a>
<a name="ln5395"> </a>
<a name="ln5396">  // Note: We cannot just do `&amp;NameBuff` because it is a statically sized array</a>
<a name="ln5397">  //       so `NameBuff == &amp;NameBuff` according to C semantics.</a>
<a name="ln5398">  char_u *buff_list[1] = {NameBuff};</a>
<a name="ln5399">  if (gen_expand_wildcards(1, buff_list, &amp;filecount, &amp;files,</a>
<a name="ln5400">          EW_FILE|EW_SILENT) == FAIL</a>
<a name="ln5401">      || filecount == 0) {</a>
<a name="ln5402">    if (!got_int) {</a>
<a name="ln5403">      EMSG2(_(&quot;E151: No match: %s&quot;), NameBuff);</a>
<a name="ln5404">    }</a>
<a name="ln5405">    return;</a>
<a name="ln5406">  }</a>
<a name="ln5407"> </a>
<a name="ln5408">  //</a>
<a name="ln5409">  // Open the tags file for writing.</a>
<a name="ln5410">  // Do this before scanning through all the files.</a>
<a name="ln5411">  //</a>
<a name="ln5412">  memcpy(NameBuff, dir, dirlen + 1);</a>
<a name="ln5413">  if (!add_pathsep((char *)NameBuff)</a>
<a name="ln5414">      || STRLCAT(NameBuff, tagfname, sizeof(NameBuff)) &gt;= MAXPATHL) {</a>
<a name="ln5415">    EMSG(_(e_fnametoolong));</a>
<a name="ln5416">    return;</a>
<a name="ln5417">  }</a>
<a name="ln5418"> </a>
<a name="ln5419">  FILE *const fd_tags = os_fopen((char *)NameBuff, &quot;w&quot;);</a>
<a name="ln5420">  if (fd_tags == NULL) {</a>
<a name="ln5421">    if (!ignore_writeerr) {</a>
<a name="ln5422">      EMSG2(_(&quot;E152: Cannot open %s for writing&quot;), NameBuff);</a>
<a name="ln5423">    }</a>
<a name="ln5424">    FreeWild(filecount, files);</a>
<a name="ln5425">    return;</a>
<a name="ln5426">  }</a>
<a name="ln5427"> </a>
<a name="ln5428">  // If using the &quot;++t&quot; argument or generating tags for &quot;$VIMRUNTIME/doc&quot;</a>
<a name="ln5429">  // add the &quot;help-tags&quot; tag.</a>
<a name="ln5430">  ga_init(&amp;ga, (int)sizeof(char_u *), 100);</a>
<a name="ln5431">  if (add_help_tags</a>
<a name="ln5432">      || path_full_compare((char_u *)&quot;$VIMRUNTIME/doc&quot;,</a>
<a name="ln5433">                           dir, false, true) == kEqualFiles) {</a>
<a name="ln5434">    s = xmalloc(18 + STRLEN(tagfname));</a>
<a name="ln5435">    sprintf((char *)s, &quot;help-tags\t%s\t1\n&quot;, tagfname);</a>
<a name="ln5436">    GA_APPEND(char_u *, &amp;ga, s);</a>
<a name="ln5437">  }</a>
<a name="ln5438"> </a>
<a name="ln5439">  // Go over all the files and extract the tags.</a>
<a name="ln5440">  for (int fi = 0; fi &lt; filecount &amp;&amp; !got_int; fi++) {</a>
<a name="ln5441">    FILE *const fd = os_fopen((char *)files[fi], &quot;r&quot;);</a>
<a name="ln5442">    if (fd == NULL) {</a>
<a name="ln5443">      EMSG2(_(&quot;E153: Unable to open %s for reading&quot;), files[fi]);</a>
<a name="ln5444">      continue;</a>
<a name="ln5445">    }</a>
<a name="ln5446">    const char_u *const fname = files[fi] + dirlen + 1;</a>
<a name="ln5447"> </a>
<a name="ln5448">    bool firstline = true;</a>
<a name="ln5449">    while (!vim_fgets(IObuff, IOSIZE, fd) &amp;&amp; !got_int) {</a>
<a name="ln5450">      if (firstline) {</a>
<a name="ln5451">        // Detect utf-8 file by a non-ASCII char in the first line.</a>
<a name="ln5452">        TriState this_utf8 = kNone;</a>
<a name="ln5453">        for (s = IObuff; *s != NUL; s++) {</a>
<a name="ln5454">          if (*s &gt;= 0x80) {</a>
<a name="ln5455">            this_utf8 = kTrue;</a>
<a name="ln5456">            const int l = utf_ptr2len(s);</a>
<a name="ln5457">            if (l == 1) {</a>
<a name="ln5458">              // Illegal UTF-8 byte sequence.</a>
<a name="ln5459">              this_utf8 = kFalse;</a>
<a name="ln5460">              break;</a>
<a name="ln5461">            }</a>
<a name="ln5462">            s += l - 1;</a>
<a name="ln5463">          }</a>
<a name="ln5464">        }</a>
<a name="ln5465">        if (this_utf8 == kNone) {           // only ASCII characters found</a>
<a name="ln5466">          this_utf8 = kFalse;</a>
<a name="ln5467">        }</a>
<a name="ln5468">        if (utf8 == kNone) {                // first file</a>
<a name="ln5469">          utf8 = this_utf8;</a>
<a name="ln5470">        } else if (utf8 != this_utf8) {</a>
<a name="ln5471">          EMSG2(_(</a>
<a name="ln5472">                  &quot;E670: Mix of help file encodings within a language: %s&quot;),</a>
<a name="ln5473">              files[fi]);</a>
<a name="ln5474">          mix = !got_int;</a>
<a name="ln5475">          got_int = TRUE;</a>
<a name="ln5476">        }</a>
<a name="ln5477">        firstline = false;</a>
<a name="ln5478">      }</a>
<a name="ln5479">      p1 = vim_strchr(IObuff, '*');                        // find first '*'</a>
<a name="ln5480">      while (p1 != NULL) {</a>
<a name="ln5481">        p2 = (char_u *)strchr((const char *)p1 + 1, '*');  // Find second '*'.</a>
<a name="ln5482">        if (p2 != NULL &amp;&amp; p2 &gt; p1 + 1) {                   // Skip &quot;*&quot; and &quot;**&quot;.</a>
<a name="ln5483">          for (s = p1 + 1; s &lt; p2; s++) {</a>
<a name="ln5484">            if (*s == ' ' || *s == '\t' || *s == '|') {</a>
<a name="ln5485">              break;</a>
<a name="ln5486">            }</a>
<a name="ln5487">          }</a>
<a name="ln5488"> </a>
<a name="ln5489">          // Only accept a *tag* when it consists of valid</a>
<a name="ln5490">          // characters, there is white space before it and is</a>
<a name="ln5491">          // followed by a white character or end-of-line.</a>
<a name="ln5492">          if (s == p2</a>
<a name="ln5493">              &amp;&amp; (p1 == IObuff || p1[-1] == ' ' || p1[-1] == '\t')</a>
<a name="ln5494">              &amp;&amp; (vim_strchr((char_u *)&quot; \t\n\r&quot;, s[1]) != NULL</a>
<a name="ln5495">                  || s[1] == '\0')) {</a>
<a name="ln5496">            *p2 = '\0';</a>
<a name="ln5497">            ++p1;</a>
<a name="ln5498">            s = xmalloc((p2 - p1) + STRLEN(fname) + 2);</a>
<a name="ln5499">            GA_APPEND(char_u *, &amp;ga, s);</a>
<a name="ln5500">            sprintf((char *)s, &quot;%s\t%s&quot;, p1, fname);</a>
<a name="ln5501"> </a>
<a name="ln5502">            // find next '*'</a>
<a name="ln5503">            p2 = vim_strchr(p2 + 1, '*');</a>
<a name="ln5504">          }</a>
<a name="ln5505">        }</a>
<a name="ln5506">        p1 = p2;</a>
<a name="ln5507">      }</a>
<a name="ln5508">      line_breakcheck();</a>
<a name="ln5509">    }</a>
<a name="ln5510"> </a>
<a name="ln5511">    fclose(fd);</a>
<a name="ln5512">  }</a>
<a name="ln5513"> </a>
<a name="ln5514">  FreeWild(filecount, files);</a>
<a name="ln5515"> </a>
<a name="ln5516">  if (!got_int &amp;&amp; ga.ga_data != NULL) {</a>
<a name="ln5517">    // Sort the tags.</a>
<a name="ln5518">    sort_strings((char_u **)ga.ga_data, ga.ga_len);</a>
<a name="ln5519"> </a>
<a name="ln5520">    // Check for duplicates.</a>
<a name="ln5521">    for (int i = 1; i &lt; ga.ga_len; i++) {</a>
<a name="ln5522">      p1 = ((char_u **)ga.ga_data)[i - 1];</a>
<a name="ln5523">      p2 = ((char_u **)ga.ga_data)[i];</a>
<a name="ln5524">      while (*p1 == *p2) {</a>
<a name="ln5525">        if (*p2 == '\t') {</a>
<a name="ln5526">          *p2 = NUL;</a>
<a name="ln5527">          vim_snprintf((char *)NameBuff, MAXPATHL,</a>
<a name="ln5528">              _(&quot;E154: Duplicate tag \&quot;%s\&quot; in file %s/%s&quot;),</a>
<a name="ln5529">              ((char_u **)ga.ga_data)[i], dir, p2 + 1);</a>
<a name="ln5530">          EMSG(NameBuff);</a>
<a name="ln5531">          *p2 = '\t';</a>
<a name="ln5532">          break;</a>
<a name="ln5533">        }</a>
<a name="ln5534">        ++p1;</a>
<a name="ln5535">        ++p2;</a>
<a name="ln5536">      }</a>
<a name="ln5537">    }</a>
<a name="ln5538"> </a>
<a name="ln5539">    if (utf8 == kTrue) {</a>
<a name="ln5540">      fprintf(fd_tags, &quot;!_TAG_FILE_ENCODING\tutf-8\t//\n&quot;);</a>
<a name="ln5541">    }</a>
<a name="ln5542"> </a>
<a name="ln5543">    // Write the tags into the file.</a>
<a name="ln5544">    for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln5545">      s = ((char_u **)ga.ga_data)[i];</a>
<a name="ln5546">      if (STRNCMP(s, &quot;help-tags\t&quot;, 10) == 0) {</a>
<a name="ln5547">        // help-tags entry was added in formatted form</a>
<a name="ln5548">        fputs((char *)s, fd_tags);</a>
<a name="ln5549">      } else {</a>
<a name="ln5550">        fprintf(fd_tags, &quot;%s\t/&quot; &quot;*&quot;, s);</a>
<a name="ln5551">        for (p1 = s; *p1 != '\t'; p1++) {</a>
<a name="ln5552">          // insert backslash before '\\' and '/'</a>
<a name="ln5553">          if (*p1 == '\\' || *p1 == '/') {</a>
<a name="ln5554">            putc('\\', fd_tags);</a>
<a name="ln5555">          }</a>
<a name="ln5556">          putc(*p1, fd_tags);</a>
<a name="ln5557">        }</a>
<a name="ln5558">        fprintf(fd_tags, &quot;*\n&quot;);</a>
<a name="ln5559">      }</a>
<a name="ln5560">    }</a>
<a name="ln5561">  }</a>
<a name="ln5562">  if (mix) {</a>
<a name="ln5563">    got_int = false;        // continue with other languages</a>
<a name="ln5564">  }</a>
<a name="ln5565"> </a>
<a name="ln5566">  GA_DEEP_CLEAR_PTR(&amp;ga);</a>
<a name="ln5567">  fclose(fd_tags);          // there is no check for an error...</a>
<a name="ln5568">}</a>
<a name="ln5569"> </a>
<a name="ln5570">/// Generate tags in one help directory, taking care of translations.</a>
<a name="ln5571">static void do_helptags(char_u *dirname, bool add_help_tags,</a>
<a name="ln5572">                        bool ignore_writeerr)</a>
<a name="ln5573">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5574">{</a>
<a name="ln5575">  int len;</a>
<a name="ln5576">  garray_T ga;</a>
<a name="ln5577">  char_u lang[2];</a>
<a name="ln5578">  char_u ext[5];</a>
<a name="ln5579">  char_u fname[8];</a>
<a name="ln5580">  int filecount;</a>
<a name="ln5581">  char_u **files;</a>
<a name="ln5582"> </a>
<a name="ln5583">  // Get a list of all files in the help directory and in subdirectories.</a>
<a name="ln5584">  STRLCPY(NameBuff, dirname, sizeof(NameBuff));</a>
<a name="ln5585">  if (!add_pathsep((char *)NameBuff)</a>
<a name="ln5586">      || STRLCAT(NameBuff, &quot;**&quot;, sizeof(NameBuff)) &gt;= MAXPATHL) {</a>
<a name="ln5587">    EMSG(_(e_fnametoolong));</a>
<a name="ln5588">    return;</a>
<a name="ln5589">  }</a>
<a name="ln5590"> </a>
<a name="ln5591">  // Note: We cannot just do `&amp;NameBuff` because it is a statically sized array</a>
<a name="ln5592">  //       so `NameBuff == &amp;NameBuff` according to C semantics.</a>
<a name="ln5593">  char_u *buff_list[1] = {NameBuff};</a>
<a name="ln5594">  if (gen_expand_wildcards(1, buff_list, &amp;filecount, &amp;files,</a>
<a name="ln5595">                           EW_FILE|EW_SILENT) == FAIL</a>
<a name="ln5596">      || filecount == 0) {</a>
<a name="ln5597">    EMSG2(_(&quot;E151: No match: %s&quot;), NameBuff);</a>
<a name="ln5598">    return;</a>
<a name="ln5599">  }</a>
<a name="ln5600"> </a>
<a name="ln5601">  /* Go over all files in the directory to find out what languages are</a>
<a name="ln5602">   * present. */</a>
<a name="ln5603">  int j;</a>
<a name="ln5604">  ga_init(&amp;ga, 1, 10);</a>
<a name="ln5605">  for (int i = 0; i &lt; filecount; i++) {</a>
<a name="ln5606">    len = (int)STRLEN(files[i]);</a>
<a name="ln5607">    if (len &lt;= 4) {</a>
<a name="ln5608">      continue;</a>
<a name="ln5609">    }</a>
<a name="ln5610">    if (STRICMP(files[i] + len - 4, &quot;.txt&quot;) == 0) {</a>
<a name="ln5611">      /* &quot;.txt&quot; -&gt; language &quot;en&quot; */</a>
<a name="ln5612">      lang[0] = 'e';</a>
<a name="ln5613">      lang[1] = 'n';</a>
<a name="ln5614">    } else if (files[i][len - 4] == '.'</a>
<a name="ln5615">               &amp;&amp; ASCII_ISALPHA(files[i][len - 3])</a>
<a name="ln5616">               &amp;&amp; ASCII_ISALPHA(files[i][len - 2])</a>
<a name="ln5617">               &amp;&amp; TOLOWER_ASC(files[i][len - 1]) == 'x') {</a>
<a name="ln5618">      /* &quot;.abx&quot; -&gt; language &quot;ab&quot; */</a>
<a name="ln5619">      lang[0] = TOLOWER_ASC(files[i][len - 3]);</a>
<a name="ln5620">      lang[1] = TOLOWER_ASC(files[i][len - 2]);</a>
<a name="ln5621">    } else</a>
<a name="ln5622">      continue;</a>
<a name="ln5623"> </a>
<a name="ln5624">    // Did we find this language already?</a>
<a name="ln5625">    for (j = 0; j &lt; ga.ga_len; j += 2) {</a>
<a name="ln5626">      if (STRNCMP(lang, ((char_u *)ga.ga_data) + j, 2) == 0) {</a>
<a name="ln5627">        break;</a>
<a name="ln5628">      }</a>
<a name="ln5629">    }</a>
<a name="ln5630">    if (j == ga.ga_len) {</a>
<a name="ln5631">      // New language, add it.</a>
<a name="ln5632">      ga_grow(&amp;ga, 2);</a>
<a name="ln5633">      ((char_u *)ga.ga_data)[ga.ga_len++] = lang[0];</a>
<a name="ln5634">      ((char_u *)ga.ga_data)[ga.ga_len++] = lang[1];</a>
<a name="ln5635">    }</a>
<a name="ln5636">  }</a>
<a name="ln5637"> </a>
<a name="ln5638">  /*</a>
<a name="ln5639">   * Loop over the found languages to generate a tags file for each one.</a>
<a name="ln5640">   */</a>
<a name="ln5641">  for (j = 0; j &lt; ga.ga_len; j += 2) {</a>
<a name="ln5642">    STRCPY(fname, &quot;tags-xx&quot;);</a>
<a name="ln5643">    fname[5] = ((char_u *)ga.ga_data)[j];</a>
<a name="ln5644">    fname[6] = ((char_u *)ga.ga_data)[j + 1];</a>
<a name="ln5645">    if (fname[5] == 'e' &amp;&amp; fname[6] == 'n') {</a>
<a name="ln5646">      /* English is an exception: use &quot;.txt&quot; and &quot;tags&quot;. */</a>
<a name="ln5647">      fname[4] = NUL;</a>
<a name="ln5648">      STRCPY(ext, &quot;.txt&quot;);</a>
<a name="ln5649">    } else {</a>
<a name="ln5650">      /* Language &quot;ab&quot; uses &quot;.abx&quot; and &quot;tags-ab&quot;. */</a>
<a name="ln5651">      STRCPY(ext, &quot;.xxx&quot;);</a>
<a name="ln5652">      ext[1] = fname[5];</a>
<a name="ln5653">      ext[2] = fname[6];</a>
<a name="ln5654">    }</a>
<a name="ln5655">    helptags_one(dirname, ext, fname, add_help_tags, ignore_writeerr);</a>
<a name="ln5656">  }</a>
<a name="ln5657"> </a>
<a name="ln5658">  ga_clear(&amp;ga);</a>
<a name="ln5659">  FreeWild(filecount, files);</a>
<a name="ln5660">}</a>
<a name="ln5661"> </a>
<a name="ln5662">static void helptags_cb(char_u *fname, void *cookie)</a>
<a name="ln5663">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5664">{</a>
<a name="ln5665">    do_helptags(fname, *(bool *)cookie, true);</a>
<a name="ln5666">}</a>
<a name="ln5667"> </a>
<a name="ln5668">/*</a>
<a name="ln5669"> * &quot;:helptags&quot;</a>
<a name="ln5670"> */</a>
<a name="ln5671">void ex_helptags(exarg_T *eap)</a>
<a name="ln5672">{</a>
<a name="ln5673">  expand_T xpc;</a>
<a name="ln5674">  char_u *dirname;</a>
<a name="ln5675">  bool add_help_tags = false;</a>
<a name="ln5676"> </a>
<a name="ln5677">  /* Check for &quot;:helptags ++t {dir}&quot;. */</a>
<a name="ln5678">  if (STRNCMP(eap-&gt;arg, &quot;++t&quot;, 3) == 0 &amp;&amp; ascii_iswhite(eap-&gt;arg[3])) {</a>
<a name="ln5679">    add_help_tags = true;</a>
<a name="ln5680">    eap-&gt;arg = skipwhite(eap-&gt;arg + 3);</a>
<a name="ln5681">  }</a>
<a name="ln5682"> </a>
<a name="ln5683">  if (STRCMP(eap-&gt;arg, &quot;ALL&quot;) == 0) {</a>
<a name="ln5684">    do_in_path(p_rtp, (char_u *)&quot;doc&quot;, DIP_ALL + DIP_DIR,</a>
<a name="ln5685">               helptags_cb, &amp;add_help_tags);</a>
<a name="ln5686">  } else {</a>
<a name="ln5687">    ExpandInit(&amp;xpc);</a>
<a name="ln5688">    xpc.xp_context = EXPAND_DIRECTORIES;</a>
<a name="ln5689">    dirname = ExpandOne(&amp;xpc, eap-&gt;arg, NULL,</a>
<a name="ln5690">                        WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);</a>
<a name="ln5691">    if (dirname == NULL || !os_isdir(dirname)) {</a>
<a name="ln5692">      EMSG2(_(&quot;E150: Not a directory: %s&quot;), eap-&gt;arg);</a>
<a name="ln5693">    } else {</a>
<a name="ln5694">      do_helptags(dirname, add_help_tags, false);</a>
<a name="ln5695">    }</a>
<a name="ln5696">    xfree(dirname);</a>
<a name="ln5697">  }</a>
<a name="ln5698">}</a>
<a name="ln5699"> </a>
<a name="ln5700">/*</a>
<a name="ln5701"> * &quot;:helpclose&quot;: Close one help window</a>
<a name="ln5702"> */</a>
<a name="ln5703">void ex_helpclose(exarg_T *eap)</a>
<a name="ln5704">{</a>
<a name="ln5705">  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {</a>
<a name="ln5706">    if (bt_help(win-&gt;w_buffer)) {</a>
<a name="ln5707">      win_close(win, false);</a>
<a name="ln5708">      return;</a>
<a name="ln5709">    }</a>
<a name="ln5710">  }</a>
<a name="ln5711">}</a>
<a name="ln5712"> </a>
<a name="ln5713">/// Tries to enter to an existing window of given buffer. If no existing buffer</a>
<a name="ln5714">/// is found, creates a new split.</a>
<a name="ln5715">///</a>
<a name="ln5716">/// Returns OK/FAIL.</a>
<a name="ln5717">int sub_preview_win(buf_T *preview_buf)</a>
<a name="ln5718">{</a>
<a name="ln5719">  if (preview_buf != NULL) {</a>
<a name="ln5720">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln5721">      if (wp-&gt;w_buffer == preview_buf) {</a>
<a name="ln5722">        win_enter(wp, false);</a>
<a name="ln5723"> </a>
<a name="ln5724">        return OK;</a>
<a name="ln5725">      }</a>
<a name="ln5726">    }</a>
<a name="ln5727">  }</a>
<a name="ln5728">  return win_split((int)p_cwh, WSP_BOT);</a>
<a name="ln5729">}</a>
<a name="ln5730"> </a>
<a name="ln5731">/// Shows the effects of the :substitute command being typed ('inccommand').</a>
<a name="ln5732">/// If inccommand=split, shows a preview window and later restores the layout.</a>
<a name="ln5733">static buf_T *show_sub(exarg_T *eap, pos_T old_cusr,</a>
<a name="ln5734">                       PreviewLines *preview_lines, int hl_id, int src_id,</a>
<a name="ln5735">                       handle_T bufnr)</a>
<a name="ln5736">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5737">{</a>
<a name="ln5738">  win_T *save_curwin = curwin;</a>
<a name="ln5739">  cmdmod_T save_cmdmod = cmdmod;</a>
<a name="ln5740">  char_u *save_shm_p = vim_strsave(p_shm);</a>
<a name="ln5741">  PreviewLines lines = *preview_lines;</a>
<a name="ln5742">  buf_T *orig_buf = curbuf;</a>
<a name="ln5743"> </a>
<a name="ln5744">  // We keep a special-purpose buffer around, but don't assume it exists.</a>
<a name="ln5745">  buf_T *preview_buf = bufnr ? buflist_findnr(bufnr) : 0;</a>
<a name="ln5746">  cmdmod.split = 0;               // disable :leftabove/botright modifiers</a>
<a name="ln5747">  cmdmod.tab = 0;                 // disable :tab modifier</a>
<a name="ln5748">  cmdmod.noswapfile = true;       // disable swap for preview buffer</a>
<a name="ln5749">  // disable file info message</a>
<a name="ln5750">  set_string_option_direct(&quot;shm&quot;, -1, (char_u *)&quot;F&quot;, OPT_FREE,</a>
<a name="ln5751">                           SID_NONE);</a>
<a name="ln5752"> </a>
<a name="ln5753">  bool outside_curline = (eap-&gt;line1 != old_cusr.lnum</a>
<a name="ln5754">                          || eap-&gt;line2 != old_cusr.lnum);</a>
<a name="ln5755">  bool preview = outside_curline &amp;&amp; (*p_icm != 'n');</a>
<a name="ln5756">  if (preview_buf == curbuf) {  // Preview buffer cannot preview itself!</a>
<a name="ln5757">    preview = false;</a>
<a name="ln5758">    preview_buf = NULL;</a>
<a name="ln5759">  }</a>
<a name="ln5760"> </a>
<a name="ln5761">  // Place cursor on nearest matching line, to undo do_sub() cursor placement.</a>
<a name="ln5762">  for (size_t i = 0; i &lt; lines.subresults.size; i++) {</a>
<a name="ln5763">    SubResult curres = lines.subresults.items[i];</a>
<a name="ln5764">    if (curres.start.lnum &gt;= old_cusr.lnum) {</a>
<a name="ln5765">      curwin-&gt;w_cursor.lnum = curres.start.lnum;</a>
<a name="ln5766">      curwin-&gt;w_cursor.col = curres.start.col;</a>
<a name="ln5767">      break;</a>
<a name="ln5768">    }  // Else: All matches are above, do_sub() already placed cursor.</a>
<a name="ln5769">  }</a>
<a name="ln5770"> </a>
<a name="ln5771">  // Width of the &quot;| lnum|...&quot; column which displays the line numbers.</a>
<a name="ln5772">  linenr_T highest_num_line = 0;</a>
<a name="ln5773">  int col_width = 0;</a>
<a name="ln5774"> </a>
<a name="ln5775">  if (preview &amp;&amp; sub_preview_win(preview_buf) != FAIL) {</a>
<a name="ln5776">    buf_open_scratch(preview_buf ? bufnr : 0, &quot;[Preview]&quot;);</a>
<a name="ln5777">    buf_clear();</a>
<a name="ln5778">    preview_buf = curbuf;</a>
<a name="ln5779">    curbuf-&gt;b_p_bl = false;</a>
<a name="ln5780">    curbuf-&gt;b_p_ma = true;</a>
<a name="ln5781">    curbuf-&gt;b_p_ul = -1;</a>
<a name="ln5782">    curbuf-&gt;b_p_tw = 0;         // Reset 'textwidth' (was set by ftplugin)</a>
<a name="ln5783">    curwin-&gt;w_p_cul = false;</a>
<a name="ln5784">    curwin-&gt;w_p_cuc = false;</a>
<a name="ln5785">    curwin-&gt;w_p_spell = false;</a>
<a name="ln5786">    curwin-&gt;w_p_fen = false;</a>
<a name="ln5787"> </a>
<a name="ln5788">    if (lines.subresults.size &gt; 0) {</a>
<a name="ln5789">      highest_num_line = kv_last(lines.subresults).end.lnum;</a>
<a name="ln5790">      col_width = log10(highest_num_line) + 1 + 3;</a>
<a name="ln5791">    }</a>
<a name="ln5792">  } else {</a>
<a name="ln5793">    // Failed to split the window, don't show 'inccommand' preview.</a>
<a name="ln5794">    preview_buf = NULL;</a>
<a name="ln5795">  }</a>
<a name="ln5796"> </a>
<a name="ln5797">  char *str = NULL;  // construct the line to show in here</a>
<a name="ln5798">  size_t old_line_size = 0;</a>
<a name="ln5799">  size_t line_size = 0;</a>
<a name="ln5800">  linenr_T linenr_preview = 0;  // last line added to preview buffer</a>
<a name="ln5801">  linenr_T linenr_origbuf = 0;  // last line added to original buffer</a>
<a name="ln5802">  linenr_T next_linenr = 0;     // next line to show for the match</a>
<a name="ln5803"> </a>
<a name="ln5804">  for (size_t matchidx = 0; matchidx &lt; lines.subresults.size; matchidx++) {</a>
<a name="ln5805">    SubResult match = lines.subresults.items[matchidx];</a>
<a name="ln5806"> </a>
<a name="ln5807">    if (preview_buf) {</a>
<a name="ln5808">      lpos_T p_start = { 0, match.start.col };  // match starts here in preview</a>
<a name="ln5809">      lpos_T p_end   = { 0, match.end.col };    // ... and ends here</a>
<a name="ln5810"> </a>
<a name="ln5811">      if (match.pre_match == 0) {</a>
<a name="ln5812">        next_linenr = match.start.lnum;</a>
<a name="ln5813">      } else {</a>
<a name="ln5814">        next_linenr = match.pre_match;</a>
<a name="ln5815">      }</a>
<a name="ln5816">      // Don't add a line twice</a>
<a name="ln5817">      if (next_linenr == linenr_origbuf) {</a>
<a name="ln5818">        next_linenr++;</a>
<a name="ln5819">        p_start.lnum = linenr_preview;  // might be redefined below</a>
<a name="ln5820">        p_end.lnum = linenr_preview;  // might be redefined below</a>
<a name="ln5821">      }</a>
<a name="ln5822"> </a>
<a name="ln5823">      for (; next_linenr &lt;= match.end.lnum; next_linenr++) {</a>
<a name="ln5824">        if (next_linenr == match.start.lnum) {</a>
<a name="ln5825">          p_start.lnum = linenr_preview + 1;</a>
<a name="ln5826">        }</a>
<a name="ln5827">        if (next_linenr == match.end.lnum) {</a>
<a name="ln5828">          p_end.lnum = linenr_preview + 1;</a>
<a name="ln5829">        }</a>
<a name="ln5830">        char *line;</a>
<a name="ln5831">        if (next_linenr == orig_buf-&gt;b_ml.ml_line_count + 1) {</a>
<a name="ln5832">          line = &quot;&quot;;</a>
<a name="ln5833">        } else {</a>
<a name="ln5834">          line = (char *)ml_get_buf(orig_buf, next_linenr, false);</a>
<a name="ln5835">          line_size = strlen(line) + col_width + 1;</a>
<a name="ln5836"> </a>
<a name="ln5837">          // Reallocate if line not long enough</a>
<a name="ln5838">          if (line_size &gt; old_line_size) {</a>
<a name="ln5839">            str = xrealloc(str, line_size * sizeof(char));</a>
<a name="ln5840">            old_line_size = line_size;</a>
<a name="ln5841">          }</a>
<a name="ln5842">        }</a>
<a name="ln5843">        // Put &quot;|lnum| line&quot; into `str` and append it to the preview buffer.</a>
<a name="ln5844">        snprintf(str, line_size, &quot;|%*ld| %s&quot;, col_width - 3,</a>
<a name="ln5845">                 next_linenr, line);</a>
<a name="ln5846">        if (linenr_preview == 0) {</a>
<a name="ln5847">          ml_replace(1, (char_u *)str, true);</a>
<a name="ln5848">        } else {</a>
<a name="ln5849">          ml_append(linenr_preview, (char_u *)str, (colnr_T)line_size, false);</a>
<a name="ln5850">        }</a>
<a name="ln5851">        linenr_preview += 1;</a>
<a name="ln5852">      }</a>
<a name="ln5853">      linenr_origbuf = match.end.lnum;</a>
<a name="ln5854"> </a>
<a name="ln5855">      bufhl_add_hl_pos_offset(preview_buf, src_id, hl_id, p_start,</a>
<a name="ln5856">                              p_end, col_width);</a>
<a name="ln5857">    }</a>
<a name="ln5858">    bufhl_add_hl_pos_offset(orig_buf, src_id, hl_id, match.start,</a>
<a name="ln5859">                            match.end, 0);</a>
<a name="ln5860">  }</a>
<a name="ln5861">  xfree(str);</a>
<a name="ln5862"> </a>
<a name="ln5863">  redraw_later(curwin, SOME_VALID);</a>
<a name="ln5864">  win_enter(save_curwin, false);  // Return to original window</a>
<a name="ln5865">  update_topline(curwin);</a>
<a name="ln5866"> </a>
<a name="ln5867">  // Update screen now.</a>
<a name="ln5868">  int save_rd = RedrawingDisabled;</a>
<a name="ln5869">  RedrawingDisabled = 0;</a>
<a name="ln5870">  update_screen(SOME_VALID);</a>
<a name="ln5871">  RedrawingDisabled = save_rd;</a>
<a name="ln5872"> </a>
<a name="ln5873">  set_string_option_direct(&quot;shm&quot;, -1, save_shm_p, OPT_FREE, SID_NONE);</a>
<a name="ln5874">  xfree(save_shm_p);</a>
<a name="ln5875"> </a>
<a name="ln5876">  cmdmod = save_cmdmod;</a>
<a name="ln5877"> </a>
<a name="ln5878">  return preview_buf;</a>
<a name="ln5879">}</a>
<a name="ln5880"> </a>
<a name="ln5881">/// Closes any open windows for inccommand preview buffer.</a>
<a name="ln5882">void close_preview_windows(void)</a>
<a name="ln5883">{</a>
<a name="ln5884">    block_autocmds();</a>
<a name="ln5885">    buf_T *buf = preview_bufnr ? buflist_findnr(preview_bufnr) : NULL;</a>
<a name="ln5886">    if (buf != NULL) {</a>
<a name="ln5887">      close_windows(buf, false);</a>
<a name="ln5888">    }</a>
<a name="ln5889">    unblock_autocmds();</a>
<a name="ln5890">}</a>
<a name="ln5891"> </a>
<a name="ln5892">/// :substitute command</a>
<a name="ln5893">///</a>
<a name="ln5894">/// If 'inccommand' is empty: calls do_sub().</a>
<a name="ln5895">/// If 'inccommand' is set: shows a &quot;live&quot; preview then removes the changes.</a>
<a name="ln5896">/// from undo history.</a>
<a name="ln5897">void ex_substitute(exarg_T *eap)</a>
<a name="ln5898">{</a>
<a name="ln5899">  bool preview = (State &amp; CMDPREVIEW);</a>
<a name="ln5900">  if (*p_icm == NUL || !preview) {  // 'inccommand' is disabled</a>
<a name="ln5901">    close_preview_windows();</a>
<a name="ln5902">    (void)do_sub(eap, profile_zero(), true, preview_bufnr);</a>
<a name="ln5903"> </a>
<a name="ln5904">    return;</a>
<a name="ln5905">  }</a>
<a name="ln5906"> </a>
<a name="ln5907">  block_autocmds();           // Disable events during command preview.</a>
<a name="ln5908"> </a>
<a name="ln5909">  char_u *save_eap = eap-&gt;arg;</a>
<a name="ln5910">  garray_T save_view;</a>
<a name="ln5911">  win_size_save(&amp;save_view);  // Save current window sizes.</a>
<a name="ln5912">  save_search_patterns();</a>
<a name="ln5913">  int save_changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln5914">  time_t save_b_u_time_cur = curbuf-&gt;b_u_time_cur;</a>
<a name="ln5915">  u_header_T *save_b_u_newhead = curbuf-&gt;b_u_newhead;</a>
<a name="ln5916">  long save_b_p_ul = curbuf-&gt;b_p_ul;</a>
<a name="ln5917">  int save_w_p_cul = curwin-&gt;w_p_cul;</a>
<a name="ln5918">  int save_w_p_cuc = curwin-&gt;w_p_cuc;</a>
<a name="ln5919"> </a>
<a name="ln5920">  curbuf-&gt;b_p_ul = LONG_MAX;  // make sure we can undo all changes</a>
<a name="ln5921">  curwin-&gt;w_p_cul = false;    // Disable 'cursorline'</a>
<a name="ln5922">  curwin-&gt;w_p_cuc = false;    // Disable 'cursorcolumn'</a>
<a name="ln5923"> </a>
<a name="ln5924">  // Don't show search highlighting during live substitution</a>
<a name="ln5925">  bool save_hls = p_hls;</a>
<a name="ln5926">  p_hls = false;</a>
<a name="ln5927">  buf_T *preview_buf = do_sub(eap, profile_setlimit(p_rdt), false,</a>
<a name="ln5928">                              preview_bufnr);</a>
<a name="ln5929">  p_hls = save_hls;</a>
<a name="ln5930"> </a>
<a name="ln5931">  if (preview_buf != NULL) {</a>
<a name="ln5932">    preview_bufnr = preview_buf-&gt;handle;</a>
<a name="ln5933">  }</a>
<a name="ln5934"> </a>
<a name="ln5935">  if (save_changedtick != buf_get_changedtick(curbuf)) {</a>
<a name="ln5936">    // Undo invisibly. This also moves the cursor!</a>
<a name="ln5937">    if (!u_undo_and_forget(1)) { abort(); }</a>
<a name="ln5938">    // Restore newhead. It is meaningless when curhead is valid, but we must</a>
<a name="ln5939">    // restore it so that undotree() is identical before/after the preview.</a>
<a name="ln5940">    curbuf-&gt;b_u_newhead = save_b_u_newhead;</a>
<a name="ln5941">    curbuf-&gt;b_u_time_cur = save_b_u_time_cur;</a>
<a name="ln5942">    buf_set_changedtick(curbuf, save_changedtick);</a>
<a name="ln5943">  }</a>
<a name="ln5944"> </a>
<a name="ln5945">  curbuf-&gt;b_p_ul = save_b_p_ul;</a>
<a name="ln5946">  curwin-&gt;w_p_cul = save_w_p_cul;   // Restore 'cursorline'</a>
<a name="ln5947">  curwin-&gt;w_p_cuc = save_w_p_cuc;   // Restore 'cursorcolumn'</a>
<a name="ln5948">  eap-&gt;arg = save_eap;</a>
<a name="ln5949">  restore_search_patterns();</a>
<a name="ln5950">  win_size_restore(&amp;save_view);</a>
<a name="ln5951">  ga_clear(&amp;save_view);</a>
<a name="ln5952">  unblock_autocmds();</a>
<a name="ln5953">}</a>
<a name="ln5954"> </a>
<a name="ln5955">/// Skip over the pattern argument of &quot;:vimgrep /pat/[g][j]&quot;.</a>
<a name="ln5956">/// Put the start of the pattern in &quot;*s&quot;, unless &quot;s&quot; is NULL.</a>
<a name="ln5957">/// If &quot;flags&quot; is not NULL put the flags in it: VGR_GLOBAL, VGR_NOJUMP.</a>
<a name="ln5958">/// If &quot;s&quot; is not NULL terminate the pattern with a NUL.</a>
<a name="ln5959">/// Return a pointer to the char just past the pattern plus flags.</a>
<a name="ln5960">char_u *skip_vimgrep_pat(char_u *p, char_u **s, int *flags)</a>
<a name="ln5961">{</a>
<a name="ln5962">  int c;</a>
<a name="ln5963"> </a>
<a name="ln5964">  if (vim_isIDc(*p)) {</a>
<a name="ln5965">    // &quot;:vimgrep pattern fname&quot;</a>
<a name="ln5966">    if (s != NULL) {</a>
<a name="ln5967">      *s = p;</a>
<a name="ln5968">    }</a>
<a name="ln5969">    p = skiptowhite(p);</a>
<a name="ln5970">    if (s != NULL &amp;&amp; *p != NUL) {</a>
<a name="ln5971">      *p++ = NUL;</a>
<a name="ln5972">    }</a>
<a name="ln5973">  } else {</a>
<a name="ln5974">    // &quot;:vimgrep /pattern/[g][j] fname&quot;</a>
<a name="ln5975">    if (s != NULL) {</a>
<a name="ln5976">      *s = p + 1;</a>
<a name="ln5977">    }</a>
<a name="ln5978">    c = *p;</a>
<a name="ln5979">    p = skip_regexp(p + 1, c, true, NULL);</a>
<a name="ln5980">    if (*p != c) {</a>
<a name="ln5981">      return NULL;</a>
<a name="ln5982">    }</a>
<a name="ln5983"> </a>
<a name="ln5984">    // Truncate the pattern.</a>
<a name="ln5985">    if (s != NULL) {</a>
<a name="ln5986">      *p = NUL;</a>
<a name="ln5987">    }</a>
<a name="ln5988">    p++;</a>
<a name="ln5989"> </a>
<a name="ln5990">    // Find the flags</a>
<a name="ln5991">    while (*p == 'g' || *p == 'j') {</a>
<a name="ln5992">      if (flags != NULL) {</a>
<a name="ln5993">        if (*p == 'g') {</a>
<a name="ln5994">          *flags |= VGR_GLOBAL;</a>
<a name="ln5995">        } else {</a>
<a name="ln5996">          *flags |= VGR_NOJUMP;</a>
<a name="ln5997">        }</a>
<a name="ln5998">      }</a>
<a name="ln5999">      p++;</a>
<a name="ln6000">    }</a>
<a name="ln6001">  }</a>
<a name="ln6002">  return p;</a>
<a name="ln6003">}</a>
<a name="ln6004"> </a>
<a name="ln6005">/// List v:oldfiles in a nice way.</a>
<a name="ln6006">void ex_oldfiles(exarg_T *eap)</a>
<a name="ln6007">{</a>
<a name="ln6008">  list_T      *l = get_vim_var_list(VV_OLDFILES);</a>
<a name="ln6009">  long nr = 0;</a>
<a name="ln6010"> </a>
<a name="ln6011">  if (l == NULL) {</a>
<a name="ln6012">    msg((char_u *)_(&quot;No old files&quot;));</a>
<a name="ln6013">  } else {</a>
<a name="ln6014">    msg_start();</a>
<a name="ln6015">    msg_scroll = true;</a>
<a name="ln6016">    TV_LIST_ITER(l, li, {</a>
<a name="ln6017">      if (got_int) {</a>
<a name="ln6018">        break;</a>
<a name="ln6019">      }</a>
<a name="ln6020">      nr++;</a>
<a name="ln6021">      const char *fname = tv_get_string(TV_LIST_ITEM_TV(li));</a>
<a name="ln6022">      if (!message_filtered((char_u *)fname)) {</a>
<a name="ln6023">        msg_outnum(nr);</a>
<a name="ln6024">        MSG_PUTS(&quot;: &quot;);</a>
<a name="ln6025">        msg_outtrans((char_u *)tv_get_string(TV_LIST_ITEM_TV(li)));</a>
<a name="ln6026">        msg_clr_eos();</a>
<a name="ln6027">        msg_putchar('\n');</a>
<a name="ln6028">        ui_flush();                  // output one line at a time</a>
<a name="ln6029">        os_breakcheck();</a>
<a name="ln6030">      }</a>
<a name="ln6031">    });</a>
<a name="ln6032"> </a>
<a name="ln6033">    // Assume &quot;got_int&quot; was set to truncate the listing.</a>
<a name="ln6034">    got_int = false;</a>
<a name="ln6035"> </a>
<a name="ln6036">    // File selection prompt on &quot;:browse oldfiles&quot;</a>
<a name="ln6037">    if (cmdmod.browse) {</a>
<a name="ln6038">      quit_more = false;</a>
<a name="ln6039">      nr = prompt_for_number(false);</a>
<a name="ln6040">      msg_starthere();</a>
<a name="ln6041">      if (nr &gt; 0 &amp;&amp; nr &lt;= tv_list_len(l)) {</a>
<a name="ln6042">        const char *const p = tv_list_find_str(l, nr - 1);</a>
<a name="ln6043">        if (p == NULL) {</a>
<a name="ln6044">          return;</a>
<a name="ln6045">        }</a>
<a name="ln6046">        char *const s = (char *)expand_env_save((char_u *)p);</a>
<a name="ln6047">        eap-&gt;arg = (char_u *)s;</a>
<a name="ln6048">        eap-&gt;cmdidx = CMD_edit;</a>
<a name="ln6049">        cmdmod.browse = false;</a>
<a name="ln6050">        do_exedit(eap, NULL);</a>
<a name="ln6051">        xfree(s);</a>
<a name="ln6052">      }</a>
<a name="ln6053">    }</a>
<a name="ln6054">  }</a>
<a name="ln6055">}</a>

</code></pre>
<div class="balloon" rel="3670"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'current_match.start.lnum' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
