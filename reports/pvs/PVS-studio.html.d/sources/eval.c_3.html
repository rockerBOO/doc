
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>eval.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * eval.c: Expression evaluation.</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;math.h&gt;</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;auto/config.h&quot;</a>
<a name="ln11"> </a>
<a name="ln12">#ifdef HAVE_LOCALE_H</a>
<a name="ln13"># include &lt;locale.h&gt;</a>
<a name="ln14">#endif</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln18">#include &quot;nvim/change.h&quot;</a>
<a name="ln19">#include &quot;nvim/channel.h&quot;</a>
<a name="ln20">#include &quot;nvim/charset.h&quot;</a>
<a name="ln21">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln22">#include &quot;nvim/edit.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval.h&quot;</a>
<a name="ln25">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln26">#include &quot;nvim/eval/executor.h&quot;</a>
<a name="ln27">#include &quot;nvim/eval/gc.h&quot;</a>
<a name="ln28">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln29">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln30">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln31">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln32">#include &quot;nvim/ex_session.h&quot;</a>
<a name="ln33">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln34">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln35">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln36">#include &quot;nvim/mark.h&quot;</a>
<a name="ln37">#include &quot;nvim/memline.h&quot;</a>
<a name="ln38">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln39">#include &quot;nvim/move.h&quot;</a>
<a name="ln40">#include &quot;nvim/ops.h&quot;</a>
<a name="ln41">#include &quot;nvim/option.h&quot;</a>
<a name="ln42">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln43">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln44">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln45">#include &quot;nvim/path.h&quot;</a>
<a name="ln46">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln47">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln48">#include &quot;nvim/screen.h&quot;</a>
<a name="ln49">#include &quot;nvim/search.h&quot;</a>
<a name="ln50">#include &quot;nvim/sign.h&quot;</a>
<a name="ln51">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln52">#include &quot;nvim/ui.h&quot;</a>
<a name="ln53">#include &quot;nvim/undo.h&quot;</a>
<a name="ln54">#include &quot;nvim/version.h&quot;</a>
<a name="ln55">#include &quot;nvim/window.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57"> </a>
<a name="ln58">// TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead</a>
<a name="ln59"> </a>
<a name="ln60">#define DICT_MAXNEST 100        // maximum nesting of lists and dicts</a>
<a name="ln61"> </a>
<a name="ln62"> </a>
<a name="ln63">static char *e_letunexp = N_(&quot;E18: Unexpected characters in :let&quot;);</a>
<a name="ln64">static char *e_missbrac = N_(&quot;E111: Missing ']'&quot;);</a>
<a name="ln65">static char *e_dictrange = N_(&quot;E719: Cannot use [:] with a Dictionary&quot;);</a>
<a name="ln66">static char *e_illvar = N_(&quot;E461: Illegal variable name: %s&quot;);</a>
<a name="ln67">static char *e_cannot_mod = N_(&quot;E995: Cannot modify existing variable&quot;);</a>
<a name="ln68">static char *e_invalwindow = N_(&quot;E957: Invalid window number&quot;);</a>
<a name="ln69">static char *e_lock_unlock = N_(&quot;E940: Cannot lock or unlock variable %s&quot;);</a>
<a name="ln70"> </a>
<a name="ln71">// TODO(ZyX-I): move to eval/executor</a>
<a name="ln72">static char *e_letwrong = N_(&quot;E734: Wrong variable type for %s=&quot;);</a>
<a name="ln73"> </a>
<a name="ln74">static char_u * const namespace_char = (char_u *)&quot;abglstvw&quot;;</a>
<a name="ln75"> </a>
<a name="ln76">/// Variable used for g:</a>
<a name="ln77">static ScopeDictDictItem globvars_var;</a>
<a name="ln78"> </a>
<a name="ln79">/*</a>
<a name="ln80"> * Old Vim variables such as &quot;v:version&quot; are also available without the &quot;v:&quot;.</a>
<a name="ln81"> * Also in functions.  We need a special hashtable for them.</a>
<a name="ln82"> */</a>
<a name="ln83">static hashtab_T compat_hashtab;</a>
<a name="ln84"> </a>
<a name="ln85">/// Used for checking if local variables or arguments used in a lambda.</a>
<a name="ln86">bool *eval_lavars_used = NULL;</a>
<a name="ln87"> </a>
<a name="ln88">/*</a>
<a name="ln89"> * Array to hold the hashtab with variables local to each sourced script.</a>
<a name="ln90"> * Each item holds a variable (nameless) that points to the dict_T.</a>
<a name="ln91"> */</a>
<a name="ln92">typedef struct {</a>
<a name="ln93">  ScopeDictDictItem sv_var;</a>
<a name="ln94">  dict_T sv_dict;</a>
<a name="ln95">} scriptvar_T;</a>
<a name="ln96"> </a>
<a name="ln97">static garray_T ga_scripts = {0, 0, sizeof(scriptvar_T *), 4, NULL};</a>
<a name="ln98">#define SCRIPT_SV(id) (((scriptvar_T **)ga_scripts.ga_data)[(id) - 1])</a>
<a name="ln99">#define SCRIPT_VARS(id) (SCRIPT_SV(id)-&gt;sv_dict.dv_hashtab)</a>
<a name="ln100"> </a>
<a name="ln101">static int echo_attr = 0;   // attributes used for &quot;:echo&quot;</a>
<a name="ln102"> </a>
<a name="ln103">// The names of packages that once were loaded are remembered.</a>
<a name="ln104">static garray_T ga_loaded = { 0, 0, sizeof(char_u *), 4, NULL };</a>
<a name="ln105"> </a>
<a name="ln106">/*</a>
<a name="ln107"> * Info used by a &quot;:for&quot; loop.</a>
<a name="ln108"> */</a>
<a name="ln109">typedef struct {</a>
<a name="ln110">  int fi_semicolon;             // TRUE if ending in '; var]'</a>
<a name="ln111">  int fi_varcount;              // nr of variables in the list</a>
<a name="ln112">  listwatch_T fi_lw;            // keep an eye on the item used.</a>
<a name="ln113">  list_T      *fi_list;         // list being used</a>
<a name="ln114">} forinfo_T;</a>
<a name="ln115"> </a>
<a name="ln116">// values for vv_flags:</a>
<a name="ln117">#define VV_COMPAT       1       // compatible, also used without &quot;v:&quot;</a>
<a name="ln118">#define VV_RO           2       // read-only</a>
<a name="ln119">#define VV_RO_SBX       4       // read-only in the sandbox</a>
<a name="ln120"> </a>
<a name="ln121">#define VV(idx, name, type, flags) \</a>
<a name="ln122">  [idx] = { \</a>
<a name="ln123">    .vv_name = name, \</a>
<a name="ln124">    .vv_di = { \</a>
<a name="ln125">      .di_tv = { .v_type = type }, \</a>
<a name="ln126">      .di_flags = 0, \</a>
<a name="ln127">      .di_key = { 0 }, \</a>
<a name="ln128">    }, \</a>
<a name="ln129">    .vv_flags = flags, \</a>
<a name="ln130">  }</a>
<a name="ln131"> </a>
<a name="ln132">// Array to hold the value of v: variables.</a>
<a name="ln133">// The value is in a dictitem, so that it can also be used in the v: scope.</a>
<a name="ln134">// The reason to use this table anyway is for very quick access to the</a>
<a name="ln135">// variables with the VV_ defines.</a>
<a name="ln136">static struct vimvar {</a>
<a name="ln137">  char        *vv_name;  ///&lt; Name of the variable, without v:.</a>
<a name="ln138">  TV_DICTITEM_STRUCT(17) vv_di;  ///&lt; Value and name for key (max 16 chars).</a>
<a name="ln139">  char vv_flags;  ///&lt; Flags: #VV_COMPAT, #VV_RO, #VV_RO_SBX.</a>
<a name="ln140">} vimvars[] =</a>
<a name="ln141">{</a>
<a name="ln142">  // VV_ tails differing from upcased string literals:</a>
<a name="ln143">  // VV_CC_FROM &quot;charconvert_from&quot;</a>
<a name="ln144">  // VV_CC_TO &quot;charconvert_to&quot;</a>
<a name="ln145">  // VV_SEND_SERVER &quot;servername&quot;</a>
<a name="ln146">  // VV_REG &quot;register&quot;</a>
<a name="ln147">  // VV_OP &quot;operator&quot;</a>
<a name="ln148">  VV(VV_COUNT,          &quot;count&quot;,            VAR_NUMBER, VV_RO),</a>
<a name="ln149">  VV(VV_COUNT1,         &quot;count1&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln150">  VV(VV_PREVCOUNT,      &quot;prevcount&quot;,        VAR_NUMBER, VV_RO),</a>
<a name="ln151">  VV(VV_ERRMSG,         &quot;errmsg&quot;,           VAR_STRING, 0),</a>
<a name="ln152">  VV(VV_WARNINGMSG,     &quot;warningmsg&quot;,       VAR_STRING, 0),</a>
<a name="ln153">  VV(VV_STATUSMSG,      &quot;statusmsg&quot;,        VAR_STRING, 0),</a>
<a name="ln154">  VV(VV_SHELL_ERROR,    &quot;shell_error&quot;,      VAR_NUMBER, VV_RO),</a>
<a name="ln155">  VV(VV_THIS_SESSION,   &quot;this_session&quot;,     VAR_STRING, 0),</a>
<a name="ln156">  VV(VV_VERSION,        &quot;version&quot;,          VAR_NUMBER, VV_COMPAT+VV_RO),</a>
<a name="ln157">  VV(VV_LNUM,           &quot;lnum&quot;,             VAR_NUMBER, VV_RO_SBX),</a>
<a name="ln158">  VV(VV_TERMRESPONSE,   &quot;termresponse&quot;,     VAR_STRING, VV_RO),</a>
<a name="ln159">  VV(VV_FNAME,          &quot;fname&quot;,            VAR_STRING, VV_RO),</a>
<a name="ln160">  VV(VV_LANG,           &quot;lang&quot;,             VAR_STRING, VV_RO),</a>
<a name="ln161">  VV(VV_LC_TIME,        &quot;lc_time&quot;,          VAR_STRING, VV_RO),</a>
<a name="ln162">  VV(VV_CTYPE,          &quot;ctype&quot;,            VAR_STRING, VV_RO),</a>
<a name="ln163">  VV(VV_CC_FROM,        &quot;charconvert_from&quot;, VAR_STRING, VV_RO),</a>
<a name="ln164">  VV(VV_CC_TO,          &quot;charconvert_to&quot;,   VAR_STRING, VV_RO),</a>
<a name="ln165">  VV(VV_FNAME_IN,       &quot;fname_in&quot;,         VAR_STRING, VV_RO),</a>
<a name="ln166">  VV(VV_FNAME_OUT,      &quot;fname_out&quot;,        VAR_STRING, VV_RO),</a>
<a name="ln167">  VV(VV_FNAME_NEW,      &quot;fname_new&quot;,        VAR_STRING, VV_RO),</a>
<a name="ln168">  VV(VV_FNAME_DIFF,     &quot;fname_diff&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln169">  VV(VV_CMDARG,         &quot;cmdarg&quot;,           VAR_STRING, VV_RO),</a>
<a name="ln170">  VV(VV_FOLDSTART,      &quot;foldstart&quot;,        VAR_NUMBER, VV_RO_SBX),</a>
<a name="ln171">  VV(VV_FOLDEND,        &quot;foldend&quot;,          VAR_NUMBER, VV_RO_SBX),</a>
<a name="ln172">  VV(VV_FOLDDASHES,     &quot;folddashes&quot;,       VAR_STRING, VV_RO_SBX),</a>
<a name="ln173">  VV(VV_FOLDLEVEL,      &quot;foldlevel&quot;,        VAR_NUMBER, VV_RO_SBX),</a>
<a name="ln174">  VV(VV_PROGNAME,       &quot;progname&quot;,         VAR_STRING, VV_RO),</a>
<a name="ln175">  VV(VV_SEND_SERVER,    &quot;servername&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln176">  VV(VV_DYING,          &quot;dying&quot;,            VAR_NUMBER, VV_RO),</a>
<a name="ln177">  VV(VV_EXCEPTION,      &quot;exception&quot;,        VAR_STRING, VV_RO),</a>
<a name="ln178">  VV(VV_THROWPOINT,     &quot;throwpoint&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln179">  VV(VV_REG,            &quot;register&quot;,         VAR_STRING, VV_RO),</a>
<a name="ln180">  VV(VV_CMDBANG,        &quot;cmdbang&quot;,          VAR_NUMBER, VV_RO),</a>
<a name="ln181">  VV(VV_INSERTMODE,     &quot;insertmode&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln182">  VV(VV_VAL,            &quot;val&quot;,              VAR_UNKNOWN, VV_RO),</a>
<a name="ln183">  VV(VV_KEY,            &quot;key&quot;,              VAR_UNKNOWN, VV_RO),</a>
<a name="ln184">  VV(VV_PROFILING,      &quot;profiling&quot;,        VAR_NUMBER, VV_RO),</a>
<a name="ln185">  VV(VV_FCS_REASON,     &quot;fcs_reason&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln186">  VV(VV_FCS_CHOICE,     &quot;fcs_choice&quot;,       VAR_STRING, 0),</a>
<a name="ln187">  VV(VV_BEVAL_BUFNR,    &quot;beval_bufnr&quot;,      VAR_NUMBER, VV_RO),</a>
<a name="ln188">  VV(VV_BEVAL_WINNR,    &quot;beval_winnr&quot;,      VAR_NUMBER, VV_RO),</a>
<a name="ln189">  VV(VV_BEVAL_WINID,    &quot;beval_winid&quot;,      VAR_NUMBER, VV_RO),</a>
<a name="ln190">  VV(VV_BEVAL_LNUM,     &quot;beval_lnum&quot;,       VAR_NUMBER, VV_RO),</a>
<a name="ln191">  VV(VV_BEVAL_COL,      &quot;beval_col&quot;,        VAR_NUMBER, VV_RO),</a>
<a name="ln192">  VV(VV_BEVAL_TEXT,     &quot;beval_text&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln193">  VV(VV_SCROLLSTART,    &quot;scrollstart&quot;,      VAR_STRING, 0),</a>
<a name="ln194">  VV(VV_SWAPNAME,       &quot;swapname&quot;,         VAR_STRING, VV_RO),</a>
<a name="ln195">  VV(VV_SWAPCHOICE,     &quot;swapchoice&quot;,       VAR_STRING, 0),</a>
<a name="ln196">  VV(VV_SWAPCOMMAND,    &quot;swapcommand&quot;,      VAR_STRING, VV_RO),</a>
<a name="ln197">  VV(VV_CHAR,           &quot;char&quot;,             VAR_STRING, 0),</a>
<a name="ln198">  VV(VV_MOUSE_WIN,      &quot;mouse_win&quot;,        VAR_NUMBER, 0),</a>
<a name="ln199">  VV(VV_MOUSE_WINID,    &quot;mouse_winid&quot;,      VAR_NUMBER, 0),</a>
<a name="ln200">  VV(VV_MOUSE_LNUM,     &quot;mouse_lnum&quot;,       VAR_NUMBER, 0),</a>
<a name="ln201">  VV(VV_MOUSE_COL,      &quot;mouse_col&quot;,        VAR_NUMBER, 0),</a>
<a name="ln202">  VV(VV_OP,             &quot;operator&quot;,         VAR_STRING, VV_RO),</a>
<a name="ln203">  VV(VV_SEARCHFORWARD,  &quot;searchforward&quot;,    VAR_NUMBER, 0),</a>
<a name="ln204">  VV(VV_HLSEARCH,       &quot;hlsearch&quot;,         VAR_NUMBER, 0),</a>
<a name="ln205">  VV(VV_OLDFILES,       &quot;oldfiles&quot;,         VAR_LIST, 0),</a>
<a name="ln206">  VV(VV_WINDOWID,       &quot;windowid&quot;,         VAR_NUMBER, VV_RO_SBX),</a>
<a name="ln207">  VV(VV_PROGPATH,       &quot;progpath&quot;,         VAR_STRING, VV_RO),</a>
<a name="ln208">  VV(VV_COMPLETED_ITEM, &quot;completed_item&quot;,   VAR_DICT, VV_RO),</a>
<a name="ln209">  VV(VV_OPTION_NEW,     &quot;option_new&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln210">  VV(VV_OPTION_OLD,     &quot;option_old&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln211">  VV(VV_OPTION_TYPE,    &quot;option_type&quot;,      VAR_STRING, VV_RO),</a>
<a name="ln212">  VV(VV_ERRORS,         &quot;errors&quot;,           VAR_LIST, 0),</a>
<a name="ln213">  VV(VV_FALSE,          &quot;false&quot;,            VAR_BOOL, VV_RO),</a>
<a name="ln214">  VV(VV_TRUE,           &quot;true&quot;,             VAR_BOOL, VV_RO),</a>
<a name="ln215">  VV(VV_NULL,           &quot;null&quot;,             VAR_SPECIAL, VV_RO),</a>
<a name="ln216">  VV(VV_NUMBERMAX,      &quot;numbermax&quot;,        VAR_NUMBER, VV_RO),</a>
<a name="ln217">  VV(VV_NUMBERMIN,      &quot;numbermin&quot;,        VAR_NUMBER, VV_RO),</a>
<a name="ln218">  VV(VV_NUMBERSIZE,     &quot;numbersize&quot;,       VAR_NUMBER, VV_RO),</a>
<a name="ln219">  VV(VV_VIM_DID_ENTER,  &quot;vim_did_enter&quot;,    VAR_NUMBER, VV_RO),</a>
<a name="ln220">  VV(VV_TESTING,        &quot;testing&quot;,          VAR_NUMBER, 0),</a>
<a name="ln221">  VV(VV_TYPE_NUMBER,    &quot;t_number&quot;,         VAR_NUMBER, VV_RO),</a>
<a name="ln222">  VV(VV_TYPE_STRING,    &quot;t_string&quot;,         VAR_NUMBER, VV_RO),</a>
<a name="ln223">  VV(VV_TYPE_FUNC,      &quot;t_func&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln224">  VV(VV_TYPE_LIST,      &quot;t_list&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln225">  VV(VV_TYPE_DICT,      &quot;t_dict&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln226">  VV(VV_TYPE_FLOAT,     &quot;t_float&quot;,          VAR_NUMBER, VV_RO),</a>
<a name="ln227">  VV(VV_TYPE_BOOL,      &quot;t_bool&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln228">  VV(VV_EVENT,          &quot;event&quot;,            VAR_DICT, VV_RO),</a>
<a name="ln229">  VV(VV_ECHOSPACE,      &quot;echospace&quot;,        VAR_NUMBER, VV_RO),</a>
<a name="ln230">  VV(VV_ARGV,           &quot;argv&quot;,             VAR_LIST, VV_RO),</a>
<a name="ln231">  VV(VV_COLLATE,        &quot;collate&quot;,          VAR_STRING, VV_RO),</a>
<a name="ln232">  VV(VV_EXITING,        &quot;exiting&quot;,          VAR_NUMBER, VV_RO),</a>
<a name="ln233">  // Neovim</a>
<a name="ln234">  VV(VV_STDERR,         &quot;stderr&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln235">  VV(VV_MSGPACK_TYPES,  &quot;msgpack_types&quot;,    VAR_DICT, VV_RO),</a>
<a name="ln236">  VV(VV__NULL_STRING,   &quot;_null_string&quot;,     VAR_STRING, VV_RO),</a>
<a name="ln237">  VV(VV__NULL_LIST,     &quot;_null_list&quot;,       VAR_LIST, VV_RO),</a>
<a name="ln238">  VV(VV__NULL_DICT,     &quot;_null_dict&quot;,       VAR_DICT, VV_RO),</a>
<a name="ln239">  VV(VV_LUA,            &quot;lua&quot;,              VAR_PARTIAL, VV_RO),</a>
<a name="ln240">};</a>
<a name="ln241">#undef VV</a>
<a name="ln242"> </a>
<a name="ln243">// shorthand</a>
<a name="ln244">#define vv_type         vv_di.di_tv.v_type</a>
<a name="ln245">#define vv_nr           vv_di.di_tv.vval.v_number</a>
<a name="ln246">#define vv_bool         vv_di.di_tv.vval.v_bool</a>
<a name="ln247">#define vv_special      vv_di.di_tv.vval.v_special</a>
<a name="ln248">#define vv_float        vv_di.di_tv.vval.v_float</a>
<a name="ln249">#define vv_str          vv_di.di_tv.vval.v_string</a>
<a name="ln250">#define vv_list         vv_di.di_tv.vval.v_list</a>
<a name="ln251">#define vv_dict         vv_di.di_tv.vval.v_dict</a>
<a name="ln252">#define vv_partial      vv_di.di_tv.vval.v_partial</a>
<a name="ln253">#define vv_tv           vv_di.di_tv</a>
<a name="ln254"> </a>
<a name="ln255">/// Variable used for v:</a>
<a name="ln256">static ScopeDictDictItem vimvars_var;</a>
<a name="ln257"> </a>
<a name="ln258">static partial_T *vvlua_partial;</a>
<a name="ln259"> </a>
<a name="ln260">/// v: hashtab</a>
<a name="ln261">#define vimvarht  vimvardict.dv_hashtab</a>
<a name="ln262"> </a>
<a name="ln263">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln264"># include &quot;eval.c.generated.h&quot;</a>
<a name="ln265">#endif</a>
<a name="ln266"> </a>
<a name="ln267">static uint64_t last_timer_id = 1;</a>
<a name="ln268">static PMap(uint64_t) *timers = NULL;</a>
<a name="ln269"> </a>
<a name="ln270">static const char *const msgpack_type_names[] = {</a>
<a name="ln271">  [kMPNil] = &quot;nil&quot;,</a>
<a name="ln272">  [kMPBoolean] = &quot;boolean&quot;,</a>
<a name="ln273">  [kMPInteger] = &quot;integer&quot;,</a>
<a name="ln274">  [kMPFloat] = &quot;float&quot;,</a>
<a name="ln275">  [kMPString] = &quot;string&quot;,</a>
<a name="ln276">  [kMPBinary] = &quot;binary&quot;,</a>
<a name="ln277">  [kMPArray] = &quot;array&quot;,</a>
<a name="ln278">  [kMPMap] = &quot;map&quot;,</a>
<a name="ln279">  [kMPExt] = &quot;ext&quot;,</a>
<a name="ln280">};</a>
<a name="ln281">const list_T *eval_msgpack_type_lists[] = {</a>
<a name="ln282">  [kMPNil] = NULL,</a>
<a name="ln283">  [kMPBoolean] = NULL,</a>
<a name="ln284">  [kMPInteger] = NULL,</a>
<a name="ln285">  [kMPFloat] = NULL,</a>
<a name="ln286">  [kMPString] = NULL,</a>
<a name="ln287">  [kMPBinary] = NULL,</a>
<a name="ln288">  [kMPArray] = NULL,</a>
<a name="ln289">  [kMPMap] = NULL,</a>
<a name="ln290">  [kMPExt] = NULL,</a>
<a name="ln291">};</a>
<a name="ln292"> </a>
<a name="ln293">// Return &quot;n1&quot; divided by &quot;n2&quot;, taking care of dividing by zero.</a>
<a name="ln294">varnumber_T num_divide(varnumber_T n1, varnumber_T n2)</a>
<a name="ln295">  FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln296">{</a>
<a name="ln297">  varnumber_T result;</a>
<a name="ln298"> </a>
<a name="ln299">  if (n2 == 0) {  // give an error message?</a>
<a name="ln300">    if (n1 == 0) {</a>
<a name="ln301">      result = VARNUMBER_MIN;  // similar to NaN</a>
<a name="ln302">    } else if (n1 &lt; 0) {</a>
<a name="ln303">      result = -VARNUMBER_MAX;</a>
<a name="ln304">    } else {</a>
<a name="ln305">      result = VARNUMBER_MAX;</a>
<a name="ln306">    }</a>
<a name="ln307">  } else {</a>
<a name="ln308">    result = n1 / n2;</a>
<a name="ln309">  }</a>
<a name="ln310"> </a>
<a name="ln311">  return result;</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314">// Return &quot;n1&quot; modulus &quot;n2&quot;, taking care of dividing by zero.</a>
<a name="ln315">varnumber_T num_modulus(varnumber_T n1, varnumber_T n2)</a>
<a name="ln316">  FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln317">{</a>
<a name="ln318">  // Give an error when n2 is 0?</a>
<a name="ln319">  return (n2 == 0) ? 0 : (n1 % n2);</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322">/*</a>
<a name="ln323"> * Initialize the global and v: variables.</a>
<a name="ln324"> */</a>
<a name="ln325">void eval_init(void)</a>
<a name="ln326">{</a>
<a name="ln327">  vimvars[VV_VERSION].vv_nr = VIM_VERSION_100;</a>
<a name="ln328"> </a>
<a name="ln329">  timers = pmap_new(uint64_t)();</a>
<a name="ln330">  struct vimvar   *p;</a>
<a name="ln331"> </a>
<a name="ln332">  init_var_dict(&amp;globvardict, &amp;globvars_var, VAR_DEF_SCOPE);</a>
<a name="ln333">  init_var_dict(&amp;vimvardict, &amp;vimvars_var, VAR_SCOPE);</a>
<a name="ln334">  vimvardict.dv_lock = VAR_FIXED;</a>
<a name="ln335">  hash_init(&amp;compat_hashtab);</a>
<a name="ln336">  func_init();</a>
<a name="ln337"> </a>
<a name="ln338">  for (size_t i = 0; i &lt; ARRAY_SIZE(vimvars); i++) {</a>
<a name="ln339">    p = &amp;vimvars[i];</a>
<a name="ln340">    assert(STRLEN(p-&gt;vv_name) &lt;= 16);</a>
<a name="ln341">    STRCPY(p-&gt;vv_di.di_key, p-&gt;vv_name);</a>
<a name="ln342">    if (p-&gt;vv_flags &amp; VV_RO)</a>
<a name="ln343">      p-&gt;vv_di.di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln344">    else if (p-&gt;vv_flags &amp; VV_RO_SBX)</a>
<a name="ln345">      p-&gt;vv_di.di_flags = DI_FLAGS_RO_SBX | DI_FLAGS_FIX;</a>
<a name="ln346">    else</a>
<a name="ln347">      p-&gt;vv_di.di_flags = DI_FLAGS_FIX;</a>
<a name="ln348"> </a>
<a name="ln349">    // add to v: scope dict, unless the value is not always available</a>
<a name="ln350">    if (p-&gt;vv_type != VAR_UNKNOWN) {</a>
<a name="ln351">      hash_add(&amp;vimvarht, p-&gt;vv_di.di_key);</a>
<a name="ln352">    }</a>
<a name="ln353">    if (p-&gt;vv_flags &amp; VV_COMPAT) {</a>
<a name="ln354">      // add to compat scope dict</a>
<a name="ln355">      hash_add(&amp;compat_hashtab, p-&gt;vv_di.di_key);</a>
<a name="ln356">    }</a>
<a name="ln357">  }</a>
<a name="ln358">  vimvars[VV_VERSION].vv_nr = VIM_VERSION_100;</a>
<a name="ln359"> </a>
<a name="ln360">  dict_T *const msgpack_types_dict = tv_dict_alloc();</a>
<a name="ln361">  for (size_t i = 0; i &lt; ARRAY_SIZE(msgpack_type_names); i++) {</a>
<a name="ln362">    list_T *const type_list = tv_list_alloc(0);</a>
<a name="ln363">    tv_list_set_lock(type_list, VAR_FIXED);</a>
<a name="ln364">    tv_list_ref(type_list);</a>
<a name="ln365">    dictitem_T *const di = tv_dict_item_alloc(msgpack_type_names[i]);</a>
<a name="ln366">    di-&gt;di_flags |= DI_FLAGS_RO|DI_FLAGS_FIX;</a>
<a name="ln367">    di-&gt;di_tv = (typval_T) {</a>
<a name="ln368">      .v_type = VAR_LIST,</a>
<a name="ln369">      .vval = { .v_list = type_list, },</a>
<a name="ln370">    };</a>
<a name="ln371">    eval_msgpack_type_lists[i] = type_list;</a>
<a name="ln372">    if (tv_dict_add(msgpack_types_dict, di) == FAIL) {</a>
<a name="ln373">      // There must not be duplicate items in this dictionary by definition.</a>
<a name="ln374">      abort();</a>
<a name="ln375">    }</a>
<a name="ln376">  }</a>
<a name="ln377">  msgpack_types_dict-&gt;dv_lock = VAR_FIXED;</a>
<a name="ln378"> </a>
<a name="ln379">  set_vim_var_dict(VV_MSGPACK_TYPES, msgpack_types_dict);</a>
<a name="ln380">  set_vim_var_dict(VV_COMPLETED_ITEM, tv_dict_alloc_lock(VAR_FIXED));</a>
<a name="ln381"> </a>
<a name="ln382">  set_vim_var_dict(VV_EVENT, tv_dict_alloc_lock(VAR_FIXED));</a>
<a name="ln383">  set_vim_var_list(VV_ERRORS, tv_list_alloc(kListLenUnknown));</a>
<a name="ln384">  set_vim_var_nr(VV_STDERR,   CHAN_STDERR);</a>
<a name="ln385">  set_vim_var_nr(VV_SEARCHFORWARD, 1L);</a>
<a name="ln386">  set_vim_var_nr(VV_HLSEARCH, 1L);</a>
<a name="ln387">  set_vim_var_nr(VV_COUNT1, 1);</a>
<a name="ln388">  set_vim_var_nr(VV_TYPE_NUMBER, VAR_TYPE_NUMBER);</a>
<a name="ln389">  set_vim_var_nr(VV_TYPE_STRING, VAR_TYPE_STRING);</a>
<a name="ln390">  set_vim_var_nr(VV_TYPE_FUNC,   VAR_TYPE_FUNC);</a>
<a name="ln391">  set_vim_var_nr(VV_TYPE_LIST,   VAR_TYPE_LIST);</a>
<a name="ln392">  set_vim_var_nr(VV_TYPE_DICT,   VAR_TYPE_DICT);</a>
<a name="ln393">  set_vim_var_nr(VV_TYPE_FLOAT,  VAR_TYPE_FLOAT);</a>
<a name="ln394">  set_vim_var_nr(VV_TYPE_BOOL,   VAR_TYPE_BOOL);</a>
<a name="ln395"> </a>
<a name="ln396">  set_vim_var_bool(VV_FALSE, kBoolVarFalse);</a>
<a name="ln397">  set_vim_var_bool(VV_TRUE, kBoolVarTrue);</a>
<a name="ln398">  set_vim_var_special(VV_NULL, kSpecialVarNull);</a>
<a name="ln399">  set_vim_var_nr(VV_NUMBERMAX, VARNUMBER_MAX);</a>
<a name="ln400">  set_vim_var_nr(VV_NUMBERMIN, VARNUMBER_MIN);</a>
<a name="ln401">  set_vim_var_nr(VV_NUMBERSIZE, sizeof(varnumber_T) * 8);</a>
<a name="ln402">  set_vim_var_special(VV_EXITING, kSpecialVarNull);</a>
<a name="ln403"> </a>
<a name="ln404">  set_vim_var_nr(VV_ECHOSPACE,    sc_col - 1);</a>
<a name="ln405"> </a>
<a name="ln406">  vimvars[VV_LUA].vv_type = VAR_PARTIAL;</a>
<a name="ln407">  vvlua_partial = xcalloc(1, sizeof(partial_T));</a>
<a name="ln408">  vimvars[VV_LUA].vv_partial = vvlua_partial;</a>
<a name="ln409">  // this value shouldn't be printed, but if it is, do not crash</a>
<a name="ln410">  vvlua_partial-&gt;pt_name = xmallocz(0);</a>
<a name="ln411">  vvlua_partial-&gt;pt_refcount++;</a>
<a name="ln412"> </a>
<a name="ln413">  set_reg_var(0);  // default for v:register is not 0 but '&quot;'</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">#if defined(EXITFREE)</a>
<a name="ln417">void eval_clear(void)</a>
<a name="ln418">{</a>
<a name="ln419">  struct vimvar   *p;</a>
<a name="ln420"> </a>
<a name="ln421">  for (size_t i = 0; i &lt; ARRAY_SIZE(vimvars); i++) {</a>
<a name="ln422">    p = &amp;vimvars[i];</a>
<a name="ln423">    if (p-&gt;vv_di.di_tv.v_type == VAR_STRING) {</a>
<a name="ln424">      XFREE_CLEAR(p-&gt;vv_str);</a>
<a name="ln425">    } else if (p-&gt;vv_di.di_tv.v_type == VAR_LIST) {</a>
<a name="ln426">      tv_list_unref(p-&gt;vv_list);</a>
<a name="ln427">      p-&gt;vv_list = NULL;</a>
<a name="ln428">    }</a>
<a name="ln429">  }</a>
<a name="ln430">  hash_clear(&amp;vimvarht);</a>
<a name="ln431">  hash_init(&amp;vimvarht);    // garbage_collect() will access it</a>
<a name="ln432">  hash_clear(&amp;compat_hashtab);</a>
<a name="ln433"> </a>
<a name="ln434">  free_scriptnames();</a>
<a name="ln435">  free_locales();</a>
<a name="ln436"> </a>
<a name="ln437">  // global variables</a>
<a name="ln438">  vars_clear(&amp;globvarht);</a>
<a name="ln439"> </a>
<a name="ln440">  // autoloaded script names</a>
<a name="ln441">  ga_clear_strings(&amp;ga_loaded);</a>
<a name="ln442"> </a>
<a name="ln443">  /* Script-local variables. First clear all the variables and in a second</a>
<a name="ln444">   * loop free the scriptvar_T, because a variable in one script might hold</a>
<a name="ln445">   * a reference to the whole scope of another script. */</a>
<a name="ln446">  for (int i = 1; i &lt;= ga_scripts.ga_len; ++i)</a>
<a name="ln447">    vars_clear(&amp;SCRIPT_VARS(i));</a>
<a name="ln448">  for (int i = 1; i &lt;= ga_scripts.ga_len; ++i)</a>
<a name="ln449">    xfree(SCRIPT_SV(i));</a>
<a name="ln450">  ga_clear(&amp;ga_scripts);</a>
<a name="ln451"> </a>
<a name="ln452">  // unreferenced lists and dicts</a>
<a name="ln453">  (void)garbage_collect(false);</a>
<a name="ln454"> </a>
<a name="ln455">  // functions not garbage collected</a>
<a name="ln456">  free_all_functions();</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">#endif</a>
<a name="ln460"> </a>
<a name="ln461">/*</a>
<a name="ln462"> * Set an internal variable to a string value. Creates the variable if it does</a>
<a name="ln463"> * not already exist.</a>
<a name="ln464"> */</a>
<a name="ln465">void set_internal_string_var(const char *name, char_u *value)</a>
<a name="ln466">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln467">{</a>
<a name="ln468">  typval_T tv = {</a>
<a name="ln469">    .v_type = VAR_STRING,</a>
<a name="ln470">    .vval.v_string = value,</a>
<a name="ln471">  };</a>
<a name="ln472"> </a>
<a name="ln473">  set_var(name, strlen(name), &amp;tv, true);</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476">static lval_T   *redir_lval = NULL;</a>
<a name="ln477">static garray_T redir_ga;  // Only valid when redir_lval is not NULL.</a>
<a name="ln478">static char_u *redir_endp = NULL;</a>
<a name="ln479">static char_u   *redir_varname = NULL;</a>
<a name="ln480"> </a>
<a name="ln481">/*</a>
<a name="ln482"> * Start recording command output to a variable</a>
<a name="ln483"> * Returns OK if successfully completed the setup.  FAIL otherwise.</a>
<a name="ln484"> */</a>
<a name="ln485">int</a>
<a name="ln486">var_redir_start(</a>
<a name="ln487">    char_u *name,</a>
<a name="ln488">    int append                     // append to an existing variable</a>
<a name="ln489">)</a>
<a name="ln490">{</a>
<a name="ln491">  int save_emsg;</a>
<a name="ln492">  int err;</a>
<a name="ln493">  typval_T tv;</a>
<a name="ln494"> </a>
<a name="ln495">  // Catch a bad name early.</a>
<a name="ln496">  if (!eval_isnamec1(*name)) {</a>
<a name="ln497">    EMSG(_(e_invarg));</a>
<a name="ln498">    return FAIL;</a>
<a name="ln499">  }</a>
<a name="ln500"> </a>
<a name="ln501">  // Make a copy of the name, it is used in redir_lval until redir ends.</a>
<a name="ln502">  redir_varname = vim_strsave(name);</a>
<a name="ln503"> </a>
<a name="ln504">  redir_lval = xcalloc(1, sizeof(lval_T));</a>
<a name="ln505"> </a>
<a name="ln506">  // The output is stored in growarray &quot;redir_ga&quot; until redirection ends.</a>
<a name="ln507">  ga_init(&amp;redir_ga, (int)sizeof(char), 500);</a>
<a name="ln508"> </a>
<a name="ln509">  // Parse the variable name (can be a dict or list entry).</a>
<a name="ln510">  redir_endp = (char_u *)get_lval(redir_varname, NULL, redir_lval, false, false,</a>
<a name="ln511">                                  0, FNE_CHECK_START);</a>
<a name="ln512">  if (redir_endp == NULL || redir_lval-&gt;ll_name == NULL</a>
<a name="ln513">      || *redir_endp != NUL) {</a>
<a name="ln514">    clear_lval(redir_lval);</a>
<a name="ln515">    if (redir_endp != NULL &amp;&amp; *redir_endp != NUL) {</a>
<a name="ln516">      // Trailing characters are present after the variable name</a>
<a name="ln517">      EMSG(_(e_trailing));</a>
<a name="ln518">    } else {</a>
<a name="ln519">      EMSG(_(e_invarg));</a>
<a name="ln520">    }</a>
<a name="ln521">    redir_endp = NULL;      // don't store a value, only cleanup</a>
<a name="ln522">    var_redir_stop();</a>
<a name="ln523">    return FAIL;</a>
<a name="ln524">  }</a>
<a name="ln525"> </a>
<a name="ln526">  /* check if we can write to the variable: set it to or append an empty</a>
<a name="ln527">   * string */</a>
<a name="ln528">  save_emsg = did_emsg;</a>
<a name="ln529">  did_emsg = FALSE;</a>
<a name="ln530">  tv.v_type = VAR_STRING;</a>
<a name="ln531">  tv.vval.v_string = (char_u *)&quot;&quot;;</a>
<a name="ln532">  if (append) {</a>
<a name="ln533">    set_var_lval(redir_lval, redir_endp, &amp;tv, true, false, &quot;.&quot;);</a>
<a name="ln534">  } else {</a>
<a name="ln535">    set_var_lval(redir_lval, redir_endp, &amp;tv, true, false, &quot;=&quot;);</a>
<a name="ln536">  }</a>
<a name="ln537">  clear_lval(redir_lval);</a>
<a name="ln538">  err = did_emsg;</a>
<a name="ln539">  did_emsg |= save_emsg;</a>
<a name="ln540">  if (err) {</a>
<a name="ln541">    redir_endp = NULL;      // don't store a value, only cleanup</a>
<a name="ln542">    var_redir_stop();</a>
<a name="ln543">    return FAIL;</a>
<a name="ln544">  }</a>
<a name="ln545"> </a>
<a name="ln546">  return OK;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549">/*</a>
<a name="ln550"> * Append &quot;value[value_len]&quot; to the variable set by var_redir_start().</a>
<a name="ln551"> * The actual appending is postponed until redirection ends, because the value</a>
<a name="ln552"> * appended may in fact be the string we write to, changing it may cause freed</a>
<a name="ln553"> * memory to be used:</a>
<a name="ln554"> *   :redir =&gt; foo</a>
<a name="ln555"> *   :let foo</a>
<a name="ln556"> *   :redir END</a>
<a name="ln557"> */</a>
<a name="ln558">void var_redir_str(char_u *value, int value_len)</a>
<a name="ln559">{</a>
<a name="ln560">  int len;</a>
<a name="ln561"> </a>
<a name="ln562">  if (redir_lval == NULL)</a>
<a name="ln563">    return;</a>
<a name="ln564"> </a>
<a name="ln565">  if (value_len == -1) {</a>
<a name="ln566">    len = (int)STRLEN(value);           // Append the entire string</a>
<a name="ln567">  } else {</a>
<a name="ln568">    len = value_len;                    // Append only &quot;value_len&quot; characters</a>
<a name="ln569">  }</a>
<a name="ln570"> </a>
<a name="ln571">  ga_grow(&amp;redir_ga, len);</a>
<a name="ln572">  memmove((char *)redir_ga.ga_data + redir_ga.ga_len, value, len);</a>
<a name="ln573">  redir_ga.ga_len += len;</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">/*</a>
<a name="ln577"> * Stop redirecting command output to a variable.</a>
<a name="ln578"> * Frees the allocated memory.</a>
<a name="ln579"> */</a>
<a name="ln580">void var_redir_stop(void)</a>
<a name="ln581">{</a>
<a name="ln582">  typval_T tv;</a>
<a name="ln583"> </a>
<a name="ln584">  if (redir_lval != NULL) {</a>
<a name="ln585">    // If there was no error: assign the text to the variable.</a>
<a name="ln586">    if (redir_endp != NULL) {</a>
<a name="ln587">      ga_append(&amp;redir_ga, NUL);        // Append the trailing NUL.</a>
<a name="ln588">      tv.v_type = VAR_STRING;</a>
<a name="ln589">      tv.vval.v_string = redir_ga.ga_data;</a>
<a name="ln590">      // Call get_lval() again, if it's inside a Dict or List it may</a>
<a name="ln591">      // have changed.</a>
<a name="ln592">      redir_endp = (char_u *)get_lval(redir_varname, NULL, redir_lval,</a>
<a name="ln593">                                      false, false, 0, FNE_CHECK_START);</a>
<a name="ln594">      if (redir_endp != NULL &amp;&amp; redir_lval-&gt;ll_name != NULL) {</a>
<a name="ln595">        set_var_lval(redir_lval, redir_endp, &amp;tv, false, false, &quot;.&quot;);</a>
<a name="ln596">      }</a>
<a name="ln597">      clear_lval(redir_lval);</a>
<a name="ln598">    }</a>
<a name="ln599"> </a>
<a name="ln600">    // free the collected output</a>
<a name="ln601">    XFREE_CLEAR(redir_ga.ga_data);</a>
<a name="ln602"> </a>
<a name="ln603">    XFREE_CLEAR(redir_lval);</a>
<a name="ln604">  }</a>
<a name="ln605">  XFREE_CLEAR(redir_varname);</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">int eval_charconvert(const char *const enc_from, const char *const enc_to,</a>
<a name="ln609">                     const char *const fname_from, const char *const fname_to)</a>
<a name="ln610">{</a>
<a name="ln611">  bool err = false;</a>
<a name="ln612"> </a>
<a name="ln613">  set_vim_var_string(VV_CC_FROM, enc_from, -1);</a>
<a name="ln614">  set_vim_var_string(VV_CC_TO, enc_to, -1);</a>
<a name="ln615">  set_vim_var_string(VV_FNAME_IN, fname_from, -1);</a>
<a name="ln616">  set_vim_var_string(VV_FNAME_OUT, fname_to, -1);</a>
<a name="ln617">  if (eval_to_bool(p_ccv, &amp;err, NULL, false)) {</a>
<a name="ln618">    err = true;</a>
<a name="ln619">  }</a>
<a name="ln620">  set_vim_var_string(VV_CC_FROM, NULL, -1);</a>
<a name="ln621">  set_vim_var_string(VV_CC_TO, NULL, -1);</a>
<a name="ln622">  set_vim_var_string(VV_FNAME_IN, NULL, -1);</a>
<a name="ln623">  set_vim_var_string(VV_FNAME_OUT, NULL, -1);</a>
<a name="ln624"> </a>
<a name="ln625">  if (err) {</a>
<a name="ln626">    return FAIL;</a>
<a name="ln627">  }</a>
<a name="ln628">  return OK;</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">int eval_printexpr(const char *const fname, const char *const args)</a>
<a name="ln632">{</a>
<a name="ln633">  bool err = false;</a>
<a name="ln634"> </a>
<a name="ln635">  set_vim_var_string(VV_FNAME_IN, fname, -1);</a>
<a name="ln636">  set_vim_var_string(VV_CMDARG, args, -1);</a>
<a name="ln637">  if (eval_to_bool(p_pexpr, &amp;err, NULL, false)) {</a>
<a name="ln638">    err = true;</a>
<a name="ln639">  }</a>
<a name="ln640">  set_vim_var_string(VV_FNAME_IN, NULL, -1);</a>
<a name="ln641">  set_vim_var_string(VV_CMDARG, NULL, -1);</a>
<a name="ln642"> </a>
<a name="ln643">  if (err) {</a>
<a name="ln644">    os_remove(fname);</a>
<a name="ln645">    return FAIL;</a>
<a name="ln646">  }</a>
<a name="ln647">  return OK;</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650">void eval_diff(const char *const origfile, const char *const newfile,</a>
<a name="ln651">               const char *const outfile)</a>
<a name="ln652">{</a>
<a name="ln653">  bool err = false;</a>
<a name="ln654"> </a>
<a name="ln655">  set_vim_var_string(VV_FNAME_IN, origfile, -1);</a>
<a name="ln656">  set_vim_var_string(VV_FNAME_NEW, newfile, -1);</a>
<a name="ln657">  set_vim_var_string(VV_FNAME_OUT, outfile, -1);</a>
<a name="ln658">  (void)eval_to_bool(p_dex, &amp;err, NULL, FALSE);</a>
<a name="ln659">  set_vim_var_string(VV_FNAME_IN, NULL, -1);</a>
<a name="ln660">  set_vim_var_string(VV_FNAME_NEW, NULL, -1);</a>
<a name="ln661">  set_vim_var_string(VV_FNAME_OUT, NULL, -1);</a>
<a name="ln662">}</a>
<a name="ln663"> </a>
<a name="ln664">void eval_patch(const char *const origfile, const char *const difffile,</a>
<a name="ln665">                const char *const outfile)</a>
<a name="ln666">{</a>
<a name="ln667">  bool err = false;</a>
<a name="ln668"> </a>
<a name="ln669">  set_vim_var_string(VV_FNAME_IN, origfile, -1);</a>
<a name="ln670">  set_vim_var_string(VV_FNAME_DIFF, difffile, -1);</a>
<a name="ln671">  set_vim_var_string(VV_FNAME_OUT, outfile, -1);</a>
<a name="ln672">  (void)eval_to_bool(p_pex, &amp;err, NULL, FALSE);</a>
<a name="ln673">  set_vim_var_string(VV_FNAME_IN, NULL, -1);</a>
<a name="ln674">  set_vim_var_string(VV_FNAME_DIFF, NULL, -1);</a>
<a name="ln675">  set_vim_var_string(VV_FNAME_OUT, NULL, -1);</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">/*</a>
<a name="ln679"> * Top level evaluation function, returning a boolean.</a>
<a name="ln680"> * Sets &quot;error&quot; to TRUE if there was an error.</a>
<a name="ln681"> * Return TRUE or FALSE.</a>
<a name="ln682"> */</a>
<a name="ln683">int</a>
<a name="ln684">eval_to_bool(</a>
<a name="ln685">    char_u *arg,</a>
<a name="ln686">    bool *error,</a>
<a name="ln687">    char_u **nextcmd,</a>
<a name="ln688">    int skip                   // only parse, don't execute</a>
<a name="ln689">)</a>
<a name="ln690">{</a>
<a name="ln691">  typval_T tv;</a>
<a name="ln692">  bool retval = false;</a>
<a name="ln693"> </a>
<a name="ln694">  if (skip) {</a>
<a name="ln695">    emsg_skip++;</a>
<a name="ln696">  }</a>
<a name="ln697">  if (eval0(arg, &amp;tv, nextcmd, !skip) == FAIL) {</a>
<a name="ln698">    *error = true;</a>
<a name="ln699">  } else {</a>
<a name="ln700">    *error = false;</a>
<a name="ln701">    if (!skip) {</a>
<a name="ln702">      retval = (tv_get_number_chk(&amp;tv, error) != 0);</a>
<a name="ln703">      tv_clear(&amp;tv);</a>
<a name="ln704">    }</a>
<a name="ln705">  }</a>
<a name="ln706">  if (skip) {</a>
<a name="ln707">    emsg_skip--;</a>
<a name="ln708">  }</a>
<a name="ln709"> </a>
<a name="ln710">  return retval;</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">// Call eval1() and give an error message if not done at a lower level.</a>
<a name="ln714">static int eval1_emsg(char_u **arg, typval_T *rettv, bool evaluate)</a>
<a name="ln715">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln716">{</a>
<a name="ln717">  const char_u *const start = *arg;</a>
<a name="ln718">  const int did_emsg_before = did_emsg;</a>
<a name="ln719">  const int called_emsg_before = called_emsg;</a>
<a name="ln720"> </a>
<a name="ln721">  const int ret = eval1(arg, rettv, evaluate);</a>
<a name="ln722">  if (ret == FAIL) {</a>
<a name="ln723">    // Report the invalid expression unless the expression evaluation has</a>
<a name="ln724">    // been cancelled due to an aborting error, an interrupt, or an</a>
<a name="ln725">    // exception, or we already gave a more specific error.</a>
<a name="ln726">    // Also check called_emsg for when using assert_fails().</a>
<a name="ln727">    if (!aborting()</a>
<a name="ln728">        &amp;&amp; did_emsg == did_emsg_before</a>
<a name="ln729">        &amp;&amp; called_emsg == called_emsg_before) {</a>
<a name="ln730">      emsgf(_(e_invexpr2), start);</a>
<a name="ln731">    }</a>
<a name="ln732">  }</a>
<a name="ln733">  return ret;</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">int eval_expr_typval(const typval_T *expr, typval_T *argv,</a>
<a name="ln737">                     int argc, typval_T *rettv)</a>
<a name="ln738">  FUNC_ATTR_NONNULL_ARG(1, 2, 4)</a>
<a name="ln739">{</a>
<a name="ln740">  int dummy;</a>
<a name="ln741"> </a>
<a name="ln742">  if (expr-&gt;v_type == VAR_FUNC) {</a>
<a name="ln743">    const char_u *const s = expr-&gt;vval.v_string;</a>
<a name="ln744">    if (s == NULL || *s == NUL) {</a>
<a name="ln745">      return FAIL;</a>
<a name="ln746">    }</a>
<a name="ln747">    if (call_func(s, -1, rettv, argc, argv, NULL,</a>
<a name="ln748">                  0L, 0L, &amp;dummy, true, NULL, NULL) == FAIL) {</a>
<a name="ln749">      return FAIL;</a>
<a name="ln750">    }</a>
<a name="ln751">  } else if (expr-&gt;v_type == VAR_PARTIAL) {</a>
<a name="ln752">    partial_T *const partial = expr-&gt;vval.v_partial;</a>
<a name="ln753">    const char_u *const s = partial_name(partial);</a>
<a name="ln754">    if (s == NULL || *s == NUL) {</a>
<a name="ln755">      return FAIL;</a>
<a name="ln756">    }</a>
<a name="ln757">    if (call_func(s, -1, rettv, argc, argv, NULL,</a>
<a name="ln758">                  0L, 0L, &amp;dummy, true, partial, NULL) == FAIL) {</a>
<a name="ln759">      return FAIL;</a>
<a name="ln760">    }</a>
<a name="ln761">  } else {</a>
<a name="ln762">    char buf[NUMBUFLEN];</a>
<a name="ln763">    char_u *s = (char_u *)tv_get_string_buf_chk(expr, buf);</a>
<a name="ln764">    if (s == NULL) {</a>
<a name="ln765">      return FAIL;</a>
<a name="ln766">    }</a>
<a name="ln767">    s = skipwhite(s);</a>
<a name="ln768">    if (eval1_emsg(&amp;s, rettv, true) == FAIL) {</a>
<a name="ln769">      return FAIL;</a>
<a name="ln770">    }</a>
<a name="ln771">    if (*skipwhite(s) != NUL) {  // check for trailing chars after expr</a>
<a name="ln772">      tv_clear(rettv);</a>
<a name="ln773">      emsgf(_(e_invexpr2), s);</a>
<a name="ln774">      return FAIL;</a>
<a name="ln775">    }</a>
<a name="ln776">  }</a>
<a name="ln777">  return OK;</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780">/// Like eval_to_bool() but using a typval_T instead of a string.</a>
<a name="ln781">/// Works for string, funcref and partial.</a>
<a name="ln782">bool eval_expr_to_bool(const typval_T *expr, bool *error)</a>
<a name="ln783">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln784">{</a>
<a name="ln785">  typval_T argv, rettv;</a>
<a name="ln786"> </a>
<a name="ln787">  if (eval_expr_typval(expr, &amp;argv, 0, &amp;rettv) == FAIL) {</a>
<a name="ln788">    *error = true;</a>
<a name="ln789">    return false;</a>
<a name="ln790">  }</a>
<a name="ln791">  const bool res = (tv_get_number_chk(&amp;rettv, error) != 0);</a>
<a name="ln792">  tv_clear(&amp;rettv);</a>
<a name="ln793">  return res;</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">/// Top level evaluation function, returning a string</a>
<a name="ln797">///</a>
<a name="ln798">/// @param[in]  arg  String to evaluate.</a>
<a name="ln799">/// @param  nextcmd  Pointer to the start of the next Ex command.</a>
<a name="ln800">/// @param[in]  skip  If true, only do parsing to nextcmd without reporting</a>
<a name="ln801">///                   errors or actually evaluating anything.</a>
<a name="ln802">///</a>
<a name="ln803">/// @return [allocated] string result of evaluation or NULL in case of error or</a>
<a name="ln804">///                     when skipping.</a>
<a name="ln805">char *eval_to_string_skip(const char *arg, const char **nextcmd,</a>
<a name="ln806">                          const bool skip)</a>
<a name="ln807">  FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln808">{</a>
<a name="ln809">  typval_T tv;</a>
<a name="ln810">  char *retval;</a>
<a name="ln811"> </a>
<a name="ln812">  if (skip) {</a>
<a name="ln813">    emsg_skip++;</a>
<a name="ln814">  }</a>
<a name="ln815">  if (eval0((char_u *)arg, &amp;tv, (char_u **)nextcmd, !skip) == FAIL || skip) {</a>
<a name="ln816">    retval = NULL;</a>
<a name="ln817">  } else {</a>
<a name="ln818">    retval = xstrdup(tv_get_string(&amp;tv));</a>
<a name="ln819">    tv_clear(&amp;tv);</a>
<a name="ln820">  }</a>
<a name="ln821">  if (skip) {</a>
<a name="ln822">    emsg_skip--;</a>
<a name="ln823">  }</a>
<a name="ln824"> </a>
<a name="ln825">  return retval;</a>
<a name="ln826">}</a>
<a name="ln827"> </a>
<a name="ln828">/*</a>
<a name="ln829"> * Skip over an expression at &quot;*pp&quot;.</a>
<a name="ln830"> * Return FAIL for an error, OK otherwise.</a>
<a name="ln831"> */</a>
<a name="ln832">int skip_expr(char_u **pp)</a>
<a name="ln833">{</a>
<a name="ln834">  typval_T rettv;</a>
<a name="ln835"> </a>
<a name="ln836">  *pp = skipwhite(*pp);</a>
<a name="ln837">  return eval1(pp, &amp;rettv, FALSE);</a>
<a name="ln838">}</a>
<a name="ln839"> </a>
<a name="ln840">/*</a>
<a name="ln841"> * Top level evaluation function, returning a string.</a>
<a name="ln842"> * When &quot;convert&quot; is TRUE convert a List into a sequence of lines and convert</a>
<a name="ln843"> * a Float to a String.</a>
<a name="ln844"> * Return pointer to allocated memory, or NULL for failure.</a>
<a name="ln845"> */</a>
<a name="ln846">char_u *eval_to_string(char_u *arg, char_u **nextcmd, int convert)</a>
<a name="ln847">{</a>
<a name="ln848">  typval_T tv;</a>
<a name="ln849">  char *retval;</a>
<a name="ln850">  garray_T ga;</a>
<a name="ln851"> </a>
<a name="ln852">  if (eval0(arg, &amp;tv, nextcmd, true) == FAIL) {</a>
<a name="ln853">    retval = NULL;</a>
<a name="ln854">  } else {</a>
<a name="ln855">    if (convert &amp;&amp; tv.v_type == VAR_LIST) {</a>
<a name="ln856">      ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln857">      if (tv.vval.v_list != NULL) {</a>
<a name="ln858">        tv_list_join(&amp;ga, tv.vval.v_list, &quot;\n&quot;);</a>
<a name="ln859">        if (tv_list_len(tv.vval.v_list) &gt; 0) {</a>
<a name="ln860">          ga_append(&amp;ga, NL);</a>
<a name="ln861">        }</a>
<a name="ln862">      }</a>
<a name="ln863">      ga_append(&amp;ga, NUL);</a>
<a name="ln864">      retval = (char *)ga.ga_data;</a>
<a name="ln865">    } else if (convert &amp;&amp; tv.v_type == VAR_FLOAT) {</a>
<a name="ln866">      char numbuf[NUMBUFLEN];</a>
<a name="ln867">      vim_snprintf(numbuf, NUMBUFLEN, &quot;%g&quot;, tv.vval.v_float);</a>
<a name="ln868">      retval = xstrdup(numbuf);</a>
<a name="ln869">    } else {</a>
<a name="ln870">      retval = xstrdup(tv_get_string(&amp;tv));</a>
<a name="ln871">    }</a>
<a name="ln872">    tv_clear(&amp;tv);</a>
<a name="ln873">  }</a>
<a name="ln874"> </a>
<a name="ln875">  return (char_u *)retval;</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878">/*</a>
<a name="ln879"> * Call eval_to_string() without using current local variables and using</a>
<a name="ln880"> * textlock.  When &quot;use_sandbox&quot; is TRUE use the sandbox.</a>
<a name="ln881"> */</a>
<a name="ln882">char_u *eval_to_string_safe(char_u *arg, char_u **nextcmd, int use_sandbox)</a>
<a name="ln883">{</a>
<a name="ln884">  char_u      *retval;</a>
<a name="ln885">  funccal_entry_T funccal_entry;</a>
<a name="ln886"> </a>
<a name="ln887">  save_funccal(&amp;funccal_entry);</a>
<a name="ln888">  if (use_sandbox) {</a>
<a name="ln889">    sandbox++;</a>
<a name="ln890">  }</a>
<a name="ln891">  textlock++;</a>
<a name="ln892">  retval = eval_to_string(arg, nextcmd, false);</a>
<a name="ln893">  if (use_sandbox) {</a>
<a name="ln894">    sandbox--;</a>
<a name="ln895">  }</a>
<a name="ln896">  textlock--;</a>
<a name="ln897">  restore_funccal();</a>
<a name="ln898">  return retval;</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901">/*</a>
<a name="ln902"> * Top level evaluation function, returning a number.</a>
<a name="ln903"> * Evaluates &quot;expr&quot; silently.</a>
<a name="ln904"> * Returns -1 for an error.</a>
<a name="ln905"> */</a>
<a name="ln906">varnumber_T eval_to_number(char_u *expr)</a>
<a name="ln907">{</a>
<a name="ln908">  typval_T rettv;</a>
<a name="ln909">  varnumber_T retval;</a>
<a name="ln910">  char_u      *p = skipwhite(expr);</a>
<a name="ln911"> </a>
<a name="ln912">  ++emsg_off;</a>
<a name="ln913"> </a>
<a name="ln914">  if (eval1(&amp;p, &amp;rettv, true) == FAIL) {</a>
<a name="ln915">    retval = -1;</a>
<a name="ln916">  } else {</a>
<a name="ln917">    retval = tv_get_number_chk(&amp;rettv, NULL);</a>
<a name="ln918">    tv_clear(&amp;rettv);</a>
<a name="ln919">  }</a>
<a name="ln920">  --emsg_off;</a>
<a name="ln921"> </a>
<a name="ln922">  return retval;</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">// Top level evaluation function.</a>
<a name="ln926">// Returns an allocated typval_T with the result.</a>
<a name="ln927">// Returns NULL when there is an error.</a>
<a name="ln928">typval_T *eval_expr(char_u *arg)</a>
<a name="ln929">{</a>
<a name="ln930">  typval_T *tv = xmalloc(sizeof(*tv));</a>
<a name="ln931">  if (eval0(arg, tv, NULL, true) == FAIL) {</a>
<a name="ln932">    XFREE_CLEAR(tv);</a>
<a name="ln933">  }</a>
<a name="ln934">  return tv;</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937">/*</a>
<a name="ln938"> * Prepare v: variable &quot;idx&quot; to be used.</a>
<a name="ln939"> * Save the current typeval in &quot;save_tv&quot;.</a>
<a name="ln940"> * When not used yet add the variable to the v: hashtable.</a>
<a name="ln941"> */</a>
<a name="ln942">void prepare_vimvar(int idx, typval_T *save_tv)</a>
<a name="ln943">{</a>
<a name="ln944">  *save_tv = vimvars[idx].vv_tv;</a>
<a name="ln945">  if (vimvars[idx].vv_type == VAR_UNKNOWN)</a>
<a name="ln946">    hash_add(&amp;vimvarht, vimvars[idx].vv_di.di_key);</a>
<a name="ln947">}</a>
<a name="ln948"> </a>
<a name="ln949">/*</a>
<a name="ln950"> * Restore v: variable &quot;idx&quot; to typeval &quot;save_tv&quot;.</a>
<a name="ln951"> * When no longer defined, remove the variable from the v: hashtable.</a>
<a name="ln952"> */</a>
<a name="ln953">void restore_vimvar(int idx, typval_T *save_tv)</a>
<a name="ln954">{</a>
<a name="ln955">  hashitem_T  *hi;</a>
<a name="ln956"> </a>
<a name="ln957">  vimvars[idx].vv_tv = *save_tv;</a>
<a name="ln958">  if (vimvars[idx].vv_type == VAR_UNKNOWN) {</a>
<a name="ln959">    hi = hash_find(&amp;vimvarht, vimvars[idx].vv_di.di_key);</a>
<a name="ln960">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln961">      internal_error(&quot;restore_vimvar()&quot;);</a>
<a name="ln962">    } else {</a>
<a name="ln963">      hash_remove(&amp;vimvarht, hi);</a>
<a name="ln964">    }</a>
<a name="ln965">  }</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968">/// If there is a window for &quot;curbuf&quot;, make it the current window.</a>
<a name="ln969">void find_win_for_curbuf(void)</a>
<a name="ln970">{</a>
<a name="ln971">  for (wininfo_T *wip = curbuf-&gt;b_wininfo; wip != NULL; wip = wip-&gt;wi_next) {</a>
<a name="ln972">    if (wip-&gt;wi_win != NULL) {</a>
<a name="ln973">      curwin = wip-&gt;wi_win;</a>
<a name="ln974">      break;</a>
<a name="ln975">    }</a>
<a name="ln976">  }</a>
<a name="ln977">}</a>
<a name="ln978"> </a>
<a name="ln979">/*</a>
<a name="ln980"> * Evaluate an expression to a list with suggestions.</a>
<a name="ln981"> * For the &quot;expr:&quot; part of 'spellsuggest'.</a>
<a name="ln982"> * Returns NULL when there is an error.</a>
<a name="ln983"> */</a>
<a name="ln984">list_T *eval_spell_expr(char_u *badword, char_u *expr)</a>
<a name="ln985">{</a>
<a name="ln986">  typval_T save_val;</a>
<a name="ln987">  typval_T rettv;</a>
<a name="ln988">  list_T      *list = NULL;</a>
<a name="ln989">  char_u      *p = skipwhite(expr);</a>
<a name="ln990"> </a>
<a name="ln991">  // Set &quot;v:val&quot; to the bad word.</a>
<a name="ln992">  prepare_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln993">  vimvars[VV_VAL].vv_type = VAR_STRING;</a>
<a name="ln994">  vimvars[VV_VAL].vv_str = badword;</a>
<a name="ln995">  if (p_verbose == 0)</a>
<a name="ln996">    ++emsg_off;</a>
<a name="ln997"> </a>
<a name="ln998">  if (eval1(&amp;p, &amp;rettv, true) == OK) {</a>
<a name="ln999">    if (rettv.v_type != VAR_LIST) {</a>
<a name="ln1000">      tv_clear(&amp;rettv);</a>
<a name="ln1001">    } else {</a>
<a name="ln1002">      list = rettv.vval.v_list;</a>
<a name="ln1003">    }</a>
<a name="ln1004">  }</a>
<a name="ln1005"> </a>
<a name="ln1006">  if (p_verbose == 0)</a>
<a name="ln1007">    --emsg_off;</a>
<a name="ln1008">  restore_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln1009"> </a>
<a name="ln1010">  return list;</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013">/// Get spell word from an entry from spellsuggest=expr:</a>
<a name="ln1014">///</a>
<a name="ln1015">/// Entry in question is supposed to be a list (to be checked by the caller)</a>
<a name="ln1016">/// with two items: a word and a score represented as an unsigned number</a>
<a name="ln1017">/// (whether it actually is unsigned is not checked).</a>
<a name="ln1018">///</a>
<a name="ln1019">/// Used to get the good word and score from the eval_spell_expr() result.</a>
<a name="ln1020">///</a>
<a name="ln1021">/// @param[in]  list  List to get values from.</a>
<a name="ln1022">/// @param[out]  ret_word  Suggested word. Not initialized if return value is</a>
<a name="ln1023">///                        -1.</a>
<a name="ln1024">///</a>
<a name="ln1025">/// @return -1 in case of error, score otherwise.</a>
<a name="ln1026">int get_spellword(list_T *const list, const char **ret_word)</a>
<a name="ln1027">{</a>
<a name="ln1028">  if (tv_list_len(list) != 2) {</a>
<a name="ln1029">    EMSG(_(&quot;E5700: Expression from 'spellsuggest' must yield lists with &quot;</a>
<a name="ln1030">           &quot;exactly two values&quot;));</a>
<a name="ln1031">    return -1;</a>
<a name="ln1032">  }</a>
<a name="ln1033">  *ret_word = tv_list_find_str(list, 0);</a>
<a name="ln1034">  if (*ret_word == NULL) {</a>
<a name="ln1035">    return -1;</a>
<a name="ln1036">  }</a>
<a name="ln1037">  return tv_list_find_nr(list, -1, NULL);</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040"> </a>
<a name="ln1041">// Call some vim script function and return the result in &quot;*rettv&quot;.</a>
<a name="ln1042">// Uses argv[0] to argv[argc-1] for the function arguments. argv[argc]</a>
<a name="ln1043">// should have type VAR_UNKNOWN.</a>
<a name="ln1044">//</a>
<a name="ln1045">// Return OK or FAIL.</a>
<a name="ln1046">int call_vim_function(</a>
<a name="ln1047">    const char_u *func,</a>
<a name="ln1048">    int argc,</a>
<a name="ln1049">    typval_T *argv,</a>
<a name="ln1050">    typval_T *rettv</a>
<a name="ln1051">)</a>
<a name="ln1052">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1053">{</a>
<a name="ln1054">  int doesrange;</a>
<a name="ln1055">  int ret;</a>
<a name="ln1056">  int len = (int)STRLEN(func);</a>
<a name="ln1057">  partial_T *pt = NULL;</a>
<a name="ln1058"> </a>
<a name="ln1059">  if (len &gt;= 6 &amp;&amp; !memcmp(func, &quot;v:lua.&quot;, 6)) {</a>
<a name="ln1060">    func += 6;</a>
<a name="ln1061">    len = check_luafunc_name((const char *)func, false);</a>
<a name="ln1062">    if (len == 0) {</a>
<a name="ln1063">      ret = FAIL;</a>
<a name="ln1064">      goto fail;</a>
<a name="ln1065">    }</a>
<a name="ln1066">    pt = vvlua_partial;</a>
<a name="ln1067">  }</a>
<a name="ln1068"> </a>
<a name="ln1069">  rettv-&gt;v_type = VAR_UNKNOWN;  // tv_clear() uses this.</a>
<a name="ln1070">  ret = call_func(func, len, rettv, argc, argv, NULL,</a>
<a name="ln1071">                  curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum,</a>
<a name="ln1072">                  &amp;doesrange, true, pt, NULL);</a>
<a name="ln1073"> </a>
<a name="ln1074">fail:</a>
<a name="ln1075">  if (ret == FAIL) {</a>
<a name="ln1076">    tv_clear(rettv);</a>
<a name="ln1077">  }</a>
<a name="ln1078"> </a>
<a name="ln1079">  return ret;</a>
<a name="ln1080">}</a>
<a name="ln1081">/// Call Vim script function and return the result as a number</a>
<a name="ln1082">///</a>
<a name="ln1083">/// @param[in]  func  Function name.</a>
<a name="ln1084">/// @param[in]  argc  Number of arguments.</a>
<a name="ln1085">/// @param[in]  argv  Array with typval_T arguments.</a>
<a name="ln1086">///</a>
<a name="ln1087">/// @return -1 when calling function fails, result of function otherwise.</a>
<a name="ln1088">varnumber_T call_func_retnr(const char_u *func, int argc,</a>
<a name="ln1089">                            typval_T *argv)</a>
<a name="ln1090">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1091">{</a>
<a name="ln1092">  typval_T rettv;</a>
<a name="ln1093">  varnumber_T retval;</a>
<a name="ln1094"> </a>
<a name="ln1095">  if (call_vim_function(func, argc, argv, &amp;rettv) == FAIL) {</a>
<a name="ln1096">    return -1;</a>
<a name="ln1097">  }</a>
<a name="ln1098">  retval = tv_get_number_chk(&amp;rettv, NULL);</a>
<a name="ln1099">  tv_clear(&amp;rettv);</a>
<a name="ln1100">  return retval;</a>
<a name="ln1101">}</a>
<a name="ln1102">/// Call Vim script function and return the result as a string</a>
<a name="ln1103">///</a>
<a name="ln1104">/// @param[in]  func  Function name.</a>
<a name="ln1105">/// @param[in]  argc  Number of arguments.</a>
<a name="ln1106">/// @param[in]  argv  Array with typval_T arguments.</a>
<a name="ln1107">///</a>
<a name="ln1108">/// @return [allocated] NULL when calling function fails, allocated string</a>
<a name="ln1109">///                     otherwise.</a>
<a name="ln1110">char *call_func_retstr(const char *const func, int argc,</a>
<a name="ln1111">                       typval_T *argv)</a>
<a name="ln1112">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC</a>
<a name="ln1113">{</a>
<a name="ln1114">  typval_T rettv;</a>
<a name="ln1115">  // All arguments are passed as strings, no conversion to number.</a>
<a name="ln1116">  if (call_vim_function((const char_u *)func, argc, argv, &amp;rettv)</a>
<a name="ln1117">      == FAIL) {</a>
<a name="ln1118">    return NULL;</a>
<a name="ln1119">  }</a>
<a name="ln1120"> </a>
<a name="ln1121">  char *const retval = xstrdup(tv_get_string(&amp;rettv));</a>
<a name="ln1122">  tv_clear(&amp;rettv);</a>
<a name="ln1123">  return retval;</a>
<a name="ln1124">}</a>
<a name="ln1125">/// Call Vim script function and return the result as a List</a>
<a name="ln1126">///</a>
<a name="ln1127">/// @param[in]  func  Function name.</a>
<a name="ln1128">/// @param[in]  argc  Number of arguments.</a>
<a name="ln1129">/// @param[in]  argv  Array with typval_T arguments.</a>
<a name="ln1130">///</a>
<a name="ln1131">/// @return [allocated] NULL when calling function fails or return tv is not a</a>
<a name="ln1132">///                     List, allocated List otherwise.</a>
<a name="ln1133">void *call_func_retlist(const char_u *func, int argc, typval_T *argv)</a>
<a name="ln1134">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1135">{</a>
<a name="ln1136">  typval_T rettv;</a>
<a name="ln1137"> </a>
<a name="ln1138">  // All arguments are passed as strings, no conversion to number.</a>
<a name="ln1139">  if (call_vim_function(func, argc, argv, &amp;rettv) == FAIL) {</a>
<a name="ln1140">    return NULL;</a>
<a name="ln1141">  }</a>
<a name="ln1142"> </a>
<a name="ln1143">  if (rettv.v_type != VAR_LIST) {</a>
<a name="ln1144">    tv_clear(&amp;rettv);</a>
<a name="ln1145">    return NULL;</a>
<a name="ln1146">  }</a>
<a name="ln1147"> </a>
<a name="ln1148">  return rettv.vval.v_list;</a>
<a name="ln1149">}</a>
<a name="ln1150"> </a>
<a name="ln1151">/*</a>
<a name="ln1152"> * Prepare profiling for entering a child or something else that is not</a>
<a name="ln1153"> * counted for the script/function itself.</a>
<a name="ln1154"> * Should always be called in pair with prof_child_exit().</a>
<a name="ln1155"> */</a>
<a name="ln1156">void prof_child_enter(</a>
<a name="ln1157">    proftime_T *tm  // place to store waittime</a>
<a name="ln1158">)</a>
<a name="ln1159">{</a>
<a name="ln1160">  funccall_T *fc = get_current_funccal();</a>
<a name="ln1161"> </a>
<a name="ln1162">  if (fc != NULL &amp;&amp; fc-&gt;func-&gt;uf_profiling) {</a>
<a name="ln1163">    fc-&gt;prof_child = profile_start();</a>
<a name="ln1164">  }</a>
<a name="ln1165"> </a>
<a name="ln1166">  script_prof_save(tm);</a>
<a name="ln1167">}</a>
<a name="ln1168"> </a>
<a name="ln1169">/*</a>
<a name="ln1170"> * Take care of time spent in a child.</a>
<a name="ln1171"> * Should always be called after prof_child_enter().</a>
<a name="ln1172"> */</a>
<a name="ln1173">void prof_child_exit(</a>
<a name="ln1174">    proftime_T *tm  // where waittime was stored</a>
<a name="ln1175">)</a>
<a name="ln1176">{</a>
<a name="ln1177">  funccall_T *fc = get_current_funccal();</a>
<a name="ln1178"> </a>
<a name="ln1179">  if (fc != NULL &amp;&amp; fc-&gt;func-&gt;uf_profiling) {</a>
<a name="ln1180">    fc-&gt;prof_child = profile_end(fc-&gt;prof_child);</a>
<a name="ln1181">    // don't count waiting time</a>
<a name="ln1182">    fc-&gt;prof_child = profile_sub_wait(*tm, fc-&gt;prof_child);</a>
<a name="ln1183">    fc-&gt;func-&gt;uf_tm_children =</a>
<a name="ln1184">      profile_add(fc-&gt;func-&gt;uf_tm_children, fc-&gt;prof_child);</a>
<a name="ln1185">    fc-&gt;func-&gt;uf_tml_children =</a>
<a name="ln1186">      profile_add(fc-&gt;func-&gt;uf_tml_children, fc-&gt;prof_child);</a>
<a name="ln1187">  }</a>
<a name="ln1188">  script_prof_restore(tm);</a>
<a name="ln1189">}</a>
<a name="ln1190"> </a>
<a name="ln1191"> </a>
<a name="ln1192">/*</a>
<a name="ln1193"> * Evaluate 'foldexpr'.  Returns the foldlevel, and any character preceding</a>
<a name="ln1194"> * it in &quot;*cp&quot;.  Doesn't give error messages.</a>
<a name="ln1195"> */</a>
<a name="ln1196">int eval_foldexpr(char_u *arg, int *cp)</a>
<a name="ln1197">{</a>
<a name="ln1198">  typval_T tv;</a>
<a name="ln1199">  varnumber_T retval;</a>
<a name="ln1200">  int use_sandbox = was_set_insecurely(curwin, (char_u *)&quot;foldexpr&quot;, OPT_LOCAL);</a>
<a name="ln1201"> </a>
<a name="ln1202">  ++emsg_off;</a>
<a name="ln1203">  if (use_sandbox)</a>
<a name="ln1204">    ++sandbox;</a>
<a name="ln1205">  ++textlock;</a>
<a name="ln1206">  *cp = NUL;</a>
<a name="ln1207">  if (eval0(arg, &amp;tv, NULL, true) == FAIL) {</a>
<a name="ln1208">    retval = 0;</a>
<a name="ln1209">  } else {</a>
<a name="ln1210">    // If the result is a number, just return the number.</a>
<a name="ln1211">    if (tv.v_type == VAR_NUMBER) {</a>
<a name="ln1212">      retval = tv.vval.v_number;</a>
<a name="ln1213">    } else if (tv.v_type != VAR_STRING || tv.vval.v_string == NULL) {</a>
<a name="ln1214">      retval = 0;</a>
<a name="ln1215">    } else {</a>
<a name="ln1216">      // If the result is a string, check if there is a non-digit before</a>
<a name="ln1217">      // the number.</a>
<a name="ln1218">      char_u *s = tv.vval.v_string;</a>
<a name="ln1219">      if (!ascii_isdigit(*s) &amp;&amp; *s != '-') {</a>
<a name="ln1220">        *cp = *s++;</a>
<a name="ln1221">      }</a>
<a name="ln1222">      retval = atol((char *)s);</a>
<a name="ln1223">    }</a>
<a name="ln1224">    tv_clear(&amp;tv);</a>
<a name="ln1225">  }</a>
<a name="ln1226">  --emsg_off;</a>
<a name="ln1227">  if (use_sandbox)</a>
<a name="ln1228">    --sandbox;</a>
<a name="ln1229">  --textlock;</a>
<a name="ln1230"> </a>
<a name="ln1231">  return (int)retval;</a>
<a name="ln1232">}</a>
<a name="ln1233"> </a>
<a name="ln1234">// &quot;:cons[t] var = expr1&quot; define constant</a>
<a name="ln1235">// &quot;:cons[t] [name1, name2, ...] = expr1&quot; define constants unpacking list</a>
<a name="ln1236">// &quot;:cons[t] [name, ..., ; lastname] = expr&quot; define constants unpacking list</a>
<a name="ln1237">void ex_const(exarg_T *eap)</a>
<a name="ln1238">{</a>
<a name="ln1239">  ex_let_const(eap, true);</a>
<a name="ln1240">}</a>
<a name="ln1241"> </a>
<a name="ln1242">// Get a list of lines from a HERE document. The here document is a list of</a>
<a name="ln1243">// lines surrounded by a marker.</a>
<a name="ln1244">//     cmd &lt;&lt; {marker}</a>
<a name="ln1245">//       {line1}</a>
<a name="ln1246">//       {line2}</a>
<a name="ln1247">//       ....</a>
<a name="ln1248">//     {marker}</a>
<a name="ln1249">//</a>
<a name="ln1250">// The {marker} is a string. If the optional 'trim' word is supplied before the</a>
<a name="ln1251">// marker, then the leading indentation before the lines (matching the</a>
<a name="ln1252">// indentation in the 'cmd' line) is stripped.</a>
<a name="ln1253">// Returns a List with {lines} or NULL.</a>
<a name="ln1254">static list_T *</a>
<a name="ln1255">heredoc_get(exarg_T *eap, char_u *cmd)</a>
<a name="ln1256">{</a>
<a name="ln1257">  char_u *marker;</a>
<a name="ln1258">  char_u *p;</a>
<a name="ln1259">  int marker_indent_len = 0;</a>
<a name="ln1260">  int text_indent_len = 0;</a>
<a name="ln1261">  char_u *text_indent = NULL;</a>
<a name="ln1262"> </a>
<a name="ln1263">  if (eap-&gt;getline == NULL) {</a>
<a name="ln1264">    EMSG(_(&quot;E991: cannot use =&lt;&lt; here&quot;));</a>
<a name="ln1265">    return NULL;</a>
<a name="ln1266">  }</a>
<a name="ln1267"> </a>
<a name="ln1268">  // Check for the optional 'trim' word before the marker</a>
<a name="ln1269">  cmd = skipwhite(cmd);</a>
<a name="ln1270">  if (STRNCMP(cmd, &quot;trim&quot;, 4) == 0</a>
<a name="ln1271">      &amp;&amp; (cmd[4] == NUL || ascii_iswhite(cmd[4]))) {</a>
<a name="ln1272">    cmd = skipwhite(cmd + 4);</a>
<a name="ln1273"> </a>
<a name="ln1274">    // Trim the indentation from all the lines in the here document.</a>
<a name="ln1275">    // The amount of indentation trimmed is the same as the indentation of</a>
<a name="ln1276">    // the first line after the :let command line.  To find the end marker</a>
<a name="ln1277">    // the indent of the :let command line is trimmed.</a>
<a name="ln1278">    p = *eap-&gt;cmdlinep;</a>
<a name="ln1279">    while (ascii_iswhite(*p)) {</a>
<a name="ln1280">      p++;</a>
<a name="ln1281">      marker_indent_len++;</a>
<a name="ln1282">    }</a>
<a name="ln1283">    text_indent_len = -1;</a>
<a name="ln1284">  }</a>
<a name="ln1285"> </a>
<a name="ln1286">  // The marker is the next word.</a>
<a name="ln1287">  if (*cmd != NUL &amp;&amp; *cmd != '&quot;') {</a>
<a name="ln1288">    marker = skipwhite(cmd);</a>
<a name="ln1289">    p = skiptowhite(marker);</a>
<a name="ln1290">    if (*skipwhite(p) != NUL &amp;&amp; *skipwhite(p) != '&quot;') {</a>
<a name="ln1291">      EMSG(_(e_trailing));</a>
<a name="ln1292">      return NULL;</a>
<a name="ln1293">    }</a>
<a name="ln1294">    *p = NUL;</a>
<a name="ln1295">    if (islower(*marker)) {</a>
<a name="ln1296">      EMSG(_(&quot;E221: Marker cannot start with lower case letter&quot;));</a>
<a name="ln1297">      return NULL;</a>
<a name="ln1298">    }</a>
<a name="ln1299">  } else {</a>
<a name="ln1300">    EMSG(_(&quot;E172: Missing marker&quot;));</a>
<a name="ln1301">    return NULL;</a>
<a name="ln1302">  }</a>
<a name="ln1303"> </a>
<a name="ln1304">  list_T *l = tv_list_alloc(0);</a>
<a name="ln1305">  for (;;) {</a>
<a name="ln1306">    int mi = 0;</a>
<a name="ln1307">    int ti = 0;</a>
<a name="ln1308"> </a>
<a name="ln1309">    char_u *theline = eap-&gt;getline(NUL, eap-&gt;cookie, 0, false);</a>
<a name="ln1310">    if (theline == NULL) {</a>
<a name="ln1311">      EMSG2(_(&quot;E990: Missing end marker '%s'&quot;), marker);</a>
<a name="ln1312">      break;</a>
<a name="ln1313">    }</a>
<a name="ln1314"> </a>
<a name="ln1315">    // with &quot;trim&quot;: skip the indent matching the :let line to find the</a>
<a name="ln1316">    // marker</a>
<a name="ln1317">    if (marker_indent_len &gt; 0</a>
<a name="ln1318">        &amp;&amp; STRNCMP(theline, *eap-&gt;cmdlinep, marker_indent_len) == 0) {</a>
<a name="ln1319">        mi = marker_indent_len;</a>
<a name="ln1320">    }</a>
<a name="ln1321">    if (STRCMP(marker, theline + mi) == 0) {</a>
<a name="ln1322">      xfree(theline);</a>
<a name="ln1323">      break;</a>
<a name="ln1324">    }</a>
<a name="ln1325">    if (text_indent_len == -1 &amp;&amp; *theline != NUL) {</a>
<a name="ln1326">        // set the text indent from the first line.</a>
<a name="ln1327">        p = theline;</a>
<a name="ln1328">        text_indent_len = 0;</a>
<a name="ln1329">        while (ascii_iswhite(*p)) {</a>
<a name="ln1330">            p++;</a>
<a name="ln1331">            text_indent_len++;</a>
<a name="ln1332">        }</a>
<a name="ln1333">        text_indent = vim_strnsave(theline, text_indent_len);</a>
<a name="ln1334">    }</a>
<a name="ln1335">    // with &quot;trim&quot;: skip the indent matching the first line</a>
<a name="ln1336">    if (text_indent != NULL) {</a>
<a name="ln1337">        for (ti = 0; ti &lt; text_indent_len; ti++) {</a>
<a name="ln1338">            if (theline[ti] != text_indent[ti]) {</a>
<a name="ln1339">                break;</a>
<a name="ln1340">            }</a>
<a name="ln1341">        }</a>
<a name="ln1342">    }</a>
<a name="ln1343"> </a>
<a name="ln1344">    tv_list_append_string(l, (char *)(theline + ti), -1);</a>
<a name="ln1345">    xfree(theline);</a>
<a name="ln1346">  }</a>
<a name="ln1347">  xfree(text_indent);</a>
<a name="ln1348"> </a>
<a name="ln1349">  return l;</a>
<a name="ln1350">}</a>
<a name="ln1351"> </a>
<a name="ln1352">// &quot;:let&quot; list all variable values</a>
<a name="ln1353">// &quot;:let var1 var2&quot; list variable values</a>
<a name="ln1354">// &quot;:let var = expr&quot; assignment command.</a>
<a name="ln1355">// &quot;:let var += expr&quot; assignment command.</a>
<a name="ln1356">// &quot;:let var -= expr&quot; assignment command.</a>
<a name="ln1357">// &quot;:let var *= expr&quot; assignment command.</a>
<a name="ln1358">// &quot;:let var /= expr&quot; assignment command.</a>
<a name="ln1359">// &quot;:let var %= expr&quot; assignment command.</a>
<a name="ln1360">// &quot;:let var .= expr&quot; assignment command.</a>
<a name="ln1361">// &quot;:let var ..= expr&quot; assignment command.</a>
<a name="ln1362">// &quot;:let [var1, var2] = expr&quot; unpack list.</a>
<a name="ln1363">// &quot;:let [name, ..., ; lastname] = expr&quot; unpack list.</a>
<a name="ln1364">void ex_let(exarg_T *eap)</a>
<a name="ln1365">{</a>
<a name="ln1366">  ex_let_const(eap, false);</a>
<a name="ln1367">}</a>
<a name="ln1368"> </a>
<a name="ln1369">static void ex_let_const(exarg_T *eap, const bool is_const)</a>
<a name="ln1370">{</a>
<a name="ln1371">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln1372">  char_u      *expr = NULL;</a>
<a name="ln1373">  typval_T rettv;</a>
<a name="ln1374">  int i;</a>
<a name="ln1375">  int var_count = 0;</a>
<a name="ln1376">  int semicolon = 0;</a>
<a name="ln1377">  char_u op[2];</a>
<a name="ln1378">  char_u      *argend;</a>
<a name="ln1379">  int first = TRUE;</a>
<a name="ln1380"> </a>
<a name="ln1381">  argend = (char_u *)skip_var_list(arg, &amp;var_count, &amp;semicolon);</a>
<a name="ln1382">  if (argend == NULL) {</a>
<a name="ln1383">    return;</a>
<a name="ln1384">  }</a>
<a name="ln1385">  if (argend &gt; arg &amp;&amp; argend[-1] == '.') {  // For var.='str'.</a>
<a name="ln1386">    argend--;</a>
<a name="ln1387">  }</a>
<a name="ln1388">  expr = skipwhite(argend);</a>
<a name="ln1389">  if (*expr != '=' &amp;&amp; !((vim_strchr((char_u *)&quot;+-*/%.&quot;, *expr) != NULL</a>
<a name="ln1390">                         &amp;&amp; expr[1] == '=') || STRNCMP(expr, &quot;..=&quot;, 3) == 0)) {</a>
<a name="ln1391">    // &quot;:let&quot; without &quot;=&quot;: list variables</a>
<a name="ln1392">    if (*arg == '[') {</a>
<a name="ln1393">      EMSG(_(e_invarg));</a>
<a name="ln1394">    } else if (!ends_excmd(*arg)) {</a>
<a name="ln1395">      // &quot;:let var1 var2&quot;</a>
<a name="ln1396">      arg = (char_u *)list_arg_vars(eap, (const char *)arg, &amp;first);</a>
<a name="ln1397">    } else if (!eap-&gt;skip) {</a>
<a name="ln1398">      // &quot;:let&quot;</a>
<a name="ln1399">      list_glob_vars(&amp;first);</a>
<a name="ln1400">      list_buf_vars(&amp;first);</a>
<a name="ln1401">      list_win_vars(&amp;first);</a>
<a name="ln1402">      list_tab_vars(&amp;first);</a>
<a name="ln1403">      list_script_vars(&amp;first);</a>
<a name="ln1404">      list_func_vars(&amp;first);</a>
<a name="ln1405">      list_vim_vars(&amp;first);</a>
<a name="ln1406">    }</a>
<a name="ln1407">    eap-&gt;nextcmd = check_nextcmd(arg);</a>
<a name="ln1408">  } else if (expr[0] == '=' &amp;&amp; expr[1] == '&lt;' &amp;&amp; expr[2] == '&lt;') {</a>
<a name="ln1409">    // HERE document</a>
<a name="ln1410">    list_T *l = heredoc_get(eap, expr + 3);</a>
<a name="ln1411">    if (l != NULL) {</a>
<a name="ln1412">      tv_list_set_ret(&amp;rettv, l);</a>
<a name="ln1413">      if (!eap-&gt;skip) {</a>
<a name="ln1414">        op[0] = '=';</a>
<a name="ln1415">        op[1] = NUL;</a>
<a name="ln1416">        (void)ex_let_vars(eap-&gt;arg, &amp;rettv, false, semicolon, var_count,</a>
<a name="ln1417">                          is_const, op);</a>
<a name="ln1418">      }</a>
<a name="ln1419">      tv_clear(&amp;rettv);</a>
<a name="ln1420">    }</a>
<a name="ln1421">  } else {</a>
<a name="ln1422">    op[0] = '=';</a>
<a name="ln1423">    op[1] = NUL;</a>
<a name="ln1424">    if (*expr != '=') {</a>
<a name="ln1425">      if (vim_strchr((char_u *)&quot;+-*/%.&quot;, *expr) != NULL) {</a>
<a name="ln1426">        op[0] = *expr;  // +=, -=, *=, /=, %= or .=</a>
<a name="ln1427">        if (expr[0] == '.' &amp;&amp; expr[1] == '.') {  // ..=</a>
<a name="ln1428">          expr++;</a>
<a name="ln1429">        }</a>
<a name="ln1430">      }</a>
<a name="ln1431">      expr = skipwhite(expr + 2);</a>
<a name="ln1432">    } else {</a>
<a name="ln1433">      expr = skipwhite(expr + 1);</a>
<a name="ln1434">    }</a>
<a name="ln1435"> </a>
<a name="ln1436">    if (eap-&gt;skip)</a>
<a name="ln1437">      ++emsg_skip;</a>
<a name="ln1438">    i = eval0(expr, &amp;rettv, &amp;eap-&gt;nextcmd, !eap-&gt;skip);</a>
<a name="ln1439">    if (eap-&gt;skip) {</a>
<a name="ln1440">      if (i != FAIL) {</a>
<a name="ln1441">        tv_clear(&amp;rettv);</a>
<a name="ln1442">      }</a>
<a name="ln1443">      emsg_skip--;</a>
<a name="ln1444">    } else if (i != FAIL) {</a>
<a name="ln1445">      (void)ex_let_vars(eap-&gt;arg, &amp;rettv, false, semicolon, var_count,</a>
<a name="ln1446">                        is_const, op);</a>
<a name="ln1447">      tv_clear(&amp;rettv);</a>
<a name="ln1448">    }</a>
<a name="ln1449">  }</a>
<a name="ln1450">}</a>
<a name="ln1451"> </a>
<a name="ln1452">/*</a>
<a name="ln1453"> * Assign the typevalue &quot;tv&quot; to the variable or variables at &quot;arg_start&quot;.</a>
<a name="ln1454"> * Handles both &quot;var&quot; with any type and &quot;[var, var; var]&quot; with a list type.</a>
<a name="ln1455"> * When &quot;nextchars&quot; is not NULL it points to a string with characters that</a>
<a name="ln1456"> * must appear after the variable(s).  Use &quot;+&quot;, &quot;-&quot; or &quot;.&quot; for add, subtract</a>
<a name="ln1457"> * or concatenate.</a>
<a name="ln1458"> * Returns OK or FAIL;</a>
<a name="ln1459"> */</a>
<a name="ln1460">static int</a>
<a name="ln1461">ex_let_vars(</a>
<a name="ln1462">    char_u *arg_start,</a>
<a name="ln1463">    typval_T *tv,</a>
<a name="ln1464">    int copy,                       // copy values from &quot;tv&quot;, don't move</a>
<a name="ln1465">    int semicolon,                  // from skip_var_list()</a>
<a name="ln1466">    int var_count,                  // from skip_var_list()</a>
<a name="ln1467">    int is_const,                   // lock variables for :const</a>
<a name="ln1468">    char_u *nextchars</a>
<a name="ln1469">)</a>
<a name="ln1470">{</a>
<a name="ln1471">  char_u *arg = arg_start;</a>
<a name="ln1472">  typval_T ltv;</a>
<a name="ln1473"> </a>
<a name="ln1474">  if (*arg != '[') {</a>
<a name="ln1475">    /*</a>
<a name="ln1476">     * &quot;:let var = expr&quot; or &quot;:for var in list&quot;</a>
<a name="ln1477">     */</a>
<a name="ln1478">    if (ex_let_one(arg, tv, copy, is_const, nextchars, nextchars) == NULL) {</a>
<a name="ln1479">      return FAIL;</a>
<a name="ln1480">    }</a>
<a name="ln1481">    return OK;</a>
<a name="ln1482">  }</a>
<a name="ln1483"> </a>
<a name="ln1484">  // &quot;:let [v1, v2] = list&quot; or &quot;:for [v1, v2] in listlist&quot;</a>
<a name="ln1485">  if (tv-&gt;v_type != VAR_LIST) {</a>
<a name="ln1486">    EMSG(_(e_listreq));</a>
<a name="ln1487">    return FAIL;</a>
<a name="ln1488">  }</a>
<a name="ln1489">  list_T *const l = tv-&gt;vval.v_list;</a>
<a name="ln1490"> </a>
<a name="ln1491">  const int len = tv_list_len(l);</a>
<a name="ln1492">  if (semicolon == 0 &amp;&amp; var_count &lt; len) {</a>
<a name="ln1493">    EMSG(_(&quot;E687: Less targets than List items&quot;));</a>
<a name="ln1494">    return FAIL;</a>
<a name="ln1495">  }</a>
<a name="ln1496">  if (var_count - semicolon &gt; len) {</a>
<a name="ln1497">    EMSG(_(&quot;E688: More targets than List items&quot;));</a>
<a name="ln1498">    return FAIL;</a>
<a name="ln1499">  }</a>
<a name="ln1500">  // List l may actually be NULL, but it should fail with E688 or even earlier</a>
<a name="ln1501">  // if you try to do &quot;:let [] = v:_null_list&quot;.</a>
<a name="ln1502">  assert(l != NULL);</a>
<a name="ln1503"> </a>
<a name="ln1504">  listitem_T *item = tv_list_first(l);</a>
<a name="ln1505">  size_t rest_len = tv_list_len(l);</a>
<a name="ln1506">  while (*arg != ']') {</a>
<a name="ln1507">    arg = skipwhite(arg + 1);</a>
<a name="ln1508">    arg = ex_let_one(arg, TV_LIST_ITEM_TV(item), true, is_const,</a>
<a name="ln1509">                     (const char_u *)&quot;,;]&quot;, nextchars);</a>
<a name="ln1510">    if (arg == NULL) {</a>
<a name="ln1511">      return FAIL;</a>
<a name="ln1512">    }</a>
<a name="ln1513">    rest_len--;</a>
<a name="ln1514"> </a>
<a name="ln1515">    item = TV_LIST_ITEM_NEXT(l, item);</a>
<a name="ln1516">    arg = skipwhite(arg);</a>
<a name="ln1517">    if (*arg == ';') {</a>
<a name="ln1518">      /* Put the rest of the list (may be empty) in the var after ';'.</a>
<a name="ln1519">       * Create a new list for this. */</a>
<a name="ln1520">      list_T *const rest_list = tv_list_alloc(rest_len);</a>
<a name="ln1521">      while (item != NULL) {</a>
<a name="ln1522">        tv_list_append_tv(rest_list, TV_LIST_ITEM_TV(item));</a>
<a name="ln1523">        item = TV_LIST_ITEM_NEXT(l, item);</a>
<a name="ln1524">      }</a>
<a name="ln1525"> </a>
<a name="ln1526">      ltv.v_type = VAR_LIST;</a>
<a name="ln1527">      ltv.v_lock = VAR_UNLOCKED;</a>
<a name="ln1528">      ltv.vval.v_list = rest_list;</a>
<a name="ln1529">      tv_list_ref(rest_list);</a>
<a name="ln1530"> </a>
<a name="ln1531">      arg = ex_let_one(skipwhite(arg + 1), &amp;ltv, false, is_const,</a>
<a name="ln1532">                       (char_u *)&quot;]&quot;, nextchars);</a>
<a name="ln1533">      tv_clear(&amp;ltv);</a>
<a name="ln1534">      if (arg == NULL) {</a>
<a name="ln1535">        return FAIL;</a>
<a name="ln1536">      }</a>
<a name="ln1537">      break;</a>
<a name="ln1538">    } else if (*arg != ',' &amp;&amp; *arg != ']') {</a>
<a name="ln1539">      internal_error(&quot;ex_let_vars()&quot;);</a>
<a name="ln1540">      return FAIL;</a>
<a name="ln1541">    }</a>
<a name="ln1542">  }</a>
<a name="ln1543"> </a>
<a name="ln1544">  return OK;</a>
<a name="ln1545">}</a>
<a name="ln1546"> </a>
<a name="ln1547">/*</a>
<a name="ln1548"> * Skip over assignable variable &quot;var&quot; or list of variables &quot;[var, var]&quot;.</a>
<a name="ln1549"> * Used for &quot;:let varvar = expr&quot; and &quot;:for varvar in expr&quot;.</a>
<a name="ln1550"> * For &quot;[var, var]&quot; increment &quot;*var_count&quot; for each variable.</a>
<a name="ln1551"> * for &quot;[var, var; var]&quot; set &quot;semicolon&quot;.</a>
<a name="ln1552"> * Return NULL for an error.</a>
<a name="ln1553"> */</a>
<a name="ln1554">static const char_u *skip_var_list(const char_u *arg, int *var_count,</a>
<a name="ln1555">                                   int *semicolon)</a>
<a name="ln1556">{</a>
<a name="ln1557">  const char_u *p;</a>
<a name="ln1558">  const char_u *s;</a>
<a name="ln1559"> </a>
<a name="ln1560">  if (*arg == '[') {</a>
<a name="ln1561">    // &quot;[var, var]&quot;: find the matching ']'.</a>
<a name="ln1562">    p = arg;</a>
<a name="ln1563">    for (;; ) {</a>
<a name="ln1564">      p = skipwhite(p + 1);             // skip whites after '[', ';' or ','</a>
<a name="ln1565">      s = skip_var_one(p);</a>
<a name="ln1566">      if (s == p) {</a>
<a name="ln1567">        EMSG2(_(e_invarg2), p);</a>
<a name="ln1568">        return NULL;</a>
<a name="ln1569">      }</a>
<a name="ln1570">      ++*var_count;</a>
<a name="ln1571"> </a>
<a name="ln1572">      p = skipwhite(s);</a>
<a name="ln1573">      if (*p == ']')</a>
<a name="ln1574">        break;</a>
<a name="ln1575">      else if (*p == ';') {</a>
<a name="ln1576">        if (*semicolon == 1) {</a>
<a name="ln1577">          EMSG(_(&quot;E452: Double ; in list of variables&quot;));</a>
<a name="ln1578">          return NULL;</a>
<a name="ln1579">        }</a>
<a name="ln1580">        *semicolon = 1;</a>
<a name="ln1581">      } else if (*p != ',') {</a>
<a name="ln1582">        EMSG2(_(e_invarg2), p);</a>
<a name="ln1583">        return NULL;</a>
<a name="ln1584">      }</a>
<a name="ln1585">    }</a>
<a name="ln1586">    return p + 1;</a>
<a name="ln1587">  } else</a>
<a name="ln1588">    return skip_var_one(arg);</a>
<a name="ln1589">}</a>
<a name="ln1590"> </a>
<a name="ln1591">/*</a>
<a name="ln1592"> * Skip one (assignable) variable name, including @r, $VAR, &amp;option, d.key,</a>
<a name="ln1593"> * l[idx].</a>
<a name="ln1594"> */</a>
<a name="ln1595">static const char_u *skip_var_one(const char_u *arg)</a>
<a name="ln1596">{</a>
<a name="ln1597">  if (*arg == '@' &amp;&amp; arg[1] != NUL)</a>
<a name="ln1598">    return arg + 2;</a>
<a name="ln1599">  return find_name_end(*arg == '$' || *arg == '&amp;' ? arg + 1 : arg,</a>
<a name="ln1600">      NULL, NULL, FNE_INCL_BR | FNE_CHECK_START);</a>
<a name="ln1601">}</a>
<a name="ln1602"> </a>
<a name="ln1603">/*</a>
<a name="ln1604"> * List variables for hashtab &quot;ht&quot; with prefix &quot;prefix&quot;.</a>
<a name="ln1605"> * If &quot;empty&quot; is TRUE also list NULL strings as empty strings.</a>
<a name="ln1606"> */</a>
<a name="ln1607">void list_hashtable_vars(hashtab_T *ht, const char *prefix, int empty,</a>
<a name="ln1608">                         int *first)</a>
<a name="ln1609">{</a>
<a name="ln1610">  hashitem_T  *hi;</a>
<a name="ln1611">  dictitem_T  *di;</a>
<a name="ln1612">  int todo;</a>
<a name="ln1613"> </a>
<a name="ln1614">  todo = (int)ht-&gt;ht_used;</a>
<a name="ln1615">  for (hi = ht-&gt;ht_array; todo &gt; 0 &amp;&amp; !got_int; ++hi) {</a>
<a name="ln1616">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1617">      todo--;</a>
<a name="ln1618">      di = TV_DICT_HI2DI(hi);</a>
<a name="ln1619">      char buf[IOSIZE];</a>
<a name="ln1620"> </a>
<a name="ln1621">      // apply :filter /pat/ to variable name</a>
<a name="ln1622">      xstrlcpy(buf, prefix, IOSIZE);</a>
<a name="ln1623">      xstrlcat(buf, (char *)di-&gt;di_key, IOSIZE);</a>
<a name="ln1624">      if (message_filtered((char_u *)buf)) {</a>
<a name="ln1625">        continue;</a>
<a name="ln1626">      }</a>
<a name="ln1627"> </a>
<a name="ln1628">      if (empty || di-&gt;di_tv.v_type != VAR_STRING</a>
<a name="ln1629">          || di-&gt;di_tv.vval.v_string != NULL) {</a>
<a name="ln1630">        list_one_var(di, prefix, first);</a>
<a name="ln1631">      }</a>
<a name="ln1632">    }</a>
<a name="ln1633">  }</a>
<a name="ln1634">}</a>
<a name="ln1635"> </a>
<a name="ln1636">/*</a>
<a name="ln1637"> * List global variables.</a>
<a name="ln1638"> */</a>
<a name="ln1639">static void list_glob_vars(int *first)</a>
<a name="ln1640">{</a>
<a name="ln1641">  list_hashtable_vars(&amp;globvarht, &quot;&quot;, true, first);</a>
<a name="ln1642">}</a>
<a name="ln1643"> </a>
<a name="ln1644">/*</a>
<a name="ln1645"> * List buffer variables.</a>
<a name="ln1646"> */</a>
<a name="ln1647">static void list_buf_vars(int *first)</a>
<a name="ln1648">{</a>
<a name="ln1649">  list_hashtable_vars(&amp;curbuf-&gt;b_vars-&gt;dv_hashtab, &quot;b:&quot;, true, first);</a>
<a name="ln1650">}</a>
<a name="ln1651"> </a>
<a name="ln1652">/*</a>
<a name="ln1653"> * List window variables.</a>
<a name="ln1654"> */</a>
<a name="ln1655">static void list_win_vars(int *first)</a>
<a name="ln1656">{</a>
<a name="ln1657">  list_hashtable_vars(&amp;curwin-&gt;w_vars-&gt;dv_hashtab, &quot;w:&quot;, true, first);</a>
<a name="ln1658">}</a>
<a name="ln1659"> </a>
<a name="ln1660">/*</a>
<a name="ln1661"> * List tab page variables.</a>
<a name="ln1662"> */</a>
<a name="ln1663">static void list_tab_vars(int *first)</a>
<a name="ln1664">{</a>
<a name="ln1665">  list_hashtable_vars(&amp;curtab-&gt;tp_vars-&gt;dv_hashtab, &quot;t:&quot;, true, first);</a>
<a name="ln1666">}</a>
<a name="ln1667"> </a>
<a name="ln1668">/*</a>
<a name="ln1669"> * List Vim variables.</a>
<a name="ln1670"> */</a>
<a name="ln1671">static void list_vim_vars(int *first)</a>
<a name="ln1672">{</a>
<a name="ln1673">  list_hashtable_vars(&amp;vimvarht, &quot;v:&quot;, false, first);</a>
<a name="ln1674">}</a>
<a name="ln1675"> </a>
<a name="ln1676">// List script-local variables, if there is a script.</a>
<a name="ln1677">static void list_script_vars(int *first)</a>
<a name="ln1678">{</a>
<a name="ln1679">  if (current_sctx.sc_sid &gt; 0 &amp;&amp; current_sctx.sc_sid &lt;= ga_scripts.ga_len) {</a>
<a name="ln1680">    list_hashtable_vars(&amp;SCRIPT_VARS(current_sctx.sc_sid), &quot;s:&quot;, false, first);</a>
<a name="ln1681">  }</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684">/*</a>
<a name="ln1685"> * List variables in &quot;arg&quot;.</a>
<a name="ln1686"> */</a>
<a name="ln1687">static const char *list_arg_vars(exarg_T *eap, const char *arg, int *first)</a>
<a name="ln1688">{</a>
<a name="ln1689">  int error = FALSE;</a>
<a name="ln1690">  int len;</a>
<a name="ln1691">  const char *name;</a>
<a name="ln1692">  const char *name_start;</a>
<a name="ln1693">  typval_T tv;</a>
<a name="ln1694"> </a>
<a name="ln1695">  while (!ends_excmd(*arg) &amp;&amp; !got_int) {</a>
<a name="ln1696">    if (error || eap-&gt;skip) {</a>
<a name="ln1697">      arg = (const char *)find_name_end((char_u *)arg, NULL, NULL,</a>
<a name="ln1698">                                        FNE_INCL_BR | FNE_CHECK_START);</a>
<a name="ln1699">      if (!ascii_iswhite(*arg) &amp;&amp; !ends_excmd(*arg)) {</a>
<a name="ln1700">        emsg_severe = true;</a>
<a name="ln1701">        EMSG(_(e_trailing));</a>
<a name="ln1702">        break;</a>
<a name="ln1703">      }</a>
<a name="ln1704">    } else {</a>
<a name="ln1705">      // get_name_len() takes care of expanding curly braces</a>
<a name="ln1706">      name_start = name = arg;</a>
<a name="ln1707">      char *tofree;</a>
<a name="ln1708">      len = get_name_len(&amp;arg, &amp;tofree, true, true);</a>
<a name="ln1709">      if (len &lt;= 0) {</a>
<a name="ln1710">        /* This is mainly to keep test 49 working: when expanding</a>
<a name="ln1711">         * curly braces fails overrule the exception error message. */</a>
<a name="ln1712">        if (len &lt; 0 &amp;&amp; !aborting()) {</a>
<a name="ln1713">          emsg_severe = true;</a>
<a name="ln1714">          EMSG2(_(e_invarg2), arg);</a>
<a name="ln1715">          break;</a>
<a name="ln1716">        }</a>
<a name="ln1717">        error = TRUE;</a>
<a name="ln1718">      } else {</a>
<a name="ln1719">        if (tofree != NULL) {</a>
<a name="ln1720">          name = tofree;</a>
<a name="ln1721">        }</a>
<a name="ln1722">        if (get_var_tv((const char *)name, len, &amp;tv, NULL, true, false)</a>
<a name="ln1723">            == FAIL) {</a>
<a name="ln1724">          error = true;</a>
<a name="ln1725">        } else {</a>
<a name="ln1726">          // handle d.key, l[idx], f(expr)</a>
<a name="ln1727">          const char *const arg_subsc = arg;</a>
<a name="ln1728">          if (handle_subscript(&amp;arg, &amp;tv, true, true) == FAIL) {</a>
<a name="ln1729">            error = true;</a>
<a name="ln1730">          } else {</a>
<a name="ln1731">            if (arg == arg_subsc &amp;&amp; len == 2 &amp;&amp; name[1] == ':') {</a>
<a name="ln1732">              switch (*name) {</a>
<a name="ln1733">              case 'g': list_glob_vars(first); break;</a>
<a name="ln1734">              case 'b': list_buf_vars(first); break;</a>
<a name="ln1735">              case 'w': list_win_vars(first); break;</a>
<a name="ln1736">              case 't': list_tab_vars(first); break;</a>
<a name="ln1737">              case 'v': list_vim_vars(first); break;</a>
<a name="ln1738">              case 's': list_script_vars(first); break;</a>
<a name="ln1739">              case 'l': list_func_vars(first); break;</a>
<a name="ln1740">              default:</a>
<a name="ln1741">                EMSG2(_(&quot;E738: Can't list variables for %s&quot;), name);</a>
<a name="ln1742">              }</a>
<a name="ln1743">            } else {</a>
<a name="ln1744">              char *const s = encode_tv2echo(&amp;tv, NULL);</a>
<a name="ln1745">              const char *const used_name = (arg == arg_subsc</a>
<a name="ln1746">                                             ? name</a>
<a name="ln1747">                                             : name_start);</a>
<a name="ln1748">              const ptrdiff_t name_size = (used_name == tofree</a>
<a name="ln1749">                                           ? (ptrdiff_t)strlen(used_name)</a>
<a name="ln1750">                                           : (arg - used_name));</a>
<a name="ln1751">              list_one_var_a(&quot;&quot;, used_name, name_size,</a>
<a name="ln1752">                             tv.v_type, s == NULL ? &quot;&quot; : s, first);</a>
<a name="ln1753">              xfree(s);</a>
<a name="ln1754">            }</a>
<a name="ln1755">            tv_clear(&amp;tv);</a>
<a name="ln1756">          }</a>
<a name="ln1757">        }</a>
<a name="ln1758">      }</a>
<a name="ln1759"> </a>
<a name="ln1760">      xfree(tofree);</a>
<a name="ln1761">    }</a>
<a name="ln1762"> </a>
<a name="ln1763">    arg = (const char *)skipwhite((const char_u *)arg);</a>
<a name="ln1764">  }</a>
<a name="ln1765"> </a>
<a name="ln1766">  return arg;</a>
<a name="ln1767">}</a>
<a name="ln1768"> </a>
<a name="ln1769">// TODO(ZyX-I): move to eval/ex_cmds</a>
<a name="ln1770"> </a>
<a name="ln1771">/// Set one item of `:let var = expr` or `:let [v1, v2] = list` to its value</a>
<a name="ln1772">///</a>
<a name="ln1773">/// @param[in]  arg  Start of the variable name.</a>
<a name="ln1774">/// @param[in]  tv  Value to assign to the variable.</a>
<a name="ln1775">/// @param[in]  copy  If true, copy value from `tv`.</a>
<a name="ln1776">/// @param[in]  endchars  Valid characters after variable name or NULL.</a>
<a name="ln1777">/// @param[in]  op  Operation performed: *op is `+`, `-`, `.` for `+=`, etc.</a>
<a name="ln1778">///                 NULL for `=`.</a>
<a name="ln1779">///</a>
<a name="ln1780">/// @return a pointer to the char just after the var name or NULL in case of</a>
<a name="ln1781">///         error.</a>
<a name="ln1782">static char_u *ex_let_one(char_u *arg, typval_T *const tv,</a>
<a name="ln1783">                          const bool copy, const bool is_const,</a>
<a name="ln1784">                          const char_u *const endchars, const char_u *const op)</a>
<a name="ln1785">  FUNC_ATTR_NONNULL_ARG(1, 2) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1786">{</a>
<a name="ln1787">  char_u *arg_end = NULL;</a>
<a name="ln1788">  int len;</a>
<a name="ln1789">  int opt_flags;</a>
<a name="ln1790">  char_u *tofree = NULL;</a>
<a name="ln1791"> </a>
<a name="ln1792">  /*</a>
<a name="ln1793">   * &quot;:let $VAR = expr&quot;: Set environment variable.</a>
<a name="ln1794">   */</a>
<a name="ln1795">  if (*arg == '$') {</a>
<a name="ln1796">    if (is_const) {</a>
<a name="ln1797">      EMSG(_(&quot;E996: Cannot lock an environment variable&quot;));</a>
<a name="ln1798">      return NULL;</a>
<a name="ln1799">    }</a>
<a name="ln1800">    // Find the end of the name.</a>
<a name="ln1801">    arg++;</a>
<a name="ln1802">    char *name = (char *)arg;</a>
<a name="ln1803">    len = get_env_len((const char_u **)&amp;arg);</a>
<a name="ln1804">    if (len == 0) {</a>
<a name="ln1805">      EMSG2(_(e_invarg2), name - 1);</a>
<a name="ln1806">    } else {</a>
<a name="ln1807">      if (op != NULL &amp;&amp; vim_strchr((char_u *)&quot;+-*/%&quot;, *op) != NULL) {</a>
<a name="ln1808">        EMSG2(_(e_letwrong), op);</a>
<a name="ln1809">      } else if (endchars != NULL</a>
<a name="ln1810">                 &amp;&amp; vim_strchr(endchars, *skipwhite(arg)) == NULL) {</a>
<a name="ln1811">        EMSG(_(e_letunexp));</a>
<a name="ln1812">      } else if (!check_secure()) {</a>
<a name="ln1813">        const char c1 = name[len];</a>
<a name="ln1814">        name[len] = NUL;</a>
<a name="ln1815">        const char *p = tv_get_string_chk(tv);</a>
<a name="ln1816">        if (p != NULL &amp;&amp; op != NULL &amp;&amp; *op == '.') {</a>
<a name="ln1817">          char *s = vim_getenv(name);</a>
<a name="ln1818"> </a>
<a name="ln1819">          if (s != NULL) {</a>
<a name="ln1820">            tofree = concat_str((const char_u *)s, (const char_u *)p);</a>
<a name="ln1821">            p = (const char *)tofree;</a>
<a name="ln1822">            xfree(s);</a>
<a name="ln1823">          }</a>
<a name="ln1824">        }</a>
<a name="ln1825">        if (p != NULL) {</a>
<a name="ln1826">          os_setenv(name, p, 1);</a>
<a name="ln1827">          if (STRICMP(name, &quot;HOME&quot;) == 0) {</a>
<a name="ln1828">            init_homedir();</a>
<a name="ln1829">          } else if (didset_vim &amp;&amp; STRICMP(name, &quot;VIM&quot;) == 0) {</a>
<a name="ln1830">            didset_vim = false;</a>
<a name="ln1831">          } else if (didset_vimruntime</a>
<a name="ln1832">                     &amp;&amp; STRICMP(name, &quot;VIMRUNTIME&quot;) == 0) {</a>
<a name="ln1833">            didset_vimruntime = false;</a>
<a name="ln1834">          }</a>
<a name="ln1835">          arg_end = arg;</a>
<a name="ln1836">        }</a>
<a name="ln1837">        name[len] = c1;</a>
<a name="ln1838">        xfree(tofree);</a>
<a name="ln1839">      }</a>
<a name="ln1840">    }</a>
<a name="ln1841">  // &quot;:let &amp;option = expr&quot;: Set option value.</a>
<a name="ln1842">  // &quot;:let &amp;l:option = expr&quot;: Set local option value.</a>
<a name="ln1843">  // &quot;:let &amp;g:option = expr&quot;: Set global option value.</a>
<a name="ln1844">  } else if (*arg == '&amp;') {</a>
<a name="ln1845">    if (is_const) {</a>
<a name="ln1846">      EMSG(_(&quot;E996: Cannot lock an option&quot;));</a>
<a name="ln1847">      return NULL;</a>
<a name="ln1848">    }</a>
<a name="ln1849">    // Find the end of the name.</a>
<a name="ln1850">    char *const p = (char *)find_option_end((const char **)&amp;arg, &amp;opt_flags);</a>
<a name="ln1851">    if (p == NULL</a>
<a name="ln1852">        || (endchars != NULL</a>
<a name="ln1853">            &amp;&amp; vim_strchr(endchars, *skipwhite((const char_u *)p)) == NULL)) {</a>
<a name="ln1854">      EMSG(_(e_letunexp));</a>
<a name="ln1855">    } else {</a>
<a name="ln1856">      int opt_type;</a>
<a name="ln1857">      long numval;</a>
<a name="ln1858">      char *stringval = NULL;</a>
<a name="ln1859">      const char *s = NULL;</a>
<a name="ln1860"> </a>
<a name="ln1861">      const char c1 = *p;</a>
<a name="ln1862">      *p = NUL;</a>
<a name="ln1863"> </a>
<a name="ln1864">      varnumber_T n = tv_get_number(tv);</a>
<a name="ln1865">      if (tv-&gt;v_type != VAR_BOOL &amp;&amp; tv-&gt;v_type != VAR_SPECIAL) {</a>
<a name="ln1866">        s = tv_get_string_chk(tv);  // != NULL if number or string.</a>
<a name="ln1867">      }</a>
<a name="ln1868">      if (s != NULL &amp;&amp; op != NULL &amp;&amp; *op != '=') {</a>
<a name="ln1869">        opt_type = get_option_value((char *)arg, &amp;numval, (char_u **)&amp;stringval,</a>
<a name="ln1870">                                    opt_flags);</a>
<a name="ln1871">        if ((opt_type == 1 &amp;&amp; *op == '.')</a>
<a name="ln1872">            || (opt_type == 0 &amp;&amp; *op != '.')) {</a>
<a name="ln1873">          EMSG2(_(e_letwrong), op);</a>
<a name="ln1874">          s = NULL;  // don't set the value</a>
<a name="ln1875">        } else {</a>
<a name="ln1876">          if (opt_type == 1) {  // number</a>
<a name="ln1877">            switch (*op) {</a>
<a name="ln1878">              case '+': n = numval + n; break;</a>
<a name="ln1879">              case '-': n = numval - n; break;</a>
<a name="ln1880">              case '*': n = numval * n; break;</a>
<a name="ln1881">              case '/': n = num_divide(numval, n); break;</a>
<a name="ln1882">              case '%': n = num_modulus(numval, n); break;</a>
<a name="ln1883">            }</a>
<a name="ln1884">          } else if (opt_type == 0 &amp;&amp; stringval != NULL) {  // string</a>
<a name="ln1885">            char *const oldstringval = stringval;</a>
<a name="ln1886">            stringval = (char *)concat_str((const char_u *)stringval,</a>
<a name="ln1887">                                           (const char_u *)s);</a>
<a name="ln1888">            xfree(oldstringval);</a>
<a name="ln1889">            s = stringval;</a>
<a name="ln1890">          }</a>
<a name="ln1891">        }</a>
<a name="ln1892">      }</a>
<a name="ln1893">      if (s != NULL || tv-&gt;v_type == VAR_BOOL</a>
<a name="ln1894">          || tv-&gt;v_type == VAR_SPECIAL) {</a>
<a name="ln1895">        set_option_value((const char *)arg, n, s, opt_flags);</a>
<a name="ln1896">        arg_end = (char_u *)p;</a>
<a name="ln1897">      }</a>
<a name="ln1898">      *p = c1;</a>
<a name="ln1899">      xfree(stringval);</a>
<a name="ln1900">    }</a>
<a name="ln1901">  // &quot;:let @r = expr&quot;: Set register contents.</a>
<a name="ln1902">  } else if (*arg == '@') {</a>
<a name="ln1903">    if (is_const) {</a>
<a name="ln1904">      EMSG(_(&quot;E996: Cannot lock a register&quot;));</a>
<a name="ln1905">      return NULL;</a>
<a name="ln1906">    }</a>
<a name="ln1907">    arg++;</a>
<a name="ln1908">    if (op != NULL &amp;&amp; vim_strchr((char_u *)&quot;+-*/%&quot;, *op) != NULL) {</a>
<a name="ln1909">      emsgf(_(e_letwrong), op);</a>
<a name="ln1910">    } else if (endchars != NULL</a>
<a name="ln1911">               &amp;&amp; vim_strchr(endchars, *skipwhite(arg + 1)) == NULL) {</a>
<a name="ln1912">      EMSG(_(e_letunexp));</a>
<a name="ln1913">    } else {</a>
<a name="ln1914">      char_u      *s;</a>
<a name="ln1915"> </a>
<a name="ln1916">      char_u *ptofree = NULL;</a>
<a name="ln1917">      const char *p = tv_get_string_chk(tv);</a>
<a name="ln1918">      if (p != NULL &amp;&amp; op != NULL &amp;&amp; *op == '.') {</a>
<a name="ln1919">        s = get_reg_contents(*arg == '@' ? '&quot;' : *arg, kGRegExprSrc);</a>
<a name="ln1920">        if (s != NULL) {</a>
<a name="ln1921">          ptofree = concat_str(s, (const char_u *)p);</a>
<a name="ln1922">          p = (const char *)ptofree;</a>
<a name="ln1923">          xfree(s);</a>
<a name="ln1924">        }</a>
<a name="ln1925">      }</a>
<a name="ln1926">      if (p != NULL) {</a>
<a name="ln1927">        write_reg_contents(*arg == '@' ? '&quot;' : *arg,</a>
<a name="ln1928">                           (const char_u *)p, STRLEN(p), false);</a>
<a name="ln1929">        arg_end = arg + 1;</a>
<a name="ln1930">      }</a>
<a name="ln1931">      xfree(ptofree);</a>
<a name="ln1932">    }</a>
<a name="ln1933">  }</a>
<a name="ln1934">  /*</a>
<a name="ln1935">   * &quot;:let var = expr&quot;: Set internal variable.</a>
<a name="ln1936">   * &quot;:let {expr} = expr&quot;: Idem, name made with curly braces</a>
<a name="ln1937">   */</a>
<a name="ln1938">  else if (eval_isnamec1(*arg) || *arg == '{') {</a>
<a name="ln1939">    lval_T lv;</a>
<a name="ln1940"> </a>
<a name="ln1941">    char_u *const p = get_lval(arg, tv, &amp;lv, false, false, 0, FNE_CHECK_START);</a>
<a name="ln1942">    if (p != NULL &amp;&amp; lv.ll_name != NULL) {</a>
<a name="ln1943">      if (endchars != NULL &amp;&amp; vim_strchr(endchars, *skipwhite(p)) == NULL) {</a>
<a name="ln1944">        EMSG(_(e_letunexp));</a>
<a name="ln1945">      } else {</a>
<a name="ln1946">        set_var_lval(&amp;lv, p, tv, copy, is_const, (const char *)op);</a>
<a name="ln1947">        arg_end = p;</a>
<a name="ln1948">      }</a>
<a name="ln1949">    }</a>
<a name="ln1950">    clear_lval(&amp;lv);</a>
<a name="ln1951">  } else</a>
<a name="ln1952">    EMSG2(_(e_invarg2), arg);</a>
<a name="ln1953"> </a>
<a name="ln1954">  return arg_end;</a>
<a name="ln1955">}</a>
<a name="ln1956"> </a>
<a name="ln1957">// TODO(ZyX-I): move to eval/executor</a>
<a name="ln1958"> </a>
<a name="ln1959">/// Get an lvalue</a>
<a name="ln1960">///</a>
<a name="ln1961">/// Lvalue may be</a>
<a name="ln1962">/// - variable: &quot;name&quot;, &quot;na{me}&quot;</a>
<a name="ln1963">/// - dictionary item: &quot;dict.key&quot;, &quot;dict['key']&quot;</a>
<a name="ln1964">/// - list item: &quot;list[expr]&quot;</a>
<a name="ln1965">/// - list slice: &quot;list[expr:expr]&quot;</a>
<a name="ln1966">///</a>
<a name="ln1967">/// Indexing only works if trying to use it with an existing List or Dictionary.</a>
<a name="ln1968">///</a>
<a name="ln1969">/// @param[in]  name  Name to parse.</a>
<a name="ln1970">/// @param  rettv  Pointer to the value to be assigned or NULL.</a>
<a name="ln1971">/// @param[out]  lp  Lvalue definition. When evaluation errors occur `-&gt;ll_name`</a>
<a name="ln1972">///                  is NULL.</a>
<a name="ln1973">/// @param[in]  unlet  True if using `:unlet`. This results in slightly</a>
<a name="ln1974">///                    different behaviour when something is wrong; must end in</a>
<a name="ln1975">///                    space or cmd separator.</a>
<a name="ln1976">/// @param[in]  skip  True when skipping.</a>
<a name="ln1977">/// @param[in]  flags  @see GetLvalFlags.</a>
<a name="ln1978">/// @param[in]  fne_flags  Flags for find_name_end().</a>
<a name="ln1979">///</a>
<a name="ln1980">/// @return A pointer to just after the name, including indexes. Returns NULL</a>
<a name="ln1981">///         for a parsing error, but it is still needed to free items in lp.</a>
<a name="ln1982">char_u *get_lval(char_u *const name, typval_T *const rettv,</a>
<a name="ln1983">                 lval_T *const lp, const bool unlet, const bool skip,</a>
<a name="ln1984">                 const int flags, const int fne_flags)</a>
<a name="ln1985">  FUNC_ATTR_NONNULL_ARG(1, 3)</a>
<a name="ln1986">{</a>
<a name="ln1987">  dictitem_T  *v;</a>
<a name="ln1988">  typval_T var1;</a>
<a name="ln1989">  typval_T var2;</a>
<a name="ln1990">  int empty1 = FALSE;</a>
<a name="ln1991">  listitem_T  *ni;</a>
<a name="ln1992">  hashtab_T *ht = NULL;</a>
<a name="ln1993">  int quiet = flags &amp; GLV_QUIET;</a>
<a name="ln1994"> </a>
<a name="ln1995">  // Clear everything in &quot;lp&quot;.</a>
<a name="ln1996">  memset(lp, 0, sizeof(lval_T));</a>
<a name="ln1997"> </a>
<a name="ln1998">  if (skip) {</a>
<a name="ln1999">    // When skipping just find the end of the name.</a>
<a name="ln2000">    lp-&gt;ll_name = (const char *)name;</a>
<a name="ln2001">    return (char_u *)find_name_end((const char_u *)name, NULL, NULL,</a>
<a name="ln2002">                                   FNE_INCL_BR | fne_flags);</a>
<a name="ln2003">  }</a>
<a name="ln2004"> </a>
<a name="ln2005">  // Find the end of the name.</a>
<a name="ln2006">  char_u *expr_start;</a>
<a name="ln2007">  char_u *expr_end;</a>
<a name="ln2008">  char_u *p = (char_u *)find_name_end(name,</a>
<a name="ln2009">                                      (const char_u **)&amp;expr_start,</a>
<a name="ln2010">                                      (const char_u **)&amp;expr_end,</a>
<a name="ln2011">                                      fne_flags);</a>
<a name="ln2012">  if (expr_start != NULL) {</a>
<a name="ln2013">    // Don't expand the name when we already know there is an error.</a>
<a name="ln2014">    if (unlet &amp;&amp; !ascii_iswhite(*p) &amp;&amp; !ends_excmd(*p)</a>
<a name="ln2015">        &amp;&amp; *p != '[' &amp;&amp; *p != '.') {</a>
<a name="ln2016">      EMSG(_(e_trailing));</a>
<a name="ln2017">      return NULL;</a>
<a name="ln2018">    }</a>
<a name="ln2019"> </a>
<a name="ln2020">    lp-&gt;ll_exp_name = (char *)make_expanded_name(name, expr_start, expr_end,</a>
<a name="ln2021">                                                 (char_u *)p);</a>
<a name="ln2022">    lp-&gt;ll_name = lp-&gt;ll_exp_name;</a>
<a name="ln2023">    if (lp-&gt;ll_exp_name == NULL) {</a>
<a name="ln2024">      /* Report an invalid expression in braces, unless the</a>
<a name="ln2025">       * expression evaluation has been cancelled due to an</a>
<a name="ln2026">       * aborting error, an interrupt, or an exception. */</a>
<a name="ln2027">      if (!aborting() &amp;&amp; !quiet) {</a>
<a name="ln2028">        emsg_severe = true;</a>
<a name="ln2029">        EMSG2(_(e_invarg2), name);</a>
<a name="ln2030">        return NULL;</a>
<a name="ln2031">      }</a>
<a name="ln2032">      lp-&gt;ll_name_len = 0;</a>
<a name="ln2033">    } else {</a>
<a name="ln2034">      lp-&gt;ll_name_len = strlen(lp-&gt;ll_name);</a>
<a name="ln2035">    }</a>
<a name="ln2036">  } else {</a>
<a name="ln2037">    lp-&gt;ll_name = (const char *)name;</a>
<a name="ln2038">    lp-&gt;ll_name_len = (size_t)((const char *)p - lp-&gt;ll_name);</a>
<a name="ln2039">  }</a>
<a name="ln2040"> </a>
<a name="ln2041">  // Without [idx] or .key we are done.</a>
<a name="ln2042">  if ((*p != '[' &amp;&amp; *p != '.') || lp-&gt;ll_name == NULL) {</a>
<a name="ln2043">    return p;</a>
<a name="ln2044">  }</a>
<a name="ln2045"> </a>
<a name="ln2046">  // Only pass &amp;ht when we would write to the variable, it prevents autoload</a>
<a name="ln2047">  // as well.</a>
<a name="ln2048">  v = find_var(lp-&gt;ll_name, lp-&gt;ll_name_len,</a>
<a name="ln2049">               (flags &amp; GLV_READ_ONLY) ? NULL : &amp;ht,</a>
<a name="ln2050">               flags &amp; GLV_NO_AUTOLOAD);</a>
<a name="ln2051">  if (v == NULL &amp;&amp; !quiet) {</a>
<a name="ln2052">    emsgf(_(&quot;E121: Undefined variable: %.*s&quot;),</a>
<a name="ln2053">          (int)lp-&gt;ll_name_len, lp-&gt;ll_name);</a>
<a name="ln2054">  }</a>
<a name="ln2055">  if (v == NULL) {</a>
<a name="ln2056">    return NULL;</a>
<a name="ln2057">  }</a>
<a name="ln2058"> </a>
<a name="ln2059">  /*</a>
<a name="ln2060">   * Loop until no more [idx] or .key is following.</a>
<a name="ln2061">   */</a>
<a name="ln2062">  lp-&gt;ll_tv = &amp;v-&gt;di_tv;</a>
<a name="ln2063">  var1.v_type = VAR_UNKNOWN;</a>
<a name="ln2064">  var2.v_type = VAR_UNKNOWN;</a>
<a name="ln2065">  while (*p == '[' || (*p == '.' &amp;&amp; lp-&gt;ll_tv-&gt;v_type == VAR_DICT)) {</a>
<a name="ln2066">    if (!(lp-&gt;ll_tv-&gt;v_type == VAR_LIST &amp;&amp; lp-&gt;ll_tv-&gt;vval.v_list != NULL)</a>
<a name="ln2067">        &amp;&amp; !(lp-&gt;ll_tv-&gt;v_type == VAR_DICT</a>
<a name="ln2068">             &amp;&amp; lp-&gt;ll_tv-&gt;vval.v_dict != NULL)) {</a>
<a name="ln2069">      if (!quiet)</a>
<a name="ln2070">        EMSG(_(&quot;E689: Can only index a List or Dictionary&quot;));</a>
<a name="ln2071">      return NULL;</a>
<a name="ln2072">    }</a>
<a name="ln2073">    if (lp-&gt;ll_range) {</a>
<a name="ln2074">      if (!quiet)</a>
<a name="ln2075">        EMSG(_(&quot;E708: [:] must come last&quot;));</a>
<a name="ln2076">      return NULL;</a>
<a name="ln2077">    }</a>
<a name="ln2078"> </a>
<a name="ln2079">    int len = -1;</a>
<a name="ln2080">    char_u *key = NULL;</a>
<a name="ln2081">    if (*p == '.') {</a>
<a name="ln2082">      key = p + 1;</a>
<a name="ln2083">      for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; len++) {</a>
<a name="ln2084">      }</a>
<a name="ln2085">      if (len == 0) {</a>
<a name="ln2086">        if (!quiet) {</a>
<a name="ln2087">          EMSG(_(&quot;E713: Cannot use empty key after .&quot;));</a>
<a name="ln2088">        }</a>
<a name="ln2089">        return NULL;</a>
<a name="ln2090">      }</a>
<a name="ln2091">      p = key + len;</a>
<a name="ln2092">    } else {</a>
<a name="ln2093">      // Get the index [expr] or the first index [expr: ].</a>
<a name="ln2094">      p = skipwhite(p + 1);</a>
<a name="ln2095">      if (*p == ':') {</a>
<a name="ln2096">        empty1 = true;</a>
<a name="ln2097">      } else {</a>
<a name="ln2098">        empty1 = false;</a>
<a name="ln2099">        if (eval1(&amp;p, &amp;var1, true) == FAIL) {  // Recursive!</a>
<a name="ln2100">          return NULL;</a>
<a name="ln2101">        }</a>
<a name="ln2102">        if (!tv_check_str(&amp;var1)) {</a>
<a name="ln2103">          // Not a number or string.</a>
<a name="ln2104">          tv_clear(&amp;var1);</a>
<a name="ln2105">          return NULL;</a>
<a name="ln2106">        }</a>
<a name="ln2107">        p = skipwhite(p);</a>
<a name="ln2108">      }</a>
<a name="ln2109"> </a>
<a name="ln2110">      // Optionally get the second index [ :expr].</a>
<a name="ln2111">      if (*p == ':') {</a>
<a name="ln2112">        if (lp-&gt;ll_tv-&gt;v_type == VAR_DICT) {</a>
<a name="ln2113">          if (!quiet) {</a>
<a name="ln2114">            EMSG(_(e_dictrange));</a>
<a name="ln2115">          }</a>
<a name="ln2116">          tv_clear(&amp;var1);</a>
<a name="ln2117">          return NULL;</a>
<a name="ln2118">        }</a>
<a name="ln2119">        if (rettv != NULL &amp;&amp; (rettv-&gt;v_type != VAR_LIST</a>
<a name="ln2120">                              || rettv-&gt;vval.v_list == NULL)) {</a>
<a name="ln2121">          if (!quiet) {</a>
<a name="ln2122">            EMSG(_(&quot;E709: [:] requires a List value&quot;));</a>
<a name="ln2123">          }</a>
<a name="ln2124">          tv_clear(&amp;var1);</a>
<a name="ln2125">          return NULL;</a>
<a name="ln2126">        }</a>
<a name="ln2127">        p = skipwhite(p + 1);</a>
<a name="ln2128">        if (*p == ']') {</a>
<a name="ln2129">          lp-&gt;ll_empty2 = true;</a>
<a name="ln2130">        } else {</a>
<a name="ln2131">          lp-&gt;ll_empty2 = false;</a>
<a name="ln2132">          if (eval1(&amp;p, &amp;var2, true) == FAIL) {  // Recursive!</a>
<a name="ln2133">            tv_clear(&amp;var1);</a>
<a name="ln2134">            return NULL;</a>
<a name="ln2135">          }</a>
<a name="ln2136">          if (!tv_check_str(&amp;var2)) {</a>
<a name="ln2137">            // Not a number or string.</a>
<a name="ln2138">            tv_clear(&amp;var1);</a>
<a name="ln2139">            tv_clear(&amp;var2);</a>
<a name="ln2140">            return NULL;</a>
<a name="ln2141">          }</a>
<a name="ln2142">        }</a>
<a name="ln2143">        lp-&gt;ll_range = true;</a>
<a name="ln2144">      } else {</a>
<a name="ln2145">        lp-&gt;ll_range = false;</a>
<a name="ln2146">      }</a>
<a name="ln2147"> </a>
<a name="ln2148">      if (*p != ']') {</a>
<a name="ln2149">        if (!quiet) {</a>
<a name="ln2150">          EMSG(_(e_missbrac));</a>
<a name="ln2151">        }</a>
<a name="ln2152">        tv_clear(&amp;var1);</a>
<a name="ln2153">        tv_clear(&amp;var2);</a>
<a name="ln2154">        return NULL;</a>
<a name="ln2155">      }</a>
<a name="ln2156"> </a>
<a name="ln2157">      // Skip to past ']'.</a>
<a name="ln2158">      p++;</a>
<a name="ln2159">    }</a>
<a name="ln2160"> </a>
<a name="ln2161">    if (lp-&gt;ll_tv-&gt;v_type == VAR_DICT) {</a>
<a name="ln2162">      if (len == -1) {</a>
<a name="ln2163">        // &quot;[key]&quot;: get key from &quot;var1&quot;</a>
<a name="ln2164">        key = (char_u *)tv_get_string(&amp;var1);  // is number or string</a>
<a name="ln2165">      }</a>
<a name="ln2166">      lp-&gt;ll_list = NULL;</a>
<a name="ln2167">      lp-&gt;ll_dict = lp-&gt;ll_tv-&gt;vval.v_dict;</a>
<a name="ln2168">      lp-&gt;ll_di = tv_dict_find(lp-&gt;ll_dict, (const char *)key, len);</a>
<a name="ln2169"> </a>
<a name="ln2170">      /* When assigning to a scope dictionary check that a function and</a>
<a name="ln2171">       * variable name is valid (only variable name unless it is l: or</a>
<a name="ln2172">       * g: dictionary). Disallow overwriting a builtin function. */</a>
<a name="ln2173">      if (rettv != NULL &amp;&amp; lp-&gt;ll_dict-&gt;dv_scope != 0) {</a>
<a name="ln2174">        int prevval;</a>
<a name="ln2175">        int wrong;</a>
<a name="ln2176"> </a>
<a name="ln2177">        if (len != -1) {</a>
<a name="ln2178">          prevval = key[len];</a>
<a name="ln2179">          key[len] = NUL;</a>
<a name="ln2180">        } else {</a>
<a name="ln2181">          prevval = 0;  // Avoid compiler warning.</a>
<a name="ln2182">        }</a>
<a name="ln2183">        wrong = ((lp-&gt;ll_dict-&gt;dv_scope == VAR_DEF_SCOPE</a>
<a name="ln2184">                  &amp;&amp; tv_is_func(*rettv)</a>
<a name="ln2185">                  &amp;&amp; !var_check_func_name((const char *)key, lp-&gt;ll_di == NULL))</a>
<a name="ln2186">                 || !valid_varname((const char *)key));</a>
<a name="ln2187">        if (len != -1) {</a>
<a name="ln2188">          key[len] = prevval;</a>
<a name="ln2189">        }</a>
<a name="ln2190">        if (wrong) {</a>
<a name="ln2191">          return NULL;</a>
<a name="ln2192">        }</a>
<a name="ln2193">      }</a>
<a name="ln2194"> </a>
<a name="ln2195">      if (lp-&gt;ll_di != NULL &amp;&amp; tv_is_luafunc(&amp;lp-&gt;ll_di-&gt;di_tv)</a>
<a name="ln2196">          &amp;&amp; len == -1 &amp;&amp; rettv == NULL) {</a>
<a name="ln2197">        tv_clear(&amp;var1);</a>
<a name="ln2198">        EMSG2(e_illvar, &quot;v:['lua']&quot;);</a>
<a name="ln2199">        return NULL;</a>
<a name="ln2200">      }</a>
<a name="ln2201"> </a>
<a name="ln2202">      if (lp-&gt;ll_di == NULL) {</a>
<a name="ln2203">        // Can't add &quot;v:&quot; or &quot;a:&quot; variable.</a>
<a name="ln2204">        if (lp-&gt;ll_dict == &amp;vimvardict</a>
<a name="ln2205">            || &amp;lp-&gt;ll_dict-&gt;dv_hashtab == get_funccal_args_ht()) {</a>
<a name="ln2206">          EMSG2(_(e_illvar), name);</a>
<a name="ln2207">          tv_clear(&amp;var1);</a>
<a name="ln2208">          return NULL;</a>
<a name="ln2209">        }</a>
<a name="ln2210"> </a>
<a name="ln2211">        // Key does not exist in dict: may need to add it.</a>
<a name="ln2212">        if (*p == '[' || *p == '.' || unlet) {</a>
<a name="ln2213">          if (!quiet) {</a>
<a name="ln2214">            emsgf(_(e_dictkey), key);</a>
<a name="ln2215">          }</a>
<a name="ln2216">          tv_clear(&amp;var1);</a>
<a name="ln2217">          return NULL;</a>
<a name="ln2218">        }</a>
<a name="ln2219">        if (len == -1) {</a>
<a name="ln2220">          lp-&gt;ll_newkey = vim_strsave(key);</a>
<a name="ln2221">        } else {</a>
<a name="ln2222">          lp-&gt;ll_newkey = vim_strnsave(key, len);</a>
<a name="ln2223">        }</a>
<a name="ln2224">        tv_clear(&amp;var1);</a>
<a name="ln2225">        break;</a>
<a name="ln2226">      // existing variable, need to check if it can be changed</a>
<a name="ln2227">      } else if (!(flags &amp; GLV_READ_ONLY) &amp;&amp; var_check_ro(lp-&gt;ll_di-&gt;di_flags,</a>
<a name="ln2228">                                                          (const char *)name,</a>
<a name="ln2229">                                                          (size_t)(p - name))) {</a>
<a name="ln2230">        tv_clear(&amp;var1);</a>
<a name="ln2231">        return NULL;</a>
<a name="ln2232">      }</a>
<a name="ln2233"> </a>
<a name="ln2234">      tv_clear(&amp;var1);</a>
<a name="ln2235">      lp-&gt;ll_tv = &amp;lp-&gt;ll_di-&gt;di_tv;</a>
<a name="ln2236">    } else {</a>
<a name="ln2237">      // Get the number and item for the only or first index of the List.</a>
<a name="ln2238">      if (empty1) {</a>
<a name="ln2239">        lp-&gt;ll_n1 = 0;</a>
<a name="ln2240">      } else {</a>
<a name="ln2241">        // Is number or string.</a>
<a name="ln2242">        lp-&gt;ll_n1 = (long)tv_get_number(&amp;var1);</a>
<a name="ln2243">      }</a>
<a name="ln2244">      tv_clear(&amp;var1);</a>
<a name="ln2245"> </a>
<a name="ln2246">      lp-&gt;ll_dict = NULL;</a>
<a name="ln2247">      lp-&gt;ll_list = lp-&gt;ll_tv-&gt;vval.v_list;</a>
<a name="ln2248">      lp-&gt;ll_li = tv_list_find(lp-&gt;ll_list, lp-&gt;ll_n1);</a>
<a name="ln2249">      if (lp-&gt;ll_li == NULL) {</a>
<a name="ln2250">        if (lp-&gt;ll_n1 &lt; 0) {</a>
<a name="ln2251">          lp-&gt;ll_n1 = 0;</a>
<a name="ln2252">          lp-&gt;ll_li = tv_list_find(lp-&gt;ll_list, lp-&gt;ll_n1);</a>
<a name="ln2253">        }</a>
<a name="ln2254">      }</a>
<a name="ln2255">      if (lp-&gt;ll_li == NULL) {</a>
<a name="ln2256">        tv_clear(&amp;var2);</a>
<a name="ln2257">        if (!quiet) {</a>
<a name="ln2258">          EMSGN(_(e_listidx), lp-&gt;ll_n1);</a>
<a name="ln2259">        }</a>
<a name="ln2260">        return NULL;</a>
<a name="ln2261">      }</a>
<a name="ln2262"> </a>
<a name="ln2263">      // May need to find the item or absolute index for the second</a>
<a name="ln2264">      // index of a range.</a>
<a name="ln2265">      // When no index given: &quot;lp-&gt;ll_empty2&quot; is true.</a>
<a name="ln2266">      // Otherwise &quot;lp-&gt;ll_n2&quot; is set to the second index.</a>
<a name="ln2267">      if (lp-&gt;ll_range &amp;&amp; !lp-&gt;ll_empty2) {</a>
<a name="ln2268">        lp-&gt;ll_n2 = (long)tv_get_number(&amp;var2);  // Is number or string.</a>
<a name="ln2269">        tv_clear(&amp;var2);</a>
<a name="ln2270">        if (lp-&gt;ll_n2 &lt; 0) {</a>
<a name="ln2271">          ni = tv_list_find(lp-&gt;ll_list, lp-&gt;ll_n2);</a>
<a name="ln2272">          if (ni == NULL) {</a>
<a name="ln2273">            if (!quiet)</a>
<a name="ln2274">              EMSGN(_(e_listidx), lp-&gt;ll_n2);</a>
<a name="ln2275">            return NULL;</a>
<a name="ln2276">          }</a>
<a name="ln2277">          lp-&gt;ll_n2 = tv_list_idx_of_item(lp-&gt;ll_list, ni);</a>
<a name="ln2278">        }</a>
<a name="ln2279"> </a>
<a name="ln2280">        // Check that lp-&gt;ll_n2 isn't before lp-&gt;ll_n1.</a>
<a name="ln2281">        if (lp-&gt;ll_n1 &lt; 0) {</a>
<a name="ln2282">          lp-&gt;ll_n1 = tv_list_idx_of_item(lp-&gt;ll_list, lp-&gt;ll_li);</a>
<a name="ln2283">        }</a>
<a name="ln2284">        if (lp-&gt;ll_n2 &lt; lp-&gt;ll_n1) {</a>
<a name="ln2285">          if (!quiet) {</a>
<a name="ln2286">            EMSGN(_(e_listidx), lp-&gt;ll_n2);</a>
<a name="ln2287">          }</a>
<a name="ln2288">          return NULL;</a>
<a name="ln2289">        }</a>
<a name="ln2290">      }</a>
<a name="ln2291"> </a>
<a name="ln2292">      lp-&gt;ll_tv = TV_LIST_ITEM_TV(lp-&gt;ll_li);</a>
<a name="ln2293">    }</a>
<a name="ln2294">  }</a>
<a name="ln2295"> </a>
<a name="ln2296">  tv_clear(&amp;var1);</a>
<a name="ln2297">  return p;</a>
<a name="ln2298">}</a>
<a name="ln2299"> </a>
<a name="ln2300">// TODO(ZyX-I): move to eval/executor</a>
<a name="ln2301"> </a>
<a name="ln2302">/*</a>
<a name="ln2303"> * Clear lval &quot;lp&quot; that was filled by get_lval().</a>
<a name="ln2304"> */</a>
<a name="ln2305">void clear_lval(lval_T *lp)</a>
<a name="ln2306">{</a>
<a name="ln2307">  xfree(lp-&gt;ll_exp_name);</a>
<a name="ln2308">  xfree(lp-&gt;ll_newkey);</a>
<a name="ln2309">}</a>
<a name="ln2310"> </a>
<a name="ln2311">// TODO(ZyX-I): move to eval/executor</a>
<a name="ln2312"> </a>
<a name="ln2313">/*</a>
<a name="ln2314"> * Set a variable that was parsed by get_lval() to &quot;rettv&quot;.</a>
<a name="ln2315"> * &quot;endp&quot; points to just after the parsed name.</a>
<a name="ln2316"> * &quot;op&quot; is NULL, &quot;+&quot; for &quot;+=&quot;, &quot;-&quot; for &quot;-=&quot;, &quot;*&quot; for &quot;*=&quot;, &quot;/&quot; for &quot;/=&quot;,</a>
<a name="ln2317"> * &quot;%&quot; for &quot;%=&quot;, &quot;.&quot; for &quot;.=&quot; or &quot;=&quot; for &quot;=&quot;.</a>
<a name="ln2318"> */</a>
<a name="ln2319">static void set_var_lval(lval_T *lp, char_u *endp, typval_T *rettv,</a>
<a name="ln2320">                         int copy, const bool is_const, const char *op)</a>
<a name="ln2321">{</a>
<a name="ln2322">  int cc;</a>
<a name="ln2323">  listitem_T  *ri;</a>
<a name="ln2324">  dictitem_T  *di;</a>
<a name="ln2325"> </a>
<a name="ln2326">  if (lp-&gt;ll_tv == NULL) {</a>
<a name="ln2327">    cc = *endp;</a>
<a name="ln2328">    *endp = NUL;</a>
<a name="ln2329">    if (op != NULL &amp;&amp; *op != '=') {</a>
<a name="ln2330">      typval_T tv;</a>
<a name="ln2331"> </a>
<a name="ln2332">      if (is_const) {</a>
<a name="ln2333">        EMSG(_(e_cannot_mod));</a>
<a name="ln2334">        *endp = cc;</a>
<a name="ln2335">        return;</a>
<a name="ln2336">      }</a>
<a name="ln2337"> </a>
<a name="ln2338">      // handle +=, -=, *=, /=, %= and .=</a>
<a name="ln2339">      di = NULL;</a>
<a name="ln2340">      if (get_var_tv((const char *)lp-&gt;ll_name, (int)STRLEN(lp-&gt;ll_name),</a>
<a name="ln2341">                     &amp;tv, &amp;di, true, false) == OK) {</a>
<a name="ln2342">        if ((di == NULL</a>
<a name="ln2343">             || (!var_check_ro(di-&gt;di_flags, lp-&gt;ll_name, TV_CSTRING)</a>
<a name="ln2344">                 &amp;&amp; !tv_check_lock(&amp;di-&gt;di_tv, lp-&gt;ll_name, TV_CSTRING)))</a>
<a name="ln2345">            &amp;&amp; eexe_mod_op(&amp;tv, rettv, op) == OK) {</a>
<a name="ln2346">          set_var(lp-&gt;ll_name, lp-&gt;ll_name_len, &amp;tv, false);</a>
<a name="ln2347">        }</a>
<a name="ln2348">        tv_clear(&amp;tv);</a>
<a name="ln2349">      }</a>
<a name="ln2350">    } else {</a>
<a name="ln2351">      set_var_const(lp-&gt;ll_name, lp-&gt;ll_name_len, rettv, copy, is_const);</a>
<a name="ln2352">    }</a>
<a name="ln2353">    *endp = cc;</a>
<a name="ln2354">  } else if (var_check_lock(lp-&gt;ll_newkey == NULL</a>
<a name="ln2355">                            ? lp-&gt;ll_tv-&gt;v_lock</a>
<a name="ln2356">                            : lp-&gt;ll_tv-&gt;vval.v_dict-&gt;dv_lock,</a>
<a name="ln2357">                            lp-&gt;ll_name, TV_CSTRING)) {</a>
<a name="ln2358">  } else if (lp-&gt;ll_range) {</a>
<a name="ln2359">    listitem_T *ll_li = lp-&gt;ll_li;</a>
<a name="ln2360">    int ll_n1 = lp-&gt;ll_n1;</a>
<a name="ln2361"> </a>
<a name="ln2362">    if (is_const) {</a>
<a name="ln2363">      EMSG(_(&quot;E996: Cannot lock a range&quot;));</a>
<a name="ln2364">      return;</a>
<a name="ln2365">    }</a>
<a name="ln2366"> </a>
<a name="ln2367">    // Check whether any of the list items is locked</a>
<a name="ln2368">    for (ri = tv_list_first(rettv-&gt;vval.v_list);</a>
<a name="ln2369">         ri != NULL &amp;&amp; ll_li != NULL; ) {</a>
<a name="ln2370">      if (var_check_lock(TV_LIST_ITEM_TV(ll_li)-&gt;v_lock, lp-&gt;ll_name,</a>
<a name="ln2371">                         TV_CSTRING)) {</a>
<a name="ln2372">        return;</a>
<a name="ln2373">      }</a>
<a name="ln2374">      ri = TV_LIST_ITEM_NEXT(rettv-&gt;vval.v_list, ri);</a>
<a name="ln2375">      if (ri == NULL || (!lp-&gt;ll_empty2 &amp;&amp; lp-&gt;ll_n2 == ll_n1)) {</a>
<a name="ln2376">        break;</a>
<a name="ln2377">      }</a>
<a name="ln2378">      ll_li = TV_LIST_ITEM_NEXT(lp-&gt;ll_list, ll_li);</a>
<a name="ln2379">      ll_n1++;</a>
<a name="ln2380">    }</a>
<a name="ln2381"> </a>
<a name="ln2382">    /*</a>
<a name="ln2383">     * Assign the List values to the list items.</a>
<a name="ln2384">     */</a>
<a name="ln2385">    for (ri = tv_list_first(rettv-&gt;vval.v_list); ri != NULL; ) {</a>
<a name="ln2386">      if (op != NULL &amp;&amp; *op != '=') {</a>
<a name="ln2387">        eexe_mod_op(TV_LIST_ITEM_TV(lp-&gt;ll_li), TV_LIST_ITEM_TV(ri), op);</a>
<a name="ln2388">      } else {</a>
<a name="ln2389">        tv_clear(TV_LIST_ITEM_TV(lp-&gt;ll_li));</a>
<a name="ln2390">        tv_copy(TV_LIST_ITEM_TV(ri), TV_LIST_ITEM_TV(lp-&gt;ll_li));</a>
<a name="ln2391">      }</a>
<a name="ln2392">      ri = TV_LIST_ITEM_NEXT(rettv-&gt;vval.v_list, ri);</a>
<a name="ln2393">      if (ri == NULL || (!lp-&gt;ll_empty2 &amp;&amp; lp-&gt;ll_n2 == lp-&gt;ll_n1)) {</a>
<a name="ln2394">        break;</a>
<a name="ln2395">      }</a>
<a name="ln2396">      assert(lp-&gt;ll_li != NULL);</a>
<a name="ln2397">      if (TV_LIST_ITEM_NEXT(lp-&gt;ll_list, lp-&gt;ll_li) == NULL) {</a>
<a name="ln2398">        // Need to add an empty item.</a>
<a name="ln2399">        tv_list_append_number(lp-&gt;ll_list, 0);</a>
<a name="ln2400">        // ll_li may have become invalid after append, don’t use it.</a>
<a name="ln2401">        lp-&gt;ll_li = tv_list_last(lp-&gt;ll_list);  // Valid again.</a>
<a name="ln2402">      } else {</a>
<a name="ln2403">        lp-&gt;ll_li = TV_LIST_ITEM_NEXT(lp-&gt;ll_list, lp-&gt;ll_li);</a>
<a name="ln2404">      }</a>
<a name="ln2405">      lp-&gt;ll_n1++;</a>
<a name="ln2406">    }</a>
<a name="ln2407">    if (ri != NULL) {</a>
<a name="ln2408">      EMSG(_(&quot;E710: List value has more items than target&quot;));</a>
<a name="ln2409">    } else if (lp-&gt;ll_empty2</a>
<a name="ln2410">               ? (lp-&gt;ll_li != NULL</a>
<a name="ln2411">                  &amp;&amp; TV_LIST_ITEM_NEXT(lp-&gt;ll_list, lp-&gt;ll_li) != NULL)</a>
<a name="ln2412">               : lp-&gt;ll_n1 != lp-&gt;ll_n2) {</a>
<a name="ln2413">      EMSG(_(&quot;E711: List value has not enough items&quot;));</a>
<a name="ln2414">    }</a>
<a name="ln2415">  } else {</a>
<a name="ln2416">    typval_T oldtv = TV_INITIAL_VALUE;</a>
<a name="ln2417">    dict_T *dict = lp-&gt;ll_dict;</a>
<a name="ln2418">    bool watched = tv_dict_is_watched(dict);</a>
<a name="ln2419"> </a>
<a name="ln2420">    if (is_const) {</a>
<a name="ln2421">      EMSG(_(&quot;E996: Cannot lock a list or dict&quot;));</a>
<a name="ln2422">      return;</a>
<a name="ln2423">    }</a>
<a name="ln2424"> </a>
<a name="ln2425">    // Assign to a List or Dictionary item.</a>
<a name="ln2426">    if (lp-&gt;ll_newkey != NULL) {</a>
<a name="ln2427">      if (op != NULL &amp;&amp; *op != '=') {</a>
<a name="ln2428">        EMSG2(_(e_letwrong), op);</a>
<a name="ln2429">        return;</a>
<a name="ln2430">      }</a>
<a name="ln2431"> </a>
<a name="ln2432">      // Need to add an item to the Dictionary.</a>
<a name="ln2433">      di = tv_dict_item_alloc((const char *)lp-&gt;ll_newkey);</a>
<a name="ln2434">      if (tv_dict_add(lp-&gt;ll_tv-&gt;vval.v_dict, di) == FAIL) {</a>
<a name="ln2435">        xfree(di);</a>
<a name="ln2436">        return;</a>
<a name="ln2437">      }</a>
<a name="ln2438">      lp-&gt;ll_tv = &amp;di-&gt;di_tv;</a>
<a name="ln2439">    } else {</a>
<a name="ln2440">      if (watched) {</a>
<a name="ln2441">        tv_copy(lp-&gt;ll_tv, &amp;oldtv);</a>
<a name="ln2442">      }</a>
<a name="ln2443"> </a>
<a name="ln2444">      if (op != NULL &amp;&amp; *op != '=') {</a>
<a name="ln2445">        eexe_mod_op(lp-&gt;ll_tv, rettv, op);</a>
<a name="ln2446">        goto notify;</a>
<a name="ln2447">      } else {</a>
<a name="ln2448">        tv_clear(lp-&gt;ll_tv);</a>
<a name="ln2449">      }</a>
<a name="ln2450">    }</a>
<a name="ln2451"> </a>
<a name="ln2452">    // Assign the value to the variable or list item.</a>
<a name="ln2453">    if (copy) {</a>
<a name="ln2454">      tv_copy(rettv, lp-&gt;ll_tv);</a>
<a name="ln2455">    } else {</a>
<a name="ln2456">      *lp-&gt;ll_tv = *rettv;</a>
<a name="ln2457">      lp-&gt;ll_tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2458">      tv_init(rettv);</a>
<a name="ln2459">    }</a>
<a name="ln2460"> </a>
<a name="ln2461">notify:</a>
<a name="ln2462">    if (watched) {</a>
<a name="ln2463">      if (oldtv.v_type == VAR_UNKNOWN) {</a>
<a name="ln2464">        assert(lp-&gt;ll_newkey != NULL);</a>
<a name="ln2465">        tv_dict_watcher_notify(dict, (char *)lp-&gt;ll_newkey, lp-&gt;ll_tv, NULL);</a>
<a name="ln2466">      } else {</a>
<a name="ln2467">        dictitem_T *di_ = lp-&gt;ll_di;</a>
<a name="ln2468">        assert(di_-&gt;di_key != NULL);</a>
<a name="ln2469">        tv_dict_watcher_notify(dict, (char *)di_-&gt;di_key, lp-&gt;ll_tv, &amp;oldtv);</a>
<a name="ln2470">        tv_clear(&amp;oldtv);</a>
<a name="ln2471">      }</a>
<a name="ln2472">    }</a>
<a name="ln2473">  }</a>
<a name="ln2474">}</a>
<a name="ln2475"> </a>
<a name="ln2476">// TODO(ZyX-I): move to eval/ex_cmds</a>
<a name="ln2477"> </a>
<a name="ln2478">/*</a>
<a name="ln2479"> * Evaluate the expression used in a &quot;:for var in expr&quot; command.</a>
<a name="ln2480"> * &quot;arg&quot; points to &quot;var&quot;.</a>
<a name="ln2481"> * Set &quot;*errp&quot; to TRUE for an error, FALSE otherwise;</a>
<a name="ln2482"> * Return a pointer that holds the info.  Null when there is an error.</a>
<a name="ln2483"> */</a>
<a name="ln2484">void *eval_for_line(const char_u *arg, bool *errp, char_u **nextcmdp, int skip)</a>
<a name="ln2485">{</a>
<a name="ln2486">  forinfo_T   *fi = xcalloc(1, sizeof(forinfo_T));</a>
<a name="ln2487">  const char_u *expr;</a>
<a name="ln2488">  typval_T tv;</a>
<a name="ln2489">  list_T      *l;</a>
<a name="ln2490"> </a>
<a name="ln2491">  *errp = true;  // Default: there is an error.</a>
<a name="ln2492"> </a>
<a name="ln2493">  expr = skip_var_list(arg, &amp;fi-&gt;fi_varcount, &amp;fi-&gt;fi_semicolon);</a>
<a name="ln2494">  if (expr == NULL)</a>
<a name="ln2495">    return fi;</a>
<a name="ln2496"> </a>
<a name="ln2497">  expr = skipwhite(expr);</a>
<a name="ln2498">  if (expr[0] != 'i' || expr[1] != 'n' || !ascii_iswhite(expr[2])) {</a>
<a name="ln2499">    EMSG(_(&quot;E690: Missing \&quot;in\&quot; after :for&quot;));</a>
<a name="ln2500">    return fi;</a>
<a name="ln2501">  }</a>
<a name="ln2502"> </a>
<a name="ln2503">  if (skip)</a>
<a name="ln2504">    ++emsg_skip;</a>
<a name="ln2505">  if (eval0(skipwhite(expr + 2), &amp;tv, nextcmdp, !skip) == OK) {</a>
<a name="ln2506">    *errp = false;</a>
<a name="ln2507">    if (!skip) {</a>
<a name="ln2508">      l = tv.vval.v_list;</a>
<a name="ln2509">      if (tv.v_type != VAR_LIST) {</a>
<a name="ln2510">        EMSG(_(e_listreq));</a>
<a name="ln2511">        tv_clear(&amp;tv);</a>
<a name="ln2512">      } else if (l == NULL) {</a>
<a name="ln2513">        // a null list is like an empty list: do nothing</a>
<a name="ln2514">        tv_clear(&amp;tv);</a>
<a name="ln2515">      } else {</a>
<a name="ln2516">        /* No need to increment the refcount, it's already set for the</a>
<a name="ln2517">         * list being used in &quot;tv&quot;. */</a>
<a name="ln2518">        fi-&gt;fi_list = l;</a>
<a name="ln2519">        tv_list_watch_add(l, &amp;fi-&gt;fi_lw);</a>
<a name="ln2520">        fi-&gt;fi_lw.lw_item = tv_list_first(l);</a>
<a name="ln2521">      }</a>
<a name="ln2522">    }</a>
<a name="ln2523">  }</a>
<a name="ln2524">  if (skip)</a>
<a name="ln2525">    --emsg_skip;</a>
<a name="ln2526"> </a>
<a name="ln2527">  return fi;</a>
<a name="ln2528">}</a>
<a name="ln2529"> </a>
<a name="ln2530">// TODO(ZyX-I): move to eval/ex_cmds</a>
<a name="ln2531"> </a>
<a name="ln2532">/*</a>
<a name="ln2533"> * Use the first item in a &quot;:for&quot; list.  Advance to the next.</a>
<a name="ln2534"> * Assign the values to the variable (list).  &quot;arg&quot; points to the first one.</a>
<a name="ln2535"> * Return TRUE when a valid item was found, FALSE when at end of list or</a>
<a name="ln2536"> * something wrong.</a>
<a name="ln2537"> */</a>
<a name="ln2538">bool next_for_item(void *fi_void, char_u *arg)</a>
<a name="ln2539">{</a>
<a name="ln2540">  forinfo_T *fi = (forinfo_T *)fi_void;</a>
<a name="ln2541"> </a>
<a name="ln2542">  listitem_T *item = fi-&gt;fi_lw.lw_item;</a>
<a name="ln2543">  if (item == NULL) {</a>
<a name="ln2544">    return false;</a>
<a name="ln2545">  } else {</a>
<a name="ln2546">    fi-&gt;fi_lw.lw_item = TV_LIST_ITEM_NEXT(fi-&gt;fi_list, item);</a>
<a name="ln2547">    return (ex_let_vars(arg, TV_LIST_ITEM_TV(item), true,</a>
<a name="ln2548">                        fi-&gt;fi_semicolon, fi-&gt;fi_varcount, false, NULL) == OK);</a>
<a name="ln2549">  }</a>
<a name="ln2550">}</a>
<a name="ln2551"> </a>
<a name="ln2552">// TODO(ZyX-I): move to eval/ex_cmds</a>
<a name="ln2553"> </a>
<a name="ln2554">/*</a>
<a name="ln2555"> * Free the structure used to store info used by &quot;:for&quot;.</a>
<a name="ln2556"> */</a>
<a name="ln2557">void free_for_info(void *fi_void)</a>
<a name="ln2558">{</a>
<a name="ln2559">  forinfo_T    *fi = (forinfo_T *)fi_void;</a>
<a name="ln2560"> </a>
<a name="ln2561">  if (fi != NULL &amp;&amp; fi-&gt;fi_list != NULL) {</a>
<a name="ln2562">    tv_list_watch_remove(fi-&gt;fi_list, &amp;fi-&gt;fi_lw);</a>
<a name="ln2563">    tv_list_unref(fi-&gt;fi_list);</a>
<a name="ln2564">  }</a>
<a name="ln2565">  xfree(fi);</a>
<a name="ln2566">}</a>
<a name="ln2567"> </a>
<a name="ln2568"> </a>
<a name="ln2569">void set_context_for_expression(expand_T *xp, char_u *arg, cmdidx_T cmdidx)</a>
<a name="ln2570">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2571">{</a>
<a name="ln2572">  int got_eq = FALSE;</a>
<a name="ln2573">  int c;</a>
<a name="ln2574">  char_u      *p;</a>
<a name="ln2575"> </a>
<a name="ln2576">  if (cmdidx == CMD_let || cmdidx == CMD_const) {</a>
<a name="ln2577">    xp-&gt;xp_context = EXPAND_USER_VARS;</a>
<a name="ln2578">    if (vim_strpbrk(arg, (char_u *)&quot;\&quot;'+-*/%.=!?~|&amp;$([&lt;&gt;,#&quot;) == NULL) {</a>
<a name="ln2579">      // &quot;:let var1 var2 ...&quot;: find last space.</a>
<a name="ln2580">      for (p = arg + STRLEN(arg); p &gt;= arg; ) {</a>
<a name="ln2581">        xp-&gt;xp_pattern = p;</a>
<a name="ln2582">        MB_PTR_BACK(arg, p);</a>
<a name="ln2583">        if (ascii_iswhite(*p)) {</a>
<a name="ln2584">          break;</a>
<a name="ln2585">        }</a>
<a name="ln2586">      }</a>
<a name="ln2587">      return;</a>
<a name="ln2588">    }</a>
<a name="ln2589">  } else</a>
<a name="ln2590">    xp-&gt;xp_context = cmdidx == CMD_call ? EXPAND_FUNCTIONS</a>
<a name="ln2591">                     : EXPAND_EXPRESSION;</a>
<a name="ln2592">  while ((xp-&gt;xp_pattern = vim_strpbrk(arg,</a>
<a name="ln2593">              (char_u *)&quot;\&quot;'+-*/%.=!?~|&amp;$([&lt;&gt;,#&quot;)) != NULL) {</a>
<a name="ln2594">    c = *xp-&gt;xp_pattern;</a>
<a name="ln2595">    if (c == '&amp;') {</a>
<a name="ln2596">      c = xp-&gt;xp_pattern[1];</a>
<a name="ln2597">      if (c == '&amp;') {</a>
<a name="ln2598">        ++xp-&gt;xp_pattern;</a>
<a name="ln2599">        xp-&gt;xp_context = cmdidx != CMD_let || got_eq</a>
<a name="ln2600">                         ? EXPAND_EXPRESSION : EXPAND_NOTHING;</a>
<a name="ln2601">      } else if (c != ' ') {</a>
<a name="ln2602">        xp-&gt;xp_context = EXPAND_SETTINGS;</a>
<a name="ln2603">        if ((c == 'l' || c == 'g') &amp;&amp; xp-&gt;xp_pattern[2] == ':')</a>
<a name="ln2604">          xp-&gt;xp_pattern += 2;</a>
<a name="ln2605"> </a>
<a name="ln2606">      }</a>
<a name="ln2607">    } else if (c == '$') {</a>
<a name="ln2608">      // environment variable</a>
<a name="ln2609">      xp-&gt;xp_context = EXPAND_ENV_VARS;</a>
<a name="ln2610">    } else if (c == '=') {</a>
<a name="ln2611">      got_eq = TRUE;</a>
<a name="ln2612">      xp-&gt;xp_context = EXPAND_EXPRESSION;</a>
<a name="ln2613">    } else if (c == '#'</a>
<a name="ln2614">               &amp;&amp; xp-&gt;xp_context == EXPAND_EXPRESSION) {</a>
<a name="ln2615">      // Autoload function/variable contains '#'</a>
<a name="ln2616">      break;</a>
<a name="ln2617">    } else if ((c == '&lt;' || c == '#')</a>
<a name="ln2618">               &amp;&amp; xp-&gt;xp_context == EXPAND_FUNCTIONS</a>
<a name="ln2619">               &amp;&amp; vim_strchr(xp-&gt;xp_pattern, '(') == NULL) {</a>
<a name="ln2620">      // Function name can start with &quot;&lt;SNR&gt;&quot; and contain '#'.</a>
<a name="ln2621">      break;</a>
<a name="ln2622">    } else if (cmdidx != CMD_let || got_eq) {</a>
<a name="ln2623">      if (c == '&quot;') {               // string</a>
<a name="ln2624">        while ((c = *++xp-&gt;xp_pattern) != NUL &amp;&amp; c != '&quot;') {</a>
<a name="ln2625">          if (c == '\\' &amp;&amp; xp-&gt;xp_pattern[1] != NUL) {</a>
<a name="ln2626">            xp-&gt;xp_pattern++;</a>
<a name="ln2627">          }</a>
<a name="ln2628">        }</a>
<a name="ln2629">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln2630">      } else if (c == '\'') {     // literal string</a>
<a name="ln2631">        // Trick: '' is like stopping and starting a literal string.</a>
<a name="ln2632">        while ((c = *++xp-&gt;xp_pattern) != NUL &amp;&amp; c != '\'') {</a>
<a name="ln2633">        }</a>
<a name="ln2634">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln2635">      } else if (c == '|') {</a>
<a name="ln2636">        if (xp-&gt;xp_pattern[1] == '|') {</a>
<a name="ln2637">          ++xp-&gt;xp_pattern;</a>
<a name="ln2638">          xp-&gt;xp_context = EXPAND_EXPRESSION;</a>
<a name="ln2639">        } else</a>
<a name="ln2640">          xp-&gt;xp_context = EXPAND_COMMANDS;</a>
<a name="ln2641">      } else</a>
<a name="ln2642">        xp-&gt;xp_context = EXPAND_EXPRESSION;</a>
<a name="ln2643">    } else</a>
<a name="ln2644">      /* Doesn't look like something valid, expand as an expression</a>
<a name="ln2645">       * anyway. */</a>
<a name="ln2646">      xp-&gt;xp_context = EXPAND_EXPRESSION;</a>
<a name="ln2647">    arg = xp-&gt;xp_pattern;</a>
<a name="ln2648">    if (*arg != NUL) {</a>
<a name="ln2649">      while ((c = *++arg) != NUL &amp;&amp; (c == ' ' || c == '\t')) {</a>
<a name="ln2650">      }</a>
<a name="ln2651">    }</a>
<a name="ln2652">  }</a>
<a name="ln2653"> </a>
<a name="ln2654">  // &quot;:exe one two&quot; completes &quot;two&quot;</a>
<a name="ln2655">  if ((cmdidx == CMD_execute</a>
<a name="ln2656">       || cmdidx == CMD_echo</a>
<a name="ln2657">       || cmdidx == CMD_echon</a>
<a name="ln2658">       || cmdidx == CMD_echomsg)</a>
<a name="ln2659">      &amp;&amp; xp-&gt;xp_context == EXPAND_EXPRESSION) {</a>
<a name="ln2660">    for (;;) {</a>
<a name="ln2661">      char_u *const n = skiptowhite(arg);</a>
<a name="ln2662"> </a>
<a name="ln2663">      if (n == arg || ascii_iswhite_or_nul(*skipwhite(n))) {</a>
<a name="ln2664">        break;</a>
<a name="ln2665">      }</a>
<a name="ln2666">      arg = skipwhite(n);</a>
<a name="ln2667">    }</a>
<a name="ln2668">  }</a>
<a name="ln2669"> </a>
<a name="ln2670">  xp-&gt;xp_pattern = arg;</a>
<a name="ln2671">}</a>
<a name="ln2672"> </a>
<a name="ln2673">/// &quot;:unlet[!] var1 ... &quot; command.</a>
<a name="ln2674">void ex_unlet(exarg_T *eap)</a>
<a name="ln2675">{</a>
<a name="ln2676">  ex_unletlock(eap, eap-&gt;arg, 0, do_unlet_var);</a>
<a name="ln2677">}</a>
<a name="ln2678"> </a>
<a name="ln2679">// TODO(ZyX-I): move to eval/ex_cmds</a>
<a name="ln2680"> </a>
<a name="ln2681">/// &quot;:lockvar&quot; and &quot;:unlockvar&quot; commands</a>
<a name="ln2682">void ex_lockvar(exarg_T *eap)</a>
<a name="ln2683">{</a>
<a name="ln2684">  char_u *arg = eap-&gt;arg;</a>
<a name="ln2685">  int deep = 2;</a>
<a name="ln2686"> </a>
<a name="ln2687">  if (eap-&gt;forceit) {</a>
<a name="ln2688">    deep = -1;</a>
<a name="ln2689">  } else if (ascii_isdigit(*arg)) {</a>
<a name="ln2690">    deep = getdigits_int(&amp;arg, false, -1);</a>
<a name="ln2691">    arg = skipwhite(arg);</a>
<a name="ln2692">  }</a>
<a name="ln2693"> </a>
<a name="ln2694">  ex_unletlock(eap, arg, deep, do_lock_var);</a>
<a name="ln2695">}</a>
<a name="ln2696"> </a>
<a name="ln2697">// TODO(ZyX-I): move to eval/ex_cmds</a>
<a name="ln2698"> </a>
<a name="ln2699">/// Common parsing logic for :unlet, :lockvar and :unlockvar.</a>
<a name="ln2700">///</a>
<a name="ln2701">/// Invokes `callback` afterwards if successful and `eap-&gt;skip == false`.</a>
<a name="ln2702">///</a>
<a name="ln2703">/// @param[in]  eap  Ex command arguments for the command.</a>
<a name="ln2704">/// @param[in]  argstart  Start of the string argument for the command.</a>
<a name="ln2705">/// @param[in]  deep  Levels to (un)lock for :(un)lockvar, -1 to (un)lock</a>
<a name="ln2706">///                   everything.</a>
<a name="ln2707">/// @param[in]  callback  Appropriate handler for the command.</a>
<a name="ln2708">static void ex_unletlock(exarg_T *eap, char_u *argstart, int deep,</a>
<a name="ln2709">                         ex_unletlock_callback callback)</a>
<a name="ln2710">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2711">{</a>
<a name="ln2712">  char_u *arg = argstart;</a>
<a name="ln2713">  char_u *name_end;</a>
<a name="ln2714">  bool error = false;</a>
<a name="ln2715">  lval_T lv;</a>
<a name="ln2716"> </a>
<a name="ln2717">  do {</a>
<a name="ln2718">    if (*arg == '$') {</a>
<a name="ln2719">      lv.ll_name = (const char *)arg;</a>
<a name="ln2720">      lv.ll_tv = NULL;</a>
<a name="ln2721">      arg++;</a>
<a name="ln2722">      if (get_env_len((const char_u **)&amp;arg) == 0) {</a>
<a name="ln2723">        EMSG2(_(e_invarg2), arg - 1);</a>
<a name="ln2724">        return;</a>
<a name="ln2725">      }</a>
<a name="ln2726">      if (!error &amp;&amp; !eap-&gt;skip &amp;&amp; callback(&amp;lv, arg, eap, deep) == FAIL) {</a>
<a name="ln2727">        error = true;</a>
<a name="ln2728">      }</a>
<a name="ln2729">      name_end = arg;</a>
<a name="ln2730">    } else {</a>
<a name="ln2731">      // Parse the name and find the end.</a>
<a name="ln2732">      name_end = get_lval(arg, NULL, &amp;lv, true, eap-&gt;skip || error,</a>
<a name="ln2733">                          0, FNE_CHECK_START);</a>
<a name="ln2734">      if (lv.ll_name == NULL) {</a>
<a name="ln2735">        error = true;  // error, but continue parsing.</a>
<a name="ln2736">      }</a>
<a name="ln2737">      if (name_end == NULL</a>
<a name="ln2738">          || (!ascii_iswhite(*name_end) &amp;&amp; !ends_excmd(*name_end))) {</a>
<a name="ln2739">        if (name_end != NULL) {</a>
<a name="ln2740">          emsg_severe = true;</a>
<a name="ln2741">          EMSG(_(e_trailing));</a>
<a name="ln2742">        }</a>
<a name="ln2743">        if (!(eap-&gt;skip || error)) {</a>
<a name="ln2744">          clear_lval(&amp;lv);</a>
<a name="ln2745">        }</a>
<a name="ln2746">        break;</a>
<a name="ln2747">      }</a>
<a name="ln2748"> </a>
<a name="ln2749">      if (!error &amp;&amp; !eap-&gt;skip &amp;&amp; callback(&amp;lv, name_end, eap, deep) == FAIL) {</a>
<a name="ln2750">        error = true;</a>
<a name="ln2751">      }</a>
<a name="ln2752"> </a>
<a name="ln2753">      if (!eap-&gt;skip) {</a>
<a name="ln2754">        clear_lval(&amp;lv);</a>
<a name="ln2755">      }</a>
<a name="ln2756">    }</a>
<a name="ln2757">    arg = skipwhite(name_end);</a>
<a name="ln2758">  } while (!ends_excmd(*arg));</a>
<a name="ln2759"> </a>
<a name="ln2760">  eap-&gt;nextcmd = check_nextcmd(arg);</a>
<a name="ln2761">}</a>
<a name="ln2762"> </a>
<a name="ln2763">// TODO(ZyX-I): move to eval/ex_cmds</a>
<a name="ln2764"> </a>
<a name="ln2765">/// Unlet a variable indicated by `lp`.</a>
<a name="ln2766">///</a>
<a name="ln2767">/// @param[in]  lp  The lvalue.</a>
<a name="ln2768">/// @param[in]  name_end  End of the string argument for the command.</a>
<a name="ln2769">/// @param[in]  eap  Ex command arguments for :unlet.</a>
<a name="ln2770">/// @param[in]  deep  Unused.</a>
<a name="ln2771">///</a>
<a name="ln2772">/// @return OK on success, or FAIL on failure.</a>
<a name="ln2773">static int do_unlet_var(lval_T *lp, char_u *name_end, exarg_T *eap,</a>
<a name="ln2774">                        int deep FUNC_ATTR_UNUSED)</a>
<a name="ln2775">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2776">{</a>
<a name="ln2777">  int forceit = eap-&gt;forceit;</a>
<a name="ln2778">  int ret = OK;</a>
<a name="ln2779">  int cc;</a>
<a name="ln2780"> </a>
<a name="ln2781">  if (lp-&gt;ll_tv == NULL) {</a>
<a name="ln2782">    cc = *name_end;</a>
<a name="ln2783">    *name_end = NUL;</a>
<a name="ln2784"> </a>
<a name="ln2785">    // Environment variable, normal name or expanded name.</a>
<a name="ln2786">    if (*lp-&gt;ll_name == '$') {</a>
<a name="ln2787">      os_unsetenv(lp-&gt;ll_name + 1);</a>
<a name="ln2788">    } else if (do_unlet(lp-&gt;ll_name, lp-&gt;ll_name_len, forceit) == FAIL) {</a>
<a name="ln2789">      ret = FAIL;</a>
<a name="ln2790">    }</a>
<a name="ln2791">    *name_end = cc;</a>
<a name="ln2792">  } else if ((lp-&gt;ll_list != NULL</a>
<a name="ln2793">              // ll_list is not NULL when lvalue is not in a list, NULL lists</a>
<a name="ln2794">              // yield E689.</a>
<a name="ln2795">              &amp;&amp; var_check_lock(tv_list_locked(lp-&gt;ll_list),</a>
<a name="ln2796">                                lp-&gt;ll_name,</a>
<a name="ln2797">                                lp-&gt;ll_name_len))</a>
<a name="ln2798">             || (lp-&gt;ll_dict != NULL</a>
<a name="ln2799">                 &amp;&amp; var_check_lock(lp-&gt;ll_dict-&gt;dv_lock,</a>
<a name="ln2800">                                   lp-&gt;ll_name,</a>
<a name="ln2801">                                   lp-&gt;ll_name_len))) {</a>
<a name="ln2802">    return FAIL;</a>
<a name="ln2803">  } else if (lp-&gt;ll_range) {</a>
<a name="ln2804">    assert(lp-&gt;ll_list != NULL);</a>
<a name="ln2805">    // Delete a range of List items.</a>
<a name="ln2806">    listitem_T *const first_li = lp-&gt;ll_li;</a>
<a name="ln2807">    listitem_T *last_li = first_li;</a>
<a name="ln2808">    for (;;) {</a>
<a name="ln2809">      listitem_T *const li = TV_LIST_ITEM_NEXT(lp-&gt;ll_list, lp-&gt;ll_li);</a>
<a name="ln2810">      if (var_check_lock(TV_LIST_ITEM_TV(lp-&gt;ll_li)-&gt;v_lock,</a>
<a name="ln2811">                         lp-&gt;ll_name,</a>
<a name="ln2812">                         lp-&gt;ll_name_len)) {</a>
<a name="ln2813">        return false;</a>
<a name="ln2814">      }</a>
<a name="ln2815">      lp-&gt;ll_li = li;</a>
<a name="ln2816">      lp-&gt;ll_n1++;</a>
<a name="ln2817">      if (lp-&gt;ll_li == NULL || (!lp-&gt;ll_empty2 &amp;&amp; lp-&gt;ll_n2 &lt; lp-&gt;ll_n1)) {</a>
<a name="ln2818">        break;</a>
<a name="ln2819">      } else {</a>
<a name="ln2820">        last_li = lp-&gt;ll_li;</a>
<a name="ln2821">      }</a>
<a name="ln2822">    }</a>
<a name="ln2823">    tv_list_remove_items(lp-&gt;ll_list, first_li, last_li);</a>
<a name="ln2824">  } else {</a>
<a name="ln2825">    if (lp-&gt;ll_list != NULL) {</a>
<a name="ln2826">      // unlet a List item.</a>
<a name="ln2827">      tv_list_item_remove(lp-&gt;ll_list, lp-&gt;ll_li);</a>
<a name="ln2828">    } else {</a>
<a name="ln2829">      // unlet a Dictionary item.</a>
<a name="ln2830">      dict_T *d = lp-&gt;ll_dict;</a>
<a name="ln2831">      assert(d != NULL);</a>
<a name="ln2832">      dictitem_T *di = lp-&gt;ll_di;</a>
<a name="ln2833">      bool watched = tv_dict_is_watched(d);</a>
<a name="ln2834">      char *key = NULL;</a>
<a name="ln2835">      typval_T oldtv;</a>
<a name="ln2836"> </a>
<a name="ln2837">      if (watched) {</a>
<a name="ln2838">        tv_copy(&amp;di-&gt;di_tv, &amp;oldtv);</a>
<a name="ln2839">        // need to save key because dictitem_remove will free it</a>
<a name="ln2840">        key = xstrdup((char *)di-&gt;di_key);</a>
<a name="ln2841">      }</a>
<a name="ln2842"> </a>
<a name="ln2843">      tv_dict_item_remove(d, di);</a>
<a name="ln2844"> </a>
<a name="ln2845">      if (watched) {</a>
<a name="ln2846">        tv_dict_watcher_notify(d, key, NULL, &amp;oldtv);</a>
<a name="ln2847">        tv_clear(&amp;oldtv);</a>
<a name="ln2848">        xfree(key);</a>
<a name="ln2849">      }</a>
<a name="ln2850">    }</a>
<a name="ln2851">  }</a>
<a name="ln2852"> </a>
<a name="ln2853">  return ret;</a>
<a name="ln2854">}</a>
<a name="ln2855"> </a>
<a name="ln2856">// TODO(ZyX-I): move to eval/ex_cmds</a>
<a name="ln2857"> </a>
<a name="ln2858">/// unlet a variable</a>
<a name="ln2859">///</a>
<a name="ln2860">/// @param[in]  name  Variable name to unlet.</a>
<a name="ln2861">/// @param[in]  name_len  Variable name length.</a>
<a name="ln2862">/// @param[in]  forceit  If true, do not complain if variable doesn’t exist.</a>
<a name="ln2863">///</a>
<a name="ln2864">/// @return OK if it existed, FAIL otherwise.</a>
<a name="ln2865">int do_unlet(const char *const name, const size_t name_len, const bool forceit)</a>
<a name="ln2866">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2867">{</a>
<a name="ln2868">  const char *varname;</a>
<a name="ln2869">  dict_T *dict;</a>
<a name="ln2870">  hashtab_T *ht = find_var_ht_dict(name, name_len, &amp;varname, &amp;dict);</a>
<a name="ln2871"> </a>
<a name="ln2872">  if (ht != NULL &amp;&amp; *varname != NUL) {</a>
<a name="ln2873">    dict_T *d = get_current_funccal_dict(ht);</a>
<a name="ln2874">    if (d == NULL) {</a>
<a name="ln2875">      if (ht == &amp;globvarht) {</a>
<a name="ln2876">        d = &amp;globvardict;</a>
<a name="ln2877">      } else if (ht == &amp;compat_hashtab) {</a>
<a name="ln2878">          d = &amp;vimvardict;</a>
<a name="ln2879">      } else {</a>
<a name="ln2880">        dictitem_T *const di = find_var_in_ht(ht, *name, &quot;&quot;, 0, false);</a>
<a name="ln2881">        d = di-&gt;di_tv.vval.v_dict;</a>
<a name="ln2882">      }</a>
<a name="ln2883">      if (d == NULL) {</a>
<a name="ln2884">        internal_error(&quot;do_unlet()&quot;);</a>
<a name="ln2885">        return FAIL;</a>
<a name="ln2886">      }</a>
<a name="ln2887">    }</a>
<a name="ln2888"> </a>
<a name="ln2889">    hashitem_T *hi = hash_find(ht, (const char_u *)varname);</a>
<a name="ln2890">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln2891">      hi = find_hi_in_scoped_ht((const char *)name, &amp;ht);</a>
<a name="ln2892">    }</a>
<a name="ln2893">    if (hi != NULL &amp;&amp; !HASHITEM_EMPTY(hi)) {</a>
<a name="ln2894">      dictitem_T *const di = TV_DICT_HI2DI(hi);</a>
<a name="ln2895">      if (var_check_fixed(di-&gt;di_flags, (const char *)name, TV_CSTRING)</a>
<a name="ln2896">          || var_check_ro(di-&gt;di_flags, (const char *)name, TV_CSTRING)</a>
<a name="ln2897">          || var_check_lock(d-&gt;dv_lock, name, TV_CSTRING)) {</a>
<a name="ln2898">        return FAIL;</a>
<a name="ln2899">      }</a>
<a name="ln2900"> </a>
<a name="ln2901">      if (var_check_lock(d-&gt;dv_lock, name, TV_CSTRING)) {</a>
<a name="ln2902">        return FAIL;</a>
<a name="ln2903">      }</a>
<a name="ln2904"> </a>
<a name="ln2905">      typval_T oldtv;</a>
<a name="ln2906">      bool watched = tv_dict_is_watched(dict);</a>
<a name="ln2907"> </a>
<a name="ln2908">      if (watched) {</a>
<a name="ln2909">        tv_copy(&amp;di-&gt;di_tv, &amp;oldtv);</a>
<a name="ln2910">      }</a>
<a name="ln2911"> </a>
<a name="ln2912">      delete_var(ht, hi);</a>
<a name="ln2913"> </a>
<a name="ln2914">      if (watched) {</a>
<a name="ln2915">        tv_dict_watcher_notify(dict, varname, NULL, &amp;oldtv);</a>
<a name="ln2916">        tv_clear(&amp;oldtv);</a>
<a name="ln2917">      }</a>
<a name="ln2918">      return OK;</a>
<a name="ln2919">    }</a>
<a name="ln2920">  }</a>
<a name="ln2921">  if (forceit)</a>
<a name="ln2922">    return OK;</a>
<a name="ln2923">  EMSG2(_(&quot;E108: No such variable: \&quot;%s\&quot;&quot;), name);</a>
<a name="ln2924">  return FAIL;</a>
<a name="ln2925">}</a>
<a name="ln2926"> </a>
<a name="ln2927">// TODO(ZyX-I): move to eval/ex_cmds</a>
<a name="ln2928"> </a>
<a name="ln2929">/// Lock or unlock variable indicated by `lp`.</a>
<a name="ln2930">///</a>
<a name="ln2931">/// Locks if `eap-&gt;cmdidx == CMD_lockvar`, unlocks otherwise.</a>
<a name="ln2932">///</a>
<a name="ln2933">/// @param[in]  lp  The lvalue.</a>
<a name="ln2934">/// @param[in]  name_end  Unused.</a>
<a name="ln2935">/// @param[in]  eap  Ex command arguments for :(un)lockvar.</a>
<a name="ln2936">/// @param[in]  deep  Levels to (un)lock, -1 to (un)lock everything.</a>
<a name="ln2937">///</a>
<a name="ln2938">/// @return OK on success, or FAIL on failure.</a>
<a name="ln2939">static int do_lock_var(lval_T *lp, char_u *name_end FUNC_ATTR_UNUSED,</a>
<a name="ln2940">                       exarg_T *eap, int deep)</a>
<a name="ln2941">  FUNC_ATTR_NONNULL_ARG(1, 3)</a>
<a name="ln2942">{</a>
<a name="ln2943">  bool lock = eap-&gt;cmdidx == CMD_lockvar;</a>
<a name="ln2944">  int ret = OK;</a>
<a name="ln2945"> </a>
<a name="ln2946">  if (deep == 0) {  // Nothing to do.</a>
<a name="ln2947">    return OK;</a>
<a name="ln2948">  }</a>
<a name="ln2949"> </a>
<a name="ln2950">  if (lp-&gt;ll_tv == NULL) {</a>
<a name="ln2951">    if (*lp-&gt;ll_name == '$') {</a>
<a name="ln2952">      EMSG2(_(e_lock_unlock), lp-&gt;ll_name);</a>
<a name="ln2953">      ret = FAIL;</a>
<a name="ln2954">    } else {</a>
<a name="ln2955">      // Normal name or expanded name.</a>
<a name="ln2956">      dictitem_T *const di = find_var(</a>
<a name="ln2957">          (const char *)lp-&gt;ll_name, lp-&gt;ll_name_len, NULL,</a>
<a name="ln2958">          true);</a>
<a name="ln2959">      if (di == NULL) {</a>
<a name="ln2960">        ret = FAIL;</a>
<a name="ln2961">      } else if ((di-&gt;di_flags &amp; DI_FLAGS_FIX)</a>
<a name="ln2962">                 &amp;&amp; di-&gt;di_tv.v_type != VAR_DICT</a>
<a name="ln2963">                 &amp;&amp; di-&gt;di_tv.v_type != VAR_LIST) {</a>
<a name="ln2964">        // For historical reasons this error is not given for Lists and</a>
<a name="ln2965">        // Dictionaries. E.g. b: dictionary may be locked/unlocked.</a>
<a name="ln2966">        EMSG2(_(e_lock_unlock), lp-&gt;ll_name);</a>
<a name="ln2967">        ret = FAIL;</a>
<a name="ln2968">      } else {</a>
<a name="ln2969">        if (lock) {</a>
<a name="ln2970">          di-&gt;di_flags |= DI_FLAGS_LOCK;</a>
<a name="ln2971">        } else {</a>
<a name="ln2972">          di-&gt;di_flags &amp;= ~DI_FLAGS_LOCK;</a>
<a name="ln2973">        }</a>
<a name="ln2974">        tv_item_lock(&amp;di-&gt;di_tv, deep, lock);</a>
<a name="ln2975">      }</a>
<a name="ln2976">    }</a>
<a name="ln2977">  } else if (lp-&gt;ll_range) {</a>
<a name="ln2978">    listitem_T    *li = lp-&gt;ll_li;</a>
<a name="ln2979"> </a>
<a name="ln2980">    // (un)lock a range of List items.</a>
<a name="ln2981">    while (li != NULL &amp;&amp; (lp-&gt;ll_empty2 || lp-&gt;ll_n2 &gt;= lp-&gt;ll_n1)) {</a>
<a name="ln2982">      tv_item_lock(TV_LIST_ITEM_TV(li), deep, lock);</a>
<a name="ln2983">      li = TV_LIST_ITEM_NEXT(lp-&gt;ll_list, li);</a>
<a name="ln2984">      lp-&gt;ll_n1++;</a>
<a name="ln2985">    }</a>
<a name="ln2986">  } else if (lp-&gt;ll_list != NULL) {</a>
<a name="ln2987">    // (un)lock a List item.</a>
<a name="ln2988">    tv_item_lock(TV_LIST_ITEM_TV(lp-&gt;ll_li), deep, lock);</a>
<a name="ln2989">  } else {</a>
<a name="ln2990">    // (un)lock a Dictionary item.</a>
<a name="ln2991">    tv_item_lock(&amp;lp-&gt;ll_di-&gt;di_tv, deep, lock);</a>
<a name="ln2992">  }</a>
<a name="ln2993"> </a>
<a name="ln2994">  return ret;</a>
<a name="ln2995">}</a>
<a name="ln2996"> </a>
<a name="ln2997">/*</a>
<a name="ln2998"> * Delete all &quot;menutrans_&quot; variables.</a>
<a name="ln2999"> */</a>
<a name="ln3000">void del_menutrans_vars(void)</a>
<a name="ln3001">{</a>
<a name="ln3002">  hash_lock(&amp;globvarht);</a>
<a name="ln3003">  HASHTAB_ITER(&amp;globvarht, hi, {</a>
<a name="ln3004">    if (STRNCMP(hi-&gt;hi_key, &quot;menutrans_&quot;, 10) == 0) {</a>
<a name="ln3005">      delete_var(&amp;globvarht, hi);</a>
<a name="ln3006">    }</a>
<a name="ln3007">  });</a>
<a name="ln3008">  hash_unlock(&amp;globvarht);</a>
<a name="ln3009">}</a>
<a name="ln3010"> </a>
<a name="ln3011">/*</a>
<a name="ln3012"> * Local string buffer for the next two functions to store a variable name</a>
<a name="ln3013"> * with its prefix. Allocated in cat_prefix_varname(), freed later in</a>
<a name="ln3014"> * get_user_var_name().</a>
<a name="ln3015"> */</a>
<a name="ln3016"> </a>
<a name="ln3017"> </a>
<a name="ln3018">static char_u   *varnamebuf = NULL;</a>
<a name="ln3019">static size_t varnamebuflen = 0;</a>
<a name="ln3020"> </a>
<a name="ln3021">/*</a>
<a name="ln3022"> * Function to concatenate a prefix and a variable name.</a>
<a name="ln3023"> */</a>
<a name="ln3024">char_u *cat_prefix_varname(int prefix, const char_u *name)</a>
<a name="ln3025">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3026">{</a>
<a name="ln3027">  size_t len = STRLEN(name) + 3;</a>
<a name="ln3028"> </a>
<a name="ln3029">  if (len &gt; varnamebuflen) {</a>
<a name="ln3030">    xfree(varnamebuf);</a>
<a name="ln3031">    len += 10;                          // some additional space</a>
<a name="ln3032">    varnamebuf = xmalloc(len);</a>
<a name="ln3033">    varnamebuflen = len;</a>
<a name="ln3034">  }</a>
<a name="ln3035">  *varnamebuf = prefix;</a>
<a name="ln3036">  varnamebuf[1] = ':';</a>
<a name="ln3037">  STRCPY(varnamebuf + 2, name);</a>
<a name="ln3038">  return varnamebuf;</a>
<a name="ln3039">}</a>
<a name="ln3040"> </a>
<a name="ln3041">/*</a>
<a name="ln3042"> * Function given to ExpandGeneric() to obtain the list of user defined</a>
<a name="ln3043"> * (global/buffer/window/built-in) variable names.</a>
<a name="ln3044"> */</a>
<a name="ln3045">char_u *get_user_var_name(expand_T *xp, int idx)</a>
<a name="ln3046">{</a>
<a name="ln3047">  static size_t gdone;</a>
<a name="ln3048">  static size_t bdone;</a>
<a name="ln3049">  static size_t wdone;</a>
<a name="ln3050">  static size_t tdone;</a>
<a name="ln3051">  static size_t vidx;</a>
<a name="ln3052">  static hashitem_T   *hi;</a>
<a name="ln3053"> </a>
<a name="ln3054">  if (idx == 0) {</a>
<a name="ln3055">    gdone = bdone = wdone = vidx = 0;</a>
<a name="ln3056">    tdone = 0;</a>
<a name="ln3057">  }</a>
<a name="ln3058"> </a>
<a name="ln3059">  // Global variables</a>
<a name="ln3060">  if (gdone &lt; globvarht.ht_used) {</a>
<a name="ln3061">    if (gdone++ == 0)</a>
<a name="ln3062">      hi = globvarht.ht_array;</a>
<a name="ln3063">    else</a>
<a name="ln3064">      ++hi;</a>
<a name="ln3065">    while (HASHITEM_EMPTY(hi))</a>
<a name="ln3066">      ++hi;</a>
<a name="ln3067">    if (STRNCMP(&quot;g:&quot;, xp-&gt;xp_pattern, 2) == 0)</a>
<a name="ln3068">      return cat_prefix_varname('g', hi-&gt;hi_key);</a>
<a name="ln3069">    return hi-&gt;hi_key;</a>
<a name="ln3070">  }</a>
<a name="ln3071"> </a>
<a name="ln3072">  // b: variables</a>
<a name="ln3073">  // In cmdwin, the alternative buffer should be used.</a>
<a name="ln3074">  hashtab_T *ht = (cmdwin_type != 0 &amp;&amp; get_cmdline_type() == NUL)</a>
<a name="ln3075">    ? &amp;prevwin-&gt;w_buffer-&gt;b_vars-&gt;dv_hashtab</a>
<a name="ln3076">    : &amp;curbuf-&gt;b_vars-&gt;dv_hashtab;</a>
<a name="ln3077">  if (bdone &lt; ht-&gt;ht_used) {</a>
<a name="ln3078">    if (bdone++ == 0)</a>
<a name="ln3079">      hi = ht-&gt;ht_array;</a>
<a name="ln3080">    else</a>
<a name="ln3081">      ++hi;</a>
<a name="ln3082">    while (HASHITEM_EMPTY(hi))</a>
<a name="ln3083">      ++hi;</a>
<a name="ln3084">    return cat_prefix_varname('b', hi-&gt;hi_key);</a>
<a name="ln3085">  }</a>
<a name="ln3086"> </a>
<a name="ln3087">  // w: variables</a>
<a name="ln3088">  // In cmdwin, the alternative window should be used.</a>
<a name="ln3089">  ht = (cmdwin_type != 0 &amp;&amp; get_cmdline_type() == NUL)</a>
<a name="ln3090">    ? &amp;prevwin-&gt;w_vars-&gt;dv_hashtab</a>
<a name="ln3091">    : &amp;curwin-&gt;w_vars-&gt;dv_hashtab;</a>
<a name="ln3092">  if (wdone &lt; ht-&gt;ht_used) {</a>
<a name="ln3093">    if (wdone++ == 0)</a>
<a name="ln3094">      hi = ht-&gt;ht_array;</a>
<a name="ln3095">    else</a>
<a name="ln3096">      ++hi;</a>
<a name="ln3097">    while (HASHITEM_EMPTY(hi))</a>
<a name="ln3098">      ++hi;</a>
<a name="ln3099">    return cat_prefix_varname('w', hi-&gt;hi_key);</a>
<a name="ln3100">  }</a>
<a name="ln3101"> </a>
<a name="ln3102">  // t: variables</a>
<a name="ln3103">  ht = &amp;curtab-&gt;tp_vars-&gt;dv_hashtab;</a>
<a name="ln3104">  if (tdone &lt; ht-&gt;ht_used) {</a>
<a name="ln3105">    if (tdone++ == 0)</a>
<a name="ln3106">      hi = ht-&gt;ht_array;</a>
<a name="ln3107">    else</a>
<a name="ln3108">      ++hi;</a>
<a name="ln3109">    while (HASHITEM_EMPTY(hi))</a>
<a name="ln3110">      ++hi;</a>
<a name="ln3111">    return cat_prefix_varname('t', hi-&gt;hi_key);</a>
<a name="ln3112">  }</a>
<a name="ln3113"> </a>
<a name="ln3114">  // v: variables</a>
<a name="ln3115">  if (vidx &lt; ARRAY_SIZE(vimvars)) {</a>
<a name="ln3116">    return cat_prefix_varname('v', (char_u *)vimvars[vidx++].vv_name);</a>
<a name="ln3117">  }</a>
<a name="ln3118"> </a>
<a name="ln3119">  XFREE_CLEAR(varnamebuf);</a>
<a name="ln3120">  varnamebuflen = 0;</a>
<a name="ln3121">  return NULL;</a>
<a name="ln3122">}</a>
<a name="ln3123"> </a>
<a name="ln3124">// TODO(ZyX-I): move to eval/expressions</a>
<a name="ln3125"> </a>
<a name="ln3126">/// Return TRUE if &quot;pat&quot; matches &quot;text&quot;.</a>
<a name="ln3127">/// Does not use 'cpo' and always uses 'magic'.</a>
<a name="ln3128">static int pattern_match(char_u *pat, char_u *text, bool ic)</a>
<a name="ln3129">{</a>
<a name="ln3130">  int matches = 0;</a>
<a name="ln3131">  regmatch_T regmatch;</a>
<a name="ln3132"> </a>
<a name="ln3133">  // avoid 'l' flag in 'cpoptions'</a>
<a name="ln3134">  char_u *save_cpo = p_cpo;</a>
<a name="ln3135">  p_cpo = (char_u *)&quot;&quot;;</a>
<a name="ln3136">  regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);</a>
<a name="ln3137">  if (regmatch.regprog != NULL) {</a>
<a name="ln3138">    regmatch.rm_ic = ic;</a>
<a name="ln3139">    matches = vim_regexec_nl(&amp;regmatch, text, (colnr_T)0);</a>
<a name="ln3140">    vim_regfree(regmatch.regprog);</a>
<a name="ln3141">  }</a>
<a name="ln3142">  p_cpo = save_cpo;</a>
<a name="ln3143">  return matches;</a>
<a name="ln3144">}</a>
<a name="ln3145"> </a>
<a name="ln3146">// TODO(ZyX-I): move to eval/expressions</a>
<a name="ln3147"> </a>
<a name="ln3148">/*</a>
<a name="ln3149"> * The &quot;evaluate&quot; argument: When FALSE, the argument is only parsed but not</a>
<a name="ln3150"> * executed.  The function may return OK, but the rettv will be of type</a>
<a name="ln3151"> * VAR_UNKNOWN.  The function still returns FAIL for a syntax error.</a>
<a name="ln3152"> */</a>
<a name="ln3153"> </a>
<a name="ln3154">/*</a>
<a name="ln3155"> * Handle zero level expression.</a>
<a name="ln3156"> * This calls eval1() and handles error message and nextcmd.</a>
<a name="ln3157"> * Put the result in &quot;rettv&quot; when returning OK and &quot;evaluate&quot; is TRUE.</a>
<a name="ln3158"> * Note: &quot;rettv.v_lock&quot; is not set.</a>
<a name="ln3159"> * Return OK or FAIL.</a>
<a name="ln3160"> */</a>
<a name="ln3161">int eval0(char_u *arg, typval_T *rettv, char_u **nextcmd, int evaluate)</a>
<a name="ln3162">{</a>
<a name="ln3163">  int ret;</a>
<a name="ln3164">  char_u      *p;</a>
<a name="ln3165"> </a>
<a name="ln3166">  p = skipwhite(arg);</a>
<a name="ln3167">  ret = eval1(&amp;p, rettv, evaluate);</a>
<a name="ln3168">  if (ret == FAIL || !ends_excmd(*p)) {</a>
<a name="ln3169">    if (ret != FAIL) {</a>
<a name="ln3170">      tv_clear(rettv);</a>
<a name="ln3171">    }</a>
<a name="ln3172">    // Report the invalid expression unless the expression evaluation has</a>
<a name="ln3173">    // been cancelled due to an aborting error, an interrupt, or an</a>
<a name="ln3174">    // exception.</a>
<a name="ln3175">    if (!aborting()) {</a>
<a name="ln3176">      emsgf(_(e_invexpr2), arg);</a>
<a name="ln3177">    }</a>
<a name="ln3178">    ret = FAIL;</a>
<a name="ln3179">  }</a>
<a name="ln3180">  if (nextcmd != NULL)</a>
<a name="ln3181">    *nextcmd = check_nextcmd(p);</a>
<a name="ln3182"> </a>
<a name="ln3183">  return ret;</a>
<a name="ln3184">}</a>
<a name="ln3185"> </a>
<a name="ln3186">// TODO(ZyX-I): move to eval/expressions</a>
<a name="ln3187"> </a>
<a name="ln3188">/*</a>
<a name="ln3189"> * Handle top level expression:</a>
<a name="ln3190"> *	expr2 ? expr1 : expr1</a>
<a name="ln3191"> *</a>
<a name="ln3192"> * &quot;arg&quot; must point to the first non-white of the expression.</a>
<a name="ln3193"> * &quot;arg&quot; is advanced to the next non-white after the recognized expression.</a>
<a name="ln3194"> *</a>
<a name="ln3195"> * Note: &quot;rettv.v_lock&quot; is not set.</a>
<a name="ln3196"> *</a>
<a name="ln3197"> * Return OK or FAIL.</a>
<a name="ln3198"> */</a>
<a name="ln3199">int eval1(char_u **arg, typval_T *rettv, int evaluate)</a>
<a name="ln3200">{</a>
<a name="ln3201">  int result;</a>
<a name="ln3202">  typval_T var2;</a>
<a name="ln3203"> </a>
<a name="ln3204">  /*</a>
<a name="ln3205">   * Get the first variable.</a>
<a name="ln3206">   */</a>
<a name="ln3207">  if (eval2(arg, rettv, evaluate) == FAIL)</a>
<a name="ln3208">    return FAIL;</a>
<a name="ln3209"> </a>
<a name="ln3210">  if ((*arg)[0] == '?') {</a>
<a name="ln3211">    result = FALSE;</a>
<a name="ln3212">    if (evaluate) {</a>
<a name="ln3213">      bool error = false;</a>
<a name="ln3214"> </a>
<a name="ln3215">      if (tv_get_number_chk(rettv, &amp;error) != 0) {</a>
<a name="ln3216">        result = true;</a>
<a name="ln3217">      }</a>
<a name="ln3218">      tv_clear(rettv);</a>
<a name="ln3219">      if (error) {</a>
<a name="ln3220">        return FAIL;</a>
<a name="ln3221">      }</a>
<a name="ln3222">    }</a>
<a name="ln3223"> </a>
<a name="ln3224">    /*</a>
<a name="ln3225">     * Get the second variable.</a>
<a name="ln3226">     */</a>
<a name="ln3227">    *arg = skipwhite(*arg + 1);</a>
<a name="ln3228">    if (eval1(arg, rettv, evaluate &amp;&amp; result) == FAIL) {  // recursive!</a>
<a name="ln3229">      return FAIL;</a>
<a name="ln3230">    }</a>
<a name="ln3231"> </a>
<a name="ln3232">    /*</a>
<a name="ln3233">     * Check for the &quot;:&quot;.</a>
<a name="ln3234">     */</a>
<a name="ln3235">    if ((*arg)[0] != ':') {</a>
<a name="ln3236">      EMSG(_(&quot;E109: Missing ':' after '?'&quot;));</a>
<a name="ln3237">      if (evaluate &amp;&amp; result) {</a>
<a name="ln3238">        tv_clear(rettv);</a>
<a name="ln3239">      }</a>
<a name="ln3240">      return FAIL;</a>
<a name="ln3241">    }</a>
<a name="ln3242"> </a>
<a name="ln3243">    /*</a>
<a name="ln3244">     * Get the third variable.</a>
<a name="ln3245">     */</a>
<a name="ln3246">    *arg = skipwhite(*arg + 1);</a>
<a name="ln3247">    if (eval1(arg, &amp;var2, evaluate &amp;&amp; !result) == FAIL) {  // Recursive!</a>
<a name="ln3248">      if (evaluate &amp;&amp; result) {</a>
<a name="ln3249">        tv_clear(rettv);</a>
<a name="ln3250">      }</a>
<a name="ln3251">      return FAIL;</a>
<a name="ln3252">    }</a>
<a name="ln3253">    if (evaluate &amp;&amp; !result)</a>
<a name="ln3254">      *rettv = var2;</a>
<a name="ln3255">  }</a>
<a name="ln3256"> </a>
<a name="ln3257">  return OK;</a>
<a name="ln3258">}</a>
<a name="ln3259"> </a>
<a name="ln3260">// TODO(ZyX-I): move to eval/expressions</a>
<a name="ln3261"> </a>
<a name="ln3262">/*</a>
<a name="ln3263"> * Handle first level expression:</a>
<a name="ln3264"> *	expr2 || expr2 || expr2	    logical OR</a>
<a name="ln3265"> *</a>
<a name="ln3266"> * &quot;arg&quot; must point to the first non-white of the expression.</a>
<a name="ln3267"> * &quot;arg&quot; is advanced to the next non-white after the recognized expression.</a>
<a name="ln3268"> *</a>
<a name="ln3269"> * Return OK or FAIL.</a>
<a name="ln3270"> */</a>
<a name="ln3271">static int eval2(char_u **arg, typval_T *rettv, int evaluate)</a>
<a name="ln3272">{</a>
<a name="ln3273">  typval_T var2;</a>
<a name="ln3274">  long result;</a>
<a name="ln3275">  int first;</a>
<a name="ln3276">  bool error = false;</a>
<a name="ln3277"> </a>
<a name="ln3278">  /*</a>
<a name="ln3279">   * Get the first variable.</a>
<a name="ln3280">   */</a>
<a name="ln3281">  if (eval3(arg, rettv, evaluate) == FAIL)</a>
<a name="ln3282">    return FAIL;</a>
<a name="ln3283"> </a>
<a name="ln3284">  /*</a>
<a name="ln3285">   * Repeat until there is no following &quot;||&quot;.</a>
<a name="ln3286">   */</a>
<a name="ln3287">  first = TRUE;</a>
<a name="ln3288">  result = FALSE;</a>
<a name="ln3289">  while ((*arg)[0] == '|' &amp;&amp; (*arg)[1] == '|') {</a>
<a name="ln3290">    if (evaluate &amp;&amp; first) {</a>
<a name="ln3291">      if (tv_get_number_chk(rettv, &amp;error) != 0) {</a>
<a name="ln3292">        result = true;</a>
<a name="ln3293">      }</a>
<a name="ln3294">      tv_clear(rettv);</a>
<a name="ln3295">      if (error) {</a>
<a name="ln3296">        return FAIL;</a>
<a name="ln3297">      }</a>
<a name="ln3298">      first = false;</a>
<a name="ln3299">    }</a>
<a name="ln3300"> </a>
<a name="ln3301">    /*</a>
<a name="ln3302">     * Get the second variable.</a>
<a name="ln3303">     */</a>
<a name="ln3304">    *arg = skipwhite(*arg + 2);</a>
<a name="ln3305">    if (eval3(arg, &amp;var2, evaluate &amp;&amp; !result) == FAIL)</a>
<a name="ln3306">      return FAIL;</a>
<a name="ln3307"> </a>
<a name="ln3308">    /*</a>
<a name="ln3309">     * Compute the result.</a>
<a name="ln3310">     */</a>
<a name="ln3311">    if (evaluate &amp;&amp; !result) {</a>
<a name="ln3312">      if (tv_get_number_chk(&amp;var2, &amp;error) != 0) {</a>
<a name="ln3313">        result = true;</a>
<a name="ln3314">      }</a>
<a name="ln3315">      tv_clear(&amp;var2);</a>
<a name="ln3316">      if (error) {</a>
<a name="ln3317">        return FAIL;</a>
<a name="ln3318">      }</a>
<a name="ln3319">    }</a>
<a name="ln3320">    if (evaluate) {</a>
<a name="ln3321">      rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3322">      rettv-&gt;vval.v_number = result;</a>
<a name="ln3323">    }</a>
<a name="ln3324">  }</a>
<a name="ln3325"> </a>
<a name="ln3326">  return OK;</a>
<a name="ln3327">}</a>
<a name="ln3328"> </a>
<a name="ln3329">// TODO(ZyX-I): move to eval/expressions</a>
<a name="ln3330"> </a>
<a name="ln3331">/*</a>
<a name="ln3332"> * Handle second level expression:</a>
<a name="ln3333"> *	expr3 &amp;&amp; expr3 &amp;&amp; expr3	    logical AND</a>
<a name="ln3334"> *</a>
<a name="ln3335"> * &quot;arg&quot; must point to the first non-white of the expression.</a>
<a name="ln3336"> * &quot;arg&quot; is advanced to the next non-white after the recognized expression.</a>
<a name="ln3337"> *</a>
<a name="ln3338"> * Return OK or FAIL.</a>
<a name="ln3339"> */</a>
<a name="ln3340">static int eval3(char_u **arg, typval_T *rettv, int evaluate)</a>
<a name="ln3341">{</a>
<a name="ln3342">  typval_T var2;</a>
<a name="ln3343">  long result;</a>
<a name="ln3344">  int first;</a>
<a name="ln3345">  bool error = false;</a>
<a name="ln3346"> </a>
<a name="ln3347">  /*</a>
<a name="ln3348">   * Get the first variable.</a>
<a name="ln3349">   */</a>
<a name="ln3350">  if (eval4(arg, rettv, evaluate) == FAIL)</a>
<a name="ln3351">    return FAIL;</a>
<a name="ln3352"> </a>
<a name="ln3353">  /*</a>
<a name="ln3354">   * Repeat until there is no following &quot;&amp;&amp;&quot;.</a>
<a name="ln3355">   */</a>
<a name="ln3356">  first = TRUE;</a>
<a name="ln3357">  result = TRUE;</a>
<a name="ln3358">  while ((*arg)[0] == '&amp;' &amp;&amp; (*arg)[1] == '&amp;') {</a>
<a name="ln3359">    if (evaluate &amp;&amp; first) {</a>
<a name="ln3360">      if (tv_get_number_chk(rettv, &amp;error) == 0) {</a>
<a name="ln3361">        result = false;</a>
<a name="ln3362">      }</a>
<a name="ln3363">      tv_clear(rettv);</a>
<a name="ln3364">      if (error) {</a>
<a name="ln3365">        return FAIL;</a>
<a name="ln3366">      }</a>
<a name="ln3367">      first = false;</a>
<a name="ln3368">    }</a>
<a name="ln3369"> </a>
<a name="ln3370">    /*</a>
<a name="ln3371">     * Get the second variable.</a>
<a name="ln3372">     */</a>
<a name="ln3373">    *arg = skipwhite(*arg + 2);</a>
<a name="ln3374">    if (eval4(arg, &amp;var2, evaluate &amp;&amp; result) == FAIL)</a>
<a name="ln3375">      return FAIL;</a>
<a name="ln3376"> </a>
<a name="ln3377">    /*</a>
<a name="ln3378">     * Compute the result.</a>
<a name="ln3379">     */</a>
<a name="ln3380">    if (evaluate &amp;&amp; result) {</a>
<a name="ln3381">      if (tv_get_number_chk(&amp;var2, &amp;error) == 0) {</a>
<a name="ln3382">        result = false;</a>
<a name="ln3383">      }</a>
<a name="ln3384">      tv_clear(&amp;var2);</a>
<a name="ln3385">      if (error) {</a>
<a name="ln3386">        return FAIL;</a>
<a name="ln3387">      }</a>
<a name="ln3388">    }</a>
<a name="ln3389">    if (evaluate) {</a>
<a name="ln3390">      rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3391">      rettv-&gt;vval.v_number = result;</a>
<a name="ln3392">    }</a>
<a name="ln3393">  }</a>
<a name="ln3394"> </a>
<a name="ln3395">  return OK;</a>
<a name="ln3396">}</a>
<a name="ln3397"> </a>
<a name="ln3398">// TODO(ZyX-I): move to eval/expressions</a>
<a name="ln3399"> </a>
<a name="ln3400">/*</a>
<a name="ln3401"> * Handle third level expression:</a>
<a name="ln3402"> *	var1 == var2</a>
<a name="ln3403"> *	var1 =~ var2</a>
<a name="ln3404"> *	var1 != var2</a>
<a name="ln3405"> *	var1 !~ var2</a>
<a name="ln3406"> *	var1 &gt; var2</a>
<a name="ln3407"> *	var1 &gt;= var2</a>
<a name="ln3408"> *	var1 &lt; var2</a>
<a name="ln3409"> *	var1 &lt;= var2</a>
<a name="ln3410"> *	var1 is var2</a>
<a name="ln3411"> *	var1 isnot var2</a>
<a name="ln3412"> *</a>
<a name="ln3413"> * &quot;arg&quot; must point to the first non-white of the expression.</a>
<a name="ln3414"> * &quot;arg&quot; is advanced to the next non-white after the recognized expression.</a>
<a name="ln3415"> *</a>
<a name="ln3416"> * Return OK or FAIL.</a>
<a name="ln3417"> */</a>
<a name="ln3418">static int eval4(char_u **arg, typval_T *rettv, int evaluate)</a>
<a name="ln3419">{</a>
<a name="ln3420">  typval_T var2;</a>
<a name="ln3421">  char_u      *p;</a>
<a name="ln3422">  exprtype_T type = EXPR_UNKNOWN;</a>
<a name="ln3423">  int len = 2;</a>
<a name="ln3424">  bool ic;</a>
<a name="ln3425"> </a>
<a name="ln3426">  /*</a>
<a name="ln3427">   * Get the first variable.</a>
<a name="ln3428">   */</a>
<a name="ln3429">  if (eval5(arg, rettv, evaluate) == FAIL)</a>
<a name="ln3430">    return FAIL;</a>
<a name="ln3431"> </a>
<a name="ln3432">  p = *arg;</a>
<a name="ln3433">  switch (p[0]) {</a>
<a name="ln3434">  case '=':</a>
<a name="ln3435">    if (p[1] == '=') {</a>
<a name="ln3436">      type = EXPR_EQUAL;</a>
<a name="ln3437">    } else if (p[1] == '~') {</a>
<a name="ln3438">      type = EXPR_MATCH;</a>
<a name="ln3439">    }</a>
<a name="ln3440">    break;</a>
<a name="ln3441">  case '!':</a>
<a name="ln3442">    if (p[1] == '=') {</a>
<a name="ln3443">      type = EXPR_NEQUAL;</a>
<a name="ln3444">    } else if (p[1] == '~') {</a>
<a name="ln3445">      type = EXPR_NOMATCH;</a>
<a name="ln3446">    }</a>
<a name="ln3447">    break;</a>
<a name="ln3448">  case '&gt;':</a>
<a name="ln3449">    if (p[1] != '=') {</a>
<a name="ln3450">      type = EXPR_GREATER;</a>
<a name="ln3451">      len = 1;</a>
<a name="ln3452">    } else {</a>
<a name="ln3453">      type = EXPR_GEQUAL;</a>
<a name="ln3454">    }</a>
<a name="ln3455">    break;</a>
<a name="ln3456">  case '&lt;':</a>
<a name="ln3457">    if (p[1] != '=') {</a>
<a name="ln3458">      type = EXPR_SMALLER;</a>
<a name="ln3459">      len = 1;</a>
<a name="ln3460">    } else {</a>
<a name="ln3461">      type = EXPR_SEQUAL;</a>
<a name="ln3462">    }</a>
<a name="ln3463">    break;</a>
<a name="ln3464">  case 'i':   if (p[1] == 's') {</a>
<a name="ln3465">      if (p[2] == 'n' &amp;&amp; p[3] == 'o' &amp;&amp; p[4] == 't') {</a>
<a name="ln3466">        len = 5;</a>
<a name="ln3467">      }</a>
<a name="ln3468">      if (!isalnum(p[len]) &amp;&amp; p[len] != '_') {</a>
<a name="ln3469">        type = len == 2 ? EXPR_IS : EXPR_ISNOT;</a>
<a name="ln3470">      }</a>
<a name="ln3471">  }</a>
<a name="ln3472">    break;</a>
<a name="ln3473">  }</a>
<a name="ln3474"> </a>
<a name="ln3475">  /*</a>
<a name="ln3476">   * If there is a comparative operator, use it.</a>
<a name="ln3477">   */</a>
<a name="ln3478">  if (type != EXPR_UNKNOWN) {</a>
<a name="ln3479">    // extra question mark appended: ignore case</a>
<a name="ln3480">    if (p[len] == '?') {</a>
<a name="ln3481">      ic = true;</a>
<a name="ln3482">      len++;</a>
<a name="ln3483">    } else if (p[len] == '#') {  // extra '#' appended: match case</a>
<a name="ln3484">      ic = false;</a>
<a name="ln3485">      len++;</a>
<a name="ln3486">    } else {  // nothing appended: use 'ignorecase'</a>
<a name="ln3487">      ic = p_ic;</a>
<a name="ln3488">    }</a>
<a name="ln3489"> </a>
<a name="ln3490">    // Get the second variable.</a>
<a name="ln3491">    *arg = skipwhite(p + len);</a>
<a name="ln3492">    if (eval5(arg, &amp;var2, evaluate) == FAIL) {</a>
<a name="ln3493">      tv_clear(rettv);</a>
<a name="ln3494">      return FAIL;</a>
<a name="ln3495">    }</a>
<a name="ln3496">    if (evaluate) {</a>
<a name="ln3497">      const int ret = typval_compare(rettv, &amp;var2, type, ic);</a>
<a name="ln3498"> </a>
<a name="ln3499">      tv_clear(&amp;var2);</a>
<a name="ln3500">      return ret;</a>
<a name="ln3501">    }</a>
<a name="ln3502">  }</a>
<a name="ln3503"> </a>
<a name="ln3504">  return OK;</a>
<a name="ln3505">}</a>
<a name="ln3506"> </a>
<a name="ln3507">// TODO(ZyX-I): move to eval/expressions</a>
<a name="ln3508"> </a>
<a name="ln3509">/*</a>
<a name="ln3510"> * Handle fourth level expression:</a>
<a name="ln3511"> *	+	number addition</a>
<a name="ln3512"> *	-	number subtraction</a>
<a name="ln3513"> *	.	string concatenation</a>
<a name="ln3514"> *	..	string concatenation</a>
<a name="ln3515"> *</a>
<a name="ln3516"> * &quot;arg&quot; must point to the first non-white of the expression.</a>
<a name="ln3517"> * &quot;arg&quot; is advanced to the next non-white after the recognized expression.</a>
<a name="ln3518"> *</a>
<a name="ln3519"> * Return OK or FAIL.</a>
<a name="ln3520"> */</a>
<a name="ln3521">static int eval5(char_u **arg, typval_T *rettv, int evaluate)</a>
<a name="ln3522">{</a>
<a name="ln3523">  typval_T var2;</a>
<a name="ln3524">  typval_T var3;</a>
<a name="ln3525">  int op;</a>
<a name="ln3526">  varnumber_T n1, n2;</a>
<a name="ln3527">  float_T f1 = 0, f2 = 0;</a>
<a name="ln3528">  char_u      *p;</a>
<a name="ln3529"> </a>
<a name="ln3530">  /*</a>
<a name="ln3531">   * Get the first variable.</a>
<a name="ln3532">   */</a>
<a name="ln3533">  if (eval6(arg, rettv, evaluate, FALSE) == FAIL)</a>
<a name="ln3534">    return FAIL;</a>
<a name="ln3535"> </a>
<a name="ln3536">  /*</a>
<a name="ln3537">   * Repeat computing, until no '+', '-' or '.' is following.</a>
<a name="ln3538">   */</a>
<a name="ln3539">  for (;; ) {</a>
<a name="ln3540">    op = **arg;</a>
<a name="ln3541">    if (op != '+' &amp;&amp; op != '-' &amp;&amp; op != '.')</a>
<a name="ln3542">      break;</a>
<a name="ln3543"> </a>
<a name="ln3544">    if ((op != '+' || rettv-&gt;v_type != VAR_LIST)</a>
<a name="ln3545">        &amp;&amp; (op == '.' || rettv-&gt;v_type != VAR_FLOAT)) {</a>
<a name="ln3546">      // For &quot;list + ...&quot;, an illegal use of the first operand as</a>
<a name="ln3547">      // a number cannot be determined before evaluating the 2nd</a>
<a name="ln3548">      // operand: if this is also a list, all is ok.</a>
<a name="ln3549">      // For &quot;something . ...&quot;, &quot;something - ...&quot; or &quot;non-list + ...&quot;,</a>
<a name="ln3550">      // we know that the first operand needs to be a string or number</a>
<a name="ln3551">      // without evaluating the 2nd operand.  So check before to avoid</a>
<a name="ln3552">      // side effects after an error.</a>
<a name="ln3553">      if (evaluate &amp;&amp; !tv_check_str(rettv)) {</a>
<a name="ln3554">        tv_clear(rettv);</a>
<a name="ln3555">        return FAIL;</a>
<a name="ln3556">      }</a>
<a name="ln3557">    }</a>
<a name="ln3558"> </a>
<a name="ln3559">    /*</a>
<a name="ln3560">     * Get the second variable.</a>
<a name="ln3561">     */</a>
<a name="ln3562">    if (op == '.' &amp;&amp; *(*arg + 1) == '.') {  // ..string concatenation</a>
<a name="ln3563">      (*arg)++;</a>
<a name="ln3564">    }</a>
<a name="ln3565">    *arg = skipwhite(*arg + 1);</a>
<a name="ln3566">    if (eval6(arg, &amp;var2, evaluate, op == '.') == FAIL) {</a>
<a name="ln3567">      tv_clear(rettv);</a>
<a name="ln3568">      return FAIL;</a>
<a name="ln3569">    }</a>
<a name="ln3570"> </a>
<a name="ln3571">    if (evaluate) {</a>
<a name="ln3572">      /*</a>
<a name="ln3573">       * Compute the result.</a>
<a name="ln3574">       */</a>
<a name="ln3575">      if (op == '.') {</a>
<a name="ln3576">        char buf1[NUMBUFLEN];</a>
<a name="ln3577">        char buf2[NUMBUFLEN];</a>
<a name="ln3578">        // s1 already checked</a>
<a name="ln3579">        const char *const s1 = tv_get_string_buf(rettv, buf1);</a>
<a name="ln3580">        const char *const s2 = tv_get_string_buf_chk(&amp;var2, buf2);</a>
<a name="ln3581">        if (s2 == NULL) {  // Type error?</a>
<a name="ln3582">          tv_clear(rettv);</a>
<a name="ln3583">          tv_clear(&amp;var2);</a>
<a name="ln3584">          return FAIL;</a>
<a name="ln3585">        }</a>
<a name="ln3586">        p = concat_str((const char_u *)s1, (const char_u *)s2);</a>
<a name="ln3587">        tv_clear(rettv);</a>
<a name="ln3588">        rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3589">        rettv-&gt;vval.v_string = p;</a>
<a name="ln3590">      } else if (op == '+' &amp;&amp; rettv-&gt;v_type == VAR_LIST</a>
<a name="ln3591">                 &amp;&amp; var2.v_type == VAR_LIST) {</a>
<a name="ln3592">        // Concatenate Lists.</a>
<a name="ln3593">        if (tv_list_concat(rettv-&gt;vval.v_list, var2.vval.v_list, &amp;var3)</a>
<a name="ln3594">            == FAIL) {</a>
<a name="ln3595">          tv_clear(rettv);</a>
<a name="ln3596">          tv_clear(&amp;var2);</a>
<a name="ln3597">          return FAIL;</a>
<a name="ln3598">        }</a>
<a name="ln3599">        tv_clear(rettv);</a>
<a name="ln3600">        *rettv = var3;</a>
<a name="ln3601">      } else {</a>
<a name="ln3602">        bool error = false;</a>
<a name="ln3603"> </a>
<a name="ln3604">        if (rettv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln3605">          f1 = rettv-&gt;vval.v_float;</a>
<a name="ln3606">          n1 = 0;</a>
<a name="ln3607">        } else {</a>
<a name="ln3608">          n1 = tv_get_number_chk(rettv, &amp;error);</a>
<a name="ln3609">          if (error) {</a>
<a name="ln3610">            /* This can only happen for &quot;list + non-list&quot;.  For</a>
<a name="ln3611">             * &quot;non-list + ...&quot; or &quot;something - ...&quot;, we returned</a>
<a name="ln3612">             * before evaluating the 2nd operand. */</a>
<a name="ln3613">            tv_clear(rettv);</a>
<a name="ln3614">            return FAIL;</a>
<a name="ln3615">          }</a>
<a name="ln3616">          if (var2.v_type == VAR_FLOAT)</a>
<a name="ln3617">            f1 = n1;</a>
<a name="ln3618">        }</a>
<a name="ln3619">        if (var2.v_type == VAR_FLOAT) {</a>
<a name="ln3620">          f2 = var2.vval.v_float;</a>
<a name="ln3621">          n2 = 0;</a>
<a name="ln3622">        } else {</a>
<a name="ln3623">          n2 = tv_get_number_chk(&amp;var2, &amp;error);</a>
<a name="ln3624">          if (error) {</a>
<a name="ln3625">            tv_clear(rettv);</a>
<a name="ln3626">            tv_clear(&amp;var2);</a>
<a name="ln3627">            return FAIL;</a>
<a name="ln3628">          }</a>
<a name="ln3629">          if (rettv-&gt;v_type == VAR_FLOAT)</a>
<a name="ln3630">            f2 = n2;</a>
<a name="ln3631">        }</a>
<a name="ln3632">        tv_clear(rettv);</a>
<a name="ln3633"> </a>
<a name="ln3634">        // If there is a float on either side the result is a float.</a>
<a name="ln3635">        if (rettv-&gt;v_type == VAR_FLOAT || var2.v_type == VAR_FLOAT) {</a>
<a name="ln3636">          if (op == '+')</a>
<a name="ln3637">            f1 = f1 + f2;</a>
<a name="ln3638">          else</a>
<a name="ln3639">            f1 = f1 - f2;</a>
<a name="ln3640">          rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln3641">          rettv-&gt;vval.v_float = f1;</a>
<a name="ln3642">        } else {</a>
<a name="ln3643">          if (op == '+')</a>
<a name="ln3644">            n1 = n1 + n2;</a>
<a name="ln3645">          else</a>
<a name="ln3646">            n1 = n1 - n2;</a>
<a name="ln3647">          rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3648">          rettv-&gt;vval.v_number = n1;</a>
<a name="ln3649">        }</a>
<a name="ln3650">      }</a>
<a name="ln3651">      tv_clear(&amp;var2);</a>
<a name="ln3652">    }</a>
<a name="ln3653">  }</a>
<a name="ln3654">  return OK;</a>
<a name="ln3655">}</a>
<a name="ln3656"> </a>
<a name="ln3657">// TODO(ZyX-I): move to eval/expressions</a>
<a name="ln3658"> </a>
<a name="ln3659">/// Handle fifth level expression:</a>
<a name="ln3660">///  - *  number multiplication</a>
<a name="ln3661">///  - /  number division</a>
<a name="ln3662">///  - %  number modulo</a>
<a name="ln3663">///</a>
<a name="ln3664">/// @param[in,out]  arg  Points to the first non-whitespace character of the</a>
<a name="ln3665">///                      expression.  Is advanced to the next non-whitespace</a>
<a name="ln3666">///                      character after the recognized expression.</a>
<a name="ln3667">/// @param[out]  rettv  Location where result is saved.</a>
<a name="ln3668">/// @param[in]  evaluate  If not true, rettv is not populated.</a>
<a name="ln3669">/// @param[in]  want_string  True if &quot;.&quot; is string_concatenation, otherwise</a>
<a name="ln3670">///                          float</a>
<a name="ln3671">/// @return  OK or FAIL.</a>
<a name="ln3672">static int eval6(char_u **arg, typval_T *rettv, int evaluate, int want_string)</a>
<a name="ln3673">  FUNC_ATTR_NO_SANITIZE_UNDEFINED</a>
<a name="ln3674">{</a>
<a name="ln3675">  typval_T var2;</a>
<a name="ln3676">  int op;</a>
<a name="ln3677">  varnumber_T n1, n2;</a>
<a name="ln3678">  bool use_float = false;</a>
<a name="ln3679">  float_T f1 = 0, f2 = 0;</a>
<a name="ln3680">  bool error = false;</a>
<a name="ln3681"> </a>
<a name="ln3682">  /*</a>
<a name="ln3683">   * Get the first variable.</a>
<a name="ln3684">   */</a>
<a name="ln3685">  if (eval7(arg, rettv, evaluate, want_string) == FAIL)</a>
<a name="ln3686">    return FAIL;</a>
<a name="ln3687"> </a>
<a name="ln3688">  /*</a>
<a name="ln3689">   * Repeat computing, until no '*', '/' or '%' is following.</a>
<a name="ln3690">   */</a>
<a name="ln3691">  for (;; ) {</a>
<a name="ln3692">    op = **arg;</a>
<a name="ln3693">    if (op != '*' &amp;&amp; op != '/' &amp;&amp; op != '%') {</a>
<a name="ln3694">      break;</a>
<a name="ln3695">    }</a>
<a name="ln3696"> </a>
<a name="ln3697">    if (evaluate) {</a>
<a name="ln3698">      if (rettv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln3699">        f1 = rettv-&gt;vval.v_float;</a>
<a name="ln3700">        use_float = true;</a>
<a name="ln3701">        n1 = 0;</a>
<a name="ln3702">      } else {</a>
<a name="ln3703">        n1 = tv_get_number_chk(rettv, &amp;error);</a>
<a name="ln3704">      }</a>
<a name="ln3705">      tv_clear(rettv);</a>
<a name="ln3706">      if (error) {</a>
<a name="ln3707">        return FAIL;</a>
<a name="ln3708">      }</a>
<a name="ln3709">    } else {</a>
<a name="ln3710">      n1 = 0;</a>
<a name="ln3711">    }</a>
<a name="ln3712"> </a>
<a name="ln3713">    /*</a>
<a name="ln3714">     * Get the second variable.</a>
<a name="ln3715">     */</a>
<a name="ln3716">    *arg = skipwhite(*arg + 1);</a>
<a name="ln3717">    if (eval7(arg, &amp;var2, evaluate, FALSE) == FAIL)</a>
<a name="ln3718">      return FAIL;</a>
<a name="ln3719"> </a>
<a name="ln3720">    if (evaluate) {</a>
<a name="ln3721">      if (var2.v_type == VAR_FLOAT) {</a>
<a name="ln3722">        if (!use_float) {</a>
<a name="ln3723">          f1 = n1;</a>
<a name="ln3724">          use_float = true;</a>
<a name="ln3725">        }</a>
<a name="ln3726">        f2 = var2.vval.v_float;</a>
<a name="ln3727">        n2 = 0;</a>
<a name="ln3728">      } else {</a>
<a name="ln3729">        n2 = tv_get_number_chk(&amp;var2, &amp;error);</a>
<a name="ln3730">        tv_clear(&amp;var2);</a>
<a name="ln3731">        if (error) {</a>
<a name="ln3732">          return FAIL;</a>
<a name="ln3733">        }</a>
<a name="ln3734">        if (use_float) {</a>
<a name="ln3735">          f2 = n2;</a>
<a name="ln3736">        }</a>
<a name="ln3737">      }</a>
<a name="ln3738"> </a>
<a name="ln3739">      /*</a>
<a name="ln3740">       * Compute the result.</a>
<a name="ln3741">       * When either side is a float the result is a float.</a>
<a name="ln3742">       */</a>
<a name="ln3743">      if (use_float) {</a>
<a name="ln3744">        if (op == '*') {</a>
<a name="ln3745">          f1 = f1 * f2;</a>
<a name="ln3746">        } else if (op == '/') {</a>
<a name="ln3747">          // Division by zero triggers error from AddressSanitizer</a>
<a name="ln3748">          f1 = (f2 == 0</a>
<a name="ln3749">                ? (</a>
<a name="ln3750">#ifdef NAN</a>
<a name="ln3751">                    f1 == 0</a>
<a name="ln3752">                    ? NAN</a>
<a name="ln3753">                    :</a>
<a name="ln3754">#endif</a>
<a name="ln3755">                    (f1 &gt; 0</a>
<a name="ln3756">                     ? INFINITY</a>
<a name="ln3757">                     : -INFINITY)</a>
<a name="ln3758">                )</a>
<a name="ln3759">                : f1 / f2);</a>
<a name="ln3760">        } else {</a>
<a name="ln3761">          EMSG(_(&quot;E804: Cannot use '%' with Float&quot;));</a>
<a name="ln3762">          return FAIL;</a>
<a name="ln3763">        }</a>
<a name="ln3764">        rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln3765">        rettv-&gt;vval.v_float = f1;</a>
<a name="ln3766">      } else {</a>
<a name="ln3767">        if (op == '*') {</a>
<a name="ln3768">          n1 = n1 * n2;</a>
<a name="ln3769">        } else if (op == '/') {</a>
<a name="ln3770">          n1 = num_divide(n1, n2);</a>
<a name="ln3771">        } else {</a>
<a name="ln3772">          n1 = num_modulus(n1, n2);</a>
<a name="ln3773">        }</a>
<a name="ln3774">        rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3775">        rettv-&gt;vval.v_number = n1;</a>
<a name="ln3776">      }</a>
<a name="ln3777">    }</a>
<a name="ln3778">  }</a>
<a name="ln3779"> </a>
<a name="ln3780">  return OK;</a>
<a name="ln3781">}</a>
<a name="ln3782"> </a>
<a name="ln3783">// TODO(ZyX-I): move to eval/expressions</a>
<a name="ln3784"> </a>
<a name="ln3785">// Handle sixth level expression:</a>
<a name="ln3786">//  number  number constant</a>
<a name="ln3787">//  &quot;string&quot;  string constant</a>
<a name="ln3788">//  'string'  literal string constant</a>
<a name="ln3789">//  &amp;option-name option value</a>
<a name="ln3790">//  @r   register contents</a>
<a name="ln3791">//  identifier  variable value</a>
<a name="ln3792">//  function()  function call</a>
<a name="ln3793">//  $VAR  environment variable</a>
<a name="ln3794">//  (expression) nested expression</a>
<a name="ln3795">//  [expr, expr] List</a>
<a name="ln3796">//  {key: val, key: val}  Dictionary</a>
<a name="ln3797">//  #{key: val, key: val}  Dictionary with literal keys</a>
<a name="ln3798">//</a>
<a name="ln3799">//  Also handle:</a>
<a name="ln3800">//  ! in front  logical NOT</a>
<a name="ln3801">//  - in front  unary minus</a>
<a name="ln3802">//  + in front  unary plus (ignored)</a>
<a name="ln3803">//  trailing []  subscript in String or List</a>
<a name="ln3804">//  trailing .name entry in Dictionary</a>
<a name="ln3805">//</a>
<a name="ln3806">// &quot;arg&quot; must point to the first non-white of the expression.</a>
<a name="ln3807">// &quot;arg&quot; is advanced to the next non-white after the recognized expression.</a>
<a name="ln3808">//</a>
<a name="ln3809">// Return OK or FAIL.</a>
<a name="ln3810">static int eval7(</a>
<a name="ln3811">    char_u **arg,</a>
<a name="ln3812">    typval_T *rettv,</a>
<a name="ln3813">    int evaluate,</a>
<a name="ln3814">    int want_string                 // after &quot;.&quot; operator</a>
<a name="ln3815">)</a>
<a name="ln3816">{</a>
<a name="ln3817">  varnumber_T n;</a>
<a name="ln3818">  int len;</a>
<a name="ln3819">  char_u      *s;</a>
<a name="ln3820">  char_u      *start_leader, *end_leader;</a>
<a name="ln3821">  int ret = OK;</a>
<a name="ln3822">  char_u      *alias;</a>
<a name="ln3823"> </a>
<a name="ln3824">  // Initialise variable so that tv_clear() can't mistake this for a</a>
<a name="ln3825">  // string and free a string that isn't there.</a>
<a name="ln3826">  rettv-&gt;v_type = VAR_UNKNOWN;</a>
<a name="ln3827"> </a>
<a name="ln3828">  // Skip '!', '-' and '+' characters.  They are handled later.</a>
<a name="ln3829">  start_leader = *arg;</a>
<a name="ln3830">  while (**arg == '!' || **arg == '-' || **arg == '+') {</a>
<a name="ln3831">    *arg = skipwhite(*arg + 1);</a>
<a name="ln3832">  }</a>
<a name="ln3833">  end_leader = *arg;</a>
<a name="ln3834"> </a>
<a name="ln3835">  switch (**arg) {</a>
<a name="ln3836">  // Number constant.</a>
<a name="ln3837">  case '0':</a>
<a name="ln3838">  case '1':</a>
<a name="ln3839">  case '2':</a>
<a name="ln3840">  case '3':</a>
<a name="ln3841">  case '4':</a>
<a name="ln3842">  case '5':</a>
<a name="ln3843">  case '6':</a>
<a name="ln3844">  case '7':</a>
<a name="ln3845">  case '8':</a>
<a name="ln3846">  case '9':</a>
<a name="ln3847">  {</a>
<a name="ln3848">    char_u *p = skipdigits(*arg + 1);</a>
<a name="ln3849">    int get_float = false;</a>
<a name="ln3850"> </a>
<a name="ln3851">    // We accept a float when the format matches</a>
<a name="ln3852">    // &quot;[0-9]\+\.[0-9]\+\([eE][+-]\?[0-9]\+\)\?&quot;.  This is very</a>
<a name="ln3853">    // strict to avoid backwards compatibility problems.</a>
<a name="ln3854">    // Don't look for a float after the &quot;.&quot; operator, so that</a>
<a name="ln3855">    // &quot;:let vers = 1.2.3&quot; doesn't fail.</a>
<a name="ln3856">    if (!want_string &amp;&amp; p[0] == '.' &amp;&amp; ascii_isdigit(p[1])) {</a>
<a name="ln3857">      get_float = true;</a>
<a name="ln3858">      p = skipdigits(p + 2);</a>
<a name="ln3859">      if (*p == 'e' || *p == 'E') {</a>
<a name="ln3860">        ++p;</a>
<a name="ln3861">        if (*p == '-' || *p == '+') {</a>
<a name="ln3862">          ++p;</a>
<a name="ln3863">        }</a>
<a name="ln3864">        if (!ascii_isdigit(*p)) {</a>
<a name="ln3865">          get_float = false;</a>
<a name="ln3866">        } else {</a>
<a name="ln3867">          p = skipdigits(p + 1);</a>
<a name="ln3868">        }</a>
<a name="ln3869">      }</a>
<a name="ln3870">      if (ASCII_ISALPHA(*p) || *p == '.') {</a>
<a name="ln3871">        get_float = false;</a>
<a name="ln3872">      }</a>
<a name="ln3873">    }</a>
<a name="ln3874">    if (get_float) {</a>
<a name="ln3875">      float_T f;</a>
<a name="ln3876"> </a>
<a name="ln3877">      *arg += string2float((char *) *arg, &amp;f);</a>
<a name="ln3878">      if (evaluate) {</a>
<a name="ln3879">        rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln3880">        rettv-&gt;vval.v_float = f;</a>
<a name="ln3881">      }</a>
<a name="ln3882">    } else {</a>
<a name="ln3883">      vim_str2nr(*arg, NULL, &amp;len, STR2NR_ALL, &amp;n, NULL, 0);</a>
<a name="ln3884">      *arg += len;</a>
<a name="ln3885">      if (evaluate) {</a>
<a name="ln3886">        rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3887">        rettv-&gt;vval.v_number = n;</a>
<a name="ln3888">      }</a>
<a name="ln3889">    }</a>
<a name="ln3890">    break;</a>
<a name="ln3891">  }</a>
<a name="ln3892"> </a>
<a name="ln3893">  // String constant: &quot;string&quot;.</a>
<a name="ln3894">  case '&quot;':   ret = get_string_tv(arg, rettv, evaluate);</a>
<a name="ln3895">    break;</a>
<a name="ln3896"> </a>
<a name="ln3897">  // Literal string constant: 'str''ing'.</a>
<a name="ln3898">  case '\'':  ret = get_lit_string_tv(arg, rettv, evaluate);</a>
<a name="ln3899">    break;</a>
<a name="ln3900"> </a>
<a name="ln3901">  // List: [expr, expr]</a>
<a name="ln3902">  case '[':   ret = get_list_tv(arg, rettv, evaluate);</a>
<a name="ln3903">    break;</a>
<a name="ln3904"> </a>
<a name="ln3905">  // Dictionary: #{key: val, key: val}</a>
<a name="ln3906">  case '#':</a>
<a name="ln3907">    if ((*arg)[1] == '{') {</a>
<a name="ln3908">      (*arg)++;</a>
<a name="ln3909">      ret = dict_get_tv(arg, rettv, evaluate, true);</a>
<a name="ln3910">    } else {</a>
<a name="ln3911">      ret = NOTDONE;</a>
<a name="ln3912">    }</a>
<a name="ln3913">    break;</a>
<a name="ln3914"> </a>
<a name="ln3915">  // Lambda: {arg, arg -&gt; expr}</a>
<a name="ln3916">  // Dictionary: {'key': val, 'key': val}</a>
<a name="ln3917">  case '{':   ret = get_lambda_tv(arg, rettv, evaluate);</a>
<a name="ln3918">              if (ret == NOTDONE) {</a>
<a name="ln3919">                ret = dict_get_tv(arg, rettv, evaluate, false);</a>
<a name="ln3920">              }</a>
<a name="ln3921">    break;</a>
<a name="ln3922"> </a>
<a name="ln3923">  // Option value: &amp;name</a>
<a name="ln3924">  case '&amp;': {</a>
<a name="ln3925">    ret = get_option_tv((const char **)arg, rettv, evaluate);</a>
<a name="ln3926">    break;</a>
<a name="ln3927">  }</a>
<a name="ln3928">  // Environment variable: $VAR.</a>
<a name="ln3929">  case '$':   ret = get_env_tv(arg, rettv, evaluate);</a>
<a name="ln3930">    break;</a>
<a name="ln3931"> </a>
<a name="ln3932">  // Register contents: @r.</a>
<a name="ln3933">  case '@':   ++*arg;</a>
<a name="ln3934">    if (evaluate) {</a>
<a name="ln3935">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3936">      rettv-&gt;vval.v_string = get_reg_contents(**arg, kGRegExprSrc);</a>
<a name="ln3937">    }</a>
<a name="ln3938">    if (**arg != NUL) {</a>
<a name="ln3939">      ++*arg;</a>
<a name="ln3940">    }</a>
<a name="ln3941">    break;</a>
<a name="ln3942"> </a>
<a name="ln3943">  // nested expression: (expression).</a>
<a name="ln3944">  case '(':   *arg = skipwhite(*arg + 1);</a>
<a name="ln3945">    ret = eval1(arg, rettv, evaluate);                  // recursive!</a>
<a name="ln3946">    if (**arg == ')') {</a>
<a name="ln3947">      ++*arg;</a>
<a name="ln3948">    } else if (ret == OK) {</a>
<a name="ln3949">      EMSG(_(&quot;E110: Missing ')'&quot;));</a>
<a name="ln3950">      tv_clear(rettv);</a>
<a name="ln3951">      ret = FAIL;</a>
<a name="ln3952">    }</a>
<a name="ln3953">    break;</a>
<a name="ln3954"> </a>
<a name="ln3955">  default:    ret = NOTDONE;</a>
<a name="ln3956">    break;</a>
<a name="ln3957">  }</a>
<a name="ln3958"> </a>
<a name="ln3959">  if (ret == NOTDONE) {</a>
<a name="ln3960">    // Must be a variable or function name.</a>
<a name="ln3961">    // Can also be a curly-braces kind of name: {expr}.</a>
<a name="ln3962">    s = *arg;</a>
<a name="ln3963">    len = get_name_len((const char **)arg, (char **)&amp;alias, evaluate, true);</a>
<a name="ln3964">    if (alias != NULL) {</a>
<a name="ln3965">      s = alias;</a>
<a name="ln3966">    }</a>
<a name="ln3967"> </a>
<a name="ln3968">    if (len &lt;= 0) {</a>
<a name="ln3969">      ret = FAIL;</a>
<a name="ln3970">    } else {</a>
<a name="ln3971">      if (**arg == '(') {               // recursive!</a>
<a name="ln3972">        partial_T *partial;</a>
<a name="ln3973"> </a>
<a name="ln3974">        if (!evaluate) {</a>
<a name="ln3975">          check_vars((const char *)s, len);</a>
<a name="ln3976">        }</a>
<a name="ln3977"> </a>
<a name="ln3978">        // If &quot;s&quot; is the name of a variable of type VAR_FUNC</a>
<a name="ln3979">        // use its contents.</a>
<a name="ln3980">        s = deref_func_name((const char *)s, &amp;len, &amp;partial, !evaluate);</a>
<a name="ln3981"> </a>
<a name="ln3982">        // Need to make a copy, in case evaluating the arguments makes</a>
<a name="ln3983">        // the name invalid.</a>
<a name="ln3984">        s = xmemdupz(s, len);</a>
<a name="ln3985"> </a>
<a name="ln3986">        // Invoke the function.</a>
<a name="ln3987">        ret = get_func_tv(s, len, rettv, arg,</a>
<a name="ln3988">                          curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum,</a>
<a name="ln3989">                          &amp;len, evaluate, partial, NULL);</a>
<a name="ln3990"> </a>
<a name="ln3991">        xfree(s);</a>
<a name="ln3992"> </a>
<a name="ln3993">        // If evaluate is false rettv-&gt;v_type was not set in</a>
<a name="ln3994">        // get_func_tv, but it's needed in handle_subscript() to parse</a>
<a name="ln3995">        // what follows. So set it here.</a>
<a name="ln3996">        if (rettv-&gt;v_type == VAR_UNKNOWN &amp;&amp; !evaluate &amp;&amp; **arg == '(') {</a>
<a name="ln3997">          rettv-&gt;vval.v_string = (char_u *)tv_empty_string;</a>
<a name="ln3998">          rettv-&gt;v_type = VAR_FUNC;</a>
<a name="ln3999">        }</a>
<a name="ln4000"> </a>
<a name="ln4001">        // Stop the expression evaluation when immediately</a>
<a name="ln4002">        // aborting on error, or when an interrupt occurred or</a>
<a name="ln4003">        // an exception was thrown but not caught.</a>
<a name="ln4004">        if (evaluate &amp;&amp; aborting()) {</a>
<a name="ln4005">          if (ret == OK) {</a>
<a name="ln4006">            tv_clear(rettv);</a>
<a name="ln4007">          }</a>
<a name="ln4008">          ret = FAIL;</a>
<a name="ln4009">        }</a>
<a name="ln4010">      } else if (evaluate) {</a>
<a name="ln4011">        ret = get_var_tv((const char *)s, len, rettv, NULL, true, false);</a>
<a name="ln4012">      } else {</a>
<a name="ln4013">        check_vars((const char *)s, len);</a>
<a name="ln4014">        ret = OK;</a>
<a name="ln4015">      }</a>
<a name="ln4016">    }</a>
<a name="ln4017">    xfree(alias);</a>
<a name="ln4018">  }</a>
<a name="ln4019"> </a>
<a name="ln4020">  *arg = skipwhite(*arg);</a>
<a name="ln4021"> </a>
<a name="ln4022">  // Handle following '[', '(' and '.' for expr[expr], expr.name,</a>
<a name="ln4023">  // expr(expr).</a>
<a name="ln4024">  if (ret == OK) {</a>
<a name="ln4025">    ret = handle_subscript((const char **)arg, rettv, evaluate, true);</a>
<a name="ln4026">  }</a>
<a name="ln4027"> </a>
<a name="ln4028">  // Apply logical NOT and unary '-', from right to left, ignore '+'.</a>
<a name="ln4029">  if (ret == OK &amp;&amp; evaluate &amp;&amp; end_leader &gt; start_leader) {</a>
<a name="ln4030">    bool error = false;</a>
<a name="ln4031">    varnumber_T val = 0;</a>
<a name="ln4032">    float_T f = 0.0;</a>
<a name="ln4033"> </a>
<a name="ln4034">    if (rettv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln4035">      f = rettv-&gt;vval.v_float;</a>
<a name="ln4036">    } else {</a>
<a name="ln4037">      val = tv_get_number_chk(rettv, &amp;error);</a>
<a name="ln4038">    }</a>
<a name="ln4039">    if (error) {</a>
<a name="ln4040">      tv_clear(rettv);</a>
<a name="ln4041">      ret = FAIL;</a>
<a name="ln4042">    } else {</a>
<a name="ln4043">      while (end_leader &gt; start_leader) {</a>
<a name="ln4044">        --end_leader;</a>
<a name="ln4045">        if (*end_leader == '!') {</a>
<a name="ln4046">          if (rettv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln4047">            f = !f;</a>
<a name="ln4048">          } else {</a>
<a name="ln4049">            val = !val;</a>
<a name="ln4050">          }</a>
<a name="ln4051">        } else if (*end_leader == '-') {</a>
<a name="ln4052">          if (rettv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln4053">            f = -f;</a>
<a name="ln4054">          } else {</a>
<a name="ln4055">            val = -val;</a>
<a name="ln4056">          }</a>
<a name="ln4057">        }</a>
<a name="ln4058">      }</a>
<a name="ln4059">      if (rettv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln4060">        tv_clear(rettv);</a>
<a name="ln4061">        rettv-&gt;vval.v_float = f;</a>
<a name="ln4062">      } else {</a>
<a name="ln4063">        tv_clear(rettv);</a>
<a name="ln4064">        rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4065">        rettv-&gt;vval.v_number = val;</a>
<a name="ln4066">      }</a>
<a name="ln4067">    }</a>
<a name="ln4068">  }</a>
<a name="ln4069"> </a>
<a name="ln4070">  return ret;</a>
<a name="ln4071">}</a>
<a name="ln4072"> </a>
<a name="ln4073">// TODO(ZyX-I): move to eval/expressions</a>
<a name="ln4074"> </a>
<a name="ln4075">/*</a>
<a name="ln4076"> * Evaluate an &quot;[expr]&quot; or &quot;[expr:expr]&quot; index.  Also &quot;dict.key&quot;.</a>
<a name="ln4077"> * &quot;*arg&quot; points to the '[' or '.'.</a>
<a name="ln4078"> * Returns FAIL or OK. &quot;*arg&quot; is advanced to after the ']'.</a>
<a name="ln4079"> */</a>
<a name="ln4080">static int</a>
<a name="ln4081">eval_index(</a>
<a name="ln4082">    char_u **arg,</a>
<a name="ln4083">    typval_T *rettv,</a>
<a name="ln4084">    int evaluate,</a>
<a name="ln4085">    int verbose                    // give error messages</a>
<a name="ln4086">)</a>
<a name="ln4087">{</a>
<a name="ln4088">  bool empty1 = false;</a>
<a name="ln4089">  bool empty2 = false;</a>
<a name="ln4090">  long n1, n2 = 0;</a>
<a name="ln4091">  ptrdiff_t len = -1;</a>
<a name="ln4092">  int range = false;</a>
<a name="ln4093">  char_u      *key = NULL;</a>
<a name="ln4094"> </a>
<a name="ln4095">  switch (rettv-&gt;v_type) {</a>
<a name="ln4096">    case VAR_FUNC:</a>
<a name="ln4097">    case VAR_PARTIAL: {</a>
<a name="ln4098">      if (verbose) {</a>
<a name="ln4099">        EMSG(_(&quot;E695: Cannot index a Funcref&quot;));</a>
<a name="ln4100">      }</a>
<a name="ln4101">      return FAIL;</a>
<a name="ln4102">    }</a>
<a name="ln4103">    case VAR_FLOAT: {</a>
<a name="ln4104">      if (verbose) {</a>
<a name="ln4105">        EMSG(_(e_float_as_string));</a>
<a name="ln4106">      }</a>
<a name="ln4107">      return FAIL;</a>
<a name="ln4108">    }</a>
<a name="ln4109">    case VAR_BOOL:</a>
<a name="ln4110">    case VAR_SPECIAL: {</a>
<a name="ln4111">      if (verbose) {</a>
<a name="ln4112">        EMSG(_(&quot;E909: Cannot index a special variable&quot;));</a>
<a name="ln4113">      }</a>
<a name="ln4114">      return FAIL;</a>
<a name="ln4115">    }</a>
<a name="ln4116">    case VAR_UNKNOWN: {</a>
<a name="ln4117">      if (evaluate) {</a>
<a name="ln4118">        return FAIL;</a>
<a name="ln4119">      }</a>
<a name="ln4120">      FALLTHROUGH;</a>
<a name="ln4121">    }</a>
<a name="ln4122">    case VAR_STRING:</a>
<a name="ln4123">    case VAR_NUMBER:</a>
<a name="ln4124">    case VAR_LIST:</a>
<a name="ln4125">    case VAR_DICT: {</a>
<a name="ln4126">      break;</a>
<a name="ln4127">    }</a>
<a name="ln4128">  }</a>
<a name="ln4129"> </a>
<a name="ln4130">  typval_T var1 = TV_INITIAL_VALUE;</a>
<a name="ln4131">  typval_T var2 = TV_INITIAL_VALUE;</a>
<a name="ln4132">  if (**arg == '.') {</a>
<a name="ln4133">    /*</a>
<a name="ln4134">     * dict.name</a>
<a name="ln4135">     */</a>
<a name="ln4136">    key = *arg + 1;</a>
<a name="ln4137">    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)</a>
<a name="ln4138">      ;</a>
<a name="ln4139">    if (len == 0)</a>
<a name="ln4140">      return FAIL;</a>
<a name="ln4141">    *arg = skipwhite(key + len);</a>
<a name="ln4142">  } else {</a>
<a name="ln4143">    /*</a>
<a name="ln4144">     * something[idx]</a>
<a name="ln4145">     *</a>
<a name="ln4146">     * Get the (first) variable from inside the [].</a>
<a name="ln4147">     */</a>
<a name="ln4148">    *arg = skipwhite(*arg + 1);</a>
<a name="ln4149">    if (**arg == ':') {</a>
<a name="ln4150">      empty1 = true;</a>
<a name="ln4151">    } else if (eval1(arg, &amp;var1, evaluate) == FAIL) {  // Recursive!</a>
<a name="ln4152">      return FAIL;</a>
<a name="ln4153">    } else if (evaluate &amp;&amp; !tv_check_str(&amp;var1)) {</a>
<a name="ln4154">      // Not a number or string.</a>
<a name="ln4155">      tv_clear(&amp;var1);</a>
<a name="ln4156">      return FAIL;</a>
<a name="ln4157">    }</a>
<a name="ln4158"> </a>
<a name="ln4159">    /*</a>
<a name="ln4160">     * Get the second variable from inside the [:].</a>
<a name="ln4161">     */</a>
<a name="ln4162">    if (**arg == ':') {</a>
<a name="ln4163">      range = TRUE;</a>
<a name="ln4164">      *arg = skipwhite(*arg + 1);</a>
<a name="ln4165">      if (**arg == ']') {</a>
<a name="ln4166">        empty2 = true;</a>
<a name="ln4167">      } else if (eval1(arg, &amp;var2, evaluate) == FAIL) {  // Recursive!</a>
<a name="ln4168">        if (!empty1) {</a>
<a name="ln4169">          tv_clear(&amp;var1);</a>
<a name="ln4170">        }</a>
<a name="ln4171">        return FAIL;</a>
<a name="ln4172">      } else if (evaluate &amp;&amp; !tv_check_str(&amp;var2)) {</a>
<a name="ln4173">        // Not a number or string.</a>
<a name="ln4174">        if (!empty1) {</a>
<a name="ln4175">          tv_clear(&amp;var1);</a>
<a name="ln4176">        }</a>
<a name="ln4177">        tv_clear(&amp;var2);</a>
<a name="ln4178">        return FAIL;</a>
<a name="ln4179">      }</a>
<a name="ln4180">    }</a>
<a name="ln4181"> </a>
<a name="ln4182">    // Check for the ']'.</a>
<a name="ln4183">    if (**arg != ']') {</a>
<a name="ln4184">      if (verbose) {</a>
<a name="ln4185">        EMSG(_(e_missbrac));</a>
<a name="ln4186">      }</a>
<a name="ln4187">      tv_clear(&amp;var1);</a>
<a name="ln4188">      if (range) {</a>
<a name="ln4189">        tv_clear(&amp;var2);</a>
<a name="ln4190">      }</a>
<a name="ln4191">      return FAIL;</a>
<a name="ln4192">    }</a>
<a name="ln4193">    *arg = skipwhite(*arg + 1);         // skip the ']'</a>
<a name="ln4194">  }</a>
<a name="ln4195"> </a>
<a name="ln4196">  if (evaluate) {</a>
<a name="ln4197">    n1 = 0;</a>
<a name="ln4198">    if (!empty1 &amp;&amp; rettv-&gt;v_type != VAR_DICT &amp;&amp; !tv_is_luafunc(rettv)) {</a>
<a name="ln4199">      n1 = tv_get_number(&amp;var1);</a>
<a name="ln4200">      tv_clear(&amp;var1);</a>
<a name="ln4201">    }</a>
<a name="ln4202">    if (range) {</a>
<a name="ln4203">      if (empty2) {</a>
<a name="ln4204">        n2 = -1;</a>
<a name="ln4205">      } else {</a>
<a name="ln4206">        n2 = tv_get_number(&amp;var2);</a>
<a name="ln4207">        tv_clear(&amp;var2);</a>
<a name="ln4208">      }</a>
<a name="ln4209">    }</a>
<a name="ln4210"> </a>
<a name="ln4211">    switch (rettv-&gt;v_type) {</a>
<a name="ln4212">      case VAR_NUMBER:</a>
<a name="ln4213">      case VAR_STRING: {</a>
<a name="ln4214">        const char *const s = tv_get_string(rettv);</a>
<a name="ln4215">        char *v;</a>
<a name="ln4216">        len = (ptrdiff_t)strlen(s);</a>
<a name="ln4217">        if (range) {</a>
<a name="ln4218">          // The resulting variable is a substring.  If the indexes</a>
<a name="ln4219">          // are out of range the result is empty.</a>
<a name="ln4220">          if (n1 &lt; 0) {</a>
<a name="ln4221">            n1 = len + n1;</a>
<a name="ln4222">            if (n1 &lt; 0) {</a>
<a name="ln4223">              n1 = 0;</a>
<a name="ln4224">            }</a>
<a name="ln4225">          }</a>
<a name="ln4226">          if (n2 &lt; 0) {</a>
<a name="ln4227">            n2 = len + n2;</a>
<a name="ln4228">          } else if (n2 &gt;= len) {</a>
<a name="ln4229">            n2 = len;</a>
<a name="ln4230">          }</a>
<a name="ln4231">          if (n1 &gt;= len || n2 &lt; 0 || n1 &gt; n2) {</a>
<a name="ln4232">            v = NULL;</a>
<a name="ln4233">          } else {</a>
<a name="ln4234">            v = xmemdupz(s + n1, (size_t)(n2 - n1 + 1));</a>
<a name="ln4235">          }</a>
<a name="ln4236">        } else {</a>
<a name="ln4237">          // The resulting variable is a string of a single</a>
<a name="ln4238">          // character.  If the index is too big or negative the</a>
<a name="ln4239">          // result is empty.</a>
<a name="ln4240">          if (n1 &gt;= len || n1 &lt; 0) {</a>
<a name="ln4241">            v = NULL;</a>
<a name="ln4242">          } else {</a>
<a name="ln4243">            v = xmemdupz(s + n1, 1);</a>
<a name="ln4244">          }</a>
<a name="ln4245">        }</a>
<a name="ln4246">        tv_clear(rettv);</a>
<a name="ln4247">        rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4248">        rettv-&gt;vval.v_string = (char_u *)v;</a>
<a name="ln4249">        break;</a>
<a name="ln4250">      }</a>
<a name="ln4251">      case VAR_LIST: {</a>
<a name="ln4252">        len = tv_list_len(rettv-&gt;vval.v_list);</a>
<a name="ln4253">        if (n1 &lt; 0) {</a>
<a name="ln4254">          n1 = len + n1;</a>
<a name="ln4255">        }</a>
<a name="ln4256">        if (!empty1 &amp;&amp; (n1 &lt; 0 || n1 &gt;= len)) {</a>
<a name="ln4257">          // For a range we allow invalid values and return an empty</a>
<a name="ln4258">          // list.  A list index out of range is an error.</a>
<a name="ln4259">          if (!range) {</a>
<a name="ln4260">            if (verbose) {</a>
<a name="ln4261">              EMSGN(_(e_listidx), n1);</a>
<a name="ln4262">            }</a>
<a name="ln4263">            return FAIL;</a>
<a name="ln4264">          }</a>
<a name="ln4265">          n1 = len;</a>
<a name="ln4266">        }</a>
<a name="ln4267">        if (range) {</a>
<a name="ln4268">          list_T      *l;</a>
<a name="ln4269">          listitem_T  *item;</a>
<a name="ln4270"> </a>
<a name="ln4271">          if (n2 &lt; 0) {</a>
<a name="ln4272">            n2 = len + n2;</a>
<a name="ln4273">          } else if (n2 &gt;= len) {</a>
<a name="ln4274">            n2 = len - 1;</a>
<a name="ln4275">          }</a>
<a name="ln4276">          if (!empty2 &amp;&amp; (n2 &lt; 0 || n2 + 1 &lt; n1)) {</a>
<a name="ln4277">            n2 = -1;</a>
<a name="ln4278">          }</a>
<a name="ln4279">          l = tv_list_alloc(n2 - n1 + 1);</a>
<a name="ln4280">          item = tv_list_find(rettv-&gt;vval.v_list, n1);</a>
<a name="ln4281">          while (n1++ &lt;= n2) {</a>
<a name="ln4282">            tv_list_append_tv(l, TV_LIST_ITEM_TV(item));</a>
<a name="ln4283">            item = TV_LIST_ITEM_NEXT(rettv-&gt;vval.v_list, item);</a>
<a name="ln4284">          }</a>
<a name="ln4285">          tv_clear(rettv);</a>
<a name="ln4286">          tv_list_set_ret(rettv, l);</a>
<a name="ln4287">        } else {</a>
<a name="ln4288">          tv_copy(TV_LIST_ITEM_TV(tv_list_find(rettv-&gt;vval.v_list, n1)), &amp;var1);</a>
<a name="ln4289">          tv_clear(rettv);</a>
<a name="ln4290">          *rettv = var1;</a>
<a name="ln4291">        }</a>
<a name="ln4292">        break;</a>
<a name="ln4293">      }</a>
<a name="ln4294">      case VAR_DICT: {</a>
<a name="ln4295">        if (range) {</a>
<a name="ln4296">          if (verbose) {</a>
<a name="ln4297">            EMSG(_(e_dictrange));</a>
<a name="ln4298">          }</a>
<a name="ln4299">          if (len == -1) {</a>
<a name="ln4300">            tv_clear(&amp;var1);</a>
<a name="ln4301">          }</a>
<a name="ln4302">          return FAIL;</a>
<a name="ln4303">        }</a>
<a name="ln4304"> </a>
<a name="ln4305">        if (len == -1) {</a>
<a name="ln4306">          key = (char_u *)tv_get_string_chk(&amp;var1);</a>
<a name="ln4307">          if (key == NULL) {</a>
<a name="ln4308">            tv_clear(&amp;var1);</a>
<a name="ln4309">            return FAIL;</a>
<a name="ln4310">          }</a>
<a name="ln4311">        }</a>
<a name="ln4312"> </a>
<a name="ln4313">        dictitem_T *const item = tv_dict_find(rettv-&gt;vval.v_dict,</a>
<a name="ln4314">                                              (const char *)key, len);</a>
<a name="ln4315"> </a>
<a name="ln4316">        if (item == NULL &amp;&amp; verbose) {</a>
<a name="ln4317">          emsgf(_(e_dictkey), key);</a>
<a name="ln4318">        }</a>
<a name="ln4319">        if (len == -1) {</a>
<a name="ln4320">          tv_clear(&amp;var1);</a>
<a name="ln4321">        }</a>
<a name="ln4322">        if (item == NULL || tv_is_luafunc(&amp;item-&gt;di_tv)) {</a>
<a name="ln4323">          return FAIL;</a>
<a name="ln4324">        }</a>
<a name="ln4325"> </a>
<a name="ln4326">        tv_copy(&amp;item-&gt;di_tv, &amp;var1);</a>
<a name="ln4327">        tv_clear(rettv);</a>
<a name="ln4328">        *rettv = var1;</a>
<a name="ln4329">        break;</a>
<a name="ln4330">      }</a>
<a name="ln4331">      case VAR_BOOL:</a>
<a name="ln4332">      case VAR_SPECIAL:</a>
<a name="ln4333">      case VAR_FUNC:</a>
<a name="ln4334">      case VAR_FLOAT:</a>
<a name="ln4335">      case VAR_PARTIAL:</a>
<a name="ln4336">      case VAR_UNKNOWN: {</a>
<a name="ln4337">        break;  // Not evaluating, skipping over subscript</a>
<a name="ln4338">      }</a>
<a name="ln4339">    }</a>
<a name="ln4340">  }</a>
<a name="ln4341"> </a>
<a name="ln4342">  return OK;</a>
<a name="ln4343">}</a>
<a name="ln4344"> </a>
<a name="ln4345">// TODO(ZyX-I): move to eval/executor</a>
<a name="ln4346"> </a>
<a name="ln4347">/// Get an option value</a>
<a name="ln4348">///</a>
<a name="ln4349">/// @param[in,out]  arg  Points to the '&amp;' or '+' before the option name. Is</a>
<a name="ln4350">///                      advanced to the character after the option name.</a>
<a name="ln4351">/// @param[out]  rettv  Location where result is saved.</a>
<a name="ln4352">/// @param[in]  evaluate  If not true, rettv is not populated.</a>
<a name="ln4353">///</a>
<a name="ln4354">/// @return OK or FAIL.</a>
<a name="ln4355">int get_option_tv(const char **const arg, typval_T *const rettv,</a>
<a name="ln4356">                  const bool evaluate)</a>
<a name="ln4357">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln4358">{</a>
<a name="ln4359">  long numval;</a>
<a name="ln4360">  char_u      *stringval;</a>
<a name="ln4361">  int opt_type;</a>
<a name="ln4362">  int c;</a>
<a name="ln4363">  bool working = (**arg == '+');  // has(&quot;+option&quot;)</a>
<a name="ln4364">  int ret = OK;</a>
<a name="ln4365">  int opt_flags;</a>
<a name="ln4366"> </a>
<a name="ln4367">  // Isolate the option name and find its value.</a>
<a name="ln4368">  char *option_end = (char *)find_option_end(arg, &amp;opt_flags);</a>
<a name="ln4369">  if (option_end == NULL) {</a>
<a name="ln4370">    if (rettv != NULL) {</a>
<a name="ln4371">      EMSG2(_(&quot;E112: Option name missing: %s&quot;), *arg);</a>
<a name="ln4372">    }</a>
<a name="ln4373">    return FAIL;</a>
<a name="ln4374">  }</a>
<a name="ln4375"> </a>
<a name="ln4376">  if (!evaluate) {</a>
<a name="ln4377">    *arg = option_end;</a>
<a name="ln4378">    return OK;</a>
<a name="ln4379">  }</a>
<a name="ln4380"> </a>
<a name="ln4381">  c = *option_end;</a>
<a name="ln4382">  *option_end = NUL;</a>
<a name="ln4383">  opt_type = get_option_value(*arg, &amp;numval,</a>
<a name="ln4384">                              rettv == NULL ? NULL : &amp;stringval, opt_flags);</a>
<a name="ln4385"> </a>
<a name="ln4386">  if (opt_type == -3) {                 // invalid name</a>
<a name="ln4387">    if (rettv != NULL) {</a>
<a name="ln4388">      EMSG2(_(&quot;E113: Unknown option: %s&quot;), *arg);</a>
<a name="ln4389">    }</a>
<a name="ln4390">    ret = FAIL;</a>
<a name="ln4391">  } else if (rettv != NULL)   {</a>
<a name="ln4392">    if (opt_type == -2) {               // hidden string option</a>
<a name="ln4393">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4394">      rettv-&gt;vval.v_string = NULL;</a>
<a name="ln4395">    } else if (opt_type == -1) {      // hidden number option</a>
<a name="ln4396">      rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4397">      rettv-&gt;vval.v_number = 0;</a>
<a name="ln4398">    } else if (opt_type == 1) {       // number option</a>
<a name="ln4399">      rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln4400">      rettv-&gt;vval.v_number = numval;</a>
<a name="ln4401">    } else {                          // string option</a>
<a name="ln4402">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4403">      rettv-&gt;vval.v_string = stringval;</a>
<a name="ln4404">    }</a>
<a name="ln4405">  } else if (working &amp;&amp; (opt_type == -2 || opt_type == -1))</a>
<a name="ln4406">    ret = FAIL;</a>
<a name="ln4407"> </a>
<a name="ln4408">  *option_end = c;                  // put back for error messages</a>
<a name="ln4409">  *arg = option_end;</a>
<a name="ln4410"> </a>
<a name="ln4411">  return ret;</a>
<a name="ln4412">}</a>
<a name="ln4413"> </a>
<a name="ln4414">/*</a>
<a name="ln4415"> * Allocate a variable for a string constant.</a>
<a name="ln4416"> * Return OK or FAIL.</a>
<a name="ln4417"> */</a>
<a name="ln4418">static int get_string_tv(char_u **arg, typval_T *rettv, int evaluate)</a>
<a name="ln4419">{</a>
<a name="ln4420">  char_u      *p;</a>
<a name="ln4421">  unsigned int extra = 0;</a>
<a name="ln4422"> </a>
<a name="ln4423">  /*</a>
<a name="ln4424">   * Find the end of the string, skipping backslashed characters.</a>
<a name="ln4425">   */</a>
<a name="ln4426">  for (p = *arg + 1; *p != NUL &amp;&amp; *p != '&quot;'; MB_PTR_ADV(p)) {</a>
<a name="ln4427">    if (*p == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln4428">      p++;</a>
<a name="ln4429">      // A &quot;\&lt;x&gt;&quot; form occupies at least 4 characters, and produces up</a>
<a name="ln4430">      // to 21 characters (3 * 6 for the char and 3 for a modifier):</a>
<a name="ln4431">      // reserve space for 18 extra.</a>
<a name="ln4432">      // Each byte in the char could be encoded as K_SPECIAL K_EXTRA x.</a>
<a name="ln4433">      if (*p == '&lt;') {</a>
<a name="ln4434">        extra += 18;</a>
<a name="ln4435">      }</a>
<a name="ln4436">    }</a>
<a name="ln4437">  }</a>
<a name="ln4438"> </a>
<a name="ln4439">  if (*p != '&quot;') {</a>
<a name="ln4440">    EMSG2(_(&quot;E114: Missing quote: %s&quot;), *arg);</a>
<a name="ln4441">    return FAIL;</a>
<a name="ln4442">  }</a>
<a name="ln4443"> </a>
<a name="ln4444">  // If only parsing, set *arg and return here</a>
<a name="ln4445">  if (!evaluate) {</a>
<a name="ln4446">    *arg = p + 1;</a>
<a name="ln4447">    return OK;</a>
<a name="ln4448">  }</a>
<a name="ln4449"> </a>
<a name="ln4450">  /*</a>
<a name="ln4451">   * Copy the string into allocated memory, handling backslashed</a>
<a name="ln4452">   * characters.</a>
<a name="ln4453">   */</a>
<a name="ln4454">  const int len = (int)(p - *arg + extra);</a>
<a name="ln4455">  char_u *name = xmalloc(len);</a>
<a name="ln4456">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4457">  rettv-&gt;vval.v_string = name;</a>
<a name="ln4458"> </a>
<a name="ln4459">  for (p = *arg + 1; *p != NUL &amp;&amp; *p != '&quot;'; ) {</a>
<a name="ln4460">    if (*p == '\\') {</a>
<a name="ln4461">      switch (*++p) {</a>
<a name="ln4462">      case 'b': *name++ = BS; ++p; break;</a>
<a name="ln4463">      case 'e': *name++ = ESC; ++p; break;</a>
<a name="ln4464">      case 'f': *name++ = FF; ++p; break;</a>
<a name="ln4465">      case 'n': *name++ = NL; ++p; break;</a>
<a name="ln4466">      case 'r': *name++ = CAR; ++p; break;</a>
<a name="ln4467">      case 't': *name++ = TAB; ++p; break;</a>
<a name="ln4468"> </a>
<a name="ln4469">      case 'X':           // hex: &quot;\x1&quot;, &quot;\x12&quot;</a>
<a name="ln4470">      case 'x':</a>
<a name="ln4471">      case 'u':           // Unicode: &quot;\u0023&quot;</a>
<a name="ln4472">      case 'U':</a>
<a name="ln4473">        if (ascii_isxdigit(p[1])) {</a>
<a name="ln4474">          int n, nr;</a>
<a name="ln4475">          int c = toupper(*p);</a>
<a name="ln4476"> </a>
<a name="ln4477">          if (c == 'X') {</a>
<a name="ln4478">            n = 2;</a>
<a name="ln4479">          } else if (*p == 'u') {</a>
<a name="ln4480">            n = 4;</a>
<a name="ln4481">          } else {</a>
<a name="ln4482">            n = 8;</a>
<a name="ln4483">          }</a>
<a name="ln4484">          nr = 0;</a>
<a name="ln4485">          while (--n &gt;= 0 &amp;&amp; ascii_isxdigit(p[1])) {</a>
<a name="ln4486">            ++p;</a>
<a name="ln4487">            nr = (nr &lt;&lt; 4) + hex2nr(*p);</a>
<a name="ln4488">          }</a>
<a name="ln4489">          ++p;</a>
<a name="ln4490">          /* For &quot;\u&quot; store the number according to</a>
<a name="ln4491">           * 'encoding'. */</a>
<a name="ln4492">          if (c != 'X') {</a>
<a name="ln4493">            name += utf_char2bytes(nr, name);</a>
<a name="ln4494">          } else {</a>
<a name="ln4495">            *name++ = nr;</a>
<a name="ln4496">          }</a>
<a name="ln4497">        }</a>
<a name="ln4498">        break;</a>
<a name="ln4499"> </a>
<a name="ln4500">      // octal: &quot;\1&quot;, &quot;\12&quot;, &quot;\123&quot;</a>
<a name="ln4501">      case '0':</a>
<a name="ln4502">      case '1':</a>
<a name="ln4503">      case '2':</a>
<a name="ln4504">      case '3':</a>
<a name="ln4505">      case '4':</a>
<a name="ln4506">      case '5':</a>
<a name="ln4507">      case '6':</a>
<a name="ln4508">      case '7': *name = *p++ - '0';</a>
<a name="ln4509">        if (*p &gt;= '0' &amp;&amp; *p &lt;= '7') {</a>
<a name="ln4510">          *name = (*name &lt;&lt; 3) + *p++ - '0';</a>
<a name="ln4511">          if (*p &gt;= '0' &amp;&amp; *p &lt;= '7')</a>
<a name="ln4512">            *name = (*name &lt;&lt; 3) + *p++ - '0';</a>
<a name="ln4513">        }</a>
<a name="ln4514">        ++name;</a>
<a name="ln4515">        break;</a>
<a name="ln4516"> </a>
<a name="ln4517">      // Special key, e.g.: &quot;\&lt;C-W&gt;&quot;</a>
<a name="ln4518">      case '&lt;':</a>
<a name="ln4519">        extra = trans_special((const char_u **)&amp;p, STRLEN(p), name, true, true);</a>
<a name="ln4520">        if (extra != 0) {</a>
<a name="ln4521">          name += extra;</a>
<a name="ln4522">          if (name &gt;= rettv-&gt;vval.v_string + len) {</a>
<a name="ln4523">            iemsg(&quot;get_string_tv() used more space than allocated&quot;);</a>
<a name="ln4524">          }</a>
<a name="ln4525">          break;</a>
<a name="ln4526">        }</a>
<a name="ln4527">        FALLTHROUGH;</a>
<a name="ln4528"> </a>
<a name="ln4529">      default:  MB_COPY_CHAR(p, name);</a>
<a name="ln4530">        break;</a>
<a name="ln4531">      }</a>
<a name="ln4532">    } else</a>
<a name="ln4533">      MB_COPY_CHAR(p, name);</a>
<a name="ln4534"> </a>
<a name="ln4535">  }</a>
<a name="ln4536">  *name = NUL;</a>
<a name="ln4537">  if (*p != NUL) {  // just in case</a>
<a name="ln4538">    p++;</a>
<a name="ln4539">  }</a>
<a name="ln4540">  *arg = p;</a>
<a name="ln4541"> </a>
<a name="ln4542">  return OK;</a>
<a name="ln4543">}</a>
<a name="ln4544"> </a>
<a name="ln4545">/*</a>
<a name="ln4546"> * Allocate a variable for a 'str''ing' constant.</a>
<a name="ln4547"> * Return OK or FAIL.</a>
<a name="ln4548"> */</a>
<a name="ln4549">static int get_lit_string_tv(char_u **arg, typval_T *rettv, int evaluate)</a>
<a name="ln4550">{</a>
<a name="ln4551">  char_u      *p;</a>
<a name="ln4552">  char_u      *str;</a>
<a name="ln4553">  int reduce = 0;</a>
<a name="ln4554"> </a>
<a name="ln4555">  /*</a>
<a name="ln4556">   * Find the end of the string, skipping ''.</a>
<a name="ln4557">   */</a>
<a name="ln4558">  for (p = *arg + 1; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln4559">    if (*p == '\'') {</a>
<a name="ln4560">      if (p[1] != '\'')</a>
<a name="ln4561">        break;</a>
<a name="ln4562">      ++reduce;</a>
<a name="ln4563">      ++p;</a>
<a name="ln4564">    }</a>
<a name="ln4565">  }</a>
<a name="ln4566"> </a>
<a name="ln4567">  if (*p != '\'') {</a>
<a name="ln4568">    EMSG2(_(&quot;E115: Missing quote: %s&quot;), *arg);</a>
<a name="ln4569">    return FAIL;</a>
<a name="ln4570">  }</a>
<a name="ln4571"> </a>
<a name="ln4572">  // If only parsing return after setting &quot;*arg&quot;</a>
<a name="ln4573">  if (!evaluate) {</a>
<a name="ln4574">    *arg = p + 1;</a>
<a name="ln4575">    return OK;</a>
<a name="ln4576">  }</a>
<a name="ln4577"> </a>
<a name="ln4578">  /*</a>
<a name="ln4579">   * Copy the string into allocated memory, handling '' to ' reduction.</a>
<a name="ln4580">   */</a>
<a name="ln4581">  str = xmalloc((p - *arg) - reduce);</a>
<a name="ln4582">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4583">  rettv-&gt;vval.v_string = str;</a>
<a name="ln4584"> </a>
<a name="ln4585">  for (p = *arg + 1; *p != NUL; ) {</a>
<a name="ln4586">    if (*p == '\'') {</a>
<a name="ln4587">      if (p[1] != '\'')</a>
<a name="ln4588">        break;</a>
<a name="ln4589">      ++p;</a>
<a name="ln4590">    }</a>
<a name="ln4591">    MB_COPY_CHAR(p, str);</a>
<a name="ln4592">  }</a>
<a name="ln4593">  *str = NUL;</a>
<a name="ln4594">  *arg = p + 1;</a>
<a name="ln4595"> </a>
<a name="ln4596">  return OK;</a>
<a name="ln4597">}</a>
<a name="ln4598"> </a>
<a name="ln4599">/// @return the function name of the partial.</a>
<a name="ln4600">char_u *partial_name(partial_T *pt)</a>
<a name="ln4601">{</a>
<a name="ln4602">  if (pt-&gt;pt_name != NULL) {</a>
<a name="ln4603">    return pt-&gt;pt_name;</a>
<a name="ln4604">  }</a>
<a name="ln4605">  return pt-&gt;pt_func-&gt;uf_name;</a>
<a name="ln4606">}</a>
<a name="ln4607"> </a>
<a name="ln4608">// TODO(ZyX-I): Move to eval/typval.h</a>
<a name="ln4609"> </a>
<a name="ln4610">static void partial_free(partial_T *pt)</a>
<a name="ln4611">{</a>
<a name="ln4612">  for (int i = 0; i &lt; pt-&gt;pt_argc; i++) {</a>
<a name="ln4613">    tv_clear(&amp;pt-&gt;pt_argv[i]);</a>
<a name="ln4614">  }</a>
<a name="ln4615">  xfree(pt-&gt;pt_argv);</a>
<a name="ln4616">  tv_dict_unref(pt-&gt;pt_dict);</a>
<a name="ln4617">  if (pt-&gt;pt_name != NULL) {</a>
<a name="ln4618">    func_unref(pt-&gt;pt_name);</a>
<a name="ln4619">    xfree(pt-&gt;pt_name);</a>
<a name="ln4620">  } else {</a>
<a name="ln4621">    func_ptr_unref(pt-&gt;pt_func);</a>
<a name="ln4622">  }</a>
<a name="ln4623">  xfree(pt);</a>
<a name="ln4624">}</a>
<a name="ln4625"> </a>
<a name="ln4626">// TODO(ZyX-I): Move to eval/typval.h</a>
<a name="ln4627"> </a>
<a name="ln4628">/// Unreference a closure: decrement the reference count and free it when it</a>
<a name="ln4629">/// becomes zero.</a>
<a name="ln4630">void partial_unref(partial_T *pt)</a>
<a name="ln4631">{</a>
<a name="ln4632">  if (pt != NULL &amp;&amp; --pt-&gt;pt_refcount &lt;= 0) {</a>
<a name="ln4633">    partial_free(pt);</a>
<a name="ln4634">  }</a>
<a name="ln4635">}</a>
<a name="ln4636"> </a>
<a name="ln4637">/// Allocate a variable for a List and fill it from &quot;*arg&quot;.</a>
<a name="ln4638">/// Return OK or FAIL.</a>
<a name="ln4639">static int get_list_tv(char_u **arg, typval_T *rettv, int evaluate)</a>
<a name="ln4640">{</a>
<a name="ln4641">  list_T      *l = NULL;</a>
<a name="ln4642"> </a>
<a name="ln4643">  if (evaluate) {</a>
<a name="ln4644">    l = tv_list_alloc(kListLenShouldKnow);</a>
<a name="ln4645">  }</a>
<a name="ln4646"> </a>
<a name="ln4647">  *arg = skipwhite(*arg + 1);</a>
<a name="ln4648">  while (**arg != ']' &amp;&amp; **arg != NUL) {</a>
<a name="ln4649">    typval_T tv;</a>
<a name="ln4650">    if (eval1(arg, &amp;tv, evaluate) == FAIL) {  // Recursive!</a>
<a name="ln4651">      goto failret;</a>
<a name="ln4652">    }</a>
<a name="ln4653">    if (evaluate) {</a>
<a name="ln4654">      tv.v_lock = VAR_UNLOCKED;</a>
<a name="ln4655">      tv_list_append_owned_tv(l, tv);</a>
<a name="ln4656">    }</a>
<a name="ln4657"> </a>
<a name="ln4658">    if (**arg == ']') {</a>
<a name="ln4659">      break;</a>
<a name="ln4660">    }</a>
<a name="ln4661">    if (**arg != ',') {</a>
<a name="ln4662">      emsgf(_(&quot;E696: Missing comma in List: %s&quot;), *arg);</a>
<a name="ln4663">      goto failret;</a>
<a name="ln4664">    }</a>
<a name="ln4665">    *arg = skipwhite(*arg + 1);</a>
<a name="ln4666">  }</a>
<a name="ln4667"> </a>
<a name="ln4668">  if (**arg != ']') {</a>
<a name="ln4669">    emsgf(_(&quot;E697: Missing end of List ']': %s&quot;), *arg);</a>
<a name="ln4670">failret:</a>
<a name="ln4671">    if (evaluate) {</a>
<a name="ln4672">      tv_list_free(l);</a>
<a name="ln4673">    }</a>
<a name="ln4674">    return FAIL;</a>
<a name="ln4675">  }</a>
<a name="ln4676"> </a>
<a name="ln4677">  *arg = skipwhite(*arg + 1);</a>
<a name="ln4678">  if (evaluate) {</a>
<a name="ln4679">    tv_list_set_ret(rettv, l);</a>
<a name="ln4680">  }</a>
<a name="ln4681"> </a>
<a name="ln4682">  return OK;</a>
<a name="ln4683">}</a>
<a name="ln4684"> </a>
<a name="ln4685">bool func_equal(</a>
<a name="ln4686">    typval_T *tv1,</a>
<a name="ln4687">    typval_T *tv2,</a>
<a name="ln4688">    bool ic         // ignore case</a>
<a name="ln4689">) {</a>
<a name="ln4690">  char_u *s1, *s2;</a>
<a name="ln4691">  dict_T *d1, *d2;</a>
<a name="ln4692">  int a1, a2;</a>
<a name="ln4693"> </a>
<a name="ln4694">  // empty and NULL function name considered the same</a>
<a name="ln4695">  s1 = tv1-&gt;v_type == VAR_FUNC ? tv1-&gt;vval.v_string</a>
<a name="ln4696">                     : partial_name(tv1-&gt;vval.v_partial);</a>
<a name="ln4697">  if (s1 != NULL &amp;&amp; *s1 == NUL) {</a>
<a name="ln4698">    s1 = NULL;</a>
<a name="ln4699">  }</a>
<a name="ln4700">  s2 = tv2-&gt;v_type == VAR_FUNC ? tv2-&gt;vval.v_string</a>
<a name="ln4701">                     : partial_name(tv2-&gt;vval.v_partial);</a>
<a name="ln4702">  if (s2 != NULL &amp;&amp; *s2 == NUL) {</a>
<a name="ln4703">    s2 = NULL;</a>
<a name="ln4704">  }</a>
<a name="ln4705">  if (s1 == NULL || s2 == NULL) {</a>
<a name="ln4706">    if (s1 != s2) {</a>
<a name="ln4707">      return false;</a>
<a name="ln4708">    }</a>
<a name="ln4709">  } else if (STRCMP(s1, s2) != 0) {</a>
<a name="ln4710">    return false;</a>
<a name="ln4711">  }</a>
<a name="ln4712"> </a>
<a name="ln4713">  // empty dict and NULL dict is different</a>
<a name="ln4714">  d1 = tv1-&gt;v_type == VAR_FUNC ? NULL : tv1-&gt;vval.v_partial-&gt;pt_dict;</a>
<a name="ln4715">  d2 = tv2-&gt;v_type == VAR_FUNC ? NULL : tv2-&gt;vval.v_partial-&gt;pt_dict;</a>
<a name="ln4716">  if (d1 == NULL || d2 == NULL) {</a>
<a name="ln4717">    if (d1 != d2) {</a>
<a name="ln4718">      return false;</a>
<a name="ln4719">    }</a>
<a name="ln4720">  } else if (!tv_dict_equal(d1, d2, ic, true)) {</a>
<a name="ln4721">    return false;</a>
<a name="ln4722">  }</a>
<a name="ln4723"> </a>
<a name="ln4724">  // empty list and no list considered the same</a>
<a name="ln4725">  a1 = tv1-&gt;v_type == VAR_FUNC ? 0 : tv1-&gt;vval.v_partial-&gt;pt_argc;</a>
<a name="ln4726">  a2 = tv2-&gt;v_type == VAR_FUNC ? 0 : tv2-&gt;vval.v_partial-&gt;pt_argc;</a>
<a name="ln4727">  if (a1 != a2) {</a>
<a name="ln4728">    return false;</a>
<a name="ln4729">  }</a>
<a name="ln4730">  for (int i = 0; i &lt; a1; i++) {</a>
<a name="ln4731">    if (!tv_equal(tv1-&gt;vval.v_partial-&gt;pt_argv + i,</a>
<a name="ln4732">                  tv2-&gt;vval.v_partial-&gt;pt_argv + i, ic, true)) {</a>
<a name="ln4733">      return false;</a>
<a name="ln4734">    }</a>
<a name="ln4735">  }</a>
<a name="ln4736">  return true;</a>
<a name="ln4737">}</a>
<a name="ln4738"> </a>
<a name="ln4739">/// Get next (unique) copy ID</a>
<a name="ln4740">///</a>
<a name="ln4741">/// Used for traversing nested structures e.g. when serializing them or garbage</a>
<a name="ln4742">/// collecting.</a>
<a name="ln4743">int get_copyID(void)</a>
<a name="ln4744">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4745">{</a>
<a name="ln4746">  // CopyID for recursively traversing lists and dicts</a>
<a name="ln4747">  //</a>
<a name="ln4748">  // This value is needed to avoid endless recursiveness. Last bit is used for</a>
<a name="ln4749">  // previous_funccal and normally ignored when comparing.</a>
<a name="ln4750">  static int current_copyID = 0;</a>
<a name="ln4751">  current_copyID += COPYID_INC;</a>
<a name="ln4752">  return current_copyID;</a>
<a name="ln4753">}</a>
<a name="ln4754"> </a>
<a name="ln4755">/*</a>
<a name="ln4756"> * Garbage collection for lists and dictionaries.</a>
<a name="ln4757"> *</a>
<a name="ln4758"> * We use reference counts to be able to free most items right away when they</a>
<a name="ln4759"> * are no longer used.  But for composite items it's possible that it becomes</a>
<a name="ln4760"> * unused while the reference count is &gt; 0: When there is a recursive</a>
<a name="ln4761"> * reference.  Example:</a>
<a name="ln4762"> *	:let l = [1, 2, 3]</a>
<a name="ln4763"> *	:let d = {9: l}</a>
<a name="ln4764"> *	:let l[1] = d</a>
<a name="ln4765"> *</a>
<a name="ln4766"> * Since this is quite unusual we handle this with garbage collection: every</a>
<a name="ln4767"> * once in a while find out which lists and dicts are not referenced from any</a>
<a name="ln4768"> * variable.</a>
<a name="ln4769"> *</a>
<a name="ln4770"> * Here is a good reference text about garbage collection (refers to Python</a>
<a name="ln4771"> * but it applies to all reference-counting mechanisms):</a>
<a name="ln4772"> *	http://python.ca/nas/python/gc/</a>
<a name="ln4773"> */</a>
<a name="ln4774"> </a>
<a name="ln4775">/// Do garbage collection for lists and dicts.</a>
<a name="ln4776">///</a>
<a name="ln4777">/// @param testing  true if called from test_garbagecollect_now().</a>
<a name="ln4778">/// @returns        true if some memory was freed.</a>
<a name="ln4779">bool garbage_collect(bool testing)</a>
<a name="ln4780">{</a>
<a name="ln4781">  bool abort = false;</a>
<a name="ln4782">#define ABORTING(func) abort = abort || func</a>
<a name="ln4783"> </a>
<a name="ln4784">  if (!testing) {</a>
<a name="ln4785">    // Only do this once.</a>
<a name="ln4786">    want_garbage_collect = false;</a>
<a name="ln4787">    may_garbage_collect = false;</a>
<a name="ln4788">    garbage_collect_at_exit = false;</a>
<a name="ln4789">  }</a>
<a name="ln4790"> </a>
<a name="ln4791">  // We advance by two (COPYID_INC) because we add one for items referenced</a>
<a name="ln4792">  // through previous_funccal.</a>
<a name="ln4793">  const int copyID = get_copyID();</a>
<a name="ln4794"> </a>
<a name="ln4795">  // 1. Go through all accessible variables and mark all lists and dicts</a>
<a name="ln4796">  // with copyID.</a>
<a name="ln4797"> </a>
<a name="ln4798">  // Don't free variables in the previous_funccal list unless they are only</a>
<a name="ln4799">  // referenced through previous_funccal.  This must be first, because if</a>
<a name="ln4800">  // the item is referenced elsewhere the funccal must not be freed.</a>
<a name="ln4801">  ABORTING(set_ref_in_previous_funccal)(copyID);</a>
<a name="ln4802"> </a>
<a name="ln4803">  // script-local variables</a>
<a name="ln4804">  for (int i = 1; i &lt;= ga_scripts.ga_len; ++i) {</a>
<a name="ln4805">    ABORTING(set_ref_in_ht)(&amp;SCRIPT_VARS(i), copyID, NULL);</a>
<a name="ln4806">  }</a>
<a name="ln4807"> </a>
<a name="ln4808">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln4809">    // buffer-local variables</a>
<a name="ln4810">    ABORTING(set_ref_in_item)(&amp;buf-&gt;b_bufvar.di_tv, copyID, NULL, NULL);</a>
<a name="ln4811">    // buffer marks (ShaDa additional data)</a>
<a name="ln4812">    ABORTING(set_ref_in_fmark)(buf-&gt;b_last_cursor, copyID);</a>
<a name="ln4813">    ABORTING(set_ref_in_fmark)(buf-&gt;b_last_insert, copyID);</a>
<a name="ln4814">    ABORTING(set_ref_in_fmark)(buf-&gt;b_last_change, copyID);</a>
<a name="ln4815">    for (size_t i = 0; i &lt; NMARKS; i++) {</a>
<a name="ln4816">      ABORTING(set_ref_in_fmark)(buf-&gt;b_namedm[i], copyID);</a>
<a name="ln4817">    }</a>
<a name="ln4818">    // buffer change list (ShaDa additional data)</a>
<a name="ln4819">    for (int i = 0; i &lt; buf-&gt;b_changelistlen; i++) {</a>
<a name="ln4820">      ABORTING(set_ref_in_fmark)(buf-&gt;b_changelist[i], copyID);</a>
<a name="ln4821">    }</a>
<a name="ln4822">    // buffer ShaDa additional data</a>
<a name="ln4823">    ABORTING(set_ref_dict)(buf-&gt;additional_data, copyID);</a>
<a name="ln4824"> </a>
<a name="ln4825">    // buffer callback functions</a>
<a name="ln4826">    set_ref_in_callback(&amp;buf-&gt;b_prompt_callback, copyID, NULL, NULL);</a>
<a name="ln4827">    set_ref_in_callback(&amp;buf-&gt;b_prompt_interrupt, copyID, NULL, NULL);</a>
<a name="ln4828">  }</a>
<a name="ln4829"> </a>
<a name="ln4830">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln4831">    // window-local variables</a>
<a name="ln4832">    ABORTING(set_ref_in_item)(&amp;wp-&gt;w_winvar.di_tv, copyID, NULL, NULL);</a>
<a name="ln4833">    // window jump list (ShaDa additional data)</a>
<a name="ln4834">    for (int i = 0; i &lt; wp-&gt;w_jumplistlen; i++) {</a>
<a name="ln4835">      ABORTING(set_ref_in_fmark)(wp-&gt;w_jumplist[i].fmark, copyID);</a>
<a name="ln4836">    }</a>
<a name="ln4837">  }</a>
<a name="ln4838">  if (aucmd_win != NULL) {</a>
<a name="ln4839">    ABORTING(set_ref_in_item)(&amp;aucmd_win-&gt;w_winvar.di_tv, copyID, NULL, NULL);</a>
<a name="ln4840">  }</a>
<a name="ln4841"> </a>
<a name="ln4842">  // registers (ShaDa additional data)</a>
<a name="ln4843">  {</a>
<a name="ln4844">    const void *reg_iter = NULL;</a>
<a name="ln4845">    do {</a>
<a name="ln4846">      yankreg_T reg;</a>
<a name="ln4847">      char name = NUL;</a>
<a name="ln4848">      bool is_unnamed = false;</a>
<a name="ln4849">      reg_iter = op_global_reg_iter(reg_iter, &amp;name, &amp;reg, &amp;is_unnamed);</a>
<a name="ln4850">      if (name != NUL) {</a>
<a name="ln4851">        ABORTING(set_ref_dict)(reg.additional_data, copyID);</a>
<a name="ln4852">      }</a>
<a name="ln4853">    } while (reg_iter != NULL);</a>
<a name="ln4854">  }</a>
<a name="ln4855"> </a>
<a name="ln4856">  // global marks (ShaDa additional data)</a>
<a name="ln4857">  {</a>
<a name="ln4858">    const void *mark_iter = NULL;</a>
<a name="ln4859">    do {</a>
<a name="ln4860">      xfmark_T fm;</a>
<a name="ln4861">      char name = NUL;</a>
<a name="ln4862">      mark_iter = mark_global_iter(mark_iter, &amp;name, &amp;fm);</a>
<a name="ln4863">      if (name != NUL) {</a>
<a name="ln4864">        ABORTING(set_ref_dict)(fm.fmark.additional_data, copyID);</a>
<a name="ln4865">      }</a>
<a name="ln4866">    } while (mark_iter != NULL);</a>
<a name="ln4867">  }</a>
<a name="ln4868"> </a>
<a name="ln4869">  // tabpage-local variables</a>
<a name="ln4870">  FOR_ALL_TABS(tp) {</a>
<a name="ln4871">    ABORTING(set_ref_in_item)(&amp;tp-&gt;tp_winvar.di_tv, copyID, NULL, NULL);</a>
<a name="ln4872">  }</a>
<a name="ln4873"> </a>
<a name="ln4874">  // global variables</a>
<a name="ln4875">  ABORTING(set_ref_in_ht)(&amp;globvarht, copyID, NULL);</a>
<a name="ln4876"> </a>
<a name="ln4877">  // function-local variables</a>
<a name="ln4878">  ABORTING(set_ref_in_call_stack)(copyID);</a>
<a name="ln4879"> </a>
<a name="ln4880">  // named functions (matters for closures)</a>
<a name="ln4881">  ABORTING(set_ref_in_functions)(copyID);</a>
<a name="ln4882"> </a>
<a name="ln4883">  // Channels</a>
<a name="ln4884">  {</a>
<a name="ln4885">    Channel *data;</a>
<a name="ln4886">    map_foreach_value(channels, data, {</a>
<a name="ln4887">      set_ref_in_callback_reader(&amp;data-&gt;on_data, copyID, NULL, NULL);</a>
<a name="ln4888">      set_ref_in_callback_reader(&amp;data-&gt;on_stderr, copyID, NULL, NULL);</a>
<a name="ln4889">      set_ref_in_callback(&amp;data-&gt;on_exit, copyID, NULL, NULL);</a>
<a name="ln4890">    })</a>
<a name="ln4891">  }</a>
<a name="ln4892"> </a>
<a name="ln4893">  // Timers</a>
<a name="ln4894">  {</a>
<a name="ln4895">    timer_T *timer;</a>
<a name="ln4896">    map_foreach_value(timers, timer, {</a>
<a name="ln4897">      set_ref_in_callback(&amp;timer-&gt;callback, copyID, NULL, NULL);</a>
<a name="ln4898">    })</a>
<a name="ln4899">  }</a>
<a name="ln4900"> </a>
<a name="ln4901">  // function call arguments, if v:testing is set.</a>
<a name="ln4902">  ABORTING(set_ref_in_func_args)(copyID);</a>
<a name="ln4903"> </a>
<a name="ln4904">  // v: vars</a>
<a name="ln4905">  ABORTING(set_ref_in_ht)(&amp;vimvarht, copyID, NULL);</a>
<a name="ln4906"> </a>
<a name="ln4907">  // history items (ShaDa additional elements)</a>
<a name="ln4908">  if (p_hi) {</a>
<a name="ln4909">    for (uint8_t i = 0; i &lt; HIST_COUNT; i++) {</a>
<a name="ln4910">      const void *iter = NULL;</a>
<a name="ln4911">      do {</a>
<a name="ln4912">        histentry_T hist;</a>
<a name="ln4913">        iter = hist_iter(iter, i, false, &amp;hist);</a>
<a name="ln4914">        if (hist.hisstr != NULL) {</a>
<a name="ln4915">          ABORTING(set_ref_list)(hist.additional_elements, copyID);</a>
<a name="ln4916">        }</a>
<a name="ln4917">      } while (iter != NULL);</a>
<a name="ln4918">    }</a>
<a name="ln4919">  }</a>
<a name="ln4920"> </a>
<a name="ln4921">  // previously used search/substitute patterns (ShaDa additional data)</a>
<a name="ln4922">  {</a>
<a name="ln4923">    SearchPattern pat;</a>
<a name="ln4924">    get_search_pattern(&amp;pat);</a>
<a name="ln4925">    ABORTING(set_ref_dict)(pat.additional_data, copyID);</a>
<a name="ln4926">    get_substitute_pattern(&amp;pat);</a>
<a name="ln4927">    ABORTING(set_ref_dict)(pat.additional_data, copyID);</a>
<a name="ln4928">  }</a>
<a name="ln4929"> </a>
<a name="ln4930">  // previously used replacement string</a>
<a name="ln4931">  {</a>
<a name="ln4932">    SubReplacementString sub;</a>
<a name="ln4933">    sub_get_replacement(&amp;sub);</a>
<a name="ln4934">    ABORTING(set_ref_list)(sub.additional_elements, copyID);</a>
<a name="ln4935">  }</a>
<a name="ln4936"> </a>
<a name="ln4937">  ABORTING(set_ref_in_quickfix)(copyID);</a>
<a name="ln4938"> </a>
<a name="ln4939">  bool did_free = false;</a>
<a name="ln4940">  if (!abort) {</a>
<a name="ln4941">    // 2. Free lists and dictionaries that are not referenced.</a>
<a name="ln4942">    did_free = free_unref_items(copyID);</a>
<a name="ln4943"> </a>
<a name="ln4944">    // 3. Check if any funccal can be freed now.</a>
<a name="ln4945">    //    This may call us back recursively.</a>
<a name="ln4946">    did_free = free_unref_funccal(copyID, testing) || did_free;</a>
<a name="ln4947">  } else if (p_verbose &gt; 0) {</a>
<a name="ln4948">    verb_msg(_(</a>
<a name="ln4949">        &quot;Not enough memory to set references, garbage collection aborted!&quot;));</a>
<a name="ln4950">  }</a>
<a name="ln4951">#undef ABORTING</a>
<a name="ln4952">  return did_free;</a>
<a name="ln4953">}</a>
<a name="ln4954"> </a>
<a name="ln4955">/// Free lists and dictionaries that are no longer referenced.</a>
<a name="ln4956">///</a>
<a name="ln4957">/// @note This function may only be called from garbage_collect().</a>
<a name="ln4958">///</a>
<a name="ln4959">/// @param copyID Free lists/dictionaries that don't have this ID.</a>
<a name="ln4960">/// @return true, if something was freed.</a>
<a name="ln4961">static int free_unref_items(int copyID)</a>
<a name="ln4962">{</a>
<a name="ln4963">  bool did_free = false;</a>
<a name="ln4964"> </a>
<a name="ln4965">  // Let all &quot;free&quot; functions know that we are here. This means no</a>
<a name="ln4966">  // dictionaries, lists, or jobs are to be freed, because we will</a>
<a name="ln4967">  // do that here.</a>
<a name="ln4968">  tv_in_free_unref_items = true;</a>
<a name="ln4969"> </a>
<a name="ln4970">  // PASS 1: free the contents of the items. We don't free the items</a>
<a name="ln4971">  // themselves yet, so that it is possible to decrement refcount counters.</a>
<a name="ln4972"> </a>
<a name="ln4973">  // Go through the list of dicts and free items without the copyID.</a>
<a name="ln4974">  // Don't free dicts that are referenced internally.</a>
<a name="ln4975">  for (dict_T *dd = gc_first_dict; dd != NULL; dd = dd-&gt;dv_used_next) {</a>
<a name="ln4976">    if ((dd-&gt;dv_copyID &amp; COPYID_MASK) != (copyID &amp; COPYID_MASK)) {</a>
<a name="ln4977">      // Free the Dictionary and ordinary items it contains, but don't</a>
<a name="ln4978">      // recurse into Lists and Dictionaries, they will be in the list</a>
<a name="ln4979">      // of dicts or list of lists.</a>
<a name="ln4980">      tv_dict_free_contents(dd);</a>
<a name="ln4981">      did_free = true;</a>
<a name="ln4982">    }</a>
<a name="ln4983">  }</a>
<a name="ln4984"> </a>
<a name="ln4985">  // Go through the list of lists and free items without the copyID.</a>
<a name="ln4986">  // But don't free a list that has a watcher (used in a for loop), these</a>
<a name="ln4987">  // are not referenced anywhere.</a>
<a name="ln4988">  for (list_T *ll = gc_first_list; ll != NULL; ll = ll-&gt;lv_used_next) {</a>
<a name="ln4989">    if ((tv_list_copyid(ll) &amp; COPYID_MASK) != (copyID &amp; COPYID_MASK)</a>
<a name="ln4990">        &amp;&amp; !tv_list_has_watchers(ll)) {</a>
<a name="ln4991">      // Free the List and ordinary items it contains, but don't recurse</a>
<a name="ln4992">      // into Lists and Dictionaries, they will be in the list of dicts</a>
<a name="ln4993">      // or list of lists.</a>
<a name="ln4994">      tv_list_free_contents(ll);</a>
<a name="ln4995">      did_free = true;</a>
<a name="ln4996">    }</a>
<a name="ln4997">  }</a>
<a name="ln4998"> </a>
<a name="ln4999">  // PASS 2: free the items themselves.</a>
<a name="ln5000">  dict_T *dd_next;</a>
<a name="ln5001">  for (dict_T *dd = gc_first_dict; dd != NULL; dd = dd_next) {</a>
<a name="ln5002">    dd_next = dd-&gt;dv_used_next;</a>
<a name="ln5003">    if ((dd-&gt;dv_copyID &amp; COPYID_MASK) != (copyID &amp; COPYID_MASK)) {</a>
<a name="ln5004">      tv_dict_free_dict(dd);</a>
<a name="ln5005">    }</a>
<a name="ln5006">  }</a>
<a name="ln5007"> </a>
<a name="ln5008">  list_T *ll_next;</a>
<a name="ln5009">  for (list_T *ll = gc_first_list; ll != NULL; ll = ll_next) {</a>
<a name="ln5010">    ll_next = ll-&gt;lv_used_next;</a>
<a name="ln5011">    if ((ll-&gt;lv_copyID &amp; COPYID_MASK) != (copyID &amp; COPYID_MASK)</a>
<a name="ln5012">        &amp;&amp; !tv_list_has_watchers(ll)) {</a>
<a name="ln5013">      // Free the List and ordinary items it contains, but don't recurse</a>
<a name="ln5014">      // into Lists and Dictionaries, they will be in the list of dicts</a>
<a name="ln5015">      // or list of lists.</a>
<a name="ln5016">      tv_list_free_list(ll);</a>
<a name="ln5017">    }</a>
<a name="ln5018">  }</a>
<a name="ln5019">  tv_in_free_unref_items = false;</a>
<a name="ln5020">  return did_free;</a>
<a name="ln5021">}</a>
<a name="ln5022"> </a>
<a name="ln5023">/// Mark all lists and dicts referenced through hashtab &quot;ht&quot; with &quot;copyID&quot;.</a>
<a name="ln5024">///</a>
<a name="ln5025">/// @param ht            Hashtab content will be marked.</a>
<a name="ln5026">/// @param copyID        New mark for lists and dicts.</a>
<a name="ln5027">/// @param list_stack    Used to add lists to be marked. Can be NULL.</a>
<a name="ln5028">///</a>
<a name="ln5029">/// @returns             true if setting references failed somehow.</a>
<a name="ln5030">bool set_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack)</a>
<a name="ln5031">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5032">{</a>
<a name="ln5033">  bool abort = false;</a>
<a name="ln5034">  ht_stack_T *ht_stack = NULL;</a>
<a name="ln5035"> </a>
<a name="ln5036">  hashtab_T *cur_ht = ht;</a>
<a name="ln5037">  for (;;) {</a>
<a name="ln5038">    if (!abort) {</a>
<a name="ln5039">      // Mark each item in the hashtab.  If the item contains a hashtab</a>
<a name="ln5040">      // it is added to ht_stack, if it contains a list it is added to</a>
<a name="ln5041">      // list_stack.</a>
<a name="ln5042">      HASHTAB_ITER(cur_ht, hi, {</a>
<a name="ln5043">        abort = abort || set_ref_in_item(</a>
<a name="ln5044">            &amp;TV_DICT_HI2DI(hi)-&gt;di_tv, copyID, &amp;ht_stack, list_stack);</a>
<a name="ln5045">      });</a>
<a name="ln5046">    }</a>
<a name="ln5047"> </a>
<a name="ln5048">    if (ht_stack == NULL) {</a>
<a name="ln5049">      break;</a>
<a name="ln5050">    }</a>
<a name="ln5051"> </a>
<a name="ln5052">    // take an item from the stack</a>
<a name="ln5053">    cur_ht = ht_stack-&gt;ht;</a>
<a name="ln5054">    ht_stack_T *tempitem = ht_stack;</a>
<a name="ln5055">    ht_stack = ht_stack-&gt;prev;</a>
<a name="ln5056">    xfree(tempitem);</a>
<a name="ln5057">  }</a>
<a name="ln5058"> </a>
<a name="ln5059">  return abort;</a>
<a name="ln5060">}</a>
<a name="ln5061"> </a>
<a name="ln5062">/// Mark all lists and dicts referenced through list &quot;l&quot; with &quot;copyID&quot;.</a>
<a name="ln5063">///</a>
<a name="ln5064">/// @param l             List content will be marked.</a>
<a name="ln5065">/// @param copyID        New mark for lists and dicts.</a>
<a name="ln5066">/// @param ht_stack      Used to add hashtabs to be marked. Can be NULL.</a>
<a name="ln5067">///</a>
<a name="ln5068">/// @returns             true if setting references failed somehow.</a>
<a name="ln5069">bool set_ref_in_list(list_T *l, int copyID, ht_stack_T **ht_stack)</a>
<a name="ln5070">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5071">{</a>
<a name="ln5072">  bool abort = false;</a>
<a name="ln5073">  list_stack_T *list_stack = NULL;</a>
<a name="ln5074"> </a>
<a name="ln5075">  list_T *cur_l = l;</a>
<a name="ln5076">  for (;;) {</a>
<a name="ln5077">    // Mark each item in the list.  If the item contains a hashtab</a>
<a name="ln5078">    // it is added to ht_stack, if it contains a list it is added to</a>
<a name="ln5079">    // list_stack.</a>
<a name="ln5080">    TV_LIST_ITER(cur_l, li, {</a>
<a name="ln5081">      if (abort) {</a>
<a name="ln5082">        break;</a>
<a name="ln5083">      }</a>
<a name="ln5084">      abort = set_ref_in_item(TV_LIST_ITEM_TV(li), copyID, ht_stack,</a>
<a name="ln5085">                              &amp;list_stack);</a>
<a name="ln5086">    });</a>
<a name="ln5087"> </a>
<a name="ln5088">    if (list_stack == NULL) {</a>
<a name="ln5089">      break;</a>
<a name="ln5090">    }</a>
<a name="ln5091"> </a>
<a name="ln5092">    // take an item from the stack</a>
<a name="ln5093">    cur_l = list_stack-&gt;list;</a>
<a name="ln5094">    list_stack_T *tempitem = list_stack;</a>
<a name="ln5095">    list_stack = list_stack-&gt;prev;</a>
<a name="ln5096">    xfree(tempitem);</a>
<a name="ln5097">  }</a>
<a name="ln5098"> </a>
<a name="ln5099">  return abort;</a>
<a name="ln5100">}</a>
<a name="ln5101"> </a>
<a name="ln5102">/// Mark all lists and dicts referenced through typval &quot;tv&quot; with &quot;copyID&quot;.</a>
<a name="ln5103">///</a>
<a name="ln5104">/// @param tv            Typval content will be marked.</a>
<a name="ln5105">/// @param copyID        New mark for lists and dicts.</a>
<a name="ln5106">/// @param ht_stack      Used to add hashtabs to be marked. Can be NULL.</a>
<a name="ln5107">/// @param list_stack    Used to add lists to be marked. Can be NULL.</a>
<a name="ln5108">///</a>
<a name="ln5109">/// @returns             true if setting references failed somehow.</a>
<a name="ln5110">bool set_ref_in_item(typval_T *tv, int copyID, ht_stack_T **ht_stack,</a>
<a name="ln5111">                     list_stack_T **list_stack)</a>
<a name="ln5112">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5113">{</a>
<a name="ln5114">  bool abort = false;</a>
<a name="ln5115"> </a>
<a name="ln5116">  switch (tv-&gt;v_type) {</a>
<a name="ln5117">    case VAR_DICT: {</a>
<a name="ln5118">      dict_T *dd = tv-&gt;vval.v_dict;</a>
<a name="ln5119">      if (dd != NULL &amp;&amp; dd-&gt;dv_copyID != copyID) {</a>
<a name="ln5120">        // Didn't see this dict yet.</a>
<a name="ln5121">        dd-&gt;dv_copyID = copyID;</a>
<a name="ln5122">        if (ht_stack == NULL) {</a>
<a name="ln5123">          abort = set_ref_in_ht(&amp;dd-&gt;dv_hashtab, copyID, list_stack);</a>
<a name="ln5124">        } else {</a>
<a name="ln5125">          ht_stack_T *const newitem = xmalloc(sizeof(ht_stack_T));</a>
<a name="ln5126">          newitem-&gt;ht = &amp;dd-&gt;dv_hashtab;</a>
<a name="ln5127">          newitem-&gt;prev = *ht_stack;</a>
<a name="ln5128">          *ht_stack = newitem;</a>
<a name="ln5129">        }</a>
<a name="ln5130"> </a>
<a name="ln5131">        QUEUE *w = NULL;</a>
<a name="ln5132">        DictWatcher *watcher = NULL;</a>
<a name="ln5133">        QUEUE_FOREACH(w, &amp;dd-&gt;watchers, {</a>
<a name="ln5134">          watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln5135">          set_ref_in_callback(&amp;watcher-&gt;callback, copyID, ht_stack, list_stack);</a>
<a name="ln5136">        })</a>
<a name="ln5137">      }</a>
<a name="ln5138">      break;</a>
<a name="ln5139">    }</a>
<a name="ln5140"> </a>
<a name="ln5141">    case VAR_LIST: {</a>
<a name="ln5142">      list_T *ll = tv-&gt;vval.v_list;</a>
<a name="ln5143">      if (ll != NULL &amp;&amp; ll-&gt;lv_copyID != copyID) {</a>
<a name="ln5144">        // Didn't see this list yet.</a>
<a name="ln5145">        ll-&gt;lv_copyID = copyID;</a>
<a name="ln5146">        if (list_stack == NULL) {</a>
<a name="ln5147">          abort = set_ref_in_list(ll, copyID, ht_stack);</a>
<a name="ln5148">        } else {</a>
<a name="ln5149">          list_stack_T *const newitem = xmalloc(sizeof(list_stack_T));</a>
<a name="ln5150">          newitem-&gt;list = ll;</a>
<a name="ln5151">          newitem-&gt;prev = *list_stack;</a>
<a name="ln5152">          *list_stack = newitem;</a>
<a name="ln5153">        }</a>
<a name="ln5154">      }</a>
<a name="ln5155">      break;</a>
<a name="ln5156">    }</a>
<a name="ln5157"> </a>
<a name="ln5158">    case VAR_PARTIAL: {</a>
<a name="ln5159">      partial_T *pt = tv-&gt;vval.v_partial;</a>
<a name="ln5160"> </a>
<a name="ln5161">      // A partial does not have a copyID, because it cannot contain itself.</a>
<a name="ln5162">      if (pt != NULL) {</a>
<a name="ln5163">        abort = set_ref_in_func(pt-&gt;pt_name, pt-&gt;pt_func, copyID);</a>
<a name="ln5164">        if (pt-&gt;pt_dict != NULL) {</a>
<a name="ln5165">          typval_T dtv;</a>
<a name="ln5166"> </a>
<a name="ln5167">          dtv.v_type = VAR_DICT;</a>
<a name="ln5168">          dtv.vval.v_dict = pt-&gt;pt_dict;</a>
<a name="ln5169">          abort = abort || set_ref_in_item(&amp;dtv, copyID, ht_stack, list_stack);</a>
<a name="ln5170">        }</a>
<a name="ln5171"> </a>
<a name="ln5172">        for (int i = 0; i &lt; pt-&gt;pt_argc; i++) {</a>
<a name="ln5173">          abort = abort || set_ref_in_item(&amp;pt-&gt;pt_argv[i], copyID,</a>
<a name="ln5174">                                           ht_stack, list_stack);</a>
<a name="ln5175">        }</a>
<a name="ln5176">      }</a>
<a name="ln5177">      break;</a>
<a name="ln5178">    }</a>
<a name="ln5179">    case VAR_FUNC:</a>
<a name="ln5180">      abort = set_ref_in_func(tv-&gt;vval.v_string, NULL, copyID);</a>
<a name="ln5181">      break;</a>
<a name="ln5182">    case VAR_UNKNOWN:</a>
<a name="ln5183">    case VAR_BOOL:</a>
<a name="ln5184">    case VAR_SPECIAL:</a>
<a name="ln5185">    case VAR_FLOAT:</a>
<a name="ln5186">    case VAR_NUMBER:</a>
<a name="ln5187">    case VAR_STRING: {</a>
<a name="ln5188">      break;</a>
<a name="ln5189">    }</a>
<a name="ln5190">  }</a>
<a name="ln5191">  return abort;</a>
<a name="ln5192">}</a>
<a name="ln5193"> </a>
<a name="ln5194"> </a>
<a name="ln5195"> </a>
<a name="ln5196">/// Mark all lists and dicts referenced in given mark</a>
<a name="ln5197">///</a>
<a name="ln5198">/// @returns true if setting references failed somehow.</a>
<a name="ln5199">static inline bool set_ref_in_fmark(fmark_T fm, int copyID)</a>
<a name="ln5200">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5201">{</a>
<a name="ln5202">  if (fm.additional_data != NULL</a>
<a name="ln5203">      &amp;&amp; fm.additional_data-&gt;dv_copyID != copyID) {</a>
<a name="ln5204">    fm.additional_data-&gt;dv_copyID = copyID;</a>
<a name="ln5205">    return set_ref_in_ht(&amp;fm.additional_data-&gt;dv_hashtab, copyID, NULL);</a>
<a name="ln5206">  }</a>
<a name="ln5207">  return false;</a>
<a name="ln5208">}</a>
<a name="ln5209"> </a>
<a name="ln5210">/// Mark all lists and dicts referenced in given list and the list itself</a>
<a name="ln5211">///</a>
<a name="ln5212">/// @returns true if setting references failed somehow.</a>
<a name="ln5213">static inline bool set_ref_list(list_T *list, int copyID)</a>
<a name="ln5214">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5215">{</a>
<a name="ln5216">  if (list != NULL) {</a>
<a name="ln5217">    typval_T tv = (typval_T) {</a>
<a name="ln5218">      .v_type = VAR_LIST,</a>
<a name="ln5219">      .vval = { .v_list = list }</a>
<a name="ln5220">    };</a>
<a name="ln5221">    return set_ref_in_item(&amp;tv, copyID, NULL, NULL);</a>
<a name="ln5222">  }</a>
<a name="ln5223">  return false;</a>
<a name="ln5224">}</a>
<a name="ln5225"> </a>
<a name="ln5226">/// Mark all lists and dicts referenced in given dict and the dict itself</a>
<a name="ln5227">///</a>
<a name="ln5228">/// @returns true if setting references failed somehow.</a>
<a name="ln5229">static inline bool set_ref_dict(dict_T *dict, int copyID)</a>
<a name="ln5230">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5231">{</a>
<a name="ln5232">  if (dict != NULL) {</a>
<a name="ln5233">    typval_T tv = (typval_T) {</a>
<a name="ln5234">      .v_type = VAR_DICT,</a>
<a name="ln5235">      .vval = { .v_dict = dict }</a>
<a name="ln5236">    };</a>
<a name="ln5237">    return set_ref_in_item(&amp;tv, copyID, NULL, NULL);</a>
<a name="ln5238">  }</a>
<a name="ln5239">  return false;</a>
<a name="ln5240">}</a>
<a name="ln5241"> </a>
<a name="ln5242"> </a>
<a name="ln5243">// Get the key for *{key: val} into &quot;tv&quot; and advance &quot;arg&quot;.</a>
<a name="ln5244">// Return FAIL when there is no valid key.</a>
<a name="ln5245">static int get_literal_key(char_u **arg, typval_T *tv)</a>
<a name="ln5246">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5247">{</a>
<a name="ln5248">  char_u *p;</a>
<a name="ln5249"> </a>
<a name="ln5250">  if (!ASCII_ISALNUM(**arg) &amp;&amp; **arg != '_' &amp;&amp; **arg != '-') {</a>
<a name="ln5251">    return FAIL;</a>
<a name="ln5252">  }</a>
<a name="ln5253">  for (p = *arg; ASCII_ISALNUM(*p) || *p == '_' || *p == '-'; p++) {</a>
<a name="ln5254">  }</a>
<a name="ln5255">  tv-&gt;v_type = VAR_STRING;</a>
<a name="ln5256">  tv-&gt;vval.v_string = vim_strnsave(*arg, p - *arg);</a>
<a name="ln5257"> </a>
<a name="ln5258">  *arg = skipwhite(p);</a>
<a name="ln5259">  return OK;</a>
<a name="ln5260">}</a>
<a name="ln5261"> </a>
<a name="ln5262">// Allocate a variable for a Dictionary and fill it from &quot;*arg&quot;.</a>
<a name="ln5263">// &quot;literal&quot; is true for *{key: val}</a>
<a name="ln5264">// Return OK or FAIL.  Returns NOTDONE for {expr}.</a>
<a name="ln5265">static int dict_get_tv(char_u **arg, typval_T *rettv, int evaluate,</a>
<a name="ln5266">                       bool literal)</a>
<a name="ln5267">{</a>
<a name="ln5268">  dict_T      *d = NULL;</a>
<a name="ln5269">  typval_T tvkey;</a>
<a name="ln5270">  typval_T tv;</a>
<a name="ln5271">  char_u      *key = NULL;</a>
<a name="ln5272">  dictitem_T  *item;</a>
<a name="ln5273">  char_u      *start = skipwhite(*arg + 1);</a>
<a name="ln5274">  char buf[NUMBUFLEN];</a>
<a name="ln5275"> </a>
<a name="ln5276">  /*</a>
<a name="ln5277">   * First check if it's not a curly-braces thing: {expr}.</a>
<a name="ln5278">   * Must do this without evaluating, otherwise a function may be called</a>
<a name="ln5279">   * twice.  Unfortunately this means we need to call eval1() twice for the</a>
<a name="ln5280">   * first item.</a>
<a name="ln5281">   * But {} is an empty Dictionary.</a>
<a name="ln5282">   */</a>
<a name="ln5283">  if (*start != '}') {</a>
<a name="ln5284">    if (eval1(&amp;start, &amp;tv, false) == FAIL) {    // recursive!</a>
<a name="ln5285">      return FAIL;</a>
<a name="ln5286">    }</a>
<a name="ln5287">    if (*skipwhite(start) == '}') {</a>
<a name="ln5288">      return NOTDONE;</a>
<a name="ln5289">    }</a>
<a name="ln5290">  }</a>
<a name="ln5291"> </a>
<a name="ln5292">  if (evaluate) {</a>
<a name="ln5293">    d = tv_dict_alloc();</a>
<a name="ln5294">  }</a>
<a name="ln5295">  tvkey.v_type = VAR_UNKNOWN;</a>
<a name="ln5296">  tv.v_type = VAR_UNKNOWN;</a>
<a name="ln5297"> </a>
<a name="ln5298">  *arg = skipwhite(*arg + 1);</a>
<a name="ln5299">  while (**arg != '}' &amp;&amp; **arg != NUL) {</a>
<a name="ln5300">    if ((literal</a>
<a name="ln5301">         ? get_literal_key(arg, &amp;tvkey)</a>
<a name="ln5302">         : eval1(arg, &amp;tvkey, evaluate)) == FAIL) {  // recursive!</a>
<a name="ln5303">      goto failret;</a>
<a name="ln5304">    }</a>
<a name="ln5305">    if (**arg != ':') {</a>
<a name="ln5306">      EMSG2(_(&quot;E720: Missing colon in Dictionary: %s&quot;), *arg);</a>
<a name="ln5307">      tv_clear(&amp;tvkey);</a>
<a name="ln5308">      goto failret;</a>
<a name="ln5309">    }</a>
<a name="ln5310">    if (evaluate) {</a>
<a name="ln5311">      key = (char_u *)tv_get_string_buf_chk(&amp;tvkey, buf);</a>
<a name="ln5312">      if (key == NULL) {</a>
<a name="ln5313">        // &quot;key&quot; is NULL when tv_get_string_buf_chk() gave an errmsg</a>
<a name="ln5314">        tv_clear(&amp;tvkey);</a>
<a name="ln5315">        goto failret;</a>
<a name="ln5316">      }</a>
<a name="ln5317">    }</a>
<a name="ln5318"> </a>
<a name="ln5319">    *arg = skipwhite(*arg + 1);</a>
<a name="ln5320">    if (eval1(arg, &amp;tv, evaluate) == FAIL) {  // Recursive!</a>
<a name="ln5321">      if (evaluate) {</a>
<a name="ln5322">        tv_clear(&amp;tvkey);</a>
<a name="ln5323">      }</a>
<a name="ln5324">      goto failret;</a>
<a name="ln5325">    }</a>
<a name="ln5326">    if (evaluate) {</a>
<a name="ln5327">      item = tv_dict_find(d, (const char *)key, -1);</a>
<a name="ln5328">      if (item != NULL) {</a>
<a name="ln5329">        EMSG2(_(&quot;E721: Duplicate key in Dictionary: \&quot;%s\&quot;&quot;), key);</a>
<a name="ln5330">        tv_clear(&amp;tvkey);</a>
<a name="ln5331">        tv_clear(&amp;tv);</a>
<a name="ln5332">        goto failret;</a>
<a name="ln5333">      }</a>
<a name="ln5334">      item = tv_dict_item_alloc((const char *)key);</a>
<a name="ln5335">      item-&gt;di_tv = tv;</a>
<a name="ln5336">      item-&gt;di_tv.v_lock = VAR_UNLOCKED;</a>
<a name="ln5337">      if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln5338">        tv_dict_item_free(item);</a>
<a name="ln5339">      }</a>
<a name="ln5340">    }</a>
<a name="ln5341">    tv_clear(&amp;tvkey);</a>
<a name="ln5342"> </a>
<a name="ln5343">    if (**arg == '}')</a>
<a name="ln5344">      break;</a>
<a name="ln5345">    if (**arg != ',') {</a>
<a name="ln5346">      EMSG2(_(&quot;E722: Missing comma in Dictionary: %s&quot;), *arg);</a>
<a name="ln5347">      goto failret;</a>
<a name="ln5348">    }</a>
<a name="ln5349">    *arg = skipwhite(*arg + 1);</a>
<a name="ln5350">  }</a>
<a name="ln5351"> </a>
<a name="ln5352">  if (**arg != '}') {</a>
<a name="ln5353">    EMSG2(_(&quot;E723: Missing end of Dictionary '}': %s&quot;), *arg);</a>
<a name="ln5354">failret:</a>
<a name="ln5355">    if (d != NULL) {</a>
<a name="ln5356">      tv_dict_free(d);</a>
<a name="ln5357">    }</a>
<a name="ln5358">    return FAIL;</a>
<a name="ln5359">  }</a>
<a name="ln5360"> </a>
<a name="ln5361">  *arg = skipwhite(*arg + 1);</a>
<a name="ln5362">  if (evaluate) {</a>
<a name="ln5363">    tv_dict_set_ret(rettv, d);</a>
<a name="ln5364">  }</a>
<a name="ln5365"> </a>
<a name="ln5366">  return OK;</a>
<a name="ln5367">}</a>
<a name="ln5368"> </a>
<a name="ln5369">/// Convert the string to a floating point number</a>
<a name="ln5370">///</a>
<a name="ln5371">/// This uses strtod().  setlocale(LC_NUMERIC, &quot;C&quot;) has been used earlier to</a>
<a name="ln5372">/// make sure this always uses a decimal point.</a>
<a name="ln5373">///</a>
<a name="ln5374">/// @param[in]  text  String to convert.</a>
<a name="ln5375">/// @param[out]  ret_value  Location where conversion result is saved.</a>
<a name="ln5376">///</a>
<a name="ln5377">/// @return Length of the text that was consumed.</a>
<a name="ln5378">size_t string2float(const char *const text, float_T *const ret_value)</a>
<a name="ln5379">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5380">{</a>
<a name="ln5381">  char *s = NULL;</a>
<a name="ln5382"> </a>
<a name="ln5383">  // MS-Windows does not deal with &quot;inf&quot; and &quot;nan&quot; properly</a>
<a name="ln5384">  if (STRNICMP(text, &quot;inf&quot;, 3) == 0) {</a>
<a name="ln5385">    *ret_value = INFINITY;</a>
<a name="ln5386">    return 3;</a>
<a name="ln5387">  }</a>
<a name="ln5388">  if (STRNICMP(text, &quot;-inf&quot;, 3) == 0) {</a>
<a name="ln5389">    *ret_value = -INFINITY;</a>
<a name="ln5390">    return 4;</a>
<a name="ln5391">  }</a>
<a name="ln5392">  if (STRNICMP(text, &quot;nan&quot;, 3) == 0) {</a>
<a name="ln5393">    *ret_value = NAN;</a>
<a name="ln5394">    return 3;</a>
<a name="ln5395">  }</a>
<a name="ln5396">  *ret_value = strtod(text, &amp;s);</a>
<a name="ln5397">  return (size_t) (s - text);</a>
<a name="ln5398">}</a>
<a name="ln5399"> </a>
<a name="ln5400">/// Get the value of an environment variable.</a>
<a name="ln5401">///</a>
<a name="ln5402">/// If the environment variable was not set, silently assume it is empty.</a>
<a name="ln5403">///</a>
<a name="ln5404">/// @param arg Points to the '$'.  It is advanced to after the name.</a>
<a name="ln5405">/// @return FAIL if the name is invalid.</a>
<a name="ln5406">///</a>
<a name="ln5407">static int get_env_tv(char_u **arg, typval_T *rettv, int evaluate)</a>
<a name="ln5408">{</a>
<a name="ln5409">  char_u *name;</a>
<a name="ln5410">  char_u *string = NULL;</a>
<a name="ln5411">  int     len;</a>
<a name="ln5412">  int     cc;</a>
<a name="ln5413"> </a>
<a name="ln5414">  ++*arg;</a>
<a name="ln5415">  name = *arg;</a>
<a name="ln5416">  len = get_env_len((const char_u **)arg);</a>
<a name="ln5417"> </a>
<a name="ln5418">  if (evaluate) {</a>
<a name="ln5419">    if (len == 0) {</a>
<a name="ln5420">      return FAIL;  // Invalid empty name.</a>
<a name="ln5421">    }</a>
<a name="ln5422">    cc = name[len];</a>
<a name="ln5423">    name[len] = NUL;</a>
<a name="ln5424">    // First try vim_getenv(), fast for normal environment vars.</a>
<a name="ln5425">    string = (char_u *)vim_getenv((char *)name);</a>
<a name="ln5426">    if (string == NULL || *string == NUL) {</a>
<a name="ln5427">      xfree(string);</a>
<a name="ln5428"> </a>
<a name="ln5429">      // Next try expanding things like $VIM and ${HOME}.</a>
<a name="ln5430">      string = expand_env_save(name - 1);</a>
<a name="ln5431">      if (string != NULL &amp;&amp; *string == '$') {</a>
<a name="ln5432">        XFREE_CLEAR(string);</a>
<a name="ln5433">      }</a>
<a name="ln5434">    }</a>
<a name="ln5435">    name[len] = cc;</a>
<a name="ln5436">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5437">    rettv-&gt;vval.v_string = string;</a>
<a name="ln5438">  }</a>
<a name="ln5439"> </a>
<a name="ln5440">  return OK;</a>
<a name="ln5441">}</a>
<a name="ln5442"> </a>
<a name="ln5443">/// Get the argument list for a given window</a>
<a name="ln5444">void get_arglist_as_rettv(aentry_T *arglist, int argcount,</a>
<a name="ln5445">                          typval_T *rettv)</a>
<a name="ln5446">{</a>
<a name="ln5447">  tv_list_alloc_ret(rettv, argcount);</a>
<a name="ln5448">  if (arglist != NULL) {</a>
<a name="ln5449">    for (int idx = 0; idx &lt; argcount; idx++) {</a>
<a name="ln5450">      tv_list_append_string(rettv-&gt;vval.v_list,</a>
<a name="ln5451">                            (const char *)alist_name(&amp;arglist[idx]), -1);</a>
<a name="ln5452">    }</a>
<a name="ln5453">  }</a>
<a name="ln5454">}</a>
<a name="ln5455"> </a>
<a name="ln5456">// Prepare &quot;gap&quot; for an assert error and add the sourcing position.</a>
<a name="ln5457">void prepare_assert_error(garray_T *gap)</a>
<a name="ln5458">{</a>
<a name="ln5459">  char buf[NUMBUFLEN];</a>
<a name="ln5460"> </a>
<a name="ln5461">  ga_init(gap, 1, 100);</a>
<a name="ln5462">  if (sourcing_name != NULL) {</a>
<a name="ln5463">    ga_concat(gap, sourcing_name);</a>
<a name="ln5464">    if (sourcing_lnum &gt; 0) {</a>
<a name="ln5465">      ga_concat(gap, (char_u *)&quot; &quot;);</a>
<a name="ln5466">    }</a>
<a name="ln5467">  }</a>
<a name="ln5468">  if (sourcing_lnum &gt; 0) {</a>
<a name="ln5469">    vim_snprintf(buf, ARRAY_SIZE(buf), &quot;line %&quot; PRId64, (int64_t)sourcing_lnum);</a>
<a name="ln5470">    ga_concat(gap, (char_u *)buf);</a>
<a name="ln5471">  }</a>
<a name="ln5472">  if (sourcing_name != NULL || sourcing_lnum &gt; 0) {</a>
<a name="ln5473">    ga_concat(gap, (char_u *)&quot;: &quot;);</a>
<a name="ln5474">  }</a>
<a name="ln5475">}</a>
<a name="ln5476"> </a>
<a name="ln5477">// Append &quot;p[clen]&quot; to &quot;gap&quot;, escaping unprintable characters.</a>
<a name="ln5478">// Changes NL to \n, CR to \r, etc.</a>
<a name="ln5479">static void ga_concat_esc(garray_T *gap, const char_u *p, int clen)</a>
<a name="ln5480">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5481">{</a>
<a name="ln5482">  char_u buf[NUMBUFLEN];</a>
<a name="ln5483"> </a>
<a name="ln5484">  if (clen &gt; 1) {</a>
<a name="ln5485">    memmove(buf, p, clen);</a>
<a name="ln5486">    buf[clen] = NUL;</a>
<a name="ln5487">    ga_concat(gap, buf);</a>
<a name="ln5488">  } else {</a>
<a name="ln5489">    switch (*p) {</a>
<a name="ln5490">      case BS: ga_concat(gap, (char_u *)&quot;\\b&quot;); break;</a>
<a name="ln5491">      case ESC: ga_concat(gap, (char_u *)&quot;\\e&quot;); break;</a>
<a name="ln5492">      case FF: ga_concat(gap, (char_u *)&quot;\\f&quot;); break;</a>
<a name="ln5493">      case NL: ga_concat(gap, (char_u *)&quot;\\n&quot;); break;</a>
<a name="ln5494">      case TAB: ga_concat(gap, (char_u *)&quot;\\t&quot;); break;</a>
<a name="ln5495">      case CAR: ga_concat(gap, (char_u *)&quot;\\r&quot;); break;</a>
<a name="ln5496">      case '\\': ga_concat(gap, (char_u *)&quot;\\\\&quot;); break;</a>
<a name="ln5497">      default:</a>
<a name="ln5498">        if (*p &lt; ' ') {</a>
<a name="ln5499">          vim_snprintf((char *)buf, NUMBUFLEN, &quot;\\x%02x&quot;, *p);</a>
<a name="ln5500">          ga_concat(gap, buf);</a>
<a name="ln5501">        } else {</a>
<a name="ln5502">          ga_append(gap, *p);</a>
<a name="ln5503">        }</a>
<a name="ln5504">        break;</a>
<a name="ln5505">    }</a>
<a name="ln5506">  }</a>
<a name="ln5507">}</a>
<a name="ln5508"> </a>
<a name="ln5509">// Append &quot;str&quot; to &quot;gap&quot;, escaping unprintable characters.</a>
<a name="ln5510">// Changes NL to \n, CR to \r, etc.</a>
<a name="ln5511">static void ga_concat_shorten_esc(garray_T *gap, const char_u *str)</a>
<a name="ln5512">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln5513">{</a>
<a name="ln5514">  char_u buf[NUMBUFLEN];</a>
<a name="ln5515"> </a>
<a name="ln5516">  if (str == NULL) {</a>
<a name="ln5517">    ga_concat(gap, (char_u *)&quot;NULL&quot;);</a>
<a name="ln5518">    return;</a>
<a name="ln5519">  }</a>
<a name="ln5520"> </a>
<a name="ln5521">  for (const char_u *p = str; *p != NUL; p++) {</a>
<a name="ln5522">    int same_len = 1;</a>
<a name="ln5523">    const char_u *s = p;</a>
<a name="ln5524">    const int c = mb_ptr2char_adv(&amp;s);</a>
<a name="ln5525">    const int clen = s - p;</a>
<a name="ln5526">    while (*s != NUL &amp;&amp; c == utf_ptr2char(s)) {</a>
<a name="ln5527">      same_len++;</a>
<a name="ln5528">      s += clen;</a>
<a name="ln5529">    }</a>
<a name="ln5530">    if (same_len &gt; 20) {</a>
<a name="ln5531">      ga_concat(gap, (char_u *)&quot;\\[&quot;);</a>
<a name="ln5532">      ga_concat_esc(gap, p, clen);</a>
<a name="ln5533">      ga_concat(gap, (char_u *)&quot; occurs &quot;);</a>
<a name="ln5534">      vim_snprintf((char *)buf, NUMBUFLEN, &quot;%d&quot;, same_len);</a>
<a name="ln5535">      ga_concat(gap, buf);</a>
<a name="ln5536">      ga_concat(gap, (char_u *)&quot; times]&quot;);</a>
<a name="ln5537">      p = s - 1;</a>
<a name="ln5538">    } else {</a>
<a name="ln5539">      ga_concat_esc(gap, p, clen);</a>
<a name="ln5540">    }</a>
<a name="ln5541">  }</a>
<a name="ln5542">}</a>
<a name="ln5543"> </a>
<a name="ln5544">// Fill &quot;gap&quot; with information about an assert error.</a>
<a name="ln5545">void fill_assert_error(garray_T *gap, typval_T *opt_msg_tv,</a>
<a name="ln5546">                       char_u *exp_str, typval_T *exp_tv,</a>
<a name="ln5547">                       typval_T *got_tv, assert_type_T atype)</a>
<a name="ln5548">{</a>
<a name="ln5549">  char_u *tofree;</a>
<a name="ln5550"> </a>
<a name="ln5551">  if (opt_msg_tv-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln5552">    tofree = (char_u *)encode_tv2echo(opt_msg_tv, NULL);</a>
<a name="ln5553">    ga_concat(gap, tofree);</a>
<a name="ln5554">    xfree(tofree);</a>
<a name="ln5555">    ga_concat(gap, (char_u *)&quot;: &quot;);</a>
<a name="ln5556">  }</a>
<a name="ln5557"> </a>
<a name="ln5558">  if (atype == ASSERT_MATCH || atype == ASSERT_NOTMATCH) {</a>
<a name="ln5559">    ga_concat(gap, (char_u *)&quot;Pattern &quot;);</a>
<a name="ln5560">  } else if (atype == ASSERT_NOTEQUAL) {</a>
<a name="ln5561">    ga_concat(gap, (char_u *)&quot;Expected not equal to &quot;);</a>
<a name="ln5562">  } else {</a>
<a name="ln5563">    ga_concat(gap, (char_u *)&quot;Expected &quot;);</a>
<a name="ln5564">  }</a>
<a name="ln5565"> </a>
<a name="ln5566">  if (exp_str == NULL) {</a>
<a name="ln5567">    tofree = (char_u *)encode_tv2string(exp_tv, NULL);</a>
<a name="ln5568">    ga_concat_shorten_esc(gap, tofree);</a>
<a name="ln5569">    xfree(tofree);</a>
<a name="ln5570">  } else {</a>
<a name="ln5571">    ga_concat_shorten_esc(gap, exp_str);</a>
<a name="ln5572">  }</a>
<a name="ln5573"> </a>
<a name="ln5574">  if (atype != ASSERT_NOTEQUAL) {</a>
<a name="ln5575">    if (atype == ASSERT_MATCH) {</a>
<a name="ln5576">      ga_concat(gap, (char_u *)&quot; does not match &quot;);</a>
<a name="ln5577">    } else if (atype == ASSERT_NOTMATCH) {</a>
<a name="ln5578">      ga_concat(gap, (char_u *)&quot; does match &quot;);</a>
<a name="ln5579">    } else {</a>
<a name="ln5580">      ga_concat(gap, (char_u *)&quot; but got &quot;);</a>
<a name="ln5581">    }</a>
<a name="ln5582">    tofree = (char_u *)encode_tv2string(got_tv, NULL);</a>
<a name="ln5583">    ga_concat_shorten_esc(gap, tofree);</a>
<a name="ln5584">    xfree(tofree);</a>
<a name="ln5585">  }</a>
<a name="ln5586">}</a>
<a name="ln5587"> </a>
<a name="ln5588">// Add an assert error to v:errors.</a>
<a name="ln5589">void assert_error(garray_T *gap)</a>
<a name="ln5590">{</a>
<a name="ln5591">  struct vimvar *vp = &amp;vimvars[VV_ERRORS];</a>
<a name="ln5592"> </a>
<a name="ln5593">  if (vp-&gt;vv_type != VAR_LIST || vimvars[VV_ERRORS].vv_list == NULL) {</a>
<a name="ln5594">    // Make sure v:errors is a list.</a>
<a name="ln5595">    set_vim_var_list(VV_ERRORS, tv_list_alloc(1));</a>
<a name="ln5596">  }</a>
<a name="ln5597">  tv_list_append_string(vimvars[VV_ERRORS].vv_list,</a>
<a name="ln5598">                        (const char *)gap-&gt;ga_data, (ptrdiff_t)gap-&gt;ga_len);</a>
<a name="ln5599">}</a>
<a name="ln5600"> </a>
<a name="ln5601">int assert_equal_common(typval_T *argvars, assert_type_T atype)</a>
<a name="ln5602">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5603">{</a>
<a name="ln5604">  garray_T ga;</a>
<a name="ln5605"> </a>
<a name="ln5606">  if (tv_equal(&amp;argvars[0], &amp;argvars[1], false, false)</a>
<a name="ln5607">      != (atype == ASSERT_EQUAL)) {</a>
<a name="ln5608">    prepare_assert_error(&amp;ga);</a>
<a name="ln5609">    fill_assert_error(&amp;ga, &amp;argvars[2], NULL,</a>
<a name="ln5610">                      &amp;argvars[0], &amp;argvars[1], atype);</a>
<a name="ln5611">    assert_error(&amp;ga);</a>
<a name="ln5612">    ga_clear(&amp;ga);</a>
<a name="ln5613">    return 1;</a>
<a name="ln5614">  }</a>
<a name="ln5615">  return 0;</a>
<a name="ln5616">}</a>
<a name="ln5617"> </a>
<a name="ln5618">int assert_equalfile(typval_T *argvars)</a>
<a name="ln5619">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5620">{</a>
<a name="ln5621">  char buf1[NUMBUFLEN];</a>
<a name="ln5622">  char buf2[NUMBUFLEN];</a>
<a name="ln5623">  const char *const fname1 = tv_get_string_buf_chk(&amp;argvars[0], buf1);</a>
<a name="ln5624">  const char *const fname2 = tv_get_string_buf_chk(&amp;argvars[1], buf2);</a>
<a name="ln5625">  garray_T ga;</a>
<a name="ln5626"> </a>
<a name="ln5627">  if (fname1 == NULL || fname2 == NULL) {</a>
<a name="ln5628">    return 0;</a>
<a name="ln5629">  }</a>
<a name="ln5630"> </a>
<a name="ln5631">  IObuff[0] = NUL;</a>
<a name="ln5632">  FILE *const fd1 = os_fopen(fname1, READBIN);</a>
<a name="ln5633">  char line1[200];</a>
<a name="ln5634">  char line2[200];</a>
<a name="ln5635">  ptrdiff_t lineidx = 0;</a>
<a name="ln5636">  if (fd1 == NULL) {</a>
<a name="ln5637">    snprintf((char *)IObuff, IOSIZE, (char *)e_notread, fname1);</a>
<a name="ln5638">  } else {</a>
<a name="ln5639">    FILE *const fd2 = os_fopen(fname2, READBIN);</a>
<a name="ln5640">    if (fd2 == NULL) {</a>
<a name="ln5641">      fclose(fd1);</a>
<a name="ln5642">      snprintf((char *)IObuff, IOSIZE, (char *)e_notread, fname2);</a>
<a name="ln5643">    } else {</a>
<a name="ln5644">      int64_t linecount = 1;</a>
<a name="ln5645">      for (int64_t count = 0; ; count++) {</a>
<a name="ln5646">        const int c1 = fgetc(fd1);</a>
<a name="ln5647">        const int c2 = fgetc(fd2);</a>
<a name="ln5648">        if (c1 == EOF) {</a>
<a name="ln5649">          if (c2 != EOF) {</a>
<a name="ln5650">            STRCPY(IObuff, &quot;first file is shorter&quot;);</a>
<a name="ln5651">          }</a>
<a name="ln5652">          break;</a>
<a name="ln5653">        } else if (c2 == EOF) {</a>
<a name="ln5654">          STRCPY(IObuff, &quot;second file is shorter&quot;);</a>
<a name="ln5655">          break;</a>
<a name="ln5656">        } else {</a>
<a name="ln5657">          line1[lineidx] = c1;</a>
<a name="ln5658">          line2[lineidx] = c2;</a>
<a name="ln5659">          lineidx++;</a>
<a name="ln5660">          if (c1 != c2) {</a>
<a name="ln5661">            snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln5662">                     &quot;difference at byte %&quot; PRId64 &quot;, line %&quot; PRId64,</a>
<a name="ln5663">                     count, linecount);</a>
<a name="ln5664">            break;</a>
<a name="ln5665">          }</a>
<a name="ln5666">        }</a>
<a name="ln5667">        if (c1 == NL) {</a>
<a name="ln5668">          linecount++;</a>
<a name="ln5669">          lineidx = 0;</a>
<a name="ln5670">        } else if (lineidx + 2 == (ptrdiff_t)sizeof(line1)) {</a>
<a name="ln5671">          memmove(line1, line1 + 100, lineidx - 100);</a>
<a name="ln5672">          memmove(line2, line2 + 100, lineidx - 100);</a>
<a name="ln5673">          lineidx -= 100;</a>
<a name="ln5674">        }</a>
<a name="ln5675">      }</a>
<a name="ln5676">      fclose(fd1);</a>
<a name="ln5677">      fclose(fd2);</a>
<a name="ln5678">    }</a>
<a name="ln5679">  }</a>
<a name="ln5680">  if (IObuff[0] != NUL) {</a>
<a name="ln5681">    prepare_assert_error(&amp;ga);</a>
<a name="ln5682">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5683">      char *const tofree = encode_tv2echo(&amp;argvars[2], NULL);</a>
<a name="ln5684">      ga_concat(&amp;ga, (char_u *)tofree);</a>
<a name="ln5685">      xfree(tofree);</a>
<a name="ln5686">      ga_concat(&amp;ga, (char_u *)&quot;: &quot;);</a>
<a name="ln5687">    }</a>
<a name="ln5688">    ga_concat(&amp;ga, IObuff);</a>
<a name="ln5689">    if (lineidx &gt; 0) {</a>
<a name="ln5690">      line1[lineidx] = NUL;</a>
<a name="ln5691">      line2[lineidx] = NUL;</a>
<a name="ln5692">      ga_concat(&amp;ga, (char_u *)&quot; after \&quot;&quot;);</a>
<a name="ln5693">      ga_concat(&amp;ga, (char_u *)line1);</a>
<a name="ln5694">      if (STRCMP(line1, line2) != 0) {</a>
<a name="ln5695">        ga_concat(&amp;ga, (char_u *)&quot;\&quot; vs \&quot;&quot;);</a>
<a name="ln5696">        ga_concat(&amp;ga, (char_u *)line2);</a>
<a name="ln5697">      }</a>
<a name="ln5698">      ga_concat(&amp;ga, (char_u *)&quot;\&quot;&quot;);</a>
<a name="ln5699">    }</a>
<a name="ln5700">    assert_error(&amp;ga);</a>
<a name="ln5701">    ga_clear(&amp;ga);</a>
<a name="ln5702">    return 1;</a>
<a name="ln5703">  }</a>
<a name="ln5704">  return 0;</a>
<a name="ln5705">}</a>
<a name="ln5706"> </a>
<a name="ln5707">int assert_inrange(typval_T *argvars)</a>
<a name="ln5708">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5709">{</a>
<a name="ln5710">  bool error = false;</a>
<a name="ln5711"> </a>
<a name="ln5712">  if (argvars[0].v_type == VAR_FLOAT</a>
<a name="ln5713">      || argvars[1].v_type == VAR_FLOAT</a>
<a name="ln5714">      || argvars[2].v_type == VAR_FLOAT) {</a>
<a name="ln5715">    const float_T flower = tv_get_float(&amp;argvars[0]);</a>
<a name="ln5716">    const float_T fupper = tv_get_float(&amp;argvars[1]);</a>
<a name="ln5717">    const float_T factual = tv_get_float(&amp;argvars[2]);</a>
<a name="ln5718"> </a>
<a name="ln5719">    if (factual &lt; flower || factual &gt; fupper) {</a>
<a name="ln5720">      garray_T ga;</a>
<a name="ln5721">      prepare_assert_error(&amp;ga);</a>
<a name="ln5722">      if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln5723">        char_u *const tofree = (char_u *)encode_tv2string(&amp;argvars[3], NULL);</a>
<a name="ln5724">        ga_concat(&amp;ga, tofree);</a>
<a name="ln5725">        xfree(tofree);</a>
<a name="ln5726">      } else {</a>
<a name="ln5727">        char msg[80];</a>
<a name="ln5728">        vim_snprintf(msg, sizeof(msg), &quot;Expected range %g - %g, but got %g&quot;,</a>
<a name="ln5729">                     flower, fupper, factual);</a>
<a name="ln5730">        ga_concat(&amp;ga, (char_u *)msg);</a>
<a name="ln5731">      }</a>
<a name="ln5732">      assert_error(&amp;ga);</a>
<a name="ln5733">      ga_clear(&amp;ga);</a>
<a name="ln5734">      return 1;</a>
<a name="ln5735">    }</a>
<a name="ln5736">  } else {</a>
<a name="ln5737">    const varnumber_T lower = tv_get_number_chk(&amp;argvars[0], &amp;error);</a>
<a name="ln5738">    const varnumber_T upper = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln5739">    const varnumber_T actual = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln5740"> </a>
<a name="ln5741">    if (error) {</a>
<a name="ln5742">      return 0;</a>
<a name="ln5743">    }</a>
<a name="ln5744">    if (actual &lt; lower || actual &gt; upper) {</a>
<a name="ln5745">      garray_T ga;</a>
<a name="ln5746">      prepare_assert_error(&amp;ga);</a>
<a name="ln5747"> </a>
<a name="ln5748">      char msg[55];</a>
<a name="ln5749">      vim_snprintf(msg, sizeof(msg),</a>
<a name="ln5750">                   &quot;range %&quot; PRIdVARNUMBER &quot; - %&quot; PRIdVARNUMBER &quot;,&quot;,</a>
<a name="ln5751">                   lower, upper);</a>
<a name="ln5752">      fill_assert_error(&amp;ga, &amp;argvars[3], (char_u *)msg, NULL, &amp;argvars[2],</a>
<a name="ln5753">                        ASSERT_INRANGE);</a>
<a name="ln5754">      assert_error(&amp;ga);</a>
<a name="ln5755">      ga_clear(&amp;ga);</a>
<a name="ln5756">      return 1;</a>
<a name="ln5757">    }</a>
<a name="ln5758">  }</a>
<a name="ln5759">  return 0;</a>
<a name="ln5760">}</a>
<a name="ln5761"> </a>
<a name="ln5762">// Common for assert_true() and assert_false().</a>
<a name="ln5763">int assert_bool(typval_T *argvars, bool is_true)</a>
<a name="ln5764">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5765">{</a>
<a name="ln5766">  bool error = false;</a>
<a name="ln5767">  garray_T ga;</a>
<a name="ln5768"> </a>
<a name="ln5769">  if ((argvars[0].v_type != VAR_NUMBER</a>
<a name="ln5770">       || (tv_get_number_chk(&amp;argvars[0], &amp;error) == 0) == is_true</a>
<a name="ln5771">       || error)</a>
<a name="ln5772">      &amp;&amp; (argvars[0].v_type != VAR_BOOL</a>
<a name="ln5773">          || (argvars[0].vval.v_bool</a>
<a name="ln5774">              != (BoolVarValue)(is_true</a>
<a name="ln5775">                                ? kBoolVarTrue</a>
<a name="ln5776">                                : kBoolVarFalse)))) {</a>
<a name="ln5777">    prepare_assert_error(&amp;ga);</a>
<a name="ln5778">    fill_assert_error(&amp;ga, &amp;argvars[1],</a>
<a name="ln5779">                      (char_u *)(is_true ? &quot;True&quot; : &quot;False&quot;),</a>
<a name="ln5780">                      NULL, &amp;argvars[0], ASSERT_OTHER);</a>
<a name="ln5781">    assert_error(&amp;ga);</a>
<a name="ln5782">    ga_clear(&amp;ga);</a>
<a name="ln5783">    return 1;</a>
<a name="ln5784">  }</a>
<a name="ln5785">  return 0;</a>
<a name="ln5786">}</a>
<a name="ln5787"> </a>
<a name="ln5788">int assert_exception(typval_T *argvars)</a>
<a name="ln5789">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5790">{</a>
<a name="ln5791">  garray_T ga;</a>
<a name="ln5792"> </a>
<a name="ln5793">  const char *const error = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln5794">  if (vimvars[VV_EXCEPTION].vv_str == NULL) {</a>
<a name="ln5795">    prepare_assert_error(&amp;ga);</a>
<a name="ln5796">    ga_concat(&amp;ga, (char_u *)&quot;v:exception is not set&quot;);</a>
<a name="ln5797">    assert_error(&amp;ga);</a>
<a name="ln5798">    ga_clear(&amp;ga);</a>
<a name="ln5799">    return 1;</a>
<a name="ln5800">  } else if (error != NULL</a>
<a name="ln5801">             &amp;&amp; strstr((char *)vimvars[VV_EXCEPTION].vv_str, error) == NULL) {</a>
<a name="ln5802">    prepare_assert_error(&amp;ga);</a>
<a name="ln5803">    fill_assert_error(&amp;ga, &amp;argvars[1], NULL, &amp;argvars[0],</a>
<a name="ln5804">                      &amp;vimvars[VV_EXCEPTION].vv_tv, ASSERT_OTHER);</a>
<a name="ln5805">    assert_error(&amp;ga);</a>
<a name="ln5806">    ga_clear(&amp;ga);</a>
<a name="ln5807">    return 1;</a>
<a name="ln5808">  }</a>
<a name="ln5809">  return 0;</a>
<a name="ln5810">}</a>
<a name="ln5811"> </a>
<a name="ln5812">static void assert_append_cmd_or_arg(garray_T *gap, typval_T *argvars,</a>
<a name="ln5813">                                     const char *cmd)</a>
<a name="ln5814">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5815">{</a>
<a name="ln5816">  if (argvars[1].v_type != VAR_UNKNOWN &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5817">    char *const tofree = encode_tv2echo(&amp;argvars[2], NULL);</a>
<a name="ln5818">    ga_concat(gap, (char_u *)tofree);</a>
<a name="ln5819">    xfree(tofree);</a>
<a name="ln5820">  } else {</a>
<a name="ln5821">    ga_concat(gap, (char_u *)cmd);</a>
<a name="ln5822">  }</a>
<a name="ln5823">}</a>
<a name="ln5824"> </a>
<a name="ln5825">int assert_beeps(typval_T *argvars, bool no_beep)</a>
<a name="ln5826">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5827">{</a>
<a name="ln5828">  const char *const cmd = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln5829">  int ret = 0;</a>
<a name="ln5830"> </a>
<a name="ln5831">  called_vim_beep = false;</a>
<a name="ln5832">  suppress_errthrow = true;</a>
<a name="ln5833">  emsg_silent = false;</a>
<a name="ln5834">  do_cmdline_cmd(cmd);</a>
<a name="ln5835">  if (no_beep ? called_vim_beep : !called_vim_beep) {</a>
<a name="ln5836">    garray_T ga;</a>
<a name="ln5837">    prepare_assert_error(&amp;ga);</a>
<a name="ln5838">    if (no_beep) {</a>
<a name="ln5839">      ga_concat(&amp;ga, (const char_u *)&quot;command did beep: &quot;);</a>
<a name="ln5840">    } else {</a>
<a name="ln5841">      ga_concat(&amp;ga, (const char_u *)&quot;command did not beep: &quot;);</a>
<a name="ln5842">    }</a>
<a name="ln5843">    ga_concat(&amp;ga, (const char_u *)cmd);</a>
<a name="ln5844">    assert_error(&amp;ga);</a>
<a name="ln5845">    ga_clear(&amp;ga);</a>
<a name="ln5846">    ret = 1;</a>
<a name="ln5847">  }</a>
<a name="ln5848"> </a>
<a name="ln5849">  suppress_errthrow = false;</a>
<a name="ln5850">  emsg_on_display = false;</a>
<a name="ln5851">  return ret;</a>
<a name="ln5852">}</a>
<a name="ln5853"> </a>
<a name="ln5854">int assert_fails(typval_T *argvars)</a>
<a name="ln5855">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5856">{</a>
<a name="ln5857">  const char *const cmd = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln5858">  garray_T    ga;</a>
<a name="ln5859">  int ret = 0;</a>
<a name="ln5860">  int         save_trylevel = trylevel;</a>
<a name="ln5861"> </a>
<a name="ln5862">  // trylevel must be zero for a &quot;:throw&quot; command to be considered failed</a>
<a name="ln5863">  trylevel = 0;</a>
<a name="ln5864">  called_emsg = false;</a>
<a name="ln5865">  suppress_errthrow = true;</a>
<a name="ln5866">  emsg_silent = true;</a>
<a name="ln5867"> </a>
<a name="ln5868">  do_cmdline_cmd(cmd);</a>
<a name="ln5869">  if (!called_emsg) {</a>
<a name="ln5870">    prepare_assert_error(&amp;ga);</a>
<a name="ln5871">    ga_concat(&amp;ga, (const char_u *)&quot;command did not fail: &quot;);</a>
<a name="ln5872">    assert_append_cmd_or_arg(&amp;ga, argvars, cmd);</a>
<a name="ln5873">    assert_error(&amp;ga);</a>
<a name="ln5874">    ga_clear(&amp;ga);</a>
<a name="ln5875">    ret = 1;</a>
<a name="ln5876">  } else if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5877">    char buf[NUMBUFLEN];</a>
<a name="ln5878">    const char *const error = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln5879"> </a>
<a name="ln5880">    if (error == NULL</a>
<a name="ln5881">        || strstr((char *)vimvars[VV_ERRMSG].vv_str, error) == NULL) {</a>
<a name="ln5882">      prepare_assert_error(&amp;ga);</a>
<a name="ln5883">      fill_assert_error(&amp;ga, &amp;argvars[2], NULL, &amp;argvars[1],</a>
<a name="ln5884">                        &amp;vimvars[VV_ERRMSG].vv_tv, ASSERT_OTHER);</a>
<a name="ln5885">      ga_concat(&amp;ga, (char_u *)&quot;: &quot;);</a>
<a name="ln5886">      assert_append_cmd_or_arg(&amp;ga, argvars, cmd);</a>
<a name="ln5887">      assert_error(&amp;ga);</a>
<a name="ln5888">      ga_clear(&amp;ga);</a>
<a name="ln5889">      ret = 1;</a>
<a name="ln5890">    }</a>
<a name="ln5891">  }</a>
<a name="ln5892"> </a>
<a name="ln5893">  trylevel = save_trylevel;</a>
<a name="ln5894">  called_emsg = false;</a>
<a name="ln5895">  suppress_errthrow = false;</a>
<a name="ln5896">  emsg_silent = false;</a>
<a name="ln5897">  emsg_on_display = false;</a>
<a name="ln5898">  set_vim_var_string(VV_ERRMSG, NULL, 0);</a>
<a name="ln5899">  return ret;</a>
<a name="ln5900">}</a>
<a name="ln5901"> </a>
<a name="ln5902">int assert_match_common(typval_T *argvars, assert_type_T atype)</a>
<a name="ln5903">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5904">{</a>
<a name="ln5905">  char buf1[NUMBUFLEN];</a>
<a name="ln5906">  char buf2[NUMBUFLEN];</a>
<a name="ln5907">  const char *const pat = tv_get_string_buf_chk(&amp;argvars[0], buf1);</a>
<a name="ln5908">  const char *const text = tv_get_string_buf_chk(&amp;argvars[1], buf2);</a>
<a name="ln5909"> </a>
<a name="ln5910">  if (pat == NULL || text == NULL) {</a>
<a name="ln5911">    EMSG(_(e_invarg));</a>
<a name="ln5912">  } else if (pattern_match((char_u *)pat, (char_u *)text, false)</a>
<a name="ln5913">             != (atype == ASSERT_MATCH)) {</a>
<a name="ln5914">    garray_T ga;</a>
<a name="ln5915">    prepare_assert_error(&amp;ga);</a>
<a name="ln5916">    fill_assert_error(&amp;ga, &amp;argvars[2], NULL, &amp;argvars[0], &amp;argvars[1], atype);</a>
<a name="ln5917">    assert_error(&amp;ga);</a>
<a name="ln5918">    ga_clear(&amp;ga);</a>
<a name="ln5919">    return 1;</a>
<a name="ln5920">  }</a>
<a name="ln5921">  return 0;</a>
<a name="ln5922">}</a>
<a name="ln5923"> </a>
<a name="ln5924">/// Find a window: When using a Window ID in any tab page, when using a number</a>
<a name="ln5925">/// in the current tab page.</a>
<a name="ln5926">win_T * find_win_by_nr_or_id(typval_T *vp)</a>
<a name="ln5927">{</a>
<a name="ln5928">  int nr = (int)tv_get_number_chk(vp, NULL);</a>
<a name="ln5929"> </a>
<a name="ln5930">  if (nr &gt;= LOWEST_WIN_ID) {</a>
<a name="ln5931">    return win_id2wp(vp);</a>
<a name="ln5932">  }</a>
<a name="ln5933"> </a>
<a name="ln5934">  return find_win_by_nr(vp, NULL);</a>
<a name="ln5935">}</a>
<a name="ln5936"> </a>
<a name="ln5937">/*</a>
<a name="ln5938"> * Implementation of map() and filter().</a>
<a name="ln5939"> */</a>
<a name="ln5940">void filter_map(typval_T *argvars, typval_T *rettv, int map)</a>
<a name="ln5941">{</a>
<a name="ln5942">  typval_T    *expr;</a>
<a name="ln5943">  list_T      *l = NULL;</a>
<a name="ln5944">  dictitem_T  *di;</a>
<a name="ln5945">  hashtab_T   *ht;</a>
<a name="ln5946">  hashitem_T  *hi;</a>
<a name="ln5947">  dict_T      *d = NULL;</a>
<a name="ln5948">  typval_T save_val;</a>
<a name="ln5949">  typval_T save_key;</a>
<a name="ln5950">  int rem = false;</a>
<a name="ln5951">  int todo;</a>
<a name="ln5952">  char_u *ermsg = (char_u *)(map ? &quot;map()&quot; : &quot;filter()&quot;);</a>
<a name="ln5953">  const char *const arg_errmsg = (map</a>
<a name="ln5954">                                  ? N_(&quot;map() argument&quot;)</a>
<a name="ln5955">                                  : N_(&quot;filter() argument&quot;));</a>
<a name="ln5956">  int save_did_emsg;</a>
<a name="ln5957">  int idx = 0;</a>
<a name="ln5958"> </a>
<a name="ln5959">  if (argvars[0].v_type == VAR_LIST) {</a>
<a name="ln5960">    tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln5961">    if ((l = argvars[0].vval.v_list) == NULL</a>
<a name="ln5962">        || (!map</a>
<a name="ln5963">            &amp;&amp; var_check_lock(tv_list_locked(l), arg_errmsg, TV_TRANSLATE))) {</a>
<a name="ln5964">      return;</a>
<a name="ln5965">    }</a>
<a name="ln5966">  } else if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln5967">    tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln5968">    if ((d = argvars[0].vval.v_dict) == NULL</a>
<a name="ln5969">        || (!map &amp;&amp; var_check_lock(d-&gt;dv_lock, arg_errmsg, TV_TRANSLATE))) {</a>
<a name="ln5970">      return;</a>
<a name="ln5971">    }</a>
<a name="ln5972">  } else {</a>
<a name="ln5973">    EMSG2(_(e_listdictarg), ermsg);</a>
<a name="ln5974">    return;</a>
<a name="ln5975">  }</a>
<a name="ln5976"> </a>
<a name="ln5977">  expr = &amp;argvars[1];</a>
<a name="ln5978">  // On type errors, the preceding call has already displayed an error</a>
<a name="ln5979">  // message.  Avoid a misleading error message for an empty string that</a>
<a name="ln5980">  // was not passed as argument.</a>
<a name="ln5981">  if (expr-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln5982">    prepare_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln5983"> </a>
<a name="ln5984">    // We reset &quot;did_emsg&quot; to be able to detect whether an error</a>
<a name="ln5985">    // occurred during evaluation of the expression.</a>
<a name="ln5986">    save_did_emsg = did_emsg;</a>
<a name="ln5987">    did_emsg = FALSE;</a>
<a name="ln5988"> </a>
<a name="ln5989">    prepare_vimvar(VV_KEY, &amp;save_key);</a>
<a name="ln5990">    if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln5991">      vimvars[VV_KEY].vv_type = VAR_STRING;</a>
<a name="ln5992"> </a>
<a name="ln5993">      ht = &amp;d-&gt;dv_hashtab;</a>
<a name="ln5994">      hash_lock(ht);</a>
<a name="ln5995">      todo = (int)ht-&gt;ht_used;</a>
<a name="ln5996">      for (hi = ht-&gt;ht_array; todo &gt; 0; ++hi) {</a>
<a name="ln5997">        if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln5998">          --todo;</a>
<a name="ln5999"> </a>
<a name="ln6000">          di = TV_DICT_HI2DI(hi);</a>
<a name="ln6001">          if (map</a>
<a name="ln6002">              &amp;&amp; (var_check_lock(di-&gt;di_tv.v_lock, arg_errmsg, TV_TRANSLATE)</a>
<a name="ln6003">                  || var_check_ro(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE))) {</a>
<a name="ln6004">            break;</a>
<a name="ln6005">          }</a>
<a name="ln6006"> </a>
<a name="ln6007">          vimvars[VV_KEY].vv_str = vim_strsave(di-&gt;di_key);</a>
<a name="ln6008">          int r = filter_map_one(&amp;di-&gt;di_tv, expr, map, &amp;rem);</a>
<a name="ln6009">          tv_clear(&amp;vimvars[VV_KEY].vv_tv);</a>
<a name="ln6010">          if (r == FAIL || did_emsg) {</a>
<a name="ln6011">            break;</a>
<a name="ln6012">          }</a>
<a name="ln6013">          if (!map &amp;&amp; rem) {</a>
<a name="ln6014">            if (var_check_fixed(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)</a>
<a name="ln6015">                || var_check_ro(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln6016">              break;</a>
<a name="ln6017">            }</a>
<a name="ln6018">            tv_dict_item_remove(d, di);</a>
<a name="ln6019">          }</a>
<a name="ln6020">        }</a>
<a name="ln6021">      }</a>
<a name="ln6022">      hash_unlock(ht);</a>
<a name="ln6023">    } else {</a>
<a name="ln6024">      assert(argvars[0].v_type == VAR_LIST);</a>
<a name="ln6025">      vimvars[VV_KEY].vv_type = VAR_NUMBER;</a>
<a name="ln6026"> </a>
<a name="ln6027">      for (listitem_T *li = tv_list_first(l); li != NULL;) {</a>
<a name="ln6028">        if (map</a>
<a name="ln6029">            &amp;&amp; var_check_lock(TV_LIST_ITEM_TV(li)-&gt;v_lock, arg_errmsg,</a>
<a name="ln6030">                              TV_TRANSLATE)) {</a>
<a name="ln6031">          break;</a>
<a name="ln6032">        }</a>
<a name="ln6033">        vimvars[VV_KEY].vv_nr = idx;</a>
<a name="ln6034">        if (filter_map_one(TV_LIST_ITEM_TV(li), expr, map, &amp;rem) == FAIL</a>
<a name="ln6035">            || did_emsg) {</a>
<a name="ln6036">          break;</a>
<a name="ln6037">        }</a>
<a name="ln6038">        if (!map &amp;&amp; rem) {</a>
<a name="ln6039">          li = tv_list_item_remove(l, li);</a>
<a name="ln6040">        } else {</a>
<a name="ln6041">          li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln6042">        }</a>
<a name="ln6043">        idx++;</a>
<a name="ln6044">      }</a>
<a name="ln6045">    }</a>
<a name="ln6046"> </a>
<a name="ln6047">    restore_vimvar(VV_KEY, &amp;save_key);</a>
<a name="ln6048">    restore_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln6049"> </a>
<a name="ln6050">    did_emsg |= save_did_emsg;</a>
<a name="ln6051">  }</a>
<a name="ln6052">}</a>
<a name="ln6053"> </a>
<a name="ln6054">static int filter_map_one(typval_T *tv, typval_T *expr, int map, int *remp)</a>
<a name="ln6055">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln6056">{</a>
<a name="ln6057">  typval_T rettv;</a>
<a name="ln6058">  typval_T argv[3];</a>
<a name="ln6059">  int retval = FAIL;</a>
<a name="ln6060"> </a>
<a name="ln6061">  tv_copy(tv, &amp;vimvars[VV_VAL].vv_tv);</a>
<a name="ln6062">  argv[0] = vimvars[VV_KEY].vv_tv;</a>
<a name="ln6063">  argv[1] = vimvars[VV_VAL].vv_tv;</a>
<a name="ln6064">  if (eval_expr_typval(expr, argv, 2, &amp;rettv) == FAIL) {</a>
<a name="ln6065">    goto theend;</a>
<a name="ln6066">  }</a>
<a name="ln6067">  if (map) {</a>
<a name="ln6068">    // map(): replace the list item value.</a>
<a name="ln6069">    tv_clear(tv);</a>
<a name="ln6070">    rettv.v_lock = VAR_UNLOCKED;</a>
<a name="ln6071">    *tv = rettv;</a>
<a name="ln6072">  } else {</a>
<a name="ln6073">    bool error = false;</a>
<a name="ln6074"> </a>
<a name="ln6075">    // filter(): when expr is zero remove the item</a>
<a name="ln6076">    *remp = (tv_get_number_chk(&amp;rettv, &amp;error) == 0);</a>
<a name="ln6077">    tv_clear(&amp;rettv);</a>
<a name="ln6078">    // On type error, nothing has been removed; return FAIL to stop the</a>
<a name="ln6079">    // loop.  The error message was given by tv_get_number_chk().</a>
<a name="ln6080">    if (error) {</a>
<a name="ln6081">      goto theend;</a>
<a name="ln6082">    }</a>
<a name="ln6083">  }</a>
<a name="ln6084">  retval = OK;</a>
<a name="ln6085">theend:</a>
<a name="ln6086">  tv_clear(&amp;vimvars[VV_VAL].vv_tv);</a>
<a name="ln6087">  return retval;</a>
<a name="ln6088">}</a>
<a name="ln6089"> </a>
<a name="ln6090">void common_function(typval_T *argvars, typval_T *rettv,</a>
<a name="ln6091">                     bool is_funcref, FunPtr fptr)</a>
<a name="ln6092">{</a>
<a name="ln6093">  char_u      *s;</a>
<a name="ln6094">  char_u      *name;</a>
<a name="ln6095">  bool use_string = false;</a>
<a name="ln6096">  partial_T *arg_pt = NULL;</a>
<a name="ln6097">  char_u *trans_name = NULL;</a>
<a name="ln6098"> </a>
<a name="ln6099">  if (argvars[0].v_type == VAR_FUNC) {</a>
<a name="ln6100">    // function(MyFunc, [arg], dict)</a>
<a name="ln6101">    s = argvars[0].vval.v_string;</a>
<a name="ln6102">  } else if (argvars[0].v_type == VAR_PARTIAL</a>
<a name="ln6103">             &amp;&amp; argvars[0].vval.v_partial != NULL) {</a>
<a name="ln6104">    // function(dict.MyFunc, [arg])</a>
<a name="ln6105">    arg_pt = argvars[0].vval.v_partial;</a>
<a name="ln6106">    s = partial_name(arg_pt);</a>
<a name="ln6107">    // TODO(bfredl): do the entire nlua_is_table_from_lua dance</a>
<a name="ln6108">  } else {</a>
<a name="ln6109">    // function('MyFunc', [arg], dict)</a>
<a name="ln6110">    s = (char_u *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln6111">    use_string = true;</a>
<a name="ln6112">  }</a>
<a name="ln6113"> </a>
<a name="ln6114">  if ((use_string &amp;&amp; vim_strchr(s, AUTOLOAD_CHAR) == NULL) || is_funcref) {</a>
<a name="ln6115">    name = s;</a>
<a name="ln6116">    trans_name = trans_function_name(&amp;name, false,</a>
<a name="ln6117">                                     TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD</a>
<a name="ln6118">                                     | TFN_NO_DEREF, NULL, NULL);</a>
<a name="ln6119">    if (*name != NUL) {</a>
<a name="ln6120">      s = NULL;</a>
<a name="ln6121">    }</a>
<a name="ln6122">  }</a>
<a name="ln6123">  if (s == NULL || *s == NUL || (use_string &amp;&amp; ascii_isdigit(*s))</a>
<a name="ln6124">      || (is_funcref &amp;&amp; trans_name == NULL)) {</a>
<a name="ln6125">    emsgf(_(e_invarg2), (use_string</a>
<a name="ln6126">                         ? tv_get_string(&amp;argvars[0])</a>
<a name="ln6127">                         : (const char *)s));</a>
<a name="ln6128">    // Don't check an autoload name for existence here.</a>
<a name="ln6129">  } else if (trans_name != NULL</a>
<a name="ln6130">             &amp;&amp; (is_funcref ? find_func(trans_name) == NULL</a>
<a name="ln6131">                 : !translated_function_exists((const char *)trans_name))) {</a>
<a name="ln6132">    emsgf(_(&quot;E700: Unknown function: %s&quot;), s);</a>
<a name="ln6133">  } else {</a>
<a name="ln6134">    int dict_idx = 0;</a>
<a name="ln6135">    int arg_idx = 0;</a>
<a name="ln6136">    list_T *list = NULL;</a>
<a name="ln6137">    if (STRNCMP(s, &quot;s:&quot;, 2) == 0 || STRNCMP(s, &quot;&lt;SID&gt;&quot;, 5) == 0) {</a>
<a name="ln6138">      char sid_buf[25];</a>
<a name="ln6139">      int off = *s == 's' ? 2 : 5;</a>
<a name="ln6140"> </a>
<a name="ln6141">      // Expand s: and &lt;SID&gt; into &lt;SNR&gt;nr_, so that the function can</a>
<a name="ln6142">      // also be called from another script. Using trans_function_name()</a>
<a name="ln6143">      // would also work, but some plugins depend on the name being</a>
<a name="ln6144">      // printable text.</a>
<a name="ln6145">      snprintf(sid_buf, sizeof(sid_buf), &quot;&lt;SNR&gt;%&quot; PRId64 &quot;_&quot;,</a>
<a name="ln6146">               (int64_t)current_sctx.sc_sid);</a>
<a name="ln6147">      name = xmalloc(STRLEN(sid_buf) + STRLEN(s + off) + 1);</a>
<a name="ln6148">      STRCPY(name, sid_buf);</a>
<a name="ln6149">      STRCAT(name, s + off);</a>
<a name="ln6150">    } else {</a>
<a name="ln6151">      name = vim_strsave(s);</a>
<a name="ln6152">    }</a>
<a name="ln6153"> </a>
<a name="ln6154">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6155">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6156">        // function(name, [args], dict)</a>
<a name="ln6157">        arg_idx = 1;</a>
<a name="ln6158">        dict_idx = 2;</a>
<a name="ln6159">      } else if (argvars[1].v_type == VAR_DICT) {</a>
<a name="ln6160">        // function(name, dict)</a>
<a name="ln6161">        dict_idx = 1;</a>
<a name="ln6162">      } else {</a>
<a name="ln6163">        // function(name, [args])</a>
<a name="ln6164">        arg_idx = 1;</a>
<a name="ln6165">      }</a>
<a name="ln6166">      if (dict_idx &gt; 0) {</a>
<a name="ln6167">        if (argvars[dict_idx].v_type != VAR_DICT) {</a>
<a name="ln6168">          EMSG(_(&quot;E922: expected a dict&quot;));</a>
<a name="ln6169">          xfree(name);</a>
<a name="ln6170">          goto theend;</a>
<a name="ln6171">        }</a>
<a name="ln6172">        if (argvars[dict_idx].vval.v_dict == NULL) {</a>
<a name="ln6173">          dict_idx = 0;</a>
<a name="ln6174">        }</a>
<a name="ln6175">      }</a>
<a name="ln6176">      if (arg_idx &gt; 0) {</a>
<a name="ln6177">        if (argvars[arg_idx].v_type != VAR_LIST) {</a>
<a name="ln6178">          EMSG(_(&quot;E923: Second argument of function() must be &quot;</a>
<a name="ln6179">                 &quot;a list or a dict&quot;));</a>
<a name="ln6180">          xfree(name);</a>
<a name="ln6181">          goto theend;</a>
<a name="ln6182">        }</a>
<a name="ln6183">        list = argvars[arg_idx].vval.v_list;</a>
<a name="ln6184">        if (tv_list_len(list) == 0) {</a>
<a name="ln6185">          arg_idx = 0;</a>
<a name="ln6186">        } else if (tv_list_len(list) &gt; MAX_FUNC_ARGS) {</a>
<a name="ln6187">          emsg_funcname((char *)e_toomanyarg, s);</a>
<a name="ln6188">          xfree(name);</a>
<a name="ln6189">          goto theend;</a>
<a name="ln6190">        }</a>
<a name="ln6191">      }</a>
<a name="ln6192">    }</a>
<a name="ln6193">    if (dict_idx &gt; 0 || arg_idx &gt; 0 || arg_pt != NULL || is_funcref) {</a>
<a name="ln6194">      partial_T *const pt = xcalloc(1, sizeof(*pt));</a>
<a name="ln6195"> </a>
<a name="ln6196">      // result is a VAR_PARTIAL</a>
<a name="ln6197">      if (arg_idx &gt; 0 || (arg_pt != NULL &amp;&amp; arg_pt-&gt;pt_argc &gt; 0)) {</a>
<a name="ln6198">        const int arg_len = (arg_pt == NULL ? 0 : arg_pt-&gt;pt_argc);</a>
<a name="ln6199">        const int lv_len = tv_list_len(list);</a>
<a name="ln6200"> </a>
<a name="ln6201">        pt-&gt;pt_argc = arg_len + lv_len;</a>
<a name="ln6202">        pt-&gt;pt_argv = xmalloc(sizeof(pt-&gt;pt_argv[0]) * pt-&gt;pt_argc);</a>
<a name="ln6203">        int i = 0;</a>
<a name="ln6204">        for (; i &lt; arg_len; i++) {</a>
<a name="ln6205">          tv_copy(&amp;arg_pt-&gt;pt_argv[i], &amp;pt-&gt;pt_argv[i]);</a>
<a name="ln6206">        }</a>
<a name="ln6207">        if (lv_len &gt; 0) {</a>
<a name="ln6208">          TV_LIST_ITER(list, li, {</a>
<a name="ln6209">            tv_copy(TV_LIST_ITEM_TV(li), &amp;pt-&gt;pt_argv[i++]);</a>
<a name="ln6210">          });</a>
<a name="ln6211">        }</a>
<a name="ln6212">      }</a>
<a name="ln6213"> </a>
<a name="ln6214">      // For &quot;function(dict.func, [], dict)&quot; and &quot;func&quot; is a partial</a>
<a name="ln6215">      // use &quot;dict&quot;. That is backwards compatible.</a>
<a name="ln6216">      if (dict_idx &gt; 0) {</a>
<a name="ln6217">        // The dict is bound explicitly, pt_auto is false</a>
<a name="ln6218">        pt-&gt;pt_dict = argvars[dict_idx].vval.v_dict;</a>
<a name="ln6219">        (pt-&gt;pt_dict-&gt;dv_refcount)++;</a>
<a name="ln6220">      } else if (arg_pt != NULL) {</a>
<a name="ln6221">        // If the dict was bound automatically the result is also</a>
<a name="ln6222">        // bound automatically.</a>
<a name="ln6223">        pt-&gt;pt_dict = arg_pt-&gt;pt_dict;</a>
<a name="ln6224">        pt-&gt;pt_auto = arg_pt-&gt;pt_auto;</a>
<a name="ln6225">        if (pt-&gt;pt_dict != NULL) {</a>
<a name="ln6226">          (pt-&gt;pt_dict-&gt;dv_refcount)++;</a>
<a name="ln6227">        }</a>
<a name="ln6228">      }</a>
<a name="ln6229"> </a>
<a name="ln6230">      pt-&gt;pt_refcount = 1;</a>
<a name="ln6231">      if (arg_pt != NULL &amp;&amp; arg_pt-&gt;pt_func != NULL) {</a>
<a name="ln6232">        pt-&gt;pt_func = arg_pt-&gt;pt_func;</a>
<a name="ln6233">        func_ptr_ref(pt-&gt;pt_func);</a>
<a name="ln6234">        xfree(name);</a>
<a name="ln6235">      } else if (is_funcref) {</a>
<a name="ln6236">        pt-&gt;pt_func = find_func(trans_name);</a>
<a name="ln6237">        func_ptr_ref(pt-&gt;pt_func);</a>
<a name="ln6238">        xfree(name);</a>
<a name="ln6239">      } else {</a>
<a name="ln6240">        pt-&gt;pt_name = name;</a>
<a name="ln6241">        func_ref(name);</a>
<a name="ln6242">      }</a>
<a name="ln6243"> </a>
<a name="ln6244">      rettv-&gt;v_type = VAR_PARTIAL;</a>
<a name="ln6245">      rettv-&gt;vval.v_partial = pt;</a>
<a name="ln6246">    } else {</a>
<a name="ln6247">      // result is a VAR_FUNC</a>
<a name="ln6248">      rettv-&gt;v_type = VAR_FUNC;</a>
<a name="ln6249">      rettv-&gt;vval.v_string = name;</a>
<a name="ln6250">      func_ref(name);</a>
<a name="ln6251">    }</a>
<a name="ln6252">  }</a>
<a name="ln6253">theend:</a>
<a name="ln6254">  xfree(trans_name);</a>
<a name="ln6255">}</a>
<a name="ln6256"> </a>
<a name="ln6257">/// Returns buffer options, variables and other attributes in a dictionary.</a>
<a name="ln6258">dict_T *get_buffer_info(buf_T *buf)</a>
<a name="ln6259">{</a>
<a name="ln6260">  dict_T *const dict = tv_dict_alloc();</a>
<a name="ln6261"> </a>
<a name="ln6262">  tv_dict_add_nr(dict, S_LEN(&quot;bufnr&quot;), buf-&gt;b_fnum);</a>
<a name="ln6263">  tv_dict_add_str(dict, S_LEN(&quot;name&quot;),</a>
<a name="ln6264">                  buf-&gt;b_ffname != NULL ? (const char *)buf-&gt;b_ffname : &quot;&quot;);</a>
<a name="ln6265">  tv_dict_add_nr(dict, S_LEN(&quot;lnum&quot;),</a>
<a name="ln6266">                 buf == curbuf ? curwin-&gt;w_cursor.lnum : buflist_findlnum(buf));</a>
<a name="ln6267">  tv_dict_add_nr(dict, S_LEN(&quot;linecount&quot;), buf-&gt;b_ml.ml_line_count);</a>
<a name="ln6268">  tv_dict_add_nr(dict, S_LEN(&quot;loaded&quot;), buf-&gt;b_ml.ml_mfp != NULL);</a>
<a name="ln6269">  tv_dict_add_nr(dict, S_LEN(&quot;listed&quot;), buf-&gt;b_p_bl);</a>
<a name="ln6270">  tv_dict_add_nr(dict, S_LEN(&quot;changed&quot;), bufIsChanged(buf));</a>
<a name="ln6271">  tv_dict_add_nr(dict, S_LEN(&quot;changedtick&quot;), buf_get_changedtick(buf));</a>
<a name="ln6272">  tv_dict_add_nr(dict, S_LEN(&quot;hidden&quot;),</a>
<a name="ln6273">                 buf-&gt;b_ml.ml_mfp != NULL &amp;&amp; buf-&gt;b_nwindows == 0);</a>
<a name="ln6274"> </a>
<a name="ln6275">  // Get a reference to buffer variables</a>
<a name="ln6276">  tv_dict_add_dict(dict, S_LEN(&quot;variables&quot;), buf-&gt;b_vars);</a>
<a name="ln6277"> </a>
<a name="ln6278">  // List of windows displaying this buffer</a>
<a name="ln6279">  list_T *const windows = tv_list_alloc(kListLenMayKnow);</a>
<a name="ln6280">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln6281">    if (wp-&gt;w_buffer == buf) {</a>
<a name="ln6282">      tv_list_append_number(windows, (varnumber_T)wp-&gt;handle);</a>
<a name="ln6283">    }</a>
<a name="ln6284">  }</a>
<a name="ln6285">  tv_dict_add_list(dict, S_LEN(&quot;windows&quot;), windows);</a>
<a name="ln6286"> </a>
<a name="ln6287">  if (buf-&gt;b_signlist != NULL) {</a>
<a name="ln6288">    // List of signs placed in this buffer</a>
<a name="ln6289">    tv_dict_add_list(dict, S_LEN(&quot;signs&quot;), get_buffer_signs(buf));</a>
<a name="ln6290">  }</a>
<a name="ln6291"> </a>
<a name="ln6292">  tv_dict_add_nr(dict, S_LEN(&quot;lastused&quot;), buf-&gt;b_last_used);</a>
<a name="ln6293"> </a>
<a name="ln6294">  return dict;</a>
<a name="ln6295">}</a>
<a name="ln6296"> </a>
<a name="ln6297">/// Get the line number from VimL object</a>
<a name="ln6298">///</a>
<a name="ln6299">/// @note Unlike tv_get_lnum(), this one supports only &quot;$&quot; special string.</a>
<a name="ln6300">///</a>
<a name="ln6301">/// @param[in]  tv  Object to get value from. Is expected to be a number or</a>
<a name="ln6302">///                 a special string &quot;$&quot;.</a>
<a name="ln6303">/// @param[in]  buf  Buffer to take last line number from in case tv is &quot;$&quot;. May</a>
<a name="ln6304">///                  be NULL, in this case &quot;$&quot; results in zero return.</a>
<a name="ln6305">///</a>
<a name="ln6306">/// @return Line number or 0 in case of error.</a>
<a name="ln6307">linenr_T tv_get_lnum_buf(const typval_T *const tv,</a>
<a name="ln6308">                         const buf_T *const buf)</a>
<a name="ln6309">  FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6310">{</a>
<a name="ln6311">  if (tv-&gt;v_type == VAR_STRING</a>
<a name="ln6312">      &amp;&amp; tv-&gt;vval.v_string != NULL</a>
<a name="ln6313">      &amp;&amp; tv-&gt;vval.v_string[0] == '$'</a>
<a name="ln6314">      &amp;&amp; buf != NULL) {</a>
<a name="ln6315">    return buf-&gt;b_ml.ml_line_count;</a>
<a name="ln6316">  }</a>
<a name="ln6317">  return tv_get_number_chk(tv, NULL);</a>
<a name="ln6318">}</a>
<a name="ln6319"> </a>
<a name="ln6320">void get_qf_loc_list(int is_qf, win_T *wp, typval_T *what_arg,</a>
<a name="ln6321">                     typval_T *rettv)</a>
<a name="ln6322">{</a>
<a name="ln6323">  if (what_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln6324">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln6325">    if (is_qf || wp != NULL) {</a>
<a name="ln6326">      (void)get_errorlist(NULL, wp, -1, 0, rettv-&gt;vval.v_list);</a>
<a name="ln6327">    }</a>
<a name="ln6328">  } else {</a>
<a name="ln6329">    tv_dict_alloc_ret(rettv);</a>
<a name="ln6330">    if (is_qf || wp != NULL) {</a>
<a name="ln6331">      if (what_arg-&gt;v_type == VAR_DICT) {</a>
<a name="ln6332">        dict_T *d = what_arg-&gt;vval.v_dict;</a>
<a name="ln6333"> </a>
<a name="ln6334">        if (d != NULL) {</a>
<a name="ln6335">          qf_get_properties(wp, d, rettv-&gt;vval.v_dict);</a>
<a name="ln6336">        }</a>
<a name="ln6337">      } else {</a>
<a name="ln6338">        EMSG(_(e_dictreq));</a>
<a name="ln6339">      }</a>
<a name="ln6340">    }</a>
<a name="ln6341">  }</a>
<a name="ln6342">}</a>
<a name="ln6343"> </a>
<a name="ln6344">/// Returns information (variables, options, etc.) about a tab page</a>
<a name="ln6345">/// as a dictionary.</a>
<a name="ln6346">dict_T *get_tabpage_info(tabpage_T *tp, int tp_idx)</a>
<a name="ln6347">{</a>
<a name="ln6348">  dict_T *const dict = tv_dict_alloc();</a>
<a name="ln6349"> </a>
<a name="ln6350">  tv_dict_add_nr(dict, S_LEN(&quot;tabnr&quot;), tp_idx);</a>
<a name="ln6351"> </a>
<a name="ln6352">  list_T *const l = tv_list_alloc(kListLenMayKnow);</a>
<a name="ln6353">  FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln6354">    tv_list_append_number(l, (varnumber_T)wp-&gt;handle);</a>
<a name="ln6355">  }</a>
<a name="ln6356">  tv_dict_add_list(dict, S_LEN(&quot;windows&quot;), l);</a>
<a name="ln6357"> </a>
<a name="ln6358">  // Make a reference to tabpage variables</a>
<a name="ln6359">  tv_dict_add_dict(dict, S_LEN(&quot;variables&quot;), tp-&gt;tp_vars);</a>
<a name="ln6360"> </a>
<a name="ln6361">  return dict;</a>
<a name="ln6362">}</a>
<a name="ln6363"> </a>
<a name="ln6364">/// Returns information about a window as a dictionary.</a>
<a name="ln6365">dict_T *get_win_info(win_T *wp, int16_t tpnr, int16_t winnr)</a>
<a name="ln6366">{</a>
<a name="ln6367">  dict_T *const dict = tv_dict_alloc();</a>
<a name="ln6368"> </a>
<a name="ln6369">  tv_dict_add_nr(dict, S_LEN(&quot;tabnr&quot;), tpnr);</a>
<a name="ln6370">  tv_dict_add_nr(dict, S_LEN(&quot;winnr&quot;), winnr);</a>
<a name="ln6371">  tv_dict_add_nr(dict, S_LEN(&quot;winid&quot;), wp-&gt;handle);</a>
<a name="ln6372">  tv_dict_add_nr(dict, S_LEN(&quot;height&quot;), wp-&gt;w_height);</a>
<a name="ln6373">  tv_dict_add_nr(dict, S_LEN(&quot;winrow&quot;), wp-&gt;w_winrow + 1);</a>
<a name="ln6374">  tv_dict_add_nr(dict, S_LEN(&quot;topline&quot;), wp-&gt;w_topline);</a>
<a name="ln6375">  tv_dict_add_nr(dict, S_LEN(&quot;botline&quot;), wp-&gt;w_botline - 1);</a>
<a name="ln6376">  tv_dict_add_nr(dict, S_LEN(&quot;winbar&quot;), 0);</a>
<a name="ln6377">  tv_dict_add_nr(dict, S_LEN(&quot;width&quot;), wp-&gt;w_width);</a>
<a name="ln6378">  tv_dict_add_nr(dict, S_LEN(&quot;bufnr&quot;), wp-&gt;w_buffer-&gt;b_fnum);</a>
<a name="ln6379">  tv_dict_add_nr(dict, S_LEN(&quot;wincol&quot;), wp-&gt;w_wincol + 1);</a>
<a name="ln6380"> </a>
<a name="ln6381">  tv_dict_add_nr(dict, S_LEN(&quot;terminal&quot;), bt_terminal(wp-&gt;w_buffer));</a>
<a name="ln6382">  tv_dict_add_nr(dict, S_LEN(&quot;quickfix&quot;), bt_quickfix(wp-&gt;w_buffer));</a>
<a name="ln6383">  tv_dict_add_nr(dict, S_LEN(&quot;loclist&quot;),</a>
<a name="ln6384">                 (bt_quickfix(wp-&gt;w_buffer) &amp;&amp; wp-&gt;w_llist_ref != NULL));</a>
<a name="ln6385"> </a>
<a name="ln6386">  // Add a reference to window variables</a>
<a name="ln6387">  tv_dict_add_dict(dict, S_LEN(&quot;variables&quot;), wp-&gt;w_vars);</a>
<a name="ln6388"> </a>
<a name="ln6389">  return dict;</a>
<a name="ln6390">}</a>
<a name="ln6391"> </a>
<a name="ln6392">// Find window specified by &quot;vp&quot; in tabpage &quot;tp&quot;.</a>
<a name="ln6393">win_T *</a>
<a name="ln6394">find_win_by_nr(</a>
<a name="ln6395">    typval_T *vp,</a>
<a name="ln6396">    tabpage_T *tp         // NULL for current tab page</a>
<a name="ln6397">)</a>
<a name="ln6398">{</a>
<a name="ln6399">  int nr = (int)tv_get_number_chk(vp, NULL);</a>
<a name="ln6400"> </a>
<a name="ln6401">  if (nr &lt; 0) {</a>
<a name="ln6402">    return NULL;</a>
<a name="ln6403">  }</a>
<a name="ln6404"> </a>
<a name="ln6405">  if (nr == 0) {</a>
<a name="ln6406">    return curwin;</a>
<a name="ln6407">  }</a>
<a name="ln6408"> </a>
<a name="ln6409">  // This method accepts NULL as an alias for curtab.</a>
<a name="ln6410">  if (tp == NULL) {</a>
<a name="ln6411">     tp = curtab;</a>
<a name="ln6412">  }</a>
<a name="ln6413"> </a>
<a name="ln6414">  FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln6415">    if (nr &gt;= LOWEST_WIN_ID) {</a>
<a name="ln6416">      if (wp-&gt;handle == nr) {</a>
<a name="ln6417">        return wp;</a>
<a name="ln6418">      }</a>
<a name="ln6419">    } else if (--nr &lt;= 0) {</a>
<a name="ln6420">      return wp;</a>
<a name="ln6421">    }</a>
<a name="ln6422">  }</a>
<a name="ln6423">  return NULL;</a>
<a name="ln6424">}</a>
<a name="ln6425"> </a>
<a name="ln6426">/// Find window specified by &quot;wvp&quot; in tabpage &quot;tvp&quot;.</a>
<a name="ln6427">win_T *find_tabwin(typval_T *wvp, typval_T *tvp)</a>
<a name="ln6428">{</a>
<a name="ln6429">  win_T *wp = NULL;</a>
<a name="ln6430">  tabpage_T *tp = NULL;</a>
<a name="ln6431"> </a>
<a name="ln6432">  if (wvp-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln6433">    if (tvp-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln6434">      long n = tv_get_number(tvp);</a>
<a name="ln6435">      if (n &gt;= 0) {</a>
<a name="ln6436">        tp = find_tabpage(n);</a>
<a name="ln6437">      }</a>
<a name="ln6438">    } else {</a>
<a name="ln6439">      tp = curtab;</a>
<a name="ln6440">    }</a>
<a name="ln6441"> </a>
<a name="ln6442">    if (tp != NULL) {</a>
<a name="ln6443">      wp = find_win_by_nr(wvp, tp);</a>
<a name="ln6444">    }</a>
<a name="ln6445">  } else {</a>
<a name="ln6446">    wp = curwin;</a>
<a name="ln6447">  }</a>
<a name="ln6448"> </a>
<a name="ln6449">  return wp;</a>
<a name="ln6450">}</a>
<a name="ln6451"> </a>
<a name="ln6452">/*</a>
<a name="ln6453"> * getwinvar() and gettabwinvar()</a>
<a name="ln6454"> */</a>
<a name="ln6455">void</a>
<a name="ln6456">getwinvar(</a>
<a name="ln6457">    typval_T *argvars,</a>
<a name="ln6458">    typval_T *rettv,</a>
<a name="ln6459">    int off                    // 1 for gettabwinvar()</a>
<a name="ln6460">)</a>
<a name="ln6461">{</a>
<a name="ln6462">  win_T *win, *oldcurwin;</a>
<a name="ln6463">  dictitem_T *v;</a>
<a name="ln6464">  tabpage_T *tp = NULL;</a>
<a name="ln6465">  tabpage_T *oldtabpage = NULL;</a>
<a name="ln6466">  bool done = false;</a>
<a name="ln6467"> </a>
<a name="ln6468">  if (off == 1) {</a>
<a name="ln6469">    tp = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln6470">  } else {</a>
<a name="ln6471">    tp = curtab;</a>
<a name="ln6472">  }</a>
<a name="ln6473">  win = find_win_by_nr(&amp;argvars[off], tp);</a>
<a name="ln6474">  const char *varname = tv_get_string_chk(&amp;argvars[off + 1]);</a>
<a name="ln6475"> </a>
<a name="ln6476">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6477">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6478"> </a>
<a name="ln6479">  emsg_off++;</a>
<a name="ln6480">  if (win != NULL &amp;&amp; varname != NULL) {</a>
<a name="ln6481">    // Set curwin to be our win, temporarily.  Also set the tabpage,</a>
<a name="ln6482">    // otherwise the window is not valid. Only do this when needed,</a>
<a name="ln6483">    // autocommands get blocked.</a>
<a name="ln6484">    bool need_switch_win = tp != curtab || win != curwin;</a>
<a name="ln6485">    if (!need_switch_win</a>
<a name="ln6486">        || switch_win(&amp;oldcurwin, &amp;oldtabpage, win, tp, true) == OK) {</a>
<a name="ln6487">      if (*varname == '&amp;') {</a>
<a name="ln6488">        if (varname[1] == NUL) {</a>
<a name="ln6489">          // get all window-local options in a dict</a>
<a name="ln6490">          dict_T *opts = get_winbuf_options(false);</a>
<a name="ln6491"> </a>
<a name="ln6492">          if (opts != NULL) {</a>
<a name="ln6493">            tv_dict_set_ret(rettv, opts);</a>
<a name="ln6494">            done = true;</a>
<a name="ln6495">          }</a>
<a name="ln6496">        } else if (get_option_tv(&amp;varname, rettv, 1) == OK) {</a>
<a name="ln6497">          // window-local-option</a>
<a name="ln6498">          done = true;</a>
<a name="ln6499">        }</a>
<a name="ln6500">      } else {</a>
<a name="ln6501">        // Look up the variable.</a>
<a name="ln6502">        // Let getwinvar({nr}, &quot;&quot;) return the &quot;w:&quot; dictionary.</a>
<a name="ln6503">        v = find_var_in_ht(&amp;win-&gt;w_vars-&gt;dv_hashtab, 'w', varname,</a>
<a name="ln6504">                           strlen(varname), false);</a>
<a name="ln6505">        if (v != NULL) {</a>
<a name="ln6506">          tv_copy(&amp;v-&gt;di_tv, rettv);</a>
<a name="ln6507">          done = true;</a>
<a name="ln6508">        }</a>
<a name="ln6509">      }</a>
<a name="ln6510">    }</a>
<a name="ln6511"> </a>
<a name="ln6512">    if (need_switch_win) {</a>
<a name="ln6513">      // restore previous notion of curwin</a>
<a name="ln6514">      restore_win(oldcurwin, oldtabpage, true);</a>
<a name="ln6515">    }</a>
<a name="ln6516">  }</a>
<a name="ln6517">  emsg_off--;</a>
<a name="ln6518"> </a>
<a name="ln6519">  if (!done &amp;&amp; argvars[off + 2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6520">    // use the default return value</a>
<a name="ln6521">    tv_copy(&amp;argvars[off + 2], rettv);</a>
<a name="ln6522">  }</a>
<a name="ln6523">}</a>
<a name="ln6524"> </a>
<a name="ln6525">/*</a>
<a name="ln6526"> * This function is used by f_input() and f_inputdialog() functions. The third</a>
<a name="ln6527"> * argument to f_input() specifies the type of completion to use at the</a>
<a name="ln6528"> * prompt. The third argument to f_inputdialog() specifies the value to return</a>
<a name="ln6529"> * when the user cancels the prompt.</a>
<a name="ln6530"> */</a>
<a name="ln6531">void get_user_input(const typval_T *const argvars,</a>
<a name="ln6532">                    typval_T *const rettv,</a>
<a name="ln6533">                    const bool inputdialog,</a>
<a name="ln6534">                    const bool secret)</a>
<a name="ln6535">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6536">{</a>
<a name="ln6537">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6538">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln6539"> </a>
<a name="ln6540">  const char *prompt = &quot;&quot;;</a>
<a name="ln6541">  const char *defstr = &quot;&quot;;</a>
<a name="ln6542">  const char *cancelreturn = NULL;</a>
<a name="ln6543">  const char *xp_name = NULL;</a>
<a name="ln6544">  Callback input_callback = { .type = kCallbackNone };</a>
<a name="ln6545">  char prompt_buf[NUMBUFLEN];</a>
<a name="ln6546">  char defstr_buf[NUMBUFLEN];</a>
<a name="ln6547">  char cancelreturn_buf[NUMBUFLEN];</a>
<a name="ln6548">  char xp_name_buf[NUMBUFLEN];</a>
<a name="ln6549">  char def[1] = { 0 };</a>
<a name="ln6550">  if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln6551">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6552">      EMSG(_(&quot;E5050: {opts} must be the only argument&quot;));</a>
<a name="ln6553">      return;</a>
<a name="ln6554">    }</a>
<a name="ln6555">    dict_T *const dict = argvars[0].vval.v_dict;</a>
<a name="ln6556">    prompt = tv_dict_get_string_buf_chk(dict, S_LEN(&quot;prompt&quot;), prompt_buf, &quot;&quot;);</a>
<a name="ln6557">    if (prompt == NULL) {</a>
<a name="ln6558">      return;</a>
<a name="ln6559">    }</a>
<a name="ln6560">    defstr = tv_dict_get_string_buf_chk(dict, S_LEN(&quot;default&quot;), defstr_buf, &quot;&quot;);</a>
<a name="ln6561">    if (defstr == NULL) {</a>
<a name="ln6562">      return;</a>
<a name="ln6563">    }</a>
<a name="ln6564">    cancelreturn = tv_dict_get_string_buf_chk(dict, S_LEN(&quot;cancelreturn&quot;),</a>
<a name="ln6565">                                              cancelreturn_buf, def);</a>
<a name="ln6566">    if (cancelreturn == NULL) {  // error</a>
<a name="ln6567">      return;</a>
<a name="ln6568">    }</a>
<a name="ln6569">    if (*cancelreturn == NUL) {</a>
<a name="ln6570">      cancelreturn = NULL;</a>
<a name="ln6571">    }</a>
<a name="ln6572">    xp_name = tv_dict_get_string_buf_chk(dict, S_LEN(&quot;completion&quot;),</a>
<a name="ln6573">                                         xp_name_buf, def);</a>
<a name="ln6574">    if (xp_name == NULL) {  // error</a>
<a name="ln6575">      return;</a>
<a name="ln6576">    }</a>
<a name="ln6577">    if (xp_name == def) {  // default to NULL</a>
<a name="ln6578">      xp_name = NULL;</a>
<a name="ln6579">    }</a>
<a name="ln6580">    if (!tv_dict_get_callback(dict, S_LEN(&quot;highlight&quot;), &amp;input_callback)) {</a>
<a name="ln6581">      return;</a>
<a name="ln6582">    }</a>
<a name="ln6583">  } else {</a>
<a name="ln6584">    prompt = tv_get_string_buf_chk(&amp;argvars[0], prompt_buf);</a>
<a name="ln6585">    if (prompt == NULL) {</a>
<a name="ln6586">      return;</a>
<a name="ln6587">    }</a>
<a name="ln6588">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln6589">      defstr = tv_get_string_buf_chk(&amp;argvars[1], defstr_buf);</a>
<a name="ln6590">      if (defstr == NULL) {</a>
<a name="ln6591">        return;</a>
<a name="ln6592">      }</a>
<a name="ln6593">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln6594">        const char *const arg2 = tv_get_string_buf_chk(&amp;argvars[2],</a>
<a name="ln6595">                                                       cancelreturn_buf);</a>
<a name="ln6596">        if (arg2 == NULL) {</a>
<a name="ln6597">          return;</a>
<a name="ln6598">        }</a>
<a name="ln6599">        if (inputdialog) {</a>
<a name="ln6600">          cancelreturn = arg2;</a>
<a name="ln6601">        } else {</a>
<a name="ln6602">          xp_name = arg2;</a>
<a name="ln6603">        }</a>
<a name="ln6604">      }</a>
<a name="ln6605">    }</a>
<a name="ln6606">  }</a>
<a name="ln6607"> </a>
<a name="ln6608">  int xp_type = EXPAND_NOTHING;</a>
<a name="ln6609">  char *xp_arg = NULL;</a>
<a name="ln6610">  if (xp_name != NULL) {</a>
<a name="ln6611">    // input() with a third argument: completion</a>
<a name="ln6612">    const int xp_namelen = (int)strlen(xp_name);</a>
<a name="ln6613"> </a>
<a name="ln6614">    uint32_t argt;</a>
<a name="ln6615">    if (parse_compl_arg((char_u *)xp_name, xp_namelen, &amp;xp_type,</a>
<a name="ln6616">                        &amp;argt, (char_u **)&amp;xp_arg) == FAIL) {</a>
<a name="ln6617">      return;</a>
<a name="ln6618">    }</a>
<a name="ln6619">  }</a>
<a name="ln6620"> </a>
<a name="ln6621">  const bool cmd_silent_save = cmd_silent;</a>
<a name="ln6622"> </a>
<a name="ln6623">  cmd_silent = false;  // Want to see the prompt.</a>
<a name="ln6624">  // Only the part of the message after the last NL is considered as</a>
<a name="ln6625">  // prompt for the command line, unlsess cmdline is externalized</a>
<a name="ln6626">  const char *p = prompt;</a>
<a name="ln6627">  if (!ui_has(kUICmdline)) {</a>
<a name="ln6628">    const char *lastnl = strrchr(prompt, '\n');</a>
<a name="ln6629">    if (lastnl != NULL) {</a>
<a name="ln6630">      p = lastnl+1;</a>
<a name="ln6631">      msg_start();</a>
<a name="ln6632">      msg_clr_eos();</a>
<a name="ln6633">      msg_puts_attr_len(prompt, p - prompt, echo_attr);</a>
<a name="ln6634">      msg_didout = false;</a>
<a name="ln6635">      msg_starthere();</a>
<a name="ln6636">    }</a>
<a name="ln6637">  }</a>
<a name="ln6638">  cmdline_row = msg_row;</a>
<a name="ln6639"> </a>
<a name="ln6640">  stuffReadbuffSpec(defstr);</a>
<a name="ln6641"> </a>
<a name="ln6642">  const int save_ex_normal_busy = ex_normal_busy;</a>
<a name="ln6643">  ex_normal_busy = 0;</a>
<a name="ln6644">  rettv-&gt;vval.v_string =</a>
<a name="ln6645">    (char_u *)getcmdline_prompt(secret ? NUL : '@', p, echo_attr,</a>
<a name="ln6646">                                xp_type, xp_arg, input_callback);</a>
<a name="ln6647">  ex_normal_busy = save_ex_normal_busy;</a>
<a name="ln6648">  callback_free(&amp;input_callback);</a>
<a name="ln6649"> </a>
<a name="ln6650">  if (rettv-&gt;vval.v_string == NULL &amp;&amp; cancelreturn != NULL) {</a>
<a name="ln6651">    rettv-&gt;vval.v_string = (char_u *)xstrdup(cancelreturn);</a>
<a name="ln6652">  }</a>
<a name="ln6653"> </a>
<a name="ln6654">  xfree(xp_arg);</a>
<a name="ln6655"> </a>
<a name="ln6656">  // Since the user typed this, no need to wait for return.</a>
<a name="ln6657">  need_wait_return = false;</a>
<a name="ln6658">  msg_didout = false;</a>
<a name="ln6659">  cmd_silent = cmd_silent_save;</a>
<a name="ln6660">}</a>
<a name="ln6661"> </a>
<a name="ln6662">/// Turn a dictionary into a list</a>
<a name="ln6663">///</a>
<a name="ln6664">/// @param[in]  tv  Dictionary to convert. Is checked for actually being</a>
<a name="ln6665">///                 a dictionary, will give an error if not.</a>
<a name="ln6666">/// @param[out]  rettv  Location where result will be saved.</a>
<a name="ln6667">/// @param[in]  what  What to save in rettv.</a>
<a name="ln6668">void dict_list(typval_T *const tv, typval_T *const rettv,</a>
<a name="ln6669">               const DictListType what)</a>
<a name="ln6670">{</a>
<a name="ln6671">  if (tv-&gt;v_type != VAR_DICT) {</a>
<a name="ln6672">    EMSG(_(e_dictreq));</a>
<a name="ln6673">    return;</a>
<a name="ln6674">  }</a>
<a name="ln6675">  if (tv-&gt;vval.v_dict == NULL) {</a>
<a name="ln6676">    return;</a>
<a name="ln6677">  }</a>
<a name="ln6678"> </a>
<a name="ln6679">  tv_list_alloc_ret(rettv, tv_dict_len(tv-&gt;vval.v_dict));</a>
<a name="ln6680"> </a>
<a name="ln6681">  TV_DICT_ITER(tv-&gt;vval.v_dict, di, {</a>
<a name="ln6682">    typval_T tv_item = { .v_lock = VAR_UNLOCKED };</a>
<a name="ln6683"> </a>
<a name="ln6684">    switch (what) {</a>
<a name="ln6685">      case kDictListKeys: {</a>
<a name="ln6686">        tv_item.v_type = VAR_STRING;</a>
<a name="ln6687">        tv_item.vval.v_string = vim_strsave(di-&gt;di_key);</a>
<a name="ln6688">        break;</a>
<a name="ln6689">      }</a>
<a name="ln6690">      case kDictListValues: {</a>
<a name="ln6691">        tv_copy(&amp;di-&gt;di_tv, &amp;tv_item);</a>
<a name="ln6692">        break;</a>
<a name="ln6693">      }</a>
<a name="ln6694">      case kDictListItems: {</a>
<a name="ln6695">        // items()</a>
<a name="ln6696">        list_T *const sub_l = tv_list_alloc(2);</a>
<a name="ln6697">        tv_item.v_type = VAR_LIST;</a>
<a name="ln6698">        tv_item.vval.v_list = sub_l;</a>
<a name="ln6699">        tv_list_ref(sub_l);</a>
<a name="ln6700"> </a>
<a name="ln6701">        tv_list_append_owned_tv(sub_l, (typval_T) {</a>
<a name="ln6702">          .v_type = VAR_STRING,</a>
<a name="ln6703">          .v_lock = VAR_UNLOCKED,</a>
<a name="ln6704">          .vval.v_string = (char_u *)xstrdup((const char *)di-&gt;di_key),</a>
<a name="ln6705">        });</a>
<a name="ln6706"> </a>
<a name="ln6707">        tv_list_append_tv(sub_l, &amp;di-&gt;di_tv);</a>
<a name="ln6708"> </a>
<a name="ln6709">        break;</a>
<a name="ln6710">      }</a>
<a name="ln6711">    }</a>
<a name="ln6712"> </a>
<a name="ln6713">    tv_list_append_owned_tv(rettv-&gt;vval.v_list, tv_item);</a>
<a name="ln6714">  });</a>
<a name="ln6715">}</a>
<a name="ln6716"> </a>
<a name="ln6717">/// Builds a process argument vector from a VimL object (typval_T).</a>
<a name="ln6718">///</a>
<a name="ln6719">/// @param[in]  cmd_tv      VimL object</a>
<a name="ln6720">/// @param[out] cmd         Returns the command or executable name.</a>
<a name="ln6721">/// @param[out] executable  Returns `false` if argv[0] is not executable.</a>
<a name="ln6722">///</a>
<a name="ln6723">/// @returns Result of `shell_build_argv()` if `cmd_tv` is a String.</a>
<a name="ln6724">///          Else, string values of `cmd_tv` copied to a (char **) list with</a>
<a name="ln6725">///          argv[0] resolved to full path ($PATHEXT-resolved on Windows).</a>
<a name="ln6726">char **tv_to_argv(typval_T *cmd_tv, const char **cmd, bool *executable)</a>
<a name="ln6727">{</a>
<a name="ln6728">  if (cmd_tv-&gt;v_type == VAR_STRING) {  // String =&gt; &quot;shell semantics&quot;.</a>
<a name="ln6729">    const char *cmd_str = tv_get_string(cmd_tv);</a>
<a name="ln6730">    if (cmd) {</a>
<a name="ln6731">      *cmd = cmd_str;</a>
<a name="ln6732">    }</a>
<a name="ln6733">    return shell_build_argv(cmd_str, NULL);</a>
<a name="ln6734">  }</a>
<a name="ln6735"> </a>
<a name="ln6736">  if (cmd_tv-&gt;v_type != VAR_LIST) {</a>
<a name="ln6737">    EMSG2(_(e_invarg2), &quot;expected String or List&quot;);</a>
<a name="ln6738">    return NULL;</a>
<a name="ln6739">  }</a>
<a name="ln6740"> </a>
<a name="ln6741">  list_T *argl = cmd_tv-&gt;vval.v_list;</a>
<a name="ln6742">  int argc = tv_list_len(argl);</a>
<a name="ln6743">  if (!argc) {</a>
<a name="ln6744">    EMSG(_(e_invarg));  // List must have at least one item.</a>
<a name="ln6745">    return NULL;</a>
<a name="ln6746">  }</a>
<a name="ln6747"> </a>
<a name="ln6748">  const char *arg0 = tv_get_string_chk(TV_LIST_ITEM_TV(tv_list_first(argl)));</a>
<a name="ln6749">  char *exe_resolved = NULL;</a>
<a name="ln6750">  if (!arg0 || !os_can_exe(arg0, &amp;exe_resolved, true)) {</a>
<a name="ln6751">    if (arg0 &amp;&amp; executable) {</a>
<a name="ln6752">      char buf[IOSIZE];</a>
<a name="ln6753">      snprintf(buf, sizeof(buf), &quot;'%s' is not executable&quot;, arg0);</a>
<a name="ln6754">      EMSG3(_(e_invargNval), &quot;cmd&quot;, buf);</a>
<a name="ln6755">      *executable = false;</a>
<a name="ln6756">    }</a>
<a name="ln6757">    return NULL;</a>
<a name="ln6758">  }</a>
<a name="ln6759"> </a>
<a name="ln6760">  if (cmd) {</a>
<a name="ln6761">    *cmd = exe_resolved;</a>
<a name="ln6762">  }</a>
<a name="ln6763"> </a>
<a name="ln6764">  // Build the argument vector</a>
<a name="ln6765">  int i = 0;</a>
<a name="ln6766">  char **argv = xcalloc(argc + 1, sizeof(char *));</a>
<a name="ln6767">  TV_LIST_ITER_CONST(argl, arg, {</a>
<a name="ln6768">    const char *a = tv_get_string_chk(TV_LIST_ITEM_TV(arg));</a>
<a name="ln6769">    if (!a) {</a>
<a name="ln6770">      // Did emsg in tv_get_string_chk; just deallocate argv.</a>
<a name="ln6771">      shell_free_argv(argv);</a>
<a name="ln6772">      xfree(exe_resolved);</a>
<a name="ln6773">      return NULL;</a>
<a name="ln6774">    }</a>
<a name="ln6775">    argv[i++] = xstrdup(a);</a>
<a name="ln6776">  });</a>
<a name="ln6777">  // Replace argv[0] with absolute path. The only reason for this is to make</a>
<a name="ln6778">  // $PATHEXT work on Windows with jobstart([…]). #9569</a>
<a name="ln6779">  xfree(argv[0]);</a>
<a name="ln6780">  argv[0] = exe_resolved;</a>
<a name="ln6781"> </a>
<a name="ln6782">  return argv;</a>
<a name="ln6783">}</a>
<a name="ln6784"> </a>
<a name="ln6785">/// Fill a dictionary with all applicable maparg() like dictionaries</a>
<a name="ln6786">///</a>
<a name="ln6787">/// @param  dict  The dictionary to be filled</a>
<a name="ln6788">/// @param  mp  The maphash that contains the mapping information</a>
<a name="ln6789">/// @param  buffer_value  The &quot;buffer&quot; value</a>
<a name="ln6790">/// @param  compatible  True for compatible with old maparg() dict</a>
<a name="ln6791">void mapblock_fill_dict(dict_T *const dict,</a>
<a name="ln6792">                        const mapblock_T *const mp,</a>
<a name="ln6793">                        long buffer_value,</a>
<a name="ln6794">                        bool compatible)</a>
<a name="ln6795">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6796">{</a>
<a name="ln6797">  char *const lhs = str2special_save((const char *)mp-&gt;m_keys,</a>
<a name="ln6798">                                     compatible, !compatible);</a>
<a name="ln6799">  char *const mapmode = map_mode_to_chars(mp-&gt;m_mode);</a>
<a name="ln6800">  varnumber_T noremap_value;</a>
<a name="ln6801"> </a>
<a name="ln6802">  if (compatible) {</a>
<a name="ln6803">    // Keep old compatible behavior</a>
<a name="ln6804">    // This is unable to determine whether a mapping is a &lt;script&gt; mapping</a>
<a name="ln6805">    noremap_value = !!mp-&gt;m_noremap;</a>
<a name="ln6806">  } else {</a>
<a name="ln6807">    // Distinguish between &lt;script&gt; mapping</a>
<a name="ln6808">    // If it's not a &lt;script&gt; mapping, check if it's a noremap</a>
<a name="ln6809">    noremap_value = mp-&gt;m_noremap == REMAP_SCRIPT ? 2 : !!mp-&gt;m_noremap;</a>
<a name="ln6810">  }</a>
<a name="ln6811"> </a>
<a name="ln6812">  if (compatible) {</a>
<a name="ln6813">    tv_dict_add_str(dict, S_LEN(&quot;rhs&quot;), (const char *)mp-&gt;m_orig_str);</a>
<a name="ln6814">  } else {</a>
<a name="ln6815">    tv_dict_add_allocated_str(dict, S_LEN(&quot;rhs&quot;),</a>
<a name="ln6816">                              str2special_save((const char *)mp-&gt;m_str, false,</a>
<a name="ln6817">                                               true));</a>
<a name="ln6818">  }</a>
<a name="ln6819">  tv_dict_add_allocated_str(dict, S_LEN(&quot;lhs&quot;), lhs);</a>
<a name="ln6820">  tv_dict_add_nr(dict, S_LEN(&quot;noremap&quot;), noremap_value);</a>
<a name="ln6821">  tv_dict_add_nr(dict, S_LEN(&quot;script&quot;), mp-&gt;m_noremap == REMAP_SCRIPT ? 1 : 0);</a>
<a name="ln6822">  tv_dict_add_nr(dict, S_LEN(&quot;expr&quot;),  mp-&gt;m_expr ? 1 : 0);</a>
<a name="ln6823">  tv_dict_add_nr(dict, S_LEN(&quot;silent&quot;), mp-&gt;m_silent ? 1 : 0);</a>
<a name="ln6824">  tv_dict_add_nr(dict, S_LEN(&quot;sid&quot;), (varnumber_T)mp-&gt;m_script_ctx.sc_sid);</a>
<a name="ln6825">  tv_dict_add_nr(dict, S_LEN(&quot;lnum&quot;), (varnumber_T)mp-&gt;m_script_ctx.sc_lnum);</a>
<a name="ln6826">  tv_dict_add_nr(dict, S_LEN(&quot;buffer&quot;), (varnumber_T)buffer_value);</a>
<a name="ln6827">  tv_dict_add_nr(dict, S_LEN(&quot;nowait&quot;), mp-&gt;m_nowait ? 1 : 0);</a>
<a name="ln6828">  tv_dict_add_allocated_str(dict, S_LEN(&quot;mode&quot;), mapmode);</a>
<a name="ln6829">}</a>
<a name="ln6830"> </a>
<a name="ln6831">int matchadd_dict_arg(typval_T *tv, const char **conceal_char,</a>
<a name="ln6832">                      win_T **win)</a>
<a name="ln6833">{</a>
<a name="ln6834">  dictitem_T *di;</a>
<a name="ln6835"> </a>
<a name="ln6836">  if (tv-&gt;v_type != VAR_DICT) {</a>
<a name="ln6837">    EMSG(_(e_dictreq));</a>
<a name="ln6838">    return FAIL;</a>
<a name="ln6839">  }</a>
<a name="ln6840"> </a>
<a name="ln6841">  if ((di = tv_dict_find(tv-&gt;vval.v_dict, S_LEN(&quot;conceal&quot;))) != NULL) {</a>
<a name="ln6842">    *conceal_char = tv_get_string(&amp;di-&gt;di_tv);</a>
<a name="ln6843">  }</a>
<a name="ln6844"> </a>
<a name="ln6845">  if ((di = tv_dict_find(tv-&gt;vval.v_dict, S_LEN(&quot;window&quot;))) != NULL) {</a>
<a name="ln6846">    *win = find_win_by_nr_or_id(&amp;di-&gt;di_tv);</a>
<a name="ln6847">    if (*win == NULL) {</a>
<a name="ln6848">      EMSG(_(e_invalwindow));</a>
<a name="ln6849">      return FAIL;</a>
<a name="ln6850">    }</a>
<a name="ln6851">  }</a>
<a name="ln6852"> </a>
<a name="ln6853">  return OK;</a>
<a name="ln6854">}</a>
<a name="ln6855"> </a>
<a name="ln6856">void return_register(int regname, typval_T *rettv)</a>
<a name="ln6857">{</a>
<a name="ln6858">  char_u buf[2] = { regname, 0 };</a>
<a name="ln6859"> </a>
<a name="ln6860">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln6861">  rettv-&gt;vval.v_string = vim_strsave(buf);</a>
<a name="ln6862">}</a>
<a name="ln6863"> </a>
<a name="ln6864">void screenchar_adjust_grid(ScreenGrid **grid, int *row, int *col)</a>
<a name="ln6865">{</a>
<a name="ln6866">  // TODO(bfredl): this is a hack for legacy tests which use screenchar()</a>
<a name="ln6867">  // to check printed messages on the screen (but not floats etc</a>
<a name="ln6868">  // as these are not legacy features). If the compositor is refactored to</a>
<a name="ln6869">  // have its own buffer, this should just read from it instead.</a>
<a name="ln6870">  msg_scroll_flush();</a>
<a name="ln6871">  if (msg_grid.chars &amp;&amp; msg_grid.comp_index &gt; 0 &amp;&amp; *row &gt;= msg_grid.comp_row</a>
<a name="ln6872">      &amp;&amp; *row &lt; (msg_grid.Rows + msg_grid.comp_row)</a>
<a name="ln6873">      &amp;&amp; *col &lt; msg_grid.Columns) {</a>
<a name="ln6874">    *grid = &amp;msg_grid;</a>
<a name="ln6875">    *row -= msg_grid.comp_row;</a>
<a name="ln6876">  }</a>
<a name="ln6877">}</a>
<a name="ln6878"> </a>
<a name="ln6879">/// Set line or list of lines in buffer &quot;buf&quot;.</a>
<a name="ln6880">void set_buffer_lines(buf_T *buf, linenr_T lnum_arg, bool append,</a>
<a name="ln6881">                      const typval_T *lines, typval_T *rettv)</a>
<a name="ln6882">  FUNC_ATTR_NONNULL_ARG(4, 5)</a>
<a name="ln6883">{</a>
<a name="ln6884">  linenr_T lnum = lnum_arg + (append ? 1 : 0);</a>
<a name="ln6885">  const char *line = NULL;</a>
<a name="ln6886">  list_T      *l = NULL;</a>
<a name="ln6887">  listitem_T  *li = NULL;</a>
<a name="ln6888">  long        added = 0;</a>
<a name="ln6889">  linenr_T append_lnum;</a>
<a name="ln6890">  buf_T       *curbuf_save = NULL;</a>
<a name="ln6891">  win_T       *curwin_save = NULL;</a>
<a name="ln6892">  const bool is_curbuf = buf == curbuf;</a>
<a name="ln6893"> </a>
<a name="ln6894">  // When using the current buffer ml_mfp will be set if needed.  Useful when</a>
<a name="ln6895">  // setline() is used on startup.  For other buffers the buffer must be</a>
<a name="ln6896">  // loaded.</a>
<a name="ln6897">  if (buf == NULL || (!is_curbuf &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) || lnum &lt; 1) {</a>
<a name="ln6898">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln6899">    return;</a>
<a name="ln6900">  }</a>
<a name="ln6901"> </a>
<a name="ln6902">  if (!is_curbuf) {</a>
<a name="ln6903">    curbuf_save = curbuf;</a>
<a name="ln6904">    curwin_save = curwin;</a>
<a name="ln6905">    curbuf = buf;</a>
<a name="ln6906">    find_win_for_curbuf();</a>
<a name="ln6907">  }</a>
<a name="ln6908"> </a>
<a name="ln6909">  if (append) {</a>
<a name="ln6910">    // appendbufline() uses the line number below which we insert</a>
<a name="ln6911">    append_lnum = lnum - 1;</a>
<a name="ln6912">  } else {</a>
<a name="ln6913">    // setbufline() uses the line number above which we insert, we only</a>
<a name="ln6914">    // append if it's below the last line</a>
<a name="ln6915">    append_lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln6916">  }</a>
<a name="ln6917"> </a>
<a name="ln6918">  if (lines-&gt;v_type == VAR_LIST) {</a>
<a name="ln6919">    l = lines-&gt;vval.v_list;</a>
<a name="ln6920">    li = tv_list_first(l);</a>
<a name="ln6921">  } else {</a>
<a name="ln6922">    line = tv_get_string_chk(lines);</a>
<a name="ln6923">  }</a>
<a name="ln6924"> </a>
<a name="ln6925">  // Default result is zero == OK.</a>
<a name="ln6926">  for (;; ) {</a>
<a name="ln6927">    if (lines-&gt;v_type == VAR_LIST) {</a>
<a name="ln6928">      // List argument, get next string.</a>
<a name="ln6929">      if (li == NULL) {</a>
<a name="ln6930">        break;</a>
<a name="ln6931">      }</a>
<a name="ln6932">      line = tv_get_string_chk(TV_LIST_ITEM_TV(li));</a>
<a name="ln6933">      li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln6934">    }</a>
<a name="ln6935"> </a>
<a name="ln6936">    rettv-&gt;vval.v_number = 1;  // FAIL</a>
<a name="ln6937">    if (line == NULL || lnum &gt; curbuf-&gt;b_ml.ml_line_count + 1) {</a>
<a name="ln6938">      break;</a>
<a name="ln6939">    }</a>
<a name="ln6940"> </a>
<a name="ln6941">    // When coming here from Insert mode, sync undo, so that this can be</a>
<a name="ln6942">    // undone separately from what was previously inserted.</a>
<a name="ln6943">    if (u_sync_once == 2) {</a>
<a name="ln6944">      u_sync_once = 1;  // notify that u_sync() was called</a>
<a name="ln6945">      u_sync(true);</a>
<a name="ln6946">    }</a>
<a name="ln6947"> </a>
<a name="ln6948">    if (!append &amp;&amp; lnum &lt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6949">      // Existing line, replace it.</a>
<a name="ln6950">      int old_len = (int)STRLEN(ml_get(lnum));</a>
<a name="ln6951">      if (u_savesub(lnum) == OK</a>
<a name="ln6952">          &amp;&amp; ml_replace(lnum, (char_u *)line, true) == OK) {</a>
<a name="ln6953">        inserted_bytes(lnum, 0, old_len, STRLEN(line));</a>
<a name="ln6954">        if (is_curbuf &amp;&amp; lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln6955">          check_cursor_col();</a>
<a name="ln6956">        }</a>
<a name="ln6957">        rettv-&gt;vval.v_number = 0;  // OK</a>
<a name="ln6958">      }</a>
<a name="ln6959">    } else if (added &gt; 0 || u_save(lnum - 1, lnum) == OK) {</a>
<a name="ln6960">      // append the line.</a>
<a name="ln6961">      added++;</a>
<a name="ln6962">      if (ml_append(lnum - 1, (char_u *)line, 0, false) == OK) {</a>
<a name="ln6963">        rettv-&gt;vval.v_number = 0;  // OK</a>
<a name="ln6964">      }</a>
<a name="ln6965">    }</a>
<a name="ln6966"> </a>
<a name="ln6967">    if (l == NULL) {  // only one string argument</a>
<a name="ln6968">      break;</a>
<a name="ln6969">    }</a>
<a name="ln6970">    lnum++;</a>
<a name="ln6971">  }</a>
<a name="ln6972"> </a>
<a name="ln6973">  if (added &gt; 0) {</a>
<a name="ln6974">    appended_lines_mark(append_lnum, added);</a>
<a name="ln6975"> </a>
<a name="ln6976">    // Only adjust the cursor for buffers other than the current, unless it</a>
<a name="ln6977">    // is the current window. For curbuf and other windows it has been done</a>
<a name="ln6978">    // in mark_adjust_internal().</a>
<a name="ln6979">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln6980">      if (wp-&gt;w_buffer == buf</a>
<a name="ln6981">          &amp;&amp; (wp-&gt;w_buffer != curbuf || wp == curwin)</a>
<a name="ln6982">          &amp;&amp; wp-&gt;w_cursor.lnum &gt; append_lnum) {</a>
<a name="ln6983">        wp-&gt;w_cursor.lnum += added;</a>
<a name="ln6984">      }</a>
<a name="ln6985">    }</a>
<a name="ln6986">    check_cursor_col();</a>
<a name="ln6987">    update_topline(curwin);</a>
<a name="ln6988">  }</a>
<a name="ln6989"> </a>
<a name="ln6990">  if (!is_curbuf) {</a>
<a name="ln6991">     curbuf = curbuf_save;</a>
<a name="ln6992">     curwin = curwin_save;</a>
<a name="ln6993">  }</a>
<a name="ln6994">}</a>
<a name="ln6995"> </a>
<a name="ln6996">/*</a>
<a name="ln6997"> * &quot;setwinvar()&quot; and &quot;settabwinvar()&quot; functions</a>
<a name="ln6998"> */</a>
<a name="ln6999"> </a>
<a name="ln7000">void setwinvar(typval_T *argvars, typval_T *rettv, int off)</a>
<a name="ln7001">{</a>
<a name="ln7002">  if (check_secure()) {</a>
<a name="ln7003">    return;</a>
<a name="ln7004">  }</a>
<a name="ln7005"> </a>
<a name="ln7006">  tabpage_T *tp = NULL;</a>
<a name="ln7007">  if (off == 1) {</a>
<a name="ln7008">    tp = find_tabpage((int)tv_get_number_chk(&amp;argvars[0], NULL));</a>
<a name="ln7009">  } else {</a>
<a name="ln7010">    tp = curtab;</a>
<a name="ln7011">  }</a>
<a name="ln7012">  win_T *const win = find_win_by_nr(&amp;argvars[off], tp);</a>
<a name="ln7013">  const char *varname = tv_get_string_chk(&amp;argvars[off + 1]);</a>
<a name="ln7014">  typval_T *varp = &amp;argvars[off + 2];</a>
<a name="ln7015"> </a>
<a name="ln7016">  if (win != NULL &amp;&amp; varname != NULL &amp;&amp; varp != NULL) {</a>
<a name="ln7017">    win_T       *save_curwin;</a>
<a name="ln7018">    tabpage_T   *save_curtab;</a>
<a name="ln7019">    bool need_switch_win = tp != curtab || win != curwin;</a>
<a name="ln7020">    if (!need_switch_win</a>
<a name="ln7021">        || switch_win(&amp;save_curwin, &amp;save_curtab, win, tp, true) == OK) {</a>
<a name="ln7022">      if (*varname == '&amp;') {</a>
<a name="ln7023">        long numval;</a>
<a name="ln7024">        bool error = false;</a>
<a name="ln7025"> </a>
<a name="ln7026">        varname++;</a>
<a name="ln7027">        numval = tv_get_number_chk(varp, &amp;error);</a>
<a name="ln7028">        char nbuf[NUMBUFLEN];</a>
<a name="ln7029">        const char *const strval = tv_get_string_buf_chk(varp, nbuf);</a>
<a name="ln7030">        if (!error &amp;&amp; strval != NULL) {</a>
<a name="ln7031">          set_option_value(varname, numval, strval, OPT_LOCAL);</a>
<a name="ln7032">        }</a>
<a name="ln7033">      } else {</a>
<a name="ln7034">        const size_t varname_len = strlen(varname);</a>
<a name="ln7035">        char *const winvarname = xmalloc(varname_len + 3);</a>
<a name="ln7036">        memcpy(winvarname, &quot;w:&quot;, 2);</a>
<a name="ln7037">        memcpy(winvarname + 2, varname, varname_len + 1);</a>
<a name="ln7038">        set_var(winvarname, varname_len + 2, varp, true);</a>
<a name="ln7039">        xfree(winvarname);</a>
<a name="ln7040">      }</a>
<a name="ln7041">    }</a>
<a name="ln7042">    if (need_switch_win) {</a>
<a name="ln7043">      restore_win(save_curwin, save_curtab, true);</a>
<a name="ln7044">    }</a>
<a name="ln7045">  }</a>
<a name="ln7046">}</a>
<a name="ln7047"> </a>
<a name="ln7048">/// &quot;stdpath()&quot; helper for list results</a>
<a name="ln7049">void get_xdg_var_list(const XDGVarType xdg, typval_T *rettv)</a>
<a name="ln7050">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7051">{</a>
<a name="ln7052">  const void *iter = NULL;</a>
<a name="ln7053">  list_T *const list = tv_list_alloc(kListLenShouldKnow);</a>
<a name="ln7054">  rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln7055">  rettv-&gt;vval.v_list = list;</a>
<a name="ln7056">  tv_list_ref(list);</a>
<a name="ln7057">  char *const dirs = stdpaths_get_xdg_var(xdg);</a>
<a name="ln7058">  if (dirs == NULL) {</a>
<a name="ln7059">    return;</a>
<a name="ln7060">  }</a>
<a name="ln7061">  do {</a>
<a name="ln7062">    size_t dir_len;</a>
<a name="ln7063">    const char *dir;</a>
<a name="ln7064">    iter = vim_env_iter(ENV_SEPCHAR, dirs, iter, &amp;dir, &amp;dir_len);</a>
<a name="ln7065">    if (dir != NULL &amp;&amp; dir_len &gt; 0) {</a>
<a name="ln7066">      char *dir_with_nvim = xmemdupz(dir, dir_len);</a>
<a name="ln7067">      dir_with_nvim = concat_fnames_realloc(dir_with_nvim, &quot;nvim&quot;, true);</a>
<a name="ln7068">      tv_list_append_string(list, dir_with_nvim, strlen(dir_with_nvim));</a>
<a name="ln7069">      xfree(dir_with_nvim);</a>
<a name="ln7070">    }</a>
<a name="ln7071">  } while (iter != NULL);</a>
<a name="ln7072">  xfree(dirs);</a>
<a name="ln7073">}</a>
<a name="ln7074"> </a>
<a name="ln7075">static list_T *string_to_list(const char *str, size_t len, const bool keepempty)</a>
<a name="ln7076">{</a>
<a name="ln7077">  if (!keepempty &amp;&amp; str[len - 1] == NL) {</a>
<a name="ln7078">    len--;</a>
<a name="ln7079">  }</a>
<a name="ln7080">  list_T *const list = tv_list_alloc(kListLenMayKnow);</a>
<a name="ln7081">  encode_list_write(list, str, len);</a>
<a name="ln7082">  return list;</a>
<a name="ln7083">}</a>
<a name="ln7084"> </a>
<a name="ln7085">// os_system wrapper. Handles 'verbose', :profile, and v:shell_error.</a>
<a name="ln7086">void get_system_output_as_rettv(typval_T *argvars, typval_T *rettv,</a>
<a name="ln7087">                                bool retlist)</a>
<a name="ln7088">{</a>
<a name="ln7089">  proftime_T wait_time;</a>
<a name="ln7090">  bool profiling = do_profiling == PROF_YES;</a>
<a name="ln7091"> </a>
<a name="ln7092">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln7093">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln7094"> </a>
<a name="ln7095">  if (check_secure()) {</a>
<a name="ln7096">    return;</a>
<a name="ln7097">  }</a>
<a name="ln7098"> </a>
<a name="ln7099">  // get input to the shell command (if any), and its length</a>
<a name="ln7100">  ptrdiff_t input_len;</a>
<a name="ln7101">  char *input = save_tv_as_string(&amp;argvars[1], &amp;input_len, false);</a>
<a name="ln7102">  if (input_len &lt; 0) {</a>
<a name="ln7103">    assert(input == NULL);</a>
<a name="ln7104">    return;</a>
<a name="ln7105">  }</a>
<a name="ln7106"> </a>
<a name="ln7107">  // get shell command to execute</a>
<a name="ln7108">  bool executable = true;</a>
<a name="ln7109">  char **argv = tv_to_argv(&amp;argvars[0], NULL, &amp;executable);</a>
<a name="ln7110">  if (!argv) {</a>
<a name="ln7111">    if (!executable) {</a>
<a name="ln7112">      set_vim_var_nr(VV_SHELL_ERROR, (long)-1);</a>
<a name="ln7113">    }</a>
<a name="ln7114">    xfree(input);</a>
<a name="ln7115">    return;  // Already did emsg.</a>
<a name="ln7116">  }</a>
<a name="ln7117"> </a>
<a name="ln7118">  if (p_verbose &gt; 3) {</a>
<a name="ln7119">    char *cmdstr = shell_argv_to_str(argv);</a>
<a name="ln7120">    verbose_enter_scroll();</a>
<a name="ln7121">    smsg(_(&quot;Executing command: \&quot;%s\&quot;&quot;), cmdstr);</a>
<a name="ln7122">    msg_puts(&quot;\n\n&quot;);</a>
<a name="ln7123">    verbose_leave_scroll();</a>
<a name="ln7124">    xfree(cmdstr);</a>
<a name="ln7125">  }</a>
<a name="ln7126"> </a>
<a name="ln7127">  if (profiling) {</a>
<a name="ln7128">    prof_child_enter(&amp;wait_time);</a>
<a name="ln7129">  }</a>
<a name="ln7130"> </a>
<a name="ln7131">  // execute the command</a>
<a name="ln7132">  size_t nread = 0;</a>
<a name="ln7133">  char *res = NULL;</a>
<a name="ln7134">  int status = os_system(argv, input, input_len, &amp;res, &amp;nread);</a>
<a name="ln7135"> </a>
<a name="ln7136">  if (profiling) {</a>
<a name="ln7137">    prof_child_exit(&amp;wait_time);</a>
<a name="ln7138">  }</a>
<a name="ln7139"> </a>
<a name="ln7140">  xfree(input);</a>
<a name="ln7141"> </a>
<a name="ln7142">  set_vim_var_nr(VV_SHELL_ERROR, (long) status);</a>
<a name="ln7143"> </a>
<a name="ln7144">  if (res == NULL) {</a>
<a name="ln7145">    if (retlist) {</a>
<a name="ln7146">      // return an empty list when there's no output</a>
<a name="ln7147">      tv_list_alloc_ret(rettv, 0);</a>
<a name="ln7148">    } else {</a>
<a name="ln7149">      rettv-&gt;vval.v_string = (char_u *) xstrdup(&quot;&quot;);</a>
<a name="ln7150">    }</a>
<a name="ln7151">    return;</a>
<a name="ln7152">  }</a>
<a name="ln7153"> </a>
<a name="ln7154">  if (retlist) {</a>
<a name="ln7155">    int keepempty = 0;</a>
<a name="ln7156">    if (argvars[1].v_type != VAR_UNKNOWN &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln7157">      keepempty = tv_get_number(&amp;argvars[2]);</a>
<a name="ln7158">    }</a>
<a name="ln7159">    rettv-&gt;vval.v_list = string_to_list(res, nread, (bool)keepempty);</a>
<a name="ln7160">    tv_list_ref(rettv-&gt;vval.v_list);</a>
<a name="ln7161">    rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln7162"> </a>
<a name="ln7163">    xfree(res);</a>
<a name="ln7164">  } else {</a>
<a name="ln7165">    // res may contain several NULs before the final terminating one.</a>
<a name="ln7166">    // Replace them with SOH (1) like in get_cmd_output() to avoid truncation.</a>
<a name="ln7167">    memchrsub(res, NUL, 1, nread);</a>
<a name="ln7168">#ifdef USE_CRNL</a>
<a name="ln7169">    // translate &lt;CR&gt;&lt;NL&gt; into &lt;NL&gt;</a>
<a name="ln7170">    char *d = res;</a>
<a name="ln7171">    for (char *s = res; *s; ++s) {</a>
<a name="ln7172">      if (s[0] == CAR &amp;&amp; s[1] == NL) {</a>
<a name="ln7173">        ++s;</a>
<a name="ln7174">      }</a>
<a name="ln7175"> </a>
<a name="ln7176">      *d++ = *s;</a>
<a name="ln7177">    }</a>
<a name="ln7178"> </a>
<a name="ln7179">    *d = NUL;</a>
<a name="ln7180">#endif</a>
<a name="ln7181">    rettv-&gt;vval.v_string = (char_u *) res;</a>
<a name="ln7182">  }</a>
<a name="ln7183">}</a>
<a name="ln7184"> </a>
<a name="ln7185">bool callback_from_typval(Callback *const callback, typval_T *const arg)</a>
<a name="ln7186">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7187">{</a>
<a name="ln7188">  int r = OK;</a>
<a name="ln7189"> </a>
<a name="ln7190">  if (arg-&gt;v_type == VAR_PARTIAL &amp;&amp; arg-&gt;vval.v_partial != NULL) {</a>
<a name="ln7191">    callback-&gt;data.partial = arg-&gt;vval.v_partial;</a>
<a name="ln7192">    callback-&gt;data.partial-&gt;pt_refcount++;</a>
<a name="ln7193">    callback-&gt;type = kCallbackPartial;</a>
<a name="ln7194">  } else if (arg-&gt;v_type == VAR_STRING</a>
<a name="ln7195">             &amp;&amp; arg-&gt;vval.v_string != NULL</a>
<a name="ln7196">             &amp;&amp; ascii_isdigit(*arg-&gt;vval.v_string)) {</a>
<a name="ln7197">    r = FAIL;</a>
<a name="ln7198">  } else if (arg-&gt;v_type == VAR_FUNC || arg-&gt;v_type == VAR_STRING) {</a>
<a name="ln7199">    char_u *name = arg-&gt;vval.v_string;</a>
<a name="ln7200">    if (name == NULL) {</a>
<a name="ln7201">      r = FAIL;</a>
<a name="ln7202">    } else if (*name == NUL) {</a>
<a name="ln7203">      callback-&gt;type = kCallbackNone;</a>
<a name="ln7204">      callback-&gt;data.funcref = NULL;</a>
<a name="ln7205">    } else {</a>
<a name="ln7206">      func_ref(name);</a>
<a name="ln7207">      callback-&gt;data.funcref = vim_strsave(name);</a>
<a name="ln7208">      callback-&gt;type = kCallbackFuncref;</a>
<a name="ln7209">    }</a>
<a name="ln7210">  } else if (nlua_is_table_from_lua(arg)) {</a>
<a name="ln7211">    char_u *name = nlua_register_table_as_callable(arg);</a>
<a name="ln7212"> </a>
<a name="ln7213">    if (name != NULL) {</a>
<a name="ln7214">      callback-&gt;data.funcref = vim_strsave(name);</a>
<a name="ln7215">      callback-&gt;type = kCallbackFuncref;</a>
<a name="ln7216">    } else {</a>
<a name="ln7217">      r = FAIL;</a>
<a name="ln7218">    }</a>
<a name="ln7219">  } else if (arg-&gt;v_type == VAR_SPECIAL</a>
<a name="ln7220">             || (arg-&gt;v_type == VAR_NUMBER &amp;&amp; arg-&gt;vval.v_number == 0)) {</a>
<a name="ln7221">    callback-&gt;type = kCallbackNone;</a>
<a name="ln7222">    callback-&gt;data.funcref = NULL;</a>
<a name="ln7223">  } else {</a>
<a name="ln7224">    r = FAIL;</a>
<a name="ln7225">  }</a>
<a name="ln7226"> </a>
<a name="ln7227">  if (r == FAIL) {</a>
<a name="ln7228">    EMSG(_(&quot;E921: Invalid callback argument&quot;));</a>
<a name="ln7229">    return false;</a>
<a name="ln7230">  }</a>
<a name="ln7231">  return true;</a>
<a name="ln7232">}</a>
<a name="ln7233"> </a>
<a name="ln7234">bool callback_call(Callback *const callback, const int argcount_in,</a>
<a name="ln7235">                   typval_T *const argvars_in, typval_T *const rettv)</a>
<a name="ln7236">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7237">{</a>
<a name="ln7238">  partial_T *partial;</a>
<a name="ln7239">  char_u *name;</a>
<a name="ln7240">  switch (callback-&gt;type) {</a>
<a name="ln7241">    case kCallbackFuncref:</a>
<a name="ln7242">      name = callback-&gt;data.funcref;</a>
<a name="ln7243">      partial = NULL;</a>
<a name="ln7244">      break;</a>
<a name="ln7245"> </a>
<a name="ln7246">    case kCallbackPartial:</a>
<a name="ln7247">      partial = callback-&gt;data.partial;</a>
<a name="ln7248">      name = partial_name(partial);</a>
<a name="ln7249">      break;</a>
<a name="ln7250"> </a>
<a name="ln7251">    case kCallbackNone:</a>
<a name="ln7252">      return false;</a>
<a name="ln7253">      break;</a>
<a name="ln7254"> </a>
<a name="ln7255">    default:</a>
<a name="ln7256">      abort();</a>
<a name="ln7257">  }</a>
<a name="ln7258"> </a>
<a name="ln7259">  int dummy;</a>
<a name="ln7260">  return call_func(name, -1, rettv, argcount_in, argvars_in,</a>
<a name="ln7261">                   NULL, curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum, &amp;dummy,</a>
<a name="ln7262">                   true, partial, NULL);</a>
<a name="ln7263">}</a>
<a name="ln7264"> </a>
<a name="ln7265">static bool set_ref_in_callback(Callback *callback, int copyID,</a>
<a name="ln7266">                                ht_stack_T **ht_stack,</a>
<a name="ln7267">                                list_stack_T **list_stack)</a>
<a name="ln7268">{</a>
<a name="ln7269">  typval_T tv;</a>
<a name="ln7270">  switch (callback-&gt;type) {</a>
<a name="ln7271">    case kCallbackFuncref:</a>
<a name="ln7272">    case kCallbackNone:</a>
<a name="ln7273">      break;</a>
<a name="ln7274"> </a>
<a name="ln7275">    case kCallbackPartial:</a>
<a name="ln7276">      tv.v_type = VAR_PARTIAL;</a>
<a name="ln7277">      tv.vval.v_partial = callback-&gt;data.partial;</a>
<a name="ln7278">      return set_ref_in_item(&amp;tv, copyID, ht_stack, list_stack);</a>
<a name="ln7279">      break;</a>
<a name="ln7280"> </a>
<a name="ln7281"> </a>
<a name="ln7282">    default:</a>
<a name="ln7283">      abort();</a>
<a name="ln7284">  }</a>
<a name="ln7285">  return false;</a>
<a name="ln7286">}</a>
<a name="ln7287"> </a>
<a name="ln7288">static bool set_ref_in_callback_reader(CallbackReader *reader, int copyID,</a>
<a name="ln7289">                                       ht_stack_T **ht_stack,</a>
<a name="ln7290">                                       list_stack_T **list_stack)</a>
<a name="ln7291">{</a>
<a name="ln7292">  if (set_ref_in_callback(&amp;reader-&gt;cb, copyID, ht_stack, list_stack)) {</a>
<a name="ln7293">    return true;</a>
<a name="ln7294">  }</a>
<a name="ln7295"> </a>
<a name="ln7296">  if (reader-&gt;self) {</a>
<a name="ln7297">    typval_T tv;</a>
<a name="ln7298">    tv.v_type = VAR_DICT;</a>
<a name="ln7299">    tv.vval.v_dict = reader-&gt;self;</a>
<a name="ln7300">    return set_ref_in_item(&amp;tv, copyID, ht_stack, list_stack);</a>
<a name="ln7301">  }</a>
<a name="ln7302">  return false;</a>
<a name="ln7303">}</a>
<a name="ln7304"> </a>
<a name="ln7305">timer_T *find_timer_by_nr(varnumber_T xx)</a>
<a name="ln7306">{</a>
<a name="ln7307">    return pmap_get(uint64_t)(timers, xx);</a>
<a name="ln7308">}</a>
<a name="ln7309"> </a>
<a name="ln7310">void add_timer_info(typval_T *rettv, timer_T *timer)</a>
<a name="ln7311">{</a>
<a name="ln7312">  list_T *list = rettv-&gt;vval.v_list;</a>
<a name="ln7313">  dict_T *dict = tv_dict_alloc();</a>
<a name="ln7314"> </a>
<a name="ln7315">  tv_list_append_dict(list, dict);</a>
<a name="ln7316">  tv_dict_add_nr(dict, S_LEN(&quot;id&quot;), timer-&gt;timer_id);</a>
<a name="ln7317">  tv_dict_add_nr(dict, S_LEN(&quot;time&quot;), timer-&gt;timeout);</a>
<a name="ln7318">  tv_dict_add_nr(dict, S_LEN(&quot;paused&quot;), timer-&gt;paused);</a>
<a name="ln7319"> </a>
<a name="ln7320">  tv_dict_add_nr(dict, S_LEN(&quot;repeat&quot;),</a>
<a name="ln7321">                 (timer-&gt;repeat_count &lt; 0 ? -1 : timer-&gt;repeat_count));</a>
<a name="ln7322"> </a>
<a name="ln7323">  dictitem_T *di = tv_dict_item_alloc(&quot;callback&quot;);</a>
<a name="ln7324">  if (tv_dict_add(dict, di) == FAIL) {</a>
<a name="ln7325">    xfree(di);</a>
<a name="ln7326">    return;</a>
<a name="ln7327">  }</a>
<a name="ln7328"> </a>
<a name="ln7329">  callback_put(&amp;timer-&gt;callback, &amp;di-&gt;di_tv);</a>
<a name="ln7330">}</a>
<a name="ln7331"> </a>
<a name="ln7332">void add_timer_info_all(typval_T *rettv)</a>
<a name="ln7333">{</a>
<a name="ln7334">  tv_list_alloc_ret(rettv, timers-&gt;table-&gt;n_occupied);</a>
<a name="ln7335">  timer_T *timer;</a>
<a name="ln7336">  map_foreach_value(timers, timer, {</a>
<a name="ln7337">    if (!timer-&gt;stopped) {</a>
<a name="ln7338">      add_timer_info(rettv, timer);</a>
<a name="ln7339">    }</a>
<a name="ln7340">  })</a>
<a name="ln7341">}</a>
<a name="ln7342"> </a>
<a name="ln7343">// invoked on the main loop</a>
<a name="ln7344">void timer_due_cb(TimeWatcher *tw, void *data)</a>
<a name="ln7345">{</a>
<a name="ln7346">  timer_T *timer = (timer_T *)data;</a>
<a name="ln7347">  int save_did_emsg = did_emsg;</a>
<a name="ln7348">  int save_called_emsg = called_emsg;</a>
<a name="ln7349">  const bool save_ex_pressedreturn = get_pressedreturn();</a>
<a name="ln7350"> </a>
<a name="ln7351">  if (timer-&gt;stopped || timer-&gt;paused) {</a>
<a name="ln7352">    return;</a>
<a name="ln7353">  }</a>
<a name="ln7354"> </a>
<a name="ln7355">  timer-&gt;refcount++;</a>
<a name="ln7356">  // if repeat was negative repeat forever</a>
<a name="ln7357">  if (timer-&gt;repeat_count &gt;= 0 &amp;&amp; --timer-&gt;repeat_count == 0) {</a>
<a name="ln7358">    timer_stop(timer);</a>
<a name="ln7359">  }</a>
<a name="ln7360"> </a>
<a name="ln7361">  typval_T argv[2] = { TV_INITIAL_VALUE, TV_INITIAL_VALUE };</a>
<a name="ln7362">  argv[0].v_type = VAR_NUMBER;</a>
<a name="ln7363">  argv[0].vval.v_number = timer-&gt;timer_id;</a>
<a name="ln7364">  typval_T rettv = TV_INITIAL_VALUE;</a>
<a name="ln7365">  called_emsg = false;</a>
<a name="ln7366"> </a>
<a name="ln7367">  callback_call(&amp;timer-&gt;callback, 1, argv, &amp;rettv);</a>
<a name="ln7368"> </a>
<a name="ln7369">  // Handle error message</a>
<a name="ln7370">  if (called_emsg &amp;&amp; did_emsg) {</a>
<a name="ln7371">    timer-&gt;emsg_count++;</a>
<a name="ln7372">    if (current_exception != NULL) {</a>
<a name="ln7373">      discard_current_exception();</a>
<a name="ln7374">    }</a>
<a name="ln7375">  }</a>
<a name="ln7376">  did_emsg = save_did_emsg;</a>
<a name="ln7377">  called_emsg = save_called_emsg;</a>
<a name="ln7378">  set_pressedreturn(save_ex_pressedreturn);</a>
<a name="ln7379"> </a>
<a name="ln7380">  if (timer-&gt;emsg_count &gt;= 3) {</a>
<a name="ln7381">    timer_stop(timer);</a>
<a name="ln7382">  }</a>
<a name="ln7383"> </a>
<a name="ln7384">  tv_clear(&amp;rettv);</a>
<a name="ln7385"> </a>
<a name="ln7386">  if (!timer-&gt;stopped &amp;&amp; timer-&gt;timeout == 0) {</a>
<a name="ln7387">    // special case: timeout=0 means the callback will be</a>
<a name="ln7388">    // invoked again on the next event loop tick.</a>
<a name="ln7389">    // we don't use uv_idle_t to not spin the event loop</a>
<a name="ln7390">    // when the main loop is blocked.</a>
<a name="ln7391">    time_watcher_start(&amp;timer-&gt;tw, timer_due_cb, 0, 0);</a>
<a name="ln7392">  }</a>
<a name="ln7393">  timer_decref(timer);</a>
<a name="ln7394">}</a>
<a name="ln7395"> </a>
<a name="ln7396">uint64_t timer_start(const long timeout,</a>
<a name="ln7397">                     const int repeat_count,</a>
<a name="ln7398">                     const Callback *const callback)</a>
<a name="ln7399">{</a>
<a name="ln7400">  timer_T *timer = xmalloc(sizeof *timer);</a>
<a name="ln7401">  timer-&gt;refcount = 1;</a>
<a name="ln7402">  timer-&gt;stopped = false;</a>
<a name="ln7403">  timer-&gt;paused = false;</a>
<a name="ln7404">  timer-&gt;emsg_count = 0;</a>
<a name="ln7405">  timer-&gt;repeat_count = repeat_count;</a>
<a name="ln7406">  timer-&gt;timeout = timeout;</a>
<a name="ln7407">  timer-&gt;timer_id = last_timer_id++;</a>
<a name="ln7408">  timer-&gt;callback = *callback;</a>
<a name="ln7409"> </a>
<a name="ln7410">  time_watcher_init(&amp;main_loop, &amp;timer-&gt;tw, timer);</a>
<a name="ln7411">  timer-&gt;tw.events = multiqueue_new_child(main_loop.events);</a>
<a name="ln7412">  // if main loop is blocked, don't queue up multiple events</a>
<a name="ln7413">  timer-&gt;tw.blockable = true;</a>
<a name="ln7414">  time_watcher_start(&amp;timer-&gt;tw, timer_due_cb, timeout, timeout);</a>
<a name="ln7415"> </a>
<a name="ln7416">  pmap_put(uint64_t)(timers, timer-&gt;timer_id, timer);</a>
<a name="ln7417">  return timer-&gt;timer_id;</a>
<a name="ln7418">}</a>
<a name="ln7419"> </a>
<a name="ln7420">void timer_stop(timer_T *timer)</a>
<a name="ln7421">{</a>
<a name="ln7422">  if (timer-&gt;stopped) {</a>
<a name="ln7423">    // avoid double free</a>
<a name="ln7424">    return;</a>
<a name="ln7425">  }</a>
<a name="ln7426">  timer-&gt;stopped = true;</a>
<a name="ln7427">  time_watcher_stop(&amp;timer-&gt;tw);</a>
<a name="ln7428">  time_watcher_close(&amp;timer-&gt;tw, timer_close_cb);</a>
<a name="ln7429">}</a>
<a name="ln7430"> </a>
<a name="ln7431">// This will be run on the main loop after the last timer_due_cb, so at this</a>
<a name="ln7432">// point it is safe to free the callback.</a>
<a name="ln7433">static void timer_close_cb(TimeWatcher *tw, void *data)</a>
<a name="ln7434">{</a>
<a name="ln7435">  timer_T *timer = (timer_T *)data;</a>
<a name="ln7436">  multiqueue_free(timer-&gt;tw.events);</a>
<a name="ln7437">  callback_free(&amp;timer-&gt;callback);</a>
<a name="ln7438">  pmap_del(uint64_t)(timers, timer-&gt;timer_id);</a>
<a name="ln7439">  timer_decref(timer);</a>
<a name="ln7440">}</a>
<a name="ln7441"> </a>
<a name="ln7442">static void timer_decref(timer_T *timer)</a>
<a name="ln7443">{</a>
<a name="ln7444">  if (--timer-&gt;refcount == 0) {</a>
<a name="ln7445">    xfree(timer);</a>
<a name="ln7446">  }</a>
<a name="ln7447">}</a>
<a name="ln7448"> </a>
<a name="ln7449">void timer_stop_all(void)</a>
<a name="ln7450">{</a>
<a name="ln7451">  timer_T *timer;</a>
<a name="ln7452">  map_foreach_value(timers, timer, {</a>
<a name="ln7453">    timer_stop(timer);</a>
<a name="ln7454">  })</a>
<a name="ln7455">}</a>
<a name="ln7456"> </a>
<a name="ln7457">void timer_teardown(void)</a>
<a name="ln7458">{</a>
<a name="ln7459">  timer_stop_all();</a>
<a name="ln7460">}</a>
<a name="ln7461"> </a>
<a name="ln7462">/// Write &quot;list&quot; of strings to file &quot;fd&quot;.</a>
<a name="ln7463">///</a>
<a name="ln7464">/// @param  fp  File to write to.</a>
<a name="ln7465">/// @param[in]  list  List to write.</a>
<a name="ln7466">/// @param[in]  binary  Whether to write in binary mode.</a>
<a name="ln7467">///</a>
<a name="ln7468">/// @return true in case of success, false otherwise.</a>
<a name="ln7469">bool write_list(FileDescriptor *const fp, const list_T *const list,</a>
<a name="ln7470">                const bool binary)</a>
<a name="ln7471">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln7472">{</a>
<a name="ln7473">  int error = 0;</a>
<a name="ln7474">  TV_LIST_ITER_CONST(list, li, {</a>
<a name="ln7475">    const char *const s = tv_get_string_chk(TV_LIST_ITEM_TV(li));</a>
<a name="ln7476">    if (s == NULL) {</a>
<a name="ln7477">      return false;</a>
<a name="ln7478">    }</a>
<a name="ln7479">    const char *hunk_start = s;</a>
<a name="ln7480">    for (const char *p = hunk_start;; p++) {</a>
<a name="ln7481">      if (*p == NUL || *p == NL) {</a>
<a name="ln7482">        if (p != hunk_start) {</a>
<a name="ln7483">          const ptrdiff_t written = file_write(fp, hunk_start,</a>
<a name="ln7484">                                               (size_t)(p - hunk_start));</a>
<a name="ln7485">          if (written &lt; 0) {</a>
<a name="ln7486">            error = (int)written;</a>
<a name="ln7487">            goto write_list_error;</a>
<a name="ln7488">          }</a>
<a name="ln7489">        }</a>
<a name="ln7490">        if (*p == NUL) {</a>
<a name="ln7491">          break;</a>
<a name="ln7492">        } else {</a>
<a name="ln7493">          hunk_start = p + 1;</a>
<a name="ln7494">          const ptrdiff_t written = file_write(fp, (char[]){ NUL }, 1);</a>
<a name="ln7495">          if (written &lt; 0) {</a>
<a name="ln7496">            error = (int)written;</a>
<a name="ln7497">            break;</a>
<a name="ln7498">          }</a>
<a name="ln7499">        }</a>
<a name="ln7500">      }</a>
<a name="ln7501">    }</a>
<a name="ln7502">    if (!binary || TV_LIST_ITEM_NEXT(list, li) != NULL) {</a>
<a name="ln7503">      const ptrdiff_t written = file_write(fp, &quot;\n&quot;, 1);</a>
<a name="ln7504">      if (written &lt; 0) {</a>
<a name="ln7505">        error = (int)written;</a>
<a name="ln7506">        goto write_list_error;</a>
<a name="ln7507">      }</a>
<a name="ln7508">    }</a>
<a name="ln7509">  });</a>
<a name="ln7510">  if ((error = file_flush(fp)) != 0) {</a>
<a name="ln7511">    goto write_list_error;</a>
<a name="ln7512">  }</a>
<a name="ln7513">  return true;</a>
<a name="ln7514">write_list_error:</a>
<a name="ln7515">  emsgf(_(&quot;E80: Error while writing: %s&quot;), os_strerror(error));</a>
<a name="ln7516">  return false;</a>
<a name="ln7517">}</a>
<a name="ln7518"> </a>
<a name="ln7519">/// Saves a typval_T as a string.</a>
<a name="ln7520">///</a>
<a name="ln7521">/// For lists or buffers, replaces NLs with NUL and separates items with NLs.</a>
<a name="ln7522">///</a>
<a name="ln7523">/// @param[in]  tv   Value to store as a string.</a>
<a name="ln7524">/// @param[out] len  Length of the resulting string or -1 on error.</a>
<a name="ln7525">/// @param[in]  endnl If true, the output will end in a newline (if a list).</a>
<a name="ln7526">/// @returns an allocated string if `tv` represents a VimL string, list, or</a>
<a name="ln7527">///          number; NULL otherwise.</a>
<a name="ln7528">char *save_tv_as_string(typval_T *tv, ptrdiff_t *const len, bool endnl)</a>
<a name="ln7529">  FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7530">{</a>
<a name="ln7531">  *len = 0;</a>
<a name="ln7532">  if (tv-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln7533">    return NULL;</a>
<a name="ln7534">  }</a>
<a name="ln7535"> </a>
<a name="ln7536">  // For other types, let tv_get_string_buf_chk() get the value or</a>
<a name="ln7537">  // print an error.</a>
<a name="ln7538">  if (tv-&gt;v_type != VAR_LIST &amp;&amp; tv-&gt;v_type != VAR_NUMBER) {</a>
<a name="ln7539">    const char *ret = tv_get_string_chk(tv);</a>
<a name="ln7540">    if (ret) {</a>
<a name="ln7541">      *len = strlen(ret);</a>
<a name="ln7542">      return xmemdupz(ret, (size_t)(*len));</a>
<a name="ln7543">    } else {</a>
<a name="ln7544">      *len = -1;</a>
<a name="ln7545">      return NULL;</a>
<a name="ln7546">    }</a>
<a name="ln7547">  }</a>
<a name="ln7548"> </a>
<a name="ln7549">  if (tv-&gt;v_type == VAR_NUMBER) {  // Treat number as a buffer-id.</a>
<a name="ln7550">    buf_T *buf = buflist_findnr(tv-&gt;vval.v_number);</a>
<a name="ln7551">    if (buf) {</a>
<a name="ln7552">      for (linenr_T lnum = 1; lnum &lt;= buf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln7553">        for (char_u *p = ml_get_buf(buf, lnum, false); *p != NUL; p++) {</a>
<a name="ln7554">          *len += 1;</a>
<a name="ln7555">        }</a>
<a name="ln7556">        *len += 1;</a>
<a name="ln7557">      }</a>
<a name="ln7558">    } else {</a>
<a name="ln7559">      EMSGN(_(e_nobufnr), tv-&gt;vval.v_number);</a>
<a name="ln7560">      *len = -1;</a>
<a name="ln7561">      return NULL;</a>
<a name="ln7562">    }</a>
<a name="ln7563"> </a>
<a name="ln7564">    if (*len == 0) {</a>
<a name="ln7565">      return NULL;</a>
<a name="ln7566">    }</a>
<a name="ln7567"> </a>
<a name="ln7568">    char *ret = xmalloc(*len + 1);</a>
<a name="ln7569">    char *end = ret;</a>
<a name="ln7570">    for (linenr_T lnum = 1; lnum &lt;= buf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln7571">      for (char_u *p = ml_get_buf(buf, lnum, false); *p != NUL; p++) {</a>
<a name="ln7572">        *end++ = (*p == '\n') ? NUL : *p;</a>
<a name="ln7573">      }</a>
<a name="ln7574">      *end++ = '\n';</a>
<a name="ln7575">    }</a>
<a name="ln7576">    *end = NUL;</a>
<a name="ln7577">    *len = end - ret;</a>
<a name="ln7578">    return ret;</a>
<a name="ln7579">  }</a>
<a name="ln7580"> </a>
<a name="ln7581">  assert(tv-&gt;v_type == VAR_LIST);</a>
<a name="ln7582">  // Pre-calculate the resulting length.</a>
<a name="ln7583">  list_T *list = tv-&gt;vval.v_list;</a>
<a name="ln7584">  TV_LIST_ITER_CONST(list, li, {</a>
<a name="ln7585">    *len += strlen(tv_get_string(TV_LIST_ITEM_TV(li))) + 1;</a>
<a name="ln7586">  });</a>
<a name="ln7587"> </a>
<a name="ln7588">  if (*len == 0) {</a>
<a name="ln7589">    return NULL;</a>
<a name="ln7590">  }</a>
<a name="ln7591"> </a>
<a name="ln7592">  char *ret = xmalloc(*len + endnl);</a>
<a name="ln7593">  char *end = ret;</a>
<a name="ln7594">  TV_LIST_ITER_CONST(list, li, {</a>
<a name="ln7595">    for (const char *s = tv_get_string(TV_LIST_ITEM_TV(li)); *s != NUL; s++) {</a>
<a name="ln7596">      *end++ = (*s == '\n') ? NUL : *s;</a>
<a name="ln7597">    }</a>
<a name="ln7598">    if (endnl || TV_LIST_ITEM_NEXT(list, li) != NULL) {</a>
<a name="ln7599">      *end++ = '\n';</a>
<a name="ln7600">    }</a>
<a name="ln7601">  });</a>
<a name="ln7602">  *end = NUL;</a>
<a name="ln7603">  *len = end - ret;</a>
<a name="ln7604">  return ret;</a>
<a name="ln7605">}</a>
<a name="ln7606"> </a>
<a name="ln7607">/// Translate a VimL object into a position</a>
<a name="ln7608">///</a>
<a name="ln7609">/// Accepts VAR_LIST and VAR_STRING objects. Does not give an error for invalid</a>
<a name="ln7610">/// type.</a>
<a name="ln7611">///</a>
<a name="ln7612">/// @param[in]  tv  Object to translate.</a>
<a name="ln7613">/// @param[in]  dollar_lnum  True when &quot;$&quot; is last line.</a>
<a name="ln7614">/// @param[out]  ret_fnum  Set to fnum for marks.</a>
<a name="ln7615">///</a>
<a name="ln7616">/// @return Pointer to position or NULL in case of error (e.g. invalid type).</a>
<a name="ln7617">pos_T *var2fpos(const typval_T *const tv, const bool dollar_lnum,</a>
<a name="ln7618">                int *const ret_fnum)</a>
<a name="ln7619">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7620">{</a>
<a name="ln7621">  static pos_T pos;</a>
<a name="ln7622">  pos_T               *pp;</a>
<a name="ln7623"> </a>
<a name="ln7624">  // Argument can be [lnum, col, coladd].</a>
<a name="ln7625">  if (tv-&gt;v_type == VAR_LIST) {</a>
<a name="ln7626">    list_T          *l;</a>
<a name="ln7627">    int len;</a>
<a name="ln7628">    bool error = false;</a>
<a name="ln7629">    listitem_T *li;</a>
<a name="ln7630"> </a>
<a name="ln7631">    l = tv-&gt;vval.v_list;</a>
<a name="ln7632">    if (l == NULL) {</a>
<a name="ln7633">      return NULL;</a>
<a name="ln7634">    }</a>
<a name="ln7635"> </a>
<a name="ln7636">    // Get the line number.</a>
<a name="ln7637">    pos.lnum = tv_list_find_nr(l, 0L, &amp;error);</a>
<a name="ln7638">    if (error || pos.lnum &lt;= 0 || pos.lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln7639">      // Invalid line number.</a>
<a name="ln7640">      return NULL;</a>
<a name="ln7641">    }</a>
<a name="ln7642"> </a>
<a name="ln7643">    // Get the column number.</a>
<a name="ln7644">    pos.col = tv_list_find_nr(l, 1L, &amp;error);</a>
<a name="ln7645">    if (error) {</a>
<a name="ln7646">      return NULL;</a>
<a name="ln7647">    }</a>
<a name="ln7648">    len = (long)STRLEN(ml_get(pos.lnum));</a>
<a name="ln7649"> </a>
<a name="ln7650">    // We accept &quot;$&quot; for the column number: last column.</a>
<a name="ln7651">    li = tv_list_find(l, 1L);</a>
<a name="ln7652">    if (li != NULL &amp;&amp; TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_STRING</a>
<a name="ln7653">        &amp;&amp; TV_LIST_ITEM_TV(li)-&gt;vval.v_string != NULL</a>
<a name="ln7654">        &amp;&amp; STRCMP(TV_LIST_ITEM_TV(li)-&gt;vval.v_string, &quot;$&quot;) == 0) {</a>
<a name="ln7655">      pos.col = len + 1;</a>
<a name="ln7656">    }</a>
<a name="ln7657"> </a>
<a name="ln7658">    // Accept a position up to the NUL after the line.</a>
<a name="ln7659">    if (pos.col == 0 || (int)pos.col &gt; len + 1) {</a>
<a name="ln7660">      // Invalid column number.</a>
<a name="ln7661">      return NULL;</a>
<a name="ln7662">    }</a>
<a name="ln7663">    pos.col--;</a>
<a name="ln7664"> </a>
<a name="ln7665">    // Get the virtual offset.  Defaults to zero.</a>
<a name="ln7666">    pos.coladd = tv_list_find_nr(l, 2L, &amp;error);</a>
<a name="ln7667">    if (error) {</a>
<a name="ln7668">      pos.coladd = 0;</a>
<a name="ln7669">    }</a>
<a name="ln7670"> </a>
<a name="ln7671">    return &amp;pos;</a>
<a name="ln7672">  }</a>
<a name="ln7673"> </a>
<a name="ln7674">  const char *const name = tv_get_string_chk(tv);</a>
<a name="ln7675">  if (name == NULL) {</a>
<a name="ln7676">    return NULL;</a>
<a name="ln7677">  }</a>
<a name="ln7678">  if (name[0] == '.') {  // Cursor.</a>
<a name="ln7679">    return &amp;curwin-&gt;w_cursor;</a>
<a name="ln7680">  }</a>
<a name="ln7681">  if (name[0] == 'v' &amp;&amp; name[1] == NUL) {  // Visual start.</a>
<a name="ln7682">    if (VIsual_active) {</a>
<a name="ln7683">      return &amp;VIsual;</a>
<a name="ln7684">    }</a>
<a name="ln7685">    return &amp;curwin-&gt;w_cursor;</a>
<a name="ln7686">  }</a>
<a name="ln7687">  if (name[0] == '\'') {  // Mark.</a>
<a name="ln7688">    pp = getmark_buf_fnum(curbuf, (uint8_t)name[1], false, ret_fnum);</a>
<a name="ln7689">    if (pp == NULL || pp == (pos_T *)-1 || pp-&gt;lnum &lt;= 0) {</a>
<a name="ln7690">      return NULL;</a>
<a name="ln7691">    }</a>
<a name="ln7692">    return pp;</a>
<a name="ln7693">  }</a>
<a name="ln7694"> </a>
<a name="ln7695">  pos.coladd = 0;</a>
<a name="ln7696"> </a>
<a name="ln7697">  if (name[0] == 'w' &amp;&amp; dollar_lnum) {</a>
<a name="ln7698">    pos.col = 0;</a>
<a name="ln7699">    if (name[1] == '0') {               // &quot;w0&quot;: first visible line</a>
<a name="ln7700">      update_topline(curwin);</a>
<a name="ln7701">      // In silent Ex mode topline is zero, but that's not a valid line</a>
<a name="ln7702">      // number; use one instead.</a>
<a name="ln7703">      pos.lnum = curwin-&gt;w_topline &gt; 0 ? curwin-&gt;w_topline : 1;</a>
<a name="ln7704">      return &amp;pos;</a>
<a name="ln7705">    } else if (name[1] == '$') {      // &quot;w$&quot;: last visible line</a>
<a name="ln7706">      validate_botline(curwin);</a>
<a name="ln7707">      // In silent Ex mode botline is zero, return zero then.</a>
<a name="ln7708">      pos.lnum = curwin-&gt;w_botline &gt; 0 ? curwin-&gt;w_botline - 1 : 0;</a>
<a name="ln7709">      return &amp;pos;</a>
<a name="ln7710">    }</a>
<a name="ln7711">  } else if (name[0] == '$') {        // last column or line</a>
<a name="ln7712">    if (dollar_lnum) {</a>
<a name="ln7713">      pos.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln7714">      pos.col = 0;</a>
<a name="ln7715">    } else {</a>
<a name="ln7716">      pos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln7717">      pos.col = (colnr_T)STRLEN(get_cursor_line_ptr());</a>
<a name="ln7718">    }</a>
<a name="ln7719">    return &amp;pos;</a>
<a name="ln7720">  }</a>
<a name="ln7721">  return NULL;</a>
<a name="ln7722">}</a>
<a name="ln7723"> </a>
<a name="ln7724">/*</a>
<a name="ln7725"> * Convert list in &quot;arg&quot; into a position and optional file number.</a>
<a name="ln7726"> * When &quot;fnump&quot; is NULL there is no file number, only 3 items.</a>
<a name="ln7727"> * Note that the column is passed on as-is, the caller may want to decrement</a>
<a name="ln7728"> * it to use 1 for the first column.</a>
<a name="ln7729"> * Return FAIL when conversion is not possible, doesn't check the position for</a>
<a name="ln7730"> * validity.</a>
<a name="ln7731"> */</a>
<a name="ln7732">int list2fpos(typval_T *arg, pos_T *posp, int *fnump, colnr_T *curswantp)</a>
<a name="ln7733">{</a>
<a name="ln7734">  list_T *l;</a>
<a name="ln7735">  long i = 0;</a>
<a name="ln7736">  long n;</a>
<a name="ln7737"> </a>
<a name="ln7738">  // List must be: [fnum, lnum, col, coladd, curswant], where &quot;fnum&quot; is only</a>
<a name="ln7739">  // there when &quot;fnump&quot; isn't NULL; &quot;coladd&quot; and &quot;curswant&quot; are optional.</a>
<a name="ln7740">  if (arg-&gt;v_type != VAR_LIST</a>
<a name="ln7741">      || (l = arg-&gt;vval.v_list) == NULL</a>
<a name="ln7742">      || tv_list_len(l) &lt; (fnump == NULL ? 2 : 3)</a>
<a name="ln7743">      || tv_list_len(l) &gt; (fnump == NULL ? 4 : 5)) {</a>
<a name="ln7744">    return FAIL;</a>
<a name="ln7745">  }</a>
<a name="ln7746"> </a>
<a name="ln7747">  if (fnump != NULL) {</a>
<a name="ln7748">    n = tv_list_find_nr(l, i++, NULL);  // fnum</a>
<a name="ln7749">    if (n &lt; 0) {</a>
<a name="ln7750">      return FAIL;</a>
<a name="ln7751">    }</a>
<a name="ln7752">    if (n == 0) {</a>
<a name="ln7753">      n = curbuf-&gt;b_fnum;  // Current buffer.</a>
<a name="ln7754">    }</a>
<a name="ln7755">    *fnump = n;</a>
<a name="ln7756">  }</a>
<a name="ln7757"> </a>
<a name="ln7758">  n = tv_list_find_nr(l, i++, NULL);  // lnum</a>
<a name="ln7759">  if (n &lt; 0) {</a>
<a name="ln7760">    return FAIL;</a>
<a name="ln7761">  }</a>
<a name="ln7762">  posp-&gt;lnum = n;</a>
<a name="ln7763"> </a>
<a name="ln7764">  n = tv_list_find_nr(l, i++, NULL);  // col</a>
<a name="ln7765">  if (n &lt; 0) {</a>
<a name="ln7766">    return FAIL;</a>
<a name="ln7767">  }</a>
<a name="ln7768">  posp-&gt;col = n;</a>
<a name="ln7769"> </a>
<a name="ln7770">  n = tv_list_find_nr(l, i, NULL);  // off</a>
<a name="ln7771">  if (n &lt; 0) {</a>
<a name="ln7772">    posp-&gt;coladd = 0;</a>
<a name="ln7773">  } else {</a>
<a name="ln7774">    posp-&gt;coladd = n;</a>
<a name="ln7775">  }</a>
<a name="ln7776"> </a>
<a name="ln7777">  if (curswantp != NULL) {</a>
<a name="ln7778">    *curswantp = tv_list_find_nr(l, i + 1, NULL);  // curswant</a>
<a name="ln7779">  }</a>
<a name="ln7780"> </a>
<a name="ln7781">  return OK;</a>
<a name="ln7782">}</a>
<a name="ln7783"> </a>
<a name="ln7784">/*</a>
<a name="ln7785"> * Get the length of an environment variable name.</a>
<a name="ln7786"> * Advance &quot;arg&quot; to the first character after the name.</a>
<a name="ln7787"> * Return 0 for error.</a>
<a name="ln7788"> */</a>
<a name="ln7789">static int get_env_len(const char_u **arg)</a>
<a name="ln7790">{</a>
<a name="ln7791">  int len;</a>
<a name="ln7792"> </a>
<a name="ln7793">  const char_u *p;</a>
<a name="ln7794">  for (p = *arg; vim_isIDc(*p); p++) {</a>
<a name="ln7795">  }</a>
<a name="ln7796">  if (p == *arg) {  // No name found.</a>
<a name="ln7797">    return 0;</a>
<a name="ln7798">  }</a>
<a name="ln7799"> </a>
<a name="ln7800">  len = (int)(p - *arg);</a>
<a name="ln7801">  *arg = p;</a>
<a name="ln7802">  return len;</a>
<a name="ln7803">}</a>
<a name="ln7804"> </a>
<a name="ln7805">// Get the length of the name of a function or internal variable.</a>
<a name="ln7806">// &quot;arg&quot; is advanced to the first non-white character after the name.</a>
<a name="ln7807">// Return 0 if something is wrong.</a>
<a name="ln7808">int get_id_len(const char **const arg)</a>
<a name="ln7809">{</a>
<a name="ln7810">  int len;</a>
<a name="ln7811"> </a>
<a name="ln7812">  // Find the end of the name.</a>
<a name="ln7813">  const char *p;</a>
<a name="ln7814">  for (p = *arg; eval_isnamec(*p); p++) {</a>
<a name="ln7815">    if (*p == ':') {</a>
<a name="ln7816">      // &quot;s:&quot; is start of &quot;s:var&quot;, but &quot;n:&quot; is not and can be used in</a>
<a name="ln7817">      // slice &quot;[n:]&quot;. Also &quot;xx:&quot; is not a namespace.</a>
<a name="ln7818">      len = (int)(p - *arg);</a>
<a name="ln7819">      if (len &gt; 1</a>
<a name="ln7820">          || (len == 1 &amp;&amp; vim_strchr(namespace_char, **arg) == NULL)) {</a>
<a name="ln7821">        break;</a>
<a name="ln7822">      }</a>
<a name="ln7823">    }</a>
<a name="ln7824">  }</a>
<a name="ln7825">  if (p == *arg) {  // no name found</a>
<a name="ln7826">    return 0;</a>
<a name="ln7827">  }</a>
<a name="ln7828"> </a>
<a name="ln7829">  len = (int)(p - *arg);</a>
<a name="ln7830">  *arg = (const char *)skipwhite((const char_u *)p);</a>
<a name="ln7831"> </a>
<a name="ln7832">  return len;</a>
<a name="ln7833">}</a>
<a name="ln7834"> </a>
<a name="ln7835">/*</a>
<a name="ln7836"> * Get the length of the name of a variable or function.</a>
<a name="ln7837"> * Only the name is recognized, does not handle &quot;.key&quot; or &quot;[idx]&quot;.</a>
<a name="ln7838"> * &quot;arg&quot; is advanced to the first non-white character after the name.</a>
<a name="ln7839"> * Return -1 if curly braces expansion failed.</a>
<a name="ln7840"> * Return 0 if something else is wrong.</a>
<a name="ln7841"> * If the name contains 'magic' {}'s, expand them and return the</a>
<a name="ln7842"> * expanded name in an allocated string via 'alias' - caller must free.</a>
<a name="ln7843"> */</a>
<a name="ln7844">int get_name_len(const char **const arg,</a>
<a name="ln7845">                 char **alias,</a>
<a name="ln7846">                 bool evaluate,</a>
<a name="ln7847">                 bool verbose)</a>
<a name="ln7848">{</a>
<a name="ln7849">  int len;</a>
<a name="ln7850"> </a>
<a name="ln7851">  *alias = NULL;    // default to no alias</a>
<a name="ln7852"> </a>
<a name="ln7853">  if ((*arg)[0] == (char)K_SPECIAL &amp;&amp; (*arg)[1] == (char)KS_EXTRA</a>
<a name="ln7854">      &amp;&amp; (*arg)[2] == (char)KE_SNR) {</a>
<a name="ln7855">    // Hard coded &lt;SNR&gt;, already translated.</a>
<a name="ln7856">    *arg += 3;</a>
<a name="ln7857">    return get_id_len(arg) + 3;</a>
<a name="ln7858">  }</a>
<a name="ln7859">  len = eval_fname_script(*arg);</a>
<a name="ln7860">  if (len &gt; 0) {</a>
<a name="ln7861">    // literal &quot;&lt;SID&gt;&quot;, &quot;s:&quot; or &quot;&lt;SNR&gt;&quot;</a>
<a name="ln7862">    *arg += len;</a>
<a name="ln7863">  }</a>
<a name="ln7864"> </a>
<a name="ln7865">  // Find the end of the name; check for {} construction.</a>
<a name="ln7866">  char_u      *expr_start;</a>
<a name="ln7867">  char_u      *expr_end;</a>
<a name="ln7868">  const char *p = (const char *)find_name_end((char_u *)(*arg),</a>
<a name="ln7869">                                              (const char_u **)&amp;expr_start,</a>
<a name="ln7870">                                              (const char_u **)&amp;expr_end,</a>
<a name="ln7871">                                              len &gt; 0 ? 0 : FNE_CHECK_START);</a>
<a name="ln7872">  if (expr_start != NULL) {</a>
<a name="ln7873">    if (!evaluate) {</a>
<a name="ln7874">      len += (int)(p - *arg);</a>
<a name="ln7875">      *arg = (const char *)skipwhite((const char_u *)p);</a>
<a name="ln7876">      return len;</a>
<a name="ln7877">    }</a>
<a name="ln7878"> </a>
<a name="ln7879">    /*</a>
<a name="ln7880">     * Include any &lt;SID&gt; etc in the expanded string:</a>
<a name="ln7881">     * Thus the -len here.</a>
<a name="ln7882">     */</a>
<a name="ln7883">    char_u *temp_string = make_expanded_name((char_u *)(*arg) - len, expr_start,</a>
<a name="ln7884">                                             expr_end, (char_u *)p);</a>
<a name="ln7885">    if (temp_string == NULL) {</a>
<a name="ln7886">      return -1;</a>
<a name="ln7887">    }</a>
<a name="ln7888">    *alias = (char *)temp_string;</a>
<a name="ln7889">    *arg = (const char *)skipwhite((const char_u *)p);</a>
<a name="ln7890">    return (int)STRLEN(temp_string);</a>
<a name="ln7891">  }</a>
<a name="ln7892"> </a>
<a name="ln7893">  len += get_id_len(arg);</a>
<a name="ln7894">  // Only give an error when there is something, otherwise it will be</a>
<a name="ln7895">  // reported at a higher level.</a>
<a name="ln7896">  if (len == 0 &amp;&amp; verbose &amp;&amp; **arg != NUL) {</a>
<a name="ln7897">    EMSG2(_(e_invexpr2), *arg);</a>
<a name="ln7898">  }</a>
<a name="ln7899"> </a>
<a name="ln7900">  return len;</a>
<a name="ln7901">}</a>
<a name="ln7902"> </a>
<a name="ln7903">// Find the end of a variable or function name, taking care of magic braces.</a>
<a name="ln7904">// If &quot;expr_start&quot; is not NULL then &quot;expr_start&quot; and &quot;expr_end&quot; are set to the</a>
<a name="ln7905">// start and end of the first magic braces item.</a>
<a name="ln7906">// &quot;flags&quot; can have FNE_INCL_BR and FNE_CHECK_START.</a>
<a name="ln7907">// Return a pointer to just after the name.  Equal to &quot;arg&quot; if there is no</a>
<a name="ln7908">// valid name.</a>
<a name="ln7909">const char_u *find_name_end(const char_u *arg, const char_u **expr_start,</a>
<a name="ln7910">                            const char_u **expr_end, int flags)</a>
<a name="ln7911">{</a>
<a name="ln7912">  int mb_nest = 0;</a>
<a name="ln7913">  int br_nest = 0;</a>
<a name="ln7914">  int len;</a>
<a name="ln7915"> </a>
<a name="ln7916">  if (expr_start != NULL) {</a>
<a name="ln7917">    *expr_start = NULL;</a>
<a name="ln7918">    *expr_end = NULL;</a>
<a name="ln7919">  }</a>
<a name="ln7920"> </a>
<a name="ln7921">  // Quick check for valid starting character.</a>
<a name="ln7922">  if ((flags &amp; FNE_CHECK_START) &amp;&amp; !eval_isnamec1(*arg) &amp;&amp; *arg != '{') {</a>
<a name="ln7923">    return arg;</a>
<a name="ln7924">  }</a>
<a name="ln7925"> </a>
<a name="ln7926">  const char_u *p;</a>
<a name="ln7927">  for (p = arg; *p != NUL</a>
<a name="ln7928">       &amp;&amp; (eval_isnamec(*p)</a>
<a name="ln7929">           || *p == '{'</a>
<a name="ln7930">           || ((flags &amp; FNE_INCL_BR) &amp;&amp; (*p == '[' || *p == '.'))</a>
<a name="ln7931">           || mb_nest != 0</a>
<a name="ln7932">           || br_nest != 0); MB_PTR_ADV(p)) {</a>
<a name="ln7933">    if (*p == '\'') {</a>
<a name="ln7934">      // skip over 'string' to avoid counting [ and ] inside it.</a>
<a name="ln7935">      for (p = p + 1; *p != NUL &amp;&amp; *p != '\''; MB_PTR_ADV(p)) {</a>
<a name="ln7936">      }</a>
<a name="ln7937">      if (*p == NUL) {</a>
<a name="ln7938">        break;</a>
<a name="ln7939">      }</a>
<a name="ln7940">    } else if (*p == '&quot;') {</a>
<a name="ln7941">      // skip over &quot;str\&quot;ing&quot; to avoid counting [ and ] inside it.</a>
<a name="ln7942">      for (p = p + 1; *p != NUL &amp;&amp; *p != '&quot;'; MB_PTR_ADV(p)) {</a>
<a name="ln7943">        if (*p == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln7944">          ++p;</a>
<a name="ln7945">        }</a>
<a name="ln7946">      }</a>
<a name="ln7947">      if (*p == NUL) {</a>
<a name="ln7948">        break;</a>
<a name="ln7949">      }</a>
<a name="ln7950">    } else if (br_nest == 0 &amp;&amp; mb_nest == 0 &amp;&amp; *p == ':') {</a>
<a name="ln7951">      // &quot;s:&quot; is start of &quot;s:var&quot;, but &quot;n:&quot; is not and can be used in</a>
<a name="ln7952">      // slice &quot;[n:]&quot;.  Also &quot;xx:&quot; is not a namespace. But {ns}: is. */</a>
<a name="ln7953">      len = (int)(p - arg);</a>
<a name="ln7954">      if ((len &gt; 1 &amp;&amp; p[-1] != '}')</a>
<a name="ln7955">          || (len == 1 &amp;&amp; vim_strchr(namespace_char, *arg) == NULL)) {</a>
<a name="ln7956">        break;</a>
<a name="ln7957">      }</a>
<a name="ln7958">    }</a>
<a name="ln7959"> </a>
<a name="ln7960">    if (mb_nest == 0) {</a>
<a name="ln7961">      if (*p == '[') {</a>
<a name="ln7962">        ++br_nest;</a>
<a name="ln7963">      } else if (*p == ']') {</a>
<a name="ln7964">        --br_nest;</a>
<a name="ln7965">      }</a>
<a name="ln7966">    }</a>
<a name="ln7967"> </a>
<a name="ln7968">    if (br_nest == 0) {</a>
<a name="ln7969">      if (*p == '{') {</a>
<a name="ln7970">        mb_nest++;</a>
<a name="ln7971">        if (expr_start != NULL &amp;&amp; *expr_start == NULL) {</a>
<a name="ln7972">          *expr_start = p;</a>
<a name="ln7973">        }</a>
<a name="ln7974">      } else if (*p == '}') {</a>
<a name="ln7975">        mb_nest--;</a>
<a name="ln7976">        if (expr_start != NULL &amp;&amp; mb_nest == 0 &amp;&amp; *expr_end == NULL) {</a>
<a name="ln7977">          *expr_end = p;</a>
<a name="ln7978">        }</a>
<a name="ln7979">      }</a>
<a name="ln7980">    }</a>
<a name="ln7981">  }</a>
<a name="ln7982"> </a>
<a name="ln7983">  return p;</a>
<a name="ln7984">}</a>
<a name="ln7985"> </a>
<a name="ln7986">/*</a>
<a name="ln7987"> * Expands out the 'magic' {}'s in a variable/function name.</a>
<a name="ln7988"> * Note that this can call itself recursively, to deal with</a>
<a name="ln7989"> * constructs like foo{bar}{baz}{bam}</a>
<a name="ln7990"> * The four pointer arguments point to &quot;foo{expre}ss{ion}bar&quot;</a>
<a name="ln7991"> *			&quot;in_start&quot;      ^</a>
<a name="ln7992"> *			&quot;expr_start&quot;	   ^</a>
<a name="ln7993"> *			&quot;expr_end&quot;		 ^</a>
<a name="ln7994"> *			&quot;in_end&quot;			    ^</a>
<a name="ln7995"> *</a>
<a name="ln7996"> * Returns a new allocated string, which the caller must free.</a>
<a name="ln7997"> * Returns NULL for failure.</a>
<a name="ln7998"> */</a>
<a name="ln7999">static char_u *make_expanded_name(const char_u *in_start, char_u *expr_start,</a>
<a name="ln8000">                                  char_u *expr_end, char_u *in_end)</a>
<a name="ln8001">{</a>
<a name="ln8002">  char_u c1;</a>
<a name="ln8003">  char_u      *retval = NULL;</a>
<a name="ln8004">  char_u      *temp_result;</a>
<a name="ln8005">  char_u      *nextcmd = NULL;</a>
<a name="ln8006"> </a>
<a name="ln8007">  if (expr_end == NULL || in_end == NULL)</a>
<a name="ln8008">    return NULL;</a>
<a name="ln8009">  *expr_start = NUL;</a>
<a name="ln8010">  *expr_end = NUL;</a>
<a name="ln8011">  c1 = *in_end;</a>
<a name="ln8012">  *in_end = NUL;</a>
<a name="ln8013"> </a>
<a name="ln8014">  temp_result = eval_to_string(expr_start + 1, &amp;nextcmd, FALSE);</a>
<a name="ln8015">  if (temp_result != NULL &amp;&amp; nextcmd == NULL) {</a>
<a name="ln8016">    retval = xmalloc(STRLEN(temp_result) + (expr_start - in_start)</a>
<a name="ln8017">                     + (in_end - expr_end) + 1);</a>
<a name="ln8018">    STRCPY(retval, in_start);</a>
<a name="ln8019">    STRCAT(retval, temp_result);</a>
<a name="ln8020">    STRCAT(retval, expr_end + 1);</a>
<a name="ln8021">  }</a>
<a name="ln8022">  xfree(temp_result);</a>
<a name="ln8023"> </a>
<a name="ln8024">  *in_end = c1;                 // put char back for error messages</a>
<a name="ln8025">  *expr_start = '{';</a>
<a name="ln8026">  *expr_end = '}';</a>
<a name="ln8027"> </a>
<a name="ln8028">  if (retval != NULL) {</a>
<a name="ln8029">    temp_result = (char_u *)find_name_end(retval,</a>
<a name="ln8030">                                          (const char_u **)&amp;expr_start,</a>
<a name="ln8031">                                          (const char_u **)&amp;expr_end, 0);</a>
<a name="ln8032">    if (expr_start != NULL) {</a>
<a name="ln8033">      // Further expansion!</a>
<a name="ln8034">      temp_result = make_expanded_name(retval, expr_start,</a>
<a name="ln8035">          expr_end, temp_result);</a>
<a name="ln8036">      xfree(retval);</a>
<a name="ln8037">      retval = temp_result;</a>
<a name="ln8038">    }</a>
<a name="ln8039">  }</a>
<a name="ln8040"> </a>
<a name="ln8041">  return retval;</a>
<a name="ln8042">}</a>
<a name="ln8043"> </a>
<a name="ln8044">/*</a>
<a name="ln8045"> * Return TRUE if character &quot;c&quot; can be used in a variable or function name.</a>
<a name="ln8046"> * Does not include '{' or '}' for magic braces.</a>
<a name="ln8047"> */</a>
<a name="ln8048">int eval_isnamec(int c)</a>
<a name="ln8049">{</a>
<a name="ln8050">  return ASCII_ISALNUM(c) || c == '_' || c == ':' || c == AUTOLOAD_CHAR;</a>
<a name="ln8051">}</a>
<a name="ln8052"> </a>
<a name="ln8053">/*</a>
<a name="ln8054"> * Return TRUE if character &quot;c&quot; can be used as the first character in a</a>
<a name="ln8055"> * variable or function name (excluding '{' and '}').</a>
<a name="ln8056"> */</a>
<a name="ln8057">int eval_isnamec1(int c)</a>
<a name="ln8058">{</a>
<a name="ln8059">  return ASCII_ISALPHA(c) || c == '_';</a>
<a name="ln8060">}</a>
<a name="ln8061"> </a>
<a name="ln8062">/*</a>
<a name="ln8063"> * Get number v: variable value.</a>
<a name="ln8064"> */</a>
<a name="ln8065">varnumber_T get_vim_var_nr(int idx) FUNC_ATTR_PURE</a>
<a name="ln8066">{</a>
<a name="ln8067">  return vimvars[idx].vv_nr;</a>
<a name="ln8068">}</a>
<a name="ln8069"> </a>
<a name="ln8070">// Get string v: variable value.  Uses a static buffer, can only be used once.</a>
<a name="ln8071">// If the String variable has never been set, return an empty string.</a>
<a name="ln8072">// Never returns NULL;</a>
<a name="ln8073">char_u *get_vim_var_str(int idx) FUNC_ATTR_PURE FUNC_ATTR_NONNULL_RET</a>
<a name="ln8074">{</a>
<a name="ln8075">  return (char_u *)tv_get_string(&amp;vimvars[idx].vv_tv);</a>
<a name="ln8076">}</a>
<a name="ln8077"> </a>
<a name="ln8078">/*</a>
<a name="ln8079"> * Get List v: variable value.  Caller must take care of reference count when</a>
<a name="ln8080"> * needed.</a>
<a name="ln8081"> */</a>
<a name="ln8082">list_T *get_vim_var_list(int idx) FUNC_ATTR_PURE</a>
<a name="ln8083">{</a>
<a name="ln8084">  return vimvars[idx].vv_list;</a>
<a name="ln8085">}</a>
<a name="ln8086"> </a>
<a name="ln8087">/// Get Dictionary v: variable value.  Caller must take care of reference count</a>
<a name="ln8088">/// when needed.</a>
<a name="ln8089">dict_T *get_vim_var_dict(int idx) FUNC_ATTR_PURE</a>
<a name="ln8090">{</a>
<a name="ln8091">  return vimvars[idx].vv_dict;</a>
<a name="ln8092">}</a>
<a name="ln8093"> </a>
<a name="ln8094">/*</a>
<a name="ln8095"> * Set v:char to character &quot;c&quot;.</a>
<a name="ln8096"> */</a>
<a name="ln8097">void set_vim_var_char(int c)</a>
<a name="ln8098">{</a>
<a name="ln8099">  char buf[MB_MAXBYTES + 1];</a>
<a name="ln8100"> </a>
<a name="ln8101">  buf[utf_char2bytes(c, (char_u *)buf)] = NUL;</a>
<a name="ln8102">  set_vim_var_string(VV_CHAR, buf, -1);</a>
<a name="ln8103">}</a>
<a name="ln8104"> </a>
<a name="ln8105">/*</a>
<a name="ln8106"> * Set v:count to &quot;count&quot; and v:count1 to &quot;count1&quot;.</a>
<a name="ln8107"> * When &quot;set_prevcount&quot; is TRUE first set v:prevcount from v:count.</a>
<a name="ln8108"> */</a>
<a name="ln8109">void set_vcount(long count, long count1, int set_prevcount)</a>
<a name="ln8110">{</a>
<a name="ln8111">  if (set_prevcount)</a>
<a name="ln8112">    vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;</a>
<a name="ln8113">  vimvars[VV_COUNT].vv_nr = count;</a>
<a name="ln8114">  vimvars[VV_COUNT1].vv_nr = count1;</a>
<a name="ln8115">}</a>
<a name="ln8116"> </a>
<a name="ln8117">/// Set number v: variable to the given value</a>
<a name="ln8118">///</a>
<a name="ln8119">/// @param[in]  idx  Index of variable to set.</a>
<a name="ln8120">/// @param[in]  val  Value to set to.</a>
<a name="ln8121">void set_vim_var_nr(const VimVarIndex idx, const varnumber_T val)</a>
<a name="ln8122">{</a>
<a name="ln8123">  tv_clear(&amp;vimvars[idx].vv_tv);</a>
<a name="ln8124">  vimvars[idx].vv_type = VAR_NUMBER;</a>
<a name="ln8125">  vimvars[idx].vv_nr = val;</a>
<a name="ln8126">}</a>
<a name="ln8127"> </a>
<a name="ln8128">/// Set boolean v: {true, false} to the given value</a>
<a name="ln8129">///</a>
<a name="ln8130">/// @param[in]  idx  Index of variable to set.</a>
<a name="ln8131">/// @param[in]  val  Value to set to.</a>
<a name="ln8132">void set_vim_var_bool(const VimVarIndex idx, const BoolVarValue val)</a>
<a name="ln8133">{</a>
<a name="ln8134">  tv_clear(&amp;vimvars[idx].vv_tv);</a>
<a name="ln8135">  vimvars[idx].vv_type = VAR_BOOL;</a>
<a name="ln8136">  vimvars[idx].vv_bool = val;</a>
<a name="ln8137">}</a>
<a name="ln8138"> </a>
<a name="ln8139">/// Set special v: variable to the given value</a>
<a name="ln8140">///</a>
<a name="ln8141">/// @param[in]  idx  Index of variable to set.</a>
<a name="ln8142">/// @param[in]  val  Value to set to.</a>
<a name="ln8143">void set_vim_var_special(const VimVarIndex idx, const SpecialVarValue val)</a>
<a name="ln8144">{</a>
<a name="ln8145">  tv_clear(&amp;vimvars[idx].vv_tv);</a>
<a name="ln8146">  vimvars[idx].vv_type = VAR_SPECIAL;</a>
<a name="ln8147">  vimvars[idx].vv_special = val;</a>
<a name="ln8148">}</a>
<a name="ln8149"> </a>
<a name="ln8150">/// Set string v: variable to the given string</a>
<a name="ln8151">///</a>
<a name="ln8152">/// @param[in]  idx  Index of variable to set.</a>
<a name="ln8153">/// @param[in]  val  Value to set to. Will be copied.</a>
<a name="ln8154">/// @param[in]  len  Legth of that value or -1 in which case strlen() will be</a>
<a name="ln8155">///                  used.</a>
<a name="ln8156">void set_vim_var_string(const VimVarIndex idx, const char *const val,</a>
<a name="ln8157">                        const ptrdiff_t len)</a>
<a name="ln8158">{</a>
<a name="ln8159">  tv_clear(&amp;vimvars[idx].vv_di.di_tv);</a>
<a name="ln8160">  vimvars[idx].vv_type = VAR_STRING;</a>
<a name="ln8161">  if (val == NULL) {</a>
<a name="ln8162">    vimvars[idx].vv_str = NULL;</a>
<a name="ln8163">  } else if (len == -1) {</a>
<a name="ln8164">    vimvars[idx].vv_str = (char_u *) xstrdup(val);</a>
<a name="ln8165">  } else {</a>
<a name="ln8166">    vimvars[idx].vv_str = (char_u *) xstrndup(val, (size_t) len);</a>
<a name="ln8167">  }</a>
<a name="ln8168">}</a>
<a name="ln8169"> </a>
<a name="ln8170">/// Set list v: variable to the given list</a>
<a name="ln8171">///</a>
<a name="ln8172">/// @param[in]  idx  Index of variable to set.</a>
<a name="ln8173">/// @param[in,out]  val  Value to set to. Reference count will be incremented.</a>
<a name="ln8174">void set_vim_var_list(const VimVarIndex idx, list_T *const val)</a>
<a name="ln8175">{</a>
<a name="ln8176">  tv_clear(&amp;vimvars[idx].vv_di.di_tv);</a>
<a name="ln8177">  vimvars[idx].vv_type = VAR_LIST;</a>
<a name="ln8178">  vimvars[idx].vv_list = val;</a>
<a name="ln8179">  if (val != NULL) {</a>
<a name="ln8180">    tv_list_ref(val);</a>
<a name="ln8181">  }</a>
<a name="ln8182">}</a>
<a name="ln8183"> </a>
<a name="ln8184">/// Set Dictionary v: variable to the given dictionary</a>
<a name="ln8185">///</a>
<a name="ln8186">/// @param[in]  idx  Index of variable to set.</a>
<a name="ln8187">/// @param[in,out]  val  Value to set to. Reference count will be incremented.</a>
<a name="ln8188">///                      Also keys of the dictionary will be made read-only.</a>
<a name="ln8189">void set_vim_var_dict(const VimVarIndex idx, dict_T *const val)</a>
<a name="ln8190">{</a>
<a name="ln8191">  tv_clear(&amp;vimvars[idx].vv_di.di_tv);</a>
<a name="ln8192">  vimvars[idx].vv_type = VAR_DICT;</a>
<a name="ln8193">  vimvars[idx].vv_dict = val;</a>
<a name="ln8194"> </a>
<a name="ln8195">  if (val != NULL) {</a>
<a name="ln8196">    val-&gt;dv_refcount++;</a>
<a name="ln8197">    // Set readonly</a>
<a name="ln8198">    tv_dict_set_keys_readonly(val);</a>
<a name="ln8199">  }</a>
<a name="ln8200">}</a>
<a name="ln8201"> </a>
<a name="ln8202">/// Set the v:argv list.</a>
<a name="ln8203">void set_argv_var(char **argv, int argc)</a>
<a name="ln8204">{</a>
<a name="ln8205">  list_T *l = tv_list_alloc(argc);</a>
<a name="ln8206">  int i;</a>
<a name="ln8207"> </a>
<a name="ln8208">  tv_list_set_lock(l, VAR_FIXED);</a>
<a name="ln8209">  for (i = 0; i &lt; argc; i++) {</a>
<a name="ln8210">    tv_list_append_string(l, (const char *const)argv[i], -1);</a>
<a name="ln8211">    TV_LIST_ITEM_TV(tv_list_last(l))-&gt;v_lock = VAR_FIXED;</a>
<a name="ln8212">  }</a>
<a name="ln8213">  set_vim_var_list(VV_ARGV, l);</a>
<a name="ln8214">}</a>
<a name="ln8215"> </a>
<a name="ln8216">/*</a>
<a name="ln8217"> * Set v:register if needed.</a>
<a name="ln8218"> */</a>
<a name="ln8219">void set_reg_var(int c)</a>
<a name="ln8220">{</a>
<a name="ln8221">  char regname;</a>
<a name="ln8222"> </a>
<a name="ln8223">  if (c == 0 || c == ' ') {</a>
<a name="ln8224">    regname = '&quot;';</a>
<a name="ln8225">  } else {</a>
<a name="ln8226">    regname = c;</a>
<a name="ln8227">  }</a>
<a name="ln8228">  // Avoid free/alloc when the value is already right.</a>
<a name="ln8229">  if (vimvars[VV_REG].vv_str == NULL || vimvars[VV_REG].vv_str[0] != c) {</a>
<a name="ln8230">    set_vim_var_string(VV_REG, &amp;regname, 1);</a>
<a name="ln8231">  }</a>
<a name="ln8232">}</a>
<a name="ln8233"> </a>
<a name="ln8234">/*</a>
<a name="ln8235"> * Get or set v:exception.  If &quot;oldval&quot; == NULL, return the current value.</a>
<a name="ln8236"> * Otherwise, restore the value to &quot;oldval&quot; and return NULL.</a>
<a name="ln8237"> * Must always be called in pairs to save and restore v:exception!  Does not</a>
<a name="ln8238"> * take care of memory allocations.</a>
<a name="ln8239"> */</a>
<a name="ln8240">char_u *v_exception(char_u *oldval)</a>
<a name="ln8241">{</a>
<a name="ln8242">  if (oldval == NULL)</a>
<a name="ln8243">    return vimvars[VV_EXCEPTION].vv_str;</a>
<a name="ln8244"> </a>
<a name="ln8245">  vimvars[VV_EXCEPTION].vv_str = oldval;</a>
<a name="ln8246">  return NULL;</a>
<a name="ln8247">}</a>
<a name="ln8248"> </a>
<a name="ln8249">/*</a>
<a name="ln8250"> * Get or set v:throwpoint.  If &quot;oldval&quot; == NULL, return the current value.</a>
<a name="ln8251"> * Otherwise, restore the value to &quot;oldval&quot; and return NULL.</a>
<a name="ln8252"> * Must always be called in pairs to save and restore v:throwpoint!  Does not</a>
<a name="ln8253"> * take care of memory allocations.</a>
<a name="ln8254"> */</a>
<a name="ln8255">char_u *v_throwpoint(char_u *oldval)</a>
<a name="ln8256">{</a>
<a name="ln8257">  if (oldval == NULL)</a>
<a name="ln8258">    return vimvars[VV_THROWPOINT].vv_str;</a>
<a name="ln8259"> </a>
<a name="ln8260">  vimvars[VV_THROWPOINT].vv_str = oldval;</a>
<a name="ln8261">  return NULL;</a>
<a name="ln8262">}</a>
<a name="ln8263"> </a>
<a name="ln8264">/*</a>
<a name="ln8265"> * Set v:cmdarg.</a>
<a name="ln8266"> * If &quot;eap&quot; != NULL, use &quot;eap&quot; to generate the value and return the old value.</a>
<a name="ln8267"> * If &quot;oldarg&quot; != NULL, restore the value to &quot;oldarg&quot; and return NULL.</a>
<a name="ln8268"> * Must always be called in pairs!</a>
<a name="ln8269"> */</a>
<a name="ln8270">char_u *set_cmdarg(exarg_T *eap, char_u *oldarg)</a>
<a name="ln8271">{</a>
<a name="ln8272">  char_u *oldval = vimvars[VV_CMDARG].vv_str;</a>
<a name="ln8273">  if (eap == NULL) {</a>
<a name="ln8274">    xfree(oldval);</a>
<a name="ln8275">    vimvars[VV_CMDARG].vv_str = oldarg;</a>
<a name="ln8276">    return NULL;</a>
<a name="ln8277">  }</a>
<a name="ln8278"> </a>
<a name="ln8279">  size_t len = 0;</a>
<a name="ln8280">  if (eap-&gt;force_bin == FORCE_BIN)</a>
<a name="ln8281">    len = 6;</a>
<a name="ln8282">  else if (eap-&gt;force_bin == FORCE_NOBIN)</a>
<a name="ln8283">    len = 8;</a>
<a name="ln8284"> </a>
<a name="ln8285">  if (eap-&gt;read_edit)</a>
<a name="ln8286">    len += 7;</a>
<a name="ln8287"> </a>
<a name="ln8288">  if (eap-&gt;force_ff != 0) {</a>
<a name="ln8289">    len += 10;  // &quot; ++ff=unix&quot;</a>
<a name="ln8290">  }</a>
<a name="ln8291">  if (eap-&gt;force_enc != 0) {</a>
<a name="ln8292">    len += STRLEN(eap-&gt;cmd + eap-&gt;force_enc) + 7;</a>
<a name="ln8293">  }</a>
<a name="ln8294">  if (eap-&gt;bad_char != 0) {</a>
<a name="ln8295">    len += 7 + 4;  // &quot; ++bad=&quot; + &quot;keep&quot; or &quot;drop&quot;</a>
<a name="ln8296">  }</a>
<a name="ln8297"> </a>
<a name="ln8298">  const size_t newval_len = len + 1;</a>
<a name="ln8299">  char_u *newval = xmalloc(newval_len);</a>
<a name="ln8300"> </a>
<a name="ln8301">  if (eap-&gt;force_bin == FORCE_BIN)</a>
<a name="ln8302">    sprintf((char *)newval, &quot; ++bin&quot;);</a>
<a name="ln8303">  else if (eap-&gt;force_bin == FORCE_NOBIN)</a>
<a name="ln8304">    sprintf((char *)newval, &quot; ++nobin&quot;);</a>
<a name="ln8305">  else</a>
<a name="ln8306">    *newval = NUL;</a>
<a name="ln8307"> </a>
<a name="ln8308">  if (eap-&gt;read_edit)</a>
<a name="ln8309">    STRCAT(newval, &quot; ++edit&quot;);</a>
<a name="ln8310"> </a>
<a name="ln8311">  if (eap-&gt;force_ff != 0) {</a>
<a name="ln8312">    snprintf((char *)newval + STRLEN(newval), newval_len, &quot; ++ff=%s&quot;,</a>
<a name="ln8313">             eap-&gt;force_ff == 'u' ? &quot;unix&quot; :</a>
<a name="ln8314">             eap-&gt;force_ff == 'd' ? &quot;dos&quot; : &quot;mac&quot;);</a>
<a name="ln8315">  }</a>
<a name="ln8316">  if (eap-&gt;force_enc != 0) {</a>
<a name="ln8317">    snprintf((char *)newval + STRLEN(newval), newval_len, &quot; ++enc=%s&quot;,</a>
<a name="ln8318">             eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln8319">  }</a>
<a name="ln8320">  if (eap-&gt;bad_char == BAD_KEEP) {</a>
<a name="ln8321">    STRCPY(newval + STRLEN(newval), &quot; ++bad=keep&quot;);</a>
<a name="ln8322">  } else if (eap-&gt;bad_char == BAD_DROP) {</a>
<a name="ln8323">    STRCPY(newval + STRLEN(newval), &quot; ++bad=drop&quot;);</a>
<a name="ln8324">  } else if (eap-&gt;bad_char != 0) {</a>
<a name="ln8325">    snprintf((char *)newval + STRLEN(newval), newval_len, &quot; ++bad=%c&quot;,</a>
<a name="ln8326">             eap-&gt;bad_char);</a>
<a name="ln8327">  }</a>
<a name="ln8328">  vimvars[VV_CMDARG].vv_str = newval;</a>
<a name="ln8329">  return oldval;</a>
<a name="ln8330">}</a>
<a name="ln8331"> </a>
<a name="ln8332">// Get the value of internal variable &quot;name&quot;.</a>
<a name="ln8333">// Return OK or FAIL.  If OK is returned &quot;rettv&quot; must be cleared.</a>
<a name="ln8334">int get_var_tv(</a>
<a name="ln8335">    const char *name,</a>
<a name="ln8336">    int len,           // length of &quot;name&quot;</a>
<a name="ln8337">    typval_T *rettv,   // NULL when only checking existence</a>
<a name="ln8338">    dictitem_T **dip,  // non-NULL when typval's dict item is needed</a>
<a name="ln8339">    int verbose,       // may give error message</a>
<a name="ln8340">    int no_autoload    // do not use script autoloading</a>
<a name="ln8341">)</a>
<a name="ln8342">{</a>
<a name="ln8343">  int ret = OK;</a>
<a name="ln8344">  typval_T    *tv = NULL;</a>
<a name="ln8345">  dictitem_T  *v;</a>
<a name="ln8346"> </a>
<a name="ln8347">  v = find_var(name, (size_t)len, NULL, no_autoload);</a>
<a name="ln8348">  if (v != NULL) {</a>
<a name="ln8349">    tv = &amp;v-&gt;di_tv;</a>
<a name="ln8350">    if (dip != NULL) {</a>
<a name="ln8351">      *dip = v;</a>
<a name="ln8352">    }</a>
<a name="ln8353">  }</a>
<a name="ln8354"> </a>
<a name="ln8355">  if (tv == NULL) {</a>
<a name="ln8356">    if (rettv != NULL &amp;&amp; verbose) {</a>
<a name="ln8357">      emsgf(_(&quot;E121: Undefined variable: %.*s&quot;), len, name);</a>
<a name="ln8358">    }</a>
<a name="ln8359">    ret = FAIL;</a>
<a name="ln8360">  } else if (rettv != NULL) {</a>
<a name="ln8361">    tv_copy(tv, rettv);</a>
<a name="ln8362">  }</a>
<a name="ln8363"> </a>
<a name="ln8364">  return ret;</a>
<a name="ln8365">}</a>
<a name="ln8366"> </a>
<a name="ln8367">/// Check if variable &quot;name[len]&quot; is a local variable or an argument.</a>
<a name="ln8368">/// If so, &quot;*eval_lavars_used&quot; is set to true.</a>
<a name="ln8369">static void check_vars(const char *name, size_t len)</a>
<a name="ln8370">{</a>
<a name="ln8371">  if (eval_lavars_used == NULL) {</a>
<a name="ln8372">    return;</a>
<a name="ln8373">  }</a>
<a name="ln8374"> </a>
<a name="ln8375">  const char *varname;</a>
<a name="ln8376">  hashtab_T *ht = find_var_ht(name, len, &amp;varname);</a>
<a name="ln8377"> </a>
<a name="ln8378">  if (ht == get_funccal_local_ht() || ht == get_funccal_args_ht()) {</a>
<a name="ln8379">    if (find_var(name, len, NULL, true) != NULL) {</a>
<a name="ln8380">      *eval_lavars_used = true;</a>
<a name="ln8381">    }</a>
<a name="ln8382">  }</a>
<a name="ln8383">}</a>
<a name="ln8384"> </a>
<a name="ln8385">/// check if special v:lua value for calling lua functions</a>
<a name="ln8386">bool is_luafunc(partial_T *partial)</a>
<a name="ln8387">{</a>
<a name="ln8388">  return partial == vvlua_partial;</a>
<a name="ln8389">}</a>
<a name="ln8390"> </a>
<a name="ln8391">/// check if special v:lua value for calling lua functions</a>
<a name="ln8392">static bool tv_is_luafunc(typval_T *tv)</a>
<a name="ln8393">{</a>
<a name="ln8394">  return tv-&gt;v_type == VAR_PARTIAL &amp;&amp; is_luafunc(tv-&gt;vval.v_partial);</a>
<a name="ln8395">}</a>
<a name="ln8396"> </a>
<a name="ln8397">/// check the function name after &quot;v:lua.&quot;</a>
<a name="ln8398">int check_luafunc_name(const char *str, bool paren)</a>
<a name="ln8399">{</a>
<a name="ln8400">  const char *p = str;</a>
<a name="ln8401">  while (ASCII_ISALNUM(*p) || *p == '_' || *p == '.' || *p == '\'') {</a>
<a name="ln8402">    p++;</a>
<a name="ln8403">  }</a>
<a name="ln8404">  if (*p != (paren ? '(' : NUL)) {</a>
<a name="ln8405">    return 0;</a>
<a name="ln8406">  } else {</a>
<a name="ln8407">    return (int)(p-str);</a>
<a name="ln8408">  }</a>
<a name="ln8409">}</a>
<a name="ln8410"> </a>
<a name="ln8411">/// Handle expr[expr], expr[expr:expr] subscript and .name lookup.</a>
<a name="ln8412">/// Also handle function call with Funcref variable: func(expr)</a>
<a name="ln8413">/// Can all be combined: dict.func(expr)[idx]['func'](expr)</a>
<a name="ln8414">int</a>
<a name="ln8415">handle_subscript(</a>
<a name="ln8416">    const char **const arg,</a>
<a name="ln8417">    typval_T *rettv,</a>
<a name="ln8418">    int evaluate,                   // do more than finding the end</a>
<a name="ln8419">    int verbose                    // give error messages</a>
<a name="ln8420">)</a>
<a name="ln8421">{</a>
<a name="ln8422">  int ret = OK;</a>
<a name="ln8423">  dict_T      *selfdict = NULL;</a>
<a name="ln8424">  const char_u *s;</a>
<a name="ln8425">  int len;</a>
<a name="ln8426">  typval_T functv;</a>
<a name="ln8427">  int slen = 0;</a>
<a name="ln8428">  bool lua = false;</a>
<a name="ln8429"> </a>
<a name="ln8430">  if (tv_is_luafunc(rettv)) {</a>
<a name="ln8431">    if (**arg != '.') {</a>
<a name="ln8432">      tv_clear(rettv);</a>
<a name="ln8433">      ret = FAIL;</a>
<a name="ln8434">    } else {</a>
<a name="ln8435">      (*arg)++;</a>
<a name="ln8436"> </a>
<a name="ln8437">      lua = true;</a>
<a name="ln8438">      s = (char_u *)(*arg);</a>
<a name="ln8439">      slen = check_luafunc_name(*arg, true);</a>
<a name="ln8440">      if (slen == 0) {</a>
<a name="ln8441">        tv_clear(rettv);</a>
<a name="ln8442">        ret = FAIL;</a>
<a name="ln8443">      }</a>
<a name="ln8444">      (*arg) += slen;</a>
<a name="ln8445">    }</a>
<a name="ln8446">  }</a>
<a name="ln8447"> </a>
<a name="ln8448"> </a>
<a name="ln8449">  while (ret == OK</a>
<a name="ln8450">         &amp;&amp; (**arg == '['</a>
<a name="ln8451">             || (**arg == '.' &amp;&amp; rettv-&gt;v_type == VAR_DICT)</a>
<a name="ln8452">             || (**arg == '(' &amp;&amp; (!evaluate || tv_is_func(*rettv))))</a>
<a name="ln8453">         &amp;&amp; !ascii_iswhite(*(*arg - 1))) {</a>
<a name="ln8454">    if (**arg == '(') {</a>
<a name="ln8455">      partial_T *pt = NULL;</a>
<a name="ln8456">      // need to copy the funcref so that we can clear rettv</a>
<a name="ln8457">      if (evaluate) {</a>
<a name="ln8458">        functv = *rettv;</a>
<a name="ln8459">        rettv-&gt;v_type = VAR_UNKNOWN;</a>
<a name="ln8460"> </a>
<a name="ln8461">        // Invoke the function.  Recursive!</a>
<a name="ln8462">        if (functv.v_type == VAR_PARTIAL) {</a>
<a name="ln8463">          pt = functv.vval.v_partial;</a>
<a name="ln8464">          if (!lua) {</a>
<a name="ln8465">            s = partial_name(pt);</a>
<a name="ln8466">          }</a>
<a name="ln8467">        } else {</a>
<a name="ln8468">          s = functv.vval.v_string;</a>
<a name="ln8469">        }</a>
<a name="ln8470">      } else {</a>
<a name="ln8471">        s = (char_u *)&quot;&quot;;</a>
<a name="ln8472">      }</a>
<a name="ln8473">      ret = get_func_tv(s, lua ? slen : -1, rettv, (char_u **)arg,</a>
<a name="ln8474">                        curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum,</a>
<a name="ln8475">                        &amp;len, evaluate, pt, selfdict);</a>
<a name="ln8476"> </a>
<a name="ln8477">      // Clear the funcref afterwards, so that deleting it while</a>
<a name="ln8478">      // evaluating the arguments is possible (see test55).</a>
<a name="ln8479">      if (evaluate) {</a>
<a name="ln8480">        tv_clear(&amp;functv);</a>
<a name="ln8481">      }</a>
<a name="ln8482"> </a>
<a name="ln8483">      /* Stop the expression evaluation when immediately aborting on</a>
<a name="ln8484">       * error, or when an interrupt occurred or an exception was thrown</a>
<a name="ln8485">       * but not caught. */</a>
<a name="ln8486">      if (aborting()) {</a>
<a name="ln8487">        if (ret == OK) {</a>
<a name="ln8488">          tv_clear(rettv);</a>
<a name="ln8489">        }</a>
<a name="ln8490">        ret = FAIL;</a>
<a name="ln8491">      }</a>
<a name="ln8492">      tv_dict_unref(selfdict);</a>
<a name="ln8493">      selfdict = NULL;</a>
<a name="ln8494">    } else {  // **arg == '[' || **arg == '.'</a>
<a name="ln8495">      tv_dict_unref(selfdict);</a>
<a name="ln8496">      if (rettv-&gt;v_type == VAR_DICT) {</a>
<a name="ln8497">        selfdict = rettv-&gt;vval.v_dict;</a>
<a name="ln8498">        if (selfdict != NULL)</a>
<a name="ln8499">          ++selfdict-&gt;dv_refcount;</a>
<a name="ln8500">      } else</a>
<a name="ln8501">        selfdict = NULL;</a>
<a name="ln8502">      if (eval_index((char_u **)arg, rettv, evaluate, verbose) == FAIL) {</a>
<a name="ln8503">        tv_clear(rettv);</a>
<a name="ln8504">        ret = FAIL;</a>
<a name="ln8505">      }</a>
<a name="ln8506">    }</a>
<a name="ln8507">  }</a>
<a name="ln8508"> </a>
<a name="ln8509">  // Turn &quot;dict.Func&quot; into a partial for &quot;Func&quot; bound to &quot;dict&quot;.</a>
<a name="ln8510">  if (selfdict != NULL &amp;&amp; tv_is_func(*rettv)) {</a>
<a name="ln8511">    set_selfdict(rettv, selfdict);</a>
<a name="ln8512">  }</a>
<a name="ln8513"> </a>
<a name="ln8514">  tv_dict_unref(selfdict);</a>
<a name="ln8515">  return ret;</a>
<a name="ln8516">}</a>
<a name="ln8517"> </a>
<a name="ln8518">void set_selfdict(typval_T *const rettv, dict_T *const selfdict)</a>
<a name="ln8519">{</a>
<a name="ln8520">  // Don't do this when &quot;dict.Func&quot; is already a partial that was bound</a>
<a name="ln8521">  // explicitly (pt_auto is false).</a>
<a name="ln8522">  if (rettv-&gt;v_type == VAR_PARTIAL &amp;&amp; !rettv-&gt;vval.v_partial-&gt;pt_auto</a>
<a name="ln8523">      &amp;&amp; rettv-&gt;vval.v_partial-&gt;pt_dict != NULL) {</a>
<a name="ln8524">    return;</a>
<a name="ln8525">  }</a>
<a name="ln8526">  make_partial(selfdict, rettv);</a>
<a name="ln8527">}</a>
<a name="ln8528"> </a>
<a name="ln8529">// Find variable &quot;name&quot; in the list of variables.</a>
<a name="ln8530">// Return a pointer to it if found, NULL if not found.</a>
<a name="ln8531">// Careful: &quot;a:0&quot; variables don't have a name.</a>
<a name="ln8532">// When &quot;htp&quot; is not NULL we are writing to the variable, set &quot;htp&quot; to the</a>
<a name="ln8533">// hashtab_T used.</a>
<a name="ln8534">dictitem_T *find_var(const char *const name, const size_t name_len,</a>
<a name="ln8535">                     hashtab_T **htp, int no_autoload)</a>
<a name="ln8536">{</a>
<a name="ln8537">  const char *varname;</a>
<a name="ln8538">  hashtab_T *const ht = find_var_ht(name, name_len, &amp;varname);</a>
<a name="ln8539">  if (htp != NULL) {</a>
<a name="ln8540">    *htp = ht;</a>
<a name="ln8541">  }</a>
<a name="ln8542">  if (ht == NULL) {</a>
<a name="ln8543">    return NULL;</a>
<a name="ln8544">  }</a>
<a name="ln8545">  dictitem_T *const ret = find_var_in_ht(ht, *name,</a>
<a name="ln8546">                                         varname,</a>
<a name="ln8547">                                         name_len - (size_t)(varname - name),</a>
<a name="ln8548">                                         no_autoload || htp != NULL);</a>
<a name="ln8549">  if (ret != NULL) {</a>
<a name="ln8550">    return ret;</a>
<a name="ln8551">  }</a>
<a name="ln8552"> </a>
<a name="ln8553">  // Search in parent scope for lambda</a>
<a name="ln8554">  return find_var_in_scoped_ht(name, name_len, no_autoload || htp != NULL);</a>
<a name="ln8555">}</a>
<a name="ln8556"> </a>
<a name="ln8557">/// Find variable in hashtab.</a>
<a name="ln8558">/// When &quot;varname&quot; is empty returns curwin/curtab/etc vars dictionary.</a>
<a name="ln8559">///</a>
<a name="ln8560">/// @param[in]  ht  Hashtab to find variable in.</a>
<a name="ln8561">/// @param[in]  htname  Hashtab name (first character).</a>
<a name="ln8562">/// @param[in]  varname  Variable name.</a>
<a name="ln8563">/// @param[in]  varname_len  Variable name length.</a>
<a name="ln8564">/// @param[in]  no_autoload  If true then autoload scripts will not be sourced</a>
<a name="ln8565">///                          if autoload variable was not found.</a>
<a name="ln8566">///</a>
<a name="ln8567">/// @return pointer to the dictionary item with the found variable or NULL if it</a>
<a name="ln8568">///         was not found.</a>
<a name="ln8569">dictitem_T *find_var_in_ht(hashtab_T *const ht,</a>
<a name="ln8570">                           int htname,</a>
<a name="ln8571">                           const char *const varname,</a>
<a name="ln8572">                           const size_t varname_len,</a>
<a name="ln8573">                           int no_autoload)</a>
<a name="ln8574">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln8575">{</a>
<a name="ln8576">  hashitem_T  *hi;</a>
<a name="ln8577"> </a>
<a name="ln8578">  if (varname_len == 0) {</a>
<a name="ln8579">    // Must be something like &quot;s:&quot;, otherwise &quot;ht&quot; would be NULL.</a>
<a name="ln8580">    switch (htname) {</a>
<a name="ln8581">      case 's': return (dictitem_T *)&amp;SCRIPT_SV(current_sctx.sc_sid)-&gt;sv_var;</a>
<a name="ln8582">      case 'g': return (dictitem_T *)&amp;globvars_var;</a>
<a name="ln8583">      case 'v': return (dictitem_T *)&amp;vimvars_var;</a>
<a name="ln8584">      case 'b': return (dictitem_T *)&amp;curbuf-&gt;b_bufvar;</a>
<a name="ln8585">      case 'w': return (dictitem_T *)&amp;curwin-&gt;w_winvar;</a>
<a name="ln8586">      case 't': return (dictitem_T *)&amp;curtab-&gt;tp_winvar;</a>
<a name="ln8587">      case 'l': return get_funccal_local_var();</a>
<a name="ln8588">      case 'a': return get_funccal_args_var();</a>
<a name="ln8589">    }</a>
<a name="ln8590">    return NULL;</a>
<a name="ln8591">  }</a>
<a name="ln8592"> </a>
<a name="ln8593">  hi = hash_find_len(ht, varname, varname_len);</a>
<a name="ln8594">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln8595">    // For global variables we may try auto-loading the script.  If it</a>
<a name="ln8596">    // worked find the variable again.  Don't auto-load a script if it was</a>
<a name="ln8597">    // loaded already, otherwise it would be loaded every time when</a>
<a name="ln8598">    // checking if a function name is a Funcref variable.</a>
<a name="ln8599">    if (ht == &amp;globvarht &amp;&amp; !no_autoload) {</a>
<a name="ln8600">      // Note: script_autoload() may make &quot;hi&quot; invalid. It must either</a>
<a name="ln8601">      // be obtained again or not used.</a>
<a name="ln8602">      if (!script_autoload(varname, varname_len, false) || aborting()) {</a>
<a name="ln8603">        return NULL;</a>
<a name="ln8604">      }</a>
<a name="ln8605">      hi = hash_find_len(ht, varname, varname_len);</a>
<a name="ln8606">    }</a>
<a name="ln8607">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln8608">      return NULL;</a>
<a name="ln8609">    }</a>
<a name="ln8610">  }</a>
<a name="ln8611">  return TV_DICT_HI2DI(hi);</a>
<a name="ln8612">}</a>
<a name="ln8613"> </a>
<a name="ln8614">/// Finds the dict (g:, l:, s:, …) and hashtable used for a variable.</a>
<a name="ln8615">///</a>
<a name="ln8616">/// @param[in]  name  Variable name, possibly with scope prefix.</a>
<a name="ln8617">/// @param[in]  name_len  Variable name length.</a>
<a name="ln8618">/// @param[out]  varname  Will be set to the start of the name without scope</a>
<a name="ln8619">///                       prefix.</a>
<a name="ln8620">/// @param[out]  d  Scope dictionary.</a>
<a name="ln8621">///</a>
<a name="ln8622">/// @return Scope hashtab, NULL if name is not valid.</a>
<a name="ln8623">static hashtab_T *find_var_ht_dict(const char *name, const size_t name_len,</a>
<a name="ln8624">                                   const char **varname, dict_T **d)</a>
<a name="ln8625">{</a>
<a name="ln8626">  hashitem_T *hi;</a>
<a name="ln8627">  funccall_T *funccal = get_funccal();</a>
<a name="ln8628">  *d = NULL;</a>
<a name="ln8629"> </a>
<a name="ln8630">  if (name_len == 0) {</a>
<a name="ln8631">    return NULL;</a>
<a name="ln8632">  }</a>
<a name="ln8633">  if (name_len == 1 || name[1] != ':') {</a>
<a name="ln8634">    // name has implicit scope</a>
<a name="ln8635">    if (name[0] == ':' || name[0] == AUTOLOAD_CHAR) {</a>
<a name="ln8636">      // The name must not start with a colon or #.</a>
<a name="ln8637">      return NULL;</a>
<a name="ln8638">    }</a>
<a name="ln8639">    *varname = name;</a>
<a name="ln8640"> </a>
<a name="ln8641">    // &quot;version&quot; is &quot;v:version&quot; in all scopes</a>
<a name="ln8642">    hi = hash_find_len(&amp;compat_hashtab, name, name_len);</a>
<a name="ln8643">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln8644">      return &amp;compat_hashtab;</a>
<a name="ln8645">    }</a>
<a name="ln8646"> </a>
<a name="ln8647">    if (funccal == NULL) {  // global variable</a>
<a name="ln8648">      *d = &amp;globvardict;</a>
<a name="ln8649">    } else {  // l: variable</a>
<a name="ln8650">      *d = &amp;funccal-&gt;l_vars;</a>
<a name="ln8651">    }</a>
<a name="ln8652">    goto end;</a>
<a name="ln8653">  }</a>
<a name="ln8654"> </a>
<a name="ln8655">  *varname = name + 2;</a>
<a name="ln8656">  if (*name == 'g') {  // global variable</a>
<a name="ln8657">    *d = &amp;globvardict;</a>
<a name="ln8658">  } else if (name_len &gt; 2</a>
<a name="ln8659">             &amp;&amp; (memchr(name + 2, ':', name_len - 2) != NULL</a>
<a name="ln8660">                 || memchr(name + 2, AUTOLOAD_CHAR, name_len - 2) != NULL)) {</a>
<a name="ln8661">    // There must be no ':' or '#' in the rest of the name if g: was not used</a>
<a name="ln8662">    return NULL;</a>
<a name="ln8663">  }</a>
<a name="ln8664"> </a>
<a name="ln8665">  if (*name == 'b') {  // buffer variable</a>
<a name="ln8666">    *d = curbuf-&gt;b_vars;</a>
<a name="ln8667">  } else if (*name == 'w') {  // window variable</a>
<a name="ln8668">    *d = curwin-&gt;w_vars;</a>
<a name="ln8669">  } else if (*name == 't') {  // tab page variable</a>
<a name="ln8670">    *d = curtab-&gt;tp_vars;</a>
<a name="ln8671">  } else if (*name == 'v') {  // v: variable</a>
<a name="ln8672">    *d = &amp;vimvardict;</a>
<a name="ln8673">  } else if (*name == 'a' &amp;&amp; funccal != NULL) {  // function argument</a>
<a name="ln8674">    *d = &amp;funccal-&gt;l_avars;</a>
<a name="ln8675">  } else if (*name == 'l' &amp;&amp; funccal != NULL) {  // local variable</a>
<a name="ln8676">    *d = &amp;funccal-&gt;l_vars;</a>
<a name="ln8677">  } else if (*name == 's'  // script variable</a>
<a name="ln8678">             &amp;&amp; current_sctx.sc_sid &gt; 0</a>
<a name="ln8679">             &amp;&amp; current_sctx.sc_sid &lt;= ga_scripts.ga_len) {</a>
<a name="ln8680">    *d = &amp;SCRIPT_SV(current_sctx.sc_sid)-&gt;sv_dict;</a>
<a name="ln8681">  }</a>
<a name="ln8682"> </a>
<a name="ln8683">end:</a>
<a name="ln8684">  return *d ? &amp;(*d)-&gt;dv_hashtab : NULL;</a>
<a name="ln8685">}</a>
<a name="ln8686"> </a>
<a name="ln8687">/// Find the hashtable used for a variable</a>
<a name="ln8688">///</a>
<a name="ln8689">/// @param[in]  name  Variable name, possibly with scope prefix.</a>
<a name="ln8690">/// @param[in]  name_len  Variable name length.</a>
<a name="ln8691">/// @param[out]  varname  Will be set to the start of the name without scope</a>
<a name="ln8692">///                       prefix.</a>
<a name="ln8693">///</a>
<a name="ln8694">/// @return Scope hashtab, NULL if name is not valid.</a>
<a name="ln8695">hashtab_T *find_var_ht(const char *name, const size_t name_len,</a>
<a name="ln8696">                       const char **varname)</a>
<a name="ln8697">{</a>
<a name="ln8698">  dict_T *d;</a>
<a name="ln8699">  return find_var_ht_dict(name, name_len, varname, &amp;d);</a>
<a name="ln8700">}</a>
<a name="ln8701"> </a>
<a name="ln8702">/*</a>
<a name="ln8703"> * Get the string value of a (global/local) variable.</a>
<a name="ln8704"> * Note: see tv_get_string() for how long the pointer remains valid.</a>
<a name="ln8705"> * Returns NULL when it doesn't exist.</a>
<a name="ln8706"> */</a>
<a name="ln8707">char_u *get_var_value(const char *const name)</a>
<a name="ln8708">{</a>
<a name="ln8709">  dictitem_T  *v;</a>
<a name="ln8710"> </a>
<a name="ln8711">  v = find_var(name, strlen(name), NULL, false);</a>
<a name="ln8712">  if (v == NULL) {</a>
<a name="ln8713">    return NULL;</a>
<a name="ln8714">  }</a>
<a name="ln8715">  return (char_u *)tv_get_string(&amp;v-&gt;di_tv);</a>
<a name="ln8716">}</a>
<a name="ln8717"> </a>
<a name="ln8718">/*</a>
<a name="ln8719"> * Allocate a new hashtab for a sourced script.  It will be used while</a>
<a name="ln8720"> * sourcing this script and when executing functions defined in the script.</a>
<a name="ln8721"> */</a>
<a name="ln8722">void new_script_vars(scid_T id)</a>
<a name="ln8723">{</a>
<a name="ln8724">  hashtab_T   *ht;</a>
<a name="ln8725">  scriptvar_T *sv;</a>
<a name="ln8726"> </a>
<a name="ln8727">  ga_grow(&amp;ga_scripts, (int)(id - ga_scripts.ga_len));</a>
<a name="ln8728">  {</a>
<a name="ln8729">    /* Re-allocating ga_data means that an ht_array pointing to</a>
<a name="ln8730">     * ht_smallarray becomes invalid.  We can recognize this: ht_mask is</a>
<a name="ln8731">     * at its init value.  Also reset &quot;v_dict&quot;, it's always the same. */</a>
<a name="ln8732">    for (int i = 1; i &lt;= ga_scripts.ga_len; ++i) {</a>
<a name="ln8733">      ht = &amp;SCRIPT_VARS(i);</a>
<a name="ln8734">      if (ht-&gt;ht_mask == HT_INIT_SIZE - 1)</a>
<a name="ln8735">        ht-&gt;ht_array = ht-&gt;ht_smallarray;</a>
<a name="ln8736">      sv = SCRIPT_SV(i);</a>
<a name="ln8737">      sv-&gt;sv_var.di_tv.vval.v_dict = &amp;sv-&gt;sv_dict;</a>
<a name="ln8738">    }</a>
<a name="ln8739"> </a>
<a name="ln8740">    while (ga_scripts.ga_len &lt; id) {</a>
<a name="ln8741">      sv = SCRIPT_SV(ga_scripts.ga_len + 1) = xcalloc(1, sizeof(scriptvar_T));</a>
<a name="ln8742">      init_var_dict(&amp;sv-&gt;sv_dict, &amp;sv-&gt;sv_var, VAR_SCOPE);</a>
<a name="ln8743">      ++ga_scripts.ga_len;</a>
<a name="ln8744">    }</a>
<a name="ln8745">  }</a>
<a name="ln8746">}</a>
<a name="ln8747"> </a>
<a name="ln8748">/*</a>
<a name="ln8749"> * Initialize dictionary &quot;dict&quot; as a scope and set variable &quot;dict_var&quot; to</a>
<a name="ln8750"> * point to it.</a>
<a name="ln8751"> */</a>
<a name="ln8752">void init_var_dict(dict_T *dict, ScopeDictDictItem *dict_var, int scope)</a>
<a name="ln8753">{</a>
<a name="ln8754">  hash_init(&amp;dict-&gt;dv_hashtab);</a>
<a name="ln8755">  dict-&gt;dv_lock = VAR_UNLOCKED;</a>
<a name="ln8756">  dict-&gt;dv_scope = scope;</a>
<a name="ln8757">  dict-&gt;dv_refcount = DO_NOT_FREE_CNT;</a>
<a name="ln8758">  dict-&gt;dv_copyID = 0;</a>
<a name="ln8759">  dict_var-&gt;di_tv.vval.v_dict = dict;</a>
<a name="ln8760">  dict_var-&gt;di_tv.v_type = VAR_DICT;</a>
<a name="ln8761">  dict_var-&gt;di_tv.v_lock = VAR_FIXED;</a>
<a name="ln8762">  dict_var-&gt;di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln8763">  dict_var-&gt;di_key[0] = NUL;</a>
<a name="ln8764">  QUEUE_INIT(&amp;dict-&gt;watchers);</a>
<a name="ln8765">}</a>
<a name="ln8766"> </a>
<a name="ln8767">/*</a>
<a name="ln8768"> * Unreference a dictionary initialized by init_var_dict().</a>
<a name="ln8769"> */</a>
<a name="ln8770">void unref_var_dict(dict_T *dict)</a>
<a name="ln8771">{</a>
<a name="ln8772">  /* Now the dict needs to be freed if no one else is using it, go back to</a>
<a name="ln8773">   * normal reference counting. */</a>
<a name="ln8774">  dict-&gt;dv_refcount -= DO_NOT_FREE_CNT - 1;</a>
<a name="ln8775">  tv_dict_unref(dict);</a>
<a name="ln8776">}</a>
<a name="ln8777"> </a>
<a name="ln8778">/*</a>
<a name="ln8779"> * Clean up a list of internal variables.</a>
<a name="ln8780"> * Frees all allocated variables and the value they contain.</a>
<a name="ln8781"> * Clears hashtab &quot;ht&quot;, does not free it.</a>
<a name="ln8782"> */</a>
<a name="ln8783">void vars_clear(hashtab_T *ht)</a>
<a name="ln8784">{</a>
<a name="ln8785">  vars_clear_ext(ht, TRUE);</a>
<a name="ln8786">}</a>
<a name="ln8787"> </a>
<a name="ln8788">/*</a>
<a name="ln8789"> * Like vars_clear(), but only free the value if &quot;free_val&quot; is TRUE.</a>
<a name="ln8790"> */</a>
<a name="ln8791">void vars_clear_ext(hashtab_T *ht, int free_val)</a>
<a name="ln8792">{</a>
<a name="ln8793">  int todo;</a>
<a name="ln8794">  hashitem_T  *hi;</a>
<a name="ln8795">  dictitem_T  *v;</a>
<a name="ln8796"> </a>
<a name="ln8797">  hash_lock(ht);</a>
<a name="ln8798">  todo = (int)ht-&gt;ht_used;</a>
<a name="ln8799">  for (hi = ht-&gt;ht_array; todo &gt; 0; ++hi) {</a>
<a name="ln8800">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln8801">      --todo;</a>
<a name="ln8802"> </a>
<a name="ln8803">      // Free the variable.  Don't remove it from the hashtab,</a>
<a name="ln8804">      // ht_array might change then.  hash_clear() takes care of it</a>
<a name="ln8805">      // later.</a>
<a name="ln8806">      v = TV_DICT_HI2DI(hi);</a>
<a name="ln8807">      if (free_val) {</a>
<a name="ln8808">        tv_clear(&amp;v-&gt;di_tv);</a>
<a name="ln8809">      }</a>
<a name="ln8810">      if (v-&gt;di_flags &amp; DI_FLAGS_ALLOC) {</a>
<a name="ln8811">        xfree(v);</a>
<a name="ln8812">      }</a>
<a name="ln8813">    }</a>
<a name="ln8814">  }</a>
<a name="ln8815">  hash_clear(ht);</a>
<a name="ln8816">  ht-&gt;ht_used = 0;</a>
<a name="ln8817">}</a>
<a name="ln8818"> </a>
<a name="ln8819">/*</a>
<a name="ln8820"> * Delete a variable from hashtab &quot;ht&quot; at item &quot;hi&quot;.</a>
<a name="ln8821"> * Clear the variable value and free the dictitem.</a>
<a name="ln8822"> */</a>
<a name="ln8823">static void delete_var(hashtab_T *ht, hashitem_T *hi)</a>
<a name="ln8824">{</a>
<a name="ln8825">  dictitem_T  *di = TV_DICT_HI2DI(hi);</a>
<a name="ln8826"> </a>
<a name="ln8827">  hash_remove(ht, hi);</a>
<a name="ln8828">  tv_clear(&amp;di-&gt;di_tv);</a>
<a name="ln8829">  xfree(di);</a>
<a name="ln8830">}</a>
<a name="ln8831"> </a>
<a name="ln8832">/*</a>
<a name="ln8833"> * List the value of one internal variable.</a>
<a name="ln8834"> */</a>
<a name="ln8835">static void list_one_var(dictitem_T *v, const char *prefix, int *first)</a>
<a name="ln8836">{</a>
<a name="ln8837">  char *const s = encode_tv2echo(&amp;v-&gt;di_tv, NULL);</a>
<a name="ln8838">  list_one_var_a(prefix, (const char *)v-&gt;di_key, STRLEN(v-&gt;di_key),</a>
<a name="ln8839">                 v-&gt;di_tv.v_type, (s == NULL ? &quot;&quot; : s), first);</a>
<a name="ln8840">  xfree(s);</a>
<a name="ln8841">}</a>
<a name="ln8842"> </a>
<a name="ln8843">/// @param[in]  name_len  Length of the name. May be -1, in this case strlen()</a>
<a name="ln8844">///                       will be used.</a>
<a name="ln8845">/// @param[in,out]  first  When true clear rest of screen and set to false.</a>
<a name="ln8846">static void list_one_var_a(const char *prefix, const char *name,</a>
<a name="ln8847">                           const ptrdiff_t name_len, const int type,</a>
<a name="ln8848">                           const char *string, int *first)</a>
<a name="ln8849">{</a>
<a name="ln8850">  // don't use msg() or msg_attr() to avoid overwriting &quot;v:statusmsg&quot;</a>
<a name="ln8851">  msg_start();</a>
<a name="ln8852">  msg_puts(prefix);</a>
<a name="ln8853">  if (name != NULL) {  // &quot;a:&quot; vars don't have a name stored</a>
<a name="ln8854">    msg_puts_attr_len(name, name_len, 0);</a>
<a name="ln8855">  }</a>
<a name="ln8856">  msg_putchar(' ');</a>
<a name="ln8857">  msg_advance(22);</a>
<a name="ln8858">  if (type == VAR_NUMBER) {</a>
<a name="ln8859">    msg_putchar('#');</a>
<a name="ln8860">  } else if (type == VAR_FUNC || type == VAR_PARTIAL) {</a>
<a name="ln8861">    msg_putchar('*');</a>
<a name="ln8862">  } else if (type == VAR_LIST) {</a>
<a name="ln8863">    msg_putchar('[');</a>
<a name="ln8864">    if (*string == '[')</a>
<a name="ln8865">      ++string;</a>
<a name="ln8866">  } else if (type == VAR_DICT) {</a>
<a name="ln8867">    msg_putchar('{');</a>
<a name="ln8868">    if (*string == '{')</a>
<a name="ln8869">      ++string;</a>
<a name="ln8870">  } else</a>
<a name="ln8871">    msg_putchar(' ');</a>
<a name="ln8872"> </a>
<a name="ln8873">  msg_outtrans((char_u *)string);</a>
<a name="ln8874"> </a>
<a name="ln8875">  if (type == VAR_FUNC || type == VAR_PARTIAL) {</a>
<a name="ln8876">    msg_puts(&quot;()&quot;);</a>
<a name="ln8877">  }</a>
<a name="ln8878">  if (*first) {</a>
<a name="ln8879">    msg_clr_eos();</a>
<a name="ln8880">    *first = FALSE;</a>
<a name="ln8881">  }</a>
<a name="ln8882">}</a>
<a name="ln8883"> </a>
<a name="ln8884">/// Set variable to the given value</a>
<a name="ln8885">///</a>
<a name="ln8886">/// If the variable already exists, the value is updated. Otherwise the variable</a>
<a name="ln8887">/// is created.</a>
<a name="ln8888">///</a>
<a name="ln8889">/// @param[in]  name  Variable name to set.</a>
<a name="ln8890">/// @param[in]  name_len  Length of the variable name.</a>
<a name="ln8891">/// @param  tv  Variable value.</a>
<a name="ln8892">/// @param[in]  copy  True if value in tv is to be copied.</a>
<a name="ln8893">void set_var(const char *name, const size_t name_len, typval_T *const tv,</a>
<a name="ln8894">             const bool copy)</a>
<a name="ln8895">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln8896">{</a>
<a name="ln8897">  set_var_const(name, name_len, tv, copy, false);</a>
<a name="ln8898">}</a>
<a name="ln8899"> </a>
<a name="ln8900">/// Set variable to the given value</a>
<a name="ln8901">///</a>
<a name="ln8902">/// If the variable already exists, the value is updated. Otherwise the variable</a>
<a name="ln8903">/// is created.</a>
<a name="ln8904">///</a>
<a name="ln8905">/// @param[in]  name  Variable name to set.</a>
<a name="ln8906">/// @param[in]  name_len  Length of the variable name.</a>
<a name="ln8907">/// @param  tv  Variable value.</a>
<a name="ln8908">/// @param[in]  copy  True if value in tv is to be copied.</a>
<a name="ln8909">/// @param[in]  is_const  True if value in tv is to be locked.</a>
<a name="ln8910">static void set_var_const(const char *name, const size_t name_len,</a>
<a name="ln8911">                          typval_T *const tv, const bool copy,</a>
<a name="ln8912">                          const bool is_const)</a>
<a name="ln8913">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln8914">{</a>
<a name="ln8915">  dictitem_T  *v;</a>
<a name="ln8916">  hashtab_T   *ht;</a>
<a name="ln8917">  dict_T *dict;</a>
<a name="ln8918"> </a>
<a name="ln8919">  const char *varname;</a>
<a name="ln8920">  ht = find_var_ht_dict(name, name_len, &amp;varname, &amp;dict);</a>
<a name="ln8921">  const bool watched = tv_dict_is_watched(dict);</a>
<a name="ln8922"> </a>
<a name="ln8923">  if (ht == NULL || *varname == NUL) {</a>
<a name="ln8924">    EMSG2(_(e_illvar), name);</a>
<a name="ln8925">    return;</a>
<a name="ln8926">  }</a>
<a name="ln8927">  v = find_var_in_ht(ht, 0, varname, name_len - (size_t)(varname - name), true);</a>
<a name="ln8928"> </a>
<a name="ln8929">  // Search in parent scope which is possible to reference from lambda</a>
<a name="ln8930">  if (v == NULL) {</a>
<a name="ln8931">    v = find_var_in_scoped_ht((const char *)name, name_len, true);</a>
<a name="ln8932">  }</a>
<a name="ln8933"> </a>
<a name="ln8934">  if (tv_is_func(*tv) &amp;&amp; !var_check_func_name(name, v == NULL)) {</a>
<a name="ln8935">    return;</a>
<a name="ln8936">  }</a>
<a name="ln8937"> </a>
<a name="ln8938">  typval_T oldtv = TV_INITIAL_VALUE;</a>
<a name="ln8939">  if (v != NULL) {</a>
<a name="ln8940">    if (is_const) {</a>
<a name="ln8941">      EMSG(_(e_cannot_mod));</a>
<a name="ln8942">      return;</a>
<a name="ln8943">    }</a>
<a name="ln8944"> </a>
<a name="ln8945">    // existing variable, need to clear the value</a>
<a name="ln8946">    if (var_check_ro(v-&gt;di_flags, name, name_len)</a>
<a name="ln8947">        || var_check_lock(v-&gt;di_tv.v_lock, name, name_len)) {</a>
<a name="ln8948">      return;</a>
<a name="ln8949">    }</a>
<a name="ln8950"> </a>
<a name="ln8951">    // Handle setting internal v: variables separately where needed to</a>
<a name="ln8952">    // prevent changing the type.</a>
<a name="ln8953">    if (ht == &amp;vimvarht) {</a>
<a name="ln8954">      if (v-&gt;di_tv.v_type == VAR_STRING) {</a>
<a name="ln8955">        XFREE_CLEAR(v-&gt;di_tv.vval.v_string);</a>
<a name="ln8956">        if (copy || tv-&gt;v_type != VAR_STRING) {</a>
<a name="ln8957">          const char *const val = tv_get_string(tv);</a>
<a name="ln8958"> </a>
<a name="ln8959">          // Careful: when assigning to v:errmsg and tv_get_string()</a>
<a name="ln8960">          // causes an error message the variable will alrady be set.</a>
<a name="ln8961">          if (v-&gt;di_tv.vval.v_string == NULL) {</a>
<a name="ln8962">            v-&gt;di_tv.vval.v_string = (char_u *)xstrdup(val);</a>
<a name="ln8963">          }</a>
<a name="ln8964">        } else {</a>
<a name="ln8965">          // Take over the string to avoid an extra alloc/free.</a>
<a name="ln8966">          v-&gt;di_tv.vval.v_string = tv-&gt;vval.v_string;</a>
<a name="ln8967">          tv-&gt;vval.v_string = NULL;</a>
<a name="ln8968">        }</a>
<a name="ln8969">        return;</a>
<a name="ln8970">      } else if (v-&gt;di_tv.v_type == VAR_NUMBER) {</a>
<a name="ln8971">        v-&gt;di_tv.vval.v_number = tv_get_number(tv);</a>
<a name="ln8972">        if (strcmp(varname, &quot;searchforward&quot;) == 0) {</a>
<a name="ln8973">          set_search_direction(v-&gt;di_tv.vval.v_number ? '/' : '?');</a>
<a name="ln8974">        } else if (strcmp(varname, &quot;hlsearch&quot;) == 0) {</a>
<a name="ln8975">          no_hlsearch = !v-&gt;di_tv.vval.v_number;</a>
<a name="ln8976">          redraw_all_later(SOME_VALID);</a>
<a name="ln8977">        }</a>
<a name="ln8978">        return;</a>
<a name="ln8979">      } else if (v-&gt;di_tv.v_type != tv-&gt;v_type) {</a>
<a name="ln8980">        EMSG2(_(&quot;E963: setting %s to value with wrong type&quot;), name);</a>
<a name="ln8981">        return;</a>
<a name="ln8982">      }</a>
<a name="ln8983">    }</a>
<a name="ln8984"> </a>
<a name="ln8985">    if (watched) {</a>
<a name="ln8986">      tv_copy(&amp;v-&gt;di_tv, &amp;oldtv);</a>
<a name="ln8987">    }</a>
<a name="ln8988">    tv_clear(&amp;v-&gt;di_tv);</a>
<a name="ln8989">  } else {  // Add a new variable.</a>
<a name="ln8990">    // Can't add &quot;v:&quot; or &quot;a:&quot; variable.</a>
<a name="ln8991">    if (ht == &amp;vimvarht || ht == get_funccal_args_ht()) {</a>
<a name="ln8992">      emsgf(_(e_illvar), name);</a>
<a name="ln8993">      return;</a>
<a name="ln8994">    }</a>
<a name="ln8995"> </a>
<a name="ln8996">    // Make sure the variable name is valid.</a>
<a name="ln8997">    if (!valid_varname(varname)) {</a>
<a name="ln8998">      return;</a>
<a name="ln8999">    }</a>
<a name="ln9000"> </a>
<a name="ln9001">    // Make sure dict is valid</a>
<a name="ln9002">    assert(dict != NULL);</a>
<a name="ln9003"> </a>
<a name="ln9004">    v = xmalloc(sizeof(dictitem_T) + strlen(varname));</a>
<a name="ln9005">    STRCPY(v-&gt;di_key, varname);</a>
<a name="ln9006">    if (tv_dict_add(dict, v) == FAIL) {</a>
<a name="ln9007">      xfree(v);</a>
<a name="ln9008">      return;</a>
<a name="ln9009">    }</a>
<a name="ln9010">    v-&gt;di_flags = DI_FLAGS_ALLOC;</a>
<a name="ln9011">    if (is_const) {</a>
<a name="ln9012">      v-&gt;di_flags |= DI_FLAGS_LOCK;</a>
<a name="ln9013">    }</a>
<a name="ln9014">  }</a>
<a name="ln9015"> </a>
<a name="ln9016">  if (copy || tv-&gt;v_type == VAR_NUMBER || tv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln9017">    tv_copy(tv, &amp;v-&gt;di_tv);</a>
<a name="ln9018">  } else {</a>
<a name="ln9019">    v-&gt;di_tv = *tv;</a>
<a name="ln9020">    v-&gt;di_tv.v_lock = VAR_UNLOCKED;</a>
<a name="ln9021">    tv_init(tv);</a>
<a name="ln9022">  }</a>
<a name="ln9023"> </a>
<a name="ln9024">  if (watched) {</a>
<a name="ln9025">    if (oldtv.v_type == VAR_UNKNOWN) {</a>
<a name="ln9026">      tv_dict_watcher_notify(dict, (char *)v-&gt;di_key, &amp;v-&gt;di_tv, NULL);</a>
<a name="ln9027">    } else {</a>
<a name="ln9028">      tv_dict_watcher_notify(dict, (char *)v-&gt;di_key, &amp;v-&gt;di_tv, &amp;oldtv);</a>
<a name="ln9029">      tv_clear(&amp;oldtv);</a>
<a name="ln9030">    }</a>
<a name="ln9031">  }</a>
<a name="ln9032"> </a>
<a name="ln9033">  if (is_const) {</a>
<a name="ln9034">    tv_item_lock(&amp;v-&gt;di_tv, 1, true);</a>
<a name="ln9035">  }</a>
<a name="ln9036">}</a>
<a name="ln9037"> </a>
<a name="ln9038">/// Check whether variable is read-only (DI_FLAGS_RO, DI_FLAGS_RO_SBX)</a>
<a name="ln9039">///</a>
<a name="ln9040">/// Also gives an error message.</a>
<a name="ln9041">///</a>
<a name="ln9042">/// @param[in]  flags  di_flags attribute value.</a>
<a name="ln9043">/// @param[in]  name  Variable name, for use in error message.</a>
<a name="ln9044">/// @param[in]  name_len  Variable name length. Use #TV_TRANSLATE to translate</a>
<a name="ln9045">///                       variable name and compute the length. Use #TV_CSTRING</a>
<a name="ln9046">///                       to compute the length with strlen() without</a>
<a name="ln9047">///                       translating.</a>
<a name="ln9048">///</a>
<a name="ln9049">///                       Both #TV_… values are used for optimization purposes:</a>
<a name="ln9050">///                       variable name with its length is needed only in case</a>
<a name="ln9051">///                       of error, when no error occurs computing them is</a>
<a name="ln9052">///                       a waste of CPU resources. This especially applies to</a>
<a name="ln9053">///                       gettext.</a>
<a name="ln9054">///</a>
<a name="ln9055">/// @return True if variable is read-only: either always or in sandbox when</a>
<a name="ln9056">///         sandbox is enabled, false otherwise.</a>
<a name="ln9057">bool var_check_ro(const int flags, const char *name,</a>
<a name="ln9058">                  size_t name_len)</a>
<a name="ln9059">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln9060">{</a>
<a name="ln9061">  const char *error_message = NULL;</a>
<a name="ln9062">  if (flags &amp; DI_FLAGS_RO) {</a>
<a name="ln9063">    error_message = _(e_readonlyvar);</a>
<a name="ln9064">  } else if ((flags &amp; DI_FLAGS_RO_SBX) &amp;&amp; sandbox) {</a>
<a name="ln9065">    error_message = N_(&quot;E794: Cannot set variable in the sandbox: \&quot;%.*s\&quot;&quot;);</a>
<a name="ln9066">  }</a>
<a name="ln9067"> </a>
<a name="ln9068">  if (error_message == NULL) {</a>
<a name="ln9069">    return false;</a>
<a name="ln9070">  }</a>
<a name="ln9071">  if (name_len == TV_TRANSLATE) {</a>
<a name="ln9072">    name = _(name);</a>
<a name="ln9073">    name_len = strlen(name);</a>
<a name="ln9074">  } else if (name_len == TV_CSTRING) {</a>
<a name="ln9075">    name_len = strlen(name);</a>
<a name="ln9076">  }</a>
<a name="ln9077"> </a>
<a name="ln9078">  emsgf(_(error_message), (int)name_len, name);</a>
<a name="ln9079"> </a>
<a name="ln9080">  return true;</a>
<a name="ln9081">}</a>
<a name="ln9082"> </a>
<a name="ln9083">/// Check whether variable is fixed (DI_FLAGS_FIX)</a>
<a name="ln9084">///</a>
<a name="ln9085">/// Also gives an error message.</a>
<a name="ln9086">///</a>
<a name="ln9087">/// @param[in]  flags  di_flags attribute value.</a>
<a name="ln9088">/// @param[in]  name  Variable name, for use in error message.</a>
<a name="ln9089">/// @param[in]  name_len  Variable name length. Use #TV_TRANSLATE to translate</a>
<a name="ln9090">///                       variable name and compute the length. Use #TV_CSTRING</a>
<a name="ln9091">///                       to compute the length with strlen() without</a>
<a name="ln9092">///                       translating.</a>
<a name="ln9093">///</a>
<a name="ln9094">///                       Both #TV_… values are used for optimization purposes:</a>
<a name="ln9095">///                       variable name with its length is needed only in case</a>
<a name="ln9096">///                       of error, when no error occurs computing them is</a>
<a name="ln9097">///                       a waste of CPU resources. This especially applies to</a>
<a name="ln9098">///                       gettext.</a>
<a name="ln9099">///</a>
<a name="ln9100">/// @return True if variable is fixed, false otherwise.</a>
<a name="ln9101">bool var_check_fixed(const int flags, const char *name,</a>
<a name="ln9102">                     size_t name_len)</a>
<a name="ln9103">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln9104">{</a>
<a name="ln9105">  if (flags &amp; DI_FLAGS_FIX) {</a>
<a name="ln9106">    if (name_len == TV_TRANSLATE) {</a>
<a name="ln9107">      name = _(name);</a>
<a name="ln9108">      name_len = strlen(name);</a>
<a name="ln9109">    } else if (name_len == TV_CSTRING) {</a>
<a name="ln9110">      name_len = strlen(name);</a>
<a name="ln9111">    }</a>
<a name="ln9112">    EMSG3(_(&quot;E795: Cannot delete variable %.*s&quot;), (int)name_len, name);</a>
<a name="ln9113">    return true;</a>
<a name="ln9114">  }</a>
<a name="ln9115">  return false;</a>
<a name="ln9116">}</a>
<a name="ln9117"> </a>
<a name="ln9118">// TODO(ZyX-I): move to eval/expressions</a>
<a name="ln9119"> </a>
<a name="ln9120">/// Check if name is a valid name to assign funcref to</a>
<a name="ln9121">///</a>
<a name="ln9122">/// @param[in]  name  Possible function/funcref name.</a>
<a name="ln9123">/// @param[in]  new_var  True if it is a name for a variable.</a>
<a name="ln9124">///</a>
<a name="ln9125">/// @return false in case of error, true in case of success. Also gives an</a>
<a name="ln9126">///         error message if appropriate.</a>
<a name="ln9127">bool var_check_func_name(const char *const name, const bool new_var)</a>
<a name="ln9128">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln9129">{</a>
<a name="ln9130">  // Allow for w: b: s: and t:.</a>
<a name="ln9131">  if (!(vim_strchr((char_u *)&quot;wbst&quot;, name[0]) != NULL &amp;&amp; name[1] == ':')</a>
<a name="ln9132">      &amp;&amp; !ASCII_ISUPPER((name[0] != NUL &amp;&amp; name[1] == ':') ? name[2]</a>
<a name="ln9133">                                                           : name[0])) {</a>
<a name="ln9134">    EMSG2(_(&quot;E704: Funcref variable name must start with a capital: %s&quot;), name);</a>
<a name="ln9135">    return false;</a>
<a name="ln9136">  }</a>
<a name="ln9137">  // Don't allow hiding a function.  When &quot;v&quot; is not NULL we might be</a>
<a name="ln9138">  // assigning another function to the same var, the type is checked</a>
<a name="ln9139">  // below.</a>
<a name="ln9140">  if (new_var &amp;&amp; function_exists((const char *)name, false)) {</a>
<a name="ln9141">    EMSG2(_(&quot;E705: Variable name conflicts with existing function: %s&quot;),</a>
<a name="ln9142">          name);</a>
<a name="ln9143">    return false;</a>
<a name="ln9144">  }</a>
<a name="ln9145">  return true;</a>
<a name="ln9146">}</a>
<a name="ln9147"> </a>
<a name="ln9148">// TODO(ZyX-I): move to eval/expressions</a>
<a name="ln9149"> </a>
<a name="ln9150">/// Check if a variable name is valid</a>
<a name="ln9151">///</a>
<a name="ln9152">/// @param[in]  varname  Variable name to check.</a>
<a name="ln9153">///</a>
<a name="ln9154">/// @return false when variable name is not valid, true when it is. Also gives</a>
<a name="ln9155">///         an error message if appropriate.</a>
<a name="ln9156">bool valid_varname(const char *varname)</a>
<a name="ln9157">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln9158">{</a>
<a name="ln9159">  for (const char *p = varname; *p != NUL; p++) {</a>
<a name="ln9160">    if (!eval_isnamec1((int)(uint8_t)(*p))</a>
<a name="ln9161">        &amp;&amp; (p == varname || !ascii_isdigit(*p))</a>
<a name="ln9162">        &amp;&amp; *p != AUTOLOAD_CHAR) {</a>
<a name="ln9163">      emsgf(_(e_illvar), varname);</a>
<a name="ln9164">      return false;</a>
<a name="ln9165">    }</a>
<a name="ln9166">  }</a>
<a name="ln9167">  return true;</a>
<a name="ln9168">}</a>
<a name="ln9169"> </a>
<a name="ln9170">/// Make a copy of an item</a>
<a name="ln9171">///</a>
<a name="ln9172">/// Lists and Dictionaries are also copied.</a>
<a name="ln9173">///</a>
<a name="ln9174">/// @param[in]  conv  If not NULL, convert all copied strings.</a>
<a name="ln9175">/// @param[in]  from  Value to copy.</a>
<a name="ln9176">/// @param[out]  to  Location where to copy to.</a>
<a name="ln9177">/// @param[in]  deep  If true, use copy the container and all of the contained</a>
<a name="ln9178">///                   containers (nested).</a>
<a name="ln9179">/// @param[in]  copyID  If non-zero then when container is referenced more then</a>
<a name="ln9180">///                     once then copy of it that was already done is used. E.g.</a>
<a name="ln9181">///                     when copying list `list = [list2, list2]` (`list[0] is</a>
<a name="ln9182">///                     list[1]`) var_item_copy with zero copyID will emit</a>
<a name="ln9183">///                     a copy with (`copy[0] isnot copy[1]`), with non-zero it</a>
<a name="ln9184">///                     will emit a copy with (`copy[0] is copy[1]`) like in the</a>
<a name="ln9185">///                     original list. Not used when deep is false.</a>
<a name="ln9186">int var_item_copy(const vimconv_T *const conv,</a>
<a name="ln9187">                  typval_T *const from,</a>
<a name="ln9188">                  typval_T *const to,</a>
<a name="ln9189">                  const bool deep,</a>
<a name="ln9190">                  const int copyID)</a>
<a name="ln9191">  FUNC_ATTR_NONNULL_ARG(2, 3)</a>
<a name="ln9192">{</a>
<a name="ln9193">  static int recurse = 0;</a>
<a name="ln9194">  int ret = OK;</a>
<a name="ln9195"> </a>
<a name="ln9196">  if (recurse &gt;= DICT_MAXNEST) {</a>
<a name="ln9197">    EMSG(_(&quot;E698: variable nested too deep for making a copy&quot;));</a>
<a name="ln9198">    return FAIL;</a>
<a name="ln9199">  }</a>
<a name="ln9200">  ++recurse;</a>
<a name="ln9201"> </a>
<a name="ln9202">  switch (from-&gt;v_type) {</a>
<a name="ln9203">  case VAR_NUMBER:</a>
<a name="ln9204">  case VAR_FLOAT:</a>
<a name="ln9205">  case VAR_FUNC:</a>
<a name="ln9206">  case VAR_PARTIAL:</a>
<a name="ln9207">  case VAR_BOOL:</a>
<a name="ln9208">  case VAR_SPECIAL:</a>
<a name="ln9209">    tv_copy(from, to);</a>
<a name="ln9210">    break;</a>
<a name="ln9211">  case VAR_STRING:</a>
<a name="ln9212">    if (conv == NULL || conv-&gt;vc_type == CONV_NONE</a>
<a name="ln9213">        || from-&gt;vval.v_string == NULL) {</a>
<a name="ln9214">      tv_copy(from, to);</a>
<a name="ln9215">    } else {</a>
<a name="ln9216">      to-&gt;v_type = VAR_STRING;</a>
<a name="ln9217">      to-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln9218">      if ((to-&gt;vval.v_string = string_convert((vimconv_T *)conv,</a>
<a name="ln9219">                                              from-&gt;vval.v_string,</a>
<a name="ln9220">                                              NULL))</a>
<a name="ln9221">          == NULL) {</a>
<a name="ln9222">        to-&gt;vval.v_string = (char_u *) xstrdup((char *) from-&gt;vval.v_string);</a>
<a name="ln9223">      }</a>
<a name="ln9224">    }</a>
<a name="ln9225">    break;</a>
<a name="ln9226">  case VAR_LIST:</a>
<a name="ln9227">    to-&gt;v_type = VAR_LIST;</a>
<a name="ln9228">    to-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln9229">    if (from-&gt;vval.v_list == NULL) {</a>
<a name="ln9230">      to-&gt;vval.v_list = NULL;</a>
<a name="ln9231">    } else if (copyID != 0 &amp;&amp; tv_list_copyid(from-&gt;vval.v_list) == copyID) {</a>
<a name="ln9232">      // Use the copy made earlier.</a>
<a name="ln9233">      to-&gt;vval.v_list = tv_list_latest_copy(from-&gt;vval.v_list);</a>
<a name="ln9234">      tv_list_ref(to-&gt;vval.v_list);</a>
<a name="ln9235">    } else {</a>
<a name="ln9236">      to-&gt;vval.v_list = tv_list_copy(conv, from-&gt;vval.v_list, deep, copyID);</a>
<a name="ln9237">    }</a>
<a name="ln9238">    if (to-&gt;vval.v_list == NULL &amp;&amp; from-&gt;vval.v_list != NULL) {</a>
<a name="ln9239">      ret = FAIL;</a>
<a name="ln9240">    }</a>
<a name="ln9241">    break;</a>
<a name="ln9242">  case VAR_DICT:</a>
<a name="ln9243">    to-&gt;v_type = VAR_DICT;</a>
<a name="ln9244">    to-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln9245">    if (from-&gt;vval.v_dict == NULL) {</a>
<a name="ln9246">      to-&gt;vval.v_dict = NULL;</a>
<a name="ln9247">    } else if (copyID != 0 &amp;&amp; from-&gt;vval.v_dict-&gt;dv_copyID == copyID) {</a>
<a name="ln9248">      // use the copy made earlier</a>
<a name="ln9249">      to-&gt;vval.v_dict = from-&gt;vval.v_dict-&gt;dv_copydict;</a>
<a name="ln9250">      ++to-&gt;vval.v_dict-&gt;dv_refcount;</a>
<a name="ln9251">    } else {</a>
<a name="ln9252">      to-&gt;vval.v_dict = tv_dict_copy(conv, from-&gt;vval.v_dict, deep, copyID);</a>
<a name="ln9253">    }</a>
<a name="ln9254">    if (to-&gt;vval.v_dict == NULL &amp;&amp; from-&gt;vval.v_dict != NULL) {</a>
<a name="ln9255">      ret = FAIL;</a>
<a name="ln9256">    }</a>
<a name="ln9257">    break;</a>
<a name="ln9258">  case VAR_UNKNOWN:</a>
<a name="ln9259">    internal_error(&quot;var_item_copy(UNKNOWN)&quot;);</a>
<a name="ln9260">    ret = FAIL;</a>
<a name="ln9261">  }</a>
<a name="ln9262">  --recurse;</a>
<a name="ln9263">  return ret;</a>
<a name="ln9264">}</a>
<a name="ln9265"> </a>
<a name="ln9266">/*</a>
<a name="ln9267"> * &quot;:echo expr1 ...&quot;	print each argument separated with a space, add a</a>
<a name="ln9268"> *			newline at the end.</a>
<a name="ln9269"> * &quot;:echon expr1 ...&quot;	print each argument plain.</a>
<a name="ln9270"> */</a>
<a name="ln9271">void ex_echo(exarg_T *eap)</a>
<a name="ln9272">{</a>
<a name="ln9273">  char_u      *arg = eap-&gt;arg;</a>
<a name="ln9274">  typval_T rettv;</a>
<a name="ln9275">  bool atstart = true;</a>
<a name="ln9276">  bool need_clear = true;</a>
<a name="ln9277">  const int did_emsg_before = did_emsg;</a>
<a name="ln9278"> </a>
<a name="ln9279">  if (eap-&gt;skip)</a>
<a name="ln9280">    ++emsg_skip;</a>
<a name="ln9281">  while (*arg != NUL &amp;&amp; *arg != '|' &amp;&amp; *arg != '\n' &amp;&amp; !got_int) {</a>
<a name="ln9282">    // If eval1() causes an error message the text from the command may</a>
<a name="ln9283">    // still need to be cleared. E.g., &quot;echo 22,44&quot;.</a>
<a name="ln9284">    need_clr_eos = true;</a>
<a name="ln9285"> </a>
<a name="ln9286">    {</a>
<a name="ln9287">      char_u *p = arg;</a>
<a name="ln9288">      if (eval1(&amp;arg, &amp;rettv, !eap-&gt;skip) == FAIL) {</a>
<a name="ln9289">        // Report the invalid expression unless the expression evaluation</a>
<a name="ln9290">        // has been cancelled due to an aborting error, an interrupt, or an</a>
<a name="ln9291">        // exception.</a>
<a name="ln9292">        if (!aborting() &amp;&amp; did_emsg == did_emsg_before) {</a>
<a name="ln9293">          EMSG2(_(e_invexpr2), p);</a>
<a name="ln9294">        }</a>
<a name="ln9295">        need_clr_eos = false;</a>
<a name="ln9296">        break;</a>
<a name="ln9297">      }</a>
<a name="ln9298">      need_clr_eos = false;</a>
<a name="ln9299">    }</a>
<a name="ln9300"> </a>
<a name="ln9301">    if (!eap-&gt;skip) {</a>
<a name="ln9302">      if (atstart) {</a>
<a name="ln9303">        atstart = false;</a>
<a name="ln9304">        /* Call msg_start() after eval1(), evaluating the expression</a>
<a name="ln9305">         * may cause a message to appear. */</a>
<a name="ln9306">        if (eap-&gt;cmdidx == CMD_echo) {</a>
<a name="ln9307">          /* Mark the saved text as finishing the line, so that what</a>
<a name="ln9308">           * follows is displayed on a new line when scrolling back</a>
<a name="ln9309">           * at the more prompt. */</a>
<a name="ln9310">          msg_sb_eol();</a>
<a name="ln9311">          msg_start();</a>
<a name="ln9312">        }</a>
<a name="ln9313">      } else if (eap-&gt;cmdidx == CMD_echo) {</a>
<a name="ln9314">        msg_puts_attr(&quot; &quot;, echo_attr);</a>
<a name="ln9315">      }</a>
<a name="ln9316">      char *tofree = encode_tv2echo(&amp;rettv, NULL);</a>
<a name="ln9317">      if (*tofree != NUL) {</a>
<a name="ln9318">        msg_ext_set_kind(&quot;echo&quot;);</a>
<a name="ln9319">        msg_multiline_attr(tofree, echo_attr, true, &amp;need_clear);</a>
<a name="ln9320">      }</a>
<a name="ln9321">      xfree(tofree);</a>
<a name="ln9322">    }</a>
<a name="ln9323">    tv_clear(&amp;rettv);</a>
<a name="ln9324">    arg = skipwhite(arg);</a>
<a name="ln9325">  }</a>
<a name="ln9326">  eap-&gt;nextcmd = check_nextcmd(arg);</a>
<a name="ln9327"> </a>
<a name="ln9328">  if (eap-&gt;skip) {</a>
<a name="ln9329">    emsg_skip--;</a>
<a name="ln9330">  } else {</a>
<a name="ln9331">    // remove text that may still be there from the command</a>
<a name="ln9332">    if (need_clear) {</a>
<a name="ln9333">      msg_clr_eos();</a>
<a name="ln9334">    }</a>
<a name="ln9335">    if (eap-&gt;cmdidx == CMD_echo) {</a>
<a name="ln9336">      msg_end();</a>
<a name="ln9337">    }</a>
<a name="ln9338">  }</a>
<a name="ln9339">}</a>
<a name="ln9340"> </a>
<a name="ln9341">/*</a>
<a name="ln9342"> * &quot;:echohl {name}&quot;.</a>
<a name="ln9343"> */</a>
<a name="ln9344">void ex_echohl(exarg_T *eap)</a>
<a name="ln9345">{</a>
<a name="ln9346">  echo_attr = syn_name2attr(eap-&gt;arg);</a>
<a name="ln9347">}</a>
<a name="ln9348"> </a>
<a name="ln9349">/*</a>
<a name="ln9350"> * &quot;:execute expr1 ...&quot;	execute the result of an expression.</a>
<a name="ln9351"> * &quot;:echomsg expr1 ...&quot;	Print a message</a>
<a name="ln9352"> * &quot;:echoerr expr1 ...&quot;	Print an error</a>
<a name="ln9353"> * Each gets spaces around each argument and a newline at the end for</a>
<a name="ln9354"> * echo commands</a>
<a name="ln9355"> */</a>
<a name="ln9356">void ex_execute(exarg_T *eap)</a>
<a name="ln9357">{</a>
<a name="ln9358">  char_u *arg = eap-&gt;arg;</a>
<a name="ln9359">  typval_T rettv;</a>
<a name="ln9360">  int ret = OK;</a>
<a name="ln9361">  garray_T ga;</a>
<a name="ln9362">  int save_did_emsg;</a>
<a name="ln9363"> </a>
<a name="ln9364">  ga_init(&amp;ga, 1, 80);</a>
<a name="ln9365"> </a>
<a name="ln9366">  if (eap-&gt;skip)</a>
<a name="ln9367">    ++emsg_skip;</a>
<a name="ln9368">  while (*arg != NUL &amp;&amp; *arg != '|' &amp;&amp; *arg != '\n') {</a>
<a name="ln9369">    ret = eval1_emsg(&amp;arg, &amp;rettv, !eap-&gt;skip);</a>
<a name="ln9370">    if (ret == FAIL) {</a>
<a name="ln9371">      break;</a>
<a name="ln9372">    }</a>
<a name="ln9373"> </a>
<a name="ln9374">    if (!eap-&gt;skip) {</a>
<a name="ln9375">      const char *const argstr = eap-&gt;cmdidx == CMD_execute</a>
<a name="ln9376">        ? tv_get_string(&amp;rettv)</a>
<a name="ln9377">        : rettv.v_type == VAR_STRING</a>
<a name="ln9378">        ? encode_tv2echo(&amp;rettv, NULL)</a>
<a name="ln9379">        : encode_tv2string(&amp;rettv, NULL);</a>
<a name="ln9380">      const size_t len = strlen(argstr);</a>
<a name="ln9381">      ga_grow(&amp;ga, len + 2);</a>
<a name="ln9382">      if (!GA_EMPTY(&amp;ga)) {</a>
<a name="ln9383">        ((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';</a>
<a name="ln9384">      }</a>
<a name="ln9385">      memcpy((char_u *)(ga.ga_data) + ga.ga_len, argstr, len + 1);</a>
<a name="ln9386">      if (eap-&gt;cmdidx != CMD_execute) {</a>
<a name="ln9387">        xfree((void *)argstr);</a>
<a name="ln9388">      }</a>
<a name="ln9389">      ga.ga_len += len;</a>
<a name="ln9390">    }</a>
<a name="ln9391"> </a>
<a name="ln9392">    tv_clear(&amp;rettv);</a>
<a name="ln9393">    arg = skipwhite(arg);</a>
<a name="ln9394">  }</a>
<a name="ln9395"> </a>
<a name="ln9396">  if (ret != FAIL &amp;&amp; ga.ga_data != NULL) {</a>
<a name="ln9397">    if (eap-&gt;cmdidx == CMD_echomsg || eap-&gt;cmdidx == CMD_echoerr) {</a>
<a name="ln9398">      // Mark the already saved text as finishing the line, so that what</a>
<a name="ln9399">      // follows is displayed on a new line when scrolling back at the</a>
<a name="ln9400">      // more prompt.</a>
<a name="ln9401">      msg_sb_eol();</a>
<a name="ln9402">    }</a>
<a name="ln9403"> </a>
<a name="ln9404">    if (eap-&gt;cmdidx == CMD_echomsg) {</a>
<a name="ln9405">      msg_ext_set_kind(&quot;echomsg&quot;);</a>
<a name="ln9406">      MSG_ATTR(ga.ga_data, echo_attr);</a>
<a name="ln9407">      ui_flush();</a>
<a name="ln9408">    } else if (eap-&gt;cmdidx == CMD_echoerr) {</a>
<a name="ln9409">      // We don't want to abort following commands, restore did_emsg.</a>
<a name="ln9410">      save_did_emsg = did_emsg;</a>
<a name="ln9411">      msg_ext_set_kind(&quot;echoerr&quot;);</a>
<a name="ln9412">      EMSG((char_u *)ga.ga_data);</a>
<a name="ln9413">      if (!force_abort)</a>
<a name="ln9414">        did_emsg = save_did_emsg;</a>
<a name="ln9415">    } else if (eap-&gt;cmdidx == CMD_execute)</a>
<a name="ln9416">      do_cmdline((char_u *)ga.ga_data,</a>
<a name="ln9417">          eap-&gt;getline, eap-&gt;cookie, DOCMD_NOWAIT|DOCMD_VERBOSE);</a>
<a name="ln9418">  }</a>
<a name="ln9419"> </a>
<a name="ln9420">  ga_clear(&amp;ga);</a>
<a name="ln9421"> </a>
<a name="ln9422">  if (eap-&gt;skip)</a>
<a name="ln9423">    --emsg_skip;</a>
<a name="ln9424"> </a>
<a name="ln9425">  eap-&gt;nextcmd = check_nextcmd(arg);</a>
<a name="ln9426">}</a>
<a name="ln9427"> </a>
<a name="ln9428">/*</a>
<a name="ln9429"> * Skip over the name of an option: &quot;&amp;option&quot;, &quot;&amp;g:option&quot; or &quot;&amp;l:option&quot;.</a>
<a name="ln9430"> * &quot;arg&quot; points to the &quot;&amp;&quot; or '+' when called, to &quot;option&quot; when returning.</a>
<a name="ln9431"> * Returns NULL when no option name found.  Otherwise pointer to the char</a>
<a name="ln9432"> * after the option name.</a>
<a name="ln9433"> */</a>
<a name="ln9434">static const char *find_option_end(const char **const arg, int *const opt_flags)</a>
<a name="ln9435">{</a>
<a name="ln9436">  const char *p = *arg;</a>
<a name="ln9437"> </a>
<a name="ln9438">  ++p;</a>
<a name="ln9439">  if (*p == 'g' &amp;&amp; p[1] == ':') {</a>
<a name="ln9440">    *opt_flags = OPT_GLOBAL;</a>
<a name="ln9441">    p += 2;</a>
<a name="ln9442">  } else if (*p == 'l' &amp;&amp; p[1] == ':') {</a>
<a name="ln9443">    *opt_flags = OPT_LOCAL;</a>
<a name="ln9444">    p += 2;</a>
<a name="ln9445">  } else {</a>
<a name="ln9446">    *opt_flags = 0;</a>
<a name="ln9447">  }</a>
<a name="ln9448"> </a>
<a name="ln9449">  if (!ASCII_ISALPHA(*p)) {</a>
<a name="ln9450">    return NULL;</a>
<a name="ln9451">  }</a>
<a name="ln9452">  *arg = p;</a>
<a name="ln9453"> </a>
<a name="ln9454">  if (p[0] == 't' &amp;&amp; p[1] == '_' &amp;&amp; p[2] != NUL &amp;&amp; p[3] != NUL) {</a>
<a name="ln9455">    p += 4;  // t_xx/termcap option</a>
<a name="ln9456">  } else {</a>
<a name="ln9457">    while (ASCII_ISALPHA(*p)) {</a>
<a name="ln9458">      p++;</a>
<a name="ln9459">    }</a>
<a name="ln9460">  }</a>
<a name="ln9461">  return p;</a>
<a name="ln9462">}</a>
<a name="ln9463"> </a>
<a name="ln9464">/// Start profiling function &quot;fp&quot;.</a>
<a name="ln9465">void func_do_profile(ufunc_T *fp)</a>
<a name="ln9466">{</a>
<a name="ln9467">  int len = fp-&gt;uf_lines.ga_len;</a>
<a name="ln9468"> </a>
<a name="ln9469">  if (!fp-&gt;uf_prof_initialized) {</a>
<a name="ln9470">    if (len == 0) {</a>
<a name="ln9471">      len = 1;  // avoid getting error for allocating zero bytes</a>
<a name="ln9472">    }</a>
<a name="ln9473">    fp-&gt;uf_tm_count = 0;</a>
<a name="ln9474">    fp-&gt;uf_tm_self = profile_zero();</a>
<a name="ln9475">    fp-&gt;uf_tm_total = profile_zero();</a>
<a name="ln9476"> </a>
<a name="ln9477">    if (fp-&gt;uf_tml_count == NULL) {</a>
<a name="ln9478">      fp-&gt;uf_tml_count = xcalloc(len, sizeof(int));</a>
<a name="ln9479">    }</a>
<a name="ln9480"> </a>
<a name="ln9481">    if (fp-&gt;uf_tml_total == NULL) {</a>
<a name="ln9482">      fp-&gt;uf_tml_total = xcalloc(len, sizeof(proftime_T));</a>
<a name="ln9483">    }</a>
<a name="ln9484"> </a>
<a name="ln9485">    if (fp-&gt;uf_tml_self == NULL) {</a>
<a name="ln9486">      fp-&gt;uf_tml_self = xcalloc(len, sizeof(proftime_T));</a>
<a name="ln9487">    }</a>
<a name="ln9488"> </a>
<a name="ln9489">    fp-&gt;uf_tml_idx = -1;</a>
<a name="ln9490">    fp-&gt;uf_prof_initialized = true;</a>
<a name="ln9491">  }</a>
<a name="ln9492"> </a>
<a name="ln9493">  fp-&gt;uf_profiling = TRUE;</a>
<a name="ln9494">}</a>
<a name="ln9495"> </a>
<a name="ln9496">/*</a>
<a name="ln9497"> * Dump the profiling results for all functions in file &quot;fd&quot;.</a>
<a name="ln9498"> */</a>
<a name="ln9499">void func_dump_profile(FILE *fd)</a>
<a name="ln9500">{</a>
<a name="ln9501">  hashitem_T  *hi;</a>
<a name="ln9502">  int todo;</a>
<a name="ln9503">  ufunc_T     *fp;</a>
<a name="ln9504">  ufunc_T     **sorttab;</a>
<a name="ln9505">  int st_len = 0;</a>
<a name="ln9506"> </a>
<a name="ln9507">  todo = (int)func_hashtab.ht_used;</a>
<a name="ln9508">  if (todo == 0) {</a>
<a name="ln9509">    return;         // nothing to dump</a>
<a name="ln9510">  }</a>
<a name="ln9511"> </a>
<a name="ln9512">  sorttab = xmalloc(sizeof(ufunc_T *) * todo);</a>
<a name="ln9513"> </a>
<a name="ln9514">  for (hi = func_hashtab.ht_array; todo &gt; 0; ++hi) {</a>
<a name="ln9515">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln9516">      --todo;</a>
<a name="ln9517">      fp = HI2UF(hi);</a>
<a name="ln9518">      if (fp-&gt;uf_prof_initialized) {</a>
<a name="ln9519">        sorttab[st_len++] = fp;</a>
<a name="ln9520"> </a>
<a name="ln9521">        if (fp-&gt;uf_name[0] == K_SPECIAL) {</a>
<a name="ln9522">          fprintf(fd, &quot;FUNCTION  &lt;SNR&gt;%s()\n&quot;, fp-&gt;uf_name + 3);</a>
<a name="ln9523">        } else {</a>
<a name="ln9524">          fprintf(fd, &quot;FUNCTION  %s()\n&quot;, fp-&gt;uf_name);</a>
<a name="ln9525">        }</a>
<a name="ln9526">        if (fp-&gt;uf_script_ctx.sc_sid != 0) {</a>
<a name="ln9527">          bool should_free;</a>
<a name="ln9528">          const LastSet last_set = (LastSet){</a>
<a name="ln9529">            .script_ctx = fp-&gt;uf_script_ctx,</a>
<a name="ln9530">              .channel_id = 0,</a>
<a name="ln9531">          };</a>
<a name="ln9532">          char_u *p = get_scriptname(last_set, &amp;should_free);</a>
<a name="ln9533">          fprintf(fd, &quot;    Defined: %s:%&quot; PRIdLINENR &quot;\n&quot;,</a>
<a name="ln9534">                  p, fp-&gt;uf_script_ctx.sc_lnum);</a>
<a name="ln9535">          if (should_free) {</a>
<a name="ln9536">            xfree(p);</a>
<a name="ln9537">          }</a>
<a name="ln9538">        }</a>
<a name="ln9539">        if (fp-&gt;uf_tm_count == 1) {</a>
<a name="ln9540">          fprintf(fd, &quot;Called 1 time\n&quot;);</a>
<a name="ln9541">        } else {</a>
<a name="ln9542">          fprintf(fd, &quot;Called %d times\n&quot;, fp-&gt;uf_tm_count);</a>
<a name="ln9543">        }</a>
<a name="ln9544">        fprintf(fd, &quot;Total time: %s\n&quot;, profile_msg(fp-&gt;uf_tm_total));</a>
<a name="ln9545">        fprintf(fd, &quot; Self time: %s\n&quot;, profile_msg(fp-&gt;uf_tm_self));</a>
<a name="ln9546">        fprintf(fd, &quot;\n&quot;);</a>
<a name="ln9547">        fprintf(fd, &quot;count  total (s)   self (s)\n&quot;);</a>
<a name="ln9548"> </a>
<a name="ln9549">        for (int i = 0; i &lt; fp-&gt;uf_lines.ga_len; ++i) {</a>
<a name="ln9550">          if (FUNCLINE(fp, i) == NULL)</a>
<a name="ln9551">            continue;</a>
<a name="ln9552">          prof_func_line(fd, fp-&gt;uf_tml_count[i],</a>
<a name="ln9553">              &amp;fp-&gt;uf_tml_total[i], &amp;fp-&gt;uf_tml_self[i], TRUE);</a>
<a name="ln9554">          fprintf(fd, &quot;%s\n&quot;, FUNCLINE(fp, i));</a>
<a name="ln9555">        }</a>
<a name="ln9556">        fprintf(fd, &quot;\n&quot;);</a>
<a name="ln9557">      }</a>
<a name="ln9558">    }</a>
<a name="ln9559">  }</a>
<a name="ln9560"> </a>
<a name="ln9561">  if (st_len &gt; 0) {</a>
<a name="ln9562">    qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),</a>
<a name="ln9563">        prof_total_cmp);</a>
<a name="ln9564">    prof_sort_list(fd, sorttab, st_len, &quot;TOTAL&quot;, FALSE);</a>
<a name="ln9565">    qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),</a>
<a name="ln9566">        prof_self_cmp);</a>
<a name="ln9567">    prof_sort_list(fd, sorttab, st_len, &quot;SELF&quot;, TRUE);</a>
<a name="ln9568">  }</a>
<a name="ln9569"> </a>
<a name="ln9570">  xfree(sorttab);</a>
<a name="ln9571">}</a>
<a name="ln9572"> </a>
<a name="ln9573">static void</a>
<a name="ln9574">prof_sort_list(</a>
<a name="ln9575">    FILE *fd,</a>
<a name="ln9576">    ufunc_T **sorttab,</a>
<a name="ln9577">    int st_len,</a>
<a name="ln9578">    char *title,</a>
<a name="ln9579">    int prefer_self                // when equal print only self time</a>
<a name="ln9580">)</a>
<a name="ln9581">{</a>
<a name="ln9582">  int i;</a>
<a name="ln9583">  ufunc_T     *fp;</a>
<a name="ln9584"> </a>
<a name="ln9585">  fprintf(fd, &quot;FUNCTIONS SORTED ON %s TIME\n&quot;, title);</a>
<a name="ln9586">  fprintf(fd, &quot;count  total (s)   self (s)  function\n&quot;);</a>
<a name="ln9587">  for (i = 0; i &lt; 20 &amp;&amp; i &lt; st_len; ++i) {</a>
<a name="ln9588">    fp = sorttab[i];</a>
<a name="ln9589">    prof_func_line(fd, fp-&gt;uf_tm_count, &amp;fp-&gt;uf_tm_total, &amp;fp-&gt;uf_tm_self,</a>
<a name="ln9590">        prefer_self);</a>
<a name="ln9591">    if (fp-&gt;uf_name[0] == K_SPECIAL)</a>
<a name="ln9592">      fprintf(fd, &quot; &lt;SNR&gt;%s()\n&quot;, fp-&gt;uf_name + 3);</a>
<a name="ln9593">    else</a>
<a name="ln9594">      fprintf(fd, &quot; %s()\n&quot;, fp-&gt;uf_name);</a>
<a name="ln9595">  }</a>
<a name="ln9596">  fprintf(fd, &quot;\n&quot;);</a>
<a name="ln9597">}</a>
<a name="ln9598"> </a>
<a name="ln9599">/*</a>
<a name="ln9600"> * Print the count and times for one function or function line.</a>
<a name="ln9601"> */</a>
<a name="ln9602">static void prof_func_line(</a>
<a name="ln9603">    FILE        *fd,</a>
<a name="ln9604">    int count,</a>
<a name="ln9605">    proftime_T  *total,</a>
<a name="ln9606">    proftime_T  *self,</a>
<a name="ln9607">    int prefer_self                 // when equal print only self time</a>
<a name="ln9608">)</a>
<a name="ln9609">{</a>
<a name="ln9610">  if (count &gt; 0) {</a>
<a name="ln9611">    fprintf(fd, &quot;%5d &quot;, count);</a>
<a name="ln9612">    if (prefer_self &amp;&amp; profile_equal(*total, *self))</a>
<a name="ln9613">      fprintf(fd, &quot;           &quot;);</a>
<a name="ln9614">    else</a>
<a name="ln9615">      fprintf(fd, &quot;%s &quot;, profile_msg(*total));</a>
<a name="ln9616">    if (!prefer_self &amp;&amp; profile_equal(*total, *self))</a>
<a name="ln9617">      fprintf(fd, &quot;           &quot;);</a>
<a name="ln9618">    else</a>
<a name="ln9619">      fprintf(fd, &quot;%s &quot;, profile_msg(*self));</a>
<a name="ln9620">  } else</a>
<a name="ln9621">    fprintf(fd, &quot;                            &quot;);</a>
<a name="ln9622">}</a>
<a name="ln9623"> </a>
<a name="ln9624">/*</a>
<a name="ln9625"> * Compare function for total time sorting.</a>
<a name="ln9626"> */</a>
<a name="ln9627">static int prof_total_cmp(const void *s1, const void *s2)</a>
<a name="ln9628">{</a>
<a name="ln9629">  ufunc_T *p1 = *(ufunc_T **)s1;</a>
<a name="ln9630">  ufunc_T *p2 = *(ufunc_T **)s2;</a>
<a name="ln9631">  return profile_cmp(p1-&gt;uf_tm_total, p2-&gt;uf_tm_total);</a>
<a name="ln9632">}</a>
<a name="ln9633"> </a>
<a name="ln9634">/*</a>
<a name="ln9635"> * Compare function for self time sorting.</a>
<a name="ln9636"> */</a>
<a name="ln9637">static int prof_self_cmp(const void *s1, const void *s2)</a>
<a name="ln9638">{</a>
<a name="ln9639">  ufunc_T *p1 = *(ufunc_T **)s1;</a>
<a name="ln9640">  ufunc_T *p2 = *(ufunc_T **)s2;</a>
<a name="ln9641">  return profile_cmp(p1-&gt;uf_tm_self, p2-&gt;uf_tm_self);</a>
<a name="ln9642">}</a>
<a name="ln9643"> </a>
<a name="ln9644">/// Return the autoload script name for a function or variable name</a>
<a name="ln9645">/// Caller must make sure that &quot;name&quot; contains AUTOLOAD_CHAR.</a>
<a name="ln9646">///</a>
<a name="ln9647">/// @param[in]  name  Variable/function name.</a>
<a name="ln9648">/// @param[in]  name_len  Name length.</a>
<a name="ln9649">///</a>
<a name="ln9650">/// @return [allocated] autoload script name.</a>
<a name="ln9651">char *autoload_name(const char *const name, const size_t name_len)</a>
<a name="ln9652">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln9653">{</a>
<a name="ln9654">  // Get the script file name: replace '#' with '/', append &quot;.vim&quot;.</a>
<a name="ln9655">  char *const scriptname = xmalloc(name_len + sizeof(&quot;autoload/.vim&quot;));</a>
<a name="ln9656">  memcpy(scriptname, &quot;autoload/&quot;, sizeof(&quot;autoload/&quot;) - 1);</a>
<a name="ln9657">  memcpy(scriptname + sizeof(&quot;autoload/&quot;) - 1, name, name_len);</a>
<a name="ln9658">  size_t auchar_idx = 0;</a>
<a name="ln9659">  for (size_t i = sizeof(&quot;autoload/&quot;) - 1;</a>
<a name="ln9660">       i - sizeof(&quot;autoload/&quot;) + 1 &lt; name_len;</a>
<a name="ln9661">       i++) {</a>
<a name="ln9662">    if (scriptname[i] == AUTOLOAD_CHAR) {</a>
<a name="ln9663">      scriptname[i] = '/';</a>
<a name="ln9664">      auchar_idx = i;</a>
<a name="ln9665">    }</a>
<a name="ln9666">  }</a>
<a name="ln9667">  memcpy(scriptname + auchar_idx, &quot;.vim&quot;, sizeof(&quot;.vim&quot;));</a>
<a name="ln9668"> </a>
<a name="ln9669">  return scriptname;</a>
<a name="ln9670">}</a>
<a name="ln9671"> </a>
<a name="ln9672">/// If name has a package name try autoloading the script for it</a>
<a name="ln9673">///</a>
<a name="ln9674">/// @param[in]  name  Variable/function name.</a>
<a name="ln9675">/// @param[in]  name_len  Name length.</a>
<a name="ln9676">/// @param[in]  reload  If true, load script again when already loaded.</a>
<a name="ln9677">///</a>
<a name="ln9678">/// @return true if a package was loaded.</a>
<a name="ln9679">bool script_autoload(const char *const name, const size_t name_len,</a>
<a name="ln9680">                     const bool reload)</a>
<a name="ln9681">{</a>
<a name="ln9682">  // If there is no '#' after name[0] there is no package name.</a>
<a name="ln9683">  const char *p = memchr(name, AUTOLOAD_CHAR, name_len);</a>
<a name="ln9684">  if (p == NULL || p == name) {</a>
<a name="ln9685">    return false;</a>
<a name="ln9686">  }</a>
<a name="ln9687"> </a>
<a name="ln9688">  bool ret = false;</a>
<a name="ln9689">  char *tofree = autoload_name(name, name_len);</a>
<a name="ln9690">  char *scriptname = tofree;</a>
<a name="ln9691"> </a>
<a name="ln9692">  // Find the name in the list of previously loaded package names.  Skip</a>
<a name="ln9693">  // &quot;autoload/&quot;, it's always the same.</a>
<a name="ln9694">  int i = 0;</a>
<a name="ln9695">  for (; i &lt; ga_loaded.ga_len; i++) {</a>
<a name="ln9696">    if (STRCMP(((char **)ga_loaded.ga_data)[i] + 9, scriptname + 9) == 0) {</a>
<a name="ln9697">      break;</a>
<a name="ln9698">    }</a>
<a name="ln9699">  }</a>
<a name="ln9700">  if (!reload &amp;&amp; i &lt; ga_loaded.ga_len) {</a>
<a name="ln9701">    ret = false;  // Was loaded already.</a>
<a name="ln9702">  } else {</a>
<a name="ln9703">    // Remember the name if it wasn't loaded already.</a>
<a name="ln9704">    if (i == ga_loaded.ga_len) {</a>
<a name="ln9705">      GA_APPEND(char *, &amp;ga_loaded, scriptname);</a>
<a name="ln9706">      tofree = NULL;</a>
<a name="ln9707">    }</a>
<a name="ln9708"> </a>
<a name="ln9709">    // Try loading the package from $VIMRUNTIME/autoload/&lt;name&gt;.vim</a>
<a name="ln9710">    if (source_runtime((char_u *)scriptname, 0) == OK) {</a>
<a name="ln9711">      ret = true;</a>
<a name="ln9712">    }</a>
<a name="ln9713">  }</a>
<a name="ln9714"> </a>
<a name="ln9715">  xfree(tofree);</a>
<a name="ln9716">  return ret;</a>
<a name="ln9717">}</a>
<a name="ln9718"> </a>
<a name="ln9719">/*</a>
<a name="ln9720"> * Called when starting to read a function line.</a>
<a name="ln9721"> * &quot;sourcing_lnum&quot; must be correct!</a>
<a name="ln9722"> * When skipping lines it may not actually be executed, but we won't find out</a>
<a name="ln9723"> * until later and we need to store the time now.</a>
<a name="ln9724"> */</a>
<a name="ln9725">void func_line_start(void *cookie)</a>
<a name="ln9726">{</a>
<a name="ln9727">  funccall_T  *fcp = (funccall_T *)cookie;</a>
<a name="ln9728">  ufunc_T     *fp = fcp-&gt;func;</a>
<a name="ln9729"> </a>
<a name="ln9730">  if (fp-&gt;uf_profiling &amp;&amp; sourcing_lnum &gt;= 1</a>
<a name="ln9731">      &amp;&amp; sourcing_lnum &lt;= fp-&gt;uf_lines.ga_len) {</a>
<a name="ln9732">    fp-&gt;uf_tml_idx = sourcing_lnum - 1;</a>
<a name="ln9733">    // Skip continuation lines.</a>
<a name="ln9734">    while (fp-&gt;uf_tml_idx &gt; 0 &amp;&amp; FUNCLINE(fp, fp-&gt;uf_tml_idx) == NULL) {</a>
<a name="ln9735">      fp-&gt;uf_tml_idx--;</a>
<a name="ln9736">    }</a>
<a name="ln9737">    fp-&gt;uf_tml_execed = false;</a>
<a name="ln9738">    fp-&gt;uf_tml_start = profile_start();</a>
<a name="ln9739">    fp-&gt;uf_tml_children = profile_zero();</a>
<a name="ln9740">    fp-&gt;uf_tml_wait = profile_get_wait();</a>
<a name="ln9741">  }</a>
<a name="ln9742">}</a>
<a name="ln9743"> </a>
<a name="ln9744">/*</a>
<a name="ln9745"> * Called when actually executing a function line.</a>
<a name="ln9746"> */</a>
<a name="ln9747">void func_line_exec(void *cookie)</a>
<a name="ln9748">{</a>
<a name="ln9749">  funccall_T  *fcp = (funccall_T *)cookie;</a>
<a name="ln9750">  ufunc_T     *fp = fcp-&gt;func;</a>
<a name="ln9751"> </a>
<a name="ln9752">  if (fp-&gt;uf_profiling &amp;&amp; fp-&gt;uf_tml_idx &gt;= 0)</a>
<a name="ln9753">    fp-&gt;uf_tml_execed = TRUE;</a>
<a name="ln9754">}</a>
<a name="ln9755"> </a>
<a name="ln9756">/*</a>
<a name="ln9757"> * Called when done with a function line.</a>
<a name="ln9758"> */</a>
<a name="ln9759">void func_line_end(void *cookie)</a>
<a name="ln9760">{</a>
<a name="ln9761">  funccall_T  *fcp = (funccall_T *)cookie;</a>
<a name="ln9762">  ufunc_T     *fp = fcp-&gt;func;</a>
<a name="ln9763"> </a>
<a name="ln9764">  if (fp-&gt;uf_profiling &amp;&amp; fp-&gt;uf_tml_idx &gt;= 0) {</a>
<a name="ln9765">    if (fp-&gt;uf_tml_execed) {</a>
<a name="ln9766">      ++fp-&gt;uf_tml_count[fp-&gt;uf_tml_idx];</a>
<a name="ln9767">      fp-&gt;uf_tml_start = profile_end(fp-&gt;uf_tml_start);</a>
<a name="ln9768">      fp-&gt;uf_tml_start = profile_sub_wait(fp-&gt;uf_tml_wait, fp-&gt;uf_tml_start);</a>
<a name="ln9769">      fp-&gt;uf_tml_total[fp-&gt;uf_tml_idx] =</a>
<a name="ln9770">        profile_add(fp-&gt;uf_tml_total[fp-&gt;uf_tml_idx], fp-&gt;uf_tml_start);</a>
<a name="ln9771">      fp-&gt;uf_tml_self[fp-&gt;uf_tml_idx] =</a>
<a name="ln9772">        profile_self(fp-&gt;uf_tml_self[fp-&gt;uf_tml_idx], fp-&gt;uf_tml_start,</a>
<a name="ln9773">          fp-&gt;uf_tml_children);</a>
<a name="ln9774">    }</a>
<a name="ln9775">    fp-&gt;uf_tml_idx = -1;</a>
<a name="ln9776">  }</a>
<a name="ln9777">}</a>
<a name="ln9778"> </a>
<a name="ln9779">static var_flavour_T var_flavour(char_u *varname)</a>
<a name="ln9780">{</a>
<a name="ln9781">  char_u *p = varname;</a>
<a name="ln9782"> </a>
<a name="ln9783">  if (ASCII_ISUPPER(*p)) {</a>
<a name="ln9784">    while (*(++p))</a>
<a name="ln9785">      if (ASCII_ISLOWER(*p)) {</a>
<a name="ln9786">        return VAR_FLAVOUR_SESSION;</a>
<a name="ln9787">      }</a>
<a name="ln9788">    return VAR_FLAVOUR_SHADA;</a>
<a name="ln9789">  } else {</a>
<a name="ln9790">    return VAR_FLAVOUR_DEFAULT;</a>
<a name="ln9791">  }</a>
<a name="ln9792">}</a>
<a name="ln9793"> </a>
<a name="ln9794">/// Iterate over global variables</a>
<a name="ln9795">///</a>
<a name="ln9796">/// @warning No modifications to global variable dictionary must be performed</a>
<a name="ln9797">///          while iteration is in progress.</a>
<a name="ln9798">///</a>
<a name="ln9799">/// @param[in]   iter   Iterator. Pass NULL to start iteration.</a>
<a name="ln9800">/// @param[out]  name   Variable name.</a>
<a name="ln9801">/// @param[out]  rettv  Variable value.</a>
<a name="ln9802">///</a>
<a name="ln9803">/// @return Pointer that needs to be passed to next `var_shada_iter` invocation</a>
<a name="ln9804">///         or NULL to indicate that iteration is over.</a>
<a name="ln9805">const void *var_shada_iter(const void *const iter, const char **const name,</a>
<a name="ln9806">                           typval_T *rettv, var_flavour_T flavour)</a>
<a name="ln9807">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(2, 3)</a>
<a name="ln9808">{</a>
<a name="ln9809">  const hashitem_T *hi;</a>
<a name="ln9810">  const hashitem_T *hifirst = globvarht.ht_array;</a>
<a name="ln9811">  const size_t hinum = (size_t) globvarht.ht_mask + 1;</a>
<a name="ln9812">  *name = NULL;</a>
<a name="ln9813">  if (iter == NULL) {</a>
<a name="ln9814">    hi = globvarht.ht_array;</a>
<a name="ln9815">    while ((size_t) (hi - hifirst) &lt; hinum</a>
<a name="ln9816">           &amp;&amp; (HASHITEM_EMPTY(hi)</a>
<a name="ln9817">               || !(var_flavour(hi-&gt;hi_key) &amp; flavour))) {</a>
<a name="ln9818">      hi++;</a>
<a name="ln9819">    }</a>
<a name="ln9820">    if ((size_t) (hi - hifirst) == hinum) {</a>
<a name="ln9821">      return NULL;</a>
<a name="ln9822">    }</a>
<a name="ln9823">  } else {</a>
<a name="ln9824">    hi = (const hashitem_T *) iter;</a>
<a name="ln9825">  }</a>
<a name="ln9826">  *name = (char *)TV_DICT_HI2DI(hi)-&gt;di_key;</a>
<a name="ln9827">  tv_copy(&amp;TV_DICT_HI2DI(hi)-&gt;di_tv, rettv);</a>
<a name="ln9828">  while ((size_t)(++hi - hifirst) &lt; hinum) {</a>
<a name="ln9829">    if (!HASHITEM_EMPTY(hi) &amp;&amp; (var_flavour(hi-&gt;hi_key) &amp; flavour)) {</a>
<a name="ln9830">      return hi;</a>
<a name="ln9831">    }</a>
<a name="ln9832">  }</a>
<a name="ln9833">  return NULL;</a>
<a name="ln9834">}</a>
<a name="ln9835"> </a>
<a name="ln9836">void var_set_global(const char *const name, typval_T vartv)</a>
<a name="ln9837">{</a>
<a name="ln9838">  funccal_entry_T funccall_entry;</a>
<a name="ln9839"> </a>
<a name="ln9840">  save_funccal(&amp;funccall_entry);</a>
<a name="ln9841">  set_var(name, strlen(name), &amp;vartv, false);</a>
<a name="ln9842">  restore_funccal();</a>
<a name="ln9843">}</a>
<a name="ln9844"> </a>
<a name="ln9845">int store_session_globals(FILE *fd)</a>
<a name="ln9846">{</a>
<a name="ln9847">  TV_DICT_ITER(&amp;globvardict, this_var, {</a>
<a name="ln9848">    if ((this_var-&gt;di_tv.v_type == VAR_NUMBER</a>
<a name="ln9849">         || this_var-&gt;di_tv.v_type == VAR_STRING)</a>
<a name="ln9850">        &amp;&amp; var_flavour(this_var-&gt;di_key) == VAR_FLAVOUR_SESSION) {</a>
<a name="ln9851">      // Escape special characters with a backslash.  Turn a LF and</a>
<a name="ln9852">      // CR into \n and \r.</a>
<a name="ln9853">      char_u *const p = vim_strsave_escaped(</a>
<a name="ln9854">          (const char_u *)tv_get_string(&amp;this_var-&gt;di_tv),</a>
<a name="ln9855">          (const char_u *)&quot;\\\&quot;\n\r&quot;);</a>
<a name="ln9856">      for (char_u *t = p; *t != NUL; t++) {</a>
<a name="ln9857">        if (*t == '\n') {</a>
<a name="ln9858">          *t = 'n';</a>
<a name="ln9859">        } else if (*t == '\r') {</a>
<a name="ln9860">          *t = 'r';</a>
<a name="ln9861">        }</a>
<a name="ln9862">      }</a>
<a name="ln9863">      if ((fprintf(fd, &quot;let %s = %c%s%c&quot;,</a>
<a name="ln9864">                   this_var-&gt;di_key,</a>
<a name="ln9865">                   ((this_var-&gt;di_tv.v_type == VAR_STRING) ? '&quot;'</a>
<a name="ln9866">                    : ' '),</a>
<a name="ln9867">                   p,</a>
<a name="ln9868">                   ((this_var-&gt;di_tv.v_type == VAR_STRING) ? '&quot;'</a>
<a name="ln9869">                    : ' ')) &lt; 0)</a>
<a name="ln9870">          || put_eol(fd) == FAIL) {</a>
<a name="ln9871">        xfree(p);</a>
<a name="ln9872">        return FAIL;</a>
<a name="ln9873">      }</a>
<a name="ln9874">      xfree(p);</a>
<a name="ln9875">    } else if (this_var-&gt;di_tv.v_type == VAR_FLOAT</a>
<a name="ln9876">               &amp;&amp; var_flavour(this_var-&gt;di_key) == VAR_FLAVOUR_SESSION) {</a>
<a name="ln9877">      float_T f = this_var-&gt;di_tv.vval.v_float;</a>
<a name="ln9878">      int sign = ' ';</a>
<a name="ln9879"> </a>
<a name="ln9880">      if (f &lt; 0) {</a>
<a name="ln9881">        f = -f;</a>
<a name="ln9882">        sign = '-';</a>
<a name="ln9883">      }</a>
<a name="ln9884">      if ((fprintf(fd, &quot;let %s = %c%f&quot;, this_var-&gt;di_key, sign, f) &lt; 0)</a>
<a name="ln9885">          || put_eol(fd) == FAIL) {</a>
<a name="ln9886">        return FAIL;</a>
<a name="ln9887">      }</a>
<a name="ln9888">    }</a>
<a name="ln9889">  });</a>
<a name="ln9890">  return OK;</a>
<a name="ln9891">}</a>
<a name="ln9892"> </a>
<a name="ln9893">/*</a>
<a name="ln9894"> * Display script name where an item was last set.</a>
<a name="ln9895"> * Should only be invoked when 'verbose' is non-zero.</a>
<a name="ln9896"> */</a>
<a name="ln9897">void last_set_msg(sctx_T script_ctx)</a>
<a name="ln9898">{</a>
<a name="ln9899">  const LastSet last_set = (LastSet){</a>
<a name="ln9900">    .script_ctx = script_ctx,</a>
<a name="ln9901">    .channel_id = 0,</a>
<a name="ln9902">  };</a>
<a name="ln9903">  option_last_set_msg(last_set);</a>
<a name="ln9904">}</a>
<a name="ln9905"> </a>
<a name="ln9906">/// Displays where an option was last set.</a>
<a name="ln9907">///</a>
<a name="ln9908">/// Should only be invoked when 'verbose' is non-zero.</a>
<a name="ln9909">void option_last_set_msg(LastSet last_set)</a>
<a name="ln9910">{</a>
<a name="ln9911">  if (last_set.script_ctx.sc_sid != 0) {</a>
<a name="ln9912">    bool should_free;</a>
<a name="ln9913">    char_u *p = get_scriptname(last_set, &amp;should_free);</a>
<a name="ln9914">    verbose_enter();</a>
<a name="ln9915">    MSG_PUTS(_(&quot;\n\tLast set from &quot;));</a>
<a name="ln9916">    MSG_PUTS(p);</a>
<a name="ln9917">    if (last_set.script_ctx.sc_lnum &gt; 0) {</a>
<a name="ln9918">      MSG_PUTS(_(line_msg));</a>
<a name="ln9919">      msg_outnum((long)last_set.script_ctx.sc_lnum);</a>
<a name="ln9920">    }</a>
<a name="ln9921">    if (should_free) {</a>
<a name="ln9922">      xfree(p);</a>
<a name="ln9923">    }</a>
<a name="ln9924">    verbose_leave();</a>
<a name="ln9925">  }</a>
<a name="ln9926">}</a>
<a name="ln9927"> </a>
<a name="ln9928">// reset v:option_new, v:option_old and v:option_type</a>
<a name="ln9929">void reset_v_option_vars(void)</a>
<a name="ln9930">{</a>
<a name="ln9931">  set_vim_var_string(VV_OPTION_NEW,  NULL, -1);</a>
<a name="ln9932">  set_vim_var_string(VV_OPTION_OLD,  NULL, -1);</a>
<a name="ln9933">  set_vim_var_string(VV_OPTION_TYPE, NULL, -1);</a>
<a name="ln9934">}</a>
<a name="ln9935"> </a>
<a name="ln9936">/*</a>
<a name="ln9937"> * Adjust a filename, according to a string of modifiers.</a>
<a name="ln9938"> * *fnamep must be NUL terminated when called.  When returning, the length is</a>
<a name="ln9939"> * determined by *fnamelen.</a>
<a name="ln9940"> * Returns VALID_ flags or -1 for failure.</a>
<a name="ln9941"> * When there is an error, *fnamep is set to NULL.</a>
<a name="ln9942"> */</a>
<a name="ln9943">int</a>
<a name="ln9944">modify_fname(</a>
<a name="ln9945">    char_u *src,              // string with modifiers</a>
<a name="ln9946">    bool tilde_file,          // &quot;~&quot; is a file name, not $HOME</a>
<a name="ln9947">    size_t *usedlen,          // characters after src that are used</a>
<a name="ln9948">    char_u **fnamep,          // file name so far</a>
<a name="ln9949">    char_u **bufp,            // buffer for allocated file name or NULL</a>
<a name="ln9950">    size_t *fnamelen          // length of fnamep</a>
<a name="ln9951">)</a>
<a name="ln9952">{</a>
<a name="ln9953">  int valid = 0;</a>
<a name="ln9954">  char_u      *tail;</a>
<a name="ln9955">  char_u      *s, *p, *pbuf;</a>
<a name="ln9956">  char_u dirname[MAXPATHL];</a>
<a name="ln9957">  int c;</a>
<a name="ln9958">  int has_fullname = 0;</a>
<a name="ln9959"> </a>
<a name="ln9960">repeat:</a>
<a name="ln9961">  // &quot;:p&quot; - full path/file_name</a>
<a name="ln9962">  if (src[*usedlen] == ':' &amp;&amp; src[*usedlen + 1] == 'p') {</a>
<a name="ln9963">    has_fullname = 1;</a>
<a name="ln9964"> </a>
<a name="ln9965">    valid |= VALID_PATH;</a>
<a name="ln9966">    *usedlen += 2;</a>
<a name="ln9967"> </a>
<a name="ln9968">    // Expand &quot;~/path&quot; for all systems and &quot;~user/path&quot; for Unix</a>
<a name="ln9969">    if ((*fnamep)[0] == '~'</a>
<a name="ln9970">#if !defined(UNIX)</a>
<a name="ln9971">        &amp;&amp; ((*fnamep)[1] == '/'</a>
<a name="ln9972"># ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln9973">            || (*fnamep)[1] == '\\'</a>
<a name="ln9974"># endif</a>
<a name="ln9975">            || (*fnamep)[1] == NUL)</a>
<a name="ln9976">#endif</a>
<a name="ln9977">        &amp;&amp; !(tilde_file &amp;&amp; (*fnamep)[1] == NUL)</a>
<a name="ln9978">        ) {</a>
<a name="ln9979">      *fnamep = expand_env_save(*fnamep);</a>
<a name="ln9980">      xfree(*bufp);          // free any allocated file name</a>
<a name="ln9981">      *bufp = *fnamep;</a>
<a name="ln9982">      if (*fnamep == NULL)</a>
<a name="ln9983">        return -1;</a>
<a name="ln9984">    }</a>
<a name="ln9985"> </a>
<a name="ln9986">    // When &quot;/.&quot; or &quot;/..&quot; is used: force expansion to get rid of it.</a>
<a name="ln9987">    for (p = *fnamep; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln9988">      if (vim_ispathsep(*p)</a>
<a name="ln9989">          &amp;&amp; p[1] == '.'</a>
<a name="ln9990">          &amp;&amp; (p[2] == NUL</a>
<a name="ln9991">              || vim_ispathsep(p[2])</a>
<a name="ln9992">              || (p[2] == '.'</a>
<a name="ln9993">                  &amp;&amp; (p[3] == NUL || vim_ispathsep(p[3]))))) {</a>
<a name="ln9994">        break;</a>
<a name="ln9995">      }</a>
<a name="ln9996">    }</a>
<a name="ln9997"> </a>
<a name="ln9998">    // FullName_save() is slow, don't use it when not needed.</a>
<a name="ln9999">    if (*p != NUL || !vim_isAbsName(*fnamep)) {</a>
<a name="ln10000">      *fnamep = (char_u *)FullName_save((char *)(*fnamep), *p != NUL);</a>
<a name="ln10001">      xfree(*bufp);          // free any allocated file name</a>
<a name="ln10002">      *bufp = *fnamep;</a>
<a name="ln10003">      if (*fnamep == NULL)</a>
<a name="ln10004">        return -1;</a>
<a name="ln10005">    }</a>
<a name="ln10006"> </a>
<a name="ln10007">    // Append a path separator to a directory.</a>
<a name="ln10008">    if (os_isdir(*fnamep)) {</a>
<a name="ln10009">      // Make room for one or two extra characters.</a>
<a name="ln10010">      *fnamep = vim_strnsave(*fnamep, STRLEN(*fnamep) + 2);</a>
<a name="ln10011">      xfree(*bufp);          // free any allocated file name</a>
<a name="ln10012">      *bufp = *fnamep;</a>
<a name="ln10013">      if (*fnamep == NULL)</a>
<a name="ln10014">        return -1;</a>
<a name="ln10015">      add_pathsep((char *)*fnamep);</a>
<a name="ln10016">    }</a>
<a name="ln10017">  }</a>
<a name="ln10018"> </a>
<a name="ln10019">  // &quot;:.&quot; - path relative to the current directory</a>
<a name="ln10020">  // &quot;:~&quot; - path relative to the home directory</a>
<a name="ln10021">  // &quot;:8&quot; - shortname path - postponed till after</a>
<a name="ln10022">  while (src[*usedlen] == ':'</a>
<a name="ln10023">         &amp;&amp; ((c = src[*usedlen + 1]) == '.' || c == '~' || c == '8')) {</a>
<a name="ln10024">    *usedlen += 2;</a>
<a name="ln10025">    if (c == '8') {</a>
<a name="ln10026">      continue;</a>
<a name="ln10027">    }</a>
<a name="ln10028">    pbuf = NULL;</a>
<a name="ln10029">    // Need full path first (use expand_env() to remove a &quot;~/&quot;)</a>
<a name="ln10030">    if (!has_fullname) {</a>
<a name="ln10031">      if (c == '.' &amp;&amp; **fnamep == '~')</a>
<a name="ln10032">        p = pbuf = expand_env_save(*fnamep);</a>
<a name="ln10033">      else</a>
<a name="ln10034">        p = pbuf = (char_u *)FullName_save((char *)*fnamep, FALSE);</a>
<a name="ln10035">    } else</a>
<a name="ln10036">      p = *fnamep;</a>
<a name="ln10037"> </a>
<a name="ln10038">    has_fullname = 0;</a>
<a name="ln10039"> </a>
<a name="ln10040">    if (p != NULL) {</a>
<a name="ln10041">      if (c == '.') {</a>
<a name="ln10042">        os_dirname(dirname, MAXPATHL);</a>
<a name="ln10043">        s = path_shorten_fname(p, dirname);</a>
<a name="ln10044">        if (s != NULL) {</a>
<a name="ln10045">          *fnamep = s;</a>
<a name="ln10046">          if (pbuf != NULL) {</a>
<a name="ln10047">            xfree(*bufp);               // free any allocated file name</a>
<a name="ln10048">            *bufp = pbuf;</a>
<a name="ln10049">            pbuf = NULL;</a>
<a name="ln10050">          }</a>
<a name="ln10051">        }</a>
<a name="ln10052">      } else {</a>
<a name="ln10053">        home_replace(NULL, p, dirname, MAXPATHL, true);</a>
<a name="ln10054">        // Only replace it when it starts with '~'</a>
<a name="ln10055">        if (*dirname == '~') {</a>
<a name="ln10056">          s = vim_strsave(dirname);</a>
<a name="ln10057">          *fnamep = s;</a>
<a name="ln10058">          xfree(*bufp);</a>
<a name="ln10059">          *bufp = s;</a>
<a name="ln10060">        }</a>
<a name="ln10061">      }</a>
<a name="ln10062">      xfree(pbuf);</a>
<a name="ln10063">    }</a>
<a name="ln10064">  }</a>
<a name="ln10065"> </a>
<a name="ln10066">  tail = path_tail(*fnamep);</a>
<a name="ln10067">  *fnamelen = STRLEN(*fnamep);</a>
<a name="ln10068"> </a>
<a name="ln10069">  // &quot;:h&quot; - head, remove &quot;/file_name&quot;, can be repeated</a>
<a name="ln10070">  // Don't remove the first &quot;/&quot; or &quot;c:\&quot;</a>
<a name="ln10071">  while (src[*usedlen] == ':' &amp;&amp; src[*usedlen + 1] == 'h') {</a>
<a name="ln10072">    valid |= VALID_HEAD;</a>
<a name="ln10073">    *usedlen += 2;</a>
<a name="ln10074">    s = get_past_head(*fnamep);</a>
<a name="ln10075">    while (tail &gt; s &amp;&amp; after_pathsep((char *)s, (char *)tail)) {</a>
<a name="ln10076">      MB_PTR_BACK(*fnamep, tail);</a>
<a name="ln10077">    }</a>
<a name="ln10078">    *fnamelen = (size_t)(tail - *fnamep);</a>
<a name="ln10079">    if (*fnamelen == 0) {</a>
<a name="ln10080">      // Result is empty.  Turn it into &quot;.&quot; to make &quot;:cd %:h&quot; work.</a>
<a name="ln10081">      xfree(*bufp);</a>
<a name="ln10082">      *bufp = *fnamep = tail = vim_strsave((char_u *)&quot;.&quot;);</a>
<a name="ln10083">      *fnamelen = 1;</a>
<a name="ln10084">    } else {</a>
<a name="ln10085">      while (tail &gt; s &amp;&amp; !after_pathsep((char *)s, (char *)tail)) {</a>
<a name="ln10086">        MB_PTR_BACK(*fnamep, tail);</a>
<a name="ln10087">      }</a>
<a name="ln10088">    }</a>
<a name="ln10089">  }</a>
<a name="ln10090"> </a>
<a name="ln10091">  // &quot;:8&quot; - shortname</a>
<a name="ln10092">  if (src[*usedlen] == ':' &amp;&amp; src[*usedlen + 1] == '8') {</a>
<a name="ln10093">    *usedlen += 2;</a>
<a name="ln10094">  }</a>
<a name="ln10095"> </a>
<a name="ln10096"> </a>
<a name="ln10097">  // &quot;:t&quot; - tail, just the basename</a>
<a name="ln10098">  if (src[*usedlen] == ':' &amp;&amp; src[*usedlen + 1] == 't') {</a>
<a name="ln10099">    *usedlen += 2;</a>
<a name="ln10100">    *fnamelen -= (size_t)(tail - *fnamep);</a>
<a name="ln10101">    *fnamep = tail;</a>
<a name="ln10102">  }</a>
<a name="ln10103"> </a>
<a name="ln10104">  // &quot;:e&quot; - extension, can be repeated</a>
<a name="ln10105">  // &quot;:r&quot; - root, without extension, can be repeated</a>
<a name="ln10106">  while (src[*usedlen] == ':'</a>
<a name="ln10107">         &amp;&amp; (src[*usedlen + 1] == 'e' || src[*usedlen + 1] == 'r')) {</a>
<a name="ln10108">    /* find a '.' in the tail:</a>
<a name="ln10109">     * - for second :e: before the current fname</a>
<a name="ln10110">     * - otherwise: The last '.'</a>
<a name="ln10111">     */</a>
<a name="ln10112">    const bool is_second_e = *fnamep &gt; tail;</a>
<a name="ln10113">    if (src[*usedlen + 1] == 'e' &amp;&amp; is_second_e) {</a>
<a name="ln10114">      s = *fnamep - 2;</a>
<a name="ln10115">    } else {</a>
<a name="ln10116">      s = *fnamep + *fnamelen - 1;</a>
<a name="ln10117">    }</a>
<a name="ln10118"> </a>
<a name="ln10119">    for (; s &gt; tail; s--) {</a>
<a name="ln10120">      if (s[0] == '.') {</a>
<a name="ln10121">        break;</a>
<a name="ln10122">      }</a>
<a name="ln10123">    }</a>
<a name="ln10124">    if (src[*usedlen + 1] == 'e') {</a>
<a name="ln10125">      if (s &gt; tail || (0 &amp;&amp; is_second_e &amp;&amp; s == tail)) {</a>
<a name="ln10126">        // we stopped at a '.' (so anchor to &amp;'.' + 1)</a>
<a name="ln10127">        char_u *newstart = s + 1;</a>
<a name="ln10128">        size_t distance_stepped_back = *fnamep - newstart;</a>
<a name="ln10129">        *fnamelen += distance_stepped_back;</a>
<a name="ln10130">        *fnamep = newstart;</a>
<a name="ln10131">      } else if (*fnamep &lt;= tail) {</a>
<a name="ln10132">        *fnamelen = 0;</a>
<a name="ln10133">      }</a>
<a name="ln10134">    } else {</a>
<a name="ln10135">      // :r - Remove one extension</a>
<a name="ln10136">      //</a>
<a name="ln10137">      // Ensure that `s` doesn't go before `*fnamep`,</a>
<a name="ln10138">      // since then we're taking too many roots:</a>
<a name="ln10139">      //</a>
<a name="ln10140">      // &quot;path/to/this.file.ext&quot; :e:e:r:r</a>
<a name="ln10141">      //          ^    ^-------- *fnamep</a>
<a name="ln10142">      //          +------------- tail</a>
<a name="ln10143">      //</a>
<a name="ln10144">      // Also ensure `s` doesn't go before `tail`,</a>
<a name="ln10145">      // since then we're taking too many roots again:</a>
<a name="ln10146">      //</a>
<a name="ln10147">      // &quot;path/to/this.file.ext&quot; :r:r:r</a>
<a name="ln10148">      //  ^       ^------------- tail</a>
<a name="ln10149">      //  +--------------------- *fnamep</a>
<a name="ln10150">      if (s &gt; MAX(tail, *fnamep)) {</a>
<a name="ln10151">        *fnamelen = (size_t)(s - *fnamep);</a>
<a name="ln10152">      }</a>
<a name="ln10153">    }</a>
<a name="ln10154">    *usedlen += 2;</a>
<a name="ln10155">  }</a>
<a name="ln10156"> </a>
<a name="ln10157">  // &quot;:s?pat?foo?&quot; - substitute</a>
<a name="ln10158">  // &quot;:gs?pat?foo?&quot; - global substitute</a>
<a name="ln10159">  if (src[*usedlen] == ':'</a>
<a name="ln10160">      &amp;&amp; (src[*usedlen + 1] == 's'</a>
<a name="ln10161">          || (src[*usedlen + 1] == 'g' &amp;&amp; src[*usedlen + 2] == 's'))) {</a>
<a name="ln10162">    int sep;</a>
<a name="ln10163">    char_u      *flags;</a>
<a name="ln10164">    int didit = FALSE;</a>
<a name="ln10165"> </a>
<a name="ln10166">    flags = (char_u *)&quot;&quot;;</a>
<a name="ln10167">    s = src + *usedlen + 2;</a>
<a name="ln10168">    if (src[*usedlen + 1] == 'g') {</a>
<a name="ln10169">      flags = (char_u *)&quot;g&quot;;</a>
<a name="ln10170">      ++s;</a>
<a name="ln10171">    }</a>
<a name="ln10172"> </a>
<a name="ln10173">    sep = *s++;</a>
<a name="ln10174">    if (sep) {</a>
<a name="ln10175">      // find end of pattern</a>
<a name="ln10176">      p = vim_strchr(s, sep);</a>
<a name="ln10177">      if (p != NULL) {</a>
<a name="ln10178">        char_u *const pat = vim_strnsave(s, p - s);</a>
<a name="ln10179">        s = p + 1;</a>
<a name="ln10180">        // find end of substitution</a>
<a name="ln10181">        p = vim_strchr(s, sep);</a>
<a name="ln10182">        if (p != NULL) {</a>
<a name="ln10183">          char_u *const sub = vim_strnsave(s, p - s);</a>
<a name="ln10184">          char_u *const str = vim_strnsave(*fnamep, *fnamelen);</a>
<a name="ln10185">          *usedlen = (size_t)(p + 1 - src);</a>
<a name="ln10186">          s = do_string_sub(str, pat, sub, NULL, flags);</a>
<a name="ln10187">          *fnamep = s;</a>
<a name="ln10188">          *fnamelen = STRLEN(s);</a>
<a name="ln10189">          xfree(*bufp);</a>
<a name="ln10190">          *bufp = s;</a>
<a name="ln10191">          didit = TRUE;</a>
<a name="ln10192">          xfree(sub);</a>
<a name="ln10193">          xfree(str);</a>
<a name="ln10194">        }</a>
<a name="ln10195">        xfree(pat);</a>
<a name="ln10196">      }</a>
<a name="ln10197">      // after using &quot;:s&quot;, repeat all the modifiers</a>
<a name="ln10198">      if (didit) {</a>
<a name="ln10199">        goto repeat;</a>
<a name="ln10200">      }</a>
<a name="ln10201">    }</a>
<a name="ln10202">  }</a>
<a name="ln10203"> </a>
<a name="ln10204">  if (src[*usedlen] == ':' &amp;&amp; src[*usedlen + 1] == 'S') {</a>
<a name="ln10205">    // vim_strsave_shellescape() needs a NUL terminated string.</a>
<a name="ln10206">    c = (*fnamep)[*fnamelen];</a>
<a name="ln10207">    if (c != NUL) {</a>
<a name="ln10208">      (*fnamep)[*fnamelen] = NUL;</a>
<a name="ln10209">    }</a>
<a name="ln10210">    p = vim_strsave_shellescape(*fnamep, false, false);</a>
<a name="ln10211">    if (c != NUL) {</a>
<a name="ln10212">      (*fnamep)[*fnamelen] = c;</a>
<a name="ln10213">    }</a>
<a name="ln10214">    xfree(*bufp);</a>
<a name="ln10215">    *bufp = *fnamep = p;</a>
<a name="ln10216">    *fnamelen = STRLEN(p);</a>
<a name="ln10217">    *usedlen += 2;</a>
<a name="ln10218">  }</a>
<a name="ln10219"> </a>
<a name="ln10220">  return valid;</a>
<a name="ln10221">}</a>
<a name="ln10222"> </a>
<a name="ln10223">/// Perform a substitution on &quot;str&quot; with pattern &quot;pat&quot; and substitute &quot;sub&quot;.</a>
<a name="ln10224">/// When &quot;sub&quot; is NULL &quot;expr&quot; is used, must be a VAR_FUNC or VAR_PARTIAL.</a>
<a name="ln10225">/// &quot;flags&quot; can be &quot;g&quot; to do a global substitute.</a>
<a name="ln10226">/// Returns an allocated string, NULL for error.</a>
<a name="ln10227">char_u *do_string_sub(char_u *str, char_u *pat, char_u *sub,</a>
<a name="ln10228">                      typval_T *expr, char_u *flags)</a>
<a name="ln10229">{</a>
<a name="ln10230">  int sublen;</a>
<a name="ln10231">  regmatch_T regmatch;</a>
<a name="ln10232">  int do_all;</a>
<a name="ln10233">  char_u      *tail;</a>
<a name="ln10234">  char_u      *end;</a>
<a name="ln10235">  garray_T ga;</a>
<a name="ln10236">  char_u      *save_cpo;</a>
<a name="ln10237">  char_u      *zero_width = NULL;</a>
<a name="ln10238"> </a>
<a name="ln10239">  // Make 'cpoptions' empty, so that the 'l' flag doesn't work here</a>
<a name="ln10240">  save_cpo = p_cpo;</a>
<a name="ln10241">  p_cpo = empty_option;</a>
<a name="ln10242"> </a>
<a name="ln10243">  ga_init(&amp;ga, 1, 200);</a>
<a name="ln10244"> </a>
<a name="ln10245">  do_all = (flags[0] == 'g');</a>
<a name="ln10246"> </a>
<a name="ln10247">  regmatch.rm_ic = p_ic;</a>
<a name="ln10248">  regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);</a>
<a name="ln10249">  if (regmatch.regprog != NULL) {</a>
<a name="ln10250">    tail = str;</a>
<a name="ln10251">    end = str + STRLEN(str);</a>
<a name="ln10252">    while (vim_regexec_nl(&amp;regmatch, str, (colnr_T)(tail - str))) {</a>
<a name="ln10253">      // Skip empty match except for first match.</a>
<a name="ln10254">      if (regmatch.startp[0] == regmatch.endp[0]) {</a>
<a name="ln10255">        if (zero_width == regmatch.startp[0]) {</a>
<a name="ln10256">          // avoid getting stuck on a match with an empty string</a>
<a name="ln10257">          int i = utfc_ptr2len(tail);</a>
<a name="ln10258">          memmove((char_u *)ga.ga_data + ga.ga_len, tail, (size_t)i);</a>
<a name="ln10259">          ga.ga_len += i;</a>
<a name="ln10260">          tail += i;</a>
<a name="ln10261">          continue;</a>
<a name="ln10262">        }</a>
<a name="ln10263">        zero_width = regmatch.startp[0];</a>
<a name="ln10264">      }</a>
<a name="ln10265"> </a>
<a name="ln10266">      // Get some space for a temporary buffer to do the substitution</a>
<a name="ln10267">      // into.  It will contain:</a>
<a name="ln10268">      // - The text up to where the match is.</a>
<a name="ln10269">      // - The substituted text.</a>
<a name="ln10270">      // - The text after the match.</a>
<a name="ln10271">      sublen = vim_regsub(&amp;regmatch, sub, expr, tail, false, true, false);</a>
<a name="ln10272">      ga_grow(&amp;ga, (int)((end - tail) + sublen -</a>
<a name="ln10273">                     (regmatch.endp[0] - regmatch.startp[0])));</a>
<a name="ln10274"> </a>
<a name="ln10275">      // copy the text up to where the match is</a>
<a name="ln10276">      int i = (int)(regmatch.startp[0] - tail);</a>
<a name="ln10277">      memmove((char_u *)ga.ga_data + ga.ga_len, tail, (size_t)i);</a>
<a name="ln10278">      // add the substituted text</a>
<a name="ln10279">      (void)vim_regsub(&amp;regmatch, sub, expr, (char_u *)ga.ga_data</a>
<a name="ln10280">                       + ga.ga_len + i, true, true, false);</a>
<a name="ln10281">      ga.ga_len += i + sublen - 1;</a>
<a name="ln10282">      tail = regmatch.endp[0];</a>
<a name="ln10283">      if (*tail == NUL)</a>
<a name="ln10284">        break;</a>
<a name="ln10285">      if (!do_all)</a>
<a name="ln10286">        break;</a>
<a name="ln10287">    }</a>
<a name="ln10288"> </a>
<a name="ln10289">    if (ga.ga_data != NULL)</a>
<a name="ln10290">      STRCPY((char *)ga.ga_data + ga.ga_len, tail);</a>
<a name="ln10291"> </a>
<a name="ln10292">    vim_regfree(regmatch.regprog);</a>
<a name="ln10293">  }</a>
<a name="ln10294"> </a>
<a name="ln10295">  char_u *ret = vim_strsave(ga.ga_data == NULL ? str : (char_u *)ga.ga_data);</a>
<a name="ln10296">  ga_clear(&amp;ga);</a>
<a name="ln10297">  if (p_cpo == empty_option) {</a>
<a name="ln10298">    p_cpo = save_cpo;</a>
<a name="ln10299">  } else {</a>
<a name="ln10300">    // Darn, evaluating {sub} expression or {expr} changed the value.</a>
<a name="ln10301">    free_string_option(save_cpo);</a>
<a name="ln10302">  }</a>
<a name="ln10303"> </a>
<a name="ln10304">  return ret;</a>
<a name="ln10305">}</a>
<a name="ln10306"> </a>
<a name="ln10307">/// common code for getting job callbacks for jobstart, termopen and rpcstart</a>
<a name="ln10308">///</a>
<a name="ln10309">/// @return true/false on success/failure.</a>
<a name="ln10310">bool common_job_callbacks(dict_T *vopts,</a>
<a name="ln10311">                          CallbackReader *on_stdout,</a>
<a name="ln10312">                          CallbackReader *on_stderr,</a>
<a name="ln10313">                          Callback *on_exit)</a>
<a name="ln10314">{</a>
<a name="ln10315">  if (tv_dict_get_callback(vopts, S_LEN(&quot;on_stdout&quot;), &amp;on_stdout-&gt;cb)</a>
<a name="ln10316">      &amp;&amp;tv_dict_get_callback(vopts, S_LEN(&quot;on_stderr&quot;), &amp;on_stderr-&gt;cb)</a>
<a name="ln10317">      &amp;&amp; tv_dict_get_callback(vopts, S_LEN(&quot;on_exit&quot;), on_exit)) {</a>
<a name="ln10318">    on_stdout-&gt;buffered = tv_dict_get_number(vopts, &quot;stdout_buffered&quot;);</a>
<a name="ln10319">    on_stderr-&gt;buffered = tv_dict_get_number(vopts, &quot;stderr_buffered&quot;);</a>
<a name="ln10320">    if (on_stdout-&gt;buffered &amp;&amp; on_stdout-&gt;cb.type == kCallbackNone) {</a>
<a name="ln10321">      on_stdout-&gt;self = vopts;</a>
<a name="ln10322">    }</a>
<a name="ln10323">    if (on_stderr-&gt;buffered &amp;&amp; on_stderr-&gt;cb.type == kCallbackNone) {</a>
<a name="ln10324">      on_stderr-&gt;self = vopts;</a>
<a name="ln10325">    }</a>
<a name="ln10326">    vopts-&gt;dv_refcount++;</a>
<a name="ln10327">    return true;</a>
<a name="ln10328">  }</a>
<a name="ln10329"> </a>
<a name="ln10330">  callback_reader_free(on_stdout);</a>
<a name="ln10331">  callback_reader_free(on_stderr);</a>
<a name="ln10332">  callback_free(on_exit);</a>
<a name="ln10333">  return false;</a>
<a name="ln10334">}</a>
<a name="ln10335"> </a>
<a name="ln10336"> </a>
<a name="ln10337">Channel *find_job(uint64_t id, bool show_error)</a>
<a name="ln10338">{</a>
<a name="ln10339">  Channel *data = find_channel(id);</a>
<a name="ln10340">  if (!data || data-&gt;streamtype != kChannelStreamProc</a>
<a name="ln10341">      || process_is_stopped(&amp;data-&gt;stream.proc)) {</a>
<a name="ln10342">    if (show_error) {</a>
<a name="ln10343">      if (data &amp;&amp; data-&gt;streamtype != kChannelStreamProc) {</a>
<a name="ln10344">        EMSG(_(e_invchanjob));</a>
<a name="ln10345">      } else {</a>
<a name="ln10346">        EMSG(_(e_invchan));</a>
<a name="ln10347">      }</a>
<a name="ln10348">    }</a>
<a name="ln10349">    return NULL;</a>
<a name="ln10350">  }</a>
<a name="ln10351">  return data;</a>
<a name="ln10352">}</a>
<a name="ln10353"> </a>
<a name="ln10354"> </a>
<a name="ln10355">void script_host_eval(char *name, typval_T *argvars, typval_T *rettv)</a>
<a name="ln10356">{</a>
<a name="ln10357">  if (check_secure()) {</a>
<a name="ln10358">    return;</a>
<a name="ln10359">  }</a>
<a name="ln10360"> </a>
<a name="ln10361">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln10362">    EMSG(_(e_invarg));</a>
<a name="ln10363">    return;</a>
<a name="ln10364">  }</a>
<a name="ln10365"> </a>
<a name="ln10366">  list_T *args = tv_list_alloc(1);</a>
<a name="ln10367">  tv_list_append_string(args, (const char *)argvars[0].vval.v_string, -1);</a>
<a name="ln10368">  *rettv = eval_call_provider(name, &quot;eval&quot;, args, false);</a>
<a name="ln10369">}</a>
<a name="ln10370"> </a>
<a name="ln10371">/// @param discard  Clears the value returned by the provider and returns</a>
<a name="ln10372">///                 an empty typval_T.</a>
<a name="ln10373">typval_T eval_call_provider(char *provider, char *method, list_T *arguments,</a>
<a name="ln10374">                            bool discard)</a>
<a name="ln10375">{</a>
<a name="ln10376">  if (!eval_has_provider(provider)) {</a>
<a name="ln10377">    emsgf(&quot;E319: No \&quot;%s\&quot; provider found. Run \&quot;:checkhealth provider\&quot;&quot;,</a>
<a name="ln10378">          provider);</a>
<a name="ln10379">    return (typval_T){</a>
<a name="ln10380">      .v_type = VAR_NUMBER,</a>
<a name="ln10381">      .v_lock = VAR_UNLOCKED,</a>
<a name="ln10382">      .vval.v_number = (varnumber_T)0</a>
<a name="ln10383">    };</a>
<a name="ln10384">  }</a>
<a name="ln10385"> </a>
<a name="ln10386">  char func[256];</a>
<a name="ln10387">  int name_len = snprintf(func, sizeof(func), &quot;provider#%s#Call&quot;, provider);</a>
<a name="ln10388"> </a>
<a name="ln10389">  // Save caller scope information</a>
<a name="ln10390">  struct caller_scope saved_provider_caller_scope = provider_caller_scope;</a>
<a name="ln10391">  provider_caller_scope = (struct caller_scope) {</a>
<a name="ln10392">    .script_ctx = current_sctx,</a>
<a name="ln10393">    .sourcing_name = sourcing_name,</a>
<a name="ln10394">    .sourcing_lnum = sourcing_lnum,</a>
<a name="ln10395">    .autocmd_fname = autocmd_fname,</a>
<a name="ln10396">    .autocmd_match = autocmd_match,</a>
<a name="ln10397">    .autocmd_bufnr = autocmd_bufnr,</a>
<a name="ln10398">    .funccalp = (void *)get_current_funccal()</a>
<a name="ln10399">  };</a>
<a name="ln10400">  funccal_entry_T funccal_entry;</a>
<a name="ln10401">  save_funccal(&amp;funccal_entry);</a>
<a name="ln10402">  provider_call_nesting++;</a>
<a name="ln10403"> </a>
<a name="ln10404">  typval_T argvars[3] = {</a>
<a name="ln10405">    { .v_type = VAR_STRING, .vval.v_string = (char_u *)method,</a>
<a name="ln10406">      .v_lock = VAR_UNLOCKED },</a>
<a name="ln10407">    { .v_type = VAR_LIST, .vval.v_list = arguments, .v_lock = VAR_UNLOCKED },</a>
<a name="ln10408">    { .v_type = VAR_UNKNOWN }</a>
<a name="ln10409">  };</a>
<a name="ln10410">  typval_T rettv = { .v_type = VAR_UNKNOWN, .v_lock = VAR_UNLOCKED };</a>
<a name="ln10411">  tv_list_ref(arguments);</a>
<a name="ln10412"> </a>
<a name="ln10413">  int dummy;</a>
<a name="ln10414">  (void)call_func((const char_u *)func,</a>
<a name="ln10415">                  name_len,</a>
<a name="ln10416">                  &amp;rettv,</a>
<a name="ln10417">                  2,</a>
<a name="ln10418">                  argvars,</a>
<a name="ln10419">                  NULL,</a>
<a name="ln10420">                  curwin-&gt;w_cursor.lnum,</a>
<a name="ln10421">                  curwin-&gt;w_cursor.lnum,</a>
<a name="ln10422">                  &amp;dummy,</a>
<a name="ln10423">                  true,</a>
<a name="ln10424">                  NULL,</a>
<a name="ln10425">                  NULL);</a>
<a name="ln10426"> </a>
<a name="ln10427">  tv_list_unref(arguments);</a>
<a name="ln10428">  // Restore caller scope information</a>
<a name="ln10429">  restore_funccal();</a>
<a name="ln10430">  provider_caller_scope = saved_provider_caller_scope;</a>
<a name="ln10431">  provider_call_nesting--;</a>
<a name="ln10432">  assert(provider_call_nesting &gt;= 0);</a>
<a name="ln10433"> </a>
<a name="ln10434">  if (discard) {</a>
<a name="ln10435">    tv_clear(&amp;rettv);</a>
<a name="ln10436">  }</a>
<a name="ln10437"> </a>
<a name="ln10438">  return rettv;</a>
<a name="ln10439">}</a>
<a name="ln10440"> </a>
<a name="ln10441">/// Checks if provider for feature `feat` is enabled.</a>
<a name="ln10442">bool eval_has_provider(const char *feat)</a>
<a name="ln10443">{</a>
<a name="ln10444">  if (!strequal(feat, &quot;clipboard&quot;)</a>
<a name="ln10445">      &amp;&amp; !strequal(feat, &quot;python&quot;)</a>
<a name="ln10446">      &amp;&amp; !strequal(feat, &quot;python3&quot;)</a>
<a name="ln10447">      &amp;&amp; !strequal(feat, &quot;python_compiled&quot;)</a>
<a name="ln10448">      &amp;&amp; !strequal(feat, &quot;python_dynamic&quot;)</a>
<a name="ln10449">      &amp;&amp; !strequal(feat, &quot;python3_compiled&quot;)</a>
<a name="ln10450">      &amp;&amp; !strequal(feat, &quot;python3_dynamic&quot;)</a>
<a name="ln10451">      &amp;&amp; !strequal(feat, &quot;perl&quot;)</a>
<a name="ln10452">      &amp;&amp; !strequal(feat, &quot;ruby&quot;)</a>
<a name="ln10453">      &amp;&amp; !strequal(feat, &quot;node&quot;)) {</a>
<a name="ln10454">    // Avoid autoload for non-provider has() features.</a>
<a name="ln10455">    return false;</a>
<a name="ln10456">  }</a>
<a name="ln10457"> </a>
<a name="ln10458">  char name[32];  // Normalized: &quot;python_compiled&quot; =&gt; &quot;python&quot;.</a>
<a name="ln10459">  snprintf(name, sizeof(name), &quot;%s&quot;, feat);</a>
<a name="ln10460">  strchrsub(name, '_', '\0');  // Chop any &quot;_xx&quot; suffix.</a>
<a name="ln10461"> </a>
<a name="ln10462">  char buf[256];</a>
<a name="ln10463">  typval_T tv;</a>
<a name="ln10464">  // Get the g:loaded_xx_provider variable.</a>
<a name="ln10465">  int len = snprintf(buf, sizeof(buf), &quot;g:loaded_%s_provider&quot;, name);</a>
<a name="ln10466">  if (get_var_tv(buf, len, &amp;tv, NULL, false, true) == FAIL) {</a>
<a name="ln10467">    // Trigger autoload once.</a>
<a name="ln10468">    len = snprintf(buf, sizeof(buf), &quot;provider#%s#bogus&quot;, name);</a>
<a name="ln10469">    script_autoload(buf, len, false);</a>
<a name="ln10470"> </a>
<a name="ln10471">    // Retry the (non-autoload-style) variable.</a>
<a name="ln10472">    len = snprintf(buf, sizeof(buf), &quot;g:loaded_%s_provider&quot;, name);</a>
<a name="ln10473">    if (get_var_tv(buf, len, &amp;tv, NULL, false, true) == FAIL) {</a>
<a name="ln10474">      // Show a hint if Call() is defined but g:loaded_xx_provider is missing.</a>
<a name="ln10475">      snprintf(buf, sizeof(buf), &quot;provider#%s#Call&quot;, name);</a>
<a name="ln10476">      if (!!find_func((char_u *)buf) &amp;&amp; p_lpl) {</a>
<a name="ln10477">        emsgf(&quot;provider: %s: missing required variable g:loaded_%s_provider&quot;,</a>
<a name="ln10478">              name, name);</a>
<a name="ln10479">      }</a>
<a name="ln10480">      return false;</a>
<a name="ln10481">    }</a>
<a name="ln10482">  }</a>
<a name="ln10483"> </a>
<a name="ln10484">  bool ok = (tv.v_type == VAR_NUMBER)</a>
<a name="ln10485">    ? 2 == tv.vval.v_number  // Value of 2 means &quot;loaded and working&quot;.</a>
<a name="ln10486">    : false;</a>
<a name="ln10487"> </a>
<a name="ln10488">  if (ok) {</a>
<a name="ln10489">    // Call() must be defined if provider claims to be working.</a>
<a name="ln10490">    snprintf(buf, sizeof(buf), &quot;provider#%s#Call&quot;, name);</a>
<a name="ln10491">    if (!find_func((char_u *)buf)) {</a>
<a name="ln10492">      emsgf(&quot;provider: %s: g:loaded_%s_provider=2 but %s is not defined&quot;,</a>
<a name="ln10493">            name, name, buf);</a>
<a name="ln10494">      ok = false;</a>
<a name="ln10495">    }</a>
<a name="ln10496">  }</a>
<a name="ln10497"> </a>
<a name="ln10498">  return ok;</a>
<a name="ln10499">}</a>
<a name="ln10500"> </a>
<a name="ln10501">/// Writes &quot;&lt;sourcing_name&gt;:&lt;sourcing_lnum&gt;&quot; to `buf[bufsize]`.</a>
<a name="ln10502">void eval_fmt_source_name_line(char *buf, size_t bufsize)</a>
<a name="ln10503">{</a>
<a name="ln10504">  if (sourcing_name) {</a>
<a name="ln10505">    snprintf(buf, bufsize, &quot;%s:%&quot; PRIdLINENR, sourcing_name, sourcing_lnum);</a>
<a name="ln10506">  } else {</a>
<a name="ln10507">    snprintf(buf, bufsize, &quot;?&quot;);</a>
<a name="ln10508">  }</a>
<a name="ln10509">}</a>
<a name="ln10510"> </a>
<a name="ln10511">/// &quot;:checkhealth [plugins]&quot;</a>
<a name="ln10512">void ex_checkhealth(exarg_T *eap)</a>
<a name="ln10513">{</a>
<a name="ln10514">  bool found = !!find_func((char_u *)&quot;health#check&quot;);</a>
<a name="ln10515">  if (!found</a>
<a name="ln10516">      &amp;&amp; script_autoload(&quot;health#check&quot;, sizeof(&quot;health#check&quot;) - 1, false)) {</a>
<a name="ln10517">    found = !!find_func((char_u *)&quot;health#check&quot;);</a>
<a name="ln10518">  }</a>
<a name="ln10519">  if (!found) {</a>
<a name="ln10520">    const char *vimruntime_env = os_getenv(&quot;VIMRUNTIME&quot;);</a>
<a name="ln10521">    if (vimruntime_env == NULL) {</a>
<a name="ln10522">      EMSG(_(&quot;E5009: $VIMRUNTIME is empty or unset&quot;));</a>
<a name="ln10523">    } else {</a>
<a name="ln10524">      bool rtp_ok = NULL != strstr((char *)p_rtp, vimruntime_env);</a>
<a name="ln10525">      if (rtp_ok) {</a>
<a name="ln10526">        EMSG2(_(&quot;E5009: Invalid $VIMRUNTIME: %s&quot;), vimruntime_env);</a>
<a name="ln10527">      } else {</a>
<a name="ln10528">        EMSG(_(&quot;E5009: Invalid 'runtimepath'&quot;));</a>
<a name="ln10529">      }</a>
<a name="ln10530">    }</a>
<a name="ln10531">    return;</a>
<a name="ln10532">  }</a>
<a name="ln10533"> </a>
<a name="ln10534">  size_t bufsize = STRLEN(eap-&gt;arg) + sizeof(&quot;call health#check('')&quot;);</a>
<a name="ln10535">  char *buf = xmalloc(bufsize);</a>
<a name="ln10536">  snprintf(buf, bufsize, &quot;call health#check('%s')&quot;, eap-&gt;arg);</a>
<a name="ln10537"> </a>
<a name="ln10538">  do_cmdline_cmd(buf);</a>
<a name="ln10539"> </a>
<a name="ln10540">  xfree(buf);</a>
<a name="ln10541">}</a>
<a name="ln10542"> </a>
<a name="ln10543">void invoke_prompt_callback(void)</a>
<a name="ln10544">{</a>
<a name="ln10545">    typval_T rettv;</a>
<a name="ln10546">    typval_T argv[2];</a>
<a name="ln10547">    char_u *text;</a>
<a name="ln10548">    char_u *prompt;</a>
<a name="ln10549">    linenr_T lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln10550"> </a>
<a name="ln10551">    // Add a new line for the prompt before invoking the callback, so that</a>
<a name="ln10552">    // text can always be inserted above the last line.</a>
<a name="ln10553">    ml_append(lnum, (char_u  *)&quot;&quot;, 0, false);</a>
<a name="ln10554">    curwin-&gt;w_cursor.lnum = lnum + 1;</a>
<a name="ln10555">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln10556"> </a>
<a name="ln10557">    if (curbuf-&gt;b_prompt_callback.type == kCallbackNone) {</a>
<a name="ln10558">      return;</a>
<a name="ln10559">    }</a>
<a name="ln10560">    text = ml_get(lnum);</a>
<a name="ln10561">    prompt = prompt_text();</a>
<a name="ln10562">    if (STRLEN(text) &gt;= STRLEN(prompt)) {</a>
<a name="ln10563">      text += STRLEN(prompt);</a>
<a name="ln10564">    }</a>
<a name="ln10565">    argv[0].v_type = VAR_STRING;</a>
<a name="ln10566">    argv[0].vval.v_string = vim_strsave(text);</a>
<a name="ln10567">    argv[1].v_type = VAR_UNKNOWN;</a>
<a name="ln10568"> </a>
<a name="ln10569">    callback_call(&amp;curbuf-&gt;b_prompt_callback, 1, argv, &amp;rettv);</a>
<a name="ln10570">    tv_clear(&amp;argv[0]);</a>
<a name="ln10571">    tv_clear(&amp;rettv);</a>
<a name="ln10572">}</a>
<a name="ln10573"> </a>
<a name="ln10574">// Return true When the interrupt callback was invoked.</a>
<a name="ln10575">bool invoke_prompt_interrupt(void)</a>
<a name="ln10576">{</a>
<a name="ln10577">    typval_T rettv;</a>
<a name="ln10578">    typval_T argv[1];</a>
<a name="ln10579"> </a>
<a name="ln10580">    if (curbuf-&gt;b_prompt_interrupt.type == kCallbackNone) {</a>
<a name="ln10581">      return false;</a>
<a name="ln10582">    }</a>
<a name="ln10583">    argv[0].v_type = VAR_UNKNOWN;</a>
<a name="ln10584"> </a>
<a name="ln10585">    got_int = false;  // don't skip executing commands</a>
<a name="ln10586">    callback_call(&amp;curbuf-&gt;b_prompt_interrupt, 0, argv, &amp;rettv);</a>
<a name="ln10587">    tv_clear(&amp;rettv);</a>
<a name="ln10588">    return true;</a>
<a name="ln10589">}</a>
<a name="ln10590"> </a>
<a name="ln10591">// Compare &quot;typ1&quot; and &quot;typ2&quot;.  Put the result in &quot;typ1&quot;.</a>
<a name="ln10592">int typval_compare(</a>
<a name="ln10593">    typval_T *typ1,   // first operand</a>
<a name="ln10594">    typval_T *typ2,   // second operand</a>
<a name="ln10595">    exprtype_T type,  // operator</a>
<a name="ln10596">    bool ic           // ignore case</a>
<a name="ln10597">)</a>
<a name="ln10598">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln10599">{</a>
<a name="ln10600">  varnumber_T n1, n2;</a>
<a name="ln10601">  const bool type_is = type == EXPR_IS || type == EXPR_ISNOT;</a>
<a name="ln10602"> </a>
<a name="ln10603">  if (type_is &amp;&amp; typ1-&gt;v_type != typ2-&gt;v_type) {</a>
<a name="ln10604">    // For &quot;is&quot; a different type always means false, for &quot;notis&quot;</a>
<a name="ln10605">    // it means true.</a>
<a name="ln10606">    n1 = type == EXPR_ISNOT;</a>
<a name="ln10607">  } else if (typ1-&gt;v_type == VAR_LIST || typ2-&gt;v_type == VAR_LIST) {</a>
<a name="ln10608">    if (type_is) {</a>
<a name="ln10609">      n1 = typ1-&gt;v_type == typ2-&gt;v_type</a>
<a name="ln10610">        &amp;&amp; typ1-&gt;vval.v_list == typ2-&gt;vval.v_list;</a>
<a name="ln10611">      if (type == EXPR_ISNOT) {</a>
<a name="ln10612">        n1 = !n1;</a>
<a name="ln10613">      }</a>
<a name="ln10614">    } else if (typ1-&gt;v_type != typ2-&gt;v_type</a>
<a name="ln10615">               || (type != EXPR_EQUAL &amp;&amp; type != EXPR_NEQUAL)) {</a>
<a name="ln10616">      if (typ1-&gt;v_type != typ2-&gt;v_type) {</a>
<a name="ln10617">        EMSG(_(&quot;E691: Can only compare List with List&quot;));</a>
<a name="ln10618">      } else {</a>
<a name="ln10619">        EMSG(_(&quot;E692: Invalid operation for List&quot;));</a>
<a name="ln10620">      }</a>
<a name="ln10621">      tv_clear(typ1);</a>
<a name="ln10622">      return FAIL;</a>
<a name="ln10623">    } else {</a>
<a name="ln10624">      // Compare two Lists for being equal or unequal.</a>
<a name="ln10625">      n1 = tv_list_equal(typ1-&gt;vval.v_list, typ2-&gt;vval.v_list, ic, false);</a>
<a name="ln10626">      if (type == EXPR_NEQUAL) {</a>
<a name="ln10627">        n1 = !n1;</a>
<a name="ln10628">      }</a>
<a name="ln10629">    }</a>
<a name="ln10630">  } else if (typ1-&gt;v_type == VAR_DICT || typ2-&gt;v_type == VAR_DICT) {</a>
<a name="ln10631">    if (type_is) {</a>
<a name="ln10632">      n1 = typ1-&gt;v_type == typ2-&gt;v_type</a>
<a name="ln10633">        &amp;&amp; typ1-&gt;vval.v_dict == typ2-&gt;vval.v_dict;</a>
<a name="ln10634">      if (type == EXPR_ISNOT) {</a>
<a name="ln10635">        n1 = !n1;</a>
<a name="ln10636">      }</a>
<a name="ln10637">    } else if (typ1-&gt;v_type != typ2-&gt;v_type</a>
<a name="ln10638">               || (type != EXPR_EQUAL &amp;&amp; type != EXPR_NEQUAL)) {</a>
<a name="ln10639">      if (typ1-&gt;v_type != typ2-&gt;v_type) {</a>
<a name="ln10640">        EMSG(_(&quot;E735: Can only compare Dictionary with Dictionary&quot;));</a>
<a name="ln10641">      } else {</a>
<a name="ln10642">        EMSG(_(&quot;E736: Invalid operation for Dictionary&quot;));</a>
<a name="ln10643">      }</a>
<a name="ln10644">      tv_clear(typ1);</a>
<a name="ln10645">      return FAIL;</a>
<a name="ln10646">    } else {</a>
<a name="ln10647">      // Compare two Dictionaries for being equal or unequal.</a>
<a name="ln10648">      n1 = tv_dict_equal(typ1-&gt;vval.v_dict, typ2-&gt;vval.v_dict, ic, false);</a>
<a name="ln10649">      if (type == EXPR_NEQUAL) {</a>
<a name="ln10650">        n1 = !n1;</a>
<a name="ln10651">      }</a>
<a name="ln10652">    }</a>
<a name="ln10653">  } else if (tv_is_func(*typ1) || tv_is_func(*typ2)) {</a>
<a name="ln10654">    if (type != EXPR_EQUAL &amp;&amp; type != EXPR_NEQUAL</a>
<a name="ln10655">        &amp;&amp; type != EXPR_IS &amp;&amp; type != EXPR_ISNOT) {</a>
<a name="ln10656">      EMSG(_(&quot;E694: Invalid operation for Funcrefs&quot;));</a>
<a name="ln10657">      tv_clear(typ1);</a>
<a name="ln10658">      return FAIL;</a>
<a name="ln10659">    }</a>
<a name="ln10660">    if ((typ1-&gt;v_type == VAR_PARTIAL &amp;&amp; typ1-&gt;vval.v_partial == NULL)</a>
<a name="ln10661">        || (typ2-&gt;v_type == VAR_PARTIAL &amp;&amp; typ2-&gt;vval.v_partial == NULL)) {</a>
<a name="ln10662">      // when a partial is NULL assume not equal</a>
<a name="ln10663">      n1 = false;</a>
<a name="ln10664">    } else if (type_is) {</a>
<a name="ln10665">      if (typ1-&gt;v_type == VAR_FUNC &amp;&amp; typ2-&gt;v_type == VAR_FUNC) {</a>
<a name="ln10666">        // strings are considered the same if their value is</a>
<a name="ln10667">        // the same</a>
<a name="ln10668">        n1 = tv_equal(typ1, typ2, ic, false);</a>
<a name="ln10669">      } else if (typ1-&gt;v_type == VAR_PARTIAL &amp;&amp; typ2-&gt;v_type == VAR_PARTIAL) {</a>
<a name="ln10670">        n1 = typ1-&gt;vval.v_partial == typ2-&gt;vval.v_partial;</a>
<a name="ln10671">      } else {</a>
<a name="ln10672">        n1 = false;</a>
<a name="ln10673">      }</a>
<a name="ln10674">    } else {</a>
<a name="ln10675">      n1 = tv_equal(typ1, typ2, ic, false);</a>
<a name="ln10676">    }</a>
<a name="ln10677">    if (type == EXPR_NEQUAL || type == EXPR_ISNOT) {</a>
<a name="ln10678">      n1 = !n1;</a>
<a name="ln10679">    }</a>
<a name="ln10680">  } else if ((typ1-&gt;v_type == VAR_FLOAT || typ2-&gt;v_type == VAR_FLOAT)</a>
<a name="ln10681">             &amp;&amp; type != EXPR_MATCH &amp;&amp; type != EXPR_NOMATCH) {</a>
<a name="ln10682">    // If one of the two variables is a float, compare as a float.</a>
<a name="ln10683">    // When using &quot;=~&quot; or &quot;!~&quot;, always compare as string.</a>
<a name="ln10684">    const float_T f1 = tv_get_float(typ1);</a>
<a name="ln10685">    const float_T f2 = tv_get_float(typ2);</a>
<a name="ln10686">    n1 = false;</a>
<a name="ln10687">    switch (type) {</a>
<a name="ln10688">      case EXPR_IS:</a>
<a name="ln10689">      case EXPR_EQUAL:    n1 = f1 == f2; break;</a>
<a name="ln10690">      case EXPR_ISNOT:</a>
<a name="ln10691">      case EXPR_NEQUAL:   n1 = f1 != f2; break;</a>
<a name="ln10692">      case EXPR_GREATER:  n1 = f1 &gt; f2; break;</a>
<a name="ln10693">      case EXPR_GEQUAL:   n1 = f1 &gt;= f2; break;</a>
<a name="ln10694">      case EXPR_SMALLER:  n1 = f1 &lt; f2; break;</a>
<a name="ln10695">      case EXPR_SEQUAL:   n1 = f1 &lt;= f2; break;</a>
<a name="ln10696">      case EXPR_UNKNOWN:</a>
<a name="ln10697">      case EXPR_MATCH:</a>
<a name="ln10698">      case EXPR_NOMATCH:  break;  // avoid gcc warning</a>
<a name="ln10699">    }</a>
<a name="ln10700">  } else if ((typ1-&gt;v_type == VAR_NUMBER || typ2-&gt;v_type == VAR_NUMBER)</a>
<a name="ln10701">             &amp;&amp; type != EXPR_MATCH &amp;&amp; type != EXPR_NOMATCH) {</a>
<a name="ln10702">    // If one of the two variables is a number, compare as a number.</a>
<a name="ln10703">    // When using &quot;=~&quot; or &quot;!~&quot;, always compare as string.</a>
<a name="ln10704">    n1 = tv_get_number(typ1);</a>
<a name="ln10705">    n2 = tv_get_number(typ2);</a>
<a name="ln10706">    switch (type) {</a>
<a name="ln10707">      case EXPR_IS:</a>
<a name="ln10708">      case EXPR_EQUAL:    n1 = n1 == n2; break;</a>
<a name="ln10709">      case EXPR_ISNOT:</a>
<a name="ln10710">      case EXPR_NEQUAL:   n1 = n1 != n2; break;</a>
<a name="ln10711">      case EXPR_GREATER:  n1 = n1 &gt; n2; break;</a>
<a name="ln10712">      case EXPR_GEQUAL:   n1 = n1 &gt;= n2; break;</a>
<a name="ln10713">      case EXPR_SMALLER:  n1 = n1 &lt; n2; break;</a>
<a name="ln10714">      case EXPR_SEQUAL:   n1 = n1 &lt;= n2; break;</a>
<a name="ln10715">      case EXPR_UNKNOWN:</a>
<a name="ln10716">      case EXPR_MATCH:</a>
<a name="ln10717">      case EXPR_NOMATCH:  break;  // avoid gcc warning</a>
<a name="ln10718">    }</a>
<a name="ln10719">  } else {</a>
<a name="ln10720">    char buf1[NUMBUFLEN];</a>
<a name="ln10721">    char buf2[NUMBUFLEN];</a>
<a name="ln10722">    const char *const s1 = tv_get_string_buf(typ1, buf1);</a>
<a name="ln10723">    const char *const s2 = tv_get_string_buf(typ2, buf2);</a>
<a name="ln10724">    int i;</a>
<a name="ln10725">    if (type != EXPR_MATCH &amp;&amp; type != EXPR_NOMATCH) {</a>
<a name="ln10726">      i = mb_strcmp_ic(ic, s1, s2);</a>
<a name="ln10727">    } else {</a>
<a name="ln10728">      i = 0;</a>
<a name="ln10729">    }</a>
<a name="ln10730">    n1 = false;</a>
<a name="ln10731">    switch (type) {</a>
<a name="ln10732">      case EXPR_IS:</a>
<a name="ln10733">      case EXPR_EQUAL:    n1 = i == 0; break;</a>
<a name="ln10734">      case EXPR_ISNOT:</a>
<a name="ln10735">      case EXPR_NEQUAL:   n1 = i != 0; break;</a>
<a name="ln10736">      case EXPR_GREATER:  n1 = i &gt; 0; break;</a>
<a name="ln10737">      case EXPR_GEQUAL:   n1 = i &gt;= 0; break;</a>
<a name="ln10738">      case EXPR_SMALLER:  n1 = i &lt; 0; break;</a>
<a name="ln10739">      case EXPR_SEQUAL:   n1 = i &lt;= 0; break;</a>
<a name="ln10740"> </a>
<a name="ln10741">      case EXPR_MATCH:</a>
<a name="ln10742">      case EXPR_NOMATCH:</a>
<a name="ln10743">        n1 = pattern_match((char_u *)s2, (char_u *)s1, ic);</a>
<a name="ln10744">        if (type == EXPR_NOMATCH) {</a>
<a name="ln10745">          n1 = !n1;</a>
<a name="ln10746">        }</a>
<a name="ln10747">        break;</a>
<a name="ln10748">      case EXPR_UNKNOWN:  break;  // avoid gcc warning</a>
<a name="ln10749">    }</a>
<a name="ln10750">  }</a>
<a name="ln10751">  tv_clear(typ1);</a>
<a name="ln10752">  typ1-&gt;v_type = VAR_NUMBER;</a>
<a name="ln10753">  typ1-&gt;vval.v_number = n1;</a>
<a name="ln10754">  return OK;</a>
<a name="ln10755">}</a>
<a name="ln10756"> </a>
<a name="ln10757">char *typval_tostring(typval_T *arg)</a>
<a name="ln10758">{</a>
<a name="ln10759">  if (arg == NULL) {</a>
<a name="ln10760">    return xstrdup(&quot;(does not exist)&quot;);</a>
<a name="ln10761">  }</a>
<a name="ln10762">  return encode_tv2string(arg, NULL);</a>
<a name="ln10763">}</a>
<a name="ln10764"> </a>
<a name="ln10765">bool var_exists(const char *var)</a>
<a name="ln10766">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln10767">{</a>
<a name="ln10768">  char *tofree;</a>
<a name="ln10769">  bool n = false;</a>
<a name="ln10770"> </a>
<a name="ln10771">  // get_name_len() takes care of expanding curly braces</a>
<a name="ln10772">  const char *name = var;</a>
<a name="ln10773">  const int len = get_name_len((const char **)&amp;var, &amp;tofree, true, false);</a>
<a name="ln10774">  if (len &gt; 0) {</a>
<a name="ln10775">    typval_T tv;</a>
<a name="ln10776"> </a>
<a name="ln10777">    if (tofree != NULL) {</a>
<a name="ln10778">      name = tofree;</a>
<a name="ln10779">    }</a>
<a name="ln10780">    n = get_var_tv(name, len, &amp;tv, NULL, false, true) == OK;</a>
<a name="ln10781">    if (n) {</a>
<a name="ln10782">      // Handle d.key, l[idx], f(expr).</a>
<a name="ln10783">      n = handle_subscript(&amp;var, &amp;tv, true, false) == OK;</a>
<a name="ln10784">      if (n) {</a>
<a name="ln10785">        tv_clear(&amp;tv);</a>
<a name="ln10786">      }</a>
<a name="ln10787">    }</a>
<a name="ln10788">  }</a>
<a name="ln10789">  if (*var != NUL) {</a>
<a name="ln10790">    n = false;</a>
<a name="ln10791">  }</a>
<a name="ln10792"> </a>
<a name="ln10793">  xfree(tofree);</a>
<a name="ln10794">  return n;</a>
<a name="ln10795">}</a>

</code></pre>
<div class="balloon" rel="5749"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'vim_snprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="5749"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'vim_snprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="6119"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'trans_name' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
