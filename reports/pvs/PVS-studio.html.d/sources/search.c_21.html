
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>search.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * search.c: code for normal mode searching commands</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;inttypes.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12">#include &lt;limits.h&gt;             /* for INT_MAX on MSVC */</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln15">#include &quot;nvim/vim.h&quot;</a>
<a name="ln16">#include &quot;nvim/search.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln18">#include &quot;nvim/charset.h&quot;</a>
<a name="ln19">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln20">#include &quot;nvim/edit.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval.h&quot;</a>
<a name="ln22">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln23">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln25">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln26">#include &quot;nvim/fold.h&quot;</a>
<a name="ln27">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln28">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln29">#include &quot;nvim/indent.h&quot;</a>
<a name="ln30">#include &quot;nvim/main.h&quot;</a>
<a name="ln31">#include &quot;nvim/mark.h&quot;</a>
<a name="ln32">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln33">#include &quot;nvim/memline.h&quot;</a>
<a name="ln34">#include &quot;nvim/memory.h&quot;</a>
<a name="ln35">#include &quot;nvim/message.h&quot;</a>
<a name="ln36">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln37">#include &quot;nvim/move.h&quot;</a>
<a name="ln38">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln39">#include &quot;nvim/normal.h&quot;</a>
<a name="ln40">#include &quot;nvim/option.h&quot;</a>
<a name="ln41">#include &quot;nvim/path.h&quot;</a>
<a name="ln42">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln43">#include &quot;nvim/screen.h&quot;</a>
<a name="ln44">#include &quot;nvim/strings.h&quot;</a>
<a name="ln45">#include &quot;nvim/ui.h&quot;</a>
<a name="ln46">#include &quot;nvim/window.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln50"># include &quot;search.c.generated.h&quot;</a>
<a name="ln51">#endif</a>
<a name="ln52"> </a>
<a name="ln53">//  This file contains various searching-related routines. These fall into</a>
<a name="ln54">//  three groups:</a>
<a name="ln55">//  1. string searches (for /, ?, n, and N)</a>
<a name="ln56">//  2. character searches within a single line (for f, F, t, T, etc)</a>
<a name="ln57">//  3. &quot;other&quot; kinds of searches like the '%' command, and 'word' searches.</a>
<a name="ln58">//</a>
<a name="ln59">//</a>
<a name="ln60">//  String searches</a>
<a name="ln61">//</a>
<a name="ln62">//  The string search functions are divided into two levels:</a>
<a name="ln63">//  lowest:  searchit(); uses a pos_T for starting position and found match.</a>
<a name="ln64">//  Highest: do_search(); uses curwin-&gt;w_cursor; calls searchit().</a>
<a name="ln65">//</a>
<a name="ln66">//  The last search pattern is remembered for repeating the same search.</a>
<a name="ln67">//  This pattern is shared between the :g, :s, ? and / commands.</a>
<a name="ln68">//  This is in search_regcomp().</a>
<a name="ln69">//</a>
<a name="ln70">//  The actual string matching is done using a heavily modified version of</a>
<a name="ln71">//  Henry Spencer's regular expression library.  See regexp.c.</a>
<a name="ln72">//</a>
<a name="ln73">//</a>
<a name="ln74">//</a>
<a name="ln75">// Two search patterns are remembered: One for the :substitute command and</a>
<a name="ln76">// one for other searches.  last_idx points to the one that was used the last</a>
<a name="ln77">// time.</a>
<a name="ln78"> </a>
<a name="ln79">static struct spat spats[2] =</a>
<a name="ln80">{</a>
<a name="ln81">  // Last used search pattern</a>
<a name="ln82">  [0] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL},</a>
<a name="ln83">  // Last used substitute pattern</a>
<a name="ln84">  [1] = {NULL, true, false, 0, {'/', false, false, 0L}, NULL}</a>
<a name="ln85">};</a>
<a name="ln86"> </a>
<a name="ln87">static int last_idx = 0;        /* index in spats[] for RE_LAST */</a>
<a name="ln88"> </a>
<a name="ln89">static char_u lastc[2] = { NUL, NUL };    // last character searched for</a>
<a name="ln90">static Direction lastcdir = FORWARD;      // last direction of character search</a>
<a name="ln91">static int last_t_cmd = true;             // last search t_cmd</a>
<a name="ln92">static char_u lastc_bytes[MB_MAXBYTES + 1];</a>
<a name="ln93">static int lastc_bytelen = 1;             // &gt;1 for multi-byte char</a>
<a name="ln94"> </a>
<a name="ln95">// copy of spats[], for keeping the search patterns while executing autocmds</a>
<a name="ln96">static struct spat saved_spats[2];</a>
<a name="ln97">static int saved_spats_last_idx = 0;</a>
<a name="ln98">static bool saved_spats_no_hlsearch = false;</a>
<a name="ln99"> </a>
<a name="ln100">static char_u       *mr_pattern = NULL;    // pattern used by search_regcomp()</a>
<a name="ln101">static int mr_pattern_alloced = false;     // mr_pattern was allocated</a>
<a name="ln102"> </a>
<a name="ln103">/*</a>
<a name="ln104"> * Type used by find_pattern_in_path() to remember which included files have</a>
<a name="ln105"> * been searched already.</a>
<a name="ln106"> */</a>
<a name="ln107">typedef struct SearchedFile {</a>
<a name="ln108">  FILE        *fp;              /* File pointer */</a>
<a name="ln109">  char_u      *name;            /* Full name of file */</a>
<a name="ln110">  linenr_T lnum;                /* Line we were up to in file */</a>
<a name="ln111">  int matched;                  /* Found a match in this file */</a>
<a name="ln112">} SearchedFile;</a>
<a name="ln113"> </a>
<a name="ln114">/*</a>
<a name="ln115"> * translate search pattern for vim_regcomp()</a>
<a name="ln116"> *</a>
<a name="ln117"> * pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)</a>
<a name="ln118"> * pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)</a>
<a name="ln119"> * pat_save == RE_BOTH: save pat in both patterns (:global command)</a>
<a name="ln120"> * pat_use  == RE_SEARCH: use previous search pattern if &quot;pat&quot; is NULL</a>
<a name="ln121"> * pat_use  == RE_SUBST: use previous substitute pattern if &quot;pat&quot; is NULL</a>
<a name="ln122"> * pat_use  == RE_LAST: use last used pattern if &quot;pat&quot; is NULL</a>
<a name="ln123"> * options &amp; SEARCH_HIS: put search string in history</a>
<a name="ln124"> * options &amp; SEARCH_KEEP: keep previous search pattern</a>
<a name="ln125"> *</a>
<a name="ln126"> * returns FAIL if failed, OK otherwise.</a>
<a name="ln127"> */</a>
<a name="ln128">int</a>
<a name="ln129">search_regcomp(</a>
<a name="ln130">    char_u *pat,</a>
<a name="ln131">    int pat_save,</a>
<a name="ln132">    int pat_use,</a>
<a name="ln133">    int options,</a>
<a name="ln134">    regmmatch_T *regmatch          /* return: pattern and ignore-case flag */</a>
<a name="ln135">)</a>
<a name="ln136">{</a>
<a name="ln137">  int magic;</a>
<a name="ln138">  int i;</a>
<a name="ln139"> </a>
<a name="ln140">  rc_did_emsg = FALSE;</a>
<a name="ln141">  magic = p_magic;</a>
<a name="ln142"> </a>
<a name="ln143">  /*</a>
<a name="ln144">   * If no pattern given, use a previously defined pattern.</a>
<a name="ln145">   */</a>
<a name="ln146">  if (pat == NULL || *pat == NUL) {</a>
<a name="ln147">    if (pat_use == RE_LAST)</a>
<a name="ln148">      i = last_idx;</a>
<a name="ln149">    else</a>
<a name="ln150">      i = pat_use;</a>
<a name="ln151">    if (spats[i].pat == NULL) {         /* pattern was never defined */</a>
<a name="ln152">      if (pat_use == RE_SUBST)</a>
<a name="ln153">        EMSG(_(e_nopresub));</a>
<a name="ln154">      else</a>
<a name="ln155">        EMSG(_(e_noprevre));</a>
<a name="ln156">      rc_did_emsg = TRUE;</a>
<a name="ln157">      return FAIL;</a>
<a name="ln158">    }</a>
<a name="ln159">    pat = spats[i].pat;</a>
<a name="ln160">    magic = spats[i].magic;</a>
<a name="ln161">    no_smartcase = spats[i].no_scs;</a>
<a name="ln162">  } else if (options &amp; SEARCH_HIS)      /* put new pattern in history */</a>
<a name="ln163">    add_to_history(HIST_SEARCH, pat, TRUE, NUL);</a>
<a name="ln164"> </a>
<a name="ln165">  if (mr_pattern_alloced) {</a>
<a name="ln166">    xfree(mr_pattern);</a>
<a name="ln167">    mr_pattern_alloced = FALSE;</a>
<a name="ln168">  }</a>
<a name="ln169"> </a>
<a name="ln170">  if (curwin-&gt;w_p_rl &amp;&amp; *curwin-&gt;w_p_rlc == 's') {</a>
<a name="ln171">    mr_pattern = reverse_text(pat);</a>
<a name="ln172">    mr_pattern_alloced = TRUE;</a>
<a name="ln173">  } else</a>
<a name="ln174">    mr_pattern = pat;</a>
<a name="ln175"> </a>
<a name="ln176">  /*</a>
<a name="ln177">   * Save the currently used pattern in the appropriate place,</a>
<a name="ln178">   * unless the pattern should not be remembered.</a>
<a name="ln179">   */</a>
<a name="ln180">  if (!(options &amp; SEARCH_KEEP) &amp;&amp; !cmdmod.keeppatterns) {</a>
<a name="ln181">    /* search or global command */</a>
<a name="ln182">    if (pat_save == RE_SEARCH || pat_save == RE_BOTH)</a>
<a name="ln183">      save_re_pat(RE_SEARCH, pat, magic);</a>
<a name="ln184">    /* substitute or global command */</a>
<a name="ln185">    if (pat_save == RE_SUBST || pat_save == RE_BOTH)</a>
<a name="ln186">      save_re_pat(RE_SUBST, pat, magic);</a>
<a name="ln187">  }</a>
<a name="ln188"> </a>
<a name="ln189">  regmatch-&gt;rmm_ic = ignorecase(pat);</a>
<a name="ln190">  regmatch-&gt;rmm_maxcol = 0;</a>
<a name="ln191">  regmatch-&gt;regprog = vim_regcomp(pat, magic ? RE_MAGIC : 0);</a>
<a name="ln192">  if (regmatch-&gt;regprog == NULL)</a>
<a name="ln193">    return FAIL;</a>
<a name="ln194">  return OK;</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">/*</a>
<a name="ln198"> * Get search pattern used by search_regcomp().</a>
<a name="ln199"> */</a>
<a name="ln200">char_u *get_search_pat(void)</a>
<a name="ln201">{</a>
<a name="ln202">  return mr_pattern;</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">/*</a>
<a name="ln206"> * Reverse text into allocated memory.</a>
<a name="ln207"> * Returns the allocated string.</a>
<a name="ln208"> *</a>
<a name="ln209"> * TODO(philix): move reverse_text() to strings.c</a>
<a name="ln210"> */</a>
<a name="ln211">char_u *reverse_text(char_u *s) FUNC_ATTR_NONNULL_RET</a>
<a name="ln212">{</a>
<a name="ln213">  /*</a>
<a name="ln214">   * Reverse the pattern.</a>
<a name="ln215">   */</a>
<a name="ln216">  size_t len = STRLEN(s);</a>
<a name="ln217">  char_u *rev = xmalloc(len + 1);</a>
<a name="ln218">  size_t rev_i = len;</a>
<a name="ln219">  for (size_t s_i = 0; s_i &lt; len; s_i++) {</a>
<a name="ln220">    const int mb_len = utfc_ptr2len(s + s_i);</a>
<a name="ln221">    rev_i -= mb_len;</a>
<a name="ln222">    memmove(rev + rev_i, s + s_i, mb_len);</a>
<a name="ln223">    s_i += mb_len - 1;</a>
<a name="ln224">  }</a>
<a name="ln225">  rev[len] = NUL;</a>
<a name="ln226"> </a>
<a name="ln227">  return rev;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">void save_re_pat(int idx, char_u *pat, int magic)</a>
<a name="ln231">{</a>
<a name="ln232">  if (spats[idx].pat != pat) {</a>
<a name="ln233">    free_spat(&amp;spats[idx]);</a>
<a name="ln234">    spats[idx].pat = vim_strsave(pat);</a>
<a name="ln235">    spats[idx].magic = magic;</a>
<a name="ln236">    spats[idx].no_scs = no_smartcase;</a>
<a name="ln237">    spats[idx].timestamp = os_time();</a>
<a name="ln238">    spats[idx].additional_data = NULL;</a>
<a name="ln239">    last_idx = idx;</a>
<a name="ln240">    /* If 'hlsearch' set and search pat changed: need redraw. */</a>
<a name="ln241">    if (p_hls)</a>
<a name="ln242">      redraw_all_later(SOME_VALID);</a>
<a name="ln243">    set_no_hlsearch(false);</a>
<a name="ln244">  }</a>
<a name="ln245">}</a>
<a name="ln246"> </a>
<a name="ln247">/*</a>
<a name="ln248"> * Save the search patterns, so they can be restored later.</a>
<a name="ln249"> * Used before/after executing autocommands and user functions.</a>
<a name="ln250"> */</a>
<a name="ln251">static int save_level = 0;</a>
<a name="ln252"> </a>
<a name="ln253">void save_search_patterns(void)</a>
<a name="ln254">{</a>
<a name="ln255">  if (save_level++ == 0) {</a>
<a name="ln256">    saved_spats[0] = spats[0];</a>
<a name="ln257">    if (spats[0].pat != NULL)</a>
<a name="ln258">      saved_spats[0].pat = vim_strsave(spats[0].pat);</a>
<a name="ln259">    saved_spats[1] = spats[1];</a>
<a name="ln260">    if (spats[1].pat != NULL)</a>
<a name="ln261">      saved_spats[1].pat = vim_strsave(spats[1].pat);</a>
<a name="ln262">    saved_spats_last_idx = last_idx;</a>
<a name="ln263">    saved_spats_no_hlsearch = no_hlsearch;</a>
<a name="ln264">  }</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">void restore_search_patterns(void)</a>
<a name="ln268">{</a>
<a name="ln269">  if (--save_level == 0) {</a>
<a name="ln270">    free_spat(&amp;spats[0]);</a>
<a name="ln271">    spats[0] = saved_spats[0];</a>
<a name="ln272">    set_vv_searchforward();</a>
<a name="ln273">    free_spat(&amp;spats[1]);</a>
<a name="ln274">    spats[1] = saved_spats[1];</a>
<a name="ln275">    last_idx = saved_spats_last_idx;</a>
<a name="ln276">    set_no_hlsearch(saved_spats_no_hlsearch);</a>
<a name="ln277">  }</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">static inline void free_spat(struct spat *const spat)</a>
<a name="ln281">{</a>
<a name="ln282">  xfree(spat-&gt;pat);</a>
<a name="ln283">  tv_dict_unref(spat-&gt;additional_data);</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">#if defined(EXITFREE)</a>
<a name="ln287">void free_search_patterns(void)</a>
<a name="ln288">{</a>
<a name="ln289">  free_spat(&amp;spats[0]);</a>
<a name="ln290">  free_spat(&amp;spats[1]);</a>
<a name="ln291"> </a>
<a name="ln292">  memset(spats, 0, sizeof(spats));</a>
<a name="ln293"> </a>
<a name="ln294">  if (mr_pattern_alloced) {</a>
<a name="ln295">    xfree(mr_pattern);</a>
<a name="ln296">    mr_pattern_alloced = FALSE;</a>
<a name="ln297">    mr_pattern = NULL;</a>
<a name="ln298">  }</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">#endif</a>
<a name="ln302"> </a>
<a name="ln303">// copy of spats[RE_SEARCH], for keeping the search patterns while incremental</a>
<a name="ln304">// searching</a>
<a name="ln305">static struct spat saved_last_search_spat;</a>
<a name="ln306">static int did_save_last_search_spat = 0;</a>
<a name="ln307">static int saved_last_idx = 0;</a>
<a name="ln308">static bool saved_no_hlsearch = false;</a>
<a name="ln309"> </a>
<a name="ln310">/// Save and restore the search pattern for incremental highlight search</a>
<a name="ln311">/// feature.</a>
<a name="ln312">///</a>
<a name="ln313">/// It's similar to but different from save_search_patterns() and</a>
<a name="ln314">/// restore_search_patterns(), because the search pattern must be restored when</a>
<a name="ln315">/// cancelling incremental searching even if it's called inside user functions.</a>
<a name="ln316">void save_last_search_pattern(void)</a>
<a name="ln317">{</a>
<a name="ln318">  if (++did_save_last_search_spat != 1) {</a>
<a name="ln319">    // nested call, nothing to do</a>
<a name="ln320">    return;</a>
<a name="ln321">  }</a>
<a name="ln322"> </a>
<a name="ln323">  saved_last_search_spat = spats[RE_SEARCH];</a>
<a name="ln324">  if (spats[RE_SEARCH].pat != NULL) {</a>
<a name="ln325">    saved_last_search_spat.pat = vim_strsave(spats[RE_SEARCH].pat);</a>
<a name="ln326">  }</a>
<a name="ln327">  saved_last_idx = last_idx;</a>
<a name="ln328">  saved_no_hlsearch = no_hlsearch;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">void restore_last_search_pattern(void)</a>
<a name="ln332">{</a>
<a name="ln333">  if (--did_save_last_search_spat &gt; 0) {</a>
<a name="ln334">    // nested call, nothing to do</a>
<a name="ln335">    return;</a>
<a name="ln336">  }</a>
<a name="ln337">  if (did_save_last_search_spat != 0) {</a>
<a name="ln338">    iemsg(&quot;restore_last_search_pattern() called more often than&quot;</a>
<a name="ln339">          &quot; save_last_search_pattern()&quot;);</a>
<a name="ln340">    return;</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  xfree(spats[RE_SEARCH].pat);</a>
<a name="ln344">  spats[RE_SEARCH] = saved_last_search_spat;</a>
<a name="ln345">  saved_last_search_spat.pat = NULL;</a>
<a name="ln346">  set_vv_searchforward();</a>
<a name="ln347">  last_idx = saved_last_idx;</a>
<a name="ln348">  set_no_hlsearch(saved_no_hlsearch);</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">char_u *last_search_pattern(void)</a>
<a name="ln352">{</a>
<a name="ln353">  return spats[RE_SEARCH].pat;</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">/*</a>
<a name="ln357"> * Return TRUE when case should be ignored for search pattern &quot;pat&quot;.</a>
<a name="ln358"> * Uses the 'ignorecase' and 'smartcase' options.</a>
<a name="ln359"> */</a>
<a name="ln360">int ignorecase(char_u *pat)</a>
<a name="ln361">{</a>
<a name="ln362">  return ignorecase_opt(pat, p_ic, p_scs);</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">/// As ignorecase() put pass the &quot;ic&quot; and &quot;scs&quot; flags.</a>
<a name="ln366">int ignorecase_opt(char_u *pat, int ic_in, int scs)</a>
<a name="ln367">{</a>
<a name="ln368">  int ic = ic_in;</a>
<a name="ln369">  if (ic &amp;&amp; !no_smartcase &amp;&amp; scs</a>
<a name="ln370">      &amp;&amp; !(ctrl_x_mode_not_default() &amp;&amp; curbuf-&gt;b_p_inf)</a>
<a name="ln371">      ) {</a>
<a name="ln372">    ic = !pat_has_uppercase(pat);</a>
<a name="ln373">  }</a>
<a name="ln374">  no_smartcase = false;</a>
<a name="ln375"> </a>
<a name="ln376">  return ic;</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">/// Returns true if pattern `pat` has an uppercase character.</a>
<a name="ln380">bool pat_has_uppercase(char_u *pat)</a>
<a name="ln381">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln382">{</a>
<a name="ln383">  char_u *p = pat;</a>
<a name="ln384"> </a>
<a name="ln385">  while (*p != NUL) {</a>
<a name="ln386">    const int l = mb_ptr2len(p);</a>
<a name="ln387"> </a>
<a name="ln388">    if (l &gt; 1) {</a>
<a name="ln389">      if (mb_isupper(utf_ptr2char(p))) {</a>
<a name="ln390">        return true;</a>
<a name="ln391">      }</a>
<a name="ln392">      p += l;</a>
<a name="ln393">    } else if (*p == '\\') {</a>
<a name="ln394">      if (p[1] == '_' &amp;&amp; p[2] != NUL) {  // skip &quot;\_X&quot;</a>
<a name="ln395">        p += 3;</a>
<a name="ln396">      } else if (p[1] == '%' &amp;&amp; p[2] != NUL) {  // skip &quot;\%X&quot;</a>
<a name="ln397">        p += 3;</a>
<a name="ln398">      } else if (p[1] != NUL) {  // skip &quot;\X&quot;</a>
<a name="ln399">        p += 2;</a>
<a name="ln400">      } else {</a>
<a name="ln401">        p += 1;</a>
<a name="ln402">      }</a>
<a name="ln403">    } else if (mb_isupper(*p)) {</a>
<a name="ln404">      return true;</a>
<a name="ln405">    } else {</a>
<a name="ln406">      p++;</a>
<a name="ln407">    }</a>
<a name="ln408">  }</a>
<a name="ln409">  return false;</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">const char *last_csearch(void)</a>
<a name="ln413">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln414">{</a>
<a name="ln415">  return (const char *)lastc_bytes;</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418">int last_csearch_forward(void)</a>
<a name="ln419">{</a>
<a name="ln420">  return lastcdir == FORWARD;</a>
<a name="ln421">}</a>
<a name="ln422"> </a>
<a name="ln423">int last_csearch_until(void)</a>
<a name="ln424">{</a>
<a name="ln425">  return last_t_cmd == TRUE;</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">void set_last_csearch(int c, char_u *s, int len)</a>
<a name="ln429">{</a>
<a name="ln430">  *lastc = c;</a>
<a name="ln431">  lastc_bytelen = len;</a>
<a name="ln432">  if (len)</a>
<a name="ln433">    memcpy(lastc_bytes, s, len);</a>
<a name="ln434">  else</a>
<a name="ln435">    memset(lastc_bytes, 0, sizeof(lastc_bytes));</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">void set_csearch_direction(Direction cdir)</a>
<a name="ln439">{</a>
<a name="ln440">  lastcdir = cdir;</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">void set_csearch_until(int t_cmd)</a>
<a name="ln444">{</a>
<a name="ln445">  last_t_cmd = t_cmd;</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448">char_u *last_search_pat(void)</a>
<a name="ln449">{</a>
<a name="ln450">  return spats[last_idx].pat;</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">/*</a>
<a name="ln454"> * Reset search direction to forward.  For &quot;gd&quot; and &quot;gD&quot; commands.</a>
<a name="ln455"> */</a>
<a name="ln456">void reset_search_dir(void)</a>
<a name="ln457">{</a>
<a name="ln458">  spats[0].off.dir = '/';</a>
<a name="ln459">  set_vv_searchforward();</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">/*</a>
<a name="ln463"> * Set the last search pattern.  For &quot;:let @/ =&quot; and ShaDa file.</a>
<a name="ln464"> * Also set the saved search pattern, so that this works in an autocommand.</a>
<a name="ln465"> */</a>
<a name="ln466">void set_last_search_pat(const char_u *s, int idx, int magic, int setlast)</a>
<a name="ln467">{</a>
<a name="ln468">  free_spat(&amp;spats[idx]);</a>
<a name="ln469">  /* An empty string means that nothing should be matched. */</a>
<a name="ln470">  if (*s == NUL)</a>
<a name="ln471">    spats[idx].pat = NULL;</a>
<a name="ln472">  else</a>
<a name="ln473">    spats[idx].pat = (char_u *) xstrdup((char *) s);</a>
<a name="ln474">  spats[idx].timestamp = os_time();</a>
<a name="ln475">  spats[idx].additional_data = NULL;</a>
<a name="ln476">  spats[idx].magic = magic;</a>
<a name="ln477">  spats[idx].no_scs = FALSE;</a>
<a name="ln478">  spats[idx].off.dir = '/';</a>
<a name="ln479">  set_vv_searchforward();</a>
<a name="ln480">  spats[idx].off.line = FALSE;</a>
<a name="ln481">  spats[idx].off.end = FALSE;</a>
<a name="ln482">  spats[idx].off.off = 0;</a>
<a name="ln483">  if (setlast)</a>
<a name="ln484">    last_idx = idx;</a>
<a name="ln485">  if (save_level) {</a>
<a name="ln486">    free_spat(&amp;saved_spats[idx]);</a>
<a name="ln487">    saved_spats[idx] = spats[0];</a>
<a name="ln488">    if (spats[idx].pat == NULL)</a>
<a name="ln489">      saved_spats[idx].pat = NULL;</a>
<a name="ln490">    else</a>
<a name="ln491">      saved_spats[idx].pat = vim_strsave(spats[idx].pat);</a>
<a name="ln492">    saved_spats_last_idx = last_idx;</a>
<a name="ln493">  }</a>
<a name="ln494">  /* If 'hlsearch' set and search pat changed: need redraw. */</a>
<a name="ln495">  if (p_hls &amp;&amp; idx == last_idx &amp;&amp; !no_hlsearch)</a>
<a name="ln496">    redraw_all_later(SOME_VALID);</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">/*</a>
<a name="ln500"> * Get a regexp program for the last used search pattern.</a>
<a name="ln501"> * This is used for highlighting all matches in a window.</a>
<a name="ln502"> * Values returned in regmatch-&gt;regprog and regmatch-&gt;rmm_ic.</a>
<a name="ln503"> */</a>
<a name="ln504">void last_pat_prog(regmmatch_T *regmatch)</a>
<a name="ln505">{</a>
<a name="ln506">  if (spats[last_idx].pat == NULL) {</a>
<a name="ln507">    regmatch-&gt;regprog = NULL;</a>
<a name="ln508">    return;</a>
<a name="ln509">  }</a>
<a name="ln510">  ++emsg_off;           /* So it doesn't beep if bad expr */</a>
<a name="ln511">  (void)search_regcomp((char_u *)&quot;&quot;, 0, last_idx, SEARCH_KEEP, regmatch);</a>
<a name="ln512">  --emsg_off;</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">/// lowest level search function.</a>
<a name="ln516">/// Search for 'count'th occurrence of pattern &quot;pat&quot; in direction &quot;dir&quot;.</a>
<a name="ln517">/// Start at position &quot;pos&quot; and return the found position in &quot;pos&quot;.</a>
<a name="ln518">///</a>
<a name="ln519">/// if (options &amp; SEARCH_MSG) == 0 don't give any messages</a>
<a name="ln520">/// if (options &amp; SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages</a>
<a name="ln521">/// if (options &amp; SEARCH_MSG) == SEARCH_MSG give all messages</a>
<a name="ln522">/// if (options &amp; SEARCH_HIS) put search pattern in history</a>
<a name="ln523">/// if (options &amp; SEARCH_END) return position at end of match</a>
<a name="ln524">/// if (options &amp; SEARCH_START) accept match at pos itself</a>
<a name="ln525">/// if (options &amp; SEARCH_KEEP) keep previous search pattern</a>
<a name="ln526">/// if (options &amp; SEARCH_FOLD) match only once in a closed fold</a>
<a name="ln527">/// if (options &amp; SEARCH_PEEK) check for typed char, cancel search</a>
<a name="ln528">/// if (options &amp; SEARCH_COL) start at pos-&gt;col instead of zero</a>
<a name="ln529">///</a>
<a name="ln530">/// @returns FAIL (zero) for failure, non-zero for success.</a>
<a name="ln531">///          the index of the first matching</a>
<a name="ln532">///          subpattern plus one; one if there was none.</a>
<a name="ln533">int searchit(</a>
<a name="ln534">    win_T       *win,          // window to search in; can be NULL for a</a>
<a name="ln535">                               // buffer without a window!</a>
<a name="ln536">    buf_T       *buf,</a>
<a name="ln537">    pos_T       *pos,</a>
<a name="ln538">    pos_T       *end_pos,      // set to end of the match, unless NULL</a>
<a name="ln539">    Direction dir,</a>
<a name="ln540">    char_u      *pat,</a>
<a name="ln541">    long count,</a>
<a name="ln542">    int options,</a>
<a name="ln543">    int pat_use,               // which pattern to use when &quot;pat&quot; is empty</a>
<a name="ln544">    searchit_arg_T *extra_arg  // optional extra arguments, can be NULL</a>
<a name="ln545">)</a>
<a name="ln546">{</a>
<a name="ln547">  int found;</a>
<a name="ln548">  linenr_T lnum;                /* no init to shut up Apollo cc */</a>
<a name="ln549">  regmmatch_T regmatch;</a>
<a name="ln550">  char_u      *ptr;</a>
<a name="ln551">  colnr_T matchcol;</a>
<a name="ln552">  lpos_T endpos;</a>
<a name="ln553">  lpos_T matchpos;</a>
<a name="ln554">  int loop;</a>
<a name="ln555">  pos_T start_pos;</a>
<a name="ln556">  int at_first_line;</a>
<a name="ln557">  int extra_col;</a>
<a name="ln558">  int start_char_len;</a>
<a name="ln559">  int match_ok;</a>
<a name="ln560">  long nmatched;</a>
<a name="ln561">  int submatch = 0;</a>
<a name="ln562">  bool first_match = true;</a>
<a name="ln563">  int save_called_emsg = called_emsg;</a>
<a name="ln564">  int break_loop = false;</a>
<a name="ln565">  linenr_T stop_lnum = 0;  // stop after this line number when != 0</a>
<a name="ln566">  proftime_T *tm = NULL;   // timeout limit or NULL</a>
<a name="ln567">  int *timed_out = NULL;   // set when timed out or NULL</a>
<a name="ln568"> </a>
<a name="ln569">  if (extra_arg != NULL) {</a>
<a name="ln570">      stop_lnum = extra_arg-&gt;sa_stop_lnum;</a>
<a name="ln571">      tm = extra_arg-&gt;sa_tm;</a>
<a name="ln572">      timed_out = &amp;extra_arg-&gt;sa_timed_out;</a>
<a name="ln573">  }</a>
<a name="ln574"> </a>
<a name="ln575">  if (search_regcomp(pat, RE_SEARCH, pat_use,</a>
<a name="ln576">          (options &amp; (SEARCH_HIS + SEARCH_KEEP)), &amp;regmatch) == FAIL) {</a>
<a name="ln577">    if ((options &amp; SEARCH_MSG) &amp;&amp; !rc_did_emsg)</a>
<a name="ln578">      EMSG2(_(&quot;E383: Invalid search string: %s&quot;), mr_pattern);</a>
<a name="ln579">    return FAIL;</a>
<a name="ln580">  }</a>
<a name="ln581"> </a>
<a name="ln582">  /*</a>
<a name="ln583">   * find the string</a>
<a name="ln584">   */</a>
<a name="ln585">  called_emsg = FALSE;</a>
<a name="ln586">  do {  /* loop for count */</a>
<a name="ln587">    // When not accepting a match at the start position set &quot;extra_col&quot; to a</a>
<a name="ln588">    // non-zero value.  Don't do that when starting at MAXCOL, since MAXCOL + 1</a>
<a name="ln589">    // is zero.</a>
<a name="ln590">    if (pos-&gt;col == MAXCOL) {</a>
<a name="ln591">      start_char_len = 0;</a>
<a name="ln592">    } else if (pos-&gt;lnum &gt;= 1</a>
<a name="ln593">               &amp;&amp; pos-&gt;lnum &lt;= buf-&gt;b_ml.ml_line_count</a>
<a name="ln594">               &amp;&amp; pos-&gt;col &lt; MAXCOL - 2) {</a>
<a name="ln595">      // Watch out for the &quot;col&quot; being MAXCOL - 2, used in a closed fold.</a>
<a name="ln596">      ptr = ml_get_buf(buf, pos-&gt;lnum, false);</a>
<a name="ln597">      if ((int)STRLEN(ptr) &lt;= pos-&gt;col) {</a>
<a name="ln598">        start_char_len = 1;</a>
<a name="ln599">      } else {</a>
<a name="ln600">        start_char_len = utfc_ptr2len(ptr + pos-&gt;col);</a>
<a name="ln601">      }</a>
<a name="ln602">    } else {</a>
<a name="ln603">      start_char_len = 1;</a>
<a name="ln604">    }</a>
<a name="ln605">    if (dir == FORWARD) {</a>
<a name="ln606">      extra_col = (options &amp; SEARCH_START) ? 0 : start_char_len;</a>
<a name="ln607">    } else {</a>
<a name="ln608">      extra_col = (options &amp; SEARCH_START) ? start_char_len : 0;</a>
<a name="ln609">    }</a>
<a name="ln610"> </a>
<a name="ln611">    start_pos = *pos;           /* remember start pos for detecting no match */</a>
<a name="ln612">    found = 0;                  /* default: not found */</a>
<a name="ln613">    at_first_line = TRUE;       /* default: start in first line */</a>
<a name="ln614">    if (pos-&gt;lnum == 0) {       /* correct lnum for when starting in line 0 */</a>
<a name="ln615">      pos-&gt;lnum = 1;</a>
<a name="ln616">      pos-&gt;col = 0;</a>
<a name="ln617">      at_first_line = FALSE;        /* not in first line now */</a>
<a name="ln618">    }</a>
<a name="ln619"> </a>
<a name="ln620">    /*</a>
<a name="ln621">     * Start searching in current line, unless searching backwards and</a>
<a name="ln622">     * we're in column 0.</a>
<a name="ln623">     * If we are searching backwards, in column 0, and not including the</a>
<a name="ln624">     * current position, gain some efficiency by skipping back a line.</a>
<a name="ln625">     * Otherwise begin the search in the current line.</a>
<a name="ln626">     */</a>
<a name="ln627">    if (dir == BACKWARD &amp;&amp; start_pos.col == 0</a>
<a name="ln628">        &amp;&amp; (options &amp; SEARCH_START) == 0) {</a>
<a name="ln629">      lnum = pos-&gt;lnum - 1;</a>
<a name="ln630">      at_first_line = FALSE;</a>
<a name="ln631">    } else</a>
<a name="ln632">      lnum = pos-&gt;lnum;</a>
<a name="ln633"> </a>
<a name="ln634">    for (loop = 0; loop &lt;= 1; ++loop) {     /* loop twice if 'wrapscan' set */</a>
<a name="ln635">      for (; lnum &gt; 0 &amp;&amp; lnum &lt;= buf-&gt;b_ml.ml_line_count;</a>
<a name="ln636">           lnum += dir, at_first_line = FALSE) {</a>
<a name="ln637">        /* Stop after checking &quot;stop_lnum&quot;, if it's set. */</a>
<a name="ln638">        if (stop_lnum != 0 &amp;&amp; (dir == FORWARD</a>
<a name="ln639">                               ? lnum &gt; stop_lnum : lnum &lt; stop_lnum))</a>
<a name="ln640">          break;</a>
<a name="ln641">        /* Stop after passing the &quot;tm&quot; time limit. */</a>
<a name="ln642">        if (tm != NULL &amp;&amp; profile_passed_limit(*tm))</a>
<a name="ln643">          break;</a>
<a name="ln644"> </a>
<a name="ln645">        // Look for a match somewhere in line &quot;lnum&quot;.</a>
<a name="ln646">        colnr_T col = at_first_line &amp;&amp; (options &amp; SEARCH_COL) ? pos-&gt;col : 0;</a>
<a name="ln647">        nmatched = vim_regexec_multi(&amp;regmatch, win, buf,</a>
<a name="ln648">                                     lnum, col, tm, timed_out);</a>
<a name="ln649">        // vim_regexec_multi() may clear &quot;regprog&quot;</a>
<a name="ln650">        if (regmatch.regprog == NULL) {</a>
<a name="ln651">          break;</a>
<a name="ln652">        }</a>
<a name="ln653">        // Abort searching on an error (e.g., out of stack).</a>
<a name="ln654">        if (called_emsg || (timed_out != NULL &amp;&amp; *timed_out)) {</a>
<a name="ln655">          break;</a>
<a name="ln656">        }</a>
<a name="ln657">        if (nmatched &gt; 0) {</a>
<a name="ln658">          /* match may actually be in another line when using \zs */</a>
<a name="ln659">          matchpos = regmatch.startpos[0];</a>
<a name="ln660">          endpos = regmatch.endpos[0];</a>
<a name="ln661">          submatch = first_submatch(&amp;regmatch);</a>
<a name="ln662">          /* &quot;lnum&quot; may be past end of buffer for &quot;\n\zs&quot;. */</a>
<a name="ln663">          if (lnum + matchpos.lnum &gt; buf-&gt;b_ml.ml_line_count)</a>
<a name="ln664">            ptr = (char_u *)&quot;&quot;;</a>
<a name="ln665">          else</a>
<a name="ln666">            ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);</a>
<a name="ln667"> </a>
<a name="ln668">          /*</a>
<a name="ln669">           * Forward search in the first line: match should be after</a>
<a name="ln670">           * the start position. If not, continue at the end of the</a>
<a name="ln671">           * match (this is vi compatible) or on the next char.</a>
<a name="ln672">           */</a>
<a name="ln673">          if (dir == FORWARD &amp;&amp; at_first_line) {</a>
<a name="ln674">            match_ok = TRUE;</a>
<a name="ln675">            /*</a>
<a name="ln676">             * When the match starts in a next line it's certainly</a>
<a name="ln677">             * past the start position.</a>
<a name="ln678">             * When match lands on a NUL the cursor will be put</a>
<a name="ln679">             * one back afterwards, compare with that position,</a>
<a name="ln680">             * otherwise &quot;/$&quot; will get stuck on end of line.</a>
<a name="ln681">             */</a>
<a name="ln682">            while (matchpos.lnum == 0</a>
<a name="ln683">                   &amp;&amp; (((options &amp; SEARCH_END) &amp;&amp; first_match)</a>
<a name="ln684">                       ?  (nmatched == 1</a>
<a name="ln685">                           &amp;&amp; (int)endpos.col - 1</a>
<a name="ln686">                           &lt; (int)start_pos.col + extra_col)</a>
<a name="ln687">                       : ((int)matchpos.col</a>
<a name="ln688">                          - (ptr[matchpos.col] == NUL)</a>
<a name="ln689">                          &lt; (int)start_pos.col + extra_col))) {</a>
<a name="ln690">              /*</a>
<a name="ln691">               * If vi-compatible searching, continue at the end</a>
<a name="ln692">               * of the match, otherwise continue one position</a>
<a name="ln693">               * forward.</a>
<a name="ln694">               */</a>
<a name="ln695">              if (vim_strchr(p_cpo, CPO_SEARCH) != NULL) {</a>
<a name="ln696">                if (nmatched &gt; 1) {</a>
<a name="ln697">                  /* end is in next line, thus no match in</a>
<a name="ln698">                   * this line */</a>
<a name="ln699">                  match_ok = FALSE;</a>
<a name="ln700">                  break;</a>
<a name="ln701">                }</a>
<a name="ln702">                matchcol = endpos.col;</a>
<a name="ln703">                // for empty match (matchcol == matchpos.col): advance one char</a>
<a name="ln704">              } else {</a>
<a name="ln705">                // Prepare to start after first matched character.</a>
<a name="ln706">                matchcol = matchpos.col;</a>
<a name="ln707">              }</a>
<a name="ln708"> </a>
<a name="ln709">              if (matchcol == matchpos.col &amp;&amp; ptr[matchcol] != NUL) {</a>
<a name="ln710">                matchcol += utfc_ptr2len(ptr + matchcol);</a>
<a name="ln711">              }</a>
<a name="ln712"> </a>
<a name="ln713">              if (matchcol == 0 &amp;&amp; (options &amp; SEARCH_START)) {</a>
<a name="ln714">                break;</a>
<a name="ln715">              }</a>
<a name="ln716"> </a>
<a name="ln717">              if (ptr[matchcol] == NUL</a>
<a name="ln718">                  || (nmatched = vim_regexec_multi(&amp;regmatch, win, buf,</a>
<a name="ln719">                                                   lnum, matchcol, tm,</a>
<a name="ln720">                                                   timed_out)) == 0) {</a>
<a name="ln721">                match_ok = false;</a>
<a name="ln722">                break;</a>
<a name="ln723">              }</a>
<a name="ln724">              // vim_regexec_multi() may clear &quot;regprog&quot;</a>
<a name="ln725">              if (regmatch.regprog == NULL) {</a>
<a name="ln726">                break;</a>
<a name="ln727">              }</a>
<a name="ln728">              matchpos = regmatch.startpos[0];</a>
<a name="ln729">              endpos = regmatch.endpos[0];</a>
<a name="ln730">              submatch = first_submatch(&amp;regmatch);</a>
<a name="ln731"> </a>
<a name="ln732">              // This while-loop only works with matchpos.lnum == 0.</a>
<a name="ln733">              // For bigger values the next line pointer ptr might not be a</a>
<a name="ln734">              // buffer line.</a>
<a name="ln735">              if (matchpos.lnum != 0) {</a>
<a name="ln736">                break;</a>
<a name="ln737">              }</a>
<a name="ln738">              // Need to get the line pointer again, a multi-line search may</a>
<a name="ln739">              // have made it invalid.</a>
<a name="ln740">              ptr = ml_get_buf(buf, lnum, false);</a>
<a name="ln741">            }</a>
<a name="ln742">            if (!match_ok)</a>
<a name="ln743">              continue;</a>
<a name="ln744">          }</a>
<a name="ln745">          if (dir == BACKWARD) {</a>
<a name="ln746">            /*</a>
<a name="ln747">             * Now, if there are multiple matches on this line,</a>
<a name="ln748">             * we have to get the last one. Or the last one before</a>
<a name="ln749">             * the cursor, if we're on that line.</a>
<a name="ln750">             * When putting the new cursor at the end, compare</a>
<a name="ln751">             * relative to the end of the match.</a>
<a name="ln752">             */</a>
<a name="ln753">            match_ok = FALSE;</a>
<a name="ln754">            for (;; ) {</a>
<a name="ln755">              /* Remember a position that is before the start</a>
<a name="ln756">               * position, we use it if it's the last match in</a>
<a name="ln757">               * the line.  Always accept a position after</a>
<a name="ln758">               * wrapping around. */</a>
<a name="ln759">              if (loop</a>
<a name="ln760">                  || ((options &amp; SEARCH_END)</a>
<a name="ln761">                      ? (lnum + regmatch.endpos[0].lnum</a>
<a name="ln762">                         &lt; start_pos.lnum</a>
<a name="ln763">                         || (lnum + regmatch.endpos[0].lnum</a>
<a name="ln764">                             == start_pos.lnum</a>
<a name="ln765">                             &amp;&amp; (int)regmatch.endpos[0].col - 1</a>
<a name="ln766">                             &lt; (int)start_pos.col + extra_col))</a>
<a name="ln767">                      : (lnum + regmatch.startpos[0].lnum</a>
<a name="ln768">                         &lt; start_pos.lnum</a>
<a name="ln769">                         || (lnum + regmatch.startpos[0].lnum</a>
<a name="ln770">                             == start_pos.lnum</a>
<a name="ln771">                             &amp;&amp; (int)regmatch.startpos[0].col</a>
<a name="ln772">                             &lt; (int)start_pos.col + extra_col)))) {</a>
<a name="ln773">                match_ok = true;</a>
<a name="ln774">                matchpos = regmatch.startpos[0];</a>
<a name="ln775">                endpos = regmatch.endpos[0];</a>
<a name="ln776">                submatch = first_submatch(&amp;regmatch);</a>
<a name="ln777">              } else</a>
<a name="ln778">                break;</a>
<a name="ln779"> </a>
<a name="ln780">              // We found a valid match, now check if there is</a>
<a name="ln781">              // another one after it.</a>
<a name="ln782">              // If vi-compatible searching, continue at the end</a>
<a name="ln783">              // of the match, otherwise continue one position</a>
<a name="ln784">              // forward.</a>
<a name="ln785">              if (vim_strchr(p_cpo, CPO_SEARCH) != NULL) {</a>
<a name="ln786">                if (nmatched &gt; 1) {</a>
<a name="ln787">                  break;</a>
<a name="ln788">                }</a>
<a name="ln789">                matchcol = endpos.col;</a>
<a name="ln790">                // for empty match: advance one char</a>
<a name="ln791">                if (matchcol == matchpos.col</a>
<a name="ln792">                    &amp;&amp; ptr[matchcol] != NUL) {</a>
<a name="ln793">                  matchcol += mb_ptr2len(ptr + matchcol);</a>
<a name="ln794">                }</a>
<a name="ln795">              } else {</a>
<a name="ln796">                // Stop when the match is in a next line.</a>
<a name="ln797">                if (matchpos.lnum &gt; 0) {</a>
<a name="ln798">                  break;</a>
<a name="ln799">                }</a>
<a name="ln800">                matchcol = matchpos.col;</a>
<a name="ln801">                if (ptr[matchcol] != NUL) {</a>
<a name="ln802">                  matchcol += mb_ptr2len(ptr + matchcol);</a>
<a name="ln803">                }</a>
<a name="ln804">              }</a>
<a name="ln805">              if (ptr[matchcol] == NUL</a>
<a name="ln806">                  || (nmatched = vim_regexec_multi(</a>
<a name="ln807">                      &amp;regmatch, win, buf, lnum + matchpos.lnum, matchcol,</a>
<a name="ln808">                      tm, timed_out)) == 0) {</a>
<a name="ln809">                  // If the search timed out, we did find a match</a>
<a name="ln810">                  // but it might be the wrong one, so that's not</a>
<a name="ln811">                  // OK.</a>
<a name="ln812">                  if (tm != NULL &amp;&amp; profile_passed_limit(*tm)) {</a>
<a name="ln813">                      match_ok = false;</a>
<a name="ln814">                  }</a>
<a name="ln815">                  break;</a>
<a name="ln816">              }</a>
<a name="ln817">              // vim_regexec_multi() may clear &quot;regprog&quot;</a>
<a name="ln818">              if (regmatch.regprog == NULL) {</a>
<a name="ln819">                break;</a>
<a name="ln820">              }</a>
<a name="ln821">              // Need to get the line pointer again, a</a>
<a name="ln822">              // multi-line search may have made it invalid.</a>
<a name="ln823">              ptr = ml_get_buf(buf, lnum + matchpos.lnum, false);</a>
<a name="ln824">            }</a>
<a name="ln825"> </a>
<a name="ln826">            /*</a>
<a name="ln827">             * If there is only a match after the cursor, skip</a>
<a name="ln828">             * this match.</a>
<a name="ln829">             */</a>
<a name="ln830">            if (!match_ok)</a>
<a name="ln831">              continue;</a>
<a name="ln832">          }</a>
<a name="ln833"> </a>
<a name="ln834">          /* With the SEARCH_END option move to the last character</a>
<a name="ln835">           * of the match.  Don't do it for an empty match, end</a>
<a name="ln836">           * should be same as start then. */</a>
<a name="ln837">          if ((options &amp; SEARCH_END) &amp;&amp; !(options &amp; SEARCH_NOOF)</a>
<a name="ln838">              &amp;&amp; !(matchpos.lnum == endpos.lnum</a>
<a name="ln839">                   &amp;&amp; matchpos.col == endpos.col)) {</a>
<a name="ln840">            /* For a match in the first column, set the position</a>
<a name="ln841">             * on the NUL in the previous line. */</a>
<a name="ln842">            pos-&gt;lnum = lnum + endpos.lnum;</a>
<a name="ln843">            pos-&gt;col = endpos.col;</a>
<a name="ln844">            if (endpos.col == 0) {</a>
<a name="ln845">              if (pos-&gt;lnum &gt; 1) {              /* just in case */</a>
<a name="ln846">                --pos-&gt;lnum;</a>
<a name="ln847">                pos-&gt;col = (colnr_T)STRLEN(ml_get_buf(buf,</a>
<a name="ln848">                        pos-&gt;lnum, FALSE));</a>
<a name="ln849">              }</a>
<a name="ln850">            } else {</a>
<a name="ln851">              pos-&gt;col--;</a>
<a name="ln852">              if (pos-&gt;lnum &lt;= buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln853">                ptr = ml_get_buf(buf, pos-&gt;lnum, false);</a>
<a name="ln854">                pos-&gt;col -= utf_head_off(ptr, ptr + pos-&gt;col);</a>
<a name="ln855">              }</a>
<a name="ln856">            }</a>
<a name="ln857">            if (end_pos != NULL) {</a>
<a name="ln858">              end_pos-&gt;lnum = lnum + matchpos.lnum;</a>
<a name="ln859">              end_pos-&gt;col = matchpos.col;</a>
<a name="ln860">            }</a>
<a name="ln861">          } else {</a>
<a name="ln862">            pos-&gt;lnum = lnum + matchpos.lnum;</a>
<a name="ln863">            pos-&gt;col = matchpos.col;</a>
<a name="ln864">            if (end_pos != NULL) {</a>
<a name="ln865">              end_pos-&gt;lnum = lnum + endpos.lnum;</a>
<a name="ln866">              end_pos-&gt;col = endpos.col;</a>
<a name="ln867">            }</a>
<a name="ln868">          }</a>
<a name="ln869">          pos-&gt;coladd = 0;</a>
<a name="ln870">          if (end_pos != NULL) {</a>
<a name="ln871">            end_pos-&gt;coladd = 0;</a>
<a name="ln872">          }</a>
<a name="ln873">          found = 1;</a>
<a name="ln874">          first_match = false;</a>
<a name="ln875"> </a>
<a name="ln876">          /* Set variables used for 'incsearch' highlighting. */</a>
<a name="ln877">          search_match_lines = endpos.lnum - matchpos.lnum;</a>
<a name="ln878">          search_match_endcol = endpos.col;</a>
<a name="ln879">          break;</a>
<a name="ln880">        }</a>
<a name="ln881">        line_breakcheck();              /* stop if ctrl-C typed */</a>
<a name="ln882">        if (got_int)</a>
<a name="ln883">          break;</a>
<a name="ln884"> </a>
<a name="ln885">        /* Cancel searching if a character was typed.  Used for</a>
<a name="ln886">         * 'incsearch'.  Don't check too often, that would slowdown</a>
<a name="ln887">         * searching too much. */</a>
<a name="ln888">        if ((options &amp; SEARCH_PEEK)</a>
<a name="ln889">            &amp;&amp; ((lnum - pos-&gt;lnum) &amp; 0x3f) == 0</a>
<a name="ln890">            &amp;&amp; char_avail()) {</a>
<a name="ln891">          break_loop = TRUE;</a>
<a name="ln892">          break;</a>
<a name="ln893">        }</a>
<a name="ln894"> </a>
<a name="ln895">        if (loop &amp;&amp; lnum == start_pos.lnum)</a>
<a name="ln896">          break;                    /* if second loop, stop where started */</a>
<a name="ln897">      }</a>
<a name="ln898">      at_first_line = FALSE;</a>
<a name="ln899"> </a>
<a name="ln900">      // vim_regexec_multi() may clear &quot;regprog&quot;</a>
<a name="ln901">      if (regmatch.regprog == NULL) {</a>
<a name="ln902">        break;</a>
<a name="ln903">      }</a>
<a name="ln904"> </a>
<a name="ln905">      // Stop the search if wrapscan isn't set, &quot;stop_lnum&quot; is</a>
<a name="ln906">      // specified, after an interrupt, after a match and after looping</a>
<a name="ln907">      // twice.</a>
<a name="ln908">      if (!p_ws || stop_lnum != 0 || got_int || called_emsg</a>
<a name="ln909">          || (timed_out != NULL &amp;&amp; *timed_out)</a>
<a name="ln910">          || break_loop</a>
<a name="ln911">          || found || loop) {</a>
<a name="ln912">        break;</a>
<a name="ln913">      }</a>
<a name="ln914">      //</a>
<a name="ln915">      // If 'wrapscan' is set we continue at the other end of the file.</a>
<a name="ln916">      // If 'shortmess' does not contain 's', we give a message.</a>
<a name="ln917">      // This message is also remembered in keep_msg for when the screen</a>
<a name="ln918">      // is redrawn. The keep_msg is cleared whenever another message is</a>
<a name="ln919">      // written.</a>
<a name="ln920">      //</a>
<a name="ln921">      if (dir == BACKWARD) {        // start second loop at the other end</a>
<a name="ln922">        lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln923">      } else {</a>
<a name="ln924">        lnum = 1;</a>
<a name="ln925">      }</a>
<a name="ln926">      if (!shortmess(SHM_SEARCH) &amp;&amp; (options &amp; SEARCH_MSG)) {</a>
<a name="ln927">        give_warning((char_u *)_(dir == BACKWARD</a>
<a name="ln928">                                 ? top_bot_msg : bot_top_msg), true);</a>
<a name="ln929">      }</a>
<a name="ln930">      if (extra_arg != NULL) {</a>
<a name="ln931">        extra_arg-&gt;sa_wrapped = true;</a>
<a name="ln932">      }</a>
<a name="ln933">    }</a>
<a name="ln934">    if (got_int || called_emsg</a>
<a name="ln935">        || (timed_out != NULL &amp;&amp; *timed_out)</a>
<a name="ln936">        || break_loop</a>
<a name="ln937">        ) {</a>
<a name="ln938">      break;</a>
<a name="ln939">    }</a>
<a name="ln940">  } while (--count &gt; 0 &amp;&amp; found);   // stop after count matches or no match</a>
<a name="ln941"> </a>
<a name="ln942">  vim_regfree(regmatch.regprog);</a>
<a name="ln943"> </a>
<a name="ln944">  called_emsg |= save_called_emsg;</a>
<a name="ln945"> </a>
<a name="ln946">  if (!found) {             /* did not find it */</a>
<a name="ln947">    if (got_int)</a>
<a name="ln948">      EMSG(_(e_interr));</a>
<a name="ln949">    else if ((options &amp; SEARCH_MSG) == SEARCH_MSG) {</a>
<a name="ln950">      if (p_ws)</a>
<a name="ln951">        EMSG2(_(e_patnotf2), mr_pattern);</a>
<a name="ln952">      else if (lnum == 0)</a>
<a name="ln953">        EMSG2(_(&quot;E384: search hit TOP without match for: %s&quot;),</a>
<a name="ln954">            mr_pattern);</a>
<a name="ln955">      else</a>
<a name="ln956">        EMSG2(_(&quot;E385: search hit BOTTOM without match for: %s&quot;),</a>
<a name="ln957">            mr_pattern);</a>
<a name="ln958">    }</a>
<a name="ln959">    return FAIL;</a>
<a name="ln960">  }</a>
<a name="ln961"> </a>
<a name="ln962">  /* A pattern like &quot;\n\zs&quot; may go past the last line. */</a>
<a name="ln963">  if (pos-&gt;lnum &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln964">    pos-&gt;lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln965">    pos-&gt;col = (int)STRLEN(ml_get_buf(buf, pos-&gt;lnum, FALSE));</a>
<a name="ln966">    if (pos-&gt;col &gt; 0)</a>
<a name="ln967">      --pos-&gt;col;</a>
<a name="ln968">  }</a>
<a name="ln969"> </a>
<a name="ln970">  return submatch + 1;</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973">void set_search_direction(int cdir)</a>
<a name="ln974">{</a>
<a name="ln975">  spats[0].off.dir = cdir;</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978">static void set_vv_searchforward(void)</a>
<a name="ln979">{</a>
<a name="ln980">  set_vim_var_nr(VV_SEARCHFORWARD, (long)(spats[0].off.dir == '/'));</a>
<a name="ln981">}</a>
<a name="ln982"> </a>
<a name="ln983">// Return the number of the first subpat that matched.</a>
<a name="ln984">// Return zero if none of them matched.</a>
<a name="ln985">static int first_submatch(regmmatch_T *rp)</a>
<a name="ln986">{</a>
<a name="ln987">  int submatch;</a>
<a name="ln988"> </a>
<a name="ln989">  for (submatch = 1;; ++submatch) {</a>
<a name="ln990">    if (rp-&gt;startpos[submatch].lnum &gt;= 0)</a>
<a name="ln991">      break;</a>
<a name="ln992">    if (submatch == 9) {</a>
<a name="ln993">      submatch = 0;</a>
<a name="ln994">      break;</a>
<a name="ln995">    }</a>
<a name="ln996">  }</a>
<a name="ln997">  return submatch;</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000">/*</a>
<a name="ln1001"> * Highest level string search function.</a>
<a name="ln1002"> * Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'</a>
<a name="ln1003"> *    If 'dirc' is 0: use previous dir.</a>
<a name="ln1004"> *    If 'pat' is NULL or empty : use previous string.</a>
<a name="ln1005"> *    If 'options &amp; SEARCH_REV' : go in reverse of previous dir.</a>
<a name="ln1006"> *    If 'options &amp; SEARCH_ECHO': echo the search command and handle options</a>
<a name="ln1007"> *    If 'options &amp; SEARCH_MSG' : may give error message</a>
<a name="ln1008"> *    If 'options &amp; SEARCH_OPT' : interpret optional flags</a>
<a name="ln1009"> *    If 'options &amp; SEARCH_HIS' : put search pattern in history</a>
<a name="ln1010"> *    If 'options &amp; SEARCH_NOOF': don't add offset to position</a>
<a name="ln1011"> *    If 'options &amp; SEARCH_MARK': set previous context mark</a>
<a name="ln1012"> *    If 'options &amp; SEARCH_KEEP': keep previous search pattern</a>
<a name="ln1013"> *    If 'options &amp; SEARCH_START': accept match at curpos itself</a>
<a name="ln1014"> *    If 'options &amp; SEARCH_PEEK': check for typed char, cancel search</a>
<a name="ln1015"> *</a>
<a name="ln1016"> * Careful: If spats[0].off.line == TRUE and spats[0].off.off == 0 this</a>
<a name="ln1017"> * makes the movement linewise without moving the match position.</a>
<a name="ln1018"> *</a>
<a name="ln1019"> * Return 0 for failure, 1 for found, 2 for found and line offset added.</a>
<a name="ln1020"> */</a>
<a name="ln1021">int do_search(</a>
<a name="ln1022">    oparg_T         *oap,           // can be NULL</a>
<a name="ln1023">    int dirc,                       // '/' or '?'</a>
<a name="ln1024">    int search_delim,  // delimiter for search, e.g. '%' in s%regex%replacement</a>
<a name="ln1025">    char_u          *pat,</a>
<a name="ln1026">    long count,</a>
<a name="ln1027">    int options,</a>
<a name="ln1028">    searchit_arg_T  *sia        // optional arguments or NULL</a>
<a name="ln1029">)</a>
<a name="ln1030">{</a>
<a name="ln1031">  pos_T pos;                    /* position of the last match */</a>
<a name="ln1032">  char_u          *searchstr;</a>
<a name="ln1033">  struct soffset old_off;</a>
<a name="ln1034">  int retval;                   /* Return value */</a>
<a name="ln1035">  char_u          *p;</a>
<a name="ln1036">  long c;</a>
<a name="ln1037">  char_u          *dircp;</a>
<a name="ln1038">  char_u          *strcopy = NULL;</a>
<a name="ln1039">  char_u          *ps;</a>
<a name="ln1040">  char_u          *msgbuf = NULL;</a>
<a name="ln1041">  size_t          len;</a>
<a name="ln1042">  bool            has_offset = false;</a>
<a name="ln1043"> </a>
<a name="ln1044">  /*</a>
<a name="ln1045">   * A line offset is not remembered, this is vi compatible.</a>
<a name="ln1046">   */</a>
<a name="ln1047">  if (spats[0].off.line &amp;&amp; vim_strchr(p_cpo, CPO_LINEOFF) != NULL) {</a>
<a name="ln1048">    spats[0].off.line = FALSE;</a>
<a name="ln1049">    spats[0].off.off = 0;</a>
<a name="ln1050">  }</a>
<a name="ln1051"> </a>
<a name="ln1052">  /*</a>
<a name="ln1053">   * Save the values for when (options &amp; SEARCH_KEEP) is used.</a>
<a name="ln1054">   * (there is no &quot;if ()&quot; around this because gcc wants them initialized)</a>
<a name="ln1055">   */</a>
<a name="ln1056">  old_off = spats[0].off;</a>
<a name="ln1057"> </a>
<a name="ln1058">  pos = curwin-&gt;w_cursor;       /* start searching at the cursor position */</a>
<a name="ln1059"> </a>
<a name="ln1060">  /*</a>
<a name="ln1061">   * Find out the direction of the search.</a>
<a name="ln1062">   */</a>
<a name="ln1063">  if (dirc == 0)</a>
<a name="ln1064">    dirc = spats[0].off.dir;</a>
<a name="ln1065">  else {</a>
<a name="ln1066">    spats[0].off.dir = dirc;</a>
<a name="ln1067">    set_vv_searchforward();</a>
<a name="ln1068">  }</a>
<a name="ln1069">  if (options &amp; SEARCH_REV) {</a>
<a name="ln1070">    if (dirc == '/')</a>
<a name="ln1071">      dirc = '?';</a>
<a name="ln1072">    else</a>
<a name="ln1073">      dirc = '/';</a>
<a name="ln1074">  }</a>
<a name="ln1075"> </a>
<a name="ln1076">  /* If the cursor is in a closed fold, don't find another match in the same</a>
<a name="ln1077">   * fold. */</a>
<a name="ln1078">  if (dirc == '/') {</a>
<a name="ln1079">    if (hasFolding(pos.lnum, NULL, &amp;pos.lnum))</a>
<a name="ln1080">      pos.col = MAXCOL - 2;             /* avoid overflow when adding 1 */</a>
<a name="ln1081">  } else {</a>
<a name="ln1082">    if (hasFolding(pos.lnum, &amp;pos.lnum, NULL))</a>
<a name="ln1083">      pos.col = 0;</a>
<a name="ln1084">  }</a>
<a name="ln1085"> </a>
<a name="ln1086">  /*</a>
<a name="ln1087">   * Turn 'hlsearch' highlighting back on.</a>
<a name="ln1088">   */</a>
<a name="ln1089">  if (no_hlsearch &amp;&amp; !(options &amp; SEARCH_KEEP)) {</a>
<a name="ln1090">    redraw_all_later(SOME_VALID);</a>
<a name="ln1091">    set_no_hlsearch(false);</a>
<a name="ln1092">  }</a>
<a name="ln1093"> </a>
<a name="ln1094">  /*</a>
<a name="ln1095">   * Repeat the search when pattern followed by ';', e.g. &quot;/foo/;?bar&quot;.</a>
<a name="ln1096">   */</a>
<a name="ln1097">  for (;; ) {</a>
<a name="ln1098">    bool show_top_bot_msg = false;</a>
<a name="ln1099"> </a>
<a name="ln1100">    searchstr = pat;</a>
<a name="ln1101">    dircp = NULL;</a>
<a name="ln1102">    // use previous pattern</a>
<a name="ln1103">    if (pat == NULL || *pat == NUL || *pat == search_delim) {</a>
<a name="ln1104">      if (spats[RE_SEARCH].pat == NULL) {           // no previous pattern</a>
<a name="ln1105">        searchstr = spats[RE_SUBST].pat;</a>
<a name="ln1106">        if (searchstr == NULL) {</a>
<a name="ln1107">          EMSG(_(e_noprevre));</a>
<a name="ln1108">          retval = 0;</a>
<a name="ln1109">          goto end_do_search;</a>
<a name="ln1110">        }</a>
<a name="ln1111">      } else {</a>
<a name="ln1112">        /* make search_regcomp() use spats[RE_SEARCH].pat */</a>
<a name="ln1113">        searchstr = (char_u *)&quot;&quot;;</a>
<a name="ln1114">      }</a>
<a name="ln1115">    }</a>
<a name="ln1116"> </a>
<a name="ln1117">    if (pat != NULL &amp;&amp; *pat != NUL) {   /* look for (new) offset */</a>
<a name="ln1118">      /*</a>
<a name="ln1119">       * Find end of regular expression.</a>
<a name="ln1120">       * If there is a matching '/' or '?', toss it.</a>
<a name="ln1121">       */</a>
<a name="ln1122">      ps = strcopy;</a>
<a name="ln1123">      p = skip_regexp(pat, search_delim, p_magic, &amp;strcopy);</a>
<a name="ln1124">      if (strcopy != ps) {</a>
<a name="ln1125">        /* made a copy of &quot;pat&quot; to change &quot;\?&quot; to &quot;?&quot; */</a>
<a name="ln1126">        searchcmdlen += (int)(STRLEN(pat) - STRLEN(strcopy));</a>
<a name="ln1127">        pat = strcopy;</a>
<a name="ln1128">        searchstr = strcopy;</a>
<a name="ln1129">      }</a>
<a name="ln1130">      if (*p == search_delim) {</a>
<a name="ln1131">        dircp = p;              // remember where we put the NUL</a>
<a name="ln1132">        *p++ = NUL;</a>
<a name="ln1133">      }</a>
<a name="ln1134">      spats[0].off.line = FALSE;</a>
<a name="ln1135">      spats[0].off.end = FALSE;</a>
<a name="ln1136">      spats[0].off.off = 0;</a>
<a name="ln1137">      // Check for a line offset or a character offset.</a>
<a name="ln1138">      // For get_address (echo off) we don't check for a character</a>
<a name="ln1139">      // offset, because it is meaningless and the 's' could be a</a>
<a name="ln1140">      // substitute command.</a>
<a name="ln1141">      if (*p == '+' || *p == '-' || ascii_isdigit(*p)) {</a>
<a name="ln1142">        spats[0].off.line = true;</a>
<a name="ln1143">      } else if ((options &amp; SEARCH_OPT)</a>
<a name="ln1144">                 &amp;&amp; (*p == 'e' || *p == 's' || *p == 'b')) {</a>
<a name="ln1145">        if (*p == 'e') {  // end</a>
<a name="ln1146">          spats[0].off.end = true;</a>
<a name="ln1147">        }</a>
<a name="ln1148">        p++;</a>
<a name="ln1149">      }</a>
<a name="ln1150">      if (ascii_isdigit(*p) || *p == '+' || *p == '-') {      /* got an offset */</a>
<a name="ln1151">        /* 'nr' or '+nr' or '-nr' */</a>
<a name="ln1152">        if (ascii_isdigit(*p) || ascii_isdigit(*(p + 1)))</a>
<a name="ln1153">          spats[0].off.off = atol((char *)p);</a>
<a name="ln1154">        else if (*p == '-')                 /* single '-' */</a>
<a name="ln1155">          spats[0].off.off = -1;</a>
<a name="ln1156">        else                                /* single '+' */</a>
<a name="ln1157">          spats[0].off.off = 1;</a>
<a name="ln1158">        ++p;</a>
<a name="ln1159">        while (ascii_isdigit(*p))           /* skip number */</a>
<a name="ln1160">          ++p;</a>
<a name="ln1161">      }</a>
<a name="ln1162"> </a>
<a name="ln1163">      /* compute length of search command for get_address() */</a>
<a name="ln1164">      searchcmdlen += (int)(p - pat);</a>
<a name="ln1165"> </a>
<a name="ln1166">      pat = p;                              /* put pat after search command */</a>
<a name="ln1167">    }</a>
<a name="ln1168"> </a>
<a name="ln1169">    if ((options &amp; SEARCH_ECHO) &amp;&amp; messaging() &amp;&amp; !msg_silent</a>
<a name="ln1170">        &amp;&amp; (!cmd_silent || !shortmess(SHM_SEARCHCOUNT))) {</a>
<a name="ln1171">      char_u      *trunc;</a>
<a name="ln1172">      char_u      off_buf[40];</a>
<a name="ln1173">      size_t      off_len = 0;</a>
<a name="ln1174"> </a>
<a name="ln1175">      // Compute msg_row early.</a>
<a name="ln1176">      msg_start();</a>
<a name="ln1177"> </a>
<a name="ln1178">      // Get the offset, so we know how long it is.</a>
<a name="ln1179">      if (!cmd_silent</a>
<a name="ln1180">          &amp;&amp; (spats[0].off.line || spats[0].off.end || spats[0].off.off)) {</a>
<a name="ln1181">        p = off_buf;  // -V507</a>
<a name="ln1182">        *p++ = dirc;</a>
<a name="ln1183">        if (spats[0].off.end) {</a>
<a name="ln1184">          *p++ = 'e';</a>
<a name="ln1185">        } else if (!spats[0].off.line) {</a>
<a name="ln1186">          *p++ = 's';</a>
<a name="ln1187">        }</a>
<a name="ln1188">        if (spats[0].off.off &gt; 0 || spats[0].off.line) {</a>
<a name="ln1189">          *p++ = '+';</a>
<a name="ln1190">        }</a>
<a name="ln1191">        *p = NUL;</a>
<a name="ln1192">        if (spats[0].off.off != 0 || spats[0].off.line) {</a>
<a name="ln1193">          snprintf((char *)p, sizeof(off_buf) - 1 - (p - off_buf),</a>
<a name="ln1194">                   &quot;%&quot; PRId64, spats[0].off.off);</a>
<a name="ln1195">        }</a>
<a name="ln1196">        off_len = STRLEN(off_buf);</a>
<a name="ln1197">      }</a>
<a name="ln1198"> </a>
<a name="ln1199">      if (*searchstr == NUL) {</a>
<a name="ln1200">        p = spats[0].pat;</a>
<a name="ln1201">      } else {</a>
<a name="ln1202">        p = searchstr;</a>
<a name="ln1203">      }</a>
<a name="ln1204"> </a>
<a name="ln1205">      if (!shortmess(SHM_SEARCHCOUNT) || cmd_silent) {</a>
<a name="ln1206">        // Reserve enough space for the search pattern + offset +</a>
<a name="ln1207">        // search stat.  Use all the space available, so that the</a>
<a name="ln1208">        // search state is right aligned.  If there is not enough space</a>
<a name="ln1209">        // msg_strtrunc() will shorten in the middle.</a>
<a name="ln1210">        if (ui_has(kUIMessages)) {</a>
<a name="ln1211">          len = 0;  // adjusted below</a>
<a name="ln1212">        } else if (msg_scrolled != 0 &amp;&amp; !cmd_silent) {</a>
<a name="ln1213">          // Use all the columns.</a>
<a name="ln1214">          len = (Rows - msg_row) * Columns - 1;</a>
<a name="ln1215">        } else {</a>
<a name="ln1216">          // Use up to 'showcmd' column.</a>
<a name="ln1217">          len = (Rows - msg_row - 1) * Columns + sc_col - 1;</a>
<a name="ln1218">        }</a>
<a name="ln1219">        if (len &lt; STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3) {</a>
<a name="ln1220">          len = STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3;</a>
<a name="ln1221">        }</a>
<a name="ln1222">      } else {</a>
<a name="ln1223">        // Reserve enough space for the search pattern + offset.</a>
<a name="ln1224">        len = STRLEN(p) + off_len + 3;</a>
<a name="ln1225">      }</a>
<a name="ln1226"> </a>
<a name="ln1227">      xfree(msgbuf);</a>
<a name="ln1228">      msgbuf = xmalloc(len);</a>
<a name="ln1229">      memset(msgbuf, ' ', len);</a>
<a name="ln1230">      msgbuf[len - 1] = NUL;</a>
<a name="ln1231"> </a>
<a name="ln1232">      // do not fill the msgbuf buffer, if cmd_silent is set, leave it</a>
<a name="ln1233">      // empty for the search_stat feature.</a>
<a name="ln1234">      if (!cmd_silent) {</a>
<a name="ln1235">        msgbuf[0] = dirc;</a>
<a name="ln1236">        if (utf_iscomposing(utf_ptr2char(p))) {</a>
<a name="ln1237">          // Use a space to draw the composing char on.</a>
<a name="ln1238">          msgbuf[1] = ' ';</a>
<a name="ln1239">          memmove(msgbuf + 2, p, STRLEN(p));</a>
<a name="ln1240">        } else {</a>
<a name="ln1241">          memmove(msgbuf + 1, p, STRLEN(p));</a>
<a name="ln1242">        }</a>
<a name="ln1243">        if (off_len &gt; 0) {</a>
<a name="ln1244">          memmove(msgbuf + STRLEN(p) + 1, off_buf, off_len);</a>
<a name="ln1245">        }</a>
<a name="ln1246"> </a>
<a name="ln1247">        trunc = msg_strtrunc(msgbuf, true);</a>
<a name="ln1248">        if (trunc != NULL) {</a>
<a name="ln1249">          xfree(msgbuf);</a>
<a name="ln1250">          msgbuf = trunc;</a>
<a name="ln1251">        }</a>
<a name="ln1252"> </a>
<a name="ln1253">        // The search pattern could be shown on the right in rightleft</a>
<a name="ln1254">        // mode, but the 'ruler' and 'showcmd' area use it too, thus</a>
<a name="ln1255">        // it would be blanked out again very soon.  Show it on the</a>
<a name="ln1256">        // left, but do reverse the text.</a>
<a name="ln1257">        if (curwin-&gt;w_p_rl &amp;&amp; *curwin-&gt;w_p_rlc == 's') {</a>
<a name="ln1258">          char_u *r = reverse_text(trunc != NULL ? trunc : msgbuf);</a>
<a name="ln1259">          xfree(msgbuf);</a>
<a name="ln1260">          msgbuf = r;</a>
<a name="ln1261">          // move reversed text to beginning of buffer</a>
<a name="ln1262">          while (*r == ' ') {</a>
<a name="ln1263">            r++;</a>
<a name="ln1264">          }</a>
<a name="ln1265">          size_t pat_len = msgbuf + STRLEN(msgbuf) - r;</a>
<a name="ln1266">          memmove(msgbuf, r, pat_len);</a>
<a name="ln1267">          // overwrite old text</a>
<a name="ln1268">          if ((size_t)(r - msgbuf) &gt;= pat_len) {</a>
<a name="ln1269">            memset(r, ' ', pat_len);</a>
<a name="ln1270">          } else {</a>
<a name="ln1271">            memset(msgbuf + pat_len, ' ', r - msgbuf);</a>
<a name="ln1272">          }</a>
<a name="ln1273">        }</a>
<a name="ln1274">        msg_outtrans(msgbuf);</a>
<a name="ln1275">        msg_clr_eos();</a>
<a name="ln1276">        msg_check();</a>
<a name="ln1277"> </a>
<a name="ln1278">        gotocmdline(false);</a>
<a name="ln1279">        ui_flush();</a>
<a name="ln1280">        msg_nowait = true;  // don't wait for this message</a>
<a name="ln1281">      }</a>
<a name="ln1282">    }</a>
<a name="ln1283"> </a>
<a name="ln1284">    /*</a>
<a name="ln1285">     * If there is a character offset, subtract it from the current</a>
<a name="ln1286">     * position, so we don't get stuck at &quot;?pat?e+2&quot; or &quot;/pat/s-2&quot;.</a>
<a name="ln1287">     * Skip this if pos.col is near MAXCOL (closed fold).</a>
<a name="ln1288">     * This is not done for a line offset, because then we would not be vi</a>
<a name="ln1289">     * compatible.</a>
<a name="ln1290">     */</a>
<a name="ln1291">    if (!spats[0].off.line &amp;&amp; spats[0].off.off &amp;&amp; pos.col &lt; MAXCOL - 2) {</a>
<a name="ln1292">      if (spats[0].off.off &gt; 0) {</a>
<a name="ln1293">        for (c = spats[0].off.off; c; --c)</a>
<a name="ln1294">          if (decl(&amp;pos) == -1)</a>
<a name="ln1295">            break;</a>
<a name="ln1296">        if (c) {                        /* at start of buffer */</a>
<a name="ln1297">          pos.lnum = 0;                 /* allow lnum == 0 here */</a>
<a name="ln1298">          pos.col = MAXCOL;</a>
<a name="ln1299">        }</a>
<a name="ln1300">      } else {</a>
<a name="ln1301">        for (c = spats[0].off.off; c; ++c)</a>
<a name="ln1302">          if (incl(&amp;pos) == -1)</a>
<a name="ln1303">            break;</a>
<a name="ln1304">        if (c) {                        /* at end of buffer */</a>
<a name="ln1305">          pos.lnum = curbuf-&gt;b_ml.ml_line_count + 1;</a>
<a name="ln1306">          pos.col = 0;</a>
<a name="ln1307">        }</a>
<a name="ln1308">      }</a>
<a name="ln1309">    }</a>
<a name="ln1310"> </a>
<a name="ln1311">    c = searchit(curwin, curbuf, &amp;pos, NULL, dirc == '/' ? FORWARD : BACKWARD,</a>
<a name="ln1312">                 searchstr, count,</a>
<a name="ln1313">                 (spats[0].off.end * SEARCH_END</a>
<a name="ln1314">                  + (options</a>
<a name="ln1315">                     &amp; (SEARCH_KEEP + SEARCH_PEEK + SEARCH_HIS + SEARCH_MSG</a>
<a name="ln1316">                        + SEARCH_START</a>
<a name="ln1317">                        + ((pat != NULL &amp;&amp; *pat == ';') ? 0 : SEARCH_NOOF)))),</a>
<a name="ln1318">                 RE_LAST, sia);</a>
<a name="ln1319"> </a>
<a name="ln1320">    if (dircp != NULL) {</a>
<a name="ln1321">      *dircp = search_delim;  // restore second '/' or '?' for normal_cmd()</a>
<a name="ln1322">    }</a>
<a name="ln1323"> </a>
<a name="ln1324">    if (!shortmess(SHM_SEARCH)</a>
<a name="ln1325">        &amp;&amp; ((dirc == '/' &amp;&amp; lt(pos, curwin-&gt;w_cursor))</a>
<a name="ln1326">            || (dirc == '?' &amp;&amp; lt(curwin-&gt;w_cursor, pos)))) {</a>
<a name="ln1327">      show_top_bot_msg = true;</a>
<a name="ln1328">    }</a>
<a name="ln1329"> </a>
<a name="ln1330">    if (c == FAIL) {</a>
<a name="ln1331">      retval = 0;</a>
<a name="ln1332">      goto end_do_search;</a>
<a name="ln1333">    }</a>
<a name="ln1334">    if (spats[0].off.end &amp;&amp; oap != NULL)</a>
<a name="ln1335">      oap-&gt;inclusive = true;        /* 'e' includes last character */</a>
<a name="ln1336"> </a>
<a name="ln1337">    retval = 1;                     /* pattern found */</a>
<a name="ln1338"> </a>
<a name="ln1339">    /*</a>
<a name="ln1340">     * Add character and/or line offset</a>
<a name="ln1341">     */</a>
<a name="ln1342">    if (!(options &amp; SEARCH_NOOF) || (pat != NULL &amp;&amp; *pat == ';')) {</a>
<a name="ln1343">      pos_T org_pos = pos;</a>
<a name="ln1344"> </a>
<a name="ln1345">      if (spats[0].off.line) {  // Add the offset to the line number.</a>
<a name="ln1346">        c = pos.lnum + spats[0].off.off;</a>
<a name="ln1347">        if (c &lt; 1)</a>
<a name="ln1348">          pos.lnum = 1;</a>
<a name="ln1349">        else if (c &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln1350">          pos.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1351">        else</a>
<a name="ln1352">          pos.lnum = c;</a>
<a name="ln1353">        pos.col = 0;</a>
<a name="ln1354"> </a>
<a name="ln1355">        retval = 2;                 /* pattern found, line offset added */</a>
<a name="ln1356">      } else if (pos.col &lt; MAXCOL - 2) {      /* just in case */</a>
<a name="ln1357">        /* to the right, check for end of file */</a>
<a name="ln1358">        c = spats[0].off.off;</a>
<a name="ln1359">        if (c &gt; 0) {</a>
<a name="ln1360">          while (c-- &gt; 0)</a>
<a name="ln1361">            if (incl(&amp;pos) == -1)</a>
<a name="ln1362">              break;</a>
<a name="ln1363">        }</a>
<a name="ln1364">        /* to the left, check for start of file */</a>
<a name="ln1365">        else {</a>
<a name="ln1366">          while (c++ &lt; 0)</a>
<a name="ln1367">            if (decl(&amp;pos) == -1)</a>
<a name="ln1368">              break;</a>
<a name="ln1369">        }</a>
<a name="ln1370">      }</a>
<a name="ln1371">      if (!equalpos(pos, org_pos)) {</a>
<a name="ln1372">        has_offset = true;</a>
<a name="ln1373">      }</a>
<a name="ln1374">    }</a>
<a name="ln1375"> </a>
<a name="ln1376">    // Show [1/15] if 'S' is not in 'shortmess'.</a>
<a name="ln1377">    if ((options &amp; SEARCH_ECHO)</a>
<a name="ln1378">        &amp;&amp; messaging()</a>
<a name="ln1379">        &amp;&amp; !msg_silent</a>
<a name="ln1380">        &amp;&amp; c != FAIL</a>
<a name="ln1381">        &amp;&amp; !shortmess(SHM_SEARCHCOUNT)</a>
<a name="ln1382">        &amp;&amp; msgbuf != NULL) {</a>
<a name="ln1383">      cmdline_search_stat(dirc, &amp;pos, &amp;curwin-&gt;w_cursor,</a>
<a name="ln1384">                          show_top_bot_msg, msgbuf,</a>
<a name="ln1385">                          (count != 1 || has_offset</a>
<a name="ln1386">                           || (!(fdo_flags &amp; FDO_SEARCH)</a>
<a name="ln1387">                               &amp;&amp; hasFolding(curwin-&gt;w_cursor.lnum, NULL,</a>
<a name="ln1388">                                             NULL))),</a>
<a name="ln1389">                          SEARCH_STAT_DEF_MAX_COUNT,</a>
<a name="ln1390">                          SEARCH_STAT_DEF_TIMEOUT);</a>
<a name="ln1391">    }</a>
<a name="ln1392"> </a>
<a name="ln1393">    // The search command can be followed by a ';' to do another search.</a>
<a name="ln1394">    // For example: &quot;/pat/;/foo/+3;?bar&quot;</a>
<a name="ln1395">    // This is like doing another search command, except:</a>
<a name="ln1396">    // - The remembered direction '/' or '?' is from the first search.</a>
<a name="ln1397">    // - When an error happens the cursor isn't moved at all.</a>
<a name="ln1398">    // Don't do this when called by get_address() (it handles ';' itself).</a>
<a name="ln1399">    if (!(options &amp; SEARCH_OPT) || pat == NULL || *pat != ';') {</a>
<a name="ln1400">      break;</a>
<a name="ln1401">    }</a>
<a name="ln1402"> </a>
<a name="ln1403">    dirc = *++pat;</a>
<a name="ln1404">    search_delim = dirc;</a>
<a name="ln1405">    if (dirc != '?' &amp;&amp; dirc != '/') {</a>
<a name="ln1406">      retval = 0;</a>
<a name="ln1407">      EMSG(_(&quot;E386: Expected '?' or '/'  after ';'&quot;));</a>
<a name="ln1408">      goto end_do_search;</a>
<a name="ln1409">    }</a>
<a name="ln1410">    ++pat;</a>
<a name="ln1411">  }</a>
<a name="ln1412"> </a>
<a name="ln1413">  if (options &amp; SEARCH_MARK)</a>
<a name="ln1414">    setpcmark();</a>
<a name="ln1415">  curwin-&gt;w_cursor = pos;</a>
<a name="ln1416">  curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln1417"> </a>
<a name="ln1418">end_do_search:</a>
<a name="ln1419">  if ((options &amp; SEARCH_KEEP) || cmdmod.keeppatterns)</a>
<a name="ln1420">    spats[0].off = old_off;</a>
<a name="ln1421">  xfree(msgbuf);</a>
<a name="ln1422"> </a>
<a name="ln1423">  return retval;</a>
<a name="ln1424">}</a>
<a name="ln1425"> </a>
<a name="ln1426">/*</a>
<a name="ln1427"> * search_for_exact_line(buf, pos, dir, pat)</a>
<a name="ln1428"> *</a>
<a name="ln1429"> * Search for a line starting with the given pattern (ignoring leading</a>
<a name="ln1430"> * white-space), starting from pos and going in direction &quot;dir&quot;. &quot;pos&quot; will</a>
<a name="ln1431"> * contain the position of the match found.    Blank lines match only if</a>
<a name="ln1432"> * ADDING is set.  If p_ic is set then the pattern must be in lowercase.</a>
<a name="ln1433"> * Return OK for success, or FAIL if no line found.</a>
<a name="ln1434"> */</a>
<a name="ln1435">int search_for_exact_line(buf_T *buf, pos_T *pos, Direction dir, char_u *pat)</a>
<a name="ln1436">{</a>
<a name="ln1437">  linenr_T start = 0;</a>
<a name="ln1438">  char_u      *ptr;</a>
<a name="ln1439">  char_u      *p;</a>
<a name="ln1440"> </a>
<a name="ln1441">  if (buf-&gt;b_ml.ml_line_count == 0)</a>
<a name="ln1442">    return FAIL;</a>
<a name="ln1443">  for (;; ) {</a>
<a name="ln1444">    pos-&gt;lnum += dir;</a>
<a name="ln1445">    if (pos-&gt;lnum &lt; 1) {</a>
<a name="ln1446">      if (p_ws) {</a>
<a name="ln1447">        pos-&gt;lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln1448">        if (!shortmess(SHM_SEARCH))</a>
<a name="ln1449">          give_warning((char_u *)_(top_bot_msg), true);</a>
<a name="ln1450">      } else {</a>
<a name="ln1451">        pos-&gt;lnum = 1;</a>
<a name="ln1452">        break;</a>
<a name="ln1453">      }</a>
<a name="ln1454">    } else if (pos-&gt;lnum &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1455">      if (p_ws) {</a>
<a name="ln1456">        pos-&gt;lnum = 1;</a>
<a name="ln1457">        if (!shortmess(SHM_SEARCH))</a>
<a name="ln1458">          give_warning((char_u *)_(bot_top_msg), true);</a>
<a name="ln1459">      } else {</a>
<a name="ln1460">        pos-&gt;lnum = 1;</a>
<a name="ln1461">        break;</a>
<a name="ln1462">      }</a>
<a name="ln1463">    }</a>
<a name="ln1464">    if (pos-&gt;lnum == start)</a>
<a name="ln1465">      break;</a>
<a name="ln1466">    if (start == 0)</a>
<a name="ln1467">      start = pos-&gt;lnum;</a>
<a name="ln1468">    ptr = ml_get_buf(buf, pos-&gt;lnum, FALSE);</a>
<a name="ln1469">    p = skipwhite(ptr);</a>
<a name="ln1470">    pos-&gt;col = (colnr_T) (p - ptr);</a>
<a name="ln1471"> </a>
<a name="ln1472">    /* when adding lines the matching line may be empty but it is not</a>
<a name="ln1473">     * ignored because we are interested in the next line -- Acevedo */</a>
<a name="ln1474">    if ((compl_cont_status &amp; CONT_ADDING)</a>
<a name="ln1475">        &amp;&amp; !(compl_cont_status &amp; CONT_SOL)) {</a>
<a name="ln1476">      if (mb_strcmp_ic((bool)p_ic, (const char *)p, (const char *)pat) == 0) {</a>
<a name="ln1477">        return OK;</a>
<a name="ln1478">      }</a>
<a name="ln1479">    } else if (*p != NUL) {  // Ignore empty lines.</a>
<a name="ln1480">      // Expanding lines or words.</a>
<a name="ln1481">      assert(compl_length &gt;= 0);</a>
<a name="ln1482">      if ((p_ic ? mb_strnicmp(p, pat, (size_t)compl_length)</a>
<a name="ln1483">           : STRNCMP(p, pat, compl_length)) == 0)</a>
<a name="ln1484">        return OK;</a>
<a name="ln1485">    }</a>
<a name="ln1486">  }</a>
<a name="ln1487">  return FAIL;</a>
<a name="ln1488">}</a>
<a name="ln1489"> </a>
<a name="ln1490">/*</a>
<a name="ln1491"> * Character Searches</a>
<a name="ln1492"> */</a>
<a name="ln1493"> </a>
<a name="ln1494">/*</a>
<a name="ln1495"> * Search for a character in a line.  If &quot;t_cmd&quot; is FALSE, move to the</a>
<a name="ln1496"> * position of the character, otherwise move to just before the char.</a>
<a name="ln1497"> * Do this &quot;cap-&gt;count1&quot; times.</a>
<a name="ln1498"> * Return FAIL or OK.</a>
<a name="ln1499"> */</a>
<a name="ln1500">int searchc(cmdarg_T *cap, int t_cmd)</a>
<a name="ln1501">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1502">{</a>
<a name="ln1503">  int c = cap-&gt;nchar;                   // char to search for</a>
<a name="ln1504">  Direction dir = cap-&gt;arg;             // TRUE for searching forward</a>
<a name="ln1505">  long count = cap-&gt;count1;             // repeat count</a>
<a name="ln1506">  int col;</a>
<a name="ln1507">  char_u              *p;</a>
<a name="ln1508">  int len;</a>
<a name="ln1509">  int stop = TRUE;</a>
<a name="ln1510"> </a>
<a name="ln1511">  if (c != NUL) {       /* normal search: remember args for repeat */</a>
<a name="ln1512">    if (!KeyStuffed) {      /* don't remember when redoing */</a>
<a name="ln1513">      *lastc = c;</a>
<a name="ln1514">      set_csearch_direction(dir);</a>
<a name="ln1515">      set_csearch_until(t_cmd);</a>
<a name="ln1516">      lastc_bytelen = utf_char2bytes(c, lastc_bytes);</a>
<a name="ln1517">      if (cap-&gt;ncharC1 != 0) {</a>
<a name="ln1518">        lastc_bytelen += utf_char2bytes(cap-&gt;ncharC1,</a>
<a name="ln1519">                                        lastc_bytes + lastc_bytelen);</a>
<a name="ln1520">        if (cap-&gt;ncharC2 != 0) {</a>
<a name="ln1521">          lastc_bytelen += utf_char2bytes(cap-&gt;ncharC2,</a>
<a name="ln1522">                                          lastc_bytes + lastc_bytelen);</a>
<a name="ln1523">        }</a>
<a name="ln1524">      }</a>
<a name="ln1525">    }</a>
<a name="ln1526">  } else {            // repeat previous search</a>
<a name="ln1527">    if (*lastc == NUL &amp;&amp; lastc_bytelen == 1) {</a>
<a name="ln1528">      return FAIL;</a>
<a name="ln1529">    }</a>
<a name="ln1530">    if (dir) {        // repeat in opposite direction</a>
<a name="ln1531">      dir = -lastcdir;</a>
<a name="ln1532">    } else {</a>
<a name="ln1533">      dir = lastcdir;</a>
<a name="ln1534">    }</a>
<a name="ln1535">    t_cmd = last_t_cmd;</a>
<a name="ln1536">    c = *lastc;</a>
<a name="ln1537">    /* For multi-byte re-use last lastc_bytes[] and lastc_bytelen. */</a>
<a name="ln1538"> </a>
<a name="ln1539">    /* Force a move of at least one char, so &quot;;&quot; and &quot;,&quot; will move the</a>
<a name="ln1540">     * cursor, even if the cursor is right in front of char we are looking</a>
<a name="ln1541">     * at. */</a>
<a name="ln1542">    if (vim_strchr(p_cpo, CPO_SCOLON) == NULL &amp;&amp; count == 1 &amp;&amp; t_cmd)</a>
<a name="ln1543">      stop = FALSE;</a>
<a name="ln1544">  }</a>
<a name="ln1545"> </a>
<a name="ln1546">  if (dir == BACKWARD)</a>
<a name="ln1547">    cap-&gt;oap-&gt;inclusive = false;</a>
<a name="ln1548">  else</a>
<a name="ln1549">    cap-&gt;oap-&gt;inclusive = true;</a>
<a name="ln1550"> </a>
<a name="ln1551">  p = get_cursor_line_ptr();</a>
<a name="ln1552">  col = curwin-&gt;w_cursor.col;</a>
<a name="ln1553">  len = (int)STRLEN(p);</a>
<a name="ln1554"> </a>
<a name="ln1555">  while (count--) {</a>
<a name="ln1556">    for (;; ) {</a>
<a name="ln1557">      if (dir &gt; 0) {</a>
<a name="ln1558">        col += utfc_ptr2len(p + col);</a>
<a name="ln1559">        if (col &gt;= len) {</a>
<a name="ln1560">          return FAIL;</a>
<a name="ln1561">        }</a>
<a name="ln1562">      } else {</a>
<a name="ln1563">        if (col == 0) {</a>
<a name="ln1564">          return FAIL;</a>
<a name="ln1565">        }</a>
<a name="ln1566">        col -= utf_head_off(p, p + col - 1) + 1;</a>
<a name="ln1567">      }</a>
<a name="ln1568">      if (lastc_bytelen == 1) {</a>
<a name="ln1569">        if (p[col] == c &amp;&amp; stop) {</a>
<a name="ln1570">          break;</a>
<a name="ln1571">        }</a>
<a name="ln1572">      } else if (STRNCMP(p + col, lastc_bytes, lastc_bytelen) == 0 &amp;&amp; stop) {</a>
<a name="ln1573">        break;</a>
<a name="ln1574">      }</a>
<a name="ln1575">      stop = true;</a>
<a name="ln1576">    }</a>
<a name="ln1577">  }</a>
<a name="ln1578"> </a>
<a name="ln1579">  if (t_cmd) {</a>
<a name="ln1580">    // Backup to before the character (possibly double-byte).</a>
<a name="ln1581">    col -= dir;</a>
<a name="ln1582">    if (dir &lt; 0) {</a>
<a name="ln1583">      // Landed on the search char which is lastc_bytelen long.</a>
<a name="ln1584">      col += lastc_bytelen - 1;</a>
<a name="ln1585">    } else {</a>
<a name="ln1586">      // To previous char, which may be multi-byte.</a>
<a name="ln1587">      col -= utf_head_off(p, p + col);</a>
<a name="ln1588">    }</a>
<a name="ln1589">  }</a>
<a name="ln1590">  curwin-&gt;w_cursor.col = col;</a>
<a name="ln1591"> </a>
<a name="ln1592">  return OK;</a>
<a name="ln1593">}</a>
<a name="ln1594"> </a>
<a name="ln1595">/*</a>
<a name="ln1596"> * &quot;Other&quot; Searches</a>
<a name="ln1597"> */</a>
<a name="ln1598"> </a>
<a name="ln1599">/*</a>
<a name="ln1600"> * findmatch - find the matching paren or brace</a>
<a name="ln1601"> *</a>
<a name="ln1602"> * Improvement over vi: Braces inside quotes are ignored.</a>
<a name="ln1603"> */</a>
<a name="ln1604">pos_T *findmatch(oparg_T *oap, int initc)</a>
<a name="ln1605">{</a>
<a name="ln1606">  return findmatchlimit(oap, initc, 0, 0);</a>
<a name="ln1607">}</a>
<a name="ln1608"> </a>
<a name="ln1609">// Return true if the character before &quot;linep[col]&quot; equals &quot;ch&quot;.</a>
<a name="ln1610">// Return false if &quot;col&quot; is zero.</a>
<a name="ln1611">// Update &quot;*prevcol&quot; to the column of the previous character, unless &quot;prevcol&quot;</a>
<a name="ln1612">// is NULL.</a>
<a name="ln1613">// Handles multibyte string correctly.</a>
<a name="ln1614">static bool check_prevcol(char_u *linep, int col, int ch, int *prevcol)</a>
<a name="ln1615">{</a>
<a name="ln1616">  col--;</a>
<a name="ln1617">  if (col &gt; 0) {</a>
<a name="ln1618">    col -= utf_head_off(linep, linep + col);</a>
<a name="ln1619">  }</a>
<a name="ln1620">  if (prevcol) {</a>
<a name="ln1621">    *prevcol = col;</a>
<a name="ln1622">  }</a>
<a name="ln1623">  return (col &gt;= 0 &amp;&amp; linep[col] == ch) ? true : false;</a>
<a name="ln1624">}</a>
<a name="ln1625"> </a>
<a name="ln1626">/*</a>
<a name="ln1627"> * Raw string start is found at linep[startpos.col - 1].</a>
<a name="ln1628"> * Return true if the matching end can be found between startpos and endpos.</a>
<a name="ln1629"> */</a>
<a name="ln1630">static bool find_rawstring_end(char_u *linep, pos_T *startpos, pos_T *endpos)</a>
<a name="ln1631">{</a>
<a name="ln1632">  char_u *p;</a>
<a name="ln1633">  char_u *delim_copy;</a>
<a name="ln1634">  size_t delim_len;</a>
<a name="ln1635">  linenr_T lnum;</a>
<a name="ln1636"> </a>
<a name="ln1637">  for (p = linep + startpos-&gt;col + 1; *p &amp;&amp; *p != '('; p++) {}</a>
<a name="ln1638"> </a>
<a name="ln1639">  delim_len = (p - linep) - startpos-&gt;col - 1;</a>
<a name="ln1640">  delim_copy = vim_strnsave(linep + startpos-&gt;col + 1, delim_len);</a>
<a name="ln1641">  bool found = false;</a>
<a name="ln1642">  for (lnum = startpos-&gt;lnum; lnum &lt;= endpos-&gt;lnum; lnum++) {</a>
<a name="ln1643">    char_u *line = ml_get(lnum);</a>
<a name="ln1644"> </a>
<a name="ln1645">    for (p = line + (lnum == startpos-&gt;lnum ? startpos-&gt;col + 1 : 0); *p; p++) {</a>
<a name="ln1646">      if (lnum == endpos-&gt;lnum &amp;&amp; (colnr_T)(p - line) &gt;= endpos-&gt;col) {</a>
<a name="ln1647">        break;</a>
<a name="ln1648">      }</a>
<a name="ln1649">      if (*p == ')'</a>
<a name="ln1650">          &amp;&amp; STRNCMP(delim_copy, p + 1, delim_len) == 0</a>
<a name="ln1651">          &amp;&amp; p[delim_len + 1] == '&quot;') {</a>
<a name="ln1652">        found = true;</a>
<a name="ln1653">        break;</a>
<a name="ln1654">      }</a>
<a name="ln1655">    }</a>
<a name="ln1656">    if (found) {</a>
<a name="ln1657">      break;</a>
<a name="ln1658">    }</a>
<a name="ln1659">  }</a>
<a name="ln1660">  xfree(delim_copy);</a>
<a name="ln1661">  return found;</a>
<a name="ln1662">}</a>
<a name="ln1663"> </a>
<a name="ln1664">/// Check matchpairs option for &quot;*initc&quot;.</a>
<a name="ln1665">/// If there is a match set &quot;*initc&quot; to the matching character and &quot;*findc&quot; to</a>
<a name="ln1666">/// the opposite character.  Set &quot;*backwards&quot; to the direction.</a>
<a name="ln1667">/// When &quot;switchit&quot; is true swap the direction.</a>
<a name="ln1668">static void find_mps_values(int *initc, int *findc, bool *backwards,</a>
<a name="ln1669">                            bool switchit)</a>
<a name="ln1670">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1671">{</a>
<a name="ln1672">  char_u *ptr = curbuf-&gt;b_p_mps;</a>
<a name="ln1673"> </a>
<a name="ln1674">  while (*ptr != NUL) {</a>
<a name="ln1675">    if (utf_ptr2char(ptr) == *initc) {</a>
<a name="ln1676">      if (switchit) {</a>
<a name="ln1677">        *findc = *initc;</a>
<a name="ln1678">        *initc = utf_ptr2char(ptr + utfc_ptr2len(ptr) + 1);</a>
<a name="ln1679">        *backwards = true;</a>
<a name="ln1680">      } else {</a>
<a name="ln1681">        *findc = utf_ptr2char(ptr + utfc_ptr2len(ptr) + 1);</a>
<a name="ln1682">        *backwards = false;</a>
<a name="ln1683">      }</a>
<a name="ln1684">      return;</a>
<a name="ln1685">    }</a>
<a name="ln1686">    char_u *prev = ptr;</a>
<a name="ln1687">    ptr += utfc_ptr2len(ptr) + 1;</a>
<a name="ln1688">    if (utf_ptr2char(ptr) == *initc) {</a>
<a name="ln1689">      if (switchit) {</a>
<a name="ln1690">        *findc = *initc;</a>
<a name="ln1691">        *initc = utf_ptr2char(prev);</a>
<a name="ln1692">        *backwards = false;</a>
<a name="ln1693">      } else {</a>
<a name="ln1694">        *findc = utf_ptr2char(prev);</a>
<a name="ln1695">        *backwards = true;</a>
<a name="ln1696">      }</a>
<a name="ln1697">      return;</a>
<a name="ln1698">    }</a>
<a name="ln1699">    ptr += utfc_ptr2len(ptr);</a>
<a name="ln1700">    if (*ptr == ',') {</a>
<a name="ln1701">      ptr++;</a>
<a name="ln1702">    }</a>
<a name="ln1703">  }</a>
<a name="ln1704">}</a>
<a name="ln1705"> </a>
<a name="ln1706">/*</a>
<a name="ln1707"> * findmatchlimit -- find the matching paren or brace, if it exists within</a>
<a name="ln1708"> * maxtravel lines of the cursor.  A maxtravel of 0 means search until falling</a>
<a name="ln1709"> * off the edge of the file.</a>
<a name="ln1710"> *</a>
<a name="ln1711"> * &quot;initc&quot; is the character to find a match for.  NUL means to find the</a>
<a name="ln1712"> * character at or after the cursor. Special values:</a>
<a name="ln1713"> * '*'  look for C-style comment / *</a>
<a name="ln1714"> * '/'  look for C-style comment / *, ignoring comment-end</a>
<a name="ln1715"> * '#'  look for preprocessor directives</a>
<a name="ln1716"> * 'R'  look for raw string start: R&quot;delim(text)delim&quot; (only backwards)</a>
<a name="ln1717"> *</a>
<a name="ln1718"> * flags: FM_BACKWARD search backwards (when initc is '/', '*' or '#')</a>
<a name="ln1719"> *    FM_FORWARD  search forwards (when initc is '/', '*' or '#')</a>
<a name="ln1720"> *    FM_BLOCKSTOP  stop at start/end of block ({ or } in column 0)</a>
<a name="ln1721"> *    FM_SKIPCOMM skip comments (not implemented yet!)</a>
<a name="ln1722"> *</a>
<a name="ln1723"> * &quot;oap&quot; is only used to set oap-&gt;motion_type for a linewise motion, it can be</a>
<a name="ln1724"> * NULL</a>
<a name="ln1725"> */</a>
<a name="ln1726"> </a>
<a name="ln1727">pos_T *findmatchlimit(oparg_T *oap, int initc, int flags, int64_t maxtravel)</a>
<a name="ln1728">{</a>
<a name="ln1729">  static pos_T pos;                     // current search position</a>
<a name="ln1730">  int findc = 0;                        // matching brace</a>
<a name="ln1731">  int count = 0;                        // cumulative number of braces</a>
<a name="ln1732">  bool backwards = false;               // init for gcc</a>
<a name="ln1733">  bool raw_string = false;              // search for raw string</a>
<a name="ln1734">  bool inquote = false;                 // true when inside quotes</a>
<a name="ln1735">  char_u      *ptr;</a>
<a name="ln1736">  int hash_dir = 0;                     // Direction searched for # things</a>
<a name="ln1737">  int comment_dir = 0;                  // Direction searched for comments</a>
<a name="ln1738">  int traveled = 0;                     // how far we've searched so far</a>
<a name="ln1739">  bool ignore_cend = false;             // ignore comment end</a>
<a name="ln1740">  int match_escaped = 0;                // search for escaped match</a>
<a name="ln1741">  int dir;                              // Direction to search</a>
<a name="ln1742">  int comment_col = MAXCOL;             // start of / / comment</a>
<a name="ln1743">  bool lispcomm = false;                // inside of Lisp-style comment</a>
<a name="ln1744">  bool lisp = curbuf-&gt;b_p_lisp;         // engage Lisp-specific hacks ;)</a>
<a name="ln1745"> </a>
<a name="ln1746">  pos = curwin-&gt;w_cursor;</a>
<a name="ln1747">  pos.coladd = 0;</a>
<a name="ln1748">  char_u *linep = ml_get(pos.lnum);     // pointer to current line</a>
<a name="ln1749"> </a>
<a name="ln1750">  // vi compatible matching</a>
<a name="ln1751">  bool cpo_match = (vim_strchr(p_cpo, CPO_MATCH) != NULL);</a>
<a name="ln1752">  // don't recognize backslashes</a>
<a name="ln1753">  bool cpo_bsl = (vim_strchr(p_cpo, CPO_MATCHBSL) != NULL);</a>
<a name="ln1754"> </a>
<a name="ln1755">  /* Direction to search when initc is '/', '*' or '#' */</a>
<a name="ln1756">  if (flags &amp; FM_BACKWARD)</a>
<a name="ln1757">    dir = BACKWARD;</a>
<a name="ln1758">  else if (flags &amp; FM_FORWARD)</a>
<a name="ln1759">    dir = FORWARD;</a>
<a name="ln1760">  else</a>
<a name="ln1761">    dir = 0;</a>
<a name="ln1762"> </a>
<a name="ln1763">  /*</a>
<a name="ln1764">   * if initc given, look in the table for the matching character</a>
<a name="ln1765">   * '/' and '*' are special cases: look for start or end of comment.</a>
<a name="ln1766">   * When '/' is used, we ignore running backwards into a star-slash, for</a>
<a name="ln1767">   * &quot;[*&quot; command, we just want to find any comment.</a>
<a name="ln1768">   */</a>
<a name="ln1769">  if (initc == '/' || initc == '*' || initc == 'R') {</a>
<a name="ln1770">    comment_dir = dir;</a>
<a name="ln1771">    if (initc == '/')</a>
<a name="ln1772">      ignore_cend = true;</a>
<a name="ln1773">    backwards = (dir == FORWARD) ? false : true;</a>
<a name="ln1774">    raw_string = (initc == 'R');</a>
<a name="ln1775">    initc = NUL;</a>
<a name="ln1776">  } else if (initc != '#' &amp;&amp; initc != NUL) {</a>
<a name="ln1777">    find_mps_values(&amp;initc, &amp;findc, &amp;backwards, true);</a>
<a name="ln1778">    if (findc == NUL) {</a>
<a name="ln1779">      return NULL;</a>
<a name="ln1780">    }</a>
<a name="ln1781">  } else {</a>
<a name="ln1782">    /*</a>
<a name="ln1783">     * Either initc is '#', or no initc was given and we need to look</a>
<a name="ln1784">     * under the cursor.</a>
<a name="ln1785">     */</a>
<a name="ln1786">    if (initc == '#') {</a>
<a name="ln1787">      hash_dir = dir;</a>
<a name="ln1788">    } else {</a>
<a name="ln1789">      /*</a>
<a name="ln1790">       * initc was not given, must look for something to match under</a>
<a name="ln1791">       * or near the cursor.</a>
<a name="ln1792">       * Only check for special things when 'cpo' doesn't have '%'.</a>
<a name="ln1793">       */</a>
<a name="ln1794">      if (!cpo_match) {</a>
<a name="ln1795">        /* Are we before or at #if, #else etc.? */</a>
<a name="ln1796">        ptr = skipwhite(linep);</a>
<a name="ln1797">        if (*ptr == '#' &amp;&amp; pos.col &lt;= (colnr_T)(ptr - linep)) {</a>
<a name="ln1798">          ptr = skipwhite(ptr + 1);</a>
<a name="ln1799">          if (   STRNCMP(ptr, &quot;if&quot;, 2) == 0</a>
<a name="ln1800">                 || STRNCMP(ptr, &quot;endif&quot;, 5) == 0</a>
<a name="ln1801">                 || STRNCMP(ptr, &quot;el&quot;, 2) == 0)</a>
<a name="ln1802">            hash_dir = 1;</a>
<a name="ln1803">        }</a>
<a name="ln1804">        /* Are we on a comment? */</a>
<a name="ln1805">        else if (linep[pos.col] == '/') {</a>
<a name="ln1806">          if (linep[pos.col + 1] == '*') {</a>
<a name="ln1807">            comment_dir = FORWARD;</a>
<a name="ln1808">            backwards = false;</a>
<a name="ln1809">            pos.col++;</a>
<a name="ln1810">          } else if (pos.col &gt; 0 &amp;&amp; linep[pos.col - 1] == '*') {</a>
<a name="ln1811">            comment_dir = BACKWARD;</a>
<a name="ln1812">            backwards = true;</a>
<a name="ln1813">            pos.col--;</a>
<a name="ln1814">          }</a>
<a name="ln1815">        } else if (linep[pos.col] == '*') {</a>
<a name="ln1816">          if (linep[pos.col + 1] == '/') {</a>
<a name="ln1817">            comment_dir = BACKWARD;</a>
<a name="ln1818">            backwards = true;</a>
<a name="ln1819">          } else if (pos.col &gt; 0 &amp;&amp; linep[pos.col - 1] == '/') {</a>
<a name="ln1820">            comment_dir = FORWARD;</a>
<a name="ln1821">            backwards = false;</a>
<a name="ln1822">          }</a>
<a name="ln1823">        }</a>
<a name="ln1824">      }</a>
<a name="ln1825"> </a>
<a name="ln1826">      /*</a>
<a name="ln1827">       * If we are not on a comment or the # at the start of a line, then</a>
<a name="ln1828">       * look for brace anywhere on this line after the cursor.</a>
<a name="ln1829">       */</a>
<a name="ln1830">      if (!hash_dir &amp;&amp; !comment_dir) {</a>
<a name="ln1831">        /*</a>
<a name="ln1832">         * Find the brace under or after the cursor.</a>
<a name="ln1833">         * If beyond the end of the line, use the last character in</a>
<a name="ln1834">         * the line.</a>
<a name="ln1835">         */</a>
<a name="ln1836">        if (linep[pos.col] == NUL &amp;&amp; pos.col)</a>
<a name="ln1837">          --pos.col;</a>
<a name="ln1838">        for (;; ) {</a>
<a name="ln1839">          initc = PTR2CHAR(linep + pos.col);</a>
<a name="ln1840">          if (initc == NUL)</a>
<a name="ln1841">            break;</a>
<a name="ln1842"> </a>
<a name="ln1843">          find_mps_values(&amp;initc, &amp;findc, &amp;backwards, false);</a>
<a name="ln1844">          if (findc) {</a>
<a name="ln1845">            break;</a>
<a name="ln1846">          }</a>
<a name="ln1847">          pos.col += utfc_ptr2len(linep + pos.col);</a>
<a name="ln1848">        }</a>
<a name="ln1849">        if (!findc) {</a>
<a name="ln1850">          /* no brace in the line, maybe use &quot;  #if&quot; then */</a>
<a name="ln1851">          if (!cpo_match &amp;&amp; *skipwhite(linep) == '#')</a>
<a name="ln1852">            hash_dir = 1;</a>
<a name="ln1853">          else</a>
<a name="ln1854">            return NULL;</a>
<a name="ln1855">        } else if (!cpo_bsl) {</a>
<a name="ln1856">          int col, bslcnt = 0;</a>
<a name="ln1857"> </a>
<a name="ln1858">          /* Set &quot;match_escaped&quot; if there are an odd number of</a>
<a name="ln1859">           * backslashes. */</a>
<a name="ln1860">          for (col = pos.col; check_prevcol(linep, col, '\\', &amp;col); )</a>
<a name="ln1861">            bslcnt++;</a>
<a name="ln1862">          match_escaped = (bslcnt &amp; 1);</a>
<a name="ln1863">        }</a>
<a name="ln1864">      }</a>
<a name="ln1865">    }</a>
<a name="ln1866">    if (hash_dir) {</a>
<a name="ln1867">      /*</a>
<a name="ln1868">       * Look for matching #if, #else, #elif, or #endif</a>
<a name="ln1869">       */</a>
<a name="ln1870">      if (oap != NULL) {</a>
<a name="ln1871">        oap-&gt;motion_type = kMTLineWise;  // Linewise for this case only</a>
<a name="ln1872">      }</a>
<a name="ln1873">      if (initc != '#') {</a>
<a name="ln1874">        ptr = skipwhite(skipwhite(linep) + 1);</a>
<a name="ln1875">        if (STRNCMP(ptr, &quot;if&quot;, 2) == 0 || STRNCMP(ptr, &quot;el&quot;, 2) == 0)</a>
<a name="ln1876">          hash_dir = 1;</a>
<a name="ln1877">        else if (STRNCMP(ptr, &quot;endif&quot;, 5) == 0)</a>
<a name="ln1878">          hash_dir = -1;</a>
<a name="ln1879">        else</a>
<a name="ln1880">          return NULL;</a>
<a name="ln1881">      }</a>
<a name="ln1882">      pos.col = 0;</a>
<a name="ln1883">      while (!got_int) {</a>
<a name="ln1884">        if (hash_dir &gt; 0) {</a>
<a name="ln1885">          if (pos.lnum == curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln1886">            break;</a>
<a name="ln1887">        } else if (pos.lnum == 1)</a>
<a name="ln1888">          break;</a>
<a name="ln1889">        pos.lnum += hash_dir;</a>
<a name="ln1890">        linep = ml_get(pos.lnum);</a>
<a name="ln1891">        line_breakcheck();              /* check for CTRL-C typed */</a>
<a name="ln1892">        ptr = skipwhite(linep);</a>
<a name="ln1893">        if (*ptr != '#')</a>
<a name="ln1894">          continue;</a>
<a name="ln1895">        pos.col = (colnr_T) (ptr - linep);</a>
<a name="ln1896">        ptr = skipwhite(ptr + 1);</a>
<a name="ln1897">        if (hash_dir &gt; 0) {</a>
<a name="ln1898">          if (STRNCMP(ptr, &quot;if&quot;, 2) == 0)</a>
<a name="ln1899">            count++;</a>
<a name="ln1900">          else if (STRNCMP(ptr, &quot;el&quot;, 2) == 0) {</a>
<a name="ln1901">            if (count == 0)</a>
<a name="ln1902">              return &amp;pos;</a>
<a name="ln1903">          } else if (STRNCMP(ptr, &quot;endif&quot;, 5) == 0) {</a>
<a name="ln1904">            if (count == 0)</a>
<a name="ln1905">              return &amp;pos;</a>
<a name="ln1906">            count--;</a>
<a name="ln1907">          }</a>
<a name="ln1908">        } else {</a>
<a name="ln1909">          if (STRNCMP(ptr, &quot;if&quot;, 2) == 0) {</a>
<a name="ln1910">            if (count == 0)</a>
<a name="ln1911">              return &amp;pos;</a>
<a name="ln1912">            count--;</a>
<a name="ln1913">          } else if (initc == '#' &amp;&amp; STRNCMP(ptr, &quot;el&quot;, 2) == 0) {</a>
<a name="ln1914">            if (count == 0)</a>
<a name="ln1915">              return &amp;pos;</a>
<a name="ln1916">          } else if (STRNCMP(ptr, &quot;endif&quot;, 5) == 0)</a>
<a name="ln1917">            count++;</a>
<a name="ln1918">        }</a>
<a name="ln1919">      }</a>
<a name="ln1920">      return NULL;</a>
<a name="ln1921">    }</a>
<a name="ln1922">  }</a>
<a name="ln1923"> </a>
<a name="ln1924">  // This is just guessing: when 'rightleft' is set, search for a matching</a>
<a name="ln1925">  // paren/brace in the other direction.</a>
<a name="ln1926">  if (curwin-&gt;w_p_rl &amp;&amp; vim_strchr((char_u *)&quot;()[]{}&lt;&gt;&quot;, initc) != NULL) {</a>
<a name="ln1927">    backwards = !backwards;</a>
<a name="ln1928">  }</a>
<a name="ln1929"> </a>
<a name="ln1930">  int do_quotes = -1;                 // check for quotes in current line</a>
<a name="ln1931">  int at_start;                       // do_quotes value at start position</a>
<a name="ln1932">  TriState start_in_quotes = kNone;   // start position is in quotes</a>
<a name="ln1933">  pos_T match_pos;                    // Where last slash-star was found</a>
<a name="ln1934">  clearpos(&amp;match_pos);</a>
<a name="ln1935"> </a>
<a name="ln1936">  /* backward search: Check if this line contains a single-line comment */</a>
<a name="ln1937">  if ((backwards &amp;&amp; comment_dir)</a>
<a name="ln1938">      || lisp</a>
<a name="ln1939">      )</a>
<a name="ln1940">    comment_col = check_linecomment(linep);</a>
<a name="ln1941">  if (lisp &amp;&amp; comment_col != MAXCOL &amp;&amp; pos.col &gt; (colnr_T)comment_col) {</a>
<a name="ln1942">    lispcomm = true;        // find match inside this comment</a>
<a name="ln1943">  }</a>
<a name="ln1944">  while (!got_int) {</a>
<a name="ln1945">    /*</a>
<a name="ln1946">     * Go to the next position, forward or backward. We could use</a>
<a name="ln1947">     * inc() and dec() here, but that is much slower</a>
<a name="ln1948">     */</a>
<a name="ln1949">    if (backwards) {</a>
<a name="ln1950">      /* char to match is inside of comment, don't search outside */</a>
<a name="ln1951">      if (lispcomm &amp;&amp; pos.col &lt; (colnr_T)comment_col)</a>
<a name="ln1952">        break;</a>
<a name="ln1953">      if (pos.col == 0) {               /* at start of line, go to prev. one */</a>
<a name="ln1954">        if (pos.lnum == 1)              /* start of file */</a>
<a name="ln1955">          break;</a>
<a name="ln1956">        --pos.lnum;</a>
<a name="ln1957"> </a>
<a name="ln1958">        if (maxtravel &gt; 0 &amp;&amp; ++traveled &gt; maxtravel)</a>
<a name="ln1959">          break;</a>
<a name="ln1960"> </a>
<a name="ln1961">        linep = ml_get(pos.lnum);</a>
<a name="ln1962">        pos.col = (colnr_T)STRLEN(linep);         /* pos.col on trailing NUL */</a>
<a name="ln1963">        do_quotes = -1;</a>
<a name="ln1964">        line_breakcheck();</a>
<a name="ln1965"> </a>
<a name="ln1966">        /* Check if this line contains a single-line comment */</a>
<a name="ln1967">        if (comment_dir</a>
<a name="ln1968">            || lisp</a>
<a name="ln1969">            )</a>
<a name="ln1970">          comment_col = check_linecomment(linep);</a>
<a name="ln1971">        /* skip comment */</a>
<a name="ln1972">        if (lisp &amp;&amp; comment_col != MAXCOL)</a>
<a name="ln1973">          pos.col = comment_col;</a>
<a name="ln1974">      } else {</a>
<a name="ln1975">        pos.col--;</a>
<a name="ln1976">        pos.col -= utf_head_off(linep, linep + pos.col);</a>
<a name="ln1977">      }</a>
<a name="ln1978">    } else {                          /* forward search */</a>
<a name="ln1979">      if (linep[pos.col] == NUL</a>
<a name="ln1980">          /* at end of line, go to next one */</a>
<a name="ln1981">          /* don't search for match in comment */</a>
<a name="ln1982">          || (lisp &amp;&amp; comment_col != MAXCOL</a>
<a name="ln1983">              &amp;&amp; pos.col == (colnr_T)comment_col)</a>
<a name="ln1984">          ) {</a>
<a name="ln1985">        if (pos.lnum == curbuf-&gt;b_ml.ml_line_count          /* end of file */</a>
<a name="ln1986">            /* line is exhausted and comment with it,</a>
<a name="ln1987">             * don't search for match in code */</a>
<a name="ln1988">            || lispcomm</a>
<a name="ln1989">            )</a>
<a name="ln1990">          break;</a>
<a name="ln1991">        ++pos.lnum;</a>
<a name="ln1992"> </a>
<a name="ln1993">        if (maxtravel &amp;&amp; traveled++ &gt; maxtravel)</a>
<a name="ln1994">          break;</a>
<a name="ln1995"> </a>
<a name="ln1996">        linep = ml_get(pos.lnum);</a>
<a name="ln1997">        pos.col = 0;</a>
<a name="ln1998">        do_quotes = -1;</a>
<a name="ln1999">        line_breakcheck();</a>
<a name="ln2000">        if (lisp)           /* find comment pos in new line */</a>
<a name="ln2001">          comment_col = check_linecomment(linep);</a>
<a name="ln2002">      } else {</a>
<a name="ln2003">        pos.col += utfc_ptr2len(linep + pos.col);</a>
<a name="ln2004">      }</a>
<a name="ln2005">    }</a>
<a name="ln2006"> </a>
<a name="ln2007">    // If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.</a>
<a name="ln2008">    if (pos.col == 0 &amp;&amp; (flags &amp; FM_BLOCKSTOP)</a>
<a name="ln2009">        &amp;&amp; (linep[0] == '{' || linep[0] == '}')) {</a>
<a name="ln2010">      if (linep[0] == findc &amp;&amp; count == 0) {  // match!</a>
<a name="ln2011">        return &amp;pos;</a>
<a name="ln2012">      }</a>
<a name="ln2013">      break;  // out of scope</a>
<a name="ln2014">    }</a>
<a name="ln2015"> </a>
<a name="ln2016">    if (comment_dir) {</a>
<a name="ln2017">      /* Note: comments do not nest, and we ignore quotes in them */</a>
<a name="ln2018">      /* TODO: ignore comment brackets inside strings */</a>
<a name="ln2019">      if (comment_dir == FORWARD) {</a>
<a name="ln2020">        if (linep[pos.col] == '*' &amp;&amp; linep[pos.col + 1] == '/') {</a>
<a name="ln2021">          pos.col++;</a>
<a name="ln2022">          return &amp;pos;</a>
<a name="ln2023">        }</a>
<a name="ln2024">      } else {    /* Searching backwards */</a>
<a name="ln2025">        /*</a>
<a name="ln2026">         * A comment may contain / * or / /, it may also start or end</a>
<a name="ln2027">         * with / * /. Ignore a / * after / / and after *.</a>
<a name="ln2028">         */</a>
<a name="ln2029">        if (pos.col == 0)</a>
<a name="ln2030">          continue;</a>
<a name="ln2031">        else if (raw_string)</a>
<a name="ln2032">        {</a>
<a name="ln2033">          if (linep[pos.col - 1] == 'R'</a>
<a name="ln2034">              &amp;&amp; linep[pos.col] == '&quot;'</a>
<a name="ln2035">              &amp;&amp; vim_strchr(linep + pos.col + 1, '(') != NULL)</a>
<a name="ln2036">          {</a>
<a name="ln2037">            /* Possible start of raw string. Now that we have the</a>
<a name="ln2038">             * delimiter we can check if it ends before where we</a>
<a name="ln2039">             * started searching, or before the previously found</a>
<a name="ln2040">             * raw string start. */</a>
<a name="ln2041">            if (!find_rawstring_end(linep, &amp;pos,</a>
<a name="ln2042">                  count &gt; 0 ? &amp;match_pos : &amp;curwin-&gt;w_cursor))</a>
<a name="ln2043">            {</a>
<a name="ln2044">              count++;</a>
<a name="ln2045">              match_pos = pos;</a>
<a name="ln2046">              match_pos.col--;</a>
<a name="ln2047">            }</a>
<a name="ln2048">            linep = ml_get(pos.lnum); /* may have been released */</a>
<a name="ln2049">          }</a>
<a name="ln2050">        } else if (  linep[pos.col - 1] == '/'</a>
<a name="ln2051">                   &amp;&amp; linep[pos.col] == '*'</a>
<a name="ln2052">                   &amp;&amp; (pos.col == 1 || linep[pos.col - 2] != '*')</a>
<a name="ln2053">                   &amp;&amp; (int)pos.col &lt; comment_col) {</a>
<a name="ln2054">          count++;</a>
<a name="ln2055">          match_pos = pos;</a>
<a name="ln2056">          match_pos.col--;</a>
<a name="ln2057">        } else if (linep[pos.col - 1] == '*' &amp;&amp; linep[pos.col] == '/') {</a>
<a name="ln2058">          if (count &gt; 0)</a>
<a name="ln2059">            pos = match_pos;</a>
<a name="ln2060">          else if (pos.col &gt; 1 &amp;&amp; linep[pos.col - 2] == '/'</a>
<a name="ln2061">                   &amp;&amp; (int)pos.col &lt;= comment_col)</a>
<a name="ln2062">            pos.col -= 2;</a>
<a name="ln2063">          else if (ignore_cend)</a>
<a name="ln2064">            continue;</a>
<a name="ln2065">          else</a>
<a name="ln2066">            return NULL;</a>
<a name="ln2067">          return &amp;pos;</a>
<a name="ln2068">        }</a>
<a name="ln2069">      }</a>
<a name="ln2070">      continue;</a>
<a name="ln2071">    }</a>
<a name="ln2072"> </a>
<a name="ln2073">    /*</a>
<a name="ln2074">     * If smart matching ('cpoptions' does not contain '%'), braces inside</a>
<a name="ln2075">     * of quotes are ignored, but only if there is an even number of</a>
<a name="ln2076">     * quotes in the line.</a>
<a name="ln2077">     */</a>
<a name="ln2078">    if (cpo_match)</a>
<a name="ln2079">      do_quotes = 0;</a>
<a name="ln2080">    else if (do_quotes == -1) {</a>
<a name="ln2081">      /*</a>
<a name="ln2082">       * Count the number of quotes in the line, skipping \&quot; and '&quot;'.</a>
<a name="ln2083">       * Watch out for &quot;\\&quot;.</a>
<a name="ln2084">       */</a>
<a name="ln2085">      at_start = do_quotes;</a>
<a name="ln2086">      for (ptr = linep; *ptr; ++ptr) {</a>
<a name="ln2087">        if (ptr == linep + pos.col + backwards)</a>
<a name="ln2088">          at_start = (do_quotes &amp; 1);</a>
<a name="ln2089">        if (*ptr == '&quot;'</a>
<a name="ln2090">            &amp;&amp; (ptr == linep || ptr[-1] != '\'' || ptr[1] != '\''))</a>
<a name="ln2091">          ++do_quotes;</a>
<a name="ln2092">        if (*ptr == '\\' &amp;&amp; ptr[1] != NUL)</a>
<a name="ln2093">          ++ptr;</a>
<a name="ln2094">      }</a>
<a name="ln2095">      do_quotes &amp;= 1;               /* result is 1 with even number of quotes */</a>
<a name="ln2096"> </a>
<a name="ln2097">      /*</a>
<a name="ln2098">       * If we find an uneven count, check current line and previous</a>
<a name="ln2099">       * one for a '\' at the end.</a>
<a name="ln2100">       */</a>
<a name="ln2101">      if (!do_quotes) {</a>
<a name="ln2102">        inquote = false;</a>
<a name="ln2103">        if (ptr[-1] == '\\') {</a>
<a name="ln2104">          do_quotes = 1;</a>
<a name="ln2105">          if (start_in_quotes == kNone) {</a>
<a name="ln2106">            // Do we need to use at_start here?</a>
<a name="ln2107">            inquote = true;</a>
<a name="ln2108">            start_in_quotes = kTrue;</a>
<a name="ln2109">          } else if (backwards) {</a>
<a name="ln2110">            inquote = true;</a>
<a name="ln2111">          }</a>
<a name="ln2112">        }</a>
<a name="ln2113">        if (pos.lnum &gt; 1) {</a>
<a name="ln2114">          ptr = ml_get(pos.lnum - 1);</a>
<a name="ln2115">          if (*ptr &amp;&amp; *(ptr + STRLEN(ptr) - 1) == '\\') {</a>
<a name="ln2116">            do_quotes = 1;</a>
<a name="ln2117">            if (start_in_quotes == kNone) {</a>
<a name="ln2118">              inquote = at_start;</a>
<a name="ln2119">              if (inquote) {</a>
<a name="ln2120">                start_in_quotes = kTrue;</a>
<a name="ln2121">              }</a>
<a name="ln2122">            } else if (!backwards) {</a>
<a name="ln2123">              inquote = true;</a>
<a name="ln2124">            }</a>
<a name="ln2125">          }</a>
<a name="ln2126"> </a>
<a name="ln2127">          /* ml_get() only keeps one line, need to get linep again */</a>
<a name="ln2128">          linep = ml_get(pos.lnum);</a>
<a name="ln2129">        }</a>
<a name="ln2130">      }</a>
<a name="ln2131">    }</a>
<a name="ln2132">    if (start_in_quotes == kNone) {</a>
<a name="ln2133">      start_in_quotes = kFalse;</a>
<a name="ln2134">    }</a>
<a name="ln2135"> </a>
<a name="ln2136">    /*</a>
<a name="ln2137">     * If 'smartmatch' is set:</a>
<a name="ln2138">     *   Things inside quotes are ignored by setting 'inquote'.  If we</a>
<a name="ln2139">     *   find a quote without a preceding '\' invert 'inquote'.  At the</a>
<a name="ln2140">     *   end of a line not ending in '\' we reset 'inquote'.</a>
<a name="ln2141">     *</a>
<a name="ln2142">     *   In lines with an uneven number of quotes (without preceding '\')</a>
<a name="ln2143">     *   we do not know which part to ignore. Therefore we only set</a>
<a name="ln2144">     *   inquote if the number of quotes in a line is even, unless this</a>
<a name="ln2145">     *   line or the previous one ends in a '\'.  Complicated, isn't it?</a>
<a name="ln2146">     */</a>
<a name="ln2147">    const int c = PTR2CHAR(linep + pos.col);</a>
<a name="ln2148">    switch (c) {</a>
<a name="ln2149">    case NUL:</a>
<a name="ln2150">      /* at end of line without trailing backslash, reset inquote */</a>
<a name="ln2151">      if (pos.col == 0 || linep[pos.col - 1] != '\\') {</a>
<a name="ln2152">        inquote = false;</a>
<a name="ln2153">        start_in_quotes = kFalse;</a>
<a name="ln2154">      }</a>
<a name="ln2155">      break;</a>
<a name="ln2156"> </a>
<a name="ln2157">    case '&quot;':</a>
<a name="ln2158">      /* a quote that is preceded with an odd number of backslashes is</a>
<a name="ln2159">       * ignored */</a>
<a name="ln2160">      if (do_quotes) {</a>
<a name="ln2161">        int col;</a>
<a name="ln2162"> </a>
<a name="ln2163">        for (col = pos.col - 1; col &gt;= 0; --col)</a>
<a name="ln2164">          if (linep[col] != '\\')</a>
<a name="ln2165">            break;</a>
<a name="ln2166">        if ((((int)pos.col - 1 - col) &amp; 1) == 0) {</a>
<a name="ln2167">          inquote = !inquote;</a>
<a name="ln2168">          start_in_quotes = kFalse;</a>
<a name="ln2169">        }</a>
<a name="ln2170">      }</a>
<a name="ln2171">      break;</a>
<a name="ln2172"> </a>
<a name="ln2173">    /*</a>
<a name="ln2174">     * If smart matching ('cpoptions' does not contain '%'):</a>
<a name="ln2175">     *   Skip things in single quotes: 'x' or '\x'.  Be careful for single</a>
<a name="ln2176">     *   single quotes, eg jon's.  Things like '\233' or '\x3f' are not</a>
<a name="ln2177">     *   skipped, there is never a brace in them.</a>
<a name="ln2178">     *   Ignore this when finding matches for `'.</a>
<a name="ln2179">     */</a>
<a name="ln2180">    case '\'':</a>
<a name="ln2181">      if (!cpo_match &amp;&amp; initc != '\'' &amp;&amp; findc != '\'') {</a>
<a name="ln2182">        if (backwards) {</a>
<a name="ln2183">          if (pos.col &gt; 1) {</a>
<a name="ln2184">            if (linep[pos.col - 2] == '\'') {</a>
<a name="ln2185">              pos.col -= 2;</a>
<a name="ln2186">              break;</a>
<a name="ln2187">            } else if (linep[pos.col - 2] == '\\'</a>
<a name="ln2188">                       &amp;&amp; pos.col &gt; 2 &amp;&amp; linep[pos.col - 3] == '\'') {</a>
<a name="ln2189">              pos.col -= 3;</a>
<a name="ln2190">              break;</a>
<a name="ln2191">            }</a>
<a name="ln2192">          }</a>
<a name="ln2193">        } else if (linep[pos.col + 1]) {  // forward search</a>
<a name="ln2194">          if (linep[pos.col + 1] == '\\'</a>
<a name="ln2195">              &amp;&amp; linep[pos.col + 2] &amp;&amp; linep[pos.col + 3] == '\'') {</a>
<a name="ln2196">            pos.col += 3;</a>
<a name="ln2197">            break;</a>
<a name="ln2198">          } else if (linep[pos.col + 2] == '\'') {</a>
<a name="ln2199">            pos.col += 2;</a>
<a name="ln2200">            break;</a>
<a name="ln2201">          }</a>
<a name="ln2202">        }</a>
<a name="ln2203">      }</a>
<a name="ln2204">      FALLTHROUGH;</a>
<a name="ln2205"> </a>
<a name="ln2206">    default:</a>
<a name="ln2207">      /*</a>
<a name="ln2208">       * For Lisp skip over backslashed (), {} and [].</a>
<a name="ln2209">       * (actually, we skip #\( et al)</a>
<a name="ln2210">       */</a>
<a name="ln2211">      if (curbuf-&gt;b_p_lisp</a>
<a name="ln2212">          &amp;&amp; vim_strchr((char_u *)&quot;(){}[]&quot;, c) != NULL</a>
<a name="ln2213">          &amp;&amp; pos.col &gt; 1</a>
<a name="ln2214">          &amp;&amp; check_prevcol(linep, pos.col, '\\', NULL)</a>
<a name="ln2215">          &amp;&amp; check_prevcol(linep, pos.col - 1, '#', NULL))</a>
<a name="ln2216">        break;</a>
<a name="ln2217"> </a>
<a name="ln2218">      /* Check for match outside of quotes, and inside of</a>
<a name="ln2219">       * quotes when the start is also inside of quotes. */</a>
<a name="ln2220">      if ((!inquote || start_in_quotes == kTrue)</a>
<a name="ln2221">          &amp;&amp; (c == initc || c == findc)) {</a>
<a name="ln2222">        int col, bslcnt = 0;</a>
<a name="ln2223"> </a>
<a name="ln2224">        if (!cpo_bsl) {</a>
<a name="ln2225">          for (col = pos.col; check_prevcol(linep, col, '\\', &amp;col); )</a>
<a name="ln2226">            bslcnt++;</a>
<a name="ln2227">        }</a>
<a name="ln2228">        /* Only accept a match when 'M' is in 'cpo' or when escaping</a>
<a name="ln2229">         * is what we expect. */</a>
<a name="ln2230">        if (cpo_bsl || (bslcnt &amp; 1) == match_escaped) {</a>
<a name="ln2231">          if (c == initc)</a>
<a name="ln2232">            count++;</a>
<a name="ln2233">          else {</a>
<a name="ln2234">            if (count == 0)</a>
<a name="ln2235">              return &amp;pos;</a>
<a name="ln2236">            count--;</a>
<a name="ln2237">          }</a>
<a name="ln2238">        }</a>
<a name="ln2239">      }</a>
<a name="ln2240">    }</a>
<a name="ln2241">  }</a>
<a name="ln2242"> </a>
<a name="ln2243">  if (comment_dir == BACKWARD &amp;&amp; count &gt; 0) {</a>
<a name="ln2244">    pos = match_pos;</a>
<a name="ln2245">    return &amp;pos;</a>
<a name="ln2246">  }</a>
<a name="ln2247">  return (pos_T *)NULL;         /* never found it */</a>
<a name="ln2248">}</a>
<a name="ln2249"> </a>
<a name="ln2250">/*</a>
<a name="ln2251"> * Check if line[] contains a / / comment.</a>
<a name="ln2252"> * Return MAXCOL if not, otherwise return the column.</a>
<a name="ln2253"> * TODO: skip strings.</a>
<a name="ln2254"> */</a>
<a name="ln2255">static int check_linecomment(const char_u *line)</a>
<a name="ln2256">{</a>
<a name="ln2257">  const char_u *p = line;  // scan from start</a>
<a name="ln2258">  // skip Lispish one-line comments</a>
<a name="ln2259">  if (curbuf-&gt;b_p_lisp) {</a>
<a name="ln2260">    if (vim_strchr(p, ';') != NULL) {   /* there may be comments */</a>
<a name="ln2261">      int in_str = FALSE;       /* inside of string */</a>
<a name="ln2262"> </a>
<a name="ln2263">      while ((p = vim_strpbrk(p, (char_u *)&quot;\&quot;;&quot;)) != NULL) {</a>
<a name="ln2264">        if (*p == '&quot;') {</a>
<a name="ln2265">          if (in_str) {</a>
<a name="ln2266">            if (*(p - 1) != '\\')             /* skip escaped quote */</a>
<a name="ln2267">              in_str = FALSE;</a>
<a name="ln2268">          } else if (p == line || ((p - line) &gt;= 2</a>
<a name="ln2269">                                   /* skip #\&quot; form */</a>
<a name="ln2270">                                   &amp;&amp; *(p - 1) != '\\' &amp;&amp; *(p - 2) != '#'))</a>
<a name="ln2271">            in_str = TRUE;</a>
<a name="ln2272">        } else if (!in_str &amp;&amp; ((p - line) &lt; 2</a>
<a name="ln2273">                               || (*(p - 1) != '\\' &amp;&amp; *(p - 2) != '#')))</a>
<a name="ln2274">          break;                /* found! */</a>
<a name="ln2275">        ++p;</a>
<a name="ln2276">      }</a>
<a name="ln2277">    } else</a>
<a name="ln2278">      p = NULL;</a>
<a name="ln2279">  } else</a>
<a name="ln2280">    while ((p = vim_strchr(p, '/')) != NULL) {</a>
<a name="ln2281">      /* accept a double /, unless it's preceded with * and followed by *,</a>
<a name="ln2282">       * because * / / * is an end and start of a C comment */</a>
<a name="ln2283">      if (p[1] == '/' &amp;&amp; (p == line || p[-1] != '*' || p[2] != '*'))</a>
<a name="ln2284">        break;</a>
<a name="ln2285">      ++p;</a>
<a name="ln2286">    }</a>
<a name="ln2287"> </a>
<a name="ln2288">  if (p == NULL)</a>
<a name="ln2289">    return MAXCOL;</a>
<a name="ln2290">  return (int)(p - line);</a>
<a name="ln2291">}</a>
<a name="ln2292"> </a>
<a name="ln2293">/*</a>
<a name="ln2294"> * Move cursor briefly to character matching the one under the cursor.</a>
<a name="ln2295"> * Used for Insert mode and &quot;r&quot; command.</a>
<a name="ln2296"> * Show the match only if it is visible on the screen.</a>
<a name="ln2297"> * If there isn't a match, then beep.</a>
<a name="ln2298"> */</a>
<a name="ln2299">void</a>
<a name="ln2300">showmatch(</a>
<a name="ln2301">    int c                      // char to show match for</a>
<a name="ln2302">)</a>
<a name="ln2303">{</a>
<a name="ln2304">  pos_T       *lpos, save_cursor;</a>
<a name="ln2305">  pos_T mpos;</a>
<a name="ln2306">  colnr_T vcol;</a>
<a name="ln2307">  long *so = curwin-&gt;w_p_so &gt;= 0 ? &amp;curwin-&gt;w_p_so : &amp;p_so;</a>
<a name="ln2308">  long *siso = curwin-&gt;w_p_siso &gt;= 0 ? &amp;curwin-&gt;w_p_siso : &amp;p_siso;</a>
<a name="ln2309">  long save_so;</a>
<a name="ln2310">  long save_siso;</a>
<a name="ln2311">  int save_state;</a>
<a name="ln2312">  colnr_T save_dollar_vcol;</a>
<a name="ln2313">  char_u      *p;</a>
<a name="ln2314"> </a>
<a name="ln2315">  /*</a>
<a name="ln2316">   * Only show match for chars in the 'matchpairs' option.</a>
<a name="ln2317">   */</a>
<a name="ln2318">  /* 'matchpairs' is &quot;x:y,x:y&quot; */</a>
<a name="ln2319">  for (p = curbuf-&gt;b_p_mps; *p != NUL; ++p) {</a>
<a name="ln2320">    if (PTR2CHAR(p) == c &amp;&amp; (curwin-&gt;w_p_rl ^ p_ri))</a>
<a name="ln2321">      break;</a>
<a name="ln2322">    p += utfc_ptr2len(p) + 1;</a>
<a name="ln2323">    if (PTR2CHAR(p) == c &amp;&amp; !(curwin-&gt;w_p_rl ^ p_ri)) {</a>
<a name="ln2324">      break;</a>
<a name="ln2325">    }</a>
<a name="ln2326">    p += utfc_ptr2len(p);</a>
<a name="ln2327">    if (*p == NUL) {</a>
<a name="ln2328">      return;</a>
<a name="ln2329">    }</a>
<a name="ln2330">  }</a>
<a name="ln2331">  if (*p == NUL) {</a>
<a name="ln2332">    return;</a>
<a name="ln2333">  }</a>
<a name="ln2334"> </a>
<a name="ln2335">  if ((lpos = findmatch(NULL, NUL)) == NULL) {  // no match, so beep</a>
<a name="ln2336">    vim_beep(BO_MATCH);</a>
<a name="ln2337">  } else if (lpos-&gt;lnum &gt;= curwin-&gt;w_topline</a>
<a name="ln2338">      &amp;&amp; lpos-&gt;lnum &lt; curwin-&gt;w_botline) {</a>
<a name="ln2339">    if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln2340">      getvcol(curwin, lpos, NULL, &amp;vcol, NULL);</a>
<a name="ln2341">    }</a>
<a name="ln2342">    if (curwin-&gt;w_p_wrap</a>
<a name="ln2343">        || (vcol &gt;= curwin-&gt;w_leftcol</a>
<a name="ln2344">            &amp;&amp; vcol &lt; curwin-&gt;w_leftcol + curwin-&gt;w_width_inner)) {</a>
<a name="ln2345">      mpos = *lpos;  // save the pos, update_screen() may change it</a>
<a name="ln2346">      save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln2347">      save_so = *so;</a>
<a name="ln2348">      save_siso = *siso;</a>
<a name="ln2349">      // Handle &quot;$&quot; in 'cpo': If the ')' is typed on top of the &quot;$&quot;,</a>
<a name="ln2350">      // stop displaying the &quot;$&quot;.</a>
<a name="ln2351">      if (dollar_vcol &gt;= 0 &amp;&amp; dollar_vcol == curwin-&gt;w_virtcol) {</a>
<a name="ln2352">        dollar_vcol = -1;</a>
<a name="ln2353">      }</a>
<a name="ln2354">      curwin-&gt;w_virtcol++;              // do display ')' just before &quot;$&quot;</a>
<a name="ln2355">      update_screen(VALID);             // show the new char first</a>
<a name="ln2356"> </a>
<a name="ln2357">      save_dollar_vcol = dollar_vcol;</a>
<a name="ln2358">      save_state = State;</a>
<a name="ln2359">      State = SHOWMATCH;</a>
<a name="ln2360">      ui_cursor_shape();                // may show different cursor shape</a>
<a name="ln2361">      curwin-&gt;w_cursor = mpos;          // move to matching char</a>
<a name="ln2362">      *so = 0;                          // don't use 'scrolloff' here</a>
<a name="ln2363">      *siso = 0;                        // don't use 'sidescrolloff' here</a>
<a name="ln2364">      showruler(false);</a>
<a name="ln2365">      setcursor();</a>
<a name="ln2366">      ui_flush();</a>
<a name="ln2367">      /* Restore dollar_vcol(), because setcursor() may call curs_rows()</a>
<a name="ln2368">       * which resets it if the matching position is in a previous line</a>
<a name="ln2369">       * and has a higher column number. */</a>
<a name="ln2370">      dollar_vcol = save_dollar_vcol;</a>
<a name="ln2371"> </a>
<a name="ln2372">      /*</a>
<a name="ln2373">       * brief pause, unless 'm' is present in 'cpo' and a character is</a>
<a name="ln2374">       * available.</a>
<a name="ln2375">       */</a>
<a name="ln2376">      if (vim_strchr(p_cpo, CPO_SHOWMATCH) != NULL) {</a>
<a name="ln2377">        os_delay(p_mat * 100L + 8, true);</a>
<a name="ln2378">      } else if (!char_avail()) {</a>
<a name="ln2379">        os_delay(p_mat * 100L + 9, false);</a>
<a name="ln2380">      }</a>
<a name="ln2381">      curwin-&gt;w_cursor = save_cursor;           // restore cursor position</a>
<a name="ln2382">      *so = save_so;</a>
<a name="ln2383">      *siso = save_siso;</a>
<a name="ln2384">      State = save_state;</a>
<a name="ln2385">      ui_cursor_shape();                // may show different cursor shape</a>
<a name="ln2386">    }</a>
<a name="ln2387">  }</a>
<a name="ln2388">}</a>
<a name="ln2389"> </a>
<a name="ln2390">// Find the start of the next sentence, searching in the direction specified</a>
<a name="ln2391">// by the &quot;dir&quot; argument.  The cursor is positioned on the start of the next</a>
<a name="ln2392">// sentence when found.  If the next sentence is found, return OK.  Return FAIL</a>
<a name="ln2393">// otherwise.  See &quot;:h sentence&quot; for the precise definition of a &quot;sentence&quot;</a>
<a name="ln2394">// text object.</a>
<a name="ln2395">int findsent(Direction dir, long count)</a>
<a name="ln2396">{</a>
<a name="ln2397">  pos_T pos, tpos;</a>
<a name="ln2398">  int c;</a>
<a name="ln2399">  int         (*func)(pos_T *);</a>
<a name="ln2400">  bool noskip = false;              // do not skip blanks</a>
<a name="ln2401"> </a>
<a name="ln2402">  pos = curwin-&gt;w_cursor;</a>
<a name="ln2403">  if (dir == FORWARD)</a>
<a name="ln2404">    func = incl;</a>
<a name="ln2405">  else</a>
<a name="ln2406">    func = decl;</a>
<a name="ln2407"> </a>
<a name="ln2408">  while (count--) {</a>
<a name="ln2409">    const pos_T prev_pos = pos;</a>
<a name="ln2410"> </a>
<a name="ln2411">    // if on an empty line, skip up to a non-empty line</a>
<a name="ln2412">    if (gchar_pos(&amp;pos) == NUL) {</a>
<a name="ln2413">      do {</a>
<a name="ln2414">        if ((*func)(&amp;pos) == -1) {</a>
<a name="ln2415">          break;</a>
<a name="ln2416">        }</a>
<a name="ln2417">      } while (gchar_pos(&amp;pos) == NUL);</a>
<a name="ln2418">      if (dir == FORWARD) {</a>
<a name="ln2419">        goto found;</a>
<a name="ln2420">      }</a>
<a name="ln2421">    // if on the start of a paragraph or a section and searching forward,</a>
<a name="ln2422">    // go to the next line</a>
<a name="ln2423">    } else if (dir == FORWARD &amp;&amp; pos.col == 0</a>
<a name="ln2424">               &amp;&amp; startPS(pos.lnum, NUL, false)) {</a>
<a name="ln2425">      if (pos.lnum == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2426">        return FAIL;</a>
<a name="ln2427">      }</a>
<a name="ln2428">      pos.lnum++;</a>
<a name="ln2429">      goto found;</a>
<a name="ln2430">    } else if (dir == BACKWARD) {</a>
<a name="ln2431">      decl(&amp;pos);</a>
<a name="ln2432">    }</a>
<a name="ln2433"> </a>
<a name="ln2434">    // go back to the previous non-white non-punctuation character</a>
<a name="ln2435">    bool found_dot = false;</a>
<a name="ln2436">    while (c = gchar_pos(&amp;pos), ascii_iswhite(c)</a>
<a name="ln2437">           || vim_strchr((char_u *)&quot;.!?)]\&quot;'&quot;, c) != NULL) {</a>
<a name="ln2438">      tpos = pos;</a>
<a name="ln2439">      if (decl(&amp;tpos) == -1 || (LINEEMPTY(tpos.lnum) &amp;&amp; dir == FORWARD)) {</a>
<a name="ln2440">        break;</a>
<a name="ln2441">      }</a>
<a name="ln2442">      if (found_dot) {</a>
<a name="ln2443">        break;</a>
<a name="ln2444">      }</a>
<a name="ln2445">      if (vim_strchr((char_u *) &quot;.!?&quot;, c) != NULL) {</a>
<a name="ln2446">        found_dot = true;</a>
<a name="ln2447">      }</a>
<a name="ln2448">      if (vim_strchr((char_u *) &quot;)]\&quot;'&quot;, c) != NULL</a>
<a name="ln2449">          &amp;&amp; vim_strchr((char_u *) &quot;.!?)]\&quot;'&quot;, gchar_pos(&amp;tpos)) == NULL) {</a>
<a name="ln2450">        break;</a>
<a name="ln2451">      }</a>
<a name="ln2452">      decl(&amp;pos);</a>
<a name="ln2453">    }</a>
<a name="ln2454"> </a>
<a name="ln2455">    // remember the line where the search started</a>
<a name="ln2456">    const int startlnum = pos.lnum;</a>
<a name="ln2457">    const bool cpo_J = vim_strchr(p_cpo, CPO_ENDOFSENT) != NULL;</a>
<a name="ln2458"> </a>
<a name="ln2459">    for (;; ) {                 /* find end of sentence */</a>
<a name="ln2460">      c = gchar_pos(&amp;pos);</a>
<a name="ln2461">      if (c == NUL || (pos.col == 0 &amp;&amp; startPS(pos.lnum, NUL, FALSE))) {</a>
<a name="ln2462">        if (dir == BACKWARD &amp;&amp; pos.lnum != startlnum)</a>
<a name="ln2463">          ++pos.lnum;</a>
<a name="ln2464">        break;</a>
<a name="ln2465">      }</a>
<a name="ln2466">      if (c == '.' || c == '!' || c == '?') {</a>
<a name="ln2467">        tpos = pos;</a>
<a name="ln2468">        do</a>
<a name="ln2469">          if ((c = inc(&amp;tpos)) == -1)</a>
<a name="ln2470">            break;</a>
<a name="ln2471">        while (vim_strchr((char_u *)&quot;)]\&quot;'&quot;, c = gchar_pos(&amp;tpos))</a>
<a name="ln2472">               != NULL);</a>
<a name="ln2473">        if (c == -1  || (!cpo_J &amp;&amp; (c == ' ' || c == '\t')) || c == NUL</a>
<a name="ln2474">            || (cpo_J &amp;&amp; (c == ' ' &amp;&amp; inc(&amp;tpos) &gt;= 0</a>
<a name="ln2475">                          &amp;&amp; gchar_pos(&amp;tpos) == ' '))) {</a>
<a name="ln2476">          pos = tpos;</a>
<a name="ln2477">          if (gchar_pos(&amp;pos) == NUL)           /* skip NUL at EOL */</a>
<a name="ln2478">            inc(&amp;pos);</a>
<a name="ln2479">          break;</a>
<a name="ln2480">        }</a>
<a name="ln2481">      }</a>
<a name="ln2482">      if ((*func)(&amp;pos) == -1) {</a>
<a name="ln2483">        if (count)</a>
<a name="ln2484">          return FAIL;</a>
<a name="ln2485">        noskip = true;</a>
<a name="ln2486">        break;</a>
<a name="ln2487">      }</a>
<a name="ln2488">    }</a>
<a name="ln2489">found:</a>
<a name="ln2490">    /* skip white space */</a>
<a name="ln2491">    while (!noskip &amp;&amp; ((c = gchar_pos(&amp;pos)) == ' ' || c == '\t'))</a>
<a name="ln2492">      if (incl(&amp;pos) == -1)</a>
<a name="ln2493">        break;</a>
<a name="ln2494"> </a>
<a name="ln2495">    if (equalpos(prev_pos, pos)) {</a>
<a name="ln2496">      // didn't actually move, advance one character and try again</a>
<a name="ln2497">      if ((*func)(&amp;pos) == -1) {</a>
<a name="ln2498">        if (count) {</a>
<a name="ln2499">          return FAIL;</a>
<a name="ln2500">        }</a>
<a name="ln2501">        break;</a>
<a name="ln2502">      }</a>
<a name="ln2503">      count++;</a>
<a name="ln2504">    }</a>
<a name="ln2505">  }</a>
<a name="ln2506"> </a>
<a name="ln2507">  setpcmark();</a>
<a name="ln2508">  curwin-&gt;w_cursor = pos;</a>
<a name="ln2509">  return OK;</a>
<a name="ln2510">}</a>
<a name="ln2511"> </a>
<a name="ln2512">/*</a>
<a name="ln2513"> * Find the next paragraph or section in direction 'dir'.</a>
<a name="ln2514"> * Paragraphs are currently supposed to be separated by empty lines.</a>
<a name="ln2515"> * If 'what' is NUL we go to the next paragraph.</a>
<a name="ln2516"> * If 'what' is '{' or '}' we go to the next section.</a>
<a name="ln2517"> * If 'both' is TRUE also stop at '}'.</a>
<a name="ln2518"> * Return TRUE if the next paragraph or section was found.</a>
<a name="ln2519"> */</a>
<a name="ln2520">bool</a>
<a name="ln2521">findpar (</a>
<a name="ln2522">    bool *pincl,        /* Return: true if last char is to be included */</a>
<a name="ln2523">    int dir,</a>
<a name="ln2524">    long count,</a>
<a name="ln2525">    int what,</a>
<a name="ln2526">    int both</a>
<a name="ln2527">)</a>
<a name="ln2528">{</a>
<a name="ln2529">  linenr_T curr;</a>
<a name="ln2530">  bool did_skip;            /* true after separating lines have been skipped */</a>
<a name="ln2531">  bool first;               /* true on first line */</a>
<a name="ln2532">  linenr_T fold_first;      /* first line of a closed fold */</a>
<a name="ln2533">  linenr_T fold_last;       /* last line of a closed fold */</a>
<a name="ln2534">  bool fold_skipped;        /* true if a closed fold was skipped this</a>
<a name="ln2535">                               iteration */</a>
<a name="ln2536"> </a>
<a name="ln2537">  curr = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2538"> </a>
<a name="ln2539">  while (count--) {</a>
<a name="ln2540">    did_skip = false;</a>
<a name="ln2541">    for (first = true;; first = false) {</a>
<a name="ln2542">      if (*ml_get(curr) != NUL)</a>
<a name="ln2543">        did_skip = true;</a>
<a name="ln2544"> </a>
<a name="ln2545">      /* skip folded lines */</a>
<a name="ln2546">      fold_skipped = false;</a>
<a name="ln2547">      if (first &amp;&amp; hasFolding(curr, &amp;fold_first, &amp;fold_last)) {</a>
<a name="ln2548">        curr = ((dir &gt; 0) ? fold_last : fold_first) + dir;</a>
<a name="ln2549">        fold_skipped = true;</a>
<a name="ln2550">      }</a>
<a name="ln2551"> </a>
<a name="ln2552">      if (!first &amp;&amp; did_skip &amp;&amp; startPS(curr, what, both))</a>
<a name="ln2553">        break;</a>
<a name="ln2554"> </a>
<a name="ln2555">      if (fold_skipped)</a>
<a name="ln2556">        curr -= dir;</a>
<a name="ln2557">      if ((curr += dir) &lt; 1 || curr &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2558">        if (count)</a>
<a name="ln2559">          return false;</a>
<a name="ln2560">        curr -= dir;</a>
<a name="ln2561">        break;</a>
<a name="ln2562">      }</a>
<a name="ln2563">    }</a>
<a name="ln2564">  }</a>
<a name="ln2565">  setpcmark();</a>
<a name="ln2566">  if (both &amp;&amp; *ml_get(curr) == '}')     /* include line with '}' */</a>
<a name="ln2567">    ++curr;</a>
<a name="ln2568">  curwin-&gt;w_cursor.lnum = curr;</a>
<a name="ln2569">  if (curr == curbuf-&gt;b_ml.ml_line_count &amp;&amp; what != '}') {</a>
<a name="ln2570">    char_u *line = ml_get(curr);</a>
<a name="ln2571"> </a>
<a name="ln2572">    // Put the cursor on the last character in the last line and make the</a>
<a name="ln2573">    // motion inclusive.</a>
<a name="ln2574">    if ((curwin-&gt;w_cursor.col = (colnr_T)STRLEN(line)) != 0) {</a>
<a name="ln2575">      curwin-&gt;w_cursor.col--;</a>
<a name="ln2576">      curwin-&gt;w_cursor.col -= utf_head_off(line, line + curwin-&gt;w_cursor.col);</a>
<a name="ln2577">      *pincl = true;</a>
<a name="ln2578">    }</a>
<a name="ln2579">  } else</a>
<a name="ln2580">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2581">  return true;</a>
<a name="ln2582">}</a>
<a name="ln2583"> </a>
<a name="ln2584">/*</a>
<a name="ln2585"> * check if the string 's' is a nroff macro that is in option 'opt'</a>
<a name="ln2586"> */</a>
<a name="ln2587">static int inmacro(char_u *opt, char_u *s)</a>
<a name="ln2588">{</a>
<a name="ln2589">  char_u      *macro;</a>
<a name="ln2590"> </a>
<a name="ln2591">  for (macro = opt; macro[0]; ++macro) {</a>
<a name="ln2592">    /* Accept two characters in the option being equal to two characters</a>
<a name="ln2593">     * in the line.  A space in the option matches with a space in the</a>
<a name="ln2594">     * line or the line having ended. */</a>
<a name="ln2595">    if (       (macro[0] == s[0]</a>
<a name="ln2596">                || (macro[0] == ' '</a>
<a name="ln2597">                    &amp;&amp; (s[0] == NUL || s[0] == ' ')))</a>
<a name="ln2598">               &amp;&amp; (macro[1] == s[1]</a>
<a name="ln2599">                   || ((macro[1] == NUL || macro[1] == ' ')</a>
<a name="ln2600">                       &amp;&amp; (s[0] == NUL || s[1] == NUL || s[1] == ' '))))</a>
<a name="ln2601">      break;</a>
<a name="ln2602">    ++macro;</a>
<a name="ln2603">    if (macro[0] == NUL)</a>
<a name="ln2604">      break;</a>
<a name="ln2605">  }</a>
<a name="ln2606">  return macro[0] != NUL;</a>
<a name="ln2607">}</a>
<a name="ln2608"> </a>
<a name="ln2609">/*</a>
<a name="ln2610"> * startPS: return TRUE if line 'lnum' is the start of a section or paragraph.</a>
<a name="ln2611"> * If 'para' is '{' or '}' only check for sections.</a>
<a name="ln2612"> * If 'both' is TRUE also stop at '}'</a>
<a name="ln2613"> */</a>
<a name="ln2614">int startPS(linenr_T lnum, int para, int both)</a>
<a name="ln2615">{</a>
<a name="ln2616">  char_u      *s;</a>
<a name="ln2617"> </a>
<a name="ln2618">  s = ml_get(lnum);</a>
<a name="ln2619">  if (*s == para || *s == '\f' || (both &amp;&amp; *s == '}')) {</a>
<a name="ln2620">    return true;</a>
<a name="ln2621">  }</a>
<a name="ln2622">  if (*s == '.' &amp;&amp; (inmacro(p_sections, s + 1)</a>
<a name="ln2623">                    || (!para &amp;&amp; inmacro(p_para, s + 1)))) {</a>
<a name="ln2624">    return true;</a>
<a name="ln2625">  }</a>
<a name="ln2626">  return false;</a>
<a name="ln2627">}</a>
<a name="ln2628"> </a>
<a name="ln2629">/*</a>
<a name="ln2630"> * The following routines do the word searches performed by the 'w', 'W',</a>
<a name="ln2631"> * 'b', 'B', 'e', and 'E' commands.</a>
<a name="ln2632"> */</a>
<a name="ln2633"> </a>
<a name="ln2634">/*</a>
<a name="ln2635"> * To perform these searches, characters are placed into one of three</a>
<a name="ln2636"> * classes, and transitions between classes determine word boundaries.</a>
<a name="ln2637"> *</a>
<a name="ln2638"> * The classes are:</a>
<a name="ln2639"> *</a>
<a name="ln2640"> * 0 - white space</a>
<a name="ln2641"> * 1 - punctuation</a>
<a name="ln2642"> * 2 or higher - keyword characters (letters, digits and underscore)</a>
<a name="ln2643"> */</a>
<a name="ln2644"> </a>
<a name="ln2645">static int cls_bigword;         /* TRUE for &quot;W&quot;, &quot;B&quot; or &quot;E&quot; */</a>
<a name="ln2646"> </a>
<a name="ln2647">/*</a>
<a name="ln2648"> * cls() - returns the class of character at curwin-&gt;w_cursor</a>
<a name="ln2649"> *</a>
<a name="ln2650"> * If a 'W', 'B', or 'E' motion is being done (cls_bigword == TRUE), chars</a>
<a name="ln2651"> * from class 2 and higher are reported as class 1 since only white space</a>
<a name="ln2652"> * boundaries are of interest.</a>
<a name="ln2653"> */</a>
<a name="ln2654">static int cls(void)</a>
<a name="ln2655">{</a>
<a name="ln2656">  int c;</a>
<a name="ln2657"> </a>
<a name="ln2658">  c = gchar_cursor();</a>
<a name="ln2659">  if (c == ' ' || c == '\t' || c == NUL) {</a>
<a name="ln2660">    return 0;</a>
<a name="ln2661">  }</a>
<a name="ln2662"> </a>
<a name="ln2663">  c = utf_class(c);</a>
<a name="ln2664"> </a>
<a name="ln2665">  // If cls_bigword is TRUE, report all non-blanks as class 1.</a>
<a name="ln2666">  if (c != 0 &amp;&amp; cls_bigword) {</a>
<a name="ln2667">    return 1;</a>
<a name="ln2668">  }</a>
<a name="ln2669">  return c;</a>
<a name="ln2670">}</a>
<a name="ln2671"> </a>
<a name="ln2672">/*</a>
<a name="ln2673"> * fwd_word(count, type, eol) - move forward one word</a>
<a name="ln2674"> *</a>
<a name="ln2675"> * Returns FAIL if the cursor was already at the end of the file.</a>
<a name="ln2676"> * If eol is TRUE, last word stops at end of line (for operators).</a>
<a name="ln2677"> */</a>
<a name="ln2678">int</a>
<a name="ln2679">fwd_word(</a>
<a name="ln2680">    long count,</a>
<a name="ln2681">    int bigword,                /* &quot;W&quot;, &quot;E&quot; or &quot;B&quot; */</a>
<a name="ln2682">    int eol</a>
<a name="ln2683">)</a>
<a name="ln2684">{</a>
<a name="ln2685">  int sclass;               /* starting class */</a>
<a name="ln2686">  int i;</a>
<a name="ln2687">  int last_line;</a>
<a name="ln2688"> </a>
<a name="ln2689">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2690">  cls_bigword = bigword;</a>
<a name="ln2691">  while (--count &gt;= 0) {</a>
<a name="ln2692">    /* When inside a range of folded lines, move to the last char of the</a>
<a name="ln2693">     * last line. */</a>
<a name="ln2694">    if (hasFolding(curwin-&gt;w_cursor.lnum, NULL, &amp;curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln2695">      coladvance(MAXCOL);</a>
<a name="ln2696">    }</a>
<a name="ln2697">    sclass = cls();</a>
<a name="ln2698"> </a>
<a name="ln2699">    /*</a>
<a name="ln2700">     * We always move at least one character, unless on the last</a>
<a name="ln2701">     * character in the buffer.</a>
<a name="ln2702">     */</a>
<a name="ln2703">    last_line = (curwin-&gt;w_cursor.lnum == curbuf-&gt;b_ml.ml_line_count);</a>
<a name="ln2704">    i = inc_cursor();</a>
<a name="ln2705">    if (i == -1 || (i &gt;= 1 &amp;&amp; last_line))     /* started at last char in file */</a>
<a name="ln2706">      return FAIL;</a>
<a name="ln2707">    if (i &gt;= 1 &amp;&amp; eol &amp;&amp; count == 0)          /* started at last char in line */</a>
<a name="ln2708">      return OK;</a>
<a name="ln2709"> </a>
<a name="ln2710">    /*</a>
<a name="ln2711">     * Go one char past end of current word (if any)</a>
<a name="ln2712">     */</a>
<a name="ln2713">    if (sclass != 0)</a>
<a name="ln2714">      while (cls() == sclass) {</a>
<a name="ln2715">        i = inc_cursor();</a>
<a name="ln2716">        if (i == -1 || (i &gt;= 1 &amp;&amp; eol &amp;&amp; count == 0))</a>
<a name="ln2717">          return OK;</a>
<a name="ln2718">      }</a>
<a name="ln2719"> </a>
<a name="ln2720">    /*</a>
<a name="ln2721">     * go to next non-white</a>
<a name="ln2722">     */</a>
<a name="ln2723">    while (cls() == 0) {</a>
<a name="ln2724">      /*</a>
<a name="ln2725">       * We'll stop if we land on a blank line</a>
<a name="ln2726">       */</a>
<a name="ln2727">      if (curwin-&gt;w_cursor.col == 0 &amp;&amp; *get_cursor_line_ptr() == NUL)</a>
<a name="ln2728">        break;</a>
<a name="ln2729"> </a>
<a name="ln2730">      i = inc_cursor();</a>
<a name="ln2731">      if (i == -1 || (i &gt;= 1 &amp;&amp; eol &amp;&amp; count == 0))</a>
<a name="ln2732">        return OK;</a>
<a name="ln2733">    }</a>
<a name="ln2734">  }</a>
<a name="ln2735">  return OK;</a>
<a name="ln2736">}</a>
<a name="ln2737"> </a>
<a name="ln2738">/*</a>
<a name="ln2739"> * bck_word() - move backward 'count' words</a>
<a name="ln2740"> *</a>
<a name="ln2741"> * If stop is TRUE and we are already on the start of a word, move one less.</a>
<a name="ln2742"> *</a>
<a name="ln2743"> * Returns FAIL if top of the file was reached.</a>
<a name="ln2744"> */</a>
<a name="ln2745">int bck_word(long count, int bigword, int stop)</a>
<a name="ln2746">{</a>
<a name="ln2747">  int sclass;               /* starting class */</a>
<a name="ln2748"> </a>
<a name="ln2749">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2750">  cls_bigword = bigword;</a>
<a name="ln2751">  while (--count &gt;= 0) {</a>
<a name="ln2752">    /* When inside a range of folded lines, move to the first char of the</a>
<a name="ln2753">     * first line. */</a>
<a name="ln2754">    if (hasFolding(curwin-&gt;w_cursor.lnum, &amp;curwin-&gt;w_cursor.lnum, NULL))</a>
<a name="ln2755">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2756">    sclass = cls();</a>
<a name="ln2757">    if (dec_cursor() == -1)             /* started at start of file */</a>
<a name="ln2758">      return FAIL;</a>
<a name="ln2759"> </a>
<a name="ln2760">    if (!stop || sclass == cls() || sclass == 0) {</a>
<a name="ln2761">      /*</a>
<a name="ln2762">       * Skip white space before the word.</a>
<a name="ln2763">       * Stop on an empty line.</a>
<a name="ln2764">       */</a>
<a name="ln2765">      while (cls() == 0) {</a>
<a name="ln2766">        if (curwin-&gt;w_cursor.col == 0</a>
<a name="ln2767">            &amp;&amp; LINEEMPTY(curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln2768">          goto finished;</a>
<a name="ln2769">        }</a>
<a name="ln2770">        if (dec_cursor() == -1) {       // hit start of file, stop here</a>
<a name="ln2771">          return OK;</a>
<a name="ln2772">        }</a>
<a name="ln2773">      }</a>
<a name="ln2774"> </a>
<a name="ln2775">      /*</a>
<a name="ln2776">       * Move backward to start of this word.</a>
<a name="ln2777">       */</a>
<a name="ln2778">      if (skip_chars(cls(), BACKWARD))</a>
<a name="ln2779">        return OK;</a>
<a name="ln2780">    }</a>
<a name="ln2781"> </a>
<a name="ln2782">    inc_cursor();                       /* overshot - forward one */</a>
<a name="ln2783">finished:</a>
<a name="ln2784">    stop = FALSE;</a>
<a name="ln2785">  }</a>
<a name="ln2786">  return OK;</a>
<a name="ln2787">}</a>
<a name="ln2788"> </a>
<a name="ln2789">/*</a>
<a name="ln2790"> * end_word() - move to the end of the word</a>
<a name="ln2791"> *</a>
<a name="ln2792"> * There is an apparent bug in the 'e' motion of the real vi. At least on the</a>
<a name="ln2793"> * System V Release 3 version for the 80386. Unlike 'b' and 'w', the 'e'</a>
<a name="ln2794"> * motion crosses blank lines. When the real vi crosses a blank line in an</a>
<a name="ln2795"> * 'e' motion, the cursor is placed on the FIRST character of the next</a>
<a name="ln2796"> * non-blank line. The 'E' command, however, works correctly. Since this</a>
<a name="ln2797"> * appears to be a bug, I have not duplicated it here.</a>
<a name="ln2798"> *</a>
<a name="ln2799"> * Returns FAIL if end of the file was reached.</a>
<a name="ln2800"> *</a>
<a name="ln2801"> * If stop is TRUE and we are already on the end of a word, move one less.</a>
<a name="ln2802"> * If empty is TRUE stop on an empty line.</a>
<a name="ln2803"> */</a>
<a name="ln2804">int end_word(long count, int bigword, int stop, int empty)</a>
<a name="ln2805">{</a>
<a name="ln2806">  int sclass;               /* starting class */</a>
<a name="ln2807"> </a>
<a name="ln2808">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2809">  cls_bigword = bigword;</a>
<a name="ln2810">  while (--count &gt;= 0) {</a>
<a name="ln2811">    /* When inside a range of folded lines, move to the last char of the</a>
<a name="ln2812">     * last line. */</a>
<a name="ln2813">    if (hasFolding(curwin-&gt;w_cursor.lnum, NULL, &amp;curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln2814">      coladvance(MAXCOL);</a>
<a name="ln2815">    }</a>
<a name="ln2816">    sclass = cls();</a>
<a name="ln2817">    if (inc_cursor() == -1)</a>
<a name="ln2818">      return FAIL;</a>
<a name="ln2819"> </a>
<a name="ln2820">    /*</a>
<a name="ln2821">     * If we're in the middle of a word, we just have to move to the end</a>
<a name="ln2822">     * of it.</a>
<a name="ln2823">     */</a>
<a name="ln2824">    if (cls() == sclass &amp;&amp; sclass != 0) {</a>
<a name="ln2825">      /*</a>
<a name="ln2826">       * Move forward to end of the current word</a>
<a name="ln2827">       */</a>
<a name="ln2828">      if (skip_chars(sclass, FORWARD))</a>
<a name="ln2829">        return FAIL;</a>
<a name="ln2830">    } else if (!stop || sclass == 0) {</a>
<a name="ln2831">      /*</a>
<a name="ln2832">       * We were at the end of a word. Go to the end of the next word.</a>
<a name="ln2833">       * First skip white space, if 'empty' is TRUE, stop at empty line.</a>
<a name="ln2834">       */</a>
<a name="ln2835">      while (cls() == 0) {</a>
<a name="ln2836">        if (empty &amp;&amp; curwin-&gt;w_cursor.col == 0</a>
<a name="ln2837">            &amp;&amp; LINEEMPTY(curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln2838">          goto finished;</a>
<a name="ln2839">        }</a>
<a name="ln2840">        if (inc_cursor() == -1) {           // hit end of file, stop here</a>
<a name="ln2841">          return FAIL;</a>
<a name="ln2842">        }</a>
<a name="ln2843">      }</a>
<a name="ln2844"> </a>
<a name="ln2845">      /*</a>
<a name="ln2846">       * Move forward to the end of this word.</a>
<a name="ln2847">       */</a>
<a name="ln2848">      if (skip_chars(cls(), FORWARD))</a>
<a name="ln2849">        return FAIL;</a>
<a name="ln2850">    }</a>
<a name="ln2851">    dec_cursor();                       /* overshot - one char backward */</a>
<a name="ln2852">finished:</a>
<a name="ln2853">    stop = FALSE;                       /* we move only one word less */</a>
<a name="ln2854">  }</a>
<a name="ln2855">  return OK;</a>
<a name="ln2856">}</a>
<a name="ln2857"> </a>
<a name="ln2858">/*</a>
<a name="ln2859"> * Move back to the end of the word.</a>
<a name="ln2860"> *</a>
<a name="ln2861"> * Returns FAIL if start of the file was reached.</a>
<a name="ln2862"> */</a>
<a name="ln2863">int</a>
<a name="ln2864">bckend_word(</a>
<a name="ln2865">    long count,</a>
<a name="ln2866">    int bigword,                /* TRUE for &quot;B&quot; */</a>
<a name="ln2867">    int eol                    /* TRUE: stop at end of line. */</a>
<a name="ln2868">)</a>
<a name="ln2869">{</a>
<a name="ln2870">  int sclass;               /* starting class */</a>
<a name="ln2871">  int i;</a>
<a name="ln2872"> </a>
<a name="ln2873">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2874">  cls_bigword = bigword;</a>
<a name="ln2875">  while (--count &gt;= 0) {</a>
<a name="ln2876">    sclass = cls();</a>
<a name="ln2877">    if ((i = dec_cursor()) == -1)</a>
<a name="ln2878">      return FAIL;</a>
<a name="ln2879">    if (eol &amp;&amp; i == 1)</a>
<a name="ln2880">      return OK;</a>
<a name="ln2881"> </a>
<a name="ln2882">    /*</a>
<a name="ln2883">     * Move backward to before the start of this word.</a>
<a name="ln2884">     */</a>
<a name="ln2885">    if (sclass != 0) {</a>
<a name="ln2886">      while (cls() == sclass)</a>
<a name="ln2887">        if ((i = dec_cursor()) == -1 || (eol &amp;&amp; i == 1))</a>
<a name="ln2888">          return OK;</a>
<a name="ln2889">    }</a>
<a name="ln2890"> </a>
<a name="ln2891">    /*</a>
<a name="ln2892">     * Move backward to end of the previous word</a>
<a name="ln2893">     */</a>
<a name="ln2894">    while (cls() == 0) {</a>
<a name="ln2895">      if (curwin-&gt;w_cursor.col == 0 &amp;&amp; LINEEMPTY(curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln2896">        break;</a>
<a name="ln2897">      }</a>
<a name="ln2898">      if ((i = dec_cursor()) == -1 || (eol &amp;&amp; i == 1)) {</a>
<a name="ln2899">        return OK;</a>
<a name="ln2900">      }</a>
<a name="ln2901">    }</a>
<a name="ln2902">  }</a>
<a name="ln2903">  return OK;</a>
<a name="ln2904">}</a>
<a name="ln2905"> </a>
<a name="ln2906">/*</a>
<a name="ln2907"> * Skip a row of characters of the same class.</a>
<a name="ln2908"> * Return TRUE when end-of-file reached, FALSE otherwise.</a>
<a name="ln2909"> */</a>
<a name="ln2910">static int skip_chars(int cclass, int dir)</a>
<a name="ln2911">{</a>
<a name="ln2912">  while (cls() == cclass)</a>
<a name="ln2913">    if ((dir == FORWARD ? inc_cursor() : dec_cursor()) == -1)</a>
<a name="ln2914">      return TRUE;</a>
<a name="ln2915">  return FALSE;</a>
<a name="ln2916">}</a>
<a name="ln2917"> </a>
<a name="ln2918">/*</a>
<a name="ln2919"> * Go back to the start of the word or the start of white space</a>
<a name="ln2920"> */</a>
<a name="ln2921">static void back_in_line(void)</a>
<a name="ln2922">{</a>
<a name="ln2923">  int sclass;                       /* starting class */</a>
<a name="ln2924"> </a>
<a name="ln2925">  sclass = cls();</a>
<a name="ln2926">  for (;; ) {</a>
<a name="ln2927">    if (curwin-&gt;w_cursor.col == 0)          /* stop at start of line */</a>
<a name="ln2928">      break;</a>
<a name="ln2929">    dec_cursor();</a>
<a name="ln2930">    if (cls() != sclass) {                  /* stop at start of word */</a>
<a name="ln2931">      inc_cursor();</a>
<a name="ln2932">      break;</a>
<a name="ln2933">    }</a>
<a name="ln2934">  }</a>
<a name="ln2935">}</a>
<a name="ln2936"> </a>
<a name="ln2937">static void find_first_blank(pos_T *posp)</a>
<a name="ln2938">{</a>
<a name="ln2939">  int c;</a>
<a name="ln2940"> </a>
<a name="ln2941">  while (decl(posp) != -1) {</a>
<a name="ln2942">    c = gchar_pos(posp);</a>
<a name="ln2943">    if (!ascii_iswhite(c)) {</a>
<a name="ln2944">      incl(posp);</a>
<a name="ln2945">      break;</a>
<a name="ln2946">    }</a>
<a name="ln2947">  }</a>
<a name="ln2948">}</a>
<a name="ln2949"> </a>
<a name="ln2950">/*</a>
<a name="ln2951"> * Skip count/2 sentences and count/2 separating white spaces.</a>
<a name="ln2952"> */</a>
<a name="ln2953">static void</a>
<a name="ln2954">findsent_forward(</a>
<a name="ln2955">    long count,</a>
<a name="ln2956">    int at_start_sent              /* cursor is at start of sentence */</a>
<a name="ln2957">)</a>
<a name="ln2958">{</a>
<a name="ln2959">  while (count--) {</a>
<a name="ln2960">    findsent(FORWARD, 1L);</a>
<a name="ln2961">    if (at_start_sent)</a>
<a name="ln2962">      find_first_blank(&amp;curwin-&gt;w_cursor);</a>
<a name="ln2963">    if (count == 0 || at_start_sent)</a>
<a name="ln2964">      decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln2965">    at_start_sent = !at_start_sent;</a>
<a name="ln2966">  }</a>
<a name="ln2967">}</a>
<a name="ln2968"> </a>
<a name="ln2969">/*</a>
<a name="ln2970"> * Find word under cursor, cursor at end.</a>
<a name="ln2971"> * Used while an operator is pending, and in Visual mode.</a>
<a name="ln2972"> */</a>
<a name="ln2973">int</a>
<a name="ln2974">current_word(</a>
<a name="ln2975">    oparg_T *oap,</a>
<a name="ln2976">    long count,</a>
<a name="ln2977">    int include,                    /* TRUE: include word and white space */</a>
<a name="ln2978">    int bigword                    /* FALSE == word, TRUE == WORD */</a>
<a name="ln2979">)</a>
<a name="ln2980">{</a>
<a name="ln2981">  pos_T start_pos;</a>
<a name="ln2982">  pos_T pos;</a>
<a name="ln2983">  bool inclusive = true;</a>
<a name="ln2984">  int include_white = FALSE;</a>
<a name="ln2985"> </a>
<a name="ln2986">  cls_bigword = bigword;</a>
<a name="ln2987">  clearpos(&amp;start_pos);</a>
<a name="ln2988"> </a>
<a name="ln2989">  /* Correct cursor when 'selection' is exclusive */</a>
<a name="ln2990">  if (VIsual_active &amp;&amp; *p_sel == 'e' &amp;&amp; lt(VIsual, curwin-&gt;w_cursor))</a>
<a name="ln2991">    dec_cursor();</a>
<a name="ln2992"> </a>
<a name="ln2993">  /*</a>
<a name="ln2994">   * When Visual mode is not active, or when the VIsual area is only one</a>
<a name="ln2995">   * character, select the word and/or white space under the cursor.</a>
<a name="ln2996">   */</a>
<a name="ln2997">  if (!VIsual_active || equalpos(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln2998">    /*</a>
<a name="ln2999">     * Go to start of current word or white space.</a>
<a name="ln3000">     */</a>
<a name="ln3001">    back_in_line();</a>
<a name="ln3002">    start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3003"> </a>
<a name="ln3004">    /*</a>
<a name="ln3005">     * If the start is on white space, and white space should be included</a>
<a name="ln3006">     * (&quot; word&quot;), or start is not on white space, and white space should</a>
<a name="ln3007">     * not be included (&quot;word&quot;), find end of word.</a>
<a name="ln3008">     */</a>
<a name="ln3009">    if ((cls() == 0) == include) {</a>
<a name="ln3010">      if (end_word(1L, bigword, TRUE, TRUE) == FAIL)</a>
<a name="ln3011">        return FAIL;</a>
<a name="ln3012">    } else {</a>
<a name="ln3013">      /*</a>
<a name="ln3014">       * If the start is not on white space, and white space should be</a>
<a name="ln3015">       * included (&quot;word   &quot;), or start is on white space and white</a>
<a name="ln3016">       * space should not be included (&quot;   &quot;), find start of word.</a>
<a name="ln3017">       * If we end up in the first column of the next line (single char</a>
<a name="ln3018">       * word) back up to end of the line.</a>
<a name="ln3019">       */</a>
<a name="ln3020">      fwd_word(1L, bigword, TRUE);</a>
<a name="ln3021">      if (curwin-&gt;w_cursor.col == 0)</a>
<a name="ln3022">        decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3023">      else</a>
<a name="ln3024">        oneleft();</a>
<a name="ln3025"> </a>
<a name="ln3026">      if (include)</a>
<a name="ln3027">        include_white = TRUE;</a>
<a name="ln3028">    }</a>
<a name="ln3029"> </a>
<a name="ln3030">    if (VIsual_active) {</a>
<a name="ln3031">      /* should do something when inclusive == false ! */</a>
<a name="ln3032">      VIsual = start_pos;</a>
<a name="ln3033">      redraw_curbuf_later(INVERTED);            /* update the inversion */</a>
<a name="ln3034">    } else {</a>
<a name="ln3035">      oap-&gt;start = start_pos;</a>
<a name="ln3036">      oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln3037">    }</a>
<a name="ln3038">    --count;</a>
<a name="ln3039">  }</a>
<a name="ln3040"> </a>
<a name="ln3041">  /*</a>
<a name="ln3042">   * When count is still &gt; 0, extend with more objects.</a>
<a name="ln3043">   */</a>
<a name="ln3044">  while (count &gt; 0) {</a>
<a name="ln3045">    inclusive = true;</a>
<a name="ln3046">    if (VIsual_active &amp;&amp; lt(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln3047">      /*</a>
<a name="ln3048">       * In Visual mode, with cursor at start: move cursor back.</a>
<a name="ln3049">       */</a>
<a name="ln3050">      if (decl(&amp;curwin-&gt;w_cursor) == -1)</a>
<a name="ln3051">        return FAIL;</a>
<a name="ln3052">      if (include != (cls() != 0)) {</a>
<a name="ln3053">        if (bck_word(1L, bigword, TRUE) == FAIL)</a>
<a name="ln3054">          return FAIL;</a>
<a name="ln3055">      } else {</a>
<a name="ln3056">        if (bckend_word(1L, bigword, TRUE) == FAIL)</a>
<a name="ln3057">          return FAIL;</a>
<a name="ln3058">        (void)incl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3059">      }</a>
<a name="ln3060">    } else {</a>
<a name="ln3061">      /*</a>
<a name="ln3062">       * Move cursor forward one word and/or white area.</a>
<a name="ln3063">       */</a>
<a name="ln3064">      if (incl(&amp;curwin-&gt;w_cursor) == -1)</a>
<a name="ln3065">        return FAIL;</a>
<a name="ln3066">      if (include != (cls() == 0)) {</a>
<a name="ln3067">        if (fwd_word(1L, bigword, TRUE) == FAIL &amp;&amp; count &gt; 1)</a>
<a name="ln3068">          return FAIL;</a>
<a name="ln3069">        /*</a>
<a name="ln3070">         * If end is just past a new-line, we don't want to include</a>
<a name="ln3071">         * the first character on the line.</a>
<a name="ln3072">         * Put cursor on last char of white.</a>
<a name="ln3073">         */</a>
<a name="ln3074">        if (oneleft() == FAIL)</a>
<a name="ln3075">          inclusive = false;</a>
<a name="ln3076">      } else {</a>
<a name="ln3077">        if (end_word(1L, bigword, TRUE, TRUE) == FAIL)</a>
<a name="ln3078">          return FAIL;</a>
<a name="ln3079">      }</a>
<a name="ln3080">    }</a>
<a name="ln3081">    --count;</a>
<a name="ln3082">  }</a>
<a name="ln3083"> </a>
<a name="ln3084">  if (include_white &amp;&amp; (cls() != 0</a>
<a name="ln3085">                        || (curwin-&gt;w_cursor.col == 0 &amp;&amp; !inclusive))) {</a>
<a name="ln3086">    /*</a>
<a name="ln3087">     * If we don't include white space at the end, move the start</a>
<a name="ln3088">     * to include some white space there. This makes &quot;daw&quot; work</a>
<a name="ln3089">     * better on the last word in a sentence (and &quot;2daw&quot; on last-but-one</a>
<a name="ln3090">     * word).  Also when &quot;2daw&quot; deletes &quot;word.&quot; at the end of the line</a>
<a name="ln3091">     * (cursor is at start of next line).</a>
<a name="ln3092">     * But don't delete white space at start of line (indent).</a>
<a name="ln3093">     */</a>
<a name="ln3094">    pos = curwin-&gt;w_cursor;     /* save cursor position */</a>
<a name="ln3095">    curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3096">    if (oneleft() == OK) {</a>
<a name="ln3097">      back_in_line();</a>
<a name="ln3098">      if (cls() == 0 &amp;&amp; curwin-&gt;w_cursor.col &gt; 0) {</a>
<a name="ln3099">        if (VIsual_active)</a>
<a name="ln3100">          VIsual = curwin-&gt;w_cursor;</a>
<a name="ln3101">        else</a>
<a name="ln3102">          oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln3103">      }</a>
<a name="ln3104">    }</a>
<a name="ln3105">    curwin-&gt;w_cursor = pos;     /* put cursor back at end */</a>
<a name="ln3106">  }</a>
<a name="ln3107"> </a>
<a name="ln3108">  if (VIsual_active) {</a>
<a name="ln3109">    if (*p_sel == 'e' &amp;&amp; inclusive &amp;&amp; ltoreq(VIsual, curwin-&gt;w_cursor))</a>
<a name="ln3110">      inc_cursor();</a>
<a name="ln3111">    if (VIsual_mode == 'V') {</a>
<a name="ln3112">      VIsual_mode = 'v';</a>
<a name="ln3113">      redraw_cmdline = TRUE;                    /* show mode later */</a>
<a name="ln3114">    }</a>
<a name="ln3115">  } else</a>
<a name="ln3116">    oap-&gt;inclusive = inclusive;</a>
<a name="ln3117"> </a>
<a name="ln3118">  return OK;</a>
<a name="ln3119">}</a>
<a name="ln3120"> </a>
<a name="ln3121">/*</a>
<a name="ln3122"> * Find sentence(s) under the cursor, cursor at end.</a>
<a name="ln3123"> * When Visual active, extend it by one or more sentences.</a>
<a name="ln3124"> */</a>
<a name="ln3125">int current_sent(oparg_T *oap, long count, int include)</a>
<a name="ln3126">{</a>
<a name="ln3127">  pos_T start_pos;</a>
<a name="ln3128">  pos_T pos;</a>
<a name="ln3129">  int start_blank;</a>
<a name="ln3130">  int c;</a>
<a name="ln3131">  int at_start_sent;</a>
<a name="ln3132">  long ncount;</a>
<a name="ln3133"> </a>
<a name="ln3134">  start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3135">  pos = start_pos;</a>
<a name="ln3136">  findsent(FORWARD, 1L);        /* Find start of next sentence. */</a>
<a name="ln3137"> </a>
<a name="ln3138">  /*</a>
<a name="ln3139">   * When the Visual area is bigger than one character: Extend it.</a>
<a name="ln3140">   */</a>
<a name="ln3141">  if (VIsual_active &amp;&amp; !equalpos(start_pos, VIsual)) {</a>
<a name="ln3142">extend:</a>
<a name="ln3143">    if (lt(start_pos, VIsual)) {</a>
<a name="ln3144">      /*</a>
<a name="ln3145">       * Cursor at start of Visual area.</a>
<a name="ln3146">       * Find out where we are:</a>
<a name="ln3147">       * - in the white space before a sentence</a>
<a name="ln3148">       * - in a sentence or just after it</a>
<a name="ln3149">       * - at the start of a sentence</a>
<a name="ln3150">       */</a>
<a name="ln3151">      at_start_sent = TRUE;</a>
<a name="ln3152">      decl(&amp;pos);</a>
<a name="ln3153">      while (lt(pos, curwin-&gt;w_cursor)) {</a>
<a name="ln3154">        c = gchar_pos(&amp;pos);</a>
<a name="ln3155">        if (!ascii_iswhite(c)) {</a>
<a name="ln3156">          at_start_sent = FALSE;</a>
<a name="ln3157">          break;</a>
<a name="ln3158">        }</a>
<a name="ln3159">        incl(&amp;pos);</a>
<a name="ln3160">      }</a>
<a name="ln3161">      if (!at_start_sent) {</a>
<a name="ln3162">        findsent(BACKWARD, 1L);</a>
<a name="ln3163">        if (equalpos(curwin-&gt;w_cursor, start_pos))</a>
<a name="ln3164">          at_start_sent = TRUE;            /* exactly at start of sentence */</a>
<a name="ln3165">        else</a>
<a name="ln3166">          /* inside a sentence, go to its end (start of next) */</a>
<a name="ln3167">          findsent(FORWARD, 1L);</a>
<a name="ln3168">      }</a>
<a name="ln3169">      if (include)              /* &quot;as&quot; gets twice as much as &quot;is&quot; */</a>
<a name="ln3170">        count *= 2;</a>
<a name="ln3171">      while (count--) {</a>
<a name="ln3172">        if (at_start_sent)</a>
<a name="ln3173">          find_first_blank(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3174">        c = gchar_cursor();</a>
<a name="ln3175">        if (!at_start_sent || (!include &amp;&amp; !ascii_iswhite(c)))</a>
<a name="ln3176">          findsent(BACKWARD, 1L);</a>
<a name="ln3177">        at_start_sent = !at_start_sent;</a>
<a name="ln3178">      }</a>
<a name="ln3179">    } else {</a>
<a name="ln3180">      /*</a>
<a name="ln3181">       * Cursor at end of Visual area.</a>
<a name="ln3182">       * Find out where we are:</a>
<a name="ln3183">       * - just before a sentence</a>
<a name="ln3184">       * - just before or in the white space before a sentence</a>
<a name="ln3185">       * - in a sentence</a>
<a name="ln3186">       */</a>
<a name="ln3187">      incl(&amp;pos);</a>
<a name="ln3188">      at_start_sent = TRUE;</a>
<a name="ln3189">      if (!equalpos(pos, curwin-&gt;w_cursor)) {     /* not just before a sentence */</a>
<a name="ln3190">        at_start_sent = FALSE;</a>
<a name="ln3191">        while (lt(pos, curwin-&gt;w_cursor)) {</a>
<a name="ln3192">          c = gchar_pos(&amp;pos);</a>
<a name="ln3193">          if (!ascii_iswhite(c)) {</a>
<a name="ln3194">            at_start_sent = TRUE;</a>
<a name="ln3195">            break;</a>
<a name="ln3196">          }</a>
<a name="ln3197">          incl(&amp;pos);</a>
<a name="ln3198">        }</a>
<a name="ln3199">        if (at_start_sent)              /* in the sentence */</a>
<a name="ln3200">          findsent(BACKWARD, 1L);</a>
<a name="ln3201">        else                    /* in/before white before a sentence */</a>
<a name="ln3202">          curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3203">      }</a>
<a name="ln3204"> </a>
<a name="ln3205">      if (include)              /* &quot;as&quot; gets twice as much as &quot;is&quot; */</a>
<a name="ln3206">        count *= 2;</a>
<a name="ln3207">      findsent_forward(count, at_start_sent);</a>
<a name="ln3208">      if (*p_sel == 'e')</a>
<a name="ln3209">        ++curwin-&gt;w_cursor.col;</a>
<a name="ln3210">    }</a>
<a name="ln3211">    return OK;</a>
<a name="ln3212">  }</a>
<a name="ln3213"> </a>
<a name="ln3214">  /*</a>
<a name="ln3215">   * If the cursor started on a blank, check if it is just before the start</a>
<a name="ln3216">   * of the next sentence.</a>
<a name="ln3217">   */</a>
<a name="ln3218">  while (c = gchar_pos(&amp;pos), ascii_iswhite(c))</a>
<a name="ln3219">    incl(&amp;pos);</a>
<a name="ln3220">  if (equalpos(pos, curwin-&gt;w_cursor)) {</a>
<a name="ln3221">    start_blank = TRUE;</a>
<a name="ln3222">    find_first_blank(&amp;start_pos);       /* go back to first blank */</a>
<a name="ln3223">  } else {</a>
<a name="ln3224">    start_blank = FALSE;</a>
<a name="ln3225">    findsent(BACKWARD, 1L);</a>
<a name="ln3226">    start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3227">  }</a>
<a name="ln3228">  if (include)</a>
<a name="ln3229">    ncount = count * 2;</a>
<a name="ln3230">  else {</a>
<a name="ln3231">    ncount = count;</a>
<a name="ln3232">    if (start_blank)</a>
<a name="ln3233">      --ncount;</a>
<a name="ln3234">  }</a>
<a name="ln3235">  if (ncount &gt; 0)</a>
<a name="ln3236">    findsent_forward(ncount, TRUE);</a>
<a name="ln3237">  else</a>
<a name="ln3238">    decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3239"> </a>
<a name="ln3240">  if (include) {</a>
<a name="ln3241">    /*</a>
<a name="ln3242">     * If the blank in front of the sentence is included, exclude the</a>
<a name="ln3243">     * blanks at the end of the sentence, go back to the first blank.</a>
<a name="ln3244">     * If there are no trailing blanks, try to include leading blanks.</a>
<a name="ln3245">     */</a>
<a name="ln3246">    if (start_blank) {</a>
<a name="ln3247">      find_first_blank(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3248">      c = gchar_pos(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3249">      if (ascii_iswhite(c))</a>
<a name="ln3250">        decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3251">    } else if (c = gchar_cursor(), !ascii_iswhite(c))</a>
<a name="ln3252">      find_first_blank(&amp;start_pos);</a>
<a name="ln3253">  }</a>
<a name="ln3254"> </a>
<a name="ln3255">  if (VIsual_active) {</a>
<a name="ln3256">    /* Avoid getting stuck with &quot;is&quot; on a single space before a sentence. */</a>
<a name="ln3257">    if (equalpos(start_pos, curwin-&gt;w_cursor))</a>
<a name="ln3258">      goto extend;</a>
<a name="ln3259">    if (*p_sel == 'e')</a>
<a name="ln3260">      ++curwin-&gt;w_cursor.col;</a>
<a name="ln3261">    VIsual = start_pos;</a>
<a name="ln3262">    VIsual_mode = 'v';</a>
<a name="ln3263">    redraw_cmdline = true;    // show mode later</a>
<a name="ln3264">    redraw_curbuf_later(INVERTED);      // update the inversion</a>
<a name="ln3265">  } else {</a>
<a name="ln3266">    /* include a newline after the sentence, if there is one */</a>
<a name="ln3267">    if (incl(&amp;curwin-&gt;w_cursor) == -1)</a>
<a name="ln3268">      oap-&gt;inclusive = true;</a>
<a name="ln3269">    else</a>
<a name="ln3270">      oap-&gt;inclusive = false;</a>
<a name="ln3271">    oap-&gt;start = start_pos;</a>
<a name="ln3272">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln3273">  }</a>
<a name="ln3274">  return OK;</a>
<a name="ln3275">}</a>
<a name="ln3276"> </a>
<a name="ln3277">/*</a>
<a name="ln3278"> * Find block under the cursor, cursor at end.</a>
<a name="ln3279"> * &quot;what&quot; and &quot;other&quot; are two matching parenthesis/brace/etc.</a>
<a name="ln3280"> */</a>
<a name="ln3281">int</a>
<a name="ln3282">current_block(</a>
<a name="ln3283">    oparg_T *oap,</a>
<a name="ln3284">    long count,</a>
<a name="ln3285">    int include,                    /* TRUE == include white space */</a>
<a name="ln3286">    int what,                       /* '(', '{', etc. */</a>
<a name="ln3287">    int other                      /* ')', '}', etc. */</a>
<a name="ln3288">)</a>
<a name="ln3289">{</a>
<a name="ln3290">  pos_T old_pos;</a>
<a name="ln3291">  pos_T       *pos = NULL;</a>
<a name="ln3292">  pos_T start_pos;</a>
<a name="ln3293">  pos_T       *end_pos;</a>
<a name="ln3294">  pos_T old_start, old_end;</a>
<a name="ln3295">  char_u      *save_cpo;</a>
<a name="ln3296">  int sol = FALSE;                      /* '{' at start of line */</a>
<a name="ln3297"> </a>
<a name="ln3298">  old_pos = curwin-&gt;w_cursor;</a>
<a name="ln3299">  old_end = curwin-&gt;w_cursor;           /* remember where we started */</a>
<a name="ln3300">  old_start = old_end;</a>
<a name="ln3301"> </a>
<a name="ln3302">  /*</a>
<a name="ln3303">   * If we start on '(', '{', ')', '}', etc., use the whole block inclusive.</a>
<a name="ln3304">   */</a>
<a name="ln3305">  if (!VIsual_active || equalpos(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln3306">    setpcmark();</a>
<a name="ln3307">    if (what == '{')                    /* ignore indent */</a>
<a name="ln3308">      while (inindent(1))</a>
<a name="ln3309">        if (inc_cursor() != 0)</a>
<a name="ln3310">          break;</a>
<a name="ln3311">    if (gchar_cursor() == what)</a>
<a name="ln3312">      /* cursor on '(' or '{', move cursor just after it */</a>
<a name="ln3313">      ++curwin-&gt;w_cursor.col;</a>
<a name="ln3314">  } else if (lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln3315">    old_start = VIsual;</a>
<a name="ln3316">    curwin-&gt;w_cursor = VIsual;              /* cursor at low end of Visual */</a>
<a name="ln3317">  } else</a>
<a name="ln3318">    old_end = VIsual;</a>
<a name="ln3319"> </a>
<a name="ln3320">  // Search backwards for unclosed '(', '{', etc..</a>
<a name="ln3321">  // Put this position in start_pos.</a>
<a name="ln3322">  // Ignore quotes here.  Keep the &quot;M&quot; flag in 'cpo', as that is what the</a>
<a name="ln3323">  // user wants.</a>
<a name="ln3324">  save_cpo = p_cpo;</a>
<a name="ln3325">  p_cpo = (char_u *)(vim_strchr(p_cpo, CPO_MATCHBSL) != NULL ? &quot;%M&quot; : &quot;%&quot;);</a>
<a name="ln3326">  while (count-- &gt; 0) {</a>
<a name="ln3327">    if ((pos = findmatch(NULL, what)) == NULL) {</a>
<a name="ln3328">      break;</a>
<a name="ln3329">    }</a>
<a name="ln3330">    curwin-&gt;w_cursor = *pos;</a>
<a name="ln3331">    start_pos = *pos;  // the findmatch for end_pos will overwrite *pos</a>
<a name="ln3332">  }</a>
<a name="ln3333">  p_cpo = save_cpo;</a>
<a name="ln3334"> </a>
<a name="ln3335">  /*</a>
<a name="ln3336">   * Search for matching ')', '}', etc.</a>
<a name="ln3337">   * Put this position in curwin-&gt;w_cursor.</a>
<a name="ln3338">   */</a>
<a name="ln3339">  if (pos == NULL || (end_pos = findmatch(NULL, other)) == NULL) {</a>
<a name="ln3340">    curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3341">    return FAIL;</a>
<a name="ln3342">  }</a>
<a name="ln3343">  curwin-&gt;w_cursor = *end_pos;</a>
<a name="ln3344"> </a>
<a name="ln3345">  // Try to exclude the '(', '{', ')', '}', etc. when &quot;include&quot; is FALSE.</a>
<a name="ln3346">  // If the ending '}', ')' or ']' is only preceded by indent, skip that</a>
<a name="ln3347">  // indent. But only if the resulting area is not smaller than what we</a>
<a name="ln3348">  // started with.</a>
<a name="ln3349">  while (!include) {</a>
<a name="ln3350">    incl(&amp;start_pos);</a>
<a name="ln3351">    sol = (curwin-&gt;w_cursor.col == 0);</a>
<a name="ln3352">    decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3353">    while (inindent(1)) {</a>
<a name="ln3354">      sol = TRUE;</a>
<a name="ln3355">      if (decl(&amp;curwin-&gt;w_cursor) != 0) {</a>
<a name="ln3356">        break;</a>
<a name="ln3357">      }</a>
<a name="ln3358">    }</a>
<a name="ln3359"> </a>
<a name="ln3360">    /*</a>
<a name="ln3361">     * In Visual mode, when the resulting area is not bigger than what we</a>
<a name="ln3362">     * started with, extend it to the next block, and then exclude again.</a>
<a name="ln3363">     */</a>
<a name="ln3364">    if (!lt(start_pos, old_start) &amp;&amp; !lt(old_end, curwin-&gt;w_cursor)</a>
<a name="ln3365">        &amp;&amp; VIsual_active) {</a>
<a name="ln3366">      curwin-&gt;w_cursor = old_start;</a>
<a name="ln3367">      decl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3368">      if ((pos = findmatch(NULL, what)) == NULL) {</a>
<a name="ln3369">        curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3370">        return FAIL;</a>
<a name="ln3371">      }</a>
<a name="ln3372">      start_pos = *pos;</a>
<a name="ln3373">      curwin-&gt;w_cursor = *pos;</a>
<a name="ln3374">      if ((end_pos = findmatch(NULL, other)) == NULL) {</a>
<a name="ln3375">        curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3376">        return FAIL;</a>
<a name="ln3377">      }</a>
<a name="ln3378">      curwin-&gt;w_cursor = *end_pos;</a>
<a name="ln3379">    } else</a>
<a name="ln3380">      break;</a>
<a name="ln3381">  }</a>
<a name="ln3382"> </a>
<a name="ln3383">  if (VIsual_active) {</a>
<a name="ln3384">    if (*p_sel == 'e') {</a>
<a name="ln3385">      inc(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3386">    }</a>
<a name="ln3387">    if (sol &amp;&amp; gchar_cursor() != NUL) {</a>
<a name="ln3388">      inc(&amp;curwin-&gt;w_cursor);  // include the line break</a>
<a name="ln3389">    }</a>
<a name="ln3390">    VIsual = start_pos;</a>
<a name="ln3391">    VIsual_mode = 'v';</a>
<a name="ln3392">    redraw_curbuf_later(INVERTED);      /* update the inversion */</a>
<a name="ln3393">    showmode();</a>
<a name="ln3394">  } else {</a>
<a name="ln3395">    oap-&gt;start = start_pos;</a>
<a name="ln3396">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln3397">    oap-&gt;inclusive = false;</a>
<a name="ln3398">    if (sol)</a>
<a name="ln3399">      incl(&amp;curwin-&gt;w_cursor);</a>
<a name="ln3400">    else if (ltoreq(start_pos, curwin-&gt;w_cursor))</a>
<a name="ln3401">      /* Include the character under the cursor. */</a>
<a name="ln3402">      oap-&gt;inclusive = true;</a>
<a name="ln3403">    else</a>
<a name="ln3404">      /* End is before the start (no text in between &lt;&gt;, [], etc.): don't</a>
<a name="ln3405">       * operate on any text. */</a>
<a name="ln3406">      curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3407">  }</a>
<a name="ln3408"> </a>
<a name="ln3409">  return OK;</a>
<a name="ln3410">}</a>
<a name="ln3411"> </a>
<a name="ln3412"> </a>
<a name="ln3413">/*</a>
<a name="ln3414"> * Return TRUE if the cursor is on a &quot;&lt;aaa&gt;&quot; tag.  Ignore &quot;&lt;aaa/&gt;&quot;.</a>
<a name="ln3415"> * When &quot;end_tag&quot; is TRUE return TRUE if the cursor is on &quot;&lt;/aaa&gt;&quot;.</a>
<a name="ln3416"> */</a>
<a name="ln3417">static int in_html_tag(int end_tag)</a>
<a name="ln3418">{</a>
<a name="ln3419">  char_u      *line = get_cursor_line_ptr();</a>
<a name="ln3420">  char_u      *p;</a>
<a name="ln3421">  int c;</a>
<a name="ln3422">  int lc = NUL;</a>
<a name="ln3423">  pos_T pos;</a>
<a name="ln3424"> </a>
<a name="ln3425">  for (p = line + curwin-&gt;w_cursor.col; p &gt; line; ) {</a>
<a name="ln3426">    if (*p == '&lt;') {           // find '&lt;' under/before cursor</a>
<a name="ln3427">      break;</a>
<a name="ln3428">    }</a>
<a name="ln3429">    MB_PTR_BACK(line, p);</a>
<a name="ln3430">    if (*p == '&gt;') {           // find '&gt;' before cursor</a>
<a name="ln3431">      break;</a>
<a name="ln3432">    }</a>
<a name="ln3433">  }</a>
<a name="ln3434">  if (*p != '&lt;') {</a>
<a name="ln3435">    return false;</a>
<a name="ln3436">  }</a>
<a name="ln3437"> </a>
<a name="ln3438">  pos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3439">  pos.col = (colnr_T)(p - line);</a>
<a name="ln3440"> </a>
<a name="ln3441">  MB_PTR_ADV(p);</a>
<a name="ln3442">  if (end_tag) {</a>
<a name="ln3443">    // check that there is a '/' after the '&lt;'</a>
<a name="ln3444">    return *p == '/';</a>
<a name="ln3445">  }</a>
<a name="ln3446"> </a>
<a name="ln3447">  /* check that there is no '/' after the '&lt;' */</a>
<a name="ln3448">  if (*p == '/')</a>
<a name="ln3449">    return FALSE;</a>
<a name="ln3450"> </a>
<a name="ln3451">  /* check that the matching '&gt;' is not preceded by '/' */</a>
<a name="ln3452">  for (;; ) {</a>
<a name="ln3453">    if (inc(&amp;pos) &lt; 0)</a>
<a name="ln3454">      return FALSE;</a>
<a name="ln3455">    c = *ml_get_pos(&amp;pos);</a>
<a name="ln3456">    if (c == '&gt;')</a>
<a name="ln3457">      break;</a>
<a name="ln3458">    lc = c;</a>
<a name="ln3459">  }</a>
<a name="ln3460">  return lc != '/';</a>
<a name="ln3461">}</a>
<a name="ln3462"> </a>
<a name="ln3463">/*</a>
<a name="ln3464"> * Find tag block under the cursor, cursor at end.</a>
<a name="ln3465"> */</a>
<a name="ln3466">int</a>
<a name="ln3467">current_tagblock(</a>
<a name="ln3468">    oparg_T *oap,</a>
<a name="ln3469">    long count_arg,</a>
<a name="ln3470">    bool include                  // true == include white space</a>
<a name="ln3471">)</a>
<a name="ln3472">{</a>
<a name="ln3473">  long count = count_arg;</a>
<a name="ln3474">  pos_T old_pos;</a>
<a name="ln3475">  pos_T start_pos;</a>
<a name="ln3476">  pos_T end_pos;</a>
<a name="ln3477">  pos_T old_start, old_end;</a>
<a name="ln3478">  char_u      *p;</a>
<a name="ln3479">  char_u      *cp;</a>
<a name="ln3480">  int len;</a>
<a name="ln3481">  bool do_include = include;</a>
<a name="ln3482">  bool save_p_ws = p_ws;</a>
<a name="ln3483">  int retval = FAIL;</a>
<a name="ln3484">  int is_inclusive = true;</a>
<a name="ln3485"> </a>
<a name="ln3486">  p_ws = false;</a>
<a name="ln3487"> </a>
<a name="ln3488">  old_pos = curwin-&gt;w_cursor;</a>
<a name="ln3489">  old_end = curwin-&gt;w_cursor;               /* remember where we started */</a>
<a name="ln3490">  old_start = old_end;</a>
<a name="ln3491">  if (!VIsual_active || *p_sel == 'e')</a>
<a name="ln3492">    decl(&amp;old_end);                         /* old_end is inclusive */</a>
<a name="ln3493"> </a>
<a name="ln3494">  /*</a>
<a name="ln3495">   * If we start on &quot;&lt;aaa&gt;&quot; select that block.</a>
<a name="ln3496">   */</a>
<a name="ln3497">  if (!VIsual_active || equalpos(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln3498">    setpcmark();</a>
<a name="ln3499"> </a>
<a name="ln3500">    /* ignore indent */</a>
<a name="ln3501">    while (inindent(1))</a>
<a name="ln3502">      if (inc_cursor() != 0)</a>
<a name="ln3503">        break;</a>
<a name="ln3504"> </a>
<a name="ln3505">    if (in_html_tag(FALSE)) {</a>
<a name="ln3506">      /* cursor on start tag, move to its '&gt;' */</a>
<a name="ln3507">      while (*get_cursor_pos_ptr() != '&gt;')</a>
<a name="ln3508">        if (inc_cursor() &lt; 0)</a>
<a name="ln3509">          break;</a>
<a name="ln3510">    } else if (in_html_tag(TRUE)) {</a>
<a name="ln3511">      /* cursor on end tag, move to just before it */</a>
<a name="ln3512">      while (*get_cursor_pos_ptr() != '&lt;')</a>
<a name="ln3513">        if (dec_cursor() &lt; 0)</a>
<a name="ln3514">          break;</a>
<a name="ln3515">      dec_cursor();</a>
<a name="ln3516">      old_end = curwin-&gt;w_cursor;</a>
<a name="ln3517">    }</a>
<a name="ln3518">  } else if (lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln3519">    old_start = VIsual;</a>
<a name="ln3520">    curwin-&gt;w_cursor = VIsual;              /* cursor at low end of Visual */</a>
<a name="ln3521">  } else</a>
<a name="ln3522">    old_end = VIsual;</a>
<a name="ln3523"> </a>
<a name="ln3524">again:</a>
<a name="ln3525">  /*</a>
<a name="ln3526">   * Search backwards for unclosed &quot;&lt;aaa&gt;&quot;.</a>
<a name="ln3527">   * Put this position in start_pos.</a>
<a name="ln3528">   */</a>
<a name="ln3529">  for (long n = 0; n &lt; count; n++) {</a>
<a name="ln3530">    if (do_searchpair(</a>
<a name="ln3531">        &quot;&lt;[^ \t&gt;/!]\\+\\%(\\_s\\_[^&gt;]\\{-}[^/]&gt;\\|$\\|\\_s\\=&gt;\\)&quot;,</a>
<a name="ln3532">        &quot;&quot;,</a>
<a name="ln3533">        &quot;&lt;/[^&gt;]*&gt;&quot;, BACKWARD, NULL, 0,</a>
<a name="ln3534">        NULL, (linenr_T)0, 0L) &lt;= 0) {</a>
<a name="ln3535">      curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3536">      goto theend;</a>
<a name="ln3537">    }</a>
<a name="ln3538">  }</a>
<a name="ln3539">  start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3540"> </a>
<a name="ln3541">  /*</a>
<a name="ln3542">   * Search for matching &quot;&lt;/aaa&gt;&quot;.  First isolate the &quot;aaa&quot;.</a>
<a name="ln3543">   */</a>
<a name="ln3544">  inc_cursor();</a>
<a name="ln3545">  p = get_cursor_pos_ptr();</a>
<a name="ln3546">  for (cp = p;</a>
<a name="ln3547">       *cp != NUL &amp;&amp; *cp != '&gt;' &amp;&amp; !ascii_iswhite(*cp);</a>
<a name="ln3548">       MB_PTR_ADV(cp)) {</a>
<a name="ln3549">  }</a>
<a name="ln3550">  len = (int)(cp - p);</a>
<a name="ln3551">  if (len == 0) {</a>
<a name="ln3552">    curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3553">    goto theend;</a>
<a name="ln3554">  }</a>
<a name="ln3555">  const size_t spat_len = len + 39;</a>
<a name="ln3556">  char *const spat = xmalloc(spat_len);</a>
<a name="ln3557">  const size_t epat_len = len + 9;</a>
<a name="ln3558">  char *const epat = xmalloc(epat_len);</a>
<a name="ln3559">  snprintf(spat, spat_len,</a>
<a name="ln3560">           &quot;&lt;%.*s\\&gt;\\%%(\\_s\\_[^&gt;]\\{-}\\_[^/]&gt;\\|\\_s\\?&gt;\\)\\c&quot;, len, p);</a>
<a name="ln3561">  snprintf(epat, epat_len, &quot;&lt;/%.*s&gt;\\c&quot;, len, p);</a>
<a name="ln3562"> </a>
<a name="ln3563">  const int r = do_searchpair(spat, &quot;&quot;, epat, FORWARD, NULL,</a>
<a name="ln3564">                              0, NULL, (linenr_T)0, 0L);</a>
<a name="ln3565"> </a>
<a name="ln3566">  xfree(spat);</a>
<a name="ln3567">  xfree(epat);</a>
<a name="ln3568"> </a>
<a name="ln3569">  if (r &lt; 1 || lt(curwin-&gt;w_cursor, old_end)) {</a>
<a name="ln3570">    /* Can't find other end or it's before the previous end.  Could be a</a>
<a name="ln3571">     * HTML tag that doesn't have a matching end.  Search backwards for</a>
<a name="ln3572">     * another starting tag. */</a>
<a name="ln3573">    count = 1;</a>
<a name="ln3574">    curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3575">    goto again;</a>
<a name="ln3576">  }</a>
<a name="ln3577"> </a>
<a name="ln3578">  if (do_include) {</a>
<a name="ln3579">    // Include up to the '&gt;'.</a>
<a name="ln3580">    while (*get_cursor_pos_ptr() != '&gt;') {</a>
<a name="ln3581">      if (inc_cursor() &lt; 0) {</a>
<a name="ln3582">        break;</a>
<a name="ln3583">      }</a>
<a name="ln3584">    }</a>
<a name="ln3585">  } else {</a>
<a name="ln3586">    char_u *c = get_cursor_pos_ptr();</a>
<a name="ln3587">    // Exclude the '&lt;' of the end tag.</a>
<a name="ln3588">    // If the closing tag is on new line, do not decrement cursor, but make</a>
<a name="ln3589">    // operation exclusive, so that the linefeed will be selected</a>
<a name="ln3590">    if (*c == '&lt;' &amp;&amp; !VIsual_active &amp;&amp; curwin-&gt;w_cursor.col == 0) {</a>
<a name="ln3591">      // do not decrement cursor</a>
<a name="ln3592">      is_inclusive = false;</a>
<a name="ln3593">    } else if (*c == '&lt;') {</a>
<a name="ln3594">      dec_cursor();</a>
<a name="ln3595">    }</a>
<a name="ln3596">  }</a>
<a name="ln3597">  end_pos = curwin-&gt;w_cursor;</a>
<a name="ln3598"> </a>
<a name="ln3599">  if (!do_include) {</a>
<a name="ln3600">    /* Exclude the start tag. */</a>
<a name="ln3601">    curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3602">    while (inc_cursor() &gt;= 0)</a>
<a name="ln3603">      if (*get_cursor_pos_ptr() == '&gt;') {</a>
<a name="ln3604">        inc_cursor();</a>
<a name="ln3605">        start_pos = curwin-&gt;w_cursor;</a>
<a name="ln3606">        break;</a>
<a name="ln3607">      }</a>
<a name="ln3608">    curwin-&gt;w_cursor = end_pos;</a>
<a name="ln3609"> </a>
<a name="ln3610">    // If we are in Visual mode and now have the same text as before set</a>
<a name="ln3611">    // &quot;do_include&quot; and try again.</a>
<a name="ln3612">    if (VIsual_active</a>
<a name="ln3613">        &amp;&amp; equalpos(start_pos, old_start)</a>
<a name="ln3614">        &amp;&amp; equalpos(end_pos, old_end)) {</a>
<a name="ln3615">      do_include = true;</a>
<a name="ln3616">      curwin-&gt;w_cursor = old_start;</a>
<a name="ln3617">      count = count_arg;</a>
<a name="ln3618">      goto again;</a>
<a name="ln3619">    }</a>
<a name="ln3620">  }</a>
<a name="ln3621"> </a>
<a name="ln3622">  if (VIsual_active) {</a>
<a name="ln3623">    /* If the end is before the start there is no text between tags, select</a>
<a name="ln3624">     * the char under the cursor. */</a>
<a name="ln3625">    if (lt(end_pos, start_pos)) {</a>
<a name="ln3626">      curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3627">    } else if (*p_sel == 'e') {</a>
<a name="ln3628">      inc_cursor();</a>
<a name="ln3629">    }</a>
<a name="ln3630">    VIsual = start_pos;</a>
<a name="ln3631">    VIsual_mode = 'v';</a>
<a name="ln3632">    redraw_curbuf_later(INVERTED);      /* update the inversion */</a>
<a name="ln3633">    showmode();</a>
<a name="ln3634">  } else {</a>
<a name="ln3635">    oap-&gt;start = start_pos;</a>
<a name="ln3636">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln3637">    if (lt(end_pos, start_pos)) {</a>
<a name="ln3638">      /* End is before the start: there is no text between tags; operate</a>
<a name="ln3639">       * on an empty area. */</a>
<a name="ln3640">      curwin-&gt;w_cursor = start_pos;</a>
<a name="ln3641">      oap-&gt;inclusive = false;</a>
<a name="ln3642">    } else {</a>
<a name="ln3643">      oap-&gt;inclusive = is_inclusive;</a>
<a name="ln3644">    }</a>
<a name="ln3645">  }</a>
<a name="ln3646">  retval = OK;</a>
<a name="ln3647"> </a>
<a name="ln3648">theend:</a>
<a name="ln3649">  p_ws = save_p_ws;</a>
<a name="ln3650">  return retval;</a>
<a name="ln3651">}</a>
<a name="ln3652"> </a>
<a name="ln3653">int</a>
<a name="ln3654">current_par(</a>
<a name="ln3655">    oparg_T *oap,</a>
<a name="ln3656">    long count,</a>
<a name="ln3657">    int include,                    /* TRUE == include white space */</a>
<a name="ln3658">    int type                       /* 'p' for paragraph, 'S' for section */</a>
<a name="ln3659">)</a>
<a name="ln3660">{</a>
<a name="ln3661">  linenr_T start_lnum;</a>
<a name="ln3662">  linenr_T end_lnum;</a>
<a name="ln3663">  int white_in_front;</a>
<a name="ln3664">  int dir;</a>
<a name="ln3665">  int start_is_white;</a>
<a name="ln3666">  int prev_start_is_white;</a>
<a name="ln3667">  int retval = OK;</a>
<a name="ln3668">  int do_white = FALSE;</a>
<a name="ln3669">  int t;</a>
<a name="ln3670">  int i;</a>
<a name="ln3671"> </a>
<a name="ln3672">  if (type == 'S')          /* not implemented yet */</a>
<a name="ln3673">    return FAIL;</a>
<a name="ln3674"> </a>
<a name="ln3675">  start_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3676"> </a>
<a name="ln3677">  /*</a>
<a name="ln3678">   * When visual area is more than one line: extend it.</a>
<a name="ln3679">   */</a>
<a name="ln3680">  if (VIsual_active &amp;&amp; start_lnum != VIsual.lnum) {</a>
<a name="ln3681">extend:</a>
<a name="ln3682">    if (start_lnum &lt; VIsual.lnum)</a>
<a name="ln3683">      dir = BACKWARD;</a>
<a name="ln3684">    else</a>
<a name="ln3685">      dir = FORWARD;</a>
<a name="ln3686">    for (i = count; --i &gt;= 0; ) {</a>
<a name="ln3687">      if (start_lnum ==</a>
<a name="ln3688">          (dir == BACKWARD ? 1 : curbuf-&gt;b_ml.ml_line_count)) {</a>
<a name="ln3689">        retval = FAIL;</a>
<a name="ln3690">        break;</a>
<a name="ln3691">      }</a>
<a name="ln3692"> </a>
<a name="ln3693">      prev_start_is_white = -1;</a>
<a name="ln3694">      for (t = 0; t &lt; 2; ++t) {</a>
<a name="ln3695">        start_lnum += dir;</a>
<a name="ln3696">        start_is_white = linewhite(start_lnum);</a>
<a name="ln3697">        if (prev_start_is_white == start_is_white) {</a>
<a name="ln3698">          start_lnum -= dir;</a>
<a name="ln3699">          break;</a>
<a name="ln3700">        }</a>
<a name="ln3701">        for (;; ) {</a>
<a name="ln3702">          if (start_lnum == (dir == BACKWARD</a>
<a name="ln3703">                             ? 1 : curbuf-&gt;b_ml.ml_line_count))</a>
<a name="ln3704">            break;</a>
<a name="ln3705">          if (start_is_white != linewhite(start_lnum + dir)</a>
<a name="ln3706">              || (!start_is_white</a>
<a name="ln3707">                  &amp;&amp; startPS(start_lnum + (dir &gt; 0</a>
<a name="ln3708">                                           ? 1 : 0), 0, 0)))</a>
<a name="ln3709">            break;</a>
<a name="ln3710">          start_lnum += dir;</a>
<a name="ln3711">        }</a>
<a name="ln3712">        if (!include)</a>
<a name="ln3713">          break;</a>
<a name="ln3714">        if (start_lnum == (dir == BACKWARD</a>
<a name="ln3715">                           ? 1 : curbuf-&gt;b_ml.ml_line_count))</a>
<a name="ln3716">          break;</a>
<a name="ln3717">        prev_start_is_white = start_is_white;</a>
<a name="ln3718">      }</a>
<a name="ln3719">    }</a>
<a name="ln3720">    curwin-&gt;w_cursor.lnum = start_lnum;</a>
<a name="ln3721">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3722">    return retval;</a>
<a name="ln3723">  }</a>
<a name="ln3724"> </a>
<a name="ln3725">  /*</a>
<a name="ln3726">   * First move back to the start_lnum of the paragraph or white lines</a>
<a name="ln3727">   */</a>
<a name="ln3728">  white_in_front = linewhite(start_lnum);</a>
<a name="ln3729">  while (start_lnum &gt; 1) {</a>
<a name="ln3730">    if (white_in_front) {           /* stop at first white line */</a>
<a name="ln3731">      if (!linewhite(start_lnum - 1))</a>
<a name="ln3732">        break;</a>
<a name="ln3733">    } else {          /* stop at first non-white line of start of paragraph */</a>
<a name="ln3734">      if (linewhite(start_lnum - 1) || startPS(start_lnum, 0, 0))</a>
<a name="ln3735">        break;</a>
<a name="ln3736">    }</a>
<a name="ln3737">    --start_lnum;</a>
<a name="ln3738">  }</a>
<a name="ln3739"> </a>
<a name="ln3740">  /*</a>
<a name="ln3741">   * Move past the end of any white lines.</a>
<a name="ln3742">   */</a>
<a name="ln3743">  end_lnum = start_lnum;</a>
<a name="ln3744">  while (end_lnum &lt;= curbuf-&gt;b_ml.ml_line_count &amp;&amp; linewhite(end_lnum))</a>
<a name="ln3745">    ++end_lnum;</a>
<a name="ln3746"> </a>
<a name="ln3747">  --end_lnum;</a>
<a name="ln3748">  i = count;</a>
<a name="ln3749">  if (!include &amp;&amp; white_in_front)</a>
<a name="ln3750">    --i;</a>
<a name="ln3751">  while (i--) {</a>
<a name="ln3752">    if (end_lnum == curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln3753">      return FAIL;</a>
<a name="ln3754"> </a>
<a name="ln3755">    if (!include)</a>
<a name="ln3756">      do_white = linewhite(end_lnum + 1);</a>
<a name="ln3757"> </a>
<a name="ln3758">    if (include || !do_white) {</a>
<a name="ln3759">      ++end_lnum;</a>
<a name="ln3760">      /*</a>
<a name="ln3761">       * skip to end of paragraph</a>
<a name="ln3762">       */</a>
<a name="ln3763">      while (end_lnum &lt; curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln3764">             &amp;&amp; !linewhite(end_lnum + 1)</a>
<a name="ln3765">             &amp;&amp; !startPS(end_lnum + 1, 0, 0))</a>
<a name="ln3766">        ++end_lnum;</a>
<a name="ln3767">    }</a>
<a name="ln3768"> </a>
<a name="ln3769">    if (i == 0 &amp;&amp; white_in_front &amp;&amp; include)</a>
<a name="ln3770">      break;</a>
<a name="ln3771"> </a>
<a name="ln3772">    /*</a>
<a name="ln3773">     * skip to end of white lines after paragraph</a>
<a name="ln3774">     */</a>
<a name="ln3775">    if (include || do_white)</a>
<a name="ln3776">      while (end_lnum &lt; curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln3777">             &amp;&amp; linewhite(end_lnum + 1))</a>
<a name="ln3778">        ++end_lnum;</a>
<a name="ln3779">  }</a>
<a name="ln3780"> </a>
<a name="ln3781">  /*</a>
<a name="ln3782">   * If there are no empty lines at the end, try to find some empty lines at</a>
<a name="ln3783">   * the start (unless that has been done already).</a>
<a name="ln3784">   */</a>
<a name="ln3785">  if (!white_in_front &amp;&amp; !linewhite(end_lnum) &amp;&amp; include)</a>
<a name="ln3786">    while (start_lnum &gt; 1 &amp;&amp; linewhite(start_lnum - 1))</a>
<a name="ln3787">      --start_lnum;</a>
<a name="ln3788"> </a>
<a name="ln3789">  if (VIsual_active) {</a>
<a name="ln3790">    // Problem: when doing &quot;Vipipip&quot; nothing happens in a single white</a>
<a name="ln3791">    // line, we get stuck there.  Trap this here.</a>
<a name="ln3792">    if (VIsual_mode == 'V' &amp;&amp; start_lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln3793">      goto extend;</a>
<a name="ln3794">    }</a>
<a name="ln3795">    if (VIsual.lnum != start_lnum) {</a>
<a name="ln3796">        VIsual.lnum = start_lnum;</a>
<a name="ln3797">        VIsual.col = 0;</a>
<a name="ln3798">    }</a>
<a name="ln3799">    VIsual_mode = 'V';</a>
<a name="ln3800">    redraw_curbuf_later(INVERTED);      /* update the inversion */</a>
<a name="ln3801">    showmode();</a>
<a name="ln3802">  } else {</a>
<a name="ln3803">    oap-&gt;start.lnum = start_lnum;</a>
<a name="ln3804">    oap-&gt;start.col = 0;</a>
<a name="ln3805">    oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln3806">  }</a>
<a name="ln3807">  curwin-&gt;w_cursor.lnum = end_lnum;</a>
<a name="ln3808">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3809"> </a>
<a name="ln3810">  return OK;</a>
<a name="ln3811">}</a>
<a name="ln3812"> </a>
<a name="ln3813"> </a>
<a name="ln3814">/*</a>
<a name="ln3815"> * Search quote char from string line[col].</a>
<a name="ln3816"> * Quote character escaped by one of the characters in &quot;escape&quot; is not counted</a>
<a name="ln3817"> * as a quote.</a>
<a name="ln3818"> * Returns column number of &quot;quotechar&quot; or -1 when not found.</a>
<a name="ln3819"> */</a>
<a name="ln3820">static int</a>
<a name="ln3821">find_next_quote(</a>
<a name="ln3822">    char_u *line,</a>
<a name="ln3823">    int col,</a>
<a name="ln3824">    int quotechar,</a>
<a name="ln3825">    char_u *escape            /* escape characters, can be NULL */</a>
<a name="ln3826">)</a>
<a name="ln3827">{</a>
<a name="ln3828">  int c;</a>
<a name="ln3829"> </a>
<a name="ln3830">  for (;; ) {</a>
<a name="ln3831">    c = line[col];</a>
<a name="ln3832">    if (c == NUL) {</a>
<a name="ln3833">      return -1;</a>
<a name="ln3834">    } else if (escape != NULL &amp;&amp; vim_strchr(escape, c)) {</a>
<a name="ln3835">      col++;</a>
<a name="ln3836">    } else if (c == quotechar) {</a>
<a name="ln3837">      break;</a>
<a name="ln3838">    }</a>
<a name="ln3839">    col += mb_ptr2len(line + col);</a>
<a name="ln3840">  }</a>
<a name="ln3841">  return col;</a>
<a name="ln3842">}</a>
<a name="ln3843"> </a>
<a name="ln3844">/*</a>
<a name="ln3845"> * Search backwards in &quot;line&quot; from column &quot;col_start&quot; to find &quot;quotechar&quot;.</a>
<a name="ln3846"> * Quote character escaped by one of the characters in &quot;escape&quot; is not counted</a>
<a name="ln3847"> * as a quote.</a>
<a name="ln3848"> * Return the found column or zero.</a>
<a name="ln3849"> */</a>
<a name="ln3850">static int</a>
<a name="ln3851">find_prev_quote(</a>
<a name="ln3852">    char_u *line,</a>
<a name="ln3853">    int col_start,</a>
<a name="ln3854">    int quotechar,</a>
<a name="ln3855">    char_u *escape            /* escape characters, can be NULL */</a>
<a name="ln3856">)</a>
<a name="ln3857">{</a>
<a name="ln3858">  int n;</a>
<a name="ln3859"> </a>
<a name="ln3860">  while (col_start &gt; 0) {</a>
<a name="ln3861">    col_start--;</a>
<a name="ln3862">    col_start -= utf_head_off(line, line + col_start);</a>
<a name="ln3863">    n = 0;</a>
<a name="ln3864">    if (escape != NULL)</a>
<a name="ln3865">      while (col_start - n &gt; 0 &amp;&amp; vim_strchr(escape,</a>
<a name="ln3866">                 line[col_start - n - 1]) != NULL)</a>
<a name="ln3867">        ++n;</a>
<a name="ln3868">    if (n &amp; 1)</a>
<a name="ln3869">      col_start -= n;           /* uneven number of escape chars, skip it */</a>
<a name="ln3870">    else if (line[col_start] == quotechar)</a>
<a name="ln3871">      break;</a>
<a name="ln3872">  }</a>
<a name="ln3873">  return col_start;</a>
<a name="ln3874">}</a>
<a name="ln3875"> </a>
<a name="ln3876">// Find quote under the cursor, cursor at end.</a>
<a name="ln3877">// Returns true if found, else false.</a>
<a name="ln3878">bool current_quote(</a>
<a name="ln3879">    oparg_T *oap,</a>
<a name="ln3880">    long count,</a>
<a name="ln3881">    bool include,                 // true == include quote char</a>
<a name="ln3882">    int quotechar                 // Quote character</a>
<a name="ln3883">)</a>
<a name="ln3884">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3885">{</a>
<a name="ln3886">  char_u      *line = get_cursor_line_ptr();</a>
<a name="ln3887">  int col_end;</a>
<a name="ln3888">  int col_start = curwin-&gt;w_cursor.col;</a>
<a name="ln3889">  bool inclusive = false;</a>
<a name="ln3890">  bool vis_empty = true;                // Visual selection &lt;= 1 char</a>
<a name="ln3891">  bool vis_bef_curs = false;            // Visual starts before cursor</a>
<a name="ln3892">  bool did_exclusive_adj = false;       // adjusted pos for 'selection'</a>
<a name="ln3893">  bool inside_quotes = false;           // Looks like &quot;i'&quot; done before</a>
<a name="ln3894">  bool selected_quote = false;          // Has quote inside selection</a>
<a name="ln3895">  int i;</a>
<a name="ln3896">  bool restore_vis_bef = false;         // resotre VIsual on abort</a>
<a name="ln3897"> </a>
<a name="ln3898">  // When 'selection' is &quot;exclusive&quot; move the cursor to where it would be</a>
<a name="ln3899">  // with 'selection' &quot;inclusive&quot;, so that the logic is the same for both.</a>
<a name="ln3900">  // The cursor then is moved forward after adjusting the area.</a>
<a name="ln3901">  if (VIsual_active) {</a>
<a name="ln3902">    // this only works within one line</a>
<a name="ln3903">    if (VIsual.lnum != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln3904">        return false;</a>
<a name="ln3905">    }</a>
<a name="ln3906"> </a>
<a name="ln3907">    vis_bef_curs = lt(VIsual, curwin-&gt;w_cursor);</a>
<a name="ln3908">    vis_empty = equalpos(VIsual, curwin-&gt;w_cursor);</a>
<a name="ln3909">    if (*p_sel == 'e') {</a>
<a name="ln3910">      if (vis_bef_curs) {</a>
<a name="ln3911">        dec_cursor();</a>
<a name="ln3912">        did_exclusive_adj = true;</a>
<a name="ln3913">      } else if (!vis_empty) {</a>
<a name="ln3914">        dec(&amp;VIsual);</a>
<a name="ln3915">        did_exclusive_adj = true;</a>
<a name="ln3916">      }</a>
<a name="ln3917">      vis_empty = equalpos(VIsual, curwin-&gt;w_cursor);</a>
<a name="ln3918">      if (!vis_bef_curs &amp;&amp; !vis_empty) {</a>
<a name="ln3919">        // VIsual needs to be start of Visual selection.</a>
<a name="ln3920">        pos_T t = curwin-&gt;w_cursor;</a>
<a name="ln3921"> </a>
<a name="ln3922">        curwin-&gt;w_cursor = VIsual;</a>
<a name="ln3923">        VIsual = t;</a>
<a name="ln3924">        vis_bef_curs = true;</a>
<a name="ln3925">        restore_vis_bef = true;</a>
<a name="ln3926">      }</a>
<a name="ln3927">    }</a>
<a name="ln3928">  }</a>
<a name="ln3929"> </a>
<a name="ln3930">  if (!vis_empty) {</a>
<a name="ln3931">    /* Check if the existing selection exactly spans the text inside</a>
<a name="ln3932">     * quotes. */</a>
<a name="ln3933">    if (vis_bef_curs) {</a>
<a name="ln3934">      inside_quotes = VIsual.col &gt; 0</a>
<a name="ln3935">                      &amp;&amp; line[VIsual.col - 1] == quotechar</a>
<a name="ln3936">                      &amp;&amp; line[curwin-&gt;w_cursor.col] != NUL</a>
<a name="ln3937">                      &amp;&amp; line[curwin-&gt;w_cursor.col + 1] == quotechar;</a>
<a name="ln3938">      i = VIsual.col;</a>
<a name="ln3939">      col_end = curwin-&gt;w_cursor.col;</a>
<a name="ln3940">    } else {</a>
<a name="ln3941">      inside_quotes = curwin-&gt;w_cursor.col &gt; 0</a>
<a name="ln3942">                      &amp;&amp; line[curwin-&gt;w_cursor.col - 1] == quotechar</a>
<a name="ln3943">                      &amp;&amp; line[VIsual.col] != NUL</a>
<a name="ln3944">                      &amp;&amp; line[VIsual.col + 1] == quotechar;</a>
<a name="ln3945">      i = curwin-&gt;w_cursor.col;</a>
<a name="ln3946">      col_end = VIsual.col;</a>
<a name="ln3947">    }</a>
<a name="ln3948"> </a>
<a name="ln3949">    /* Find out if we have a quote in the selection. */</a>
<a name="ln3950">    while (i &lt;= col_end)</a>
<a name="ln3951">      if (line[i++] == quotechar) {</a>
<a name="ln3952">        selected_quote = true;</a>
<a name="ln3953">        break;</a>
<a name="ln3954">      }</a>
<a name="ln3955">  }</a>
<a name="ln3956"> </a>
<a name="ln3957">  if (!vis_empty &amp;&amp; line[col_start] == quotechar) {</a>
<a name="ln3958">    /* Already selecting something and on a quote character.  Find the</a>
<a name="ln3959">     * next quoted string. */</a>
<a name="ln3960">    if (vis_bef_curs) {</a>
<a name="ln3961">      /* Assume we are on a closing quote: move to after the next</a>
<a name="ln3962">       * opening quote. */</a>
<a name="ln3963">      col_start = find_next_quote(line, col_start + 1, quotechar, NULL);</a>
<a name="ln3964">      if (col_start &lt; 0) {</a>
<a name="ln3965">        goto abort_search;</a>
<a name="ln3966">      }</a>
<a name="ln3967">      col_end = find_next_quote(line, col_start + 1, quotechar,</a>
<a name="ln3968">          curbuf-&gt;b_p_qe);</a>
<a name="ln3969">      if (col_end &lt; 0) {</a>
<a name="ln3970">        /* We were on a starting quote perhaps? */</a>
<a name="ln3971">        col_end = col_start;</a>
<a name="ln3972">        col_start = curwin-&gt;w_cursor.col;</a>
<a name="ln3973">      }</a>
<a name="ln3974">    } else {</a>
<a name="ln3975">      col_end = find_prev_quote(line, col_start, quotechar, NULL);</a>
<a name="ln3976">      if (line[col_end] != quotechar) {</a>
<a name="ln3977">        goto abort_search;</a>
<a name="ln3978">      }</a>
<a name="ln3979">      col_start = find_prev_quote(line, col_end, quotechar,</a>
<a name="ln3980">          curbuf-&gt;b_p_qe);</a>
<a name="ln3981">      if (line[col_start] != quotechar) {</a>
<a name="ln3982">        /* We were on an ending quote perhaps? */</a>
<a name="ln3983">        col_start = col_end;</a>
<a name="ln3984">        col_end = curwin-&gt;w_cursor.col;</a>
<a name="ln3985">      }</a>
<a name="ln3986">    }</a>
<a name="ln3987">  } else if (line[col_start] == quotechar</a>
<a name="ln3988">             || !vis_empty</a>
<a name="ln3989">             ) {</a>
<a name="ln3990">    int first_col = col_start;</a>
<a name="ln3991"> </a>
<a name="ln3992">    if (!vis_empty) {</a>
<a name="ln3993">      if (vis_bef_curs)</a>
<a name="ln3994">        first_col = find_next_quote(line, col_start, quotechar, NULL);</a>
<a name="ln3995">      else</a>
<a name="ln3996">        first_col = find_prev_quote(line, col_start, quotechar, NULL);</a>
<a name="ln3997">    }</a>
<a name="ln3998">    /* The cursor is on a quote, we don't know if it's the opening or</a>
<a name="ln3999">     * closing quote.  Search from the start of the line to find out.</a>
<a name="ln4000">     * Also do this when there is a Visual area, a' may leave the cursor</a>
<a name="ln4001">     * in between two strings. */</a>
<a name="ln4002">    col_start = 0;</a>
<a name="ln4003">    for (;; ) {</a>
<a name="ln4004">      /* Find open quote character. */</a>
<a name="ln4005">      col_start = find_next_quote(line, col_start, quotechar, NULL);</a>
<a name="ln4006">      if (col_start &lt; 0 || col_start &gt; first_col) {</a>
<a name="ln4007">        goto abort_search;</a>
<a name="ln4008">      }</a>
<a name="ln4009">      // Find close quote character.</a>
<a name="ln4010">      col_end = find_next_quote(line, col_start + 1, quotechar,</a>
<a name="ln4011">          curbuf-&gt;b_p_qe);</a>
<a name="ln4012">      if (col_end &lt; 0) {</a>
<a name="ln4013">        goto abort_search;</a>
<a name="ln4014">      }</a>
<a name="ln4015">      // If is cursor between start and end quote character, it is</a>
<a name="ln4016">      // target text object.</a>
<a name="ln4017">      if (col_start &lt;= first_col &amp;&amp; first_col &lt;= col_end) {</a>
<a name="ln4018">        break;</a>
<a name="ln4019">      }</a>
<a name="ln4020">      col_start = col_end + 1;</a>
<a name="ln4021">    }</a>
<a name="ln4022">  } else {</a>
<a name="ln4023">    /* Search backward for a starting quote. */</a>
<a name="ln4024">    col_start = find_prev_quote(line, col_start, quotechar, curbuf-&gt;b_p_qe);</a>
<a name="ln4025">    if (line[col_start] != quotechar) {</a>
<a name="ln4026">      /* No quote before the cursor, look after the cursor. */</a>
<a name="ln4027">      col_start = find_next_quote(line, col_start, quotechar, NULL);</a>
<a name="ln4028">      if (col_start &lt; 0) {</a>
<a name="ln4029">        goto abort_search;</a>
<a name="ln4030">      }</a>
<a name="ln4031">    }</a>
<a name="ln4032"> </a>
<a name="ln4033">    /* Find close quote character. */</a>
<a name="ln4034">    col_end = find_next_quote(line, col_start + 1, quotechar,</a>
<a name="ln4035">                              curbuf-&gt;b_p_qe);</a>
<a name="ln4036">    if (col_end &lt; 0) {</a>
<a name="ln4037">      goto abort_search;</a>
<a name="ln4038">    }</a>
<a name="ln4039">  }</a>
<a name="ln4040"> </a>
<a name="ln4041">  // When &quot;include&quot; is true, include spaces after closing quote or before</a>
<a name="ln4042">  // the starting quote.</a>
<a name="ln4043">  if (include) {</a>
<a name="ln4044">    if (ascii_iswhite(line[col_end + 1]))</a>
<a name="ln4045">      while (ascii_iswhite(line[col_end + 1]))</a>
<a name="ln4046">        ++col_end;</a>
<a name="ln4047">    else</a>
<a name="ln4048">      while (col_start &gt; 0 &amp;&amp; ascii_iswhite(line[col_start - 1]))</a>
<a name="ln4049">        --col_start;</a>
<a name="ln4050">  }</a>
<a name="ln4051"> </a>
<a name="ln4052">  /* Set start position.  After vi&quot; another i&quot; must include the &quot;.</a>
<a name="ln4053">   * For v2i&quot; include the quotes. */</a>
<a name="ln4054">  if (!include &amp;&amp; count &lt; 2</a>
<a name="ln4055">      &amp;&amp; (vis_empty || !inside_quotes)</a>
<a name="ln4056">      )</a>
<a name="ln4057">    ++col_start;</a>
<a name="ln4058">  curwin-&gt;w_cursor.col = col_start;</a>
<a name="ln4059">  if (VIsual_active) {</a>
<a name="ln4060">    /* Set the start of the Visual area when the Visual area was empty, we</a>
<a name="ln4061">     * were just inside quotes or the Visual area didn't start at a quote</a>
<a name="ln4062">     * and didn't include a quote.</a>
<a name="ln4063">     */</a>
<a name="ln4064">    if (vis_empty</a>
<a name="ln4065">        || (vis_bef_curs</a>
<a name="ln4066">            &amp;&amp; !selected_quote</a>
<a name="ln4067">            &amp;&amp; (inside_quotes</a>
<a name="ln4068">                || (line[VIsual.col] != quotechar</a>
<a name="ln4069">                    &amp;&amp; (VIsual.col == 0</a>
<a name="ln4070">                        || line[VIsual.col - 1] != quotechar))))) {</a>
<a name="ln4071">      VIsual = curwin-&gt;w_cursor;</a>
<a name="ln4072">      redraw_curbuf_later(INVERTED);</a>
<a name="ln4073">    }</a>
<a name="ln4074">  } else {</a>
<a name="ln4075">    oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln4076">    oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln4077">  }</a>
<a name="ln4078"> </a>
<a name="ln4079">  /* Set end position. */</a>
<a name="ln4080">  curwin-&gt;w_cursor.col = col_end;</a>
<a name="ln4081">  if ((include || count &gt; 1</a>
<a name="ln4082">       /* After vi&quot; another i&quot; must include the &quot;. */</a>
<a name="ln4083">       || (!vis_empty &amp;&amp; inside_quotes)</a>
<a name="ln4084">       ) &amp;&amp; inc_cursor() == 2)</a>
<a name="ln4085">    inclusive = true;</a>
<a name="ln4086">  if (VIsual_active) {</a>
<a name="ln4087">    if (vis_empty || vis_bef_curs) {</a>
<a name="ln4088">      // decrement cursor when 'selection' is not exclusive</a>
<a name="ln4089">      if (*p_sel != 'e') {</a>
<a name="ln4090">        dec_cursor();</a>
<a name="ln4091">      }</a>
<a name="ln4092">    } else {</a>
<a name="ln4093">      /* Cursor is at start of Visual area.  Set the end of the Visual</a>
<a name="ln4094">       * area when it was just inside quotes or it didn't end at a</a>
<a name="ln4095">       * quote. */</a>
<a name="ln4096">      if (inside_quotes</a>
<a name="ln4097">          || (!selected_quote</a>
<a name="ln4098">              &amp;&amp; line[VIsual.col] != quotechar</a>
<a name="ln4099">              &amp;&amp; (line[VIsual.col] == NUL</a>
<a name="ln4100">                  || line[VIsual.col + 1] != quotechar))) {</a>
<a name="ln4101">        dec_cursor();</a>
<a name="ln4102">        VIsual = curwin-&gt;w_cursor;</a>
<a name="ln4103">      }</a>
<a name="ln4104">      curwin-&gt;w_cursor.col = col_start;</a>
<a name="ln4105">    }</a>
<a name="ln4106">    if (VIsual_mode == 'V') {</a>
<a name="ln4107">      VIsual_mode = 'v';</a>
<a name="ln4108">      redraw_cmdline = TRUE;                    /* show mode later */</a>
<a name="ln4109">    }</a>
<a name="ln4110">  } else {</a>
<a name="ln4111">    /* Set inclusive and other oap's flags. */</a>
<a name="ln4112">    oap-&gt;inclusive = inclusive;</a>
<a name="ln4113">  }</a>
<a name="ln4114"> </a>
<a name="ln4115">  return true;</a>
<a name="ln4116"> </a>
<a name="ln4117">abort_search:</a>
<a name="ln4118">  if (VIsual_active &amp;&amp; *p_sel == 'e') {</a>
<a name="ln4119">    if (did_exclusive_adj) {</a>
<a name="ln4120">      inc_cursor();</a>
<a name="ln4121">    }</a>
<a name="ln4122">    if (restore_vis_bef) {</a>
<a name="ln4123">       pos_T t = curwin-&gt;w_cursor;</a>
<a name="ln4124"> </a>
<a name="ln4125">       curwin-&gt;w_cursor = VIsual;</a>
<a name="ln4126">       VIsual = t;</a>
<a name="ln4127">    }</a>
<a name="ln4128">  }</a>
<a name="ln4129">  return false;</a>
<a name="ln4130">}</a>
<a name="ln4131"> </a>
<a name="ln4132"> </a>
<a name="ln4133"> </a>
<a name="ln4134">/*</a>
<a name="ln4135"> * Find next search match under cursor, cursor at end.</a>
<a name="ln4136"> * Used while an operator is pending, and in Visual mode.</a>
<a name="ln4137"> */</a>
<a name="ln4138">int</a>
<a name="ln4139">current_search(</a>
<a name="ln4140">    long count,</a>
<a name="ln4141">    bool forward  // true for forward, false for backward</a>
<a name="ln4142">)</a>
<a name="ln4143">{</a>
<a name="ln4144">  bool old_p_ws = p_ws;</a>
<a name="ln4145">  pos_T save_VIsual = VIsual;</a>
<a name="ln4146"> </a>
<a name="ln4147">  /* Correct cursor when 'selection' is exclusive */</a>
<a name="ln4148">  if (VIsual_active &amp;&amp; *p_sel == 'e' &amp;&amp; lt(VIsual, curwin-&gt;w_cursor))</a>
<a name="ln4149">    dec_cursor();</a>
<a name="ln4150"> </a>
<a name="ln4151">  pos_T end_pos;                // end position of the pattern match</a>
<a name="ln4152">  pos_T orig_pos;               // position of the cursor at beginning</a>
<a name="ln4153">  pos_T pos;                    // position after the pattern</a>
<a name="ln4154">  int result;                   // result of various function calls</a>
<a name="ln4155"> </a>
<a name="ln4156">  // When searching forward and the cursor is at the start of the Visual</a>
<a name="ln4157">  // area, skip the first search backward, otherwise it doesn't move.</a>
<a name="ln4158">  const bool skip_first_backward = forward &amp;&amp; VIsual_active</a>
<a name="ln4159">    &amp;&amp; lt(curwin-&gt;w_cursor, VIsual);</a>
<a name="ln4160"> </a>
<a name="ln4161">  orig_pos = pos = curwin-&gt;w_cursor;</a>
<a name="ln4162">  if (VIsual_active) {</a>
<a name="ln4163">    // Searching further will extend the match.</a>
<a name="ln4164">    if (forward) {</a>
<a name="ln4165">      incl(&amp;pos);</a>
<a name="ln4166">    } else {</a>
<a name="ln4167">      decl(&amp;pos);</a>
<a name="ln4168">    }</a>
<a name="ln4169">  }</a>
<a name="ln4170"> </a>
<a name="ln4171">  // Is the pattern is zero-width?, this time, don't care about the direction</a>
<a name="ln4172">  int zero_width = is_zero_width(spats[last_idx].pat, true, &amp;curwin-&gt;w_cursor,</a>
<a name="ln4173">                                 FORWARD);</a>
<a name="ln4174">  if (zero_width == -1) {</a>
<a name="ln4175">    return FAIL;  // pattern not found</a>
<a name="ln4176">  }</a>
<a name="ln4177"> </a>
<a name="ln4178">  // The trick is to first search backwards and then search forward again,</a>
<a name="ln4179">  // so that a match at the current cursor position will be correctly</a>
<a name="ln4180">  // captured.  When &quot;forward&quot; is false do it the other way around.</a>
<a name="ln4181">  for (int i = 0; i &lt; 2; i++) {</a>
<a name="ln4182">    int dir;</a>
<a name="ln4183">    if (forward) {</a>
<a name="ln4184">      if (i == 0 &amp;&amp; skip_first_backward) {</a>
<a name="ln4185">        continue;</a>
<a name="ln4186">      }</a>
<a name="ln4187">      dir = i;</a>
<a name="ln4188">    } else {</a>
<a name="ln4189">      dir = !i;</a>
<a name="ln4190">    }</a>
<a name="ln4191"> </a>
<a name="ln4192">    int flags = 0;</a>
<a name="ln4193"> </a>
<a name="ln4194">    if (!dir &amp;&amp; !zero_width) {</a>
<a name="ln4195">      flags = SEARCH_END;</a>
<a name="ln4196">    }</a>
<a name="ln4197">    end_pos = pos;</a>
<a name="ln4198"> </a>
<a name="ln4199">    // wrapping should not occur in the first round</a>
<a name="ln4200">    if (i == 0) {</a>
<a name="ln4201">      p_ws = false;</a>
<a name="ln4202">    }</a>
<a name="ln4203"> </a>
<a name="ln4204">    result = searchit(curwin, curbuf, &amp;pos, &amp;end_pos,</a>
<a name="ln4205">                      (dir ? FORWARD : BACKWARD),</a>
<a name="ln4206">                      spats[last_idx].pat, i ? count : 1,</a>
<a name="ln4207">                      SEARCH_KEEP | flags, RE_SEARCH, NULL);</a>
<a name="ln4208"> </a>
<a name="ln4209">    p_ws = old_p_ws;</a>
<a name="ln4210"> </a>
<a name="ln4211">    // First search may fail, but then start searching from the</a>
<a name="ln4212">    // beginning of the file (cursor might be on the search match)</a>
<a name="ln4213">    // except when Visual mode is active, so that extending the visual</a>
<a name="ln4214">    // selection works.</a>
<a name="ln4215">    if (i == 1 &amp;&amp; !result) {  // not found, abort */</a>
<a name="ln4216">      curwin-&gt;w_cursor = orig_pos;</a>
<a name="ln4217">      if (VIsual_active)</a>
<a name="ln4218">        VIsual = save_VIsual;</a>
<a name="ln4219">      return FAIL;</a>
<a name="ln4220">    } else if (i == 0 &amp;&amp; !result) {</a>
<a name="ln4221">      if (forward) {  // try again from start of buffer</a>
<a name="ln4222">        clearpos(&amp;pos);</a>
<a name="ln4223">      } else {  // try again from end of buffer</a>
<a name="ln4224">                // searching backwards, so set pos to last line and col</a>
<a name="ln4225">        pos.lnum = curwin-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln4226">        pos.col  = (colnr_T)STRLEN(</a>
<a name="ln4227">            ml_get(curwin-&gt;w_buffer-&gt;b_ml.ml_line_count));</a>
<a name="ln4228">      }</a>
<a name="ln4229">    }</a>
<a name="ln4230">  }</a>
<a name="ln4231"> </a>
<a name="ln4232">  pos_T start_pos = pos;</a>
<a name="ln4233"> </a>
<a name="ln4234">  if (!VIsual_active) {</a>
<a name="ln4235">    VIsual = start_pos;</a>
<a name="ln4236">  }</a>
<a name="ln4237"> </a>
<a name="ln4238">  // put the cursor after the match</a>
<a name="ln4239">  curwin-&gt;w_cursor = end_pos;</a>
<a name="ln4240">  if (lt(VIsual, end_pos) &amp;&amp; forward) {</a>
<a name="ln4241">    if (skip_first_backward) {</a>
<a name="ln4242">      // put the cursor on the start of the match</a>
<a name="ln4243">      curwin-&gt;w_cursor = pos;</a>
<a name="ln4244">    } else {</a>
<a name="ln4245">      // put the cursor on last character of match</a>
<a name="ln4246">      dec_cursor();</a>
<a name="ln4247">    }</a>
<a name="ln4248">  } else if (VIsual_active &amp;&amp; lt(curwin-&gt;w_cursor, VIsual) &amp;&amp; forward) {</a>
<a name="ln4249">    curwin-&gt;w_cursor = pos;   // put the cursor on the start of the match</a>
<a name="ln4250">  }</a>
<a name="ln4251">  VIsual_active = true;</a>
<a name="ln4252">  VIsual_mode = 'v';</a>
<a name="ln4253"> </a>
<a name="ln4254">  if (*p_sel == 'e') {</a>
<a name="ln4255">    // Correction for exclusive selection depends on the direction.</a>
<a name="ln4256">    if (forward &amp;&amp; ltoreq(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln4257">      inc_cursor();</a>
<a name="ln4258">    } else if (!forward &amp;&amp; ltoreq(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln4259">      inc(&amp;VIsual);</a>
<a name="ln4260">    }</a>
<a name="ln4261">  }</a>
<a name="ln4262"> </a>
<a name="ln4263">  if (fdo_flags &amp; FDO_SEARCH &amp;&amp; KeyTyped) {</a>
<a name="ln4264">    foldOpenCursor();</a>
<a name="ln4265">  }</a>
<a name="ln4266"> </a>
<a name="ln4267">  may_start_select('c');</a>
<a name="ln4268">  setmouse();</a>
<a name="ln4269">  redraw_curbuf_later(INVERTED);</a>
<a name="ln4270">  showmode();</a>
<a name="ln4271"> </a>
<a name="ln4272">  return OK;</a>
<a name="ln4273">}</a>
<a name="ln4274"> </a>
<a name="ln4275">/// Check if the pattern is zero-width.</a>
<a name="ln4276">/// If move is true, check from the beginning of the buffer,</a>
<a name="ln4277">/// else from position &quot;cur&quot;.</a>
<a name="ln4278">/// &quot;direction&quot; is FORWARD or BACKWARD.</a>
<a name="ln4279">/// Returns TRUE, FALSE or -1 for failure.</a>
<a name="ln4280">static int</a>
<a name="ln4281">is_zero_width(char_u *pattern, int move, pos_T *cur, Direction direction)</a>
<a name="ln4282">{</a>
<a name="ln4283">  regmmatch_T regmatch;</a>
<a name="ln4284">  int nmatched = 0;</a>
<a name="ln4285">  int result = -1;</a>
<a name="ln4286">  pos_T pos;</a>
<a name="ln4287">  int save_called_emsg = called_emsg;</a>
<a name="ln4288">  int flag = 0;</a>
<a name="ln4289"> </a>
<a name="ln4290">  if (pattern == NULL) {</a>
<a name="ln4291">    pattern = spats[last_idx].pat;</a>
<a name="ln4292">  }</a>
<a name="ln4293"> </a>
<a name="ln4294">  if (search_regcomp(pattern, RE_SEARCH, RE_SEARCH,</a>
<a name="ln4295">          SEARCH_KEEP, &amp;regmatch) == FAIL)</a>
<a name="ln4296">    return -1;</a>
<a name="ln4297"> </a>
<a name="ln4298">  // init startcol correctly</a>
<a name="ln4299">  regmatch.startpos[0].col = -1;</a>
<a name="ln4300">  // move to match</a>
<a name="ln4301">  if (move) {</a>
<a name="ln4302">    clearpos(&amp;pos);</a>
<a name="ln4303">  } else {</a>
<a name="ln4304">    pos = *cur;</a>
<a name="ln4305">    // accept a match at the cursor position</a>
<a name="ln4306">    flag = SEARCH_START;</a>
<a name="ln4307">  }</a>
<a name="ln4308">  if (searchit(curwin, curbuf, &amp;pos, NULL, direction, pattern, 1,</a>
<a name="ln4309">               SEARCH_KEEP + flag, RE_SEARCH, NULL) != FAIL) {</a>
<a name="ln4310">    // Zero-width pattern should match somewhere, then we can check if</a>
<a name="ln4311">    // start and end are in the same position.</a>
<a name="ln4312">    called_emsg = false;</a>
<a name="ln4313">    do {</a>
<a name="ln4314">      regmatch.startpos[0].col++;</a>
<a name="ln4315">      nmatched = vim_regexec_multi(&amp;regmatch, curwin, curbuf,</a>
<a name="ln4316">                                   pos.lnum, regmatch.startpos[0].col,</a>
<a name="ln4317">                                   NULL, NULL);</a>
<a name="ln4318">      if (nmatched != 0) {</a>
<a name="ln4319">        break;</a>
<a name="ln4320">      }</a>
<a name="ln4321">    } while (regmatch.regprog != NULL</a>
<a name="ln4322">             &amp;&amp; direction == FORWARD</a>
<a name="ln4323">             ? regmatch.startpos[0].col &lt; pos.col</a>
<a name="ln4324">             : regmatch.startpos[0].col &gt; pos.col);</a>
<a name="ln4325"> </a>
<a name="ln4326">    if (!called_emsg) {</a>
<a name="ln4327">      result = (nmatched != 0</a>
<a name="ln4328">                &amp;&amp; regmatch.startpos[0].lnum == regmatch.endpos[0].lnum</a>
<a name="ln4329">                &amp;&amp; regmatch.startpos[0].col == regmatch.endpos[0].col);</a>
<a name="ln4330">    }</a>
<a name="ln4331">  }</a>
<a name="ln4332"> </a>
<a name="ln4333">  called_emsg |= save_called_emsg;</a>
<a name="ln4334">  vim_regfree(regmatch.regprog);</a>
<a name="ln4335">  return result;</a>
<a name="ln4336">}</a>
<a name="ln4337"> </a>
<a name="ln4338">/*</a>
<a name="ln4339"> * return TRUE if line 'lnum' is empty or has white chars only.</a>
<a name="ln4340"> */</a>
<a name="ln4341">int linewhite(linenr_T lnum)</a>
<a name="ln4342">{</a>
<a name="ln4343">  char_u  *p;</a>
<a name="ln4344"> </a>
<a name="ln4345">  p = skipwhite(ml_get(lnum));</a>
<a name="ln4346">  return *p == NUL;</a>
<a name="ln4347">}</a>
<a name="ln4348"> </a>
<a name="ln4349">// Add the search count &quot;[3/19]&quot; to &quot;msgbuf&quot;.</a>
<a name="ln4350">// See update_search_stat() for other arguments.</a>
<a name="ln4351">static void cmdline_search_stat(int dirc, pos_T *pos, pos_T *cursor_pos,</a>
<a name="ln4352">                                bool show_top_bot_msg, char_u  *msgbuf,</a>
<a name="ln4353">                                bool recompute, int maxcount, long timeout)</a>
<a name="ln4354">{</a>
<a name="ln4355">    searchstat_T stat;</a>
<a name="ln4356"> </a>
<a name="ln4357">    update_search_stat(dirc, pos, cursor_pos, &amp;stat, recompute, maxcount,</a>
<a name="ln4358">                       timeout);</a>
<a name="ln4359">    if (stat.cur &gt; 0) {</a>
<a name="ln4360">      char  t[SEARCH_STAT_BUF_LEN];</a>
<a name="ln4361"> </a>
<a name="ln4362">      if (curwin-&gt;w_p_rl &amp;&amp; *curwin-&gt;w_p_rlc == 's') {</a>
<a name="ln4363">        if (stat.incomplete == 1) {</a>
<a name="ln4364">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[?/??]&quot;);</a>
<a name="ln4365">        } else if (stat.cnt &gt; maxcount &amp;&amp; stat.cur &gt; maxcount) {</a>
<a name="ln4366">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[&gt;%d/&gt;%d]&quot;,</a>
<a name="ln4367">                       maxcount, maxcount);</a>
<a name="ln4368">        } else if (stat.cnt &gt; maxcount) {</a>
<a name="ln4369">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[&gt;%d/%d]&quot;,</a>
<a name="ln4370">                       maxcount, stat.cur);</a>
<a name="ln4371">        } else {</a>
<a name="ln4372">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[%d/%d]&quot;,</a>
<a name="ln4373">                       stat.cnt, stat.cur);</a>
<a name="ln4374">        }</a>
<a name="ln4375">      } else {</a>
<a name="ln4376">        if (stat.incomplete == 1) {</a>
<a name="ln4377">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[?/??]&quot;);</a>
<a name="ln4378">        } else if (stat.cnt &gt; maxcount &amp;&amp; stat.cur &gt; maxcount) {</a>
<a name="ln4379">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[&gt;%d/&gt;%d]&quot;,</a>
<a name="ln4380">                       maxcount, maxcount);</a>
<a name="ln4381">        } else if (stat.cnt &gt; maxcount) {</a>
<a name="ln4382">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[%d/&gt;%d]&quot;,</a>
<a name="ln4383">                       stat.cur, maxcount);</a>
<a name="ln4384">        } else {</a>
<a name="ln4385">          vim_snprintf(t, SEARCH_STAT_BUF_LEN, &quot;[%d/%d]&quot;,</a>
<a name="ln4386">                       stat.cur, stat.cnt);</a>
<a name="ln4387">        }</a>
<a name="ln4388">      }</a>
<a name="ln4389"> </a>
<a name="ln4390">      size_t len = strlen(t);</a>
<a name="ln4391">      if (show_top_bot_msg &amp;&amp; len + 2 &lt; SEARCH_STAT_BUF_LEN) {</a>
<a name="ln4392">        memmove(t + 2, t, len);</a>
<a name="ln4393">        t[0] = 'W';</a>
<a name="ln4394">        t[1] = ' ';</a>
<a name="ln4395">        len += 2;</a>
<a name="ln4396">      }</a>
<a name="ln4397"> </a>
<a name="ln4398">      memmove(msgbuf + STRLEN(msgbuf) - len, t, len);</a>
<a name="ln4399">      if (dirc == '?' &amp;&amp; stat.cur == maxcount + 1) {</a>
<a name="ln4400">        stat.cur = -1;</a>
<a name="ln4401">      }</a>
<a name="ln4402"> </a>
<a name="ln4403">      // keep the message even after redraw, but don't put in history</a>
<a name="ln4404">      msg_hist_off = true;</a>
<a name="ln4405">      msg_ext_set_kind(&quot;search_count&quot;);</a>
<a name="ln4406">      give_warning(msgbuf, false);</a>
<a name="ln4407">      msg_hist_off = false;</a>
<a name="ln4408">    }</a>
<a name="ln4409">}</a>
<a name="ln4410"> </a>
<a name="ln4411">// Add the search count information to &quot;stat&quot;.</a>
<a name="ln4412">// &quot;stat&quot; must not be NULL.</a>
<a name="ln4413">// When &quot;recompute&quot; is true always recompute the numbers.</a>
<a name="ln4414">// dirc == 0: don't find the next/previous match (only set the result to &quot;stat&quot;)</a>
<a name="ln4415">// dirc == '/': find the next match</a>
<a name="ln4416">// dirc == '?': find the previous match</a>
<a name="ln4417">static void update_search_stat(int dirc, pos_T *pos, pos_T *cursor_pos,</a>
<a name="ln4418">                               searchstat_T *stat, bool recompute, int maxcount,</a>
<a name="ln4419">                               long timeout)</a>
<a name="ln4420">{</a>
<a name="ln4421">    int             save_ws = p_ws;</a>
<a name="ln4422">    bool             wraparound = false;</a>
<a name="ln4423">    pos_T           p = (*pos);</a>
<a name="ln4424">    static pos_T    lastpos = { 0, 0, 0 };</a>
<a name="ln4425">    static int      cur = 0;</a>
<a name="ln4426">    static int      cnt = 0;</a>
<a name="ln4427">    static bool      exact_match = false;</a>
<a name="ln4428">    static int      incomplete = 0;</a>
<a name="ln4429">    static int      last_maxcount = SEARCH_STAT_DEF_MAX_COUNT;</a>
<a name="ln4430">    static int      chgtick = 0;</a>
<a name="ln4431">    static char_u   *lastpat = NULL;</a>
<a name="ln4432">    static buf_T    *lbuf = NULL;</a>
<a name="ln4433">    proftime_T      start;</a>
<a name="ln4434"> </a>
<a name="ln4435">    memset(stat, 0, sizeof(searchstat_T));</a>
<a name="ln4436"> </a>
<a name="ln4437">    if (dirc == 0 &amp;&amp; !recompute &amp;&amp; !EMPTY_POS(lastpos)) {</a>
<a name="ln4438">      stat-&gt;cur = cur;</a>
<a name="ln4439">      stat-&gt;cnt = cnt;</a>
<a name="ln4440">      stat-&gt;exact_match = exact_match;</a>
<a name="ln4441">      stat-&gt;incomplete = incomplete;</a>
<a name="ln4442">      stat-&gt;last_maxcount = last_maxcount;</a>
<a name="ln4443">      return;</a>
<a name="ln4444">    }</a>
<a name="ln4445">    last_maxcount = maxcount;</a>
<a name="ln4446">    wraparound = ((dirc == '?' &amp;&amp; lt(lastpos, p))</a>
<a name="ln4447">                  || (dirc == '/' &amp;&amp; lt(p, lastpos)));</a>
<a name="ln4448"> </a>
<a name="ln4449">    // If anything relevant changed the count has to be recomputed.</a>
<a name="ln4450">    // STRNICMP ignores case, but we should not ignore case.</a>
<a name="ln4451">    // Unfortunately, there is no STRNICMP function.</a>
<a name="ln4452">    // XXX: above comment should be &quot;no MB_STRCMP function&quot; ?</a>
<a name="ln4453">    if (!(chgtick == buf_get_changedtick(curbuf)</a>
<a name="ln4454">          &amp;&amp; lastpat != NULL  // supress clang/NULL passed as nonnull parameter</a>
<a name="ln4455">          &amp;&amp; STRNICMP(lastpat, spats[last_idx].pat, STRLEN(lastpat)) == 0</a>
<a name="ln4456">          &amp;&amp; STRLEN(lastpat) == STRLEN(spats[last_idx].pat)</a>
<a name="ln4457">          &amp;&amp; equalpos(lastpos, *cursor_pos)</a>
<a name="ln4458">          &amp;&amp; lbuf == curbuf)</a>
<a name="ln4459">        || wraparound || cur &lt; 0 || (maxcount &gt; 0 &amp;&amp; cur &gt; maxcount)</a>
<a name="ln4460">        || recompute) {</a>
<a name="ln4461">      cur = 0;</a>
<a name="ln4462">      cnt = 0;</a>
<a name="ln4463">      exact_match = false;</a>
<a name="ln4464">      incomplete = 0;</a>
<a name="ln4465">      clearpos(&amp;lastpos);</a>
<a name="ln4466">      lbuf = curbuf;</a>
<a name="ln4467">    }</a>
<a name="ln4468"> </a>
<a name="ln4469">    if (equalpos(lastpos, *cursor_pos) &amp;&amp; !wraparound</a>
<a name="ln4470">        &amp;&amp; (dirc == 0 || dirc == '/' ? cur &lt; cnt : cur &gt; 0)) {</a>
<a name="ln4471">      cur += dirc == 0 ? 0 : dirc == '/' ? 1 : -1;</a>
<a name="ln4472">    } else {</a>
<a name="ln4473">      bool done_search = false;</a>
<a name="ln4474">      pos_T endpos = { 0, 0, 0 };</a>
<a name="ln4475">      p_ws = false;</a>
<a name="ln4476">      if (timeout &gt; 0) {</a>
<a name="ln4477">        start  = profile_setlimit(timeout);</a>
<a name="ln4478">      }</a>
<a name="ln4479">      while (!got_int &amp;&amp; searchit(curwin, curbuf, &amp;lastpos, &amp;endpos,</a>
<a name="ln4480">                                  FORWARD, NULL, 1, SEARCH_KEEP, RE_LAST,</a>
<a name="ln4481">                                  NULL) != FAIL) {</a>
<a name="ln4482">        done_search = true;</a>
<a name="ln4483">        // Stop after passing the time limit.</a>
<a name="ln4484">        if (timeout &gt; 0 &amp;&amp; profile_passed_limit(start)) {</a>
<a name="ln4485">          incomplete = 1;</a>
<a name="ln4486">          break;</a>
<a name="ln4487">        }</a>
<a name="ln4488">        cnt++;</a>
<a name="ln4489">        if (ltoreq(lastpos, p)) {</a>
<a name="ln4490">          cur = cnt;</a>
<a name="ln4491">          if (lt(p, endpos)) {</a>
<a name="ln4492">            exact_match = true;</a>
<a name="ln4493">          }</a>
<a name="ln4494">        }</a>
<a name="ln4495">        fast_breakcheck();</a>
<a name="ln4496">        if (maxcount &gt; 0 &amp;&amp; cnt &gt; maxcount) {</a>
<a name="ln4497">          incomplete = 2;    // max count exceeded</a>
<a name="ln4498">          break;</a>
<a name="ln4499">        }</a>
<a name="ln4500">      }</a>
<a name="ln4501">      if (got_int) {</a>
<a name="ln4502">        cur = -1;  // abort</a>
<a name="ln4503">      }</a>
<a name="ln4504">      if (done_search) {</a>
<a name="ln4505">        xfree(lastpat);</a>
<a name="ln4506">        lastpat = vim_strsave(spats[last_idx].pat);</a>
<a name="ln4507">        chgtick = buf_get_changedtick(curbuf);</a>
<a name="ln4508">        lbuf = curbuf;</a>
<a name="ln4509">        lastpos = p;</a>
<a name="ln4510">      }</a>
<a name="ln4511">    }</a>
<a name="ln4512">    stat-&gt;cur = cur;</a>
<a name="ln4513">    stat-&gt;cnt = cnt;</a>
<a name="ln4514">    stat-&gt;exact_match = exact_match;</a>
<a name="ln4515">    stat-&gt;incomplete = incomplete;</a>
<a name="ln4516">    stat-&gt;last_maxcount = last_maxcount;</a>
<a name="ln4517">    p_ws = save_ws;</a>
<a name="ln4518">}</a>
<a name="ln4519"> </a>
<a name="ln4520">// &quot;searchcount()&quot; function</a>
<a name="ln4521">void f_searchcount(typval_T *argvars, typval_T *rettv, FunPtr fptr)</a>
<a name="ln4522">{</a>
<a name="ln4523">    pos_T   pos = curwin-&gt;w_cursor;</a>
<a name="ln4524">    char_u    *pattern = NULL;</a>
<a name="ln4525">    int     maxcount = SEARCH_STAT_DEF_MAX_COUNT;</a>
<a name="ln4526">    long    timeout = SEARCH_STAT_DEF_TIMEOUT;</a>
<a name="ln4527">    bool     recompute = true;</a>
<a name="ln4528">    searchstat_T  stat;</a>
<a name="ln4529"> </a>
<a name="ln4530">    tv_dict_alloc_ret(rettv);</a>
<a name="ln4531"> </a>
<a name="ln4532">    if (shortmess(SHM_SEARCHCOUNT)) {  // 'shortmess' contains 'S' flag</a>
<a name="ln4533">      recompute = true;</a>
<a name="ln4534">    }</a>
<a name="ln4535"> </a>
<a name="ln4536">    if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln4537">      dict_T    *dict;</a>
<a name="ln4538">      dictitem_T  *di;</a>
<a name="ln4539">      listitem_T  *li;</a>
<a name="ln4540">      bool error = false;</a>
<a name="ln4541"> </a>
<a name="ln4542">      if (argvars[0].v_type != VAR_DICT || argvars[0].vval.v_dict == NULL) {</a>
<a name="ln4543">        EMSG(_(e_dictreq));</a>
<a name="ln4544">        return;</a>
<a name="ln4545">      }</a>
<a name="ln4546">      dict = argvars[0].vval.v_dict;</a>
<a name="ln4547">      di = tv_dict_find(dict, (const char *)&quot;timeout&quot;, -1);</a>
<a name="ln4548">      if (di != NULL) {</a>
<a name="ln4549">        timeout = (long)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;error);</a>
<a name="ln4550">        if (error) {</a>
<a name="ln4551">          return;</a>
<a name="ln4552">        }</a>
<a name="ln4553">      }</a>
<a name="ln4554">      di = tv_dict_find(dict, (const char *)&quot;maxcount&quot;, -1);</a>
<a name="ln4555">      if (di != NULL) {</a>
<a name="ln4556">        maxcount = (int)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;error);</a>
<a name="ln4557">        if (error) {</a>
<a name="ln4558">          return;</a>
<a name="ln4559">        }</a>
<a name="ln4560">      }</a>
<a name="ln4561">      di = tv_dict_find(dict, (const char *)&quot;recompute&quot;, -1);</a>
<a name="ln4562">      if (di != NULL) {</a>
<a name="ln4563">        recompute = tv_get_number_chk(&amp;di-&gt;di_tv, &amp;error);</a>
<a name="ln4564">        if (error) {</a>
<a name="ln4565">          return;</a>
<a name="ln4566">        }</a>
<a name="ln4567">      }</a>
<a name="ln4568">      di = tv_dict_find(dict, (const char *)&quot;pattern&quot;, -1);</a>
<a name="ln4569">      if (di != NULL) {</a>
<a name="ln4570">        pattern = (char_u *)tv_get_string_chk(&amp;di-&gt;di_tv);</a>
<a name="ln4571">        if (pattern == NULL) {</a>
<a name="ln4572">          return;</a>
<a name="ln4573">        }</a>
<a name="ln4574">      }</a>
<a name="ln4575">      di = tv_dict_find(dict, (const char *)&quot;pos&quot;, -1);</a>
<a name="ln4576">      if (di != NULL) {</a>
<a name="ln4577">        if (di-&gt;di_tv.v_type != VAR_LIST) {</a>
<a name="ln4578">          EMSG2(_(e_invarg2), &quot;pos&quot;);</a>
<a name="ln4579">          return;</a>
<a name="ln4580">        }</a>
<a name="ln4581">        if (tv_list_len(di-&gt;di_tv.vval.v_list) != 3) {</a>
<a name="ln4582">          EMSG2(_(e_invarg2), &quot;List format should be [lnum, col, off]&quot;);</a>
<a name="ln4583">          return;</a>
<a name="ln4584">        }</a>
<a name="ln4585">        li = tv_list_find(di-&gt;di_tv.vval.v_list, 0L);</a>
<a name="ln4586">        if (li != NULL) {</a>
<a name="ln4587">          pos.lnum = tv_get_number_chk(TV_LIST_ITEM_TV(li), &amp;error);</a>
<a name="ln4588">          if (error) {</a>
<a name="ln4589">            return;</a>
<a name="ln4590">          }</a>
<a name="ln4591">        }</a>
<a name="ln4592">        li = tv_list_find(di-&gt;di_tv.vval.v_list, 1L);</a>
<a name="ln4593">        if (li != NULL) {</a>
<a name="ln4594">          pos.col = tv_get_number_chk(TV_LIST_ITEM_TV(li), &amp;error) - 1;</a>
<a name="ln4595">          if (error) {</a>
<a name="ln4596">            return;</a>
<a name="ln4597">          }</a>
<a name="ln4598">        }</a>
<a name="ln4599">        li = tv_list_find(di-&gt;di_tv.vval.v_list, 2L);</a>
<a name="ln4600">        if (li != NULL) {</a>
<a name="ln4601">          pos.coladd = tv_get_number_chk(TV_LIST_ITEM_TV(li), &amp;error);</a>
<a name="ln4602">          if (error) {</a>
<a name="ln4603">            return;</a>
<a name="ln4604">          }</a>
<a name="ln4605">        }</a>
<a name="ln4606">      }</a>
<a name="ln4607">    }</a>
<a name="ln4608"> </a>
<a name="ln4609">    save_last_search_pattern();</a>
<a name="ln4610">    if (pattern != NULL) {</a>
<a name="ln4611">      if (*pattern == NUL) {</a>
<a name="ln4612">        goto the_end;</a>
<a name="ln4613">      }</a>
<a name="ln4614">      xfree(spats[last_idx].pat);</a>
<a name="ln4615">      spats[last_idx].pat = vim_strsave(pattern);</a>
<a name="ln4616">    }</a>
<a name="ln4617">    if (spats[last_idx].pat == NULL || *spats[last_idx].pat == NUL) {</a>
<a name="ln4618">      goto the_end;  // the previous pattern was never defined</a>
<a name="ln4619">    }</a>
<a name="ln4620"> </a>
<a name="ln4621">    update_search_stat(0, &amp;pos, &amp;pos, &amp;stat, recompute, maxcount, timeout);</a>
<a name="ln4622"> </a>
<a name="ln4623">    tv_dict_add_nr(rettv-&gt;vval.v_dict, S_LEN(&quot;current&quot;), stat.cur);</a>
<a name="ln4624">    tv_dict_add_nr(rettv-&gt;vval.v_dict, S_LEN(&quot;total&quot;), stat.cnt);</a>
<a name="ln4625">    tv_dict_add_nr(rettv-&gt;vval.v_dict, S_LEN(&quot;exact_match&quot;), stat.exact_match);</a>
<a name="ln4626">    tv_dict_add_nr(rettv-&gt;vval.v_dict, S_LEN(&quot;incomplete&quot;), stat.incomplete);</a>
<a name="ln4627">    tv_dict_add_nr(rettv-&gt;vval.v_dict, S_LEN(&quot;maxcount&quot;), stat.last_maxcount);</a>
<a name="ln4628"> </a>
<a name="ln4629">the_end:</a>
<a name="ln4630">    restore_last_search_pattern();</a>
<a name="ln4631">}</a>
<a name="ln4632"> </a>
<a name="ln4633">/*</a>
<a name="ln4634"> * Find identifiers or defines in included files.</a>
<a name="ln4635"> * If p_ic &amp;&amp; (compl_cont_status &amp; CONT_SOL) then ptr must be in lowercase.</a>
<a name="ln4636"> */</a>
<a name="ln4637">void</a>
<a name="ln4638">find_pattern_in_path(</a>
<a name="ln4639">    char_u *ptr,            // pointer to search pattern</a>
<a name="ln4640">    Direction dir,          // direction of expansion</a>
<a name="ln4641">    size_t len,             // length of search pattern</a>
<a name="ln4642">    bool whole,             // match whole words only</a>
<a name="ln4643">    bool skip_comments,     // don't match inside comments</a>
<a name="ln4644">    int type,               // Type of search; are we looking for a type?</a>
<a name="ln4645">                            // a macro?</a>
<a name="ln4646">    long count,</a>
<a name="ln4647">    int action,             // What to do when we find it</a>
<a name="ln4648">    linenr_T start_lnum,    // first line to start searching</a>
<a name="ln4649">    linenr_T end_lnum       // last line for searching</a>
<a name="ln4650">)</a>
<a name="ln4651">{</a>
<a name="ln4652">  SearchedFile *files;                  /* Stack of included files */</a>
<a name="ln4653">  SearchedFile *bigger;                 /* When we need more space */</a>
<a name="ln4654">  int max_path_depth = 50;</a>
<a name="ln4655">  long match_count = 1;</a>
<a name="ln4656"> </a>
<a name="ln4657">  char_u      *pat;</a>
<a name="ln4658">  char_u      *new_fname;</a>
<a name="ln4659">  char_u      *curr_fname = curbuf-&gt;b_fname;</a>
<a name="ln4660">  char_u      *prev_fname = NULL;</a>
<a name="ln4661">  linenr_T lnum;</a>
<a name="ln4662">  int depth;</a>
<a name="ln4663">  int depth_displayed;                  /* For type==CHECK_PATH */</a>
<a name="ln4664">  int old_files;</a>
<a name="ln4665">  int already_searched;</a>
<a name="ln4666">  char_u      *file_line;</a>
<a name="ln4667">  char_u      *line;</a>
<a name="ln4668">  char_u      *p;</a>
<a name="ln4669">  char_u save_char;</a>
<a name="ln4670">  int define_matched;</a>
<a name="ln4671">  regmatch_T regmatch;</a>
<a name="ln4672">  regmatch_T incl_regmatch;</a>
<a name="ln4673">  regmatch_T def_regmatch;</a>
<a name="ln4674">  bool matched = false;</a>
<a name="ln4675">  bool did_show = false;</a>
<a name="ln4676">  bool found = false;</a>
<a name="ln4677">  int i;</a>
<a name="ln4678">  char_u      *already = NULL;</a>
<a name="ln4679">  char_u      *startp = NULL;</a>
<a name="ln4680">  char_u      *inc_opt = NULL;</a>
<a name="ln4681">  win_T       *curwin_save = NULL;</a>
<a name="ln4682">  const int l_g_do_tagpreview = g_do_tagpreview;</a>
<a name="ln4683"> </a>
<a name="ln4684">  regmatch.regprog = NULL;</a>
<a name="ln4685">  incl_regmatch.regprog = NULL;</a>
<a name="ln4686">  def_regmatch.regprog = NULL;</a>
<a name="ln4687"> </a>
<a name="ln4688">  file_line = xmalloc(LSIZE);</a>
<a name="ln4689"> </a>
<a name="ln4690">  if (type != CHECK_PATH &amp;&amp; type != FIND_DEFINE</a>
<a name="ln4691">      /* when CONT_SOL is set compare &quot;ptr&quot; with the beginning of the line</a>
<a name="ln4692">       * is faster than quote_meta/regcomp/regexec &quot;ptr&quot; -- Acevedo */</a>
<a name="ln4693">      &amp;&amp; !(compl_cont_status &amp; CONT_SOL)</a>
<a name="ln4694">      ) {</a>
<a name="ln4695">    pat = xmalloc(len + 5);</a>
<a name="ln4696">    assert(len &lt;= INT_MAX);</a>
<a name="ln4697">    sprintf((char *)pat, whole ? &quot;\\&lt;%.*s\\&gt;&quot; : &quot;%.*s&quot;, (int)len, ptr);</a>
<a name="ln4698">    /* ignore case according to p_ic, p_scs and pat */</a>
<a name="ln4699">    regmatch.rm_ic = ignorecase(pat);</a>
<a name="ln4700">    regmatch.regprog = vim_regcomp(pat, p_magic ? RE_MAGIC : 0);</a>
<a name="ln4701">    xfree(pat);</a>
<a name="ln4702">    if (regmatch.regprog == NULL)</a>
<a name="ln4703">      goto fpip_end;</a>
<a name="ln4704">  }</a>
<a name="ln4705">  inc_opt = (*curbuf-&gt;b_p_inc == NUL) ? p_inc : curbuf-&gt;b_p_inc;</a>
<a name="ln4706">  if (*inc_opt != NUL) {</a>
<a name="ln4707">    incl_regmatch.regprog = vim_regcomp(inc_opt, p_magic ? RE_MAGIC : 0);</a>
<a name="ln4708">    if (incl_regmatch.regprog == NULL)</a>
<a name="ln4709">      goto fpip_end;</a>
<a name="ln4710">    incl_regmatch.rm_ic = FALSE;        /* don't ignore case in incl. pat. */</a>
<a name="ln4711">  }</a>
<a name="ln4712">  if (type == FIND_DEFINE &amp;&amp; (*curbuf-&gt;b_p_def != NUL || *p_def != NUL)) {</a>
<a name="ln4713">    def_regmatch.regprog = vim_regcomp(*curbuf-&gt;b_p_def == NUL</a>
<a name="ln4714">        ? p_def : curbuf-&gt;b_p_def, p_magic ? RE_MAGIC : 0);</a>
<a name="ln4715">    if (def_regmatch.regprog == NULL)</a>
<a name="ln4716">      goto fpip_end;</a>
<a name="ln4717">    def_regmatch.rm_ic = FALSE;         /* don't ignore case in define pat. */</a>
<a name="ln4718">  }</a>
<a name="ln4719">  files = xcalloc(max_path_depth, sizeof(SearchedFile));</a>
<a name="ln4720">  old_files = max_path_depth;</a>
<a name="ln4721">  depth = depth_displayed = -1;</a>
<a name="ln4722"> </a>
<a name="ln4723">  lnum = start_lnum;</a>
<a name="ln4724">  if (end_lnum &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln4725">    end_lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4726">  if (lnum &gt; end_lnum)                  /* do at least one line */</a>
<a name="ln4727">    lnum = end_lnum;</a>
<a name="ln4728">  line = ml_get(lnum);</a>
<a name="ln4729"> </a>
<a name="ln4730">  for (;; ) {</a>
<a name="ln4731">    if (incl_regmatch.regprog != NULL</a>
<a name="ln4732">        &amp;&amp; vim_regexec(&amp;incl_regmatch, line, (colnr_T)0)) {</a>
<a name="ln4733">      char_u *p_fname = (curr_fname == curbuf-&gt;b_fname)</a>
<a name="ln4734">                        ? curbuf-&gt;b_ffname : curr_fname;</a>
<a name="ln4735"> </a>
<a name="ln4736">      if (inc_opt != NULL &amp;&amp; strstr((char *)inc_opt, &quot;\\zs&quot;) != NULL)</a>
<a name="ln4737">        /* Use text from '\zs' to '\ze' (or end) of 'include'. */</a>
<a name="ln4738">        new_fname = find_file_name_in_path(incl_regmatch.startp[0],</a>
<a name="ln4739">                                           (size_t)(incl_regmatch.endp[0]</a>
<a name="ln4740">                                                    - incl_regmatch.startp[0]),</a>
<a name="ln4741">                                           FNAME_EXP|FNAME_INCL|FNAME_REL,</a>
<a name="ln4742">                                           1L, p_fname);</a>
<a name="ln4743">      else</a>
<a name="ln4744">        /* Use text after match with 'include'. */</a>
<a name="ln4745">        new_fname = file_name_in_line(incl_regmatch.endp[0], 0,</a>
<a name="ln4746">            FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);</a>
<a name="ln4747">      already_searched = FALSE;</a>
<a name="ln4748">      if (new_fname != NULL) {</a>
<a name="ln4749">        // Check whether we have already searched in this file</a>
<a name="ln4750">        for (i = 0;; i++) {</a>
<a name="ln4751">          if (i == depth + 1) {</a>
<a name="ln4752">            i = old_files;</a>
<a name="ln4753">          }</a>
<a name="ln4754">          if (i == max_path_depth) {</a>
<a name="ln4755">            break;</a>
<a name="ln4756">          }</a>
<a name="ln4757">          if (path_full_compare(new_fname, files[i].name,</a>
<a name="ln4758">                                true, true) &amp; kEqualFiles) {</a>
<a name="ln4759">            if (type != CHECK_PATH</a>
<a name="ln4760">                &amp;&amp; action == ACTION_SHOW_ALL &amp;&amp; files[i].matched) {</a>
<a name="ln4761">              msg_putchar('\n');  // cursor below last one */</a>
<a name="ln4762">              if (!got_int) {  // don't display if 'q' typed at &quot;--more--&quot;</a>
<a name="ln4763">                               // message</a>
<a name="ln4764">                msg_home_replace_hl(new_fname);</a>
<a name="ln4765">                MSG_PUTS(_(&quot; (includes previously listed match)&quot;));</a>
<a name="ln4766">                prev_fname = NULL;</a>
<a name="ln4767">              }</a>
<a name="ln4768">            }</a>
<a name="ln4769">            XFREE_CLEAR(new_fname);</a>
<a name="ln4770">            already_searched = true;</a>
<a name="ln4771">            break;</a>
<a name="ln4772">          }</a>
<a name="ln4773">        }</a>
<a name="ln4774">      }</a>
<a name="ln4775"> </a>
<a name="ln4776">      if (type == CHECK_PATH &amp;&amp; (action == ACTION_SHOW_ALL</a>
<a name="ln4777">                                 || (new_fname == NULL &amp;&amp; !already_searched))) {</a>
<a name="ln4778">        if (did_show) {</a>
<a name="ln4779">          msg_putchar('\n');  // cursor below last one</a>
<a name="ln4780">        } else {</a>
<a name="ln4781">          gotocmdline(true);  // cursor at status line</a>
<a name="ln4782">          MSG_PUTS_TITLE(_(&quot;--- Included files &quot;));</a>
<a name="ln4783">          if (action != ACTION_SHOW_ALL) {</a>
<a name="ln4784">            MSG_PUTS_TITLE(_(&quot;not found &quot;));</a>
<a name="ln4785">          }</a>
<a name="ln4786">          MSG_PUTS_TITLE(_(&quot;in path ---\n&quot;));</a>
<a name="ln4787">        }</a>
<a name="ln4788">        did_show = true;</a>
<a name="ln4789">        while (depth_displayed &lt; depth &amp;&amp; !got_int) {</a>
<a name="ln4790">          ++depth_displayed;</a>
<a name="ln4791">          for (i = 0; i &lt; depth_displayed; i++)</a>
<a name="ln4792">            MSG_PUTS(&quot;  &quot;);</a>
<a name="ln4793">          msg_home_replace(files[depth_displayed].name);</a>
<a name="ln4794">          MSG_PUTS(&quot; --&gt;\n&quot;);</a>
<a name="ln4795">        }</a>
<a name="ln4796">        if (!got_int) {                     /* don't display if 'q' typed</a>
<a name="ln4797">                                               for &quot;--more--&quot; message */</a>
<a name="ln4798">          for (i = 0; i &lt;= depth_displayed; i++)</a>
<a name="ln4799">            MSG_PUTS(&quot;  &quot;);</a>
<a name="ln4800">          if (new_fname != NULL) {</a>
<a name="ln4801">            /* using &quot;new_fname&quot; is more reliable, e.g., when</a>
<a name="ln4802">             * 'includeexpr' is set. */</a>
<a name="ln4803">            msg_outtrans_attr(new_fname, HL_ATTR(HLF_D));</a>
<a name="ln4804">          } else {</a>
<a name="ln4805">            /*</a>
<a name="ln4806">             * Isolate the file name.</a>
<a name="ln4807">             * Include the surrounding &quot;&quot; or &lt;&gt; if present.</a>
<a name="ln4808">             */</a>
<a name="ln4809">            if (inc_opt != NULL</a>
<a name="ln4810">                &amp;&amp; strstr((char *)inc_opt, &quot;\\zs&quot;) != NULL) {</a>
<a name="ln4811">              /* pattern contains \zs, use the match */</a>
<a name="ln4812">              p = incl_regmatch.startp[0];</a>
<a name="ln4813">              i = (int)(incl_regmatch.endp[0]</a>
<a name="ln4814">                        - incl_regmatch.startp[0]);</a>
<a name="ln4815">            } else {</a>
<a name="ln4816">              /* find the file name after the end of the match */</a>
<a name="ln4817">              for (p = incl_regmatch.endp[0];</a>
<a name="ln4818">                   *p &amp;&amp; !vim_isfilec(*p); p++)</a>
<a name="ln4819">                ;</a>
<a name="ln4820">              for (i = 0; vim_isfilec(p[i]); i++)</a>
<a name="ln4821">                ;</a>
<a name="ln4822">            }</a>
<a name="ln4823"> </a>
<a name="ln4824">            if (i == 0) {</a>
<a name="ln4825">              /* Nothing found, use the rest of the line. */</a>
<a name="ln4826">              p = incl_regmatch.endp[0];</a>
<a name="ln4827">              i = (int)STRLEN(p);</a>
<a name="ln4828">            }</a>
<a name="ln4829">            /* Avoid checking before the start of the line, can</a>
<a name="ln4830">             * happen if \zs appears in the regexp. */</a>
<a name="ln4831">            else if (p &gt; line) {</a>
<a name="ln4832">              if (p[-1] == '&quot;' || p[-1] == '&lt;') {</a>
<a name="ln4833">                --p;</a>
<a name="ln4834">                ++i;</a>
<a name="ln4835">              }</a>
<a name="ln4836">              if (p[i] == '&quot;' || p[i] == '&gt;')</a>
<a name="ln4837">                ++i;</a>
<a name="ln4838">            }</a>
<a name="ln4839">            save_char = p[i];</a>
<a name="ln4840">            p[i] = NUL;</a>
<a name="ln4841">            msg_outtrans_attr(p, HL_ATTR(HLF_D));</a>
<a name="ln4842">            p[i] = save_char;</a>
<a name="ln4843">          }</a>
<a name="ln4844"> </a>
<a name="ln4845">          if (new_fname == NULL &amp;&amp; action == ACTION_SHOW_ALL) {</a>
<a name="ln4846">            if (already_searched)</a>
<a name="ln4847">              MSG_PUTS(_(&quot;  (Already listed)&quot;));</a>
<a name="ln4848">            else</a>
<a name="ln4849">              MSG_PUTS(_(&quot;  NOT FOUND&quot;));</a>
<a name="ln4850">          }</a>
<a name="ln4851">        }</a>
<a name="ln4852">        ui_flush();                /* output each line directly */</a>
<a name="ln4853">      }</a>
<a name="ln4854"> </a>
<a name="ln4855">      if (new_fname != NULL) {</a>
<a name="ln4856">        /* Push the new file onto the file stack */</a>
<a name="ln4857">        if (depth + 1 == old_files) {</a>
<a name="ln4858">          bigger = xmalloc(max_path_depth * 2 * sizeof(SearchedFile));</a>
<a name="ln4859">          for (i = 0; i &lt;= depth; i++)</a>
<a name="ln4860">            bigger[i] = files[i];</a>
<a name="ln4861">          for (i = depth + 1; i &lt; old_files + max_path_depth; i++) {</a>
<a name="ln4862">            bigger[i].fp = NULL;</a>
<a name="ln4863">            bigger[i].name = NULL;</a>
<a name="ln4864">            bigger[i].lnum = 0;</a>
<a name="ln4865">            bigger[i].matched = FALSE;</a>
<a name="ln4866">          }</a>
<a name="ln4867">          for (i = old_files; i &lt; max_path_depth; i++)</a>
<a name="ln4868">            bigger[i + max_path_depth] = files[i];</a>
<a name="ln4869">          old_files += max_path_depth;</a>
<a name="ln4870">          max_path_depth *= 2;</a>
<a name="ln4871">          xfree(files);</a>
<a name="ln4872">          files = bigger;</a>
<a name="ln4873">        }</a>
<a name="ln4874">        if ((files[depth + 1].fp = os_fopen((char *)new_fname, &quot;r&quot;)) == NULL) {</a>
<a name="ln4875">          xfree(new_fname);</a>
<a name="ln4876">        } else {</a>
<a name="ln4877">          if (++depth == old_files) {</a>
<a name="ln4878">            // Something wrong. We will forget one of our already visited files</a>
<a name="ln4879">            // now.</a>
<a name="ln4880">            xfree(files[old_files].name);</a>
<a name="ln4881">            ++old_files;</a>
<a name="ln4882">          }</a>
<a name="ln4883">          files[depth].name = curr_fname = new_fname;</a>
<a name="ln4884">          files[depth].lnum = 0;</a>
<a name="ln4885">          files[depth].matched = FALSE;</a>
<a name="ln4886">          if (action == ACTION_EXPAND) {</a>
<a name="ln4887">            msg_hist_off = true;                // reset in msg_trunc_attr()</a>
<a name="ln4888">            vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln4889">                         _(&quot;Scanning included file: %s&quot;),</a>
<a name="ln4890">                         (char *)new_fname);</a>
<a name="ln4891">            msg_trunc_attr(IObuff, true, HL_ATTR(HLF_R));</a>
<a name="ln4892">          } else if (p_verbose &gt;= 5) {</a>
<a name="ln4893">            verbose_enter();</a>
<a name="ln4894">            smsg(_(&quot;Searching included file %s&quot;),</a>
<a name="ln4895">                (char *)new_fname);</a>
<a name="ln4896">            verbose_leave();</a>
<a name="ln4897">          }</a>
<a name="ln4898"> </a>
<a name="ln4899">        }</a>
<a name="ln4900">      }</a>
<a name="ln4901">    } else {</a>
<a name="ln4902">      /*</a>
<a name="ln4903">       * Check if the line is a define (type == FIND_DEFINE)</a>
<a name="ln4904">       */</a>
<a name="ln4905">      p = line;</a>
<a name="ln4906">search_line:</a>
<a name="ln4907">      define_matched = FALSE;</a>
<a name="ln4908">      if (def_regmatch.regprog != NULL</a>
<a name="ln4909">          &amp;&amp; vim_regexec(&amp;def_regmatch, line, (colnr_T)0)) {</a>
<a name="ln4910">        /*</a>
<a name="ln4911">         * Pattern must be first identifier after 'define', so skip</a>
<a name="ln4912">         * to that position before checking for match of pattern.  Also</a>
<a name="ln4913">         * don't let it match beyond the end of this identifier.</a>
<a name="ln4914">         */</a>
<a name="ln4915">        p = def_regmatch.endp[0];</a>
<a name="ln4916">        while (*p &amp;&amp; !vim_iswordc(*p))</a>
<a name="ln4917">          p++;</a>
<a name="ln4918">        define_matched = TRUE;</a>
<a name="ln4919">      }</a>
<a name="ln4920"> </a>
<a name="ln4921">      /*</a>
<a name="ln4922">       * Look for a match.  Don't do this if we are looking for a</a>
<a name="ln4923">       * define and this line didn't match define_prog above.</a>
<a name="ln4924">       */</a>
<a name="ln4925">      if (def_regmatch.regprog == NULL || define_matched) {</a>
<a name="ln4926">        if (define_matched</a>
<a name="ln4927">            || (compl_cont_status &amp; CONT_SOL)</a>
<a name="ln4928">            ) {</a>
<a name="ln4929">          /* compare the first &quot;len&quot; chars from &quot;ptr&quot; */</a>
<a name="ln4930">          startp = skipwhite(p);</a>
<a name="ln4931">          if (p_ic) {</a>
<a name="ln4932">            matched = !mb_strnicmp(startp, ptr, len);</a>
<a name="ln4933">          }</a>
<a name="ln4934">          else</a>
<a name="ln4935">            matched = !STRNCMP(startp, ptr, len);</a>
<a name="ln4936">          if (matched &amp;&amp; define_matched &amp;&amp; whole</a>
<a name="ln4937">              &amp;&amp; vim_iswordc(startp[len]))</a>
<a name="ln4938">            matched = false;</a>
<a name="ln4939">        } else if (regmatch.regprog != NULL</a>
<a name="ln4940">                   &amp;&amp; vim_regexec(&amp;regmatch, line, (colnr_T)(p - line))) {</a>
<a name="ln4941">          matched = true;</a>
<a name="ln4942">          startp = regmatch.startp[0];</a>
<a name="ln4943">          // Check if the line is not a comment line (unless we are</a>
<a name="ln4944">          // looking for a define).  A line starting with &quot;# define&quot;</a>
<a name="ln4945">          // is not considered to be a comment line.</a>
<a name="ln4946">          if (skip_comments) {</a>
<a name="ln4947">            if ((*line != '#'</a>
<a name="ln4948">                 || STRNCMP(skipwhite(line + 1), &quot;define&quot;, 6) != 0)</a>
<a name="ln4949">                &amp;&amp; get_leader_len(line, NULL, false, true)) {</a>
<a name="ln4950">              matched = false;</a>
<a name="ln4951">            }</a>
<a name="ln4952"> </a>
<a name="ln4953">            /*</a>
<a name="ln4954">             * Also check for a &quot;/ *&quot; or &quot;/ /&quot; before the match.</a>
<a name="ln4955">             * Skips lines like &quot;int backwards;  / * normal index</a>
<a name="ln4956">             * * /&quot; when looking for &quot;normal&quot;.</a>
<a name="ln4957">             * Note: Doesn't skip &quot;/ *&quot; in comments.</a>
<a name="ln4958">             */</a>
<a name="ln4959">            p = skipwhite(line);</a>
<a name="ln4960">            if (matched</a>
<a name="ln4961">                || (p[0] == '/' &amp;&amp; p[1] == '*') || p[0] == '*')</a>
<a name="ln4962">              for (p = line; *p &amp;&amp; p &lt; startp; ++p) {</a>
<a name="ln4963">                if (matched</a>
<a name="ln4964">                    &amp;&amp; p[0] == '/'</a>
<a name="ln4965">                    &amp;&amp; (p[1] == '*' || p[1] == '/')) {</a>
<a name="ln4966">                  matched = false;</a>
<a name="ln4967">                  // After &quot;//&quot; all text is comment</a>
<a name="ln4968">                  if (p[1] == '/') {</a>
<a name="ln4969">                    break;</a>
<a name="ln4970">                  }</a>
<a name="ln4971">                  p++;</a>
<a name="ln4972">                } else if (!matched &amp;&amp; p[0] == '*' &amp;&amp; p[1] == '/') {</a>
<a name="ln4973">                  // Can find match after &quot;* /&quot;.</a>
<a name="ln4974">                  matched = true;</a>
<a name="ln4975">                  p++;</a>
<a name="ln4976">                }</a>
<a name="ln4977">              }</a>
<a name="ln4978">          }</a>
<a name="ln4979">        }</a>
<a name="ln4980">      }</a>
<a name="ln4981">    }</a>
<a name="ln4982">    if (matched) {</a>
<a name="ln4983">      if (action == ACTION_EXPAND) {</a>
<a name="ln4984">        bool cont_s_ipos = false;</a>
<a name="ln4985">        char_u  *aux;</a>
<a name="ln4986"> </a>
<a name="ln4987">        if (depth == -1 &amp;&amp; lnum == curwin-&gt;w_cursor.lnum)</a>
<a name="ln4988">          break;</a>
<a name="ln4989">        found = true;</a>
<a name="ln4990">        aux = p = startp;</a>
<a name="ln4991">        if (compl_cont_status &amp; CONT_ADDING) {</a>
<a name="ln4992">          p += compl_length;</a>
<a name="ln4993">          if (vim_iswordp(p))</a>
<a name="ln4994">            goto exit_matched;</a>
<a name="ln4995">          p = find_word_start(p);</a>
<a name="ln4996">        }</a>
<a name="ln4997">        p = find_word_end(p);</a>
<a name="ln4998">        i = (int)(p - aux);</a>
<a name="ln4999"> </a>
<a name="ln5000">        if ((compl_cont_status &amp; CONT_ADDING) &amp;&amp; i == compl_length) {</a>
<a name="ln5001">          /* IOSIZE &gt; compl_length, so the STRNCPY works */</a>
<a name="ln5002">          STRNCPY(IObuff, aux, i);</a>
<a name="ln5003"> </a>
<a name="ln5004">          /* Get the next line: when &quot;depth&quot; &lt; 0  from the current</a>
<a name="ln5005">           * buffer, otherwise from the included file.  Jump to</a>
<a name="ln5006">           * exit_matched when past the last line. */</a>
<a name="ln5007">          if (depth &lt; 0) {</a>
<a name="ln5008">            if (lnum &gt;= end_lnum)</a>
<a name="ln5009">              goto exit_matched;</a>
<a name="ln5010">            line = ml_get(++lnum);</a>
<a name="ln5011">          } else if (vim_fgets(line = file_line,</a>
<a name="ln5012">                         LSIZE, files[depth].fp))</a>
<a name="ln5013">            goto exit_matched;</a>
<a name="ln5014"> </a>
<a name="ln5015">          /* we read a line, set &quot;already&quot; to check this &quot;line&quot; later</a>
<a name="ln5016">           * if depth &gt;= 0 we'll increase files[depth].lnum far</a>
<a name="ln5017">           * bellow  -- Acevedo */</a>
<a name="ln5018">          already = aux = p = skipwhite(line);</a>
<a name="ln5019">          p = find_word_start(p);</a>
<a name="ln5020">          p = find_word_end(p);</a>
<a name="ln5021">          if (p &gt; aux) {</a>
<a name="ln5022">            if (*aux != ')' &amp;&amp; IObuff[i-1] != TAB) {</a>
<a name="ln5023">              if (IObuff[i-1] != ' ')</a>
<a name="ln5024">                IObuff[i++] = ' ';</a>
<a name="ln5025">              /* IObuf =~ &quot;\(\k\|\i\).* &quot;, thus i &gt;= 2*/</a>
<a name="ln5026">              if (p_js</a>
<a name="ln5027">                  &amp;&amp; (IObuff[i-2] == '.'</a>
<a name="ln5028">                      || IObuff[i-2] == '?'</a>
<a name="ln5029">                      || IObuff[i-2] == '!')) {</a>
<a name="ln5030">                IObuff[i++] = ' ';</a>
<a name="ln5031">              }</a>
<a name="ln5032">            }</a>
<a name="ln5033">            /* copy as much as possible of the new word */</a>
<a name="ln5034">            if (p - aux &gt;= IOSIZE - i)</a>
<a name="ln5035">              p = aux + IOSIZE - i - 1;</a>
<a name="ln5036">            STRNCPY(IObuff + i, aux, p - aux);</a>
<a name="ln5037">            i += (int)(p - aux);</a>
<a name="ln5038">            cont_s_ipos = true;</a>
<a name="ln5039">          }</a>
<a name="ln5040">          IObuff[i] = NUL;</a>
<a name="ln5041">          aux = IObuff;</a>
<a name="ln5042"> </a>
<a name="ln5043">          if (i == compl_length)</a>
<a name="ln5044">            goto exit_matched;</a>
<a name="ln5045">        }</a>
<a name="ln5046"> </a>
<a name="ln5047">        const int add_r = ins_compl_add_infercase(</a>
<a name="ln5048">            aux, i, p_ic, curr_fname == curbuf-&gt;b_fname ? NULL : curr_fname,</a>
<a name="ln5049">            dir, cont_s_ipos);</a>
<a name="ln5050">        if (add_r == OK) {</a>
<a name="ln5051">          // if dir was BACKWARD then honor it just once</a>
<a name="ln5052">          dir = FORWARD;</a>
<a name="ln5053">        } else if (add_r == FAIL) {</a>
<a name="ln5054">          break;</a>
<a name="ln5055">        }</a>
<a name="ln5056">      } else if (action == ACTION_SHOW_ALL) {</a>
<a name="ln5057">        found = true;</a>
<a name="ln5058">        if (!did_show) {</a>
<a name="ln5059">          gotocmdline(true);                    // cursor at status line</a>
<a name="ln5060">        }</a>
<a name="ln5061">        if (curr_fname != prev_fname) {</a>
<a name="ln5062">          if (did_show)</a>
<a name="ln5063">            msg_putchar('\n');                  /* cursor below last one */</a>
<a name="ln5064">          if (!got_int)                         /* don't display if 'q' typed</a>
<a name="ln5065">                                                    at &quot;--more--&quot; message */</a>
<a name="ln5066">            msg_home_replace_hl(curr_fname);</a>
<a name="ln5067">          prev_fname = curr_fname;</a>
<a name="ln5068">        }</a>
<a name="ln5069">        did_show = true;</a>
<a name="ln5070">        if (!got_int) {</a>
<a name="ln5071">          show_pat_in_path(line, type, true, action,</a>
<a name="ln5072">                           (depth == -1) ? NULL : files[depth].fp,</a>
<a name="ln5073">                           (depth == -1) ? &amp;lnum : &amp;files[depth].lnum,</a>
<a name="ln5074">                           match_count++);</a>
<a name="ln5075">        }</a>
<a name="ln5076"> </a>
<a name="ln5077">        /* Set matched flag for this file and all the ones that</a>
<a name="ln5078">         * include it */</a>
<a name="ln5079">        for (i = 0; i &lt;= depth; ++i)</a>
<a name="ln5080">          files[i].matched = TRUE;</a>
<a name="ln5081">      } else if (--count &lt;= 0) {</a>
<a name="ln5082">        found = true;</a>
<a name="ln5083">        if (depth == -1 &amp;&amp; lnum == curwin-&gt;w_cursor.lnum</a>
<a name="ln5084">            &amp;&amp; l_g_do_tagpreview == 0) {</a>
<a name="ln5085">          EMSG(_(&quot;E387: Match is on current line&quot;));</a>
<a name="ln5086">        } else if (action == ACTION_SHOW) {</a>
<a name="ln5087">          show_pat_in_path(line, type, did_show, action,</a>
<a name="ln5088">                           (depth == -1) ? NULL : files[depth].fp,</a>
<a name="ln5089">                           (depth == -1) ? &amp;lnum : &amp;files[depth].lnum, 1L);</a>
<a name="ln5090">          did_show = true;</a>
<a name="ln5091">        } else {</a>
<a name="ln5092">          /* &quot;:psearch&quot; uses the preview window */</a>
<a name="ln5093">          if (l_g_do_tagpreview != 0) {</a>
<a name="ln5094">            curwin_save = curwin;</a>
<a name="ln5095">            prepare_tagpreview(true);</a>
<a name="ln5096">          }</a>
<a name="ln5097">          if (action == ACTION_SPLIT) {</a>
<a name="ln5098">            if (win_split(0, 0) == FAIL)</a>
<a name="ln5099">              break;</a>
<a name="ln5100">            RESET_BINDING(curwin);</a>
<a name="ln5101">          }</a>
<a name="ln5102">          if (depth == -1) {</a>
<a name="ln5103">            // match in current file</a>
<a name="ln5104">            if (l_g_do_tagpreview != 0) {</a>
<a name="ln5105">              if (!GETFILE_SUCCESS(getfile(curwin_save-&gt;w_buffer-&gt;b_fnum, NULL,</a>
<a name="ln5106">                                           NULL, true, lnum, false))) {</a>
<a name="ln5107">                break;    // failed to jump to file</a>
<a name="ln5108">              }</a>
<a name="ln5109">            } else {</a>
<a name="ln5110">              setpcmark();</a>
<a name="ln5111">            }</a>
<a name="ln5112">            curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln5113">            check_cursor();</a>
<a name="ln5114">          } else {</a>
<a name="ln5115">            if (!GETFILE_SUCCESS(getfile(0, files[depth].name, NULL, true,</a>
<a name="ln5116">                                         files[depth].lnum, false))) {</a>
<a name="ln5117">              break;    // failed to jump to file</a>
<a name="ln5118">            }</a>
<a name="ln5119">            // autocommands may have changed the lnum, we don't</a>
<a name="ln5120">            // want that here</a>
<a name="ln5121">            curwin-&gt;w_cursor.lnum = files[depth].lnum;</a>
<a name="ln5122">          }</a>
<a name="ln5123">        }</a>
<a name="ln5124">        if (action != ACTION_SHOW) {</a>
<a name="ln5125">          curwin-&gt;w_cursor.col = (colnr_T)(startp - line);</a>
<a name="ln5126">          curwin-&gt;w_set_curswant = TRUE;</a>
<a name="ln5127">        }</a>
<a name="ln5128"> </a>
<a name="ln5129">        if (l_g_do_tagpreview != 0</a>
<a name="ln5130">            &amp;&amp; curwin != curwin_save &amp;&amp; win_valid(curwin_save)) {</a>
<a name="ln5131">          /* Return cursor to where we were */</a>
<a name="ln5132">          validate_cursor();</a>
<a name="ln5133">          redraw_later(curwin, VALID);</a>
<a name="ln5134">          win_enter(curwin_save, true);</a>
<a name="ln5135">        }</a>
<a name="ln5136">        break;</a>
<a name="ln5137">      }</a>
<a name="ln5138">exit_matched:</a>
<a name="ln5139">      matched = false;</a>
<a name="ln5140">      // look for other matches in the rest of the line if we</a>
<a name="ln5141">      // are not at the end of it already</a>
<a name="ln5142">      if (def_regmatch.regprog == NULL</a>
<a name="ln5143">          &amp;&amp; action == ACTION_EXPAND</a>
<a name="ln5144">          &amp;&amp; !(compl_cont_status &amp; CONT_SOL)</a>
<a name="ln5145">          &amp;&amp; *startp != NUL</a>
<a name="ln5146">          &amp;&amp; *(p = startp + utfc_ptr2len(startp)) != NUL) {</a>
<a name="ln5147">        goto search_line;</a>
<a name="ln5148">      }</a>
<a name="ln5149">    }</a>
<a name="ln5150">    line_breakcheck();</a>
<a name="ln5151">    if (action == ACTION_EXPAND)</a>
<a name="ln5152">      ins_compl_check_keys(30, false);</a>
<a name="ln5153">    if (got_int || compl_interrupted)</a>
<a name="ln5154">      break;</a>
<a name="ln5155"> </a>
<a name="ln5156">    /*</a>
<a name="ln5157">     * Read the next line.  When reading an included file and encountering</a>
<a name="ln5158">     * end-of-file, close the file and continue in the file that included</a>
<a name="ln5159">     * it.</a>
<a name="ln5160">     */</a>
<a name="ln5161">    while (depth &gt;= 0 &amp;&amp; !already</a>
<a name="ln5162">           &amp;&amp; vim_fgets(line = file_line, LSIZE, files[depth].fp)) {</a>
<a name="ln5163">      fclose(files[depth].fp);</a>
<a name="ln5164">      --old_files;</a>
<a name="ln5165">      files[old_files].name = files[depth].name;</a>
<a name="ln5166">      files[old_files].matched = files[depth].matched;</a>
<a name="ln5167">      --depth;</a>
<a name="ln5168">      curr_fname = (depth == -1) ? curbuf-&gt;b_fname</a>
<a name="ln5169">                   : files[depth].name;</a>
<a name="ln5170">      if (depth &lt; depth_displayed)</a>
<a name="ln5171">        depth_displayed = depth;</a>
<a name="ln5172">    }</a>
<a name="ln5173">    if (depth &gt;= 0) {           /* we could read the line */</a>
<a name="ln5174">      files[depth].lnum++;</a>
<a name="ln5175">      /* Remove any CR and LF from the line. */</a>
<a name="ln5176">      i = (int)STRLEN(line);</a>
<a name="ln5177">      if (i &gt; 0 &amp;&amp; line[i - 1] == '\n')</a>
<a name="ln5178">        line[--i] = NUL;</a>
<a name="ln5179">      if (i &gt; 0 &amp;&amp; line[i - 1] == '\r')</a>
<a name="ln5180">        line[--i] = NUL;</a>
<a name="ln5181">    } else if (!already) {</a>
<a name="ln5182">      if (++lnum &gt; end_lnum)</a>
<a name="ln5183">        break;</a>
<a name="ln5184">      line = ml_get(lnum);</a>
<a name="ln5185">    }</a>
<a name="ln5186">    already = NULL;</a>
<a name="ln5187">  }</a>
<a name="ln5188">  /* End of big for (;;) loop. */</a>
<a name="ln5189"> </a>
<a name="ln5190">  /* Close any files that are still open. */</a>
<a name="ln5191">  for (i = 0; i &lt;= depth; i++) {</a>
<a name="ln5192">    fclose(files[i].fp);</a>
<a name="ln5193">    xfree(files[i].name);</a>
<a name="ln5194">  }</a>
<a name="ln5195">  for (i = old_files; i &lt; max_path_depth; i++)</a>
<a name="ln5196">    xfree(files[i].name);</a>
<a name="ln5197">  xfree(files);</a>
<a name="ln5198"> </a>
<a name="ln5199">  if (type == CHECK_PATH) {</a>
<a name="ln5200">    if (!did_show) {</a>
<a name="ln5201">      if (action != ACTION_SHOW_ALL)</a>
<a name="ln5202">        MSG(_(&quot;All included files were found&quot;));</a>
<a name="ln5203">      else</a>
<a name="ln5204">        MSG(_(&quot;No included files&quot;));</a>
<a name="ln5205">    }</a>
<a name="ln5206">  } else if (!found</a>
<a name="ln5207">             &amp;&amp; action != ACTION_EXPAND</a>
<a name="ln5208">             ) {</a>
<a name="ln5209">    if (got_int || compl_interrupted)</a>
<a name="ln5210">      EMSG(_(e_interr));</a>
<a name="ln5211">    else if (type == FIND_DEFINE)</a>
<a name="ln5212">      EMSG(_(&quot;E388: Couldn't find definition&quot;));</a>
<a name="ln5213">    else</a>
<a name="ln5214">      EMSG(_(&quot;E389: Couldn't find pattern&quot;));</a>
<a name="ln5215">  }</a>
<a name="ln5216">  if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)</a>
<a name="ln5217">    msg_end();</a>
<a name="ln5218"> </a>
<a name="ln5219">fpip_end:</a>
<a name="ln5220">  xfree(file_line);</a>
<a name="ln5221">  vim_regfree(regmatch.regprog);</a>
<a name="ln5222">  vim_regfree(incl_regmatch.regprog);</a>
<a name="ln5223">  vim_regfree(def_regmatch.regprog);</a>
<a name="ln5224">}</a>
<a name="ln5225"> </a>
<a name="ln5226">static void show_pat_in_path(char_u *line, int type, bool did_show, int action,</a>
<a name="ln5227">                             FILE *fp, linenr_T *lnum, long count)</a>
<a name="ln5228">  FUNC_ATTR_NONNULL_ARG(1, 6)</a>
<a name="ln5229">{</a>
<a name="ln5230">  char_u  *p;</a>
<a name="ln5231"> </a>
<a name="ln5232">  if (did_show) {</a>
<a name="ln5233">    msg_putchar('\n');          // cursor below last one</a>
<a name="ln5234">  } else if (!msg_silent) {</a>
<a name="ln5235">    gotocmdline(true);          // cursor at status line</a>
<a name="ln5236">  }</a>
<a name="ln5237">  if (got_int) {                // 'q' typed at &quot;--more--&quot; message</a>
<a name="ln5238">    return;</a>
<a name="ln5239">  }</a>
<a name="ln5240">  for (;; ) {</a>
<a name="ln5241">    p = line + STRLEN(line) - 1;</a>
<a name="ln5242">    if (fp != NULL) {</a>
<a name="ln5243">      /* We used fgets(), so get rid of newline at end */</a>
<a name="ln5244">      if (p &gt;= line &amp;&amp; *p == '\n')</a>
<a name="ln5245">        --p;</a>
<a name="ln5246">      if (p &gt;= line &amp;&amp; *p == '\r')</a>
<a name="ln5247">        --p;</a>
<a name="ln5248">      *(p + 1) = NUL;</a>
<a name="ln5249">    }</a>
<a name="ln5250">    if (action == ACTION_SHOW_ALL) {</a>
<a name="ln5251">      snprintf((char *)IObuff, IOSIZE, &quot;%3ld: &quot;, count);  // Show match nr.</a>
<a name="ln5252">      msg_puts((const char *)IObuff);</a>
<a name="ln5253">      snprintf((char *)IObuff, IOSIZE, &quot;%4ld&quot;, *lnum);  // Show line nr.</a>
<a name="ln5254">      // Highlight line numbers.</a>
<a name="ln5255">      msg_puts_attr((const char *)IObuff, HL_ATTR(HLF_N));</a>
<a name="ln5256">      msg_puts(&quot; &quot;);</a>
<a name="ln5257">    }</a>
<a name="ln5258">    msg_prt_line(line, FALSE);</a>
<a name="ln5259">    ui_flush();                        /* show one line at a time */</a>
<a name="ln5260"> </a>
<a name="ln5261">    /* Definition continues until line that doesn't end with '\' */</a>
<a name="ln5262">    if (got_int || type != FIND_DEFINE || p &lt; line || *p != '\\')</a>
<a name="ln5263">      break;</a>
<a name="ln5264"> </a>
<a name="ln5265">    if (fp != NULL) {</a>
<a name="ln5266">      if (vim_fgets(line, LSIZE, fp))       /* end of file */</a>
<a name="ln5267">        break;</a>
<a name="ln5268">      ++*lnum;</a>
<a name="ln5269">    } else {</a>
<a name="ln5270">      if (++*lnum &gt; curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln5271">        break;</a>
<a name="ln5272">      line = ml_get(*lnum);</a>
<a name="ln5273">    }</a>
<a name="ln5274">    msg_putchar('\n');</a>
<a name="ln5275">  }</a>
<a name="ln5276">}</a>
<a name="ln5277"> </a>
<a name="ln5278">/// Get last search pattern</a>
<a name="ln5279">void get_search_pattern(SearchPattern *const pat)</a>
<a name="ln5280">{</a>
<a name="ln5281">  memcpy(pat, &amp;(spats[0]), sizeof(spats[0]));</a>
<a name="ln5282">}</a>
<a name="ln5283"> </a>
<a name="ln5284">/// Get last substitute pattern</a>
<a name="ln5285">void get_substitute_pattern(SearchPattern *const pat)</a>
<a name="ln5286">{</a>
<a name="ln5287">  memcpy(pat, &amp;(spats[1]), sizeof(spats[1]));</a>
<a name="ln5288">  memset(&amp;(pat-&gt;off), 0, sizeof(pat-&gt;off));</a>
<a name="ln5289">}</a>
<a name="ln5290"> </a>
<a name="ln5291">/// Set last search pattern</a>
<a name="ln5292">void set_search_pattern(const SearchPattern pat)</a>
<a name="ln5293">{</a>
<a name="ln5294">  free_spat(&amp;spats[0]);</a>
<a name="ln5295">  memcpy(&amp;(spats[0]), &amp;pat, sizeof(spats[0]));</a>
<a name="ln5296">  set_vv_searchforward();</a>
<a name="ln5297">}</a>
<a name="ln5298"> </a>
<a name="ln5299">/// Set last substitute pattern</a>
<a name="ln5300">void set_substitute_pattern(const SearchPattern pat)</a>
<a name="ln5301">{</a>
<a name="ln5302">  free_spat(&amp;spats[1]);</a>
<a name="ln5303">  memcpy(&amp;(spats[1]), &amp;pat, sizeof(spats[1]));</a>
<a name="ln5304">  memset(&amp;(spats[1].off), 0, sizeof(spats[1].off));</a>
<a name="ln5305">}</a>
<a name="ln5306"> </a>
<a name="ln5307">/// Set last used search pattern</a>
<a name="ln5308">///</a>
<a name="ln5309">/// @param[in]  is_substitute_pattern  If true set substitute pattern as last</a>
<a name="ln5310">///                                    used. Otherwise sets search pattern.</a>
<a name="ln5311">void set_last_used_pattern(const bool is_substitute_pattern)</a>
<a name="ln5312">{</a>
<a name="ln5313">  last_idx = (is_substitute_pattern ? 1 : 0);</a>
<a name="ln5314">}</a>
<a name="ln5315"> </a>
<a name="ln5316">/// Returns true if search pattern was the last used one</a>
<a name="ln5317">bool search_was_last_used(void)</a>
<a name="ln5318">{</a>
<a name="ln5319">  return last_idx == 0;</a>
<a name="ln5320">}</a>

</code></pre>
<div class="balloon" rel="1530"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v768/" target="_blank">V768</a> The variable 'dir' is of enum type. It is odd that it is used as a variable of a Boolean-type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
