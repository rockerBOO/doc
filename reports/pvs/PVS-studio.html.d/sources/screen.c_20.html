
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>screen.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// screen.c: code for displaying on the screen</a>
<a name="ln5">//</a>
<a name="ln6">// Output to the screen (console, terminal emulator or GUI window) is minimized</a>
<a name="ln7">// by remembering what is already on the screen, and only updating the parts</a>
<a name="ln8">// that changed.</a>
<a name="ln9">//</a>
<a name="ln10">// The grid_*() functions write to the screen and handle updating grid-&gt;lines[].</a>
<a name="ln11">//</a>
<a name="ln12">// update_screen() is the function that updates all windows and status lines.</a>
<a name="ln13">// It is called from the main loop when must_redraw is non-zero.  It may be</a>
<a name="ln14">// called from other places when an immediate screen update is needed.</a>
<a name="ln15">//</a>
<a name="ln16">// The part of the buffer that is displayed in a window is set with:</a>
<a name="ln17">// - w_topline (first buffer line in window)</a>
<a name="ln18">// - w_topfill (filler lines above the first line)</a>
<a name="ln19">// - w_leftcol (leftmost window cell in window),</a>
<a name="ln20">// - w_skipcol (skipped window cells of first line)</a>
<a name="ln21">//</a>
<a name="ln22">// Commands that only move the cursor around in a window, do not need to take</a>
<a name="ln23">// action to update the display.  The main loop will check if w_topline is</a>
<a name="ln24">// valid and update it (scroll the window) when needed.</a>
<a name="ln25">//</a>
<a name="ln26">// Commands that scroll a window change w_topline and must call</a>
<a name="ln27">// check_cursor() to move the cursor into the visible part of the window, and</a>
<a name="ln28">// call redraw_later(wp, VALID) to have the window displayed by update_screen()</a>
<a name="ln29">// later.</a>
<a name="ln30">//</a>
<a name="ln31">// Commands that change text in the buffer must call changed_bytes() or</a>
<a name="ln32">// changed_lines() to mark the area that changed and will require updating</a>
<a name="ln33">// later.  The main loop will call update_screen(), which will update each</a>
<a name="ln34">// window that shows the changed buffer.  This assumes text above the change</a>
<a name="ln35">// can remain displayed as it is.  Text after the change may need updating for</a>
<a name="ln36">// scrolling, folding and syntax highlighting.</a>
<a name="ln37">//</a>
<a name="ln38">// Commands that change how a window is displayed (e.g., setting 'list') or</a>
<a name="ln39">// invalidate the contents of a window in another way (e.g., change fold</a>
<a name="ln40">// settings), must call redraw_later(wp, NOT_VALID) to have the whole window</a>
<a name="ln41">// redisplayed by update_screen() later.</a>
<a name="ln42">//</a>
<a name="ln43">// Commands that change how a buffer is displayed (e.g., setting 'tabstop')</a>
<a name="ln44">// must call redraw_curbuf_later(NOT_VALID) to have all the windows for the</a>
<a name="ln45">// buffer redisplayed by update_screen() later.</a>
<a name="ln46">//</a>
<a name="ln47">// Commands that change highlighting and possibly cause a scroll too must call</a>
<a name="ln48">// redraw_later(wp, SOME_VALID) to update the whole window but still use</a>
<a name="ln49">// scrolling to avoid redrawing everything.  But the length of displayed lines</a>
<a name="ln50">// must not change, use NOT_VALID then.</a>
<a name="ln51">//</a>
<a name="ln52">// Commands that move the window position must call redraw_later(wp, NOT_VALID).</a>
<a name="ln53">// TODO(neovim): should minimize redrawing by scrolling when possible.</a>
<a name="ln54">//</a>
<a name="ln55">// Commands that change everything (e.g., resizing the screen) must call</a>
<a name="ln56">// redraw_all_later(NOT_VALID) or redraw_all_later(CLEAR).</a>
<a name="ln57">//</a>
<a name="ln58">// Things that are handled indirectly:</a>
<a name="ln59">// - When messages scroll the screen up, msg_scrolled will be set and</a>
<a name="ln60">//   update_screen() called to redraw.</a>
<a name="ln61">///</a>
<a name="ln62"> </a>
<a name="ln63">#include &lt;assert.h&gt;</a>
<a name="ln64">#include &lt;inttypes.h&gt;</a>
<a name="ln65">#include &lt;stdbool.h&gt;</a>
<a name="ln66">#include &lt;string.h&gt;</a>
<a name="ln67"> </a>
<a name="ln68">#include &quot;nvim/log.h&quot;</a>
<a name="ln69">#include &quot;nvim/vim.h&quot;</a>
<a name="ln70">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln71">#include &quot;nvim/arabic.h&quot;</a>
<a name="ln72">#include &quot;nvim/screen.h&quot;</a>
<a name="ln73">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln74">#include &quot;nvim/charset.h&quot;</a>
<a name="ln75">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln76">#include &quot;nvim/cursor_shape.h&quot;</a>
<a name="ln77">#include &quot;nvim/diff.h&quot;</a>
<a name="ln78">#include &quot;nvim/eval.h&quot;</a>
<a name="ln79">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln80">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln81">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln82">#include &quot;nvim/edit.h&quot;</a>
<a name="ln83">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln84">#include &quot;nvim/fold.h&quot;</a>
<a name="ln85">#include &quot;nvim/indent.h&quot;</a>
<a name="ln86">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln87">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln88">#include &quot;nvim/main.h&quot;</a>
<a name="ln89">#include &quot;nvim/mark.h&quot;</a>
<a name="ln90">#include &quot;nvim/extmark.h&quot;</a>
<a name="ln91">#include &quot;nvim/decoration.h&quot;</a>
<a name="ln92">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln93">#include &quot;nvim/memline.h&quot;</a>
<a name="ln94">#include &quot;nvim/memory.h&quot;</a>
<a name="ln95">#include &quot;nvim/menu.h&quot;</a>
<a name="ln96">#include &quot;nvim/message.h&quot;</a>
<a name="ln97">#include &quot;nvim/misc1.h&quot;</a>
<a name="ln98">#include &quot;nvim/garray.h&quot;</a>
<a name="ln99">#include &quot;nvim/move.h&quot;</a>
<a name="ln100">#include &quot;nvim/normal.h&quot;</a>
<a name="ln101">#include &quot;nvim/option.h&quot;</a>
<a name="ln102">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln103">#include &quot;nvim/path.h&quot;</a>
<a name="ln104">#include &quot;nvim/popupmnu.h&quot;</a>
<a name="ln105">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln106">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln107">#include &quot;nvim/search.h&quot;</a>
<a name="ln108">#include &quot;nvim/sign.h&quot;</a>
<a name="ln109">#include &quot;nvim/spell.h&quot;</a>
<a name="ln110">#include &quot;nvim/state.h&quot;</a>
<a name="ln111">#include &quot;nvim/strings.h&quot;</a>
<a name="ln112">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln113">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln114">#include &quot;nvim/ui.h&quot;</a>
<a name="ln115">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln116">#include &quot;nvim/undo.h&quot;</a>
<a name="ln117">#include &quot;nvim/version.h&quot;</a>
<a name="ln118">#include &quot;nvim/window.h&quot;</a>
<a name="ln119">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln120">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln121">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln122">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln123">#include &quot;nvim/lib/kvec.h&quot;</a>
<a name="ln124"> </a>
<a name="ln125">#define MB_FILLER_CHAR '&lt;'  /* character used when a double-width character</a>
<a name="ln126">                             * doesn't fit. */</a>
<a name="ln127"> </a>
<a name="ln128">typedef kvec_withinit_t(DecorProvider *, 4) Providers;</a>
<a name="ln129"> </a>
<a name="ln130">// temporary buffer for rendering a single screenline, so it can be</a>
<a name="ln131">// compared with previous contents to calculate smallest delta.</a>
<a name="ln132">// Per-cell attributes</a>
<a name="ln133">static size_t linebuf_size = 0;</a>
<a name="ln134">static schar_T *linebuf_char = NULL;</a>
<a name="ln135">static sattr_T *linebuf_attr = NULL;</a>
<a name="ln136"> </a>
<a name="ln137">static match_T search_hl;       /* used for 'hlsearch' highlight matching */</a>
<a name="ln138"> </a>
<a name="ln139">StlClickDefinition *tab_page_click_defs = NULL;</a>
<a name="ln140"> </a>
<a name="ln141">long tab_page_click_defs_size = 0;</a>
<a name="ln142"> </a>
<a name="ln143">// for line_putchar. Contains the state that needs to be remembered from</a>
<a name="ln144">// putting one character to the next.</a>
<a name="ln145">typedef struct {</a>
<a name="ln146">  const char *p;</a>
<a name="ln147">  int prev_c;  // previous Arabic character</a>
<a name="ln148">  int prev_c1;  // first composing char for prev_c</a>
<a name="ln149">} LineState;</a>
<a name="ln150">#define LINE_STATE(p) { p, 0, 0 }</a>
<a name="ln151"> </a>
<a name="ln152">/// Whether to call &quot;ui_call_grid_resize&quot; in win_grid_alloc</a>
<a name="ln153">static bool send_grid_resize = false;</a>
<a name="ln154"> </a>
<a name="ln155">static bool conceal_cursor_used = false;</a>
<a name="ln156"> </a>
<a name="ln157">static bool redraw_popupmenu = false;</a>
<a name="ln158">static bool msg_grid_invalid = false;</a>
<a name="ln159"> </a>
<a name="ln160">static bool resizing = false;</a>
<a name="ln161"> </a>
<a name="ln162"> </a>
<a name="ln163">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln164"># include &quot;screen.c.generated.h&quot;</a>
<a name="ln165">#endif</a>
<a name="ln166">#define SEARCH_HL_PRIORITY 0</a>
<a name="ln167"> </a>
<a name="ln168">static char * provider_first_error = NULL;</a>
<a name="ln169"> </a>
<a name="ln170">static bool provider_invoke(NS ns_id, const char *name, LuaRef ref,</a>
<a name="ln171">                            Array args, bool default_true)</a>
<a name="ln172">{</a>
<a name="ln173">  Error err = ERROR_INIT;</a>
<a name="ln174"> </a>
<a name="ln175">  textlock++;</a>
<a name="ln176">  provider_active = true;</a>
<a name="ln177">  Object ret = nlua_call_ref(ref, name, args, true, &amp;err);</a>
<a name="ln178">  provider_active = false;</a>
<a name="ln179">  textlock--;</a>
<a name="ln180"> </a>
<a name="ln181">  if (!ERROR_SET(&amp;err)</a>
<a name="ln182">      &amp;&amp; api_object_to_bool(ret, &quot;provider %s retval&quot;, default_true, &amp;err)) {</a>
<a name="ln183">    return true;</a>
<a name="ln184">  }</a>
<a name="ln185"> </a>
<a name="ln186">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln187">    const char *ns_name = describe_ns(ns_id);</a>
<a name="ln188">    ELOG(&quot;error in provider %s:%s: %s&quot;, ns_name, name, err.msg);</a>
<a name="ln189">    bool verbose_errs = true;  // TODO(bfredl):</a>
<a name="ln190">    if (verbose_errs &amp;&amp; provider_first_error == NULL) {</a>
<a name="ln191">      static char errbuf[IOSIZE];</a>
<a name="ln192">      snprintf(errbuf, sizeof errbuf, &quot;%s: %s&quot;, ns_name, err.msg);</a>
<a name="ln193">      provider_first_error = xstrdup(errbuf);</a>
<a name="ln194">    }</a>
<a name="ln195">  }</a>
<a name="ln196"> </a>
<a name="ln197">  api_free_object(ret);</a>
<a name="ln198">  return false;</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">/// Redraw a window later, with update_screen(type).</a>
<a name="ln202">///</a>
<a name="ln203">/// Set must_redraw only if not already set to a higher value.</a>
<a name="ln204">/// e.g. if must_redraw is CLEAR, type NOT_VALID will do nothing.</a>
<a name="ln205">void redraw_later(win_T *wp, int type)</a>
<a name="ln206">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln207">{</a>
<a name="ln208">  if (!exiting &amp;&amp; wp-&gt;w_redr_type &lt; type) {</a>
<a name="ln209">    wp-&gt;w_redr_type = type;</a>
<a name="ln210">    if (type &gt;= NOT_VALID)</a>
<a name="ln211">      wp-&gt;w_lines_valid = 0;</a>
<a name="ln212">    if (must_redraw &lt; type)     /* must_redraw is the maximum of all windows */</a>
<a name="ln213">      must_redraw = type;</a>
<a name="ln214">  }</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">/*</a>
<a name="ln218"> * Mark all windows to be redrawn later.</a>
<a name="ln219"> */</a>
<a name="ln220">void redraw_all_later(int type)</a>
<a name="ln221">{</a>
<a name="ln222">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln223">    redraw_later(wp, type);</a>
<a name="ln224">  }</a>
<a name="ln225">  // This may be needed when switching tabs.</a>
<a name="ln226">  if (must_redraw &lt; type) {</a>
<a name="ln227">    must_redraw = type;</a>
<a name="ln228">  }</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231">void screen_invalidate_highlights(void)</a>
<a name="ln232">{</a>
<a name="ln233">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln234">    redraw_later(wp, NOT_VALID);</a>
<a name="ln235">    wp-&gt;w_grid_alloc.valid = false;</a>
<a name="ln236">  }</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">/*</a>
<a name="ln240"> * Mark all windows that are editing the current buffer to be updated later.</a>
<a name="ln241"> */</a>
<a name="ln242">void redraw_curbuf_later(int type)</a>
<a name="ln243">{</a>
<a name="ln244">  redraw_buf_later(curbuf, type);</a>
<a name="ln245">}</a>
<a name="ln246"> </a>
<a name="ln247">void redraw_buf_later(buf_T *buf, int type)</a>
<a name="ln248">{</a>
<a name="ln249">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln250">    if (wp-&gt;w_buffer == buf) {</a>
<a name="ln251">      redraw_later(wp, type);</a>
<a name="ln252">    }</a>
<a name="ln253">  }</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">void redraw_buf_line_later(buf_T *buf,  linenr_T line)</a>
<a name="ln257">{</a>
<a name="ln258">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln259">    if (wp-&gt;w_buffer == buf</a>
<a name="ln260">        &amp;&amp; line &gt;= wp-&gt;w_topline &amp;&amp; line &lt; wp-&gt;w_botline) {</a>
<a name="ln261">      redrawWinline(wp, line);</a>
<a name="ln262">    }</a>
<a name="ln263">  }</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">void redraw_buf_range_later(buf_T *buf,  linenr_T firstline, linenr_T lastline)</a>
<a name="ln267">{</a>
<a name="ln268">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln269">    if (wp-&gt;w_buffer == buf</a>
<a name="ln270">        &amp;&amp; lastline &gt;= wp-&gt;w_topline &amp;&amp; firstline &lt; wp-&gt;w_botline) {</a>
<a name="ln271">      if (wp-&gt;w_redraw_top == 0 || wp-&gt;w_redraw_top &gt; firstline) {</a>
<a name="ln272">          wp-&gt;w_redraw_top = firstline;</a>
<a name="ln273">      }</a>
<a name="ln274">      if (wp-&gt;w_redraw_bot == 0 || wp-&gt;w_redraw_bot &lt; lastline) {</a>
<a name="ln275">          wp-&gt;w_redraw_bot = lastline;</a>
<a name="ln276">      }</a>
<a name="ln277">      redraw_later(wp, VALID);</a>
<a name="ln278">    }</a>
<a name="ln279">  }</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">/*</a>
<a name="ln283"> * Changed something in the current window, at buffer line &quot;lnum&quot;, that</a>
<a name="ln284"> * requires that line and possibly other lines to be redrawn.</a>
<a name="ln285"> * Used when entering/leaving Insert mode with the cursor on a folded line.</a>
<a name="ln286"> * Used to remove the &quot;$&quot; from a change command.</a>
<a name="ln287"> * Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot</a>
<a name="ln288"> * may become invalid and the whole window will have to be redrawn.</a>
<a name="ln289"> */</a>
<a name="ln290">void</a>
<a name="ln291">redrawWinline(</a>
<a name="ln292">    win_T *wp,</a>
<a name="ln293">    linenr_T lnum</a>
<a name="ln294">)</a>
<a name="ln295">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln296">{</a>
<a name="ln297">  if (lnum &gt;= wp-&gt;w_topline</a>
<a name="ln298">      &amp;&amp; lnum &lt; wp-&gt;w_botline) {</a>
<a name="ln299">    if (wp-&gt;w_redraw_top == 0 || wp-&gt;w_redraw_top &gt; lnum) {</a>
<a name="ln300">        wp-&gt;w_redraw_top = lnum;</a>
<a name="ln301">    }</a>
<a name="ln302">    if (wp-&gt;w_redraw_bot == 0 || wp-&gt;w_redraw_bot &lt; lnum) {</a>
<a name="ln303">        wp-&gt;w_redraw_bot = lnum;</a>
<a name="ln304">    }</a>
<a name="ln305">    redraw_later(wp, VALID);</a>
<a name="ln306">  }</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">/*</a>
<a name="ln310"> * update all windows that are editing the current buffer</a>
<a name="ln311"> */</a>
<a name="ln312">void update_curbuf(int type)</a>
<a name="ln313">{</a>
<a name="ln314">  redraw_curbuf_later(type);</a>
<a name="ln315">  update_screen(type);</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">/// Redraw the parts of the screen that is marked for redraw.</a>
<a name="ln319">///</a>
<a name="ln320">/// Most code shouldn't call this directly, rather use redraw_later() and</a>
<a name="ln321">/// and redraw_all_later() to mark parts of the screen as needing a redraw.</a>
<a name="ln322">///</a>
<a name="ln323">/// @param type set to a NOT_VALID to force redraw of entire screen</a>
<a name="ln324">int update_screen(int type)</a>
<a name="ln325">{</a>
<a name="ln326">  static int did_intro = FALSE;</a>
<a name="ln327">  int did_one;</a>
<a name="ln328"> </a>
<a name="ln329">  // Don't do anything if the screen structures are (not yet) valid.</a>
<a name="ln330">  // A VimResized autocmd can invoke redrawing in the middle of a resize,</a>
<a name="ln331">  // which would bypass the checks in screen_resize for popupmenu etc.</a>
<a name="ln332">  if (!default_grid.chars || resizing) {</a>
<a name="ln333">    return FAIL;</a>
<a name="ln334">  }</a>
<a name="ln335"> </a>
<a name="ln336">  // May have postponed updating diffs.</a>
<a name="ln337">  if (need_diff_redraw) {</a>
<a name="ln338">    diff_redraw(true);</a>
<a name="ln339">  }</a>
<a name="ln340"> </a>
<a name="ln341">  if (must_redraw) {</a>
<a name="ln342">    if (type &lt; must_redraw)         /* use maximal type */</a>
<a name="ln343">      type = must_redraw;</a>
<a name="ln344"> </a>
<a name="ln345">    /* must_redraw is reset here, so that when we run into some weird</a>
<a name="ln346">    * reason to redraw while busy redrawing (e.g., asynchronous</a>
<a name="ln347">    * scrolling), or update_topline() in win_update() will cause a</a>
<a name="ln348">    * scroll, the screen will be redrawn later or in win_update(). */</a>
<a name="ln349">    must_redraw = 0;</a>
<a name="ln350">  }</a>
<a name="ln351"> </a>
<a name="ln352">  /* Need to update w_lines[]. */</a>
<a name="ln353">  if (curwin-&gt;w_lines_valid == 0 &amp;&amp; type &lt; NOT_VALID)</a>
<a name="ln354">    type = NOT_VALID;</a>
<a name="ln355"> </a>
<a name="ln356">  /* Postpone the redrawing when it's not needed and when being called</a>
<a name="ln357">   * recursively. */</a>
<a name="ln358">  if (!redrawing() || updating_screen) {</a>
<a name="ln359">    must_redraw = type;</a>
<a name="ln360">    if (type &gt; INVERTED_ALL) {</a>
<a name="ln361">      curwin-&gt;w_lines_valid = 0;  // don't use w_lines[].wl_size now</a>
<a name="ln362">    }</a>
<a name="ln363">    return FAIL;</a>
<a name="ln364">  }</a>
<a name="ln365">  updating_screen = 1;</a>
<a name="ln366"> </a>
<a name="ln367">  display_tick++;           // let syntax code know we're in a next round of</a>
<a name="ln368">                            // display updating</a>
<a name="ln369"> </a>
<a name="ln370">  // Tricky: vim code can reset msg_scrolled behind our back, so need</a>
<a name="ln371">  // separate bookkeeping for now.</a>
<a name="ln372">  if (msg_did_scroll) {</a>
<a name="ln373">    msg_did_scroll = false;</a>
<a name="ln374">    msg_scrolled_at_flush = 0;</a>
<a name="ln375">  }</a>
<a name="ln376"> </a>
<a name="ln377">  if (type &gt;= CLEAR || !default_grid.valid) {</a>
<a name="ln378">    ui_comp_set_screen_valid(false);</a>
<a name="ln379">  }</a>
<a name="ln380"> </a>
<a name="ln381">  // if the screen was scrolled up when displaying a message, scroll it down</a>
<a name="ln382">  if (msg_scrolled || msg_grid_invalid) {</a>
<a name="ln383">    clear_cmdline = true;</a>
<a name="ln384">    int valid = MAX(Rows - msg_scrollsize(), 0);</a>
<a name="ln385">    if (msg_grid.chars) {</a>
<a name="ln386">      // non-displayed part of msg_grid is considered invalid.</a>
<a name="ln387">      for (int i = 0; i &lt; MIN(msg_scrollsize(), msg_grid.Rows); i++) {</a>
<a name="ln388">        grid_clear_line(&amp;msg_grid, msg_grid.line_offset[i],</a>
<a name="ln389">                        (int)msg_grid.Columns, false);</a>
<a name="ln390">      }</a>
<a name="ln391">    }</a>
<a name="ln392">    if (msg_use_msgsep()) {</a>
<a name="ln393">      msg_grid.throttled = false;</a>
<a name="ln394">      // CLEAR is already handled</a>
<a name="ln395">      if (type == NOT_VALID &amp;&amp; !ui_has(kUIMultigrid) &amp;&amp; msg_scrolled) {</a>
<a name="ln396">        ui_comp_set_screen_valid(false);</a>
<a name="ln397">        for (int i = valid; i &lt; Rows-p_ch; i++) {</a>
<a name="ln398">          grid_clear_line(&amp;default_grid, default_grid.line_offset[i],</a>
<a name="ln399">                          Columns, false);</a>
<a name="ln400">        }</a>
<a name="ln401">        FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln402">          if (wp-&gt;w_floating) {</a>
<a name="ln403">            continue;</a>
<a name="ln404">          }</a>
<a name="ln405">          if (W_ENDROW(wp) &gt; valid) {</a>
<a name="ln406">            wp-&gt;w_redr_type = MAX(wp-&gt;w_redr_type, NOT_VALID);</a>
<a name="ln407">          }</a>
<a name="ln408">          if (W_ENDROW(wp) + wp-&gt;w_status_height &gt; valid) {</a>
<a name="ln409">            wp-&gt;w_redr_status = true;</a>
<a name="ln410">          }</a>
<a name="ln411">        }</a>
<a name="ln412">      }</a>
<a name="ln413">      msg_grid_set_pos(Rows-p_ch, false);</a>
<a name="ln414">      msg_grid_invalid = false;</a>
<a name="ln415">    } else if (msg_scrolled &gt; Rows - 5) {  // clearing is faster</a>
<a name="ln416">      type = CLEAR;</a>
<a name="ln417">    } else if (type != CLEAR) {</a>
<a name="ln418">      check_for_delay(false);</a>
<a name="ln419">      grid_ins_lines(&amp;default_grid, 0, msg_scrolled, Rows, 0, Columns);</a>
<a name="ln420">      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln421">        if (wp-&gt;w_floating) {</a>
<a name="ln422">          continue;</a>
<a name="ln423">        }</a>
<a name="ln424">        if (wp-&gt;w_winrow &lt; msg_scrolled) {</a>
<a name="ln425">          if (W_ENDROW(wp) &gt; msg_scrolled</a>
<a name="ln426">              &amp;&amp; wp-&gt;w_redr_type &lt; REDRAW_TOP</a>
<a name="ln427">              &amp;&amp; wp-&gt;w_lines_valid &gt; 0</a>
<a name="ln428">              &amp;&amp; wp-&gt;w_topline == wp-&gt;w_lines[0].wl_lnum) {</a>
<a name="ln429">            wp-&gt;w_upd_rows = msg_scrolled - wp-&gt;w_winrow;</a>
<a name="ln430">            wp-&gt;w_redr_type = REDRAW_TOP;</a>
<a name="ln431">          } else {</a>
<a name="ln432">            wp-&gt;w_redr_type = NOT_VALID;</a>
<a name="ln433">            if (W_ENDROW(wp) + wp-&gt;w_status_height</a>
<a name="ln434">                &lt;= msg_scrolled) {</a>
<a name="ln435">              wp-&gt;w_redr_status = TRUE;</a>
<a name="ln436">            }</a>
<a name="ln437">          }</a>
<a name="ln438">        }</a>
<a name="ln439">      }</a>
<a name="ln440">      redraw_cmdline = TRUE;</a>
<a name="ln441">      redraw_tabline = TRUE;</a>
<a name="ln442">    }</a>
<a name="ln443">    msg_scrolled = 0;</a>
<a name="ln444">    msg_scrolled_at_flush = 0;</a>
<a name="ln445">    need_wait_return = false;</a>
<a name="ln446">  }</a>
<a name="ln447"> </a>
<a name="ln448">  win_ui_flush();</a>
<a name="ln449">  msg_ext_check_clear();</a>
<a name="ln450"> </a>
<a name="ln451">  /* reset cmdline_row now (may have been changed temporarily) */</a>
<a name="ln452">  compute_cmdrow();</a>
<a name="ln453"> </a>
<a name="ln454">  /* Check for changed highlighting */</a>
<a name="ln455">  if (need_highlight_changed)</a>
<a name="ln456">    highlight_changed();</a>
<a name="ln457"> </a>
<a name="ln458">  if (type == CLEAR) {          // first clear screen</a>
<a name="ln459">    screenclear();              // will reset clear_cmdline</a>
<a name="ln460">    cmdline_screen_cleared();   // clear external cmdline state</a>
<a name="ln461">    type = NOT_VALID;</a>
<a name="ln462">    // must_redraw may be set indirectly, avoid another redraw later</a>
<a name="ln463">    must_redraw = 0;</a>
<a name="ln464">  } else if (!default_grid.valid) {</a>
<a name="ln465">    grid_invalidate(&amp;default_grid);</a>
<a name="ln466">    default_grid.valid = true;</a>
<a name="ln467">  }</a>
<a name="ln468"> </a>
<a name="ln469">  // After disabling msgsep the grid might not have been deallocated yet,</a>
<a name="ln470">  // hence we also need to check msg_grid.chars</a>
<a name="ln471">  if (type == NOT_VALID &amp;&amp; (msg_use_grid() || msg_grid.chars)) {</a>
<a name="ln472">    grid_fill(&amp;default_grid, Rows-p_ch, Rows, 0, Columns, ' ', ' ', 0);</a>
<a name="ln473">  }</a>
<a name="ln474"> </a>
<a name="ln475">  ui_comp_set_screen_valid(true);</a>
<a name="ln476"> </a>
<a name="ln477">  Providers providers;</a>
<a name="ln478">  kvi_init(providers);</a>
<a name="ln479">  for (size_t i = 0; i &lt; kv_size(decor_providers); i++) {</a>
<a name="ln480">    DecorProvider *p = &amp;kv_A(decor_providers, i);</a>
<a name="ln481">    if (!p-&gt;active) {</a>
<a name="ln482">      continue;</a>
<a name="ln483">    }</a>
<a name="ln484"> </a>
<a name="ln485">    bool active;</a>
<a name="ln486">    if (p-&gt;redraw_start != LUA_NOREF) {</a>
<a name="ln487">      FIXED_TEMP_ARRAY(args, 2);</a>
<a name="ln488">      args.items[0] = INTEGER_OBJ(display_tick);</a>
<a name="ln489">      args.items[1] = INTEGER_OBJ(type);</a>
<a name="ln490">      active = provider_invoke(p-&gt;ns_id, &quot;start&quot;, p-&gt;redraw_start, args, true);</a>
<a name="ln491">    } else {</a>
<a name="ln492">      active = true;</a>
<a name="ln493">    }</a>
<a name="ln494"> </a>
<a name="ln495">    if (active) {</a>
<a name="ln496">      kvi_push(providers, p);</a>
<a name="ln497">    }</a>
<a name="ln498">  }</a>
<a name="ln499"> </a>
<a name="ln500">  // &quot;start&quot; callback could have changed highlights for global elements</a>
<a name="ln501">  if (win_check_ns_hl(NULL)) {</a>
<a name="ln502">    redraw_cmdline = true;</a>
<a name="ln503">    redraw_tabline = true;</a>
<a name="ln504">  }</a>
<a name="ln505"> </a>
<a name="ln506">  if (clear_cmdline)            /* going to clear cmdline (done below) */</a>
<a name="ln507">    check_for_delay(FALSE);</a>
<a name="ln508"> </a>
<a name="ln509">  /* Force redraw when width of 'number' or 'relativenumber' column</a>
<a name="ln510">   * changes. */</a>
<a name="ln511">  if (curwin-&gt;w_redr_type &lt; NOT_VALID</a>
<a name="ln512">      &amp;&amp; curwin-&gt;w_nrwidth != ((curwin-&gt;w_p_nu || curwin-&gt;w_p_rnu)</a>
<a name="ln513">                               ? number_width(curwin) : 0))</a>
<a name="ln514">    curwin-&gt;w_redr_type = NOT_VALID;</a>
<a name="ln515"> </a>
<a name="ln516">  /*</a>
<a name="ln517">   * Only start redrawing if there is really something to do.</a>
<a name="ln518">   */</a>
<a name="ln519">  if (type == INVERTED)</a>
<a name="ln520">    update_curswant();</a>
<a name="ln521">  if (curwin-&gt;w_redr_type &lt; type</a>
<a name="ln522">      &amp;&amp; !((type == VALID</a>
<a name="ln523">            &amp;&amp; curwin-&gt;w_lines[0].wl_valid</a>
<a name="ln524">            &amp;&amp; curwin-&gt;w_topfill == curwin-&gt;w_old_topfill</a>
<a name="ln525">            &amp;&amp; curwin-&gt;w_botfill == curwin-&gt;w_old_botfill</a>
<a name="ln526">            &amp;&amp; curwin-&gt;w_topline == curwin-&gt;w_lines[0].wl_lnum)</a>
<a name="ln527">           || (type == INVERTED</a>
<a name="ln528">               &amp;&amp; VIsual_active</a>
<a name="ln529">               &amp;&amp; curwin-&gt;w_old_cursor_lnum == curwin-&gt;w_cursor.lnum</a>
<a name="ln530">               &amp;&amp; curwin-&gt;w_old_visual_mode == VIsual_mode</a>
<a name="ln531">               &amp;&amp; (curwin-&gt;w_valid &amp; VALID_VIRTCOL)</a>
<a name="ln532">               &amp;&amp; curwin-&gt;w_old_curswant == curwin-&gt;w_curswant)</a>
<a name="ln533">           ))</a>
<a name="ln534">    curwin-&gt;w_redr_type = type;</a>
<a name="ln535"> </a>
<a name="ln536">  // Redraw the tab pages line if needed.</a>
<a name="ln537">  if (redraw_tabline || type &gt;= NOT_VALID) {</a>
<a name="ln538">    update_window_hl(curwin, type &gt;= NOT_VALID);</a>
<a name="ln539">    FOR_ALL_TABS(tp) {</a>
<a name="ln540">      if (tp != curtab) {</a>
<a name="ln541">        update_window_hl(tp-&gt;tp_curwin, type &gt;= NOT_VALID);</a>
<a name="ln542">      }</a>
<a name="ln543">    }</a>
<a name="ln544">    draw_tabline();</a>
<a name="ln545">  }</a>
<a name="ln546"> </a>
<a name="ln547">  /*</a>
<a name="ln548">   * Correct stored syntax highlighting info for changes in each displayed</a>
<a name="ln549">   * buffer.  Each buffer must only be done once.</a>
<a name="ln550">   */</a>
<a name="ln551">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln552">    update_window_hl(wp, type &gt;= NOT_VALID);</a>
<a name="ln553"> </a>
<a name="ln554">    buf_T *buf = wp-&gt;w_buffer;</a>
<a name="ln555">    if (buf-&gt;b_mod_set) {</a>
<a name="ln556">      if (buf-&gt;b_mod_tick_syn &lt; display_tick</a>
<a name="ln557">          &amp;&amp; syntax_present(wp)) {</a>
<a name="ln558">        syn_stack_apply_changes(buf);</a>
<a name="ln559">        buf-&gt;b_mod_tick_syn = display_tick;</a>
<a name="ln560">      }</a>
<a name="ln561"> </a>
<a name="ln562">      if (buf-&gt;b_mod_tick_decor &lt; display_tick) {</a>
<a name="ln563">        for (size_t i = 0; i &lt; kv_size(providers); i++) {</a>
<a name="ln564">          DecorProvider *p = kv_A(providers, i);</a>
<a name="ln565">          if (p &amp;&amp; p-&gt;redraw_buf != LUA_NOREF) {</a>
<a name="ln566">            FIXED_TEMP_ARRAY(args, 1);</a>
<a name="ln567">            args.items[0] = BUFFER_OBJ(buf-&gt;handle);</a>
<a name="ln568">            provider_invoke(p-&gt;ns_id, &quot;buf&quot;, p-&gt;redraw_buf, args, true);</a>
<a name="ln569">          }</a>
<a name="ln570">        }</a>
<a name="ln571">        buf-&gt;b_mod_tick_decor = display_tick;</a>
<a name="ln572">      }</a>
<a name="ln573">    }</a>
<a name="ln574">  }</a>
<a name="ln575"> </a>
<a name="ln576">  /*</a>
<a name="ln577">   * Go from top to bottom through the windows, redrawing the ones that need</a>
<a name="ln578">   * it.</a>
<a name="ln579">   */</a>
<a name="ln580">  did_one = FALSE;</a>
<a name="ln581">  search_hl.rm.regprog = NULL;</a>
<a name="ln582"> </a>
<a name="ln583"> </a>
<a name="ln584">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln585">    if (wp-&gt;w_redr_type == CLEAR &amp;&amp; wp-&gt;w_floating &amp;&amp; wp-&gt;w_grid_alloc.chars) {</a>
<a name="ln586">      grid_invalidate(&amp;wp-&gt;w_grid_alloc);</a>
<a name="ln587">      wp-&gt;w_redr_type = NOT_VALID;</a>
<a name="ln588">    }</a>
<a name="ln589"> </a>
<a name="ln590">    // reallocate grid if needed.</a>
<a name="ln591">    win_grid_alloc(wp);</a>
<a name="ln592"> </a>
<a name="ln593">    if (wp-&gt;w_redr_border || wp-&gt;w_redr_type &gt;= NOT_VALID) {</a>
<a name="ln594">      win_redr_border(wp);</a>
<a name="ln595">    }</a>
<a name="ln596"> </a>
<a name="ln597">    if (wp-&gt;w_redr_type != 0) {</a>
<a name="ln598">      if (!did_one) {</a>
<a name="ln599">        did_one = TRUE;</a>
<a name="ln600">        start_search_hl();</a>
<a name="ln601">      }</a>
<a name="ln602">      win_update(wp, &amp;providers);</a>
<a name="ln603">    }</a>
<a name="ln604"> </a>
<a name="ln605">    /* redraw status line after the window to minimize cursor movement */</a>
<a name="ln606">    if (wp-&gt;w_redr_status) {</a>
<a name="ln607">      win_redr_status(wp);</a>
<a name="ln608">    }</a>
<a name="ln609">  }</a>
<a name="ln610"> </a>
<a name="ln611">  end_search_hl();</a>
<a name="ln612"> </a>
<a name="ln613">  // May need to redraw the popup menu.</a>
<a name="ln614">  if (pum_drawn() &amp;&amp; must_redraw_pum) {</a>
<a name="ln615">    pum_redraw();</a>
<a name="ln616">  }</a>
<a name="ln617"> </a>
<a name="ln618">  send_grid_resize = false;</a>
<a name="ln619"> </a>
<a name="ln620">  /* Reset b_mod_set flags.  Going through all windows is probably faster</a>
<a name="ln621">   * than going through all buffers (there could be many buffers). */</a>
<a name="ln622">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln623">    wp-&gt;w_buffer-&gt;b_mod_set = false;</a>
<a name="ln624">  }</a>
<a name="ln625"> </a>
<a name="ln626">  updating_screen = 0;</a>
<a name="ln627"> </a>
<a name="ln628">  /* Clear or redraw the command line.  Done last, because scrolling may</a>
<a name="ln629">   * mess up the command line. */</a>
<a name="ln630">  if (clear_cmdline || redraw_cmdline) {</a>
<a name="ln631">    showmode();</a>
<a name="ln632">  }</a>
<a name="ln633"> </a>
<a name="ln634">  /* May put up an introductory message when not editing a file */</a>
<a name="ln635">  if (!did_intro)</a>
<a name="ln636">    maybe_intro_message();</a>
<a name="ln637">  did_intro = TRUE;</a>
<a name="ln638"> </a>
<a name="ln639">  for (size_t i = 0; i &lt; kv_size(providers); i++) {</a>
<a name="ln640">    DecorProvider *p = kv_A(providers, i);</a>
<a name="ln641">    if (!p-&gt;active) {</a>
<a name="ln642">      continue;</a>
<a name="ln643">    }</a>
<a name="ln644"> </a>
<a name="ln645">    if (p-&gt;redraw_end != LUA_NOREF) {</a>
<a name="ln646">      FIXED_TEMP_ARRAY(args, 1);</a>
<a name="ln647">      args.items[0] = INTEGER_OBJ(display_tick);</a>
<a name="ln648">      provider_invoke(p-&gt;ns_id, &quot;end&quot;, p-&gt;redraw_end, args, true);</a>
<a name="ln649">    }</a>
<a name="ln650">  }</a>
<a name="ln651">  kvi_destroy(providers);</a>
<a name="ln652"> </a>
<a name="ln653"> </a>
<a name="ln654">  // either cmdline is cleared, not drawn or mode is last drawn</a>
<a name="ln655">  cmdline_was_last_drawn = false;</a>
<a name="ln656">  return OK;</a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659">// Return true if the cursor line in window &quot;wp&quot; may be concealed, according</a>
<a name="ln660">// to the 'concealcursor' option.</a>
<a name="ln661">bool conceal_cursor_line(const win_T *wp)</a>
<a name="ln662">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln663">{</a>
<a name="ln664">  int c;</a>
<a name="ln665"> </a>
<a name="ln666">  if (*wp-&gt;w_p_cocu == NUL) {</a>
<a name="ln667">    return false;</a>
<a name="ln668">  }</a>
<a name="ln669">  if (get_real_state() &amp; VISUAL) {</a>
<a name="ln670">    c = 'v';</a>
<a name="ln671">  } else if (State &amp; INSERT) {</a>
<a name="ln672">    c = 'i';</a>
<a name="ln673">  } else if (State &amp; NORMAL) {</a>
<a name="ln674">    c = 'n';</a>
<a name="ln675">  } else if (State &amp; CMDLINE) {</a>
<a name="ln676">    c = 'c';</a>
<a name="ln677">  } else {</a>
<a name="ln678">    return false;</a>
<a name="ln679">  }</a>
<a name="ln680">  return vim_strchr(wp-&gt;w_p_cocu, c) != NULL;</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">// Check if the cursor line needs to be redrawn because of 'concealcursor'.</a>
<a name="ln684">//</a>
<a name="ln685">// When cursor is moved at the same time, both lines will be redrawn regardless.</a>
<a name="ln686">void conceal_check_cursor_line(void)</a>
<a name="ln687">{</a>
<a name="ln688">  bool should_conceal = conceal_cursor_line(curwin);</a>
<a name="ln689">  if (curwin-&gt;w_p_cole &gt; 0 &amp;&amp; (conceal_cursor_used != should_conceal)) {</a>
<a name="ln690">    redrawWinline(curwin, curwin-&gt;w_cursor.lnum);</a>
<a name="ln691">    // Need to recompute cursor column, e.g., when starting Visual mode</a>
<a name="ln692">    // without concealing. */</a>
<a name="ln693">    curs_columns(curwin, true);</a>
<a name="ln694">  }</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">/// Whether cursorline is drawn in a special way</a>
<a name="ln698">///</a>
<a name="ln699">/// If true, both old and new cursorline will need</a>
<a name="ln700">/// to be redrawn when moving cursor within windows.</a>
<a name="ln701">/// TODO(bfredl): VIsual_active shouldn't be needed, but is used to fix a glitch</a>
<a name="ln702">///               caused by scrolling.</a>
<a name="ln703">bool win_cursorline_standout(const win_T *wp)</a>
<a name="ln704">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln705">{</a>
<a name="ln706">  return wp-&gt;w_p_cul</a>
<a name="ln707">    || (wp-&gt;w_p_cole &gt; 0 &amp;&amp; (VIsual_active || !conceal_cursor_line(wp)));</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710">/*</a>
<a name="ln711"> * Update a single window.</a>
<a name="ln712"> *</a>
<a name="ln713"> * This may cause the windows below it also to be redrawn (when clearing the</a>
<a name="ln714"> * screen or scrolling lines).</a>
<a name="ln715"> *</a>
<a name="ln716"> * How the window is redrawn depends on wp-&gt;w_redr_type.  Each type also</a>
<a name="ln717"> * implies the one below it.</a>
<a name="ln718"> * NOT_VALID	redraw the whole window</a>
<a name="ln719"> * SOME_VALID	redraw the whole window but do scroll when possible</a>
<a name="ln720"> * REDRAW_TOP	redraw the top w_upd_rows window lines, otherwise like VALID</a>
<a name="ln721"> * INVERTED	redraw the changed part of the Visual area</a>
<a name="ln722"> * INVERTED_ALL	redraw the whole Visual area</a>
<a name="ln723"> * VALID	1. scroll up/down to adjust for a changed w_topline</a>
<a name="ln724"> *		2. update lines at the top when scrolled down</a>
<a name="ln725"> *		3. redraw changed text:</a>
<a name="ln726"> *		   - if wp-&gt;w_buffer-&gt;b_mod_set set, update lines between</a>
<a name="ln727"> *		     b_mod_top and b_mod_bot.</a>
<a name="ln728"> *		   - if wp-&gt;w_redraw_top non-zero, redraw lines between</a>
<a name="ln729"> *		     wp-&gt;w_redraw_top and wp-&gt;w_redr_bot.</a>
<a name="ln730"> *		   - continue redrawing when syntax status is invalid.</a>
<a name="ln731"> *		4. if scrolled up, update lines at the bottom.</a>
<a name="ln732"> * This results in three areas that may need updating:</a>
<a name="ln733"> * top:	from first row to top_end (when scrolled down)</a>
<a name="ln734"> * mid: from mid_start to mid_end (update inversion or changed text)</a>
<a name="ln735"> * bot: from bot_start to last row (when scrolled up)</a>
<a name="ln736"> */</a>
<a name="ln737">static void win_update(win_T *wp, Providers *providers)</a>
<a name="ln738">{</a>
<a name="ln739">  buf_T       *buf = wp-&gt;w_buffer;</a>
<a name="ln740">  int type;</a>
<a name="ln741">  int top_end = 0;              /* Below last row of the top area that needs</a>
<a name="ln742">                                   updating.  0 when no top area updating. */</a>
<a name="ln743">  int mid_start = 999;          /* first row of the mid area that needs</a>
<a name="ln744">                                   updating.  999 when no mid area updating. */</a>
<a name="ln745">  int mid_end = 0;              /* Below last row of the mid area that needs</a>
<a name="ln746">                                   updating.  0 when no mid area updating. */</a>
<a name="ln747">  int bot_start = 999;          /* first row of the bot area that needs</a>
<a name="ln748">                                   updating.  999 when no bot area updating */</a>
<a name="ln749">  int scrolled_down = FALSE;            /* TRUE when scrolled down when</a>
<a name="ln750">                                           w_topline got smaller a bit */</a>
<a name="ln751">  bool top_to_mod = false;      // redraw above mod_top</a>
<a name="ln752"> </a>
<a name="ln753">  int row;                      /* current window row to display */</a>
<a name="ln754">  linenr_T lnum;                /* current buffer lnum to display */</a>
<a name="ln755">  int idx;                      /* current index in w_lines[] */</a>
<a name="ln756">  int srow;                     /* starting row of the current line */</a>
<a name="ln757"> </a>
<a name="ln758">  int eof = FALSE;              /* if TRUE, we hit the end of the file */</a>
<a name="ln759">  int didline = FALSE;           /* if TRUE, we finished the last line */</a>
<a name="ln760">  int i;</a>
<a name="ln761">  long j;</a>
<a name="ln762">  static bool recursive = false;  // being called recursively</a>
<a name="ln763">  const linenr_T old_botline = wp-&gt;w_botline;</a>
<a name="ln764">  const int old_wrow = wp-&gt;w_wrow;</a>
<a name="ln765">  const int old_wcol = wp-&gt;w_wcol;</a>
<a name="ln766">  // Remember what happened to the previous line.</a>
<a name="ln767">#define DID_NONE 1      // didn't update a line</a>
<a name="ln768">#define DID_LINE 2      // updated a normal line</a>
<a name="ln769">#define DID_FOLD 3      // updated a folded line</a>
<a name="ln770">  int did_update = DID_NONE;</a>
<a name="ln771">  linenr_T syntax_last_parsed = 0;              /* last parsed text line */</a>
<a name="ln772">  linenr_T mod_top = 0;</a>
<a name="ln773">  linenr_T mod_bot = 0;</a>
<a name="ln774">  int save_got_int;</a>
<a name="ln775"> </a>
<a name="ln776"> </a>
<a name="ln777">  // If we can compute a change in the automatic sizing of the sign column</a>
<a name="ln778">  // under 'signcolumn=auto:X' and signs currently placed in the buffer, better</a>
<a name="ln779">  // figuring it out here so we can redraw the entire screen for it.</a>
<a name="ln780">  buf_signcols(buf);</a>
<a name="ln781"> </a>
<a name="ln782">  type = wp-&gt;w_redr_type;</a>
<a name="ln783"> </a>
<a name="ln784">  if (type &gt;= NOT_VALID) {</a>
<a name="ln785">    wp-&gt;w_redr_status = true;</a>
<a name="ln786">    wp-&gt;w_lines_valid = 0;</a>
<a name="ln787">  }</a>
<a name="ln788"> </a>
<a name="ln789">  // Window is zero-height: nothing to draw.</a>
<a name="ln790">  if (wp-&gt;w_grid.Rows == 0) {</a>
<a name="ln791">    wp-&gt;w_redr_type = 0;</a>
<a name="ln792">    return;</a>
<a name="ln793">  }</a>
<a name="ln794"> </a>
<a name="ln795">  // Window is zero-width: Only need to draw the separator.</a>
<a name="ln796">  if (wp-&gt;w_grid.Columns == 0) {</a>
<a name="ln797">    // draw the vertical separator right of this window</a>
<a name="ln798">    draw_vsep_win(wp, 0);</a>
<a name="ln799">    wp-&gt;w_redr_type = 0;</a>
<a name="ln800">    return;</a>
<a name="ln801">  }</a>
<a name="ln802"> </a>
<a name="ln803">  init_search_hl(wp);</a>
<a name="ln804"> </a>
<a name="ln805">  /* Force redraw when width of 'number' or 'relativenumber' column</a>
<a name="ln806">   * changes. */</a>
<a name="ln807">  i = (wp-&gt;w_p_nu || wp-&gt;w_p_rnu) ? number_width(wp) : 0;</a>
<a name="ln808">  if (wp-&gt;w_nrwidth != i) {</a>
<a name="ln809">    type = NOT_VALID;</a>
<a name="ln810">    wp-&gt;w_nrwidth = i;</a>
<a name="ln811"> </a>
<a name="ln812">    if (buf-&gt;terminal) {</a>
<a name="ln813">      terminal_check_size(buf-&gt;terminal);</a>
<a name="ln814">    }</a>
<a name="ln815">  } else if (buf-&gt;b_mod_set</a>
<a name="ln816">             &amp;&amp; buf-&gt;b_mod_xlines != 0</a>
<a name="ln817">             &amp;&amp; wp-&gt;w_redraw_top != 0) {</a>
<a name="ln818">    // When there are both inserted/deleted lines and specific lines to be</a>
<a name="ln819">    // redrawn, w_redraw_top and w_redraw_bot may be invalid, just redraw</a>
<a name="ln820">    // everything (only happens when redrawing is off for while).</a>
<a name="ln821">    type = NOT_VALID;</a>
<a name="ln822">  } else {</a>
<a name="ln823">    /*</a>
<a name="ln824">     * Set mod_top to the first line that needs displaying because of</a>
<a name="ln825">     * changes.  Set mod_bot to the first line after the changes.</a>
<a name="ln826">     */</a>
<a name="ln827">    mod_top = wp-&gt;w_redraw_top;</a>
<a name="ln828">    if (wp-&gt;w_redraw_bot != 0)</a>
<a name="ln829">      mod_bot = wp-&gt;w_redraw_bot + 1;</a>
<a name="ln830">    else</a>
<a name="ln831">      mod_bot = 0;</a>
<a name="ln832">    if (buf-&gt;b_mod_set) {</a>
<a name="ln833">      if (mod_top == 0 || mod_top &gt; buf-&gt;b_mod_top) {</a>
<a name="ln834">        mod_top = buf-&gt;b_mod_top;</a>
<a name="ln835">        /* Need to redraw lines above the change that may be included</a>
<a name="ln836">         * in a pattern match. */</a>
<a name="ln837">        if (syntax_present(wp)) {</a>
<a name="ln838">          mod_top -= buf-&gt;b_s.b_syn_sync_linebreaks;</a>
<a name="ln839">          if (mod_top &lt; 1)</a>
<a name="ln840">            mod_top = 1;</a>
<a name="ln841">        }</a>
<a name="ln842">      }</a>
<a name="ln843">      if (mod_bot == 0 || mod_bot &lt; buf-&gt;b_mod_bot)</a>
<a name="ln844">        mod_bot = buf-&gt;b_mod_bot;</a>
<a name="ln845"> </a>
<a name="ln846">      // When 'hlsearch' is on and using a multi-line search pattern, a</a>
<a name="ln847">      // change in one line may make the Search highlighting in a</a>
<a name="ln848">      // previous line invalid.  Simple solution: redraw all visible</a>
<a name="ln849">      // lines above the change.</a>
<a name="ln850">      // Same for a match pattern.</a>
<a name="ln851">      if (search_hl.rm.regprog != NULL</a>
<a name="ln852">          &amp;&amp; re_multiline(search_hl.rm.regprog)) {</a>
<a name="ln853">        top_to_mod = true;</a>
<a name="ln854">      } else {</a>
<a name="ln855">        const matchitem_T *cur = wp-&gt;w_match_head;</a>
<a name="ln856">        while (cur != NULL) {</a>
<a name="ln857">          if (cur-&gt;match.regprog != NULL</a>
<a name="ln858">              &amp;&amp; re_multiline(cur-&gt;match.regprog)) {</a>
<a name="ln859">            top_to_mod = true;</a>
<a name="ln860">            break;</a>
<a name="ln861">          }</a>
<a name="ln862">          cur = cur-&gt;next;</a>
<a name="ln863">        }</a>
<a name="ln864">      }</a>
<a name="ln865">    }</a>
<a name="ln866">    if (mod_top != 0 &amp;&amp; hasAnyFolding(wp)) {</a>
<a name="ln867">      linenr_T lnumt, lnumb;</a>
<a name="ln868"> </a>
<a name="ln869">      /*</a>
<a name="ln870">       * A change in a line can cause lines above it to become folded or</a>
<a name="ln871">       * unfolded.  Find the top most buffer line that may be affected.</a>
<a name="ln872">       * If the line was previously folded and displayed, get the first</a>
<a name="ln873">       * line of that fold.  If the line is folded now, get the first</a>
<a name="ln874">       * folded line.  Use the minimum of these two.</a>
<a name="ln875">       */</a>
<a name="ln876"> </a>
<a name="ln877">      /* Find last valid w_lines[] entry above mod_top.  Set lnumt to</a>
<a name="ln878">       * the line below it.  If there is no valid entry, use w_topline.</a>
<a name="ln879">       * Find the first valid w_lines[] entry below mod_bot.  Set lnumb</a>
<a name="ln880">       * to this line.  If there is no valid entry, use MAXLNUM. */</a>
<a name="ln881">      lnumt = wp-&gt;w_topline;</a>
<a name="ln882">      lnumb = MAXLNUM;</a>
<a name="ln883">      for (i = 0; i &lt; wp-&gt;w_lines_valid; ++i)</a>
<a name="ln884">        if (wp-&gt;w_lines[i].wl_valid) {</a>
<a name="ln885">          if (wp-&gt;w_lines[i].wl_lastlnum &lt; mod_top)</a>
<a name="ln886">            lnumt = wp-&gt;w_lines[i].wl_lastlnum + 1;</a>
<a name="ln887">          if (lnumb == MAXLNUM &amp;&amp; wp-&gt;w_lines[i].wl_lnum &gt;= mod_bot) {</a>
<a name="ln888">            lnumb = wp-&gt;w_lines[i].wl_lnum;</a>
<a name="ln889">            // When there is a fold column it might need updating</a>
<a name="ln890">            // in the next line (&quot;J&quot; just above an open fold).</a>
<a name="ln891">            if (compute_foldcolumn(wp, 0) &gt; 0) {</a>
<a name="ln892">              lnumb++;</a>
<a name="ln893">            }</a>
<a name="ln894">          }</a>
<a name="ln895">        }</a>
<a name="ln896"> </a>
<a name="ln897">      (void)hasFoldingWin(wp, mod_top, &amp;mod_top, NULL, true, NULL);</a>
<a name="ln898">      if (mod_top &gt; lnumt) {</a>
<a name="ln899">        mod_top = lnumt;</a>
<a name="ln900">      }</a>
<a name="ln901"> </a>
<a name="ln902">      // Now do the same for the bottom line (one above mod_bot).</a>
<a name="ln903">      mod_bot--;</a>
<a name="ln904">      (void)hasFoldingWin(wp, mod_bot, NULL, &amp;mod_bot, true, NULL);</a>
<a name="ln905">      mod_bot++;</a>
<a name="ln906">      if (mod_bot &lt; lnumb) {</a>
<a name="ln907">        mod_bot = lnumb;</a>
<a name="ln908">      }</a>
<a name="ln909">    }</a>
<a name="ln910"> </a>
<a name="ln911">    /* When a change starts above w_topline and the end is below</a>
<a name="ln912">     * w_topline, start redrawing at w_topline.</a>
<a name="ln913">     * If the end of the change is above w_topline: do like no change was</a>
<a name="ln914">     * made, but redraw the first line to find changes in syntax. */</a>
<a name="ln915">    if (mod_top != 0 &amp;&amp; mod_top &lt; wp-&gt;w_topline) {</a>
<a name="ln916">      if (mod_bot &gt; wp-&gt;w_topline)</a>
<a name="ln917">        mod_top = wp-&gt;w_topline;</a>
<a name="ln918">      else if (syntax_present(wp))</a>
<a name="ln919">        top_end = 1;</a>
<a name="ln920">    }</a>
<a name="ln921"> </a>
<a name="ln922">    /* When line numbers are displayed need to redraw all lines below</a>
<a name="ln923">     * inserted/deleted lines. */</a>
<a name="ln924">    if (mod_top != 0 &amp;&amp; buf-&gt;b_mod_xlines != 0 &amp;&amp; wp-&gt;w_p_nu)</a>
<a name="ln925">      mod_bot = MAXLNUM;</a>
<a name="ln926">  }</a>
<a name="ln927">  wp-&gt;w_redraw_top = 0;  // reset for next time</a>
<a name="ln928">  wp-&gt;w_redraw_bot = 0;</a>
<a name="ln929"> </a>
<a name="ln930">  /*</a>
<a name="ln931">   * When only displaying the lines at the top, set top_end.  Used when</a>
<a name="ln932">   * window has scrolled down for msg_scrolled.</a>
<a name="ln933">   */</a>
<a name="ln934">  if (type == REDRAW_TOP) {</a>
<a name="ln935">    j = 0;</a>
<a name="ln936">    for (i = 0; i &lt; wp-&gt;w_lines_valid; ++i) {</a>
<a name="ln937">      j += wp-&gt;w_lines[i].wl_size;</a>
<a name="ln938">      if (j &gt;= wp-&gt;w_upd_rows) {</a>
<a name="ln939">        top_end = j;</a>
<a name="ln940">        break;</a>
<a name="ln941">      }</a>
<a name="ln942">    }</a>
<a name="ln943">    if (top_end == 0)</a>
<a name="ln944">      /* not found (cannot happen?): redraw everything */</a>
<a name="ln945">      type = NOT_VALID;</a>
<a name="ln946">    else</a>
<a name="ln947">      /* top area defined, the rest is VALID */</a>
<a name="ln948">      type = VALID;</a>
<a name="ln949">  }</a>
<a name="ln950"> </a>
<a name="ln951">  /*</a>
<a name="ln952">   * If there are no changes on the screen that require a complete redraw,</a>
<a name="ln953">   * handle three cases:</a>
<a name="ln954">   * 1: we are off the top of the screen by a few lines: scroll down</a>
<a name="ln955">   * 2: wp-&gt;w_topline is below wp-&gt;w_lines[0].wl_lnum: may scroll up</a>
<a name="ln956">   * 3: wp-&gt;w_topline is wp-&gt;w_lines[0].wl_lnum: find first entry in</a>
<a name="ln957">   *    w_lines[] that needs updating.</a>
<a name="ln958">   */</a>
<a name="ln959">  if ((type == VALID || type == SOME_VALID</a>
<a name="ln960">       || type == INVERTED || type == INVERTED_ALL)</a>
<a name="ln961">      &amp;&amp; !wp-&gt;w_botfill &amp;&amp; !wp-&gt;w_old_botfill</a>
<a name="ln962">      ) {</a>
<a name="ln963">    if (mod_top != 0</a>
<a name="ln964">        &amp;&amp; wp-&gt;w_topline == mod_top</a>
<a name="ln965">        &amp;&amp; (!wp-&gt;w_lines[0].wl_valid</a>
<a name="ln966">            || wp-&gt;w_topline &lt;= wp-&gt;w_lines[0].wl_lnum)) {</a>
<a name="ln967">      // w_topline is the first changed line and window is not scrolled,</a>
<a name="ln968">      // the scrolling from changed lines will be done further down.</a>
<a name="ln969">    } else if (wp-&gt;w_lines[0].wl_valid</a>
<a name="ln970">               &amp;&amp; (wp-&gt;w_topline &lt; wp-&gt;w_lines[0].wl_lnum</a>
<a name="ln971">                   || (wp-&gt;w_topline == wp-&gt;w_lines[0].wl_lnum</a>
<a name="ln972">                       &amp;&amp; wp-&gt;w_topfill &gt; wp-&gt;w_old_topfill)</a>
<a name="ln973">                   )) {</a>
<a name="ln974">      /*</a>
<a name="ln975">       * New topline is above old topline: May scroll down.</a>
<a name="ln976">       */</a>
<a name="ln977">      if (hasAnyFolding(wp)) {</a>
<a name="ln978">        linenr_T ln;</a>
<a name="ln979"> </a>
<a name="ln980">        /* count the number of lines we are off, counting a sequence</a>
<a name="ln981">         * of folded lines as one */</a>
<a name="ln982">        j = 0;</a>
<a name="ln983">        for (ln = wp-&gt;w_topline; ln &lt; wp-&gt;w_lines[0].wl_lnum; ln++) {</a>
<a name="ln984">          j++;</a>
<a name="ln985">          if (j &gt;= wp-&gt;w_grid.Rows - 2) {</a>
<a name="ln986">            break;</a>
<a name="ln987">          }</a>
<a name="ln988">          (void)hasFoldingWin(wp, ln, NULL, &amp;ln, true, NULL);</a>
<a name="ln989">        }</a>
<a name="ln990">      } else</a>
<a name="ln991">        j = wp-&gt;w_lines[0].wl_lnum - wp-&gt;w_topline;</a>
<a name="ln992">      if (j &lt; wp-&gt;w_grid.Rows - 2) {               // not too far off</a>
<a name="ln993">        i = plines_m_win(wp, wp-&gt;w_topline, wp-&gt;w_lines[0].wl_lnum - 1);</a>
<a name="ln994">        /* insert extra lines for previously invisible filler lines */</a>
<a name="ln995">        if (wp-&gt;w_lines[0].wl_lnum != wp-&gt;w_topline)</a>
<a name="ln996">          i += diff_check_fill(wp, wp-&gt;w_lines[0].wl_lnum)</a>
<a name="ln997">               - wp-&gt;w_old_topfill;</a>
<a name="ln998">        if (i != 0 &amp;&amp; i &lt; wp-&gt;w_grid.Rows - 2) {  // less than a screen off</a>
<a name="ln999">          // Try to insert the correct number of lines.</a>
<a name="ln1000">          // If not the last window, delete the lines at the bottom.</a>
<a name="ln1001">          // win_ins_lines may fail when the terminal can't do it.</a>
<a name="ln1002">          win_scroll_lines(wp, 0, i);</a>
<a name="ln1003">          if (wp-&gt;w_lines_valid != 0) {</a>
<a name="ln1004">            // Need to update rows that are new, stop at the</a>
<a name="ln1005">            // first one that scrolled down.</a>
<a name="ln1006">            top_end = i;</a>
<a name="ln1007">            scrolled_down = true;</a>
<a name="ln1008"> </a>
<a name="ln1009">            // Move the entries that were scrolled, disable</a>
<a name="ln1010">            // the entries for the lines to be redrawn.</a>
<a name="ln1011">            if ((wp-&gt;w_lines_valid += j) &gt; wp-&gt;w_grid.Rows) {</a>
<a name="ln1012">              wp-&gt;w_lines_valid = wp-&gt;w_grid.Rows;</a>
<a name="ln1013">            }</a>
<a name="ln1014">            for (idx = wp-&gt;w_lines_valid; idx - j &gt;= 0; idx--) {</a>
<a name="ln1015">              wp-&gt;w_lines[idx] = wp-&gt;w_lines[idx - j];</a>
<a name="ln1016">            }</a>
<a name="ln1017">            while (idx &gt;= 0) {</a>
<a name="ln1018">              wp-&gt;w_lines[idx--].wl_valid = false;</a>
<a name="ln1019">            }</a>
<a name="ln1020">          }</a>
<a name="ln1021">        } else {</a>
<a name="ln1022">          mid_start = 0;  // redraw all lines</a>
<a name="ln1023">        }</a>
<a name="ln1024">      } else {</a>
<a name="ln1025">        mid_start = 0;  // redraw all lines</a>
<a name="ln1026">      }</a>
<a name="ln1027">    } else {</a>
<a name="ln1028">      /*</a>
<a name="ln1029">       * New topline is at or below old topline: May scroll up.</a>
<a name="ln1030">       * When topline didn't change, find first entry in w_lines[] that</a>
<a name="ln1031">       * needs updating.</a>
<a name="ln1032">       */</a>
<a name="ln1033"> </a>
<a name="ln1034">      /* try to find wp-&gt;w_topline in wp-&gt;w_lines[].wl_lnum */</a>
<a name="ln1035">      j = -1;</a>
<a name="ln1036">      row = 0;</a>
<a name="ln1037">      for (i = 0; i &lt; wp-&gt;w_lines_valid; i++) {</a>
<a name="ln1038">        if (wp-&gt;w_lines[i].wl_valid</a>
<a name="ln1039">            &amp;&amp; wp-&gt;w_lines[i].wl_lnum == wp-&gt;w_topline) {</a>
<a name="ln1040">          j = i;</a>
<a name="ln1041">          break;</a>
<a name="ln1042">        }</a>
<a name="ln1043">        row += wp-&gt;w_lines[i].wl_size;</a>
<a name="ln1044">      }</a>
<a name="ln1045">      if (j == -1) {</a>
<a name="ln1046">        /* if wp-&gt;w_topline is not in wp-&gt;w_lines[].wl_lnum redraw all</a>
<a name="ln1047">         * lines */</a>
<a name="ln1048">        mid_start = 0;</a>
<a name="ln1049">      } else {</a>
<a name="ln1050">        /*</a>
<a name="ln1051">         * Try to delete the correct number of lines.</a>
<a name="ln1052">         * wp-&gt;w_topline is at wp-&gt;w_lines[i].wl_lnum.</a>
<a name="ln1053">         */</a>
<a name="ln1054">        /* If the topline didn't change, delete old filler lines,</a>
<a name="ln1055">         * otherwise delete filler lines of the new topline... */</a>
<a name="ln1056">        if (wp-&gt;w_lines[0].wl_lnum == wp-&gt;w_topline)</a>
<a name="ln1057">          row += wp-&gt;w_old_topfill;</a>
<a name="ln1058">        else</a>
<a name="ln1059">          row += diff_check_fill(wp, wp-&gt;w_topline);</a>
<a name="ln1060">        /* ... but don't delete new filler lines. */</a>
<a name="ln1061">        row -= wp-&gt;w_topfill;</a>
<a name="ln1062">        if (row &gt; 0) {</a>
<a name="ln1063">          win_scroll_lines(wp, 0, -row);</a>
<a name="ln1064">          bot_start = wp-&gt;w_grid.Rows - row;</a>
<a name="ln1065">        }</a>
<a name="ln1066">        if ((row == 0 || bot_start &lt; 999) &amp;&amp; wp-&gt;w_lines_valid != 0) {</a>
<a name="ln1067">          /*</a>
<a name="ln1068">           * Skip the lines (below the deleted lines) that are still</a>
<a name="ln1069">           * valid and don't need redrawing.	Copy their info</a>
<a name="ln1070">           * upwards, to compensate for the deleted lines.  Set</a>
<a name="ln1071">           * bot_start to the first row that needs redrawing.</a>
<a name="ln1072">           */</a>
<a name="ln1073">          bot_start = 0;</a>
<a name="ln1074">          idx = 0;</a>
<a name="ln1075">          for (;; ) {</a>
<a name="ln1076">            wp-&gt;w_lines[idx] = wp-&gt;w_lines[j];</a>
<a name="ln1077">            /* stop at line that didn't fit, unless it is still</a>
<a name="ln1078">             * valid (no lines deleted) */</a>
<a name="ln1079">            if (row &gt; 0 &amp;&amp; bot_start + row</a>
<a name="ln1080">                + (int)wp-&gt;w_lines[j].wl_size &gt; wp-&gt;w_grid.Rows) {</a>
<a name="ln1081">              wp-&gt;w_lines_valid = idx + 1;</a>
<a name="ln1082">              break;</a>
<a name="ln1083">            }</a>
<a name="ln1084">            bot_start += wp-&gt;w_lines[idx++].wl_size;</a>
<a name="ln1085"> </a>
<a name="ln1086">            /* stop at the last valid entry in w_lines[].wl_size */</a>
<a name="ln1087">            if (++j &gt;= wp-&gt;w_lines_valid) {</a>
<a name="ln1088">              wp-&gt;w_lines_valid = idx;</a>
<a name="ln1089">              break;</a>
<a name="ln1090">            }</a>
<a name="ln1091">          }</a>
<a name="ln1092">          /* Correct the first entry for filler lines at the top</a>
<a name="ln1093">           * when it won't get updated below. */</a>
<a name="ln1094">          if (wp-&gt;w_p_diff &amp;&amp; bot_start &gt; 0)</a>
<a name="ln1095">            wp-&gt;w_lines[0].wl_size =</a>
<a name="ln1096">              plines_win_nofill(wp, wp-&gt;w_topline, true)</a>
<a name="ln1097">              + wp-&gt;w_topfill;</a>
<a name="ln1098">        }</a>
<a name="ln1099">      }</a>
<a name="ln1100">    }</a>
<a name="ln1101"> </a>
<a name="ln1102">    // When starting redraw in the first line, redraw all lines.</a>
<a name="ln1103">    if (mid_start == 0) {</a>
<a name="ln1104">      mid_end = wp-&gt;w_grid.Rows;</a>
<a name="ln1105">    }</a>
<a name="ln1106">  } else {</a>
<a name="ln1107">    /* Not VALID or INVERTED: redraw all lines. */</a>
<a name="ln1108">    mid_start = 0;</a>
<a name="ln1109">    mid_end = wp-&gt;w_grid.Rows;</a>
<a name="ln1110">  }</a>
<a name="ln1111"> </a>
<a name="ln1112">  if (type == SOME_VALID) {</a>
<a name="ln1113">    /* SOME_VALID: redraw all lines. */</a>
<a name="ln1114">    mid_start = 0;</a>
<a name="ln1115">    mid_end = wp-&gt;w_grid.Rows;</a>
<a name="ln1116">    type = NOT_VALID;</a>
<a name="ln1117">  }</a>
<a name="ln1118"> </a>
<a name="ln1119">  /* check if we are updating or removing the inverted part */</a>
<a name="ln1120">  if ((VIsual_active &amp;&amp; buf == curwin-&gt;w_buffer)</a>
<a name="ln1121">      || (wp-&gt;w_old_cursor_lnum != 0 &amp;&amp; type != NOT_VALID)) {</a>
<a name="ln1122">    linenr_T from, to;</a>
<a name="ln1123"> </a>
<a name="ln1124">    if (VIsual_active) {</a>
<a name="ln1125">      if (VIsual_mode != wp-&gt;w_old_visual_mode || type == INVERTED_ALL) {</a>
<a name="ln1126">        // If the type of Visual selection changed, redraw the whole</a>
<a name="ln1127">        // selection.  Also when the ownership of the X selection is</a>
<a name="ln1128">        // gained or lost.</a>
<a name="ln1129">        if (curwin-&gt;w_cursor.lnum &lt; VIsual.lnum) {</a>
<a name="ln1130">          from = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1131">          to = VIsual.lnum;</a>
<a name="ln1132">        } else {</a>
<a name="ln1133">          from = VIsual.lnum;</a>
<a name="ln1134">          to = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1135">        }</a>
<a name="ln1136">        /* redraw more when the cursor moved as well */</a>
<a name="ln1137">        if (wp-&gt;w_old_cursor_lnum &lt; from)</a>
<a name="ln1138">          from = wp-&gt;w_old_cursor_lnum;</a>
<a name="ln1139">        if (wp-&gt;w_old_cursor_lnum &gt; to)</a>
<a name="ln1140">          to = wp-&gt;w_old_cursor_lnum;</a>
<a name="ln1141">        if (wp-&gt;w_old_visual_lnum &lt; from)</a>
<a name="ln1142">          from = wp-&gt;w_old_visual_lnum;</a>
<a name="ln1143">        if (wp-&gt;w_old_visual_lnum &gt; to)</a>
<a name="ln1144">          to = wp-&gt;w_old_visual_lnum;</a>
<a name="ln1145">      } else {</a>
<a name="ln1146">        /*</a>
<a name="ln1147">         * Find the line numbers that need to be updated: The lines</a>
<a name="ln1148">         * between the old cursor position and the current cursor</a>
<a name="ln1149">         * position.  Also check if the Visual position changed.</a>
<a name="ln1150">         */</a>
<a name="ln1151">        if (curwin-&gt;w_cursor.lnum &lt; wp-&gt;w_old_cursor_lnum) {</a>
<a name="ln1152">          from = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1153">          to = wp-&gt;w_old_cursor_lnum;</a>
<a name="ln1154">        } else {</a>
<a name="ln1155">          from = wp-&gt;w_old_cursor_lnum;</a>
<a name="ln1156">          to = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1157">          if (from == 0)                /* Visual mode just started */</a>
<a name="ln1158">            from = to;</a>
<a name="ln1159">        }</a>
<a name="ln1160"> </a>
<a name="ln1161">        if (VIsual.lnum != wp-&gt;w_old_visual_lnum</a>
<a name="ln1162">            || VIsual.col != wp-&gt;w_old_visual_col) {</a>
<a name="ln1163">          if (wp-&gt;w_old_visual_lnum &lt; from</a>
<a name="ln1164">              &amp;&amp; wp-&gt;w_old_visual_lnum != 0)</a>
<a name="ln1165">            from = wp-&gt;w_old_visual_lnum;</a>
<a name="ln1166">          if (wp-&gt;w_old_visual_lnum &gt; to)</a>
<a name="ln1167">            to = wp-&gt;w_old_visual_lnum;</a>
<a name="ln1168">          if (VIsual.lnum &lt; from)</a>
<a name="ln1169">            from = VIsual.lnum;</a>
<a name="ln1170">          if (VIsual.lnum &gt; to)</a>
<a name="ln1171">            to = VIsual.lnum;</a>
<a name="ln1172">        }</a>
<a name="ln1173">      }</a>
<a name="ln1174"> </a>
<a name="ln1175">      /*</a>
<a name="ln1176">       * If in block mode and changed column or curwin-&gt;w_curswant:</a>
<a name="ln1177">       * update all lines.</a>
<a name="ln1178">       * First compute the actual start and end column.</a>
<a name="ln1179">       */</a>
<a name="ln1180">      if (VIsual_mode == Ctrl_V) {</a>
<a name="ln1181">        colnr_T fromc, toc;</a>
<a name="ln1182">        int save_ve_flags = ve_flags;</a>
<a name="ln1183"> </a>
<a name="ln1184">        if (curwin-&gt;w_p_lbr)</a>
<a name="ln1185">          ve_flags = VE_ALL;</a>
<a name="ln1186"> </a>
<a name="ln1187">        getvcols(wp, &amp;VIsual, &amp;curwin-&gt;w_cursor, &amp;fromc, &amp;toc);</a>
<a name="ln1188">        ve_flags = save_ve_flags;</a>
<a name="ln1189">        toc++;</a>
<a name="ln1190">        // Highlight to the end of the line, unless 'virtualedit' has</a>
<a name="ln1191">        // &quot;block&quot;.</a>
<a name="ln1192">        if (curwin-&gt;w_curswant == MAXCOL &amp;&amp; !(ve_flags &amp; VE_BLOCK)) {</a>
<a name="ln1193">          toc = MAXCOL;</a>
<a name="ln1194">        }</a>
<a name="ln1195"> </a>
<a name="ln1196">        if (fromc != wp-&gt;w_old_cursor_fcol</a>
<a name="ln1197">            || toc != wp-&gt;w_old_cursor_lcol) {</a>
<a name="ln1198">          if (from &gt; VIsual.lnum)</a>
<a name="ln1199">            from = VIsual.lnum;</a>
<a name="ln1200">          if (to &lt; VIsual.lnum)</a>
<a name="ln1201">            to = VIsual.lnum;</a>
<a name="ln1202">        }</a>
<a name="ln1203">        wp-&gt;w_old_cursor_fcol = fromc;</a>
<a name="ln1204">        wp-&gt;w_old_cursor_lcol = toc;</a>
<a name="ln1205">      }</a>
<a name="ln1206">    } else {</a>
<a name="ln1207">      /* Use the line numbers of the old Visual area. */</a>
<a name="ln1208">      if (wp-&gt;w_old_cursor_lnum &lt; wp-&gt;w_old_visual_lnum) {</a>
<a name="ln1209">        from = wp-&gt;w_old_cursor_lnum;</a>
<a name="ln1210">        to = wp-&gt;w_old_visual_lnum;</a>
<a name="ln1211">      } else {</a>
<a name="ln1212">        from = wp-&gt;w_old_visual_lnum;</a>
<a name="ln1213">        to = wp-&gt;w_old_cursor_lnum;</a>
<a name="ln1214">      }</a>
<a name="ln1215">    }</a>
<a name="ln1216"> </a>
<a name="ln1217">    /*</a>
<a name="ln1218">     * There is no need to update lines above the top of the window.</a>
<a name="ln1219">     */</a>
<a name="ln1220">    if (from &lt; wp-&gt;w_topline)</a>
<a name="ln1221">      from = wp-&gt;w_topline;</a>
<a name="ln1222"> </a>
<a name="ln1223">    /*</a>
<a name="ln1224">     * If we know the value of w_botline, use it to restrict the update to</a>
<a name="ln1225">     * the lines that are visible in the window.</a>
<a name="ln1226">     */</a>
<a name="ln1227">    if (wp-&gt;w_valid &amp; VALID_BOTLINE) {</a>
<a name="ln1228">      if (from &gt;= wp-&gt;w_botline)</a>
<a name="ln1229">        from = wp-&gt;w_botline - 1;</a>
<a name="ln1230">      if (to &gt;= wp-&gt;w_botline)</a>
<a name="ln1231">        to = wp-&gt;w_botline - 1;</a>
<a name="ln1232">    }</a>
<a name="ln1233"> </a>
<a name="ln1234">    /*</a>
<a name="ln1235">     * Find the minimal part to be updated.</a>
<a name="ln1236">     * Watch out for scrolling that made entries in w_lines[] invalid.</a>
<a name="ln1237">     * E.g., CTRL-U makes the first half of w_lines[] invalid and sets</a>
<a name="ln1238">     * top_end; need to redraw from top_end to the &quot;to&quot; line.</a>
<a name="ln1239">     * A middle mouse click with a Visual selection may change the text</a>
<a name="ln1240">     * above the Visual area and reset wl_valid, do count these for</a>
<a name="ln1241">     * mid_end (in srow).</a>
<a name="ln1242">     */</a>
<a name="ln1243">    if (mid_start &gt; 0) {</a>
<a name="ln1244">      lnum = wp-&gt;w_topline;</a>
<a name="ln1245">      idx = 0;</a>
<a name="ln1246">      srow = 0;</a>
<a name="ln1247">      if (scrolled_down)</a>
<a name="ln1248">        mid_start = top_end;</a>
<a name="ln1249">      else</a>
<a name="ln1250">        mid_start = 0;</a>
<a name="ln1251">      while (lnum &lt; from &amp;&amp; idx &lt; wp-&gt;w_lines_valid) {          /* find start */</a>
<a name="ln1252">        if (wp-&gt;w_lines[idx].wl_valid)</a>
<a name="ln1253">          mid_start += wp-&gt;w_lines[idx].wl_size;</a>
<a name="ln1254">        else if (!scrolled_down)</a>
<a name="ln1255">          srow += wp-&gt;w_lines[idx].wl_size;</a>
<a name="ln1256">        ++idx;</a>
<a name="ln1257">        if (idx &lt; wp-&gt;w_lines_valid &amp;&amp; wp-&gt;w_lines[idx].wl_valid)</a>
<a name="ln1258">          lnum = wp-&gt;w_lines[idx].wl_lnum;</a>
<a name="ln1259">        else</a>
<a name="ln1260">          ++lnum;</a>
<a name="ln1261">      }</a>
<a name="ln1262">      srow += mid_start;</a>
<a name="ln1263">      mid_end = wp-&gt;w_grid.Rows;</a>
<a name="ln1264">      for (; idx &lt; wp-&gt;w_lines_valid; idx++) {                  // find end</a>
<a name="ln1265">        if (wp-&gt;w_lines[idx].wl_valid</a>
<a name="ln1266">            &amp;&amp; wp-&gt;w_lines[idx].wl_lnum &gt;= to + 1) {</a>
<a name="ln1267">          /* Only update until first row of this line */</a>
<a name="ln1268">          mid_end = srow;</a>
<a name="ln1269">          break;</a>
<a name="ln1270">        }</a>
<a name="ln1271">        srow += wp-&gt;w_lines[idx].wl_size;</a>
<a name="ln1272">      }</a>
<a name="ln1273">    }</a>
<a name="ln1274">  }</a>
<a name="ln1275"> </a>
<a name="ln1276">  if (VIsual_active &amp;&amp; buf == curwin-&gt;w_buffer) {</a>
<a name="ln1277">    wp-&gt;w_old_visual_mode = VIsual_mode;</a>
<a name="ln1278">    wp-&gt;w_old_cursor_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1279">    wp-&gt;w_old_visual_lnum = VIsual.lnum;</a>
<a name="ln1280">    wp-&gt;w_old_visual_col = VIsual.col;</a>
<a name="ln1281">    wp-&gt;w_old_curswant = curwin-&gt;w_curswant;</a>
<a name="ln1282">  } else {</a>
<a name="ln1283">    wp-&gt;w_old_visual_mode = 0;</a>
<a name="ln1284">    wp-&gt;w_old_cursor_lnum = 0;</a>
<a name="ln1285">    wp-&gt;w_old_visual_lnum = 0;</a>
<a name="ln1286">    wp-&gt;w_old_visual_col = 0;</a>
<a name="ln1287">  }</a>
<a name="ln1288"> </a>
<a name="ln1289">  /* reset got_int, otherwise regexp won't work */</a>
<a name="ln1290">  save_got_int = got_int;</a>
<a name="ln1291">  got_int = 0;</a>
<a name="ln1292">  // Set the time limit to 'redrawtime'.</a>
<a name="ln1293">  proftime_T syntax_tm = profile_setlimit(p_rdt);</a>
<a name="ln1294">  syn_set_timeout(&amp;syntax_tm);</a>
<a name="ln1295"> </a>
<a name="ln1296">  /*</a>
<a name="ln1297">   * Update all the window rows.</a>
<a name="ln1298">   */</a>
<a name="ln1299">  idx = 0;              /* first entry in w_lines[].wl_size */</a>
<a name="ln1300">  row = 0;</a>
<a name="ln1301">  srow = 0;</a>
<a name="ln1302">  lnum = wp-&gt;w_topline;  // first line shown in window</a>
<a name="ln1303"> </a>
<a name="ln1304">  decor_redraw_reset(buf, &amp;decor_state);</a>
<a name="ln1305"> </a>
<a name="ln1306">  Providers line_providers;</a>
<a name="ln1307">  kvi_init(line_providers);</a>
<a name="ln1308"> </a>
<a name="ln1309">  linenr_T knownmax = ((wp-&gt;w_valid &amp; VALID_BOTLINE)</a>
<a name="ln1310">                       ? wp-&gt;w_botline</a>
<a name="ln1311">                       : (wp-&gt;w_topline + wp-&gt;w_height_inner));</a>
<a name="ln1312"> </a>
<a name="ln1313">  for (size_t k = 0; k &lt; kv_size(*providers); k++) {</a>
<a name="ln1314">    DecorProvider *p = kv_A(*providers, k);</a>
<a name="ln1315">    if (p &amp;&amp; p-&gt;redraw_win != LUA_NOREF) {</a>
<a name="ln1316">      FIXED_TEMP_ARRAY(args, 4);</a>
<a name="ln1317">      args.items[0] = WINDOW_OBJ(wp-&gt;handle);</a>
<a name="ln1318">      args.items[1] = BUFFER_OBJ(buf-&gt;handle);</a>
<a name="ln1319">      // TODO(bfredl): we are not using this, but should be first drawn line?</a>
<a name="ln1320">      args.items[2] = INTEGER_OBJ(wp-&gt;w_topline-1);</a>
<a name="ln1321">      args.items[3] = INTEGER_OBJ(knownmax);</a>
<a name="ln1322">      if (provider_invoke(p-&gt;ns_id, &quot;win&quot;, p-&gt;redraw_win, args, true)) {</a>
<a name="ln1323">        kvi_push(line_providers, p);</a>
<a name="ln1324">      }</a>
<a name="ln1325">    }</a>
<a name="ln1326">  }</a>
<a name="ln1327"> </a>
<a name="ln1328">  win_check_ns_hl(wp);</a>
<a name="ln1329"> </a>
<a name="ln1330"> </a>
<a name="ln1331">  for (;; ) {</a>
<a name="ln1332">    /* stop updating when reached the end of the window (check for _past_</a>
<a name="ln1333">     * the end of the window is at the end of the loop) */</a>
<a name="ln1334">    if (row == wp-&gt;w_grid.Rows) {</a>
<a name="ln1335">      didline = true;</a>
<a name="ln1336">      break;</a>
<a name="ln1337">    }</a>
<a name="ln1338"> </a>
<a name="ln1339">    /* stop updating when hit the end of the file */</a>
<a name="ln1340">    if (lnum &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1341">      eof = TRUE;</a>
<a name="ln1342">      break;</a>
<a name="ln1343">    }</a>
<a name="ln1344"> </a>
<a name="ln1345">    /* Remember the starting row of the line that is going to be dealt</a>
<a name="ln1346">     * with.  It is used further down when the line doesn't fit. */</a>
<a name="ln1347">    srow = row;</a>
<a name="ln1348"> </a>
<a name="ln1349">    // Update a line when it is in an area that needs updating, when it</a>
<a name="ln1350">    // has changes or w_lines[idx] is invalid.</a>
<a name="ln1351">    // &quot;bot_start&quot; may be halfway a wrapped line after using</a>
<a name="ln1352">    // win_scroll_lines(), check if the current line includes it.</a>
<a name="ln1353">    // When syntax folding is being used, the saved syntax states will</a>
<a name="ln1354">    // already have been updated, we can't see where the syntax state is</a>
<a name="ln1355">    // the same again, just update until the end of the window.</a>
<a name="ln1356">    if (row &lt; top_end</a>
<a name="ln1357">        || (row &gt;= mid_start &amp;&amp; row &lt; mid_end)</a>
<a name="ln1358">        || top_to_mod</a>
<a name="ln1359">        || idx &gt;= wp-&gt;w_lines_valid</a>
<a name="ln1360">        || (row + wp-&gt;w_lines[idx].wl_size &gt; bot_start)</a>
<a name="ln1361">        || (mod_top != 0</a>
<a name="ln1362">            &amp;&amp; (lnum == mod_top</a>
<a name="ln1363">                || (lnum &gt;= mod_top</a>
<a name="ln1364">                    &amp;&amp; (lnum &lt; mod_bot</a>
<a name="ln1365">                        || did_update == DID_FOLD</a>
<a name="ln1366">                        || (did_update == DID_LINE</a>
<a name="ln1367">                            &amp;&amp; syntax_present(wp)</a>
<a name="ln1368">                            &amp;&amp; ((foldmethodIsSyntax(wp)</a>
<a name="ln1369">                                 &amp;&amp; hasAnyFolding(wp))</a>
<a name="ln1370">                                || syntax_check_changed(lnum)))</a>
<a name="ln1371">                        // match in fixed position might need redraw</a>
<a name="ln1372">                        // if lines were inserted or deleted</a>
<a name="ln1373">                        || (wp-&gt;w_match_head != NULL</a>
<a name="ln1374">                            &amp;&amp; buf-&gt;b_mod_xlines != 0)))))) {</a>
<a name="ln1375">      if (lnum == mod_top) {</a>
<a name="ln1376">        top_to_mod = false;</a>
<a name="ln1377">      }</a>
<a name="ln1378"> </a>
<a name="ln1379">      /*</a>
<a name="ln1380">       * When at start of changed lines: May scroll following lines</a>
<a name="ln1381">       * up or down to minimize redrawing.</a>
<a name="ln1382">       * Don't do this when the change continues until the end.</a>
<a name="ln1383">       * Don't scroll when dollar_vcol &gt;= 0, keep the &quot;$&quot;.</a>
<a name="ln1384">       */</a>
<a name="ln1385">      if (lnum == mod_top</a>
<a name="ln1386">          &amp;&amp; mod_bot != MAXLNUM</a>
<a name="ln1387">          &amp;&amp; !(dollar_vcol &gt;= 0 &amp;&amp; mod_bot == mod_top + 1)) {</a>
<a name="ln1388">        int old_rows = 0;</a>
<a name="ln1389">        int new_rows = 0;</a>
<a name="ln1390">        int xtra_rows;</a>
<a name="ln1391">        linenr_T l;</a>
<a name="ln1392"> </a>
<a name="ln1393">        /* Count the old number of window rows, using w_lines[], which</a>
<a name="ln1394">         * should still contain the sizes for the lines as they are</a>
<a name="ln1395">         * currently displayed. */</a>
<a name="ln1396">        for (i = idx; i &lt; wp-&gt;w_lines_valid; ++i) {</a>
<a name="ln1397">          /* Only valid lines have a meaningful wl_lnum.  Invalid</a>
<a name="ln1398">           * lines are part of the changed area. */</a>
<a name="ln1399">          if (wp-&gt;w_lines[i].wl_valid</a>
<a name="ln1400">              &amp;&amp; wp-&gt;w_lines[i].wl_lnum == mod_bot)</a>
<a name="ln1401">            break;</a>
<a name="ln1402">          old_rows += wp-&gt;w_lines[i].wl_size;</a>
<a name="ln1403">          if (wp-&gt;w_lines[i].wl_valid</a>
<a name="ln1404">              &amp;&amp; wp-&gt;w_lines[i].wl_lastlnum + 1 == mod_bot) {</a>
<a name="ln1405">            /* Must have found the last valid entry above mod_bot.</a>
<a name="ln1406">             * Add following invalid entries. */</a>
<a name="ln1407">            ++i;</a>
<a name="ln1408">            while (i &lt; wp-&gt;w_lines_valid</a>
<a name="ln1409">                   &amp;&amp; !wp-&gt;w_lines[i].wl_valid)</a>
<a name="ln1410">              old_rows += wp-&gt;w_lines[i++].wl_size;</a>
<a name="ln1411">            break;</a>
<a name="ln1412">          }</a>
<a name="ln1413">        }</a>
<a name="ln1414"> </a>
<a name="ln1415">        if (i &gt;= wp-&gt;w_lines_valid) {</a>
<a name="ln1416">          /* We can't find a valid line below the changed lines,</a>
<a name="ln1417">           * need to redraw until the end of the window.</a>
<a name="ln1418">           * Inserting/deleting lines has no use. */</a>
<a name="ln1419">          bot_start = 0;</a>
<a name="ln1420">        } else {</a>
<a name="ln1421">          /* Able to count old number of rows: Count new window</a>
<a name="ln1422">           * rows, and may insert/delete lines */</a>
<a name="ln1423">          j = idx;</a>
<a name="ln1424">          for (l = lnum; l &lt; mod_bot; l++) {</a>
<a name="ln1425">            if (hasFoldingWin(wp, l, NULL, &amp;l, true, NULL)) {</a>
<a name="ln1426">              new_rows++;</a>
<a name="ln1427">            } else if (l == wp-&gt;w_topline) {</a>
<a name="ln1428">              new_rows += plines_win_nofill(wp, l, true) + wp-&gt;w_topfill;</a>
<a name="ln1429">            } else {</a>
<a name="ln1430">              new_rows += plines_win(wp, l, true);</a>
<a name="ln1431">            }</a>
<a name="ln1432">            j++;</a>
<a name="ln1433">            if (new_rows &gt; wp-&gt;w_grid.Rows - row - 2) {</a>
<a name="ln1434">              // it's getting too much, must redraw the rest</a>
<a name="ln1435">              new_rows = 9999;</a>
<a name="ln1436">              break;</a>
<a name="ln1437">            }</a>
<a name="ln1438">          }</a>
<a name="ln1439">          xtra_rows = new_rows - old_rows;</a>
<a name="ln1440">          if (xtra_rows &lt; 0) {</a>
<a name="ln1441">            /* May scroll text up.  If there is not enough</a>
<a name="ln1442">             * remaining text or scrolling fails, must redraw the</a>
<a name="ln1443">             * rest.  If scrolling works, must redraw the text</a>
<a name="ln1444">             * below the scrolled text. */</a>
<a name="ln1445">            if (row - xtra_rows &gt;= wp-&gt;w_grid.Rows - 2) {</a>
<a name="ln1446">              mod_bot = MAXLNUM;</a>
<a name="ln1447">            } else {</a>
<a name="ln1448">              win_scroll_lines(wp, row, xtra_rows);</a>
<a name="ln1449">              bot_start = wp-&gt;w_grid.Rows + xtra_rows;</a>
<a name="ln1450">            }</a>
<a name="ln1451">          } else if (xtra_rows &gt; 0) {</a>
<a name="ln1452">            /* May scroll text down.  If there is not enough</a>
<a name="ln1453">             * remaining text of scrolling fails, must redraw the</a>
<a name="ln1454">             * rest. */</a>
<a name="ln1455">            if (row + xtra_rows &gt;= wp-&gt;w_grid.Rows - 2) {</a>
<a name="ln1456">              mod_bot = MAXLNUM;</a>
<a name="ln1457">            } else {</a>
<a name="ln1458">              win_scroll_lines(wp, row + old_rows, xtra_rows);</a>
<a name="ln1459">              if (top_end &gt; row + old_rows) {</a>
<a name="ln1460">                // Scrolled the part at the top that requires</a>
<a name="ln1461">                // updating down.</a>
<a name="ln1462">                top_end += xtra_rows;</a>
<a name="ln1463">              }</a>
<a name="ln1464">            }</a>
<a name="ln1465">          }</a>
<a name="ln1466"> </a>
<a name="ln1467">          /* When not updating the rest, may need to move w_lines[]</a>
<a name="ln1468">           * entries. */</a>
<a name="ln1469">          if (mod_bot != MAXLNUM &amp;&amp; i != j) {</a>
<a name="ln1470">            if (j &lt; i) {</a>
<a name="ln1471">              int x = row + new_rows;</a>
<a name="ln1472"> </a>
<a name="ln1473">              /* move entries in w_lines[] upwards */</a>
<a name="ln1474">              for (;; ) {</a>
<a name="ln1475">                /* stop at last valid entry in w_lines[] */</a>
<a name="ln1476">                if (i &gt;= wp-&gt;w_lines_valid) {</a>
<a name="ln1477">                  wp-&gt;w_lines_valid = j;</a>
<a name="ln1478">                  break;</a>
<a name="ln1479">                }</a>
<a name="ln1480">                wp-&gt;w_lines[j] = wp-&gt;w_lines[i];</a>
<a name="ln1481">                /* stop at a line that won't fit */</a>
<a name="ln1482">                if (x + (int)wp-&gt;w_lines[j].wl_size</a>
<a name="ln1483">                    &gt; wp-&gt;w_grid.Rows) {</a>
<a name="ln1484">                  wp-&gt;w_lines_valid = j + 1;</a>
<a name="ln1485">                  break;</a>
<a name="ln1486">                }</a>
<a name="ln1487">                x += wp-&gt;w_lines[j++].wl_size;</a>
<a name="ln1488">                ++i;</a>
<a name="ln1489">              }</a>
<a name="ln1490">              if (bot_start &gt; x)</a>
<a name="ln1491">                bot_start = x;</a>
<a name="ln1492">            } else {       /* j &gt; i */</a>
<a name="ln1493">                             /* move entries in w_lines[] downwards */</a>
<a name="ln1494">              j -= i;</a>
<a name="ln1495">              wp-&gt;w_lines_valid += j;</a>
<a name="ln1496">              if (wp-&gt;w_lines_valid &gt; wp-&gt;w_grid.Rows) {</a>
<a name="ln1497">                wp-&gt;w_lines_valid = wp-&gt;w_grid.Rows;</a>
<a name="ln1498">              }</a>
<a name="ln1499">              for (i = wp-&gt;w_lines_valid; i - j &gt;= idx; i--) {</a>
<a name="ln1500">                wp-&gt;w_lines[i] = wp-&gt;w_lines[i - j];</a>
<a name="ln1501">              }</a>
<a name="ln1502"> </a>
<a name="ln1503">              /* The w_lines[] entries for inserted lines are</a>
<a name="ln1504">               * now invalid, but wl_size may be used above.</a>
<a name="ln1505">               * Reset to zero. */</a>
<a name="ln1506">              while (i &gt;= idx) {</a>
<a name="ln1507">                wp-&gt;w_lines[i].wl_size = 0;</a>
<a name="ln1508">                wp-&gt;w_lines[i--].wl_valid = FALSE;</a>
<a name="ln1509">              }</a>
<a name="ln1510">            }</a>
<a name="ln1511">          }</a>
<a name="ln1512">        }</a>
<a name="ln1513">      }</a>
<a name="ln1514"> </a>
<a name="ln1515">      /*</a>
<a name="ln1516">       * When lines are folded, display one line for all of them.</a>
<a name="ln1517">       * Otherwise, display normally (can be several display lines when</a>
<a name="ln1518">       * 'wrap' is on).</a>
<a name="ln1519">       */</a>
<a name="ln1520">      foldinfo_T foldinfo = fold_info(wp, lnum);</a>
<a name="ln1521"> </a>
<a name="ln1522">      if (foldinfo.fi_lines == 0</a>
<a name="ln1523">          &amp;&amp; idx &lt; wp-&gt;w_lines_valid</a>
<a name="ln1524">          &amp;&amp; wp-&gt;w_lines[idx].wl_valid</a>
<a name="ln1525">          &amp;&amp; wp-&gt;w_lines[idx].wl_lnum == lnum</a>
<a name="ln1526">          &amp;&amp; lnum &gt; wp-&gt;w_topline</a>
<a name="ln1527">          &amp;&amp; !(dy_flags &amp; (DY_LASTLINE | DY_TRUNCATE))</a>
<a name="ln1528">          &amp;&amp; srow + wp-&gt;w_lines[idx].wl_size &gt; wp-&gt;w_grid.Rows</a>
<a name="ln1529">          &amp;&amp; diff_check_fill(wp, lnum) == 0</a>
<a name="ln1530">          ) {</a>
<a name="ln1531">        // This line is not going to fit.  Don't draw anything here,</a>
<a name="ln1532">        // will draw &quot;@  &quot; lines below.</a>
<a name="ln1533">        row = wp-&gt;w_grid.Rows + 1;</a>
<a name="ln1534">      } else {</a>
<a name="ln1535">        prepare_search_hl(wp, lnum);</a>
<a name="ln1536">        /* Let the syntax stuff know we skipped a few lines. */</a>
<a name="ln1537">        if (syntax_last_parsed != 0 &amp;&amp; syntax_last_parsed + 1 &lt; lnum</a>
<a name="ln1538">            &amp;&amp; syntax_present(wp))</a>
<a name="ln1539">          syntax_end_parsing(syntax_last_parsed + 1);</a>
<a name="ln1540"> </a>
<a name="ln1541">        // Display one line</a>
<a name="ln1542">        row = win_line(wp, lnum, srow,</a>
<a name="ln1543">                       foldinfo.fi_lines ? srow : wp-&gt;w_grid.Rows,</a>
<a name="ln1544">                       mod_top == 0, false, foldinfo, &amp;line_providers);</a>
<a name="ln1545"> </a>
<a name="ln1546">        wp-&gt;w_lines[idx].wl_folded = foldinfo.fi_lines != 0;</a>
<a name="ln1547">        wp-&gt;w_lines[idx].wl_lastlnum = lnum;</a>
<a name="ln1548">        did_update = DID_LINE;</a>
<a name="ln1549"> </a>
<a name="ln1550">        if (foldinfo.fi_lines &gt; 0) {</a>
<a name="ln1551">          did_update = DID_FOLD;</a>
<a name="ln1552">          foldinfo.fi_lines--;</a>
<a name="ln1553">          wp-&gt;w_lines[idx].wl_lastlnum = lnum + foldinfo.fi_lines;</a>
<a name="ln1554">        }</a>
<a name="ln1555"> </a>
<a name="ln1556">        syntax_last_parsed = lnum;</a>
<a name="ln1557">      }</a>
<a name="ln1558"> </a>
<a name="ln1559">      wp-&gt;w_lines[idx].wl_lnum = lnum;</a>
<a name="ln1560">      wp-&gt;w_lines[idx].wl_valid = true;</a>
<a name="ln1561"> </a>
<a name="ln1562">      if (row &gt; wp-&gt;w_grid.Rows) {         // past end of grid</a>
<a name="ln1563">        // we may need the size of that too long line later on</a>
<a name="ln1564">        if (dollar_vcol == -1) {</a>
<a name="ln1565">          wp-&gt;w_lines[idx].wl_size = plines_win(wp, lnum, true);</a>
<a name="ln1566">        }</a>
<a name="ln1567">        idx++;</a>
<a name="ln1568">        break;</a>
<a name="ln1569">      }</a>
<a name="ln1570">      if (dollar_vcol == -1) {</a>
<a name="ln1571">        wp-&gt;w_lines[idx].wl_size = row - srow;</a>
<a name="ln1572">      }</a>
<a name="ln1573">      idx++;</a>
<a name="ln1574">      lnum += foldinfo.fi_lines + 1;</a>
<a name="ln1575">    } else {</a>
<a name="ln1576">      if (wp-&gt;w_p_rnu) {</a>
<a name="ln1577">        // 'relativenumber' set: The text doesn't need to be drawn, but</a>
<a name="ln1578">        // the number column nearly always does.</a>
<a name="ln1579">        foldinfo_T info = fold_info(wp, lnum);</a>
<a name="ln1580">        (void)win_line(wp, lnum, srow, wp-&gt;w_grid.Rows, true, true,</a>
<a name="ln1581">                       info, &amp;line_providers);</a>
<a name="ln1582">      }</a>
<a name="ln1583"> </a>
<a name="ln1584">      // This line does not need to be drawn, advance to the next one.</a>
<a name="ln1585">      row += wp-&gt;w_lines[idx++].wl_size;</a>
<a name="ln1586">      if (row &gt; wp-&gt;w_grid.Rows) {  // past end of screen</a>
<a name="ln1587">        break;</a>
<a name="ln1588">      }</a>
<a name="ln1589">      lnum = wp-&gt;w_lines[idx - 1].wl_lastlnum + 1;</a>
<a name="ln1590">      did_update = DID_NONE;</a>
<a name="ln1591">    }</a>
<a name="ln1592"> </a>
<a name="ln1593">    if (lnum &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1594">      eof = TRUE;</a>
<a name="ln1595">      break;</a>
<a name="ln1596">    }</a>
<a name="ln1597">  }</a>
<a name="ln1598">  /*</a>
<a name="ln1599">   * End of loop over all window lines.</a>
<a name="ln1600">   */</a>
<a name="ln1601"> </a>
<a name="ln1602"> </a>
<a name="ln1603">  if (idx &gt; wp-&gt;w_lines_valid)</a>
<a name="ln1604">    wp-&gt;w_lines_valid = idx;</a>
<a name="ln1605"> </a>
<a name="ln1606">  /*</a>
<a name="ln1607">   * Let the syntax stuff know we stop parsing here.</a>
<a name="ln1608">   */</a>
<a name="ln1609">  if (syntax_last_parsed != 0 &amp;&amp; syntax_present(wp))</a>
<a name="ln1610">    syntax_end_parsing(syntax_last_parsed + 1);</a>
<a name="ln1611"> </a>
<a name="ln1612">  /*</a>
<a name="ln1613">   * If we didn't hit the end of the file, and we didn't finish the last</a>
<a name="ln1614">   * line we were working on, then the line didn't fit.</a>
<a name="ln1615">   */</a>
<a name="ln1616">  wp-&gt;w_empty_rows = 0;</a>
<a name="ln1617">  wp-&gt;w_filler_rows = 0;</a>
<a name="ln1618">  if (!eof &amp;&amp; !didline) {</a>
<a name="ln1619">    int at_attr = hl_combine_attr(wp-&gt;w_hl_attr_normal,</a>
<a name="ln1620">                                  win_hl_attr(wp, HLF_AT));</a>
<a name="ln1621">    if (lnum == wp-&gt;w_topline) {</a>
<a name="ln1622">      /*</a>
<a name="ln1623">       * Single line that does not fit!</a>
<a name="ln1624">       * Don't overwrite it, it can be edited.</a>
<a name="ln1625">       */</a>
<a name="ln1626">      wp-&gt;w_botline = lnum + 1;</a>
<a name="ln1627">    } else if (diff_check_fill(wp, lnum) &gt;= wp-&gt;w_grid.Rows - srow) {</a>
<a name="ln1628">      // Window ends in filler lines.</a>
<a name="ln1629">      wp-&gt;w_botline = lnum;</a>
<a name="ln1630">      wp-&gt;w_filler_rows = wp-&gt;w_grid.Rows - srow;</a>
<a name="ln1631">    } else if (dy_flags &amp; DY_TRUNCATE) {      // 'display' has &quot;truncate&quot;</a>
<a name="ln1632">      int scr_row = wp-&gt;w_grid.Rows - 1;</a>
<a name="ln1633"> </a>
<a name="ln1634">      // Last line isn't finished: Display &quot;@@@&quot; in the last screen line.</a>
<a name="ln1635">      grid_puts_len(&amp;wp-&gt;w_grid, (char_u *)&quot;@@&quot;, 2, scr_row, 0, at_attr);</a>
<a name="ln1636"> </a>
<a name="ln1637">      grid_fill(&amp;wp-&gt;w_grid, scr_row, scr_row + 1, 2, wp-&gt;w_grid.Columns,</a>
<a name="ln1638">                '@', ' ', at_attr);</a>
<a name="ln1639">      set_empty_rows(wp, srow);</a>
<a name="ln1640">      wp-&gt;w_botline = lnum;</a>
<a name="ln1641">    } else if (dy_flags &amp; DY_LASTLINE) {      // 'display' has &quot;lastline&quot;</a>
<a name="ln1642">      // Last line isn't finished: Display &quot;@@@&quot; at the end.</a>
<a name="ln1643">      grid_fill(&amp;wp-&gt;w_grid, wp-&gt;w_grid.Rows - 1, wp-&gt;w_grid.Rows,</a>
<a name="ln1644">                wp-&gt;w_grid.Columns - 3, wp-&gt;w_grid.Columns, '@', '@', at_attr);</a>
<a name="ln1645">      set_empty_rows(wp, srow);</a>
<a name="ln1646">      wp-&gt;w_botline = lnum;</a>
<a name="ln1647">    } else {</a>
<a name="ln1648">      win_draw_end(wp, '@', ' ', true, srow, wp-&gt;w_grid.Rows, HLF_AT);</a>
<a name="ln1649">      wp-&gt;w_botline = lnum;</a>
<a name="ln1650">    }</a>
<a name="ln1651">  } else {</a>
<a name="ln1652">    if (eof) {  // we hit the end of the file</a>
<a name="ln1653">      wp-&gt;w_botline = buf-&gt;b_ml.ml_line_count + 1;</a>
<a name="ln1654">      j = diff_check_fill(wp, wp-&gt;w_botline);</a>
<a name="ln1655">      if (j &gt; 0 &amp;&amp; !wp-&gt;w_botfill) {</a>
<a name="ln1656">        // display filler lines at the end of the file</a>
<a name="ln1657">        if (char2cells(wp-&gt;w_p_fcs_chars.diff) &gt; 1) {</a>
<a name="ln1658">          i = '-';</a>
<a name="ln1659">        } else {</a>
<a name="ln1660">          i = wp-&gt;w_p_fcs_chars.diff;</a>
<a name="ln1661">        }</a>
<a name="ln1662">        if (row + j &gt; wp-&gt;w_grid.Rows) {</a>
<a name="ln1663">          j = wp-&gt;w_grid.Rows - row;</a>
<a name="ln1664">        }</a>
<a name="ln1665">        win_draw_end(wp, i, i, true, row, row + (int)j, HLF_DED);</a>
<a name="ln1666">        row += j;</a>
<a name="ln1667">      }</a>
<a name="ln1668">    } else if (dollar_vcol == -1)</a>
<a name="ln1669">      wp-&gt;w_botline = lnum;</a>
<a name="ln1670"> </a>
<a name="ln1671">    // make sure the rest of the screen is blank</a>
<a name="ln1672">    // write the 'eob' character to rows that aren't part of the file.</a>
<a name="ln1673">    win_draw_end(wp, wp-&gt;w_p_fcs_chars.eob, ' ', false, row, wp-&gt;w_grid.Rows,</a>
<a name="ln1674">                 HLF_EOB);</a>
<a name="ln1675">  }</a>
<a name="ln1676"> </a>
<a name="ln1677">  kvi_destroy(line_providers);</a>
<a name="ln1678"> </a>
<a name="ln1679">  if (wp-&gt;w_redr_type &gt;= REDRAW_TOP) {</a>
<a name="ln1680">    draw_vsep_win(wp, 0);</a>
<a name="ln1681">  }</a>
<a name="ln1682">  syn_set_timeout(NULL);</a>
<a name="ln1683"> </a>
<a name="ln1684">  /* Reset the type of redrawing required, the window has been updated. */</a>
<a name="ln1685">  wp-&gt;w_redr_type = 0;</a>
<a name="ln1686">  wp-&gt;w_old_topfill = wp-&gt;w_topfill;</a>
<a name="ln1687">  wp-&gt;w_old_botfill = wp-&gt;w_botfill;</a>
<a name="ln1688"> </a>
<a name="ln1689">  if (dollar_vcol == -1) {</a>
<a name="ln1690">    /*</a>
<a name="ln1691">     * There is a trick with w_botline.  If we invalidate it on each</a>
<a name="ln1692">     * change that might modify it, this will cause a lot of expensive</a>
<a name="ln1693">     * calls to plines() in update_topline() each time.  Therefore the</a>
<a name="ln1694">     * value of w_botline is often approximated, and this value is used to</a>
<a name="ln1695">     * compute the value of w_topline.  If the value of w_botline was</a>
<a name="ln1696">     * wrong, check that the value of w_topline is correct (cursor is on</a>
<a name="ln1697">     * the visible part of the text).  If it's not, we need to redraw</a>
<a name="ln1698">     * again.  Mostly this just means scrolling up a few lines, so it</a>
<a name="ln1699">     * doesn't look too bad.  Only do this for the current window (where</a>
<a name="ln1700">     * changes are relevant).</a>
<a name="ln1701">     */</a>
<a name="ln1702">    wp-&gt;w_valid |= VALID_BOTLINE;</a>
<a name="ln1703">    wp-&gt;w_viewport_invalid = true;</a>
<a name="ln1704">    if (wp == curwin &amp;&amp; wp-&gt;w_botline != old_botline &amp;&amp; !recursive) {</a>
<a name="ln1705">      const linenr_T old_topline = wp-&gt;w_topline;</a>
<a name="ln1706">      const int new_wcol = wp-&gt;w_wcol;</a>
<a name="ln1707">      recursive = true;</a>
<a name="ln1708">      curwin-&gt;w_valid &amp;= ~VALID_TOPLINE;</a>
<a name="ln1709">      update_topline(curwin);  // may invalidate w_botline again</a>
<a name="ln1710"> </a>
<a name="ln1711">      if (old_wcol != new_wcol</a>
<a name="ln1712">          &amp;&amp; (wp-&gt;w_valid &amp; (VALID_WCOL|VALID_WROW))</a>
<a name="ln1713">          != (VALID_WCOL|VALID_WROW)) {</a>
<a name="ln1714">        // A win_line() call applied a fix to screen cursor column to</a>
<a name="ln1715">        // accommodate concealment of cursor line, but in this call to</a>
<a name="ln1716">        // update_topline() the cursor's row or column got invalidated.</a>
<a name="ln1717">        // If they are left invalid, setcursor() will recompute them</a>
<a name="ln1718">        // but there won't be any further win_line() call to re-fix the</a>
<a name="ln1719">        // column and the cursor will end up misplaced.  So we call</a>
<a name="ln1720">        // cursor validation now and reapply the fix again (or call</a>
<a name="ln1721">        // win_line() to do it for us).</a>
<a name="ln1722">        validate_cursor();</a>
<a name="ln1723">        if (wp-&gt;w_wcol == old_wcol</a>
<a name="ln1724">            &amp;&amp; wp-&gt;w_wrow == old_wrow</a>
<a name="ln1725">            &amp;&amp; old_topline == wp-&gt;w_topline) {</a>
<a name="ln1726">          wp-&gt;w_wcol = new_wcol;</a>
<a name="ln1727">        } else {</a>
<a name="ln1728">          redrawWinline(wp, wp-&gt;w_cursor.lnum);</a>
<a name="ln1729">        }</a>
<a name="ln1730">      }</a>
<a name="ln1731">      // New redraw either due to updated topline or due to wcol fix.</a>
<a name="ln1732">      if (wp-&gt;w_redr_type != 0) {</a>
<a name="ln1733">        // Don't update for changes in buffer again.</a>
<a name="ln1734">        i = curbuf-&gt;b_mod_set;</a>
<a name="ln1735">        curbuf-&gt;b_mod_set = false;</a>
<a name="ln1736">        j = curbuf-&gt;b_mod_xlines;</a>
<a name="ln1737">        curbuf-&gt;b_mod_xlines = 0;</a>
<a name="ln1738">        win_update(curwin, providers);</a>
<a name="ln1739">        curbuf-&gt;b_mod_set = i;</a>
<a name="ln1740">        curbuf-&gt;b_mod_xlines = j;</a>
<a name="ln1741">      }</a>
<a name="ln1742">      // Other windows might have w_redr_type raised in update_topline().</a>
<a name="ln1743">      must_redraw = 0;</a>
<a name="ln1744">      FOR_ALL_WINDOWS_IN_TAB(wwp, curtab) {</a>
<a name="ln1745">        if (wwp-&gt;w_redr_type &gt; must_redraw) {</a>
<a name="ln1746">          must_redraw = wwp-&gt;w_redr_type;</a>
<a name="ln1747">        }</a>
<a name="ln1748">      }</a>
<a name="ln1749">      recursive = false;</a>
<a name="ln1750">    }</a>
<a name="ln1751">  }</a>
<a name="ln1752"> </a>
<a name="ln1753"> </a>
<a name="ln1754">  /* restore got_int, unless CTRL-C was hit while redrawing */</a>
<a name="ln1755">  if (!got_int)</a>
<a name="ln1756">    got_int = save_got_int;</a>
<a name="ln1757">}  // NOLINT(readability/fn_size)</a>
<a name="ln1758"> </a>
<a name="ln1759">/// Returns width of the signcolumn that should be used for the whole window</a>
<a name="ln1760">///</a>
<a name="ln1761">/// @param wp window we want signcolumn width from</a>
<a name="ln1762">/// @return max width of signcolumn (cell unit)</a>
<a name="ln1763">///</a>
<a name="ln1764">/// @note Returns a constant for now but hopefully we can improve neovim so that</a>
<a name="ln1765">///       the returned value width adapts to the maximum number of marks to draw</a>
<a name="ln1766">///       for the window</a>
<a name="ln1767">/// TODO(teto)</a>
<a name="ln1768">int win_signcol_width(win_T *wp)</a>
<a name="ln1769">{</a>
<a name="ln1770">  // 2 is vim default value</a>
<a name="ln1771">  return 2;</a>
<a name="ln1772">}</a>
<a name="ln1773"> </a>
<a name="ln1774">/// Call grid_fill() with columns adjusted for 'rightleft' if needed.</a>
<a name="ln1775">/// Return the new offset.</a>
<a name="ln1776">static int win_fill_end(win_T *wp, int c1, int c2, int off, int width, int row,</a>
<a name="ln1777">                        int endrow, int attr)</a>
<a name="ln1778">{</a>
<a name="ln1779">  int nn = off + width;</a>
<a name="ln1780"> </a>
<a name="ln1781">  if (nn &gt; wp-&gt;w_grid.Columns) {</a>
<a name="ln1782">    nn = wp-&gt;w_grid.Columns;</a>
<a name="ln1783">  }</a>
<a name="ln1784"> </a>
<a name="ln1785">  if (wp-&gt;w_p_rl) {</a>
<a name="ln1786">    grid_fill(&amp;wp-&gt;w_grid, row, endrow, W_ENDCOL(wp) - nn, W_ENDCOL(wp) - off,</a>
<a name="ln1787">              c1, c2, attr);</a>
<a name="ln1788">  } else {</a>
<a name="ln1789">    grid_fill(&amp;wp-&gt;w_grid, row, endrow, off, nn, c1, c2, attr);</a>
<a name="ln1790">  }</a>
<a name="ln1791"> </a>
<a name="ln1792">  return nn;</a>
<a name="ln1793">}</a>
<a name="ln1794"> </a>
<a name="ln1795">/// Clear lines near the end of the window and mark the unused lines with &quot;c1&quot;.</a>
<a name="ln1796">/// Use &quot;c2&quot; as filler character.</a>
<a name="ln1797">/// When &quot;draw_margin&quot; is true, then draw the sign/fold/number columns.</a>
<a name="ln1798">static void win_draw_end(win_T *wp, int c1, int c2, bool draw_margin, int row,</a>
<a name="ln1799">                         int endrow, hlf_T hl)</a>
<a name="ln1800">{</a>
<a name="ln1801">  assert(hl &gt;= 0 &amp;&amp; hl &lt; HLF_COUNT);</a>
<a name="ln1802">  int n = 0;</a>
<a name="ln1803"> </a>
<a name="ln1804">  if (draw_margin) {</a>
<a name="ln1805">    // draw the fold column</a>
<a name="ln1806">    int fdc = compute_foldcolumn(wp, 0);</a>
<a name="ln1807">    if (fdc &gt; 0) {</a>
<a name="ln1808">      n = win_fill_end(wp, ' ', ' ', n, fdc, row, endrow,</a>
<a name="ln1809">                       win_hl_attr(wp, HLF_FC));</a>
<a name="ln1810">    }</a>
<a name="ln1811">    // draw the sign column</a>
<a name="ln1812">    int count = win_signcol_count(wp);</a>
<a name="ln1813">    if (count &gt; 0) {</a>
<a name="ln1814">      n = win_fill_end(wp, ' ', ' ', n, win_signcol_width(wp) * count, row,</a>
<a name="ln1815">                       endrow, win_hl_attr(wp, HLF_SC));</a>
<a name="ln1816">    }</a>
<a name="ln1817">    // draw the number column</a>
<a name="ln1818">    if ((wp-&gt;w_p_nu || wp-&gt;w_p_rnu) &amp;&amp; vim_strchr(p_cpo, CPO_NUMCOL) == NULL) {</a>
<a name="ln1819">      n = win_fill_end(wp, ' ', ' ', n, number_width(wp) + 1, row, endrow,</a>
<a name="ln1820">                       win_hl_attr(wp, HLF_N));</a>
<a name="ln1821">    }</a>
<a name="ln1822">  }</a>
<a name="ln1823"> </a>
<a name="ln1824">  int attr = hl_combine_attr(wp-&gt;w_hl_attr_normal, win_hl_attr(wp, hl));</a>
<a name="ln1825"> </a>
<a name="ln1826">  if (wp-&gt;w_p_rl) {</a>
<a name="ln1827">    grid_fill(&amp;wp-&gt;w_grid, row, endrow, wp-&gt;w_wincol, W_ENDCOL(wp) - 1 - n,</a>
<a name="ln1828">              c2, c2, attr);</a>
<a name="ln1829">    grid_fill(&amp;wp-&gt;w_grid, row, endrow, W_ENDCOL(wp) - 1 - n, W_ENDCOL(wp) - n,</a>
<a name="ln1830">              c1, c2, attr);</a>
<a name="ln1831">  } else {</a>
<a name="ln1832">    grid_fill(&amp;wp-&gt;w_grid, row, endrow, n, wp-&gt;w_grid.Columns, c1, c2, attr);</a>
<a name="ln1833">  }</a>
<a name="ln1834"> </a>
<a name="ln1835">  set_empty_rows(wp, row);</a>
<a name="ln1836">}</a>
<a name="ln1837"> </a>
<a name="ln1838"> </a>
<a name="ln1839">/*</a>
<a name="ln1840"> * Advance **color_cols and return TRUE when there are columns to draw.</a>
<a name="ln1841"> */</a>
<a name="ln1842">static int advance_color_col(int vcol, int **color_cols)</a>
<a name="ln1843">{</a>
<a name="ln1844">  while (**color_cols &gt;= 0 &amp;&amp; vcol &gt; **color_cols)</a>
<a name="ln1845">    ++*color_cols;</a>
<a name="ln1846">  return **color_cols &gt;= 0;</a>
<a name="ln1847">}</a>
<a name="ln1848"> </a>
<a name="ln1849">// Compute the width of the foldcolumn.  Based on 'foldcolumn' and how much</a>
<a name="ln1850">// space is available for window &quot;wp&quot;, minus &quot;col&quot;.</a>
<a name="ln1851">static int compute_foldcolumn(win_T *wp, int col)</a>
<a name="ln1852">{</a>
<a name="ln1853">  int fdc = win_fdccol_count(wp);</a>
<a name="ln1854">  int wmw = wp == curwin &amp;&amp; p_wmw == 0 ? 1 : p_wmw;</a>
<a name="ln1855">  int wwidth = wp-&gt;w_grid.Columns;</a>
<a name="ln1856"> </a>
<a name="ln1857">  if (fdc &gt; wwidth - (col + wmw)) {</a>
<a name="ln1858">    fdc = wwidth - (col + wmw);</a>
<a name="ln1859">  }</a>
<a name="ln1860">  return fdc;</a>
<a name="ln1861">}</a>
<a name="ln1862"> </a>
<a name="ln1863">/// Put a single char from an UTF-8 buffer into a line buffer.</a>
<a name="ln1864">///</a>
<a name="ln1865">/// Handles composing chars and arabic shaping state.</a>
<a name="ln1866">static int line_putchar(LineState *s, schar_T *dest, int maxcells, bool rl)</a>
<a name="ln1867">{</a>
<a name="ln1868">  const char_u *p = (char_u *)s-&gt;p;</a>
<a name="ln1869">  int cells = utf_ptr2cells(p);</a>
<a name="ln1870">  int c_len = utfc_ptr2len(p);</a>
<a name="ln1871">  int u8c, u8cc[MAX_MCO];</a>
<a name="ln1872">  if (cells &gt; maxcells) {</a>
<a name="ln1873">    return -1;</a>
<a name="ln1874">  }</a>
<a name="ln1875">  u8c = utfc_ptr2char(p, u8cc);</a>
<a name="ln1876">  if (*p &lt; 0x80 &amp;&amp; u8cc[0] == 0) {</a>
<a name="ln1877">    schar_from_ascii(dest[0], *p);</a>
<a name="ln1878">    s-&gt;prev_c = u8c;</a>
<a name="ln1879">  } else {</a>
<a name="ln1880">    if (p_arshape &amp;&amp; !p_tbidi &amp;&amp; arabic_char(u8c)) {</a>
<a name="ln1881">      // Do Arabic shaping.</a>
<a name="ln1882">      int pc, pc1, nc;</a>
<a name="ln1883">      int pcc[MAX_MCO];</a>
<a name="ln1884">      int firstbyte = *p;</a>
<a name="ln1885"> </a>
<a name="ln1886">      // The idea of what is the previous and next</a>
<a name="ln1887">      // character depends on 'rightleft'.</a>
<a name="ln1888">      if (rl) {</a>
<a name="ln1889">        pc = s-&gt;prev_c;</a>
<a name="ln1890">        pc1 = s-&gt;prev_c1;</a>
<a name="ln1891">        nc = utf_ptr2char(p + c_len);</a>
<a name="ln1892">        s-&gt;prev_c1 = u8cc[0];</a>
<a name="ln1893">      } else {</a>
<a name="ln1894">        pc = utfc_ptr2char(p + c_len, pcc);</a>
<a name="ln1895">        nc = s-&gt;prev_c;</a>
<a name="ln1896">        pc1 = pcc[0];</a>
<a name="ln1897">      }</a>
<a name="ln1898">      s-&gt;prev_c = u8c;</a>
<a name="ln1899"> </a>
<a name="ln1900">      u8c = arabic_shape(u8c, &amp;firstbyte, &amp;u8cc[0], pc, pc1, nc);</a>
<a name="ln1901">    } else {</a>
<a name="ln1902">      s-&gt;prev_c = u8c;</a>
<a name="ln1903">    }</a>
<a name="ln1904">    schar_from_cc(dest[0], u8c, u8cc);</a>
<a name="ln1905">  }</a>
<a name="ln1906">  if (cells &gt; 1) {</a>
<a name="ln1907">    dest[1][0] = 0;</a>
<a name="ln1908">  }</a>
<a name="ln1909">  s-&gt;p += c_len;</a>
<a name="ln1910">  return cells;</a>
<a name="ln1911">}</a>
<a name="ln1912"> </a>
<a name="ln1913"> </a>
<a name="ln1914">/// Fills the foldcolumn at &quot;p&quot; for window &quot;wp&quot;.</a>
<a name="ln1915">/// Only to be called when 'foldcolumn' &gt; 0.</a>
<a name="ln1916">///</a>
<a name="ln1917">/// @param[out] p  Char array to write into</a>
<a name="ln1918">/// @param lnum    Absolute current line number</a>
<a name="ln1919">/// @param closed  Whether it is in 'foldcolumn' mode</a>
<a name="ln1920">///</a>
<a name="ln1921">/// Assume monocell characters</a>
<a name="ln1922">/// @return number of chars added to \param p</a>
<a name="ln1923">static size_t</a>
<a name="ln1924">fill_foldcolumn(</a>
<a name="ln1925">    char_u *p,</a>
<a name="ln1926">    win_T *wp,</a>
<a name="ln1927">    foldinfo_T foldinfo,</a>
<a name="ln1928">    linenr_T lnum</a>
<a name="ln1929">)</a>
<a name="ln1930">{</a>
<a name="ln1931">  int i = 0;</a>
<a name="ln1932">  int level;</a>
<a name="ln1933">  int first_level;</a>
<a name="ln1934">  int fdc = compute_foldcolumn(wp, 0);    // available cell width</a>
<a name="ln1935">  size_t char_counter = 0;</a>
<a name="ln1936">  int symbol = 0;</a>
<a name="ln1937">  int len = 0;</a>
<a name="ln1938">  bool closed = foldinfo.fi_lines &gt; 0;</a>
<a name="ln1939">  // Init to all spaces.</a>
<a name="ln1940">  memset(p, ' ', MAX_MCO * fdc + 1);</a>
<a name="ln1941"> </a>
<a name="ln1942">  level = foldinfo.fi_level;</a>
<a name="ln1943"> </a>
<a name="ln1944">  // If the column is too narrow, we start at the lowest level that</a>
<a name="ln1945">  // fits and use numbers to indicated the depth.</a>
<a name="ln1946">  first_level = level - fdc - closed + 1;</a>
<a name="ln1947">  if (first_level &lt; 1) {</a>
<a name="ln1948">    first_level = 1;</a>
<a name="ln1949">  }</a>
<a name="ln1950"> </a>
<a name="ln1951">  for (i = 0; i  &lt; MIN(fdc, level); i++) {</a>
<a name="ln1952">    if (foldinfo.fi_lnum == lnum</a>
<a name="ln1953">        &amp;&amp; first_level + i &gt;= foldinfo.fi_low_level) {</a>
<a name="ln1954">      symbol = wp-&gt;w_p_fcs_chars.foldopen;</a>
<a name="ln1955">    } else if (first_level == 1) {</a>
<a name="ln1956">      symbol = wp-&gt;w_p_fcs_chars.foldsep;</a>
<a name="ln1957">    } else if (first_level + i &lt;= 9) {</a>
<a name="ln1958">      symbol = '0' + first_level + i;</a>
<a name="ln1959">    } else {</a>
<a name="ln1960">      symbol = '&gt;';</a>
<a name="ln1961">    }</a>
<a name="ln1962"> </a>
<a name="ln1963">    len = utf_char2bytes(symbol, &amp;p[char_counter]);</a>
<a name="ln1964">    char_counter += len;</a>
<a name="ln1965">    if (first_level + i &gt;= level) {</a>
<a name="ln1966">      i++;</a>
<a name="ln1967">      break;</a>
<a name="ln1968">    }</a>
<a name="ln1969">  }</a>
<a name="ln1970"> </a>
<a name="ln1971">  if (closed) {</a>
<a name="ln1972">    if (symbol != 0) {</a>
<a name="ln1973">      // rollback previous write</a>
<a name="ln1974">      char_counter -= len;</a>
<a name="ln1975">      memset(&amp;p[char_counter], ' ', len);</a>
<a name="ln1976">    }</a>
<a name="ln1977">    len = utf_char2bytes(wp-&gt;w_p_fcs_chars.foldclosed, &amp;p[char_counter]);</a>
<a name="ln1978">    char_counter += len;</a>
<a name="ln1979">  }</a>
<a name="ln1980"> </a>
<a name="ln1981">  return MAX(char_counter + (fdc-i), (size_t)fdc);</a>
<a name="ln1982">}</a>
<a name="ln1983"> </a>
<a name="ln1984">/// Display line &quot;lnum&quot; of window 'wp' on the screen.</a>
<a name="ln1985">/// wp-&gt;w_virtcol needs to be valid.</a>
<a name="ln1986">///</a>
<a name="ln1987">/// @param lnum         line to display</a>
<a name="ln1988">/// @param startrow     first row relative to window grid</a>
<a name="ln1989">/// @param endrow       last grid row to be redrawn</a>
<a name="ln1990">/// @param nochange     not updating for changed text</a>
<a name="ln1991">/// @param number_only  only update the number column</a>
<a name="ln1992">/// @param foldinfo     fold info for this line</a>
<a name="ln1993">/// @param[in, out] providers  decoration providers active this line</a>
<a name="ln1994">///                            items will be disables if they cause errors</a>
<a name="ln1995">///                            or explicitly return `false`.</a>
<a name="ln1996">///</a>
<a name="ln1997">/// @return             the number of last row the line occupies.</a>
<a name="ln1998">static int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow,</a>
<a name="ln1999">                    bool nochange, bool number_only, foldinfo_T foldinfo,</a>
<a name="ln2000">                    Providers *providers)</a>
<a name="ln2001">{</a>
<a name="ln2002">  int c = 0;                          // init for GCC</a>
<a name="ln2003">  long vcol = 0;                      // virtual column (for tabs)</a>
<a name="ln2004">  long vcol_sbr = -1;                 // virtual column after showbreak</a>
<a name="ln2005">  long vcol_prev = -1;                // &quot;vcol&quot; of previous character</a>
<a name="ln2006">  char_u      *line;                  // current line</a>
<a name="ln2007">  char_u      *ptr;                   // current position in &quot;line&quot;</a>
<a name="ln2008">  int row;                            // row in the window, excl w_winrow</a>
<a name="ln2009">  ScreenGrid *grid = &amp;wp-&gt;w_grid;     // grid specfic to the window</a>
<a name="ln2010"> </a>
<a name="ln2011">  char_u extra[57];                   // sign, line number and 'fdc' must</a>
<a name="ln2012">                                      // fit in here</a>
<a name="ln2013">  int n_extra = 0;                    // number of extra chars</a>
<a name="ln2014">  char_u      *p_extra = NULL;        // string of extra chars, plus NUL</a>
<a name="ln2015">  char_u      *p_extra_free = NULL;   // p_extra needs to be freed</a>
<a name="ln2016">  int c_extra = NUL;                  // extra chars, all the same</a>
<a name="ln2017">  int c_final = NUL;                  // final char, mandatory if set</a>
<a name="ln2018">  int extra_attr = 0;                 // attributes when n_extra != 0</a>
<a name="ln2019">  static char_u *at_end_str = (char_u *)&quot;&quot;;  // used for p_extra when displaying</a>
<a name="ln2020">                                             // curwin-&gt;w_p_lcs_chars.eol at</a>
<a name="ln2021">                                             // end-of-line</a>
<a name="ln2022">  int lcs_eol_one = wp-&gt;w_p_lcs_chars.eol;     // 'eol'  until it's been used</a>
<a name="ln2023">  int lcs_prec_todo = wp-&gt;w_p_lcs_chars.prec;  // 'prec' until it's been used</a>
<a name="ln2024">  bool has_fold = foldinfo.fi_level != 0 &amp;&amp; foldinfo.fi_lines &gt; 0;</a>
<a name="ln2025"> </a>
<a name="ln2026">  // saved &quot;extra&quot; items for when draw_state becomes WL_LINE (again)</a>
<a name="ln2027">  int saved_n_extra = 0;</a>
<a name="ln2028">  char_u      *saved_p_extra = NULL;</a>
<a name="ln2029">  int saved_c_extra = 0;</a>
<a name="ln2030">  int saved_c_final = 0;</a>
<a name="ln2031">  int saved_char_attr = 0;</a>
<a name="ln2032"> </a>
<a name="ln2033">  int n_attr = 0;                       /* chars with special attr */</a>
<a name="ln2034">  int saved_attr2 = 0;                  /* char_attr saved for n_attr */</a>
<a name="ln2035">  int n_attr3 = 0;                      /* chars with overruling special attr */</a>
<a name="ln2036">  int saved_attr3 = 0;                  /* char_attr saved for n_attr3 */</a>
<a name="ln2037"> </a>
<a name="ln2038">  int n_skip = 0;                       /* nr of chars to skip for 'nowrap' */</a>
<a name="ln2039"> </a>
<a name="ln2040">  int fromcol = -10;                    // start of inverting</a>
<a name="ln2041">  int tocol = MAXCOL;                   // end of inverting</a>
<a name="ln2042">  int fromcol_prev = -2;                // start of inverting after cursor</a>
<a name="ln2043">  bool noinvcur = false;                // don't invert the cursor</a>
<a name="ln2044">  int lnum_in_visual_area = false;</a>
<a name="ln2045">  pos_T pos;</a>
<a name="ln2046">  long v;</a>
<a name="ln2047"> </a>
<a name="ln2048">  int char_attr = 0;                    /* attributes for next character */</a>
<a name="ln2049">  int attr_pri = FALSE;                 /* char_attr has priority */</a>
<a name="ln2050">  int area_highlighting = FALSE;           /* Visual or incsearch highlighting</a>
<a name="ln2051">                                              in this line */</a>
<a name="ln2052">  int attr = 0;                         /* attributes for area highlighting */</a>
<a name="ln2053">  int area_attr = 0;                    /* attributes desired by highlighting */</a>
<a name="ln2054">  int search_attr = 0;                  /* attributes desired by 'hlsearch' */</a>
<a name="ln2055">  int vcol_save_attr = 0;               /* saved attr for 'cursorcolumn' */</a>
<a name="ln2056">  int syntax_attr = 0;                  /* attributes desired by syntax */</a>
<a name="ln2057">  int has_syntax = FALSE;               /* this buffer has syntax highl. */</a>
<a name="ln2058">  int save_did_emsg;</a>
<a name="ln2059">  int eol_hl_off = 0;                   // 1 if highlighted char after EOL</a>
<a name="ln2060">  int draw_color_col = false;           // highlight colorcolumn</a>
<a name="ln2061">  int *color_cols = NULL;               // pointer to according columns array</a>
<a name="ln2062">  bool has_spell = false;               // this buffer has spell checking</a>
<a name="ln2063"># define SPWORDLEN 150</a>
<a name="ln2064">  char_u nextline[SPWORDLEN * 2];       /* text with start of the next line */</a>
<a name="ln2065">  int nextlinecol = 0;                  /* column where nextline[] starts */</a>
<a name="ln2066">  int nextline_idx = 0;                 /* index in nextline[] where next line</a>
<a name="ln2067">                                           starts */</a>
<a name="ln2068">  int spell_attr = 0;                   /* attributes desired by spelling */</a>
<a name="ln2069">  int word_end = 0;                     /* last byte with same spell_attr */</a>
<a name="ln2070">  static linenr_T checked_lnum = 0;     /* line number for &quot;checked_col&quot; */</a>
<a name="ln2071">  static int checked_col = 0;           /* column in &quot;checked_lnum&quot; up to which</a>
<a name="ln2072">                                         * there are no spell errors */</a>
<a name="ln2073">  static int cap_col = -1;              // column to check for Cap word</a>
<a name="ln2074">  static linenr_T capcol_lnum = 0;      // line number where &quot;cap_col&quot;</a>
<a name="ln2075">  int cur_checked_col = 0;              // checked column for current line</a>
<a name="ln2076">  int extra_check = 0;                  // has syntax or linebreak</a>
<a name="ln2077">  int multi_attr = 0;                   // attributes desired by multibyte</a>
<a name="ln2078">  int mb_l = 1;                         // multi-byte byte length</a>
<a name="ln2079">  int mb_c = 0;                         // decoded multi-byte character</a>
<a name="ln2080">  bool mb_utf8 = false;                 // screen char is UTF-8 char</a>
<a name="ln2081">  int u8cc[MAX_MCO];                    // composing UTF-8 chars</a>
<a name="ln2082">  int filler_lines;                     // nr of filler lines to be drawn</a>
<a name="ln2083">  int filler_todo;                      // nr of filler lines still to do + 1</a>
<a name="ln2084">  hlf_T diff_hlf = (hlf_T)0;            // type of diff highlighting</a>
<a name="ln2085">  int change_start = MAXCOL;            // first col of changed area</a>
<a name="ln2086">  int change_end = -1;                  // last col of changed area</a>
<a name="ln2087">  colnr_T trailcol = MAXCOL;            // start of trailing spaces</a>
<a name="ln2088">  colnr_T leadcol = 0;                  // start of leading spaces</a>
<a name="ln2089">  bool need_showbreak = false;          // overlong line, skip first x chars</a>
<a name="ln2090">  sign_attrs_T sattrs[SIGN_SHOW_MAX];   // attributes for signs</a>
<a name="ln2091">  int num_signs;                        // number of signs for line</a>
<a name="ln2092">  int line_attr = 0;                    // attribute for the whole line</a>
<a name="ln2093">  int line_attr_lowprio = 0;            // low-priority attribute for the line</a>
<a name="ln2094">  matchitem_T *cur;                     // points to the match list</a>
<a name="ln2095">  match_T     *shl;                     // points to search_hl or a match</a>
<a name="ln2096">  bool shl_flag;                        // flag to indicate whether search_hl</a>
<a name="ln2097">                                        // has been processed or not</a>
<a name="ln2098">  bool prevcol_hl_flag;                 // flag to indicate whether prevcol</a>
<a name="ln2099">                                        // equals startcol of search_hl or one</a>
<a name="ln2100">                                        // of the matches</a>
<a name="ln2101">  int prev_c = 0;                       // previous Arabic character</a>
<a name="ln2102">  int prev_c1 = 0;                      // first composing char for prev_c</a>
<a name="ln2103"> </a>
<a name="ln2104">  bool search_attr_from_match = false;  // if search_attr is from :match</a>
<a name="ln2105">  bool has_decor = false;               // this buffer has decoration</a>
<a name="ln2106">  bool do_virttext = false;             // draw virtual text for this line</a>
<a name="ln2107">  int win_col_offset = 0;               // offset for window columns</a>
<a name="ln2108"> </a>
<a name="ln2109">  char_u buf_fold[FOLD_TEXT_LEN + 1];   // Hold value returned by get_foldtext</a>
<a name="ln2110"> </a>
<a name="ln2111">  bool area_active = false;</a>
<a name="ln2112"> </a>
<a name="ln2113">  /* draw_state: items that are drawn in sequence: */</a>
<a name="ln2114">#define WL_START        0               /* nothing done yet */</a>
<a name="ln2115"># define WL_CMDLINE     WL_START + 1    /* cmdline window column */</a>
<a name="ln2116"># define WL_FOLD        WL_CMDLINE + 1  /* 'foldcolumn' */</a>
<a name="ln2117"># define WL_SIGN        WL_FOLD + 1     /* column for signs */</a>
<a name="ln2118">#define WL_NR           WL_SIGN + 1     /* line number */</a>
<a name="ln2119"># define WL_BRI         WL_NR + 1       /* 'breakindent' */</a>
<a name="ln2120"># define WL_SBR         WL_BRI + 1       /* 'showbreak' or 'diff' */</a>
<a name="ln2121">#define WL_LINE         WL_SBR + 1      /* text in the line */</a>
<a name="ln2122">  int draw_state = WL_START;            /* what to draw next */</a>
<a name="ln2123"> </a>
<a name="ln2124">  int syntax_flags    = 0;</a>
<a name="ln2125">  int syntax_seqnr    = 0;</a>
<a name="ln2126">  int prev_syntax_id  = 0;</a>
<a name="ln2127">  int conceal_attr    = win_hl_attr(wp, HLF_CONCEAL);</a>
<a name="ln2128">  int is_concealing   = false;</a>
<a name="ln2129">  int boguscols       = 0;              ///&lt; nonexistent columns added to</a>
<a name="ln2130">                                        ///&lt; force wrapping</a>
<a name="ln2131">  int vcol_off        = 0;              ///&lt; offset for concealed characters</a>
<a name="ln2132">  int did_wcol        = false;</a>
<a name="ln2133">  int match_conc      = 0;              ///&lt; cchar for match functions</a>
<a name="ln2134">  int old_boguscols = 0;</a>
<a name="ln2135"># define VCOL_HLC (vcol - vcol_off)</a>
<a name="ln2136"># define FIX_FOR_BOGUSCOLS \</a>
<a name="ln2137">  { \</a>
<a name="ln2138">    n_extra += vcol_off; \</a>
<a name="ln2139">    vcol -= vcol_off; \</a>
<a name="ln2140">    vcol_off = 0; \</a>
<a name="ln2141">    col -= boguscols; \</a>
<a name="ln2142">    old_boguscols = boguscols; \</a>
<a name="ln2143">    boguscols = 0; \</a>
<a name="ln2144">  }</a>
<a name="ln2145"> </a>
<a name="ln2146">  if (startrow &gt; endrow)                /* past the end already! */</a>
<a name="ln2147">    return startrow;</a>
<a name="ln2148"> </a>
<a name="ln2149">  row = startrow;</a>
<a name="ln2150"> </a>
<a name="ln2151">  char *err_text = NULL;</a>
<a name="ln2152"> </a>
<a name="ln2153">  buf_T *buf = wp-&gt;w_buffer;</a>
<a name="ln2154"> </a>
<a name="ln2155">  if (!number_only) {</a>
<a name="ln2156">    // To speed up the loop below, set extra_check when there is linebreak,</a>
<a name="ln2157">    // trailing white space and/or syntax processing to be done.</a>
<a name="ln2158">    extra_check = wp-&gt;w_p_lbr;</a>
<a name="ln2159">    if (syntax_present(wp) &amp;&amp; !wp-&gt;w_s-&gt;b_syn_error &amp;&amp; !wp-&gt;w_s-&gt;b_syn_slow) {</a>
<a name="ln2160">      // Prepare for syntax highlighting in this line.  When there is an</a>
<a name="ln2161">      // error, stop syntax highlighting.</a>
<a name="ln2162">      save_did_emsg = did_emsg;</a>
<a name="ln2163">      did_emsg = false;</a>
<a name="ln2164">      syntax_start(wp, lnum);</a>
<a name="ln2165">      if (did_emsg) {</a>
<a name="ln2166">        wp-&gt;w_s-&gt;b_syn_error = true;</a>
<a name="ln2167">      } else {</a>
<a name="ln2168">        did_emsg = save_did_emsg;</a>
<a name="ln2169">        if (!wp-&gt;w_s-&gt;b_syn_slow) {</a>
<a name="ln2170">          has_syntax = true;</a>
<a name="ln2171">          extra_check = true;</a>
<a name="ln2172">        }</a>
<a name="ln2173">      }</a>
<a name="ln2174">    }</a>
<a name="ln2175"> </a>
<a name="ln2176">    has_decor = decor_redraw_line(wp-&gt;w_buffer, lnum-1,</a>
<a name="ln2177">                                  &amp;decor_state);</a>
<a name="ln2178"> </a>
<a name="ln2179">    for (size_t k = 0; k &lt; kv_size(*providers); k++) {</a>
<a name="ln2180">      DecorProvider *p = kv_A(*providers, k);</a>
<a name="ln2181">      if (p &amp;&amp; p-&gt;redraw_line != LUA_NOREF) {</a>
<a name="ln2182">        FIXED_TEMP_ARRAY(args, 3);</a>
<a name="ln2183">        args.items[0] = WINDOW_OBJ(wp-&gt;handle);</a>
<a name="ln2184">        args.items[1] = BUFFER_OBJ(buf-&gt;handle);</a>
<a name="ln2185">        args.items[2] = INTEGER_OBJ(lnum-1);</a>
<a name="ln2186">        if (provider_invoke(p-&gt;ns_id, &quot;line&quot;, p-&gt;redraw_line, args, true)) {</a>
<a name="ln2187">          has_decor = true;</a>
<a name="ln2188">        } else {</a>
<a name="ln2189">          // return 'false' or error: skip rest of this window</a>
<a name="ln2190">          kv_A(*providers, k) = NULL;</a>
<a name="ln2191">        }</a>
<a name="ln2192"> </a>
<a name="ln2193">        win_check_ns_hl(wp);</a>
<a name="ln2194">      }</a>
<a name="ln2195">    }</a>
<a name="ln2196"> </a>
<a name="ln2197">    if (has_decor) {</a>
<a name="ln2198">      extra_check = true;</a>
<a name="ln2199">    }</a>
<a name="ln2200"> </a>
<a name="ln2201">    if (provider_first_error) {</a>
<a name="ln2202">      err_text = provider_first_error;</a>
<a name="ln2203">      provider_first_error = NULL;</a>
<a name="ln2204">      do_virttext = true;</a>
<a name="ln2205">    }</a>
<a name="ln2206"> </a>
<a name="ln2207">    // Check for columns to display for 'colorcolumn'.</a>
<a name="ln2208">    color_cols = wp-&gt;w_buffer-&gt;terminal ? NULL : wp-&gt;w_p_cc_cols;</a>
<a name="ln2209">    if (color_cols != NULL) {</a>
<a name="ln2210">      draw_color_col = advance_color_col(VCOL_HLC, &amp;color_cols);</a>
<a name="ln2211">    }</a>
<a name="ln2212"> </a>
<a name="ln2213">    if (wp-&gt;w_p_spell</a>
<a name="ln2214">        &amp;&amp; !has_fold</a>
<a name="ln2215">        &amp;&amp; *wp-&gt;w_s-&gt;b_p_spl != NUL</a>
<a name="ln2216">        &amp;&amp; !GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)</a>
<a name="ln2217">        &amp;&amp; *(char **)(wp-&gt;w_s-&gt;b_langp.ga_data) != NULL) {</a>
<a name="ln2218">      // Prepare for spell checking.</a>
<a name="ln2219">      has_spell = true;</a>
<a name="ln2220">      extra_check = true;</a>
<a name="ln2221"> </a>
<a name="ln2222">      // Get the start of the next line, so that words that wrap to the next</a>
<a name="ln2223">      // line are found too: &quot;et&lt;line-break&gt;al.&quot;.</a>
<a name="ln2224">      // Trick: skip a few chars for C/shell/Vim comments</a>
<a name="ln2225">      nextline[SPWORDLEN] = NUL;</a>
<a name="ln2226">      if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln2227">        line = ml_get_buf(wp-&gt;w_buffer, lnum + 1, false);</a>
<a name="ln2228">        spell_cat_line(nextline + SPWORDLEN, line, SPWORDLEN);</a>
<a name="ln2229">      }</a>
<a name="ln2230"> </a>
<a name="ln2231">      // When a word wrapped from the previous line the start of the current</a>
<a name="ln2232">      // line is valid.</a>
<a name="ln2233">      if (lnum == checked_lnum) {</a>
<a name="ln2234">        cur_checked_col = checked_col;</a>
<a name="ln2235">      }</a>
<a name="ln2236">      checked_lnum = 0;</a>
<a name="ln2237"> </a>
<a name="ln2238">      // When there was a sentence end in the previous line may require a</a>
<a name="ln2239">      // word starting with capital in this line.  In line 1 always check</a>
<a name="ln2240">      // the first word.</a>
<a name="ln2241">      if (lnum != capcol_lnum) {</a>
<a name="ln2242">        cap_col = -1;</a>
<a name="ln2243">      }</a>
<a name="ln2244">      if (lnum == 1) {</a>
<a name="ln2245">        cap_col = 0;</a>
<a name="ln2246">      }</a>
<a name="ln2247">      capcol_lnum = 0;</a>
<a name="ln2248">    }</a>
<a name="ln2249"> </a>
<a name="ln2250">    // handle Visual active in this window</a>
<a name="ln2251">    if (VIsual_active &amp;&amp; wp-&gt;w_buffer == curwin-&gt;w_buffer) {</a>
<a name="ln2252">      pos_T *top, *bot;</a>
<a name="ln2253"> </a>
<a name="ln2254">      if (ltoreq(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln2255">        // Visual is after curwin-&gt;w_cursor</a>
<a name="ln2256">        top = &amp;curwin-&gt;w_cursor;</a>
<a name="ln2257">        bot = &amp;VIsual;</a>
<a name="ln2258">      } else {</a>
<a name="ln2259">        // Visual is before curwin-&gt;w_cursor</a>
<a name="ln2260">        top = &amp;VIsual;</a>
<a name="ln2261">        bot = &amp;curwin-&gt;w_cursor;</a>
<a name="ln2262">      }</a>
<a name="ln2263">      lnum_in_visual_area = (lnum &gt;= top-&gt;lnum &amp;&amp; lnum &lt;= bot-&gt;lnum);</a>
<a name="ln2264">      if (VIsual_mode == Ctrl_V) {</a>
<a name="ln2265">        // block mode</a>
<a name="ln2266">        if (lnum_in_visual_area) {</a>
<a name="ln2267">          fromcol = wp-&gt;w_old_cursor_fcol;</a>
<a name="ln2268">          tocol = wp-&gt;w_old_cursor_lcol;</a>
<a name="ln2269">        }</a>
<a name="ln2270">      } else {</a>
<a name="ln2271">        // non-block mode</a>
<a name="ln2272">        if (lnum &gt; top-&gt;lnum &amp;&amp; lnum &lt;= bot-&gt;lnum) {</a>
<a name="ln2273">          fromcol = 0;</a>
<a name="ln2274">        } else if (lnum == top-&gt;lnum) {</a>
<a name="ln2275">          if (VIsual_mode == 'V') {       // linewise</a>
<a name="ln2276">            fromcol = 0;</a>
<a name="ln2277">          } else {</a>
<a name="ln2278">            getvvcol(wp, top, (colnr_T *)&amp;fromcol, NULL, NULL);</a>
<a name="ln2279">            if (gchar_pos(top) == NUL) {</a>
<a name="ln2280">              tocol = fromcol + 1;</a>
<a name="ln2281">            }</a>
<a name="ln2282">          }</a>
<a name="ln2283">        }</a>
<a name="ln2284">        if (VIsual_mode != 'V' &amp;&amp; lnum == bot-&gt;lnum) {</a>
<a name="ln2285">          if (*p_sel == 'e' &amp;&amp; bot-&gt;col == 0</a>
<a name="ln2286">              &amp;&amp; bot-&gt;coladd == 0) {</a>
<a name="ln2287">            fromcol = -10;</a>
<a name="ln2288">            tocol = MAXCOL;</a>
<a name="ln2289">          } else if (bot-&gt;col == MAXCOL) {</a>
<a name="ln2290">            tocol = MAXCOL;</a>
<a name="ln2291">          } else {</a>
<a name="ln2292">            pos = *bot;</a>
<a name="ln2293">            if (*p_sel == 'e') {</a>
<a name="ln2294">              getvvcol(wp, &amp;pos, (colnr_T *)&amp;tocol, NULL, NULL);</a>
<a name="ln2295">            } else {</a>
<a name="ln2296">              getvvcol(wp, &amp;pos, NULL, NULL, (colnr_T *)&amp;tocol);</a>
<a name="ln2297">              tocol++;</a>
<a name="ln2298">            }</a>
<a name="ln2299">          }</a>
<a name="ln2300">        }</a>
<a name="ln2301">      }</a>
<a name="ln2302"> </a>
<a name="ln2303">      // Check if the char under the cursor should be inverted (highlighted).</a>
<a name="ln2304">      if (!highlight_match &amp;&amp; lnum == curwin-&gt;w_cursor.lnum &amp;&amp; wp == curwin</a>
<a name="ln2305">          &amp;&amp; cursor_is_block_during_visual(*p_sel == 'e')) {</a>
<a name="ln2306">        noinvcur = true;</a>
<a name="ln2307">      }</a>
<a name="ln2308"> </a>
<a name="ln2309">      // if inverting in this line set area_highlighting</a>
<a name="ln2310">      if (fromcol &gt;= 0) {</a>
<a name="ln2311">        area_highlighting = true;</a>
<a name="ln2312">        attr = win_hl_attr(wp, HLF_V);</a>
<a name="ln2313">      }</a>
<a name="ln2314">    // handle 'incsearch' and &quot;:s///c&quot; highlighting</a>
<a name="ln2315">    } else if (highlight_match</a>
<a name="ln2316">               &amp;&amp; wp == curwin</a>
<a name="ln2317">               &amp;&amp; !has_fold</a>
<a name="ln2318">               &amp;&amp; lnum &gt;= curwin-&gt;w_cursor.lnum</a>
<a name="ln2319">               &amp;&amp; lnum &lt;= curwin-&gt;w_cursor.lnum + search_match_lines) {</a>
<a name="ln2320">      if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln2321">        getvcol(curwin, &amp;(curwin-&gt;w_cursor),</a>
<a name="ln2322">                (colnr_T *)&amp;fromcol, NULL, NULL);</a>
<a name="ln2323">      } else {</a>
<a name="ln2324">        fromcol = 0;</a>
<a name="ln2325">      }</a>
<a name="ln2326">      if (lnum == curwin-&gt;w_cursor.lnum + search_match_lines) {</a>
<a name="ln2327">        pos.lnum = lnum;</a>
<a name="ln2328">        pos.col = search_match_endcol;</a>
<a name="ln2329">        getvcol(curwin, &amp;pos, (colnr_T *)&amp;tocol, NULL, NULL);</a>
<a name="ln2330">      }</a>
<a name="ln2331">      // do at least one character; happens when past end of line</a>
<a name="ln2332">      if (fromcol == tocol &amp;&amp; search_match_endcol) {</a>
<a name="ln2333">        tocol = fromcol + 1;</a>
<a name="ln2334">      }</a>
<a name="ln2335">      area_highlighting = true;</a>
<a name="ln2336">      attr = win_hl_attr(wp, HLF_I);</a>
<a name="ln2337">    }</a>
<a name="ln2338">  }</a>
<a name="ln2339"> </a>
<a name="ln2340">  filler_lines = diff_check(wp, lnum);</a>
<a name="ln2341">  if (filler_lines &lt; 0) {</a>
<a name="ln2342">    if (filler_lines == -1) {</a>
<a name="ln2343">      if (diff_find_change(wp, lnum, &amp;change_start, &amp;change_end))</a>
<a name="ln2344">        diff_hlf = HLF_ADD;             /* added line */</a>
<a name="ln2345">      else if (change_start == 0)</a>
<a name="ln2346">        diff_hlf = HLF_TXD;             /* changed text */</a>
<a name="ln2347">      else</a>
<a name="ln2348">        diff_hlf = HLF_CHD;             /* changed line */</a>
<a name="ln2349">    } else</a>
<a name="ln2350">      diff_hlf = HLF_ADD;               /* added line */</a>
<a name="ln2351">    filler_lines = 0;</a>
<a name="ln2352">    area_highlighting = TRUE;</a>
<a name="ln2353">  }</a>
<a name="ln2354">  if (lnum == wp-&gt;w_topline)</a>
<a name="ln2355">    filler_lines = wp-&gt;w_topfill;</a>
<a name="ln2356">  filler_todo = filler_lines;</a>
<a name="ln2357"> </a>
<a name="ln2358">  // Cursor line highlighting for 'cursorline' in the current window.</a>
<a name="ln2359">  if (lnum == wp-&gt;w_cursor.lnum) {</a>
<a name="ln2360">    // Do not show the cursor line when Visual mode is active, because it's</a>
<a name="ln2361">    // not clear what is selected then.</a>
<a name="ln2362">    if (wp-&gt;w_p_cul &amp;&amp; !(wp == curwin &amp;&amp; VIsual_active)) {</a>
<a name="ln2363">      int cul_attr = win_hl_attr(wp, HLF_CUL);</a>
<a name="ln2364">      HlAttrs ae = syn_attr2entry(cul_attr);</a>
<a name="ln2365"> </a>
<a name="ln2366">      // We make a compromise here (#7383):</a>
<a name="ln2367">      //  * low-priority CursorLine if fg is not set</a>
<a name="ln2368">      //  * high-priority (&quot;same as Vim&quot; priority) CursorLine if fg is set</a>
<a name="ln2369">      if (ae.rgb_fg_color == -1 &amp;&amp; ae.cterm_fg_color == 0) {</a>
<a name="ln2370">        line_attr_lowprio = cul_attr;</a>
<a name="ln2371">      } else {</a>
<a name="ln2372">        if (!(State &amp; INSERT) &amp;&amp; bt_quickfix(wp-&gt;w_buffer)</a>
<a name="ln2373">            &amp;&amp; qf_current_entry(wp) == lnum) {</a>
<a name="ln2374">          line_attr = hl_combine_attr(cul_attr, line_attr);</a>
<a name="ln2375">        } else {</a>
<a name="ln2376">          line_attr = cul_attr;</a>
<a name="ln2377">        }</a>
<a name="ln2378">      }</a>
<a name="ln2379">    }</a>
<a name="ln2380">    // Update w_last_cursorline even if Visual mode is active.</a>
<a name="ln2381">    wp-&gt;w_last_cursorline = wp-&gt;w_cursor.lnum;</a>
<a name="ln2382">  }</a>
<a name="ln2383"> </a>
<a name="ln2384">  memset(sattrs, 0, sizeof(sattrs));</a>
<a name="ln2385">  num_signs = buf_get_signattrs(wp-&gt;w_buffer, lnum, sattrs);</a>
<a name="ln2386"> </a>
<a name="ln2387">  // If this line has a sign with line highlighting set line_attr.</a>
<a name="ln2388">  // TODO(bfredl, vigoux): this should not take priority over decoration!</a>
<a name="ln2389">  sign_attrs_T * sattr = sign_get_attr(SIGN_LINEHL, sattrs, 0, 1);</a>
<a name="ln2390">  if (sattr != NULL) {</a>
<a name="ln2391">    line_attr = sattr-&gt;sat_linehl;</a>
<a name="ln2392">  }</a>
<a name="ln2393"> </a>
<a name="ln2394">  // Highlight the current line in the quickfix window.</a>
<a name="ln2395">  if (bt_quickfix(wp-&gt;w_buffer) &amp;&amp; qf_current_entry(wp) == lnum) {</a>
<a name="ln2396">    line_attr = win_hl_attr(wp, HLF_QFL);</a>
<a name="ln2397">  }</a>
<a name="ln2398"> </a>
<a name="ln2399">  if (line_attr_lowprio || line_attr) {</a>
<a name="ln2400">    area_highlighting = true;</a>
<a name="ln2401">  }</a>
<a name="ln2402"> </a>
<a name="ln2403">  line = ml_get_buf(wp-&gt;w_buffer, lnum, FALSE);</a>
<a name="ln2404">  ptr = line;</a>
<a name="ln2405"> </a>
<a name="ln2406">  if (has_spell &amp;&amp; !number_only) {</a>
<a name="ln2407">    // For checking first word with a capital skip white space.</a>
<a name="ln2408">    if (cap_col == 0) {</a>
<a name="ln2409">      cap_col = (int)getwhitecols(line);</a>
<a name="ln2410">    }</a>
<a name="ln2411"> </a>
<a name="ln2412">    /* To be able to spell-check over line boundaries copy the end of the</a>
<a name="ln2413">     * current line into nextline[].  Above the start of the next line was</a>
<a name="ln2414">     * copied to nextline[SPWORDLEN]. */</a>
<a name="ln2415">    if (nextline[SPWORDLEN] == NUL) {</a>
<a name="ln2416">      /* No next line or it is empty. */</a>
<a name="ln2417">      nextlinecol = MAXCOL;</a>
<a name="ln2418">      nextline_idx = 0;</a>
<a name="ln2419">    } else {</a>
<a name="ln2420">      v = (long)STRLEN(line);</a>
<a name="ln2421">      if (v &lt; SPWORDLEN) {</a>
<a name="ln2422">        /* Short line, use it completely and append the start of the</a>
<a name="ln2423">         * next line. */</a>
<a name="ln2424">        nextlinecol = 0;</a>
<a name="ln2425">        memmove(nextline, line, (size_t)v);</a>
<a name="ln2426">        STRMOVE(nextline + v, nextline + SPWORDLEN);</a>
<a name="ln2427">        nextline_idx = v + 1;</a>
<a name="ln2428">      } else {</a>
<a name="ln2429">        /* Long line, use only the last SPWORDLEN bytes. */</a>
<a name="ln2430">        nextlinecol = v - SPWORDLEN;</a>
<a name="ln2431">        memmove(nextline, line + nextlinecol, SPWORDLEN);  // -V512</a>
<a name="ln2432">        nextline_idx = SPWORDLEN + 1;</a>
<a name="ln2433">      }</a>
<a name="ln2434">    }</a>
<a name="ln2435">  }</a>
<a name="ln2436"> </a>
<a name="ln2437">  if (wp-&gt;w_p_list &amp;&amp; !has_fold) {</a>
<a name="ln2438">    if (wp-&gt;w_p_lcs_chars.space</a>
<a name="ln2439">        || wp-&gt;w_p_lcs_chars.trail</a>
<a name="ln2440">        || wp-&gt;w_p_lcs_chars.lead</a>
<a name="ln2441">        || wp-&gt;w_p_lcs_chars.nbsp) {</a>
<a name="ln2442">      extra_check = true;</a>
<a name="ln2443">    }</a>
<a name="ln2444">    // find start of trailing whitespace</a>
<a name="ln2445">    if (wp-&gt;w_p_lcs_chars.trail) {</a>
<a name="ln2446">      trailcol = (colnr_T)STRLEN(ptr);</a>
<a name="ln2447">      while (trailcol &gt; (colnr_T)0 &amp;&amp; ascii_iswhite(ptr[trailcol - 1])) {</a>
<a name="ln2448">        trailcol--;</a>
<a name="ln2449">      }</a>
<a name="ln2450">      trailcol += (colnr_T) (ptr - line);</a>
<a name="ln2451">    }</a>
<a name="ln2452">    // find end of leading whitespace</a>
<a name="ln2453">    if (wp-&gt;w_p_lcs_chars.lead) {</a>
<a name="ln2454">      leadcol = 0;</a>
<a name="ln2455">      while (ascii_iswhite(ptr[leadcol])) {</a>
<a name="ln2456">        leadcol++;</a>
<a name="ln2457">      }</a>
<a name="ln2458">      if (ptr[leadcol] == NUL) {</a>
<a name="ln2459">        // in a line full of spaces all of them are treated as trailing</a>
<a name="ln2460">        leadcol = (colnr_T)0;</a>
<a name="ln2461">      } else {</a>
<a name="ln2462">        // keep track of the first column not filled with spaces</a>
<a name="ln2463">        leadcol += (colnr_T)(ptr - line) + 1;</a>
<a name="ln2464">      }</a>
<a name="ln2465">    }</a>
<a name="ln2466">  }</a>
<a name="ln2467"> </a>
<a name="ln2468">  /*</a>
<a name="ln2469">   * 'nowrap' or 'wrap' and a single line that doesn't fit: Advance to the</a>
<a name="ln2470">   * first character to be displayed.</a>
<a name="ln2471">   */</a>
<a name="ln2472">  if (wp-&gt;w_p_wrap)</a>
<a name="ln2473">    v = wp-&gt;w_skipcol;</a>
<a name="ln2474">  else</a>
<a name="ln2475">    v = wp-&gt;w_leftcol;</a>
<a name="ln2476">  if (v &gt; 0 &amp;&amp; !number_only) {</a>
<a name="ln2477">    char_u  *prev_ptr = ptr;</a>
<a name="ln2478">    while (vcol &lt; v &amp;&amp; *ptr != NUL) {</a>
<a name="ln2479">      c = win_lbr_chartabsize(wp, line, ptr, (colnr_T)vcol, NULL);</a>
<a name="ln2480">      vcol += c;</a>
<a name="ln2481">      prev_ptr = ptr;</a>
<a name="ln2482">      MB_PTR_ADV(ptr);</a>
<a name="ln2483">    }</a>
<a name="ln2484"> </a>
<a name="ln2485">    // When:</a>
<a name="ln2486">    // - 'cuc' is set, or</a>
<a name="ln2487">    // - 'colorcolumn' is set, or</a>
<a name="ln2488">    // - 'virtualedit' is set, or</a>
<a name="ln2489">    // - the visual mode is active,</a>
<a name="ln2490">    // the end of the line may be before the start of the displayed part.</a>
<a name="ln2491">    if (vcol &lt; v &amp;&amp; (wp-&gt;w_p_cuc</a>
<a name="ln2492">                     || draw_color_col</a>
<a name="ln2493">                     || virtual_active()</a>
<a name="ln2494">                     || (VIsual_active &amp;&amp; wp-&gt;w_buffer == curwin-&gt;w_buffer))) {</a>
<a name="ln2495">      vcol = v;</a>
<a name="ln2496">    }</a>
<a name="ln2497"> </a>
<a name="ln2498">    /* Handle a character that's not completely on the screen: Put ptr at</a>
<a name="ln2499">     * that character but skip the first few screen characters. */</a>
<a name="ln2500">    if (vcol &gt; v) {</a>
<a name="ln2501">      vcol -= c;</a>
<a name="ln2502">      ptr = prev_ptr;</a>
<a name="ln2503">      // If the character fits on the screen, don't need to skip it.</a>
<a name="ln2504">      // Except for a TAB.</a>
<a name="ln2505">      if (utf_ptr2cells(ptr) &gt;= c || *ptr == TAB) {</a>
<a name="ln2506">        n_skip = v - vcol;</a>
<a name="ln2507">      }</a>
<a name="ln2508">    }</a>
<a name="ln2509"> </a>
<a name="ln2510">    /*</a>
<a name="ln2511">     * Adjust for when the inverted text is before the screen,</a>
<a name="ln2512">     * and when the start of the inverted text is before the screen.</a>
<a name="ln2513">     */</a>
<a name="ln2514">    if (tocol &lt;= vcol)</a>
<a name="ln2515">      fromcol = 0;</a>
<a name="ln2516">    else if (fromcol &gt;= 0 &amp;&amp; fromcol &lt; vcol)</a>
<a name="ln2517">      fromcol = vcol;</a>
<a name="ln2518"> </a>
<a name="ln2519">    // When w_skipcol is non-zero, first line needs 'showbreak'</a>
<a name="ln2520">    if (wp-&gt;w_p_wrap) {</a>
<a name="ln2521">      need_showbreak = true;</a>
<a name="ln2522">    }</a>
<a name="ln2523">    // When spell checking a word we need to figure out the start of the</a>
<a name="ln2524">    // word and if it's badly spelled or not.</a>
<a name="ln2525">    if (has_spell) {</a>
<a name="ln2526">      size_t len;</a>
<a name="ln2527">      colnr_T linecol = (colnr_T)(ptr - line);</a>
<a name="ln2528">      hlf_T spell_hlf = HLF_COUNT;</a>
<a name="ln2529"> </a>
<a name="ln2530">      pos = wp-&gt;w_cursor;</a>
<a name="ln2531">      wp-&gt;w_cursor.lnum = lnum;</a>
<a name="ln2532">      wp-&gt;w_cursor.col = linecol;</a>
<a name="ln2533">      len = spell_move_to(wp, FORWARD, TRUE, TRUE, &amp;spell_hlf);</a>
<a name="ln2534"> </a>
<a name="ln2535">      /* spell_move_to() may call ml_get() and make &quot;line&quot; invalid */</a>
<a name="ln2536">      line = ml_get_buf(wp-&gt;w_buffer, lnum, FALSE);</a>
<a name="ln2537">      ptr = line + linecol;</a>
<a name="ln2538"> </a>
<a name="ln2539">      if (len == 0 || (int)wp-&gt;w_cursor.col &gt; ptr - line) {</a>
<a name="ln2540">        /* no bad word found at line start, don't check until end of a</a>
<a name="ln2541">         * word */</a>
<a name="ln2542">        spell_hlf = HLF_COUNT;</a>
<a name="ln2543">        word_end = (int)(spell_to_word_end(ptr, wp) - line + 1);</a>
<a name="ln2544">      } else {</a>
<a name="ln2545">        /* bad word found, use attributes until end of word */</a>
<a name="ln2546">        assert(len &lt;= INT_MAX);</a>
<a name="ln2547">        word_end = wp-&gt;w_cursor.col + (int)len + 1;</a>
<a name="ln2548"> </a>
<a name="ln2549">        /* Turn index into actual attributes. */</a>
<a name="ln2550">        if (spell_hlf != HLF_COUNT)</a>
<a name="ln2551">          spell_attr = highlight_attr[spell_hlf];</a>
<a name="ln2552">      }</a>
<a name="ln2553">      wp-&gt;w_cursor = pos;</a>
<a name="ln2554"> </a>
<a name="ln2555">      // Need to restart syntax highlighting for this line.</a>
<a name="ln2556">      if (has_syntax) {</a>
<a name="ln2557">        syntax_start(wp, lnum);</a>
<a name="ln2558">      }</a>
<a name="ln2559">    }</a>
<a name="ln2560">  }</a>
<a name="ln2561"> </a>
<a name="ln2562">  /*</a>
<a name="ln2563">   * Correct highlighting for cursor that can't be disabled.</a>
<a name="ln2564">   * Avoids having to check this for each character.</a>
<a name="ln2565">   */</a>
<a name="ln2566">  if (fromcol &gt;= 0) {</a>
<a name="ln2567">    if (noinvcur) {</a>
<a name="ln2568">      if ((colnr_T)fromcol == wp-&gt;w_virtcol) {</a>
<a name="ln2569">        /* highlighting starts at cursor, let it start just after the</a>
<a name="ln2570">         * cursor */</a>
<a name="ln2571">        fromcol_prev = fromcol;</a>
<a name="ln2572">        fromcol = -1;</a>
<a name="ln2573">      } else if ((colnr_T)fromcol &lt; wp-&gt;w_virtcol)</a>
<a name="ln2574">        /* restart highlighting after the cursor */</a>
<a name="ln2575">        fromcol_prev = wp-&gt;w_virtcol;</a>
<a name="ln2576">    }</a>
<a name="ln2577">    if (fromcol &gt;= tocol)</a>
<a name="ln2578">      fromcol = -1;</a>
<a name="ln2579">  }</a>
<a name="ln2580"> </a>
<a name="ln2581">  /*</a>
<a name="ln2582">   * Handle highlighting the last used search pattern and matches.</a>
<a name="ln2583">   * Do this for both search_hl and the match list.</a>
<a name="ln2584">   */</a>
<a name="ln2585">  cur = wp-&gt;w_match_head;</a>
<a name="ln2586">  shl_flag = false;</a>
<a name="ln2587">  while ((cur != NULL || !shl_flag) &amp;&amp; !number_only</a>
<a name="ln2588">         &amp;&amp; !has_fold</a>
<a name="ln2589">         ) {</a>
<a name="ln2590">    if (!shl_flag) {</a>
<a name="ln2591">      shl = &amp;search_hl;</a>
<a name="ln2592">      shl_flag = true;</a>
<a name="ln2593">    } else {</a>
<a name="ln2594">      shl = &amp;cur-&gt;hl;  // -V595</a>
<a name="ln2595">    }</a>
<a name="ln2596">    shl-&gt;startcol = MAXCOL;</a>
<a name="ln2597">    shl-&gt;endcol = MAXCOL;</a>
<a name="ln2598">    shl-&gt;attr_cur = 0;</a>
<a name="ln2599">    shl-&gt;is_addpos = false;</a>
<a name="ln2600">    v = (long)(ptr - line);</a>
<a name="ln2601">    if (cur != NULL) {</a>
<a name="ln2602">      cur-&gt;pos.cur = 0;</a>
<a name="ln2603">    }</a>
<a name="ln2604">    next_search_hl(wp, shl, lnum, (colnr_T)v,</a>
<a name="ln2605">                   shl == &amp;search_hl ? NULL : cur);</a>
<a name="ln2606">    if (wp-&gt;w_s-&gt;b_syn_slow) {</a>
<a name="ln2607">      has_syntax = false;</a>
<a name="ln2608">    }</a>
<a name="ln2609"> </a>
<a name="ln2610">    // Need to get the line again, a multi-line regexp may have made it</a>
<a name="ln2611">    // invalid.</a>
<a name="ln2612">    line = ml_get_buf(wp-&gt;w_buffer, lnum, false);</a>
<a name="ln2613">    ptr = line + v;</a>
<a name="ln2614"> </a>
<a name="ln2615">    if (shl-&gt;lnum != 0 &amp;&amp; shl-&gt;lnum &lt;= lnum) {</a>
<a name="ln2616">      if (shl-&gt;lnum == lnum) {</a>
<a name="ln2617">        shl-&gt;startcol = shl-&gt;rm.startpos[0].col;</a>
<a name="ln2618">      } else {</a>
<a name="ln2619">        shl-&gt;startcol = 0;</a>
<a name="ln2620">      }</a>
<a name="ln2621">      if (lnum == shl-&gt;lnum + shl-&gt;rm.endpos[0].lnum</a>
<a name="ln2622">                  - shl-&gt;rm.startpos[0].lnum) {</a>
<a name="ln2623">          shl-&gt;endcol = shl-&gt;rm.endpos[0].col;</a>
<a name="ln2624">      } else {</a>
<a name="ln2625">          shl-&gt;endcol = MAXCOL;</a>
<a name="ln2626">      }</a>
<a name="ln2627">      // Highlight one character for an empty match.</a>
<a name="ln2628">      if (shl-&gt;startcol == shl-&gt;endcol) {</a>
<a name="ln2629">          if (line[shl-&gt;endcol] != NUL) {</a>
<a name="ln2630">              shl-&gt;endcol += (*mb_ptr2len)(line + shl-&gt;endcol);</a>
<a name="ln2631">          } else {</a>
<a name="ln2632">              ++shl-&gt;endcol;</a>
<a name="ln2633">          }</a>
<a name="ln2634">      }</a>
<a name="ln2635">      if ((long)shl-&gt;startcol &lt; v) {   // match at leftcol</a>
<a name="ln2636">        shl-&gt;attr_cur = shl-&gt;attr;</a>
<a name="ln2637">        search_attr = shl-&gt;attr;</a>
<a name="ln2638">        search_attr_from_match = shl != &amp;search_hl;</a>
<a name="ln2639">      }</a>
<a name="ln2640">      area_highlighting = true;</a>
<a name="ln2641">    }</a>
<a name="ln2642">    if (shl != &amp;search_hl &amp;&amp; cur != NULL)</a>
<a name="ln2643">      cur = cur-&gt;next;</a>
<a name="ln2644">  }</a>
<a name="ln2645"> </a>
<a name="ln2646">  unsigned off = 0;  // Offset relative start of line</a>
<a name="ln2647">  int col = 0;  // Visual column on screen.</a>
<a name="ln2648">  if (wp-&gt;w_p_rl) {</a>
<a name="ln2649">    // Rightleft window: process the text in the normal direction, but put</a>
<a name="ln2650">    // it in linebuf_char[off] from right to left.  Start at the</a>
<a name="ln2651">    // rightmost column of the window.</a>
<a name="ln2652">    col = grid-&gt;Columns - 1;</a>
<a name="ln2653">    off += col;</a>
<a name="ln2654">  }</a>
<a name="ln2655"> </a>
<a name="ln2656">  // wont highlight after TERM_ATTRS_MAX columns</a>
<a name="ln2657">  int term_attrs[TERM_ATTRS_MAX] = { 0 };</a>
<a name="ln2658">  if (wp-&gt;w_buffer-&gt;terminal) {</a>
<a name="ln2659">    terminal_get_line_attributes(wp-&gt;w_buffer-&gt;terminal, wp, lnum, term_attrs);</a>
<a name="ln2660">    extra_check = true;</a>
<a name="ln2661">  }</a>
<a name="ln2662"> </a>
<a name="ln2663">  int sign_idx = 0;</a>
<a name="ln2664">  // Repeat for the whole displayed line.</a>
<a name="ln2665">  for (;; ) {</a>
<a name="ln2666">    int has_match_conc = 0;  ///&lt; match wants to conceal</a>
<a name="ln2667">    bool did_decrement_ptr = false;</a>
<a name="ln2668"> </a>
<a name="ln2669">    // Skip this quickly when working on the text.</a>
<a name="ln2670">    if (draw_state != WL_LINE) {</a>
<a name="ln2671">      if (draw_state == WL_CMDLINE - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln2672">        draw_state = WL_CMDLINE;</a>
<a name="ln2673">        if (cmdwin_type != 0 &amp;&amp; wp == curwin) {</a>
<a name="ln2674">          /* Draw the cmdline character. */</a>
<a name="ln2675">          n_extra = 1;</a>
<a name="ln2676">          c_extra = cmdwin_type;</a>
<a name="ln2677">          c_final = NUL;</a>
<a name="ln2678">          char_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln2679">        }</a>
<a name="ln2680">      }</a>
<a name="ln2681"> </a>
<a name="ln2682">      if (draw_state == WL_FOLD - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln2683">        int fdc = compute_foldcolumn(wp, 0);</a>
<a name="ln2684"> </a>
<a name="ln2685">        draw_state = WL_FOLD;</a>
<a name="ln2686">        if (fdc &gt; 0) {</a>
<a name="ln2687">          // Draw the 'foldcolumn'.  Allocate a buffer, &quot;extra&quot; may</a>
<a name="ln2688">          // already be in use.</a>
<a name="ln2689">          xfree(p_extra_free);</a>
<a name="ln2690">          p_extra_free = xmalloc(MAX_MCO * fdc + 1);</a>
<a name="ln2691">          n_extra = (int)fill_foldcolumn(p_extra_free, wp, foldinfo, lnum);</a>
<a name="ln2692">          p_extra_free[n_extra] = NUL;</a>
<a name="ln2693">          p_extra = p_extra_free;</a>
<a name="ln2694">          c_extra = NUL;</a>
<a name="ln2695">          c_final = NUL;</a>
<a name="ln2696">          char_attr = win_hl_attr(wp, HLF_FC);</a>
<a name="ln2697">        }</a>
<a name="ln2698">      }</a>
<a name="ln2699"> </a>
<a name="ln2700">      // sign column, this is hit until sign_idx reaches count</a>
<a name="ln2701">      if (draw_state == WL_SIGN - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln2702">          draw_state = WL_SIGN;</a>
<a name="ln2703">          /* Show the sign column when there are any signs in this</a>
<a name="ln2704">           * buffer or when using Netbeans. */</a>
<a name="ln2705">          int count = win_signcol_count(wp);</a>
<a name="ln2706">          if (count &gt; 0) {</a>
<a name="ln2707">              get_sign_display_info(</a>
<a name="ln2708">                  false, wp, sattrs, row,</a>
<a name="ln2709">                  startrow, filler_lines, filler_todo, count,</a>
<a name="ln2710">                  &amp;c_extra, &amp;c_final, extra, sizeof(extra),</a>
<a name="ln2711">                  &amp;p_extra, &amp;n_extra,</a>
<a name="ln2712">                  &amp;char_attr, &amp;draw_state, &amp;sign_idx);</a>
<a name="ln2713">          }</a>
<a name="ln2714">      }</a>
<a name="ln2715"> </a>
<a name="ln2716">      if (draw_state == WL_NR - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln2717">        draw_state = WL_NR;</a>
<a name="ln2718">        /* Display the absolute or relative line number. After the</a>
<a name="ln2719">         * first fill with blanks when the 'n' flag isn't in 'cpo' */</a>
<a name="ln2720">        if ((wp-&gt;w_p_nu || wp-&gt;w_p_rnu)</a>
<a name="ln2721">            &amp;&amp; (row == startrow + filler_lines</a>
<a name="ln2722">                || vim_strchr(p_cpo, CPO_NUMCOL) == NULL)) {</a>
<a name="ln2723">          // If 'signcolumn' is set to 'number' and a sign is present</a>
<a name="ln2724">          // in 'lnum', then display the sign instead of the line</a>
<a name="ln2725">          // number.</a>
<a name="ln2726">          if (*wp-&gt;w_p_scl == 'n' &amp;&amp; *(wp-&gt;w_p_scl + 1) == 'u'</a>
<a name="ln2727">              &amp;&amp; num_signs &gt; 0) {</a>
<a name="ln2728">            int count = win_signcol_count(wp);</a>
<a name="ln2729">            get_sign_display_info(</a>
<a name="ln2730">                true, wp, sattrs, row,</a>
<a name="ln2731">                startrow, filler_lines, filler_todo, count,</a>
<a name="ln2732">                &amp;c_extra, &amp;c_final, extra, sizeof(extra),</a>
<a name="ln2733">                &amp;p_extra, &amp;n_extra,</a>
<a name="ln2734">                &amp;char_attr, &amp;draw_state, &amp;sign_idx);</a>
<a name="ln2735">          } else {</a>
<a name="ln2736">            if (row == startrow + filler_lines) {</a>
<a name="ln2737">              // Draw the line number (empty space after wrapping). */</a>
<a name="ln2738">              long num;</a>
<a name="ln2739">              char *fmt = &quot;%*ld &quot;;</a>
<a name="ln2740"> </a>
<a name="ln2741">              if (wp-&gt;w_p_nu &amp;&amp; !wp-&gt;w_p_rnu) {</a>
<a name="ln2742">                // 'number' + 'norelativenumber'</a>
<a name="ln2743">                num = (long)lnum;</a>
<a name="ln2744">              } else {</a>
<a name="ln2745">                // 'relativenumber', don't use negative numbers</a>
<a name="ln2746">                num = labs((long)get_cursor_rel_lnum(wp, lnum));</a>
<a name="ln2747">                if (num == 0 &amp;&amp; wp-&gt;w_p_nu &amp;&amp; wp-&gt;w_p_rnu) {</a>
<a name="ln2748">                  // 'number' + 'relativenumber'</a>
<a name="ln2749">                  num = lnum;</a>
<a name="ln2750">                  fmt = &quot;%-*ld &quot;;</a>
<a name="ln2751">                }</a>
<a name="ln2752">              }</a>
<a name="ln2753"> </a>
<a name="ln2754">              snprintf((char *)extra, sizeof(extra),</a>
<a name="ln2755">                       fmt, number_width(wp), num);</a>
<a name="ln2756">              if (wp-&gt;w_skipcol &gt; 0) {</a>
<a name="ln2757">                for (p_extra = extra; *p_extra == ' '; p_extra++) {</a>
<a name="ln2758">                  *p_extra = '-';</a>
<a name="ln2759">                }</a>
<a name="ln2760">              }</a>
<a name="ln2761">              if (wp-&gt;w_p_rl) {                       // reverse line numbers</a>
<a name="ln2762">                // like rl_mirror(), but keep the space at the end</a>
<a name="ln2763">                char_u *p2 = skipwhite(extra);</a>
<a name="ln2764">                p2 = skiptowhite(p2) - 1;</a>
<a name="ln2765">                for (char_u *p1 = skipwhite(extra); p1 &lt; p2; p1++, p2--) {</a>
<a name="ln2766">                  const int t = *p1;</a>
<a name="ln2767">                  *p1 = *p2;</a>
<a name="ln2768">                  *p2 = t;</a>
<a name="ln2769">                }</a>
<a name="ln2770">              }</a>
<a name="ln2771">              p_extra = extra;</a>
<a name="ln2772">              c_extra = NUL;</a>
<a name="ln2773">              c_final = NUL;</a>
<a name="ln2774">            } else {</a>
<a name="ln2775">              c_extra = ' ';</a>
<a name="ln2776">              c_final = NUL;</a>
<a name="ln2777">            }</a>
<a name="ln2778">            n_extra = number_width(wp) + 1;</a>
<a name="ln2779">            char_attr = win_hl_attr(wp, HLF_N);</a>
<a name="ln2780"> </a>
<a name="ln2781">            sign_attrs_T *num_sattr = sign_get_attr(SIGN_NUMHL, sattrs, 0, 1);</a>
<a name="ln2782">            if (num_sattr != NULL) {</a>
<a name="ln2783">              // :sign defined with &quot;numhl&quot; highlight.</a>
<a name="ln2784">              char_attr = num_sattr-&gt;sat_numhl;</a>
<a name="ln2785">            } else if ((wp-&gt;w_p_cul || wp-&gt;w_p_rnu)</a>
<a name="ln2786">                       &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln2787">                       &amp;&amp; filler_todo == 0) {</a>
<a name="ln2788">              // When 'cursorline' is set highlight the line number of</a>
<a name="ln2789">              // the current line differently.</a>
<a name="ln2790">              // TODO(vim): Can we use CursorLine instead of CursorLineNr</a>
<a name="ln2791">              // when CursorLineNr isn't set?</a>
<a name="ln2792">              char_attr = win_hl_attr(wp, HLF_CLN);</a>
<a name="ln2793">            }</a>
<a name="ln2794">          }</a>
<a name="ln2795">        }</a>
<a name="ln2796">      }</a>
<a name="ln2797"> </a>
<a name="ln2798">      if (draw_state == WL_NR &amp;&amp; n_extra == 0) {</a>
<a name="ln2799">        win_col_offset = off;</a>
<a name="ln2800">      }</a>
<a name="ln2801"> </a>
<a name="ln2802">      if (wp-&gt;w_briopt_sbr &amp;&amp; draw_state == WL_BRI - 1</a>
<a name="ln2803">          &amp;&amp; n_extra == 0 &amp;&amp; *p_sbr != NUL) {</a>
<a name="ln2804">        // draw indent after showbreak value</a>
<a name="ln2805">        draw_state = WL_BRI;</a>
<a name="ln2806">      } else if (wp-&gt;w_briopt_sbr &amp;&amp; draw_state == WL_SBR &amp;&amp; n_extra == 0) {</a>
<a name="ln2807">        // after the showbreak, draw the breakindent</a>
<a name="ln2808">        draw_state = WL_BRI - 1;</a>
<a name="ln2809">      }</a>
<a name="ln2810"> </a>
<a name="ln2811">      // draw 'breakindent': indent wrapped text accordingly</a>
<a name="ln2812">      if (draw_state == WL_BRI - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln2813">        draw_state = WL_BRI;</a>
<a name="ln2814">        // if need_showbreak is set, breakindent also applies</a>
<a name="ln2815">        if (wp-&gt;w_p_bri &amp;&amp; (row != startrow || need_showbreak)</a>
<a name="ln2816">            &amp;&amp; filler_lines == 0) {</a>
<a name="ln2817">          char_attr = 0;</a>
<a name="ln2818"> </a>
<a name="ln2819">          if (diff_hlf != (hlf_T)0) {</a>
<a name="ln2820">            char_attr = win_hl_attr(wp, diff_hlf);</a>
<a name="ln2821">            if (wp-&gt;w_p_cul &amp;&amp; lnum == wp-&gt;w_cursor.lnum) {</a>
<a name="ln2822">              char_attr = hl_combine_attr(char_attr, win_hl_attr(wp, HLF_CUL));</a>
<a name="ln2823">            }</a>
<a name="ln2824">          }</a>
<a name="ln2825">          p_extra = NULL;</a>
<a name="ln2826">          c_extra = ' ';</a>
<a name="ln2827">          c_final = NUL;</a>
<a name="ln2828">          n_extra =</a>
<a name="ln2829">            get_breakindent_win(wp, ml_get_buf(wp-&gt;w_buffer, lnum, false));</a>
<a name="ln2830">          if (row == startrow) {</a>
<a name="ln2831">            n_extra -= win_col_off2(wp);</a>
<a name="ln2832">            if (n_extra &lt; 0) {</a>
<a name="ln2833">              n_extra = 0;</a>
<a name="ln2834">            }</a>
<a name="ln2835">          }</a>
<a name="ln2836">          if (wp-&gt;w_skipcol &gt; 0 &amp;&amp; wp-&gt;w_p_wrap &amp;&amp; wp-&gt;w_briopt_sbr) {</a>
<a name="ln2837">            need_showbreak = false;</a>
<a name="ln2838">          }</a>
<a name="ln2839">          // Correct end of highlighted area for 'breakindent',</a>
<a name="ln2840">          // required wen 'linebreak' is also set.</a>
<a name="ln2841">          if (tocol == vcol) {</a>
<a name="ln2842">            tocol += n_extra;</a>
<a name="ln2843">          }</a>
<a name="ln2844">        }</a>
<a name="ln2845">      }</a>
<a name="ln2846"> </a>
<a name="ln2847">      if (draw_state == WL_SBR - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln2848">        draw_state = WL_SBR;</a>
<a name="ln2849">        if (filler_todo &gt; 0) {</a>
<a name="ln2850">          // draw &quot;deleted&quot; diff line(s)</a>
<a name="ln2851">          if (char2cells(wp-&gt;w_p_fcs_chars.diff) &gt; 1) {</a>
<a name="ln2852">            c_extra = '-';</a>
<a name="ln2853">            c_final = NUL;</a>
<a name="ln2854">          } else {</a>
<a name="ln2855">            c_extra = wp-&gt;w_p_fcs_chars.diff;</a>
<a name="ln2856">            c_final = NUL;</a>
<a name="ln2857">          }</a>
<a name="ln2858">          if (wp-&gt;w_p_rl) {</a>
<a name="ln2859">            n_extra = col + 1;</a>
<a name="ln2860">          } else {</a>
<a name="ln2861">            n_extra = grid-&gt;Columns - col;</a>
<a name="ln2862">          }</a>
<a name="ln2863">          char_attr = win_hl_attr(wp, HLF_DED);</a>
<a name="ln2864">        }</a>
<a name="ln2865">        if (*p_sbr != NUL &amp;&amp; need_showbreak) {</a>
<a name="ln2866">          /* Draw 'showbreak' at the start of each broken line. */</a>
<a name="ln2867">          p_extra = p_sbr;</a>
<a name="ln2868">          c_extra = NUL;</a>
<a name="ln2869">          c_final = NUL;</a>
<a name="ln2870">          n_extra = (int)STRLEN(p_sbr);</a>
<a name="ln2871">          char_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln2872">          if (wp-&gt;w_skipcol == 0 || !wp-&gt;w_p_wrap) {</a>
<a name="ln2873">            need_showbreak = false;</a>
<a name="ln2874">          }</a>
<a name="ln2875">          vcol_sbr = vcol + MB_CHARLEN(p_sbr);</a>
<a name="ln2876">          /* Correct end of highlighted area for 'showbreak',</a>
<a name="ln2877">           * required when 'linebreak' is also set. */</a>
<a name="ln2878">          if (tocol == vcol)</a>
<a name="ln2879">            tocol += n_extra;</a>
<a name="ln2880">          // Combine 'showbreak' with 'cursorline', prioritizing 'showbreak'.</a>
<a name="ln2881">          if (wp-&gt;w_p_cul &amp;&amp; lnum == wp-&gt;w_cursor.lnum) {</a>
<a name="ln2882">            char_attr = hl_combine_attr(win_hl_attr(wp, HLF_CUL), char_attr);</a>
<a name="ln2883">          }</a>
<a name="ln2884">        }</a>
<a name="ln2885">      }</a>
<a name="ln2886"> </a>
<a name="ln2887">      if (draw_state == WL_LINE - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln2888">        sign_idx = 0;</a>
<a name="ln2889">        draw_state = WL_LINE;</a>
<a name="ln2890"> </a>
<a name="ln2891">        if (has_decor &amp;&amp; row == startrow + filler_lines) {</a>
<a name="ln2892">          // hide virt_text on text hidden by 'nowrap'</a>
<a name="ln2893">          decor_redraw_col(wp-&gt;w_buffer, vcol, off, true, &amp;decor_state);</a>
<a name="ln2894">        }</a>
<a name="ln2895"> </a>
<a name="ln2896">        if (saved_n_extra) {</a>
<a name="ln2897">          /* Continue item from end of wrapped line. */</a>
<a name="ln2898">          n_extra = saved_n_extra;</a>
<a name="ln2899">          c_extra = saved_c_extra;</a>
<a name="ln2900">          c_final = saved_c_final;</a>
<a name="ln2901">          p_extra = saved_p_extra;</a>
<a name="ln2902">          char_attr = saved_char_attr;</a>
<a name="ln2903">        } else {</a>
<a name="ln2904">          char_attr = 0;</a>
<a name="ln2905">        }</a>
<a name="ln2906">      }</a>
<a name="ln2907">    }</a>
<a name="ln2908"> </a>
<a name="ln2909">    // When still displaying '$' of change command, stop at cursor</a>
<a name="ln2910">    if (((dollar_vcol &gt;= 0</a>
<a name="ln2911">          &amp;&amp; wp == curwin</a>
<a name="ln2912">          &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln2913">          &amp;&amp; vcol &gt;= (long)wp-&gt;w_virtcol)</a>
<a name="ln2914">         || (number_only &amp;&amp; draw_state &gt; WL_NR))</a>
<a name="ln2915">        &amp;&amp; filler_todo &lt;= 0) {</a>
<a name="ln2916">      draw_virt_text(buf, win_col_offset, &amp;col, grid-&gt;Columns);</a>
<a name="ln2917">      grid_put_linebuf(grid, row, 0, col, -grid-&gt;Columns, wp-&gt;w_p_rl, wp,</a>
<a name="ln2918">                       wp-&gt;w_hl_attr_normal, false);</a>
<a name="ln2919">      // Pretend we have finished updating the window.  Except when</a>
<a name="ln2920">      // 'cursorcolumn' is set.</a>
<a name="ln2921">      if (wp-&gt;w_p_cuc) {</a>
<a name="ln2922">        row = wp-&gt;w_cline_row + wp-&gt;w_cline_height;</a>
<a name="ln2923">      } else {</a>
<a name="ln2924">        row = grid-&gt;Rows;</a>
<a name="ln2925">      }</a>
<a name="ln2926">      break;</a>
<a name="ln2927">    }</a>
<a name="ln2928"> </a>
<a name="ln2929">    if (draw_state == WL_LINE</a>
<a name="ln2930">        &amp;&amp; has_fold</a>
<a name="ln2931">        &amp;&amp; vcol == 0</a>
<a name="ln2932">        &amp;&amp; n_extra == 0</a>
<a name="ln2933">        &amp;&amp; row == startrow) {</a>
<a name="ln2934">        char_attr = win_hl_attr(wp, HLF_FL);</a>
<a name="ln2935"> </a>
<a name="ln2936">        linenr_T lnume = lnum + foldinfo.fi_lines - 1;</a>
<a name="ln2937">        memset(buf_fold, ' ', FOLD_TEXT_LEN);</a>
<a name="ln2938">        p_extra = get_foldtext(wp, lnum, lnume, foldinfo, buf_fold);</a>
<a name="ln2939">        n_extra = STRLEN(p_extra);</a>
<a name="ln2940"> </a>
<a name="ln2941">        if (p_extra != buf_fold) {</a>
<a name="ln2942">          xfree(p_extra_free);</a>
<a name="ln2943">          p_extra_free = p_extra;</a>
<a name="ln2944">        }</a>
<a name="ln2945">        c_extra = NUL;</a>
<a name="ln2946">        c_final = NUL;</a>
<a name="ln2947">        p_extra[n_extra] = NUL;</a>
<a name="ln2948">    }</a>
<a name="ln2949"> </a>
<a name="ln2950">    if (draw_state == WL_LINE</a>
<a name="ln2951">        &amp;&amp; has_fold</a>
<a name="ln2952">        &amp;&amp; col &lt; grid-&gt;Columns</a>
<a name="ln2953">        &amp;&amp; n_extra == 0</a>
<a name="ln2954">        &amp;&amp; row == startrow) {</a>
<a name="ln2955">      // fill rest of line with 'fold'</a>
<a name="ln2956">      c_extra = wp-&gt;w_p_fcs_chars.fold;</a>
<a name="ln2957">      c_final = NUL;</a>
<a name="ln2958"> </a>
<a name="ln2959">      n_extra = wp-&gt;w_p_rl ? (col + 1) : (grid-&gt;Columns - col);</a>
<a name="ln2960">    }</a>
<a name="ln2961"> </a>
<a name="ln2962">    if (draw_state == WL_LINE</a>
<a name="ln2963">        &amp;&amp; has_fold</a>
<a name="ln2964">        &amp;&amp; col &gt;= grid-&gt;Columns</a>
<a name="ln2965">        &amp;&amp; n_extra != 0</a>
<a name="ln2966">        &amp;&amp; row == startrow) {</a>
<a name="ln2967">      // Truncate the folding.</a>
<a name="ln2968">      n_extra = 0;</a>
<a name="ln2969">    }</a>
<a name="ln2970"> </a>
<a name="ln2971">    if (draw_state == WL_LINE &amp;&amp; (area_highlighting || has_spell)) {</a>
<a name="ln2972">      // handle Visual or match highlighting in this line</a>
<a name="ln2973">      if (vcol == fromcol</a>
<a name="ln2974">          || (vcol + 1 == fromcol &amp;&amp; n_extra == 0</a>
<a name="ln2975">              &amp;&amp; utf_ptr2cells(ptr) &gt; 1)</a>
<a name="ln2976">          || ((int)vcol_prev == fromcol_prev</a>
<a name="ln2977">              &amp;&amp; vcol_prev &lt; vcol               // not at margin</a>
<a name="ln2978">              &amp;&amp; vcol &lt; tocol)) {</a>
<a name="ln2979">        area_attr = attr;                       // start highlighting</a>
<a name="ln2980">        if (area_highlighting) {</a>
<a name="ln2981">          area_active = true;</a>
<a name="ln2982">        }</a>
<a name="ln2983">      } else if (area_attr != 0 &amp;&amp; (vcol == tocol</a>
<a name="ln2984">                                    || (noinvcur</a>
<a name="ln2985">                                        &amp;&amp; (colnr_T)vcol == wp-&gt;w_virtcol))) {</a>
<a name="ln2986">        area_attr = 0;                          // stop highlighting</a>
<a name="ln2987">        area_active = false;</a>
<a name="ln2988">     }</a>
<a name="ln2989"> </a>
<a name="ln2990">      if (!n_extra) {</a>
<a name="ln2991">        /*</a>
<a name="ln2992">         * Check for start/end of search pattern match.</a>
<a name="ln2993">         * After end, check for start/end of next match.</a>
<a name="ln2994">         * When another match, have to check for start again.</a>
<a name="ln2995">         * Watch out for matching an empty string!</a>
<a name="ln2996">         * Do this for 'search_hl' and the match list (ordered by</a>
<a name="ln2997">         * priority).</a>
<a name="ln2998">         */</a>
<a name="ln2999">        v = (long)(ptr - line);</a>
<a name="ln3000">        cur = wp-&gt;w_match_head;</a>
<a name="ln3001">        shl_flag = false;</a>
<a name="ln3002">        while (cur != NULL || !shl_flag) {</a>
<a name="ln3003">          if (!shl_flag</a>
<a name="ln3004">              &amp;&amp; (cur == NULL || cur-&gt;priority &gt; SEARCH_HL_PRIORITY)) {</a>
<a name="ln3005">            shl = &amp;search_hl;</a>
<a name="ln3006">            shl_flag = true;</a>
<a name="ln3007">          } else {</a>
<a name="ln3008">            shl = &amp;cur-&gt;hl;</a>
<a name="ln3009">          }</a>
<a name="ln3010">          if (cur != NULL) {</a>
<a name="ln3011">            cur-&gt;pos.cur = 0;</a>
<a name="ln3012">          }</a>
<a name="ln3013">          bool pos_inprogress = true; // mark that a position match search is</a>
<a name="ln3014">                                      // in progress</a>
<a name="ln3015">          while (shl-&gt;rm.regprog != NULL</a>
<a name="ln3016">                                 || (cur != NULL &amp;&amp; pos_inprogress)) {</a>
<a name="ln3017">            if (shl-&gt;startcol != MAXCOL</a>
<a name="ln3018">                &amp;&amp; v &gt;= (long)shl-&gt;startcol</a>
<a name="ln3019">                &amp;&amp; v &lt; (long)shl-&gt;endcol) {</a>
<a name="ln3020">              int tmp_col = v + utfc_ptr2len(ptr);</a>
<a name="ln3021"> </a>
<a name="ln3022">              if (shl-&gt;endcol &lt; tmp_col) {</a>
<a name="ln3023">                shl-&gt;endcol = tmp_col;</a>
<a name="ln3024">              }</a>
<a name="ln3025">              shl-&gt;attr_cur = shl-&gt;attr;</a>
<a name="ln3026">              // Match with the &quot;Conceal&quot; group results in hiding</a>
<a name="ln3027">              // the match.</a>
<a name="ln3028">              if (cur != NULL</a>
<a name="ln3029">                  &amp;&amp; shl != &amp;search_hl</a>
<a name="ln3030">                  &amp;&amp; syn_name2id((char_u *)&quot;Conceal&quot;) == cur-&gt;hlg_id) {</a>
<a name="ln3031">                has_match_conc = v == (long)shl-&gt;startcol ? 2 : 1;</a>
<a name="ln3032">                match_conc = cur-&gt;conceal_char;</a>
<a name="ln3033">              } else {</a>
<a name="ln3034">                has_match_conc = 0;</a>
<a name="ln3035">              }</a>
<a name="ln3036">            } else if (v == (long)shl-&gt;endcol) {</a>
<a name="ln3037">              shl-&gt;attr_cur = 0;</a>
<a name="ln3038"> </a>
<a name="ln3039">              next_search_hl(wp, shl, lnum, (colnr_T)v,</a>
<a name="ln3040">                             shl == &amp;search_hl ? NULL : cur);</a>
<a name="ln3041">              pos_inprogress = !(cur == NULL || cur-&gt;pos.cur == 0);</a>
<a name="ln3042"> </a>
<a name="ln3043">              /* Need to get the line again, a multi-line regexp</a>
<a name="ln3044">               * may have made it invalid. */</a>
<a name="ln3045">              line = ml_get_buf(wp-&gt;w_buffer, lnum, FALSE);</a>
<a name="ln3046">              ptr = line + v;</a>
<a name="ln3047"> </a>
<a name="ln3048">              if (shl-&gt;lnum == lnum) {</a>
<a name="ln3049">                shl-&gt;startcol = shl-&gt;rm.startpos[0].col;</a>
<a name="ln3050">                if (shl-&gt;rm.endpos[0].lnum == 0)</a>
<a name="ln3051">                  shl-&gt;endcol = shl-&gt;rm.endpos[0].col;</a>
<a name="ln3052">                else</a>
<a name="ln3053">                  shl-&gt;endcol = MAXCOL;</a>
<a name="ln3054"> </a>
<a name="ln3055">                if (shl-&gt;startcol == shl-&gt;endcol) {</a>
<a name="ln3056">                  // highlight empty match, try again after it</a>
<a name="ln3057">                  shl-&gt;endcol += (*mb_ptr2len)(line + shl-&gt;endcol);</a>
<a name="ln3058">                }</a>
<a name="ln3059"> </a>
<a name="ln3060">                // Loop to check if the match starts at the</a>
<a name="ln3061">                // current position</a>
<a name="ln3062">                continue;</a>
<a name="ln3063">              }</a>
<a name="ln3064">            }</a>
<a name="ln3065">            break;</a>
<a name="ln3066">          }</a>
<a name="ln3067">          if (shl != &amp;search_hl &amp;&amp; cur != NULL)</a>
<a name="ln3068">            cur = cur-&gt;next;</a>
<a name="ln3069">        }</a>
<a name="ln3070"> </a>
<a name="ln3071">        /* Use attributes from match with highest priority among</a>
<a name="ln3072">         * 'search_hl' and the match list. */</a>
<a name="ln3073">        search_attr_from_match = false;</a>
<a name="ln3074">        search_attr = search_hl.attr_cur;</a>
<a name="ln3075">        cur = wp-&gt;w_match_head;</a>
<a name="ln3076">        shl_flag = false;</a>
<a name="ln3077">        while (cur != NULL || !shl_flag) {</a>
<a name="ln3078">          if (!shl_flag</a>
<a name="ln3079">              &amp;&amp; (cur == NULL || cur-&gt;priority &gt; SEARCH_HL_PRIORITY)) {</a>
<a name="ln3080">            shl = &amp;search_hl;</a>
<a name="ln3081">            shl_flag = true;</a>
<a name="ln3082">          } else {</a>
<a name="ln3083">            shl = &amp;cur-&gt;hl;</a>
<a name="ln3084">          }</a>
<a name="ln3085">          if (shl-&gt;attr_cur != 0) {</a>
<a name="ln3086">            search_attr = shl-&gt;attr_cur;</a>
<a name="ln3087">            search_attr_from_match = shl != &amp;search_hl;</a>
<a name="ln3088">          }</a>
<a name="ln3089">          if (shl != &amp;search_hl &amp;&amp; cur != NULL)</a>
<a name="ln3090">            cur = cur-&gt;next;</a>
<a name="ln3091">        }</a>
<a name="ln3092">        // Only highlight one character after the last column.</a>
<a name="ln3093">        if (*ptr == NUL</a>
<a name="ln3094">            &amp;&amp; (wp-&gt;w_p_list &amp;&amp; lcs_eol_one == -1)) {</a>
<a name="ln3095">          search_attr = 0;</a>
<a name="ln3096">        }</a>
<a name="ln3097"> </a>
<a name="ln3098">        // Do not allow a conceal over EOL otherwise EOL will be missed</a>
<a name="ln3099">        // and bad things happen.</a>
<a name="ln3100">        if (*ptr == NUL) {</a>
<a name="ln3101">          has_match_conc = 0;</a>
<a name="ln3102">        }</a>
<a name="ln3103">      }</a>
<a name="ln3104"> </a>
<a name="ln3105">      if (diff_hlf != (hlf_T)0) {</a>
<a name="ln3106">        if (diff_hlf == HLF_CHD &amp;&amp; ptr - line &gt;= change_start</a>
<a name="ln3107">            &amp;&amp; n_extra == 0) {</a>
<a name="ln3108">          diff_hlf = HLF_TXD;                   // changed text</a>
<a name="ln3109">        }</a>
<a name="ln3110">        if (diff_hlf == HLF_TXD &amp;&amp; ptr - line &gt; change_end</a>
<a name="ln3111">            &amp;&amp; n_extra == 0) {</a>
<a name="ln3112">          diff_hlf = HLF_CHD;                   // changed line</a>
<a name="ln3113">        }</a>
<a name="ln3114">        line_attr = win_hl_attr(wp, diff_hlf);</a>
<a name="ln3115">        // Overlay CursorLine onto diff-mode highlight.</a>
<a name="ln3116">        if (wp-&gt;w_p_cul &amp;&amp; lnum == wp-&gt;w_cursor.lnum) {</a>
<a name="ln3117">          line_attr = 0 != line_attr_lowprio  // Low-priority CursorLine</a>
<a name="ln3118">            ? hl_combine_attr(hl_combine_attr(win_hl_attr(wp, HLF_CUL),</a>
<a name="ln3119">                                              line_attr),</a>
<a name="ln3120">                              hl_get_underline())</a>
<a name="ln3121">            : hl_combine_attr(line_attr, win_hl_attr(wp, HLF_CUL));</a>
<a name="ln3122">        }</a>
<a name="ln3123">      }</a>
<a name="ln3124"> </a>
<a name="ln3125">      // Decide which of the highlight attributes to use.</a>
<a name="ln3126">      attr_pri = true;</a>
<a name="ln3127"> </a>
<a name="ln3128">      if (area_attr != 0) {</a>
<a name="ln3129">        char_attr = hl_combine_attr(line_attr, area_attr);</a>
<a name="ln3130">      } else if (search_attr != 0) {</a>
<a name="ln3131">        char_attr = hl_combine_attr(line_attr, search_attr);</a>
<a name="ln3132">      }</a>
<a name="ln3133">      // Use line_attr when not in the Visual or 'incsearch' area</a>
<a name="ln3134">      // (area_attr may be 0 when &quot;noinvcur&quot; is set).</a>
<a name="ln3135">      else if (line_attr != 0 &amp;&amp; ((fromcol == -10 &amp;&amp; tocol == MAXCOL)</a>
<a name="ln3136">                                  || vcol &lt; fromcol || vcol_prev &lt; fromcol_prev</a>
<a name="ln3137">                                  || vcol &gt;= tocol)) {</a>
<a name="ln3138">        char_attr = line_attr;</a>
<a name="ln3139">      } else {</a>
<a name="ln3140">        attr_pri = false;</a>
<a name="ln3141">        if (has_syntax) {</a>
<a name="ln3142">          char_attr = syntax_attr;</a>
<a name="ln3143">        } else {</a>
<a name="ln3144">          char_attr = 0;</a>
<a name="ln3145">        }</a>
<a name="ln3146">      }</a>
<a name="ln3147">    }</a>
<a name="ln3148"> </a>
<a name="ln3149">    // Get the next character to put on the screen.</a>
<a name="ln3150">    //</a>
<a name="ln3151">    // The &quot;p_extra&quot; points to the extra stuff that is inserted to</a>
<a name="ln3152">    // represent special characters (non-printable stuff) and other</a>
<a name="ln3153">    // things.  When all characters are the same, c_extra is used.</a>
<a name="ln3154">    // If c_final is set, it will compulsorily be used at the end.</a>
<a name="ln3155">    // &quot;p_extra&quot; must end in a NUL to avoid mb_ptr2len() reads past</a>
<a name="ln3156">    // &quot;p_extra[n_extra]&quot;.</a>
<a name="ln3157">    // For the '$' of the 'list' option, n_extra == 1, p_extra == &quot;&quot;.</a>
<a name="ln3158">    if (n_extra &gt; 0) {</a>
<a name="ln3159">      if (c_extra != NUL || (n_extra == 1 &amp;&amp; c_final != NUL)) {</a>
<a name="ln3160">        c = (n_extra == 1 &amp;&amp; c_final != NUL) ? c_final : c_extra;</a>
<a name="ln3161">        mb_c = c;               // doesn't handle non-utf-8 multi-byte!</a>
<a name="ln3162">        if (utf_char2len(c) &gt; 1) {</a>
<a name="ln3163">          mb_utf8 = true;</a>
<a name="ln3164">          u8cc[0] = 0;</a>
<a name="ln3165">          c = 0xc0;</a>
<a name="ln3166">        } else {</a>
<a name="ln3167">          mb_utf8 = false;</a>
<a name="ln3168">        }</a>
<a name="ln3169">      } else {</a>
<a name="ln3170">        assert(p_extra != NULL);</a>
<a name="ln3171">        c = *p_extra;</a>
<a name="ln3172">        mb_c = c;</a>
<a name="ln3173">        // If the UTF-8 character is more than one byte:</a>
<a name="ln3174">        // Decode it into &quot;mb_c&quot;.</a>
<a name="ln3175">        mb_l = utfc_ptr2len(p_extra);</a>
<a name="ln3176">        mb_utf8 = false;</a>
<a name="ln3177">        if (mb_l &gt; n_extra) {</a>
<a name="ln3178">          mb_l = 1;</a>
<a name="ln3179">        } else if (mb_l &gt; 1) {</a>
<a name="ln3180">          mb_c = utfc_ptr2char(p_extra, u8cc);</a>
<a name="ln3181">          mb_utf8 = true;</a>
<a name="ln3182">          c = 0xc0;</a>
<a name="ln3183">        }</a>
<a name="ln3184">        if (mb_l == 0) {          // at the NUL at end-of-line</a>
<a name="ln3185">          mb_l = 1;</a>
<a name="ln3186">        }</a>
<a name="ln3187"> </a>
<a name="ln3188">        // If a double-width char doesn't fit display a '&gt;' in the last column.</a>
<a name="ln3189">        if ((wp-&gt;w_p_rl ? (col &lt;= 0) : (col &gt;= grid-&gt;Columns - 1))</a>
<a name="ln3190">            &amp;&amp; (*mb_char2cells)(mb_c) == 2) {</a>
<a name="ln3191">          c = '&gt;';</a>
<a name="ln3192">          mb_c = c;</a>
<a name="ln3193">          mb_l = 1;</a>
<a name="ln3194">          (void)mb_l;</a>
<a name="ln3195">          multi_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln3196"> </a>
<a name="ln3197">          // put the pointer back to output the double-width</a>
<a name="ln3198">          // character at the start of the next line.</a>
<a name="ln3199">          n_extra++;</a>
<a name="ln3200">          p_extra--;</a>
<a name="ln3201">        } else {</a>
<a name="ln3202">          n_extra -= mb_l - 1;</a>
<a name="ln3203">          p_extra += mb_l - 1;</a>
<a name="ln3204">        }</a>
<a name="ln3205">        p_extra++;</a>
<a name="ln3206">      }</a>
<a name="ln3207">      n_extra--;</a>
<a name="ln3208">    } else if (foldinfo.fi_lines &gt; 0) {</a>
<a name="ln3209">      // skip writing the buffer line itself</a>
<a name="ln3210">      c = NUL;</a>
<a name="ln3211">      XFREE_CLEAR(p_extra_free);</a>
<a name="ln3212">    } else {</a>
<a name="ln3213">      int c0;</a>
<a name="ln3214"> </a>
<a name="ln3215">      XFREE_CLEAR(p_extra_free);</a>
<a name="ln3216"> </a>
<a name="ln3217">      // Get a character from the line itself.</a>
<a name="ln3218">      c0 = c = *ptr;</a>
<a name="ln3219">      mb_c = c;</a>
<a name="ln3220">      // If the UTF-8 character is more than one byte: Decode it</a>
<a name="ln3221">      // into &quot;mb_c&quot;.</a>
<a name="ln3222">      mb_l = utfc_ptr2len(ptr);</a>
<a name="ln3223">      mb_utf8 = false;</a>
<a name="ln3224">      if (mb_l &gt; 1) {</a>
<a name="ln3225">        mb_c = utfc_ptr2char(ptr, u8cc);</a>
<a name="ln3226">        // Overlong encoded ASCII or ASCII with composing char</a>
<a name="ln3227">        // is displayed normally, except a NUL.</a>
<a name="ln3228">        if (mb_c &lt; 0x80) {</a>
<a name="ln3229">          c0 = c = mb_c;</a>
<a name="ln3230">        }</a>
<a name="ln3231">        mb_utf8 = true;</a>
<a name="ln3232"> </a>
<a name="ln3233">        // At start of the line we can have a composing char.</a>
<a name="ln3234">        // Draw it as a space with a composing char.</a>
<a name="ln3235">        if (utf_iscomposing(mb_c)) {</a>
<a name="ln3236">          int i;</a>
<a name="ln3237"> </a>
<a name="ln3238">          for (i = MAX_MCO - 1; i &gt; 0; i--) {</a>
<a name="ln3239">            u8cc[i] = u8cc[i - 1];</a>
<a name="ln3240">          }</a>
<a name="ln3241">          u8cc[0] = mb_c;</a>
<a name="ln3242">          mb_c = ' ';</a>
<a name="ln3243">        }</a>
<a name="ln3244">      }</a>
<a name="ln3245"> </a>
<a name="ln3246">      if ((mb_l == 1 &amp;&amp; c &gt;= 0x80)</a>
<a name="ln3247">          || (mb_l &gt;= 1 &amp;&amp; mb_c == 0)</a>
<a name="ln3248">          || (mb_l &gt; 1 &amp;&amp; (!vim_isprintc(mb_c)))) {</a>
<a name="ln3249">        // Illegal UTF-8 byte: display as &lt;xx&gt;.</a>
<a name="ln3250">        // Non-BMP character : display as ? or fullwidth ?.</a>
<a name="ln3251">        transchar_hex((char *)extra, mb_c);</a>
<a name="ln3252">        if (wp-&gt;w_p_rl) {  // reverse</a>
<a name="ln3253">          rl_mirror(extra);</a>
<a name="ln3254">        }</a>
<a name="ln3255"> </a>
<a name="ln3256">        p_extra = extra;</a>
<a name="ln3257">        c = *p_extra;</a>
<a name="ln3258">        mb_c = mb_ptr2char_adv((const char_u **)&amp;p_extra);</a>
<a name="ln3259">        mb_utf8 = (c &gt;= 0x80);</a>
<a name="ln3260">        n_extra = (int)STRLEN(p_extra);</a>
<a name="ln3261">        c_extra = NUL;</a>
<a name="ln3262">        c_final = NUL;</a>
<a name="ln3263">        if (area_attr == 0 &amp;&amp; search_attr == 0) {</a>
<a name="ln3264">          n_attr = n_extra + 1;</a>
<a name="ln3265">          extra_attr = win_hl_attr(wp, HLF_8);</a>
<a name="ln3266">          saved_attr2 = char_attr;               // save current attr</a>
<a name="ln3267">        }</a>
<a name="ln3268">      } else if (mb_l == 0) {        // at the NUL at end-of-line</a>
<a name="ln3269">        mb_l = 1;</a>
<a name="ln3270">      } else if (p_arshape &amp;&amp; !p_tbidi &amp;&amp; arabic_char(mb_c)) {</a>
<a name="ln3271">        // Do Arabic shaping.</a>
<a name="ln3272">        int pc, pc1, nc;</a>
<a name="ln3273">        int pcc[MAX_MCO];</a>
<a name="ln3274"> </a>
<a name="ln3275">        // The idea of what is the previous and next</a>
<a name="ln3276">        // character depends on 'rightleft'.</a>
<a name="ln3277">        if (wp-&gt;w_p_rl) {</a>
<a name="ln3278">          pc = prev_c;</a>
<a name="ln3279">          pc1 = prev_c1;</a>
<a name="ln3280">          nc = utf_ptr2char(ptr + mb_l);</a>
<a name="ln3281">          prev_c1 = u8cc[0];</a>
<a name="ln3282">        } else {</a>
<a name="ln3283">          pc = utfc_ptr2char(ptr + mb_l, pcc);</a>
<a name="ln3284">          nc = prev_c;</a>
<a name="ln3285">          pc1 = pcc[0];</a>
<a name="ln3286">        }</a>
<a name="ln3287">        prev_c = mb_c;</a>
<a name="ln3288"> </a>
<a name="ln3289">        mb_c = arabic_shape(mb_c, &amp;c, &amp;u8cc[0], pc, pc1, nc);</a>
<a name="ln3290">      } else {</a>
<a name="ln3291">        prev_c = mb_c;</a>
<a name="ln3292">      }</a>
<a name="ln3293">      // If a double-width char doesn't fit display a '&gt;' in the</a>
<a name="ln3294">      // last column; the character is displayed at the start of the</a>
<a name="ln3295">      // next line.</a>
<a name="ln3296">      if ((wp-&gt;w_p_rl ? (col &lt;= 0) :</a>
<a name="ln3297">           (col &gt;= grid-&gt;Columns - 1))</a>
<a name="ln3298">          &amp;&amp; (*mb_char2cells)(mb_c) == 2) {</a>
<a name="ln3299">        c = '&gt;';</a>
<a name="ln3300">        mb_c = c;</a>
<a name="ln3301">        mb_utf8 = false;</a>
<a name="ln3302">        mb_l = 1;</a>
<a name="ln3303">        multi_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln3304">        // Put pointer back so that the character will be</a>
<a name="ln3305">        // displayed at the start of the next line.</a>
<a name="ln3306">        ptr--;</a>
<a name="ln3307">        did_decrement_ptr = true;</a>
<a name="ln3308">      } else if (*ptr != NUL) {</a>
<a name="ln3309">        ptr += mb_l - 1;</a>
<a name="ln3310">      }</a>
<a name="ln3311"> </a>
<a name="ln3312">      // If a double-width char doesn't fit at the left side display a '&lt;' in</a>
<a name="ln3313">      // the first column.  Don't do this for unprintable characters.</a>
<a name="ln3314">      if (n_skip &gt; 0 &amp;&amp; mb_l &gt; 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln3315">        n_extra = 1;</a>
<a name="ln3316">        c_extra = MB_FILLER_CHAR;</a>
<a name="ln3317">        c_final = NUL;</a>
<a name="ln3318">        c = ' ';</a>
<a name="ln3319">        if (area_attr == 0 &amp;&amp; search_attr == 0) {</a>
<a name="ln3320">          n_attr = n_extra + 1;</a>
<a name="ln3321">          extra_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln3322">          saved_attr2 = char_attr;             // save current attr</a>
<a name="ln3323">        }</a>
<a name="ln3324">        mb_c = c;</a>
<a name="ln3325">        mb_utf8 = false;</a>
<a name="ln3326">        mb_l = 1;</a>
<a name="ln3327">      }</a>
<a name="ln3328">      ptr++;</a>
<a name="ln3329"> </a>
<a name="ln3330">      if (extra_check) {</a>
<a name="ln3331">        bool can_spell = true;</a>
<a name="ln3332"> </a>
<a name="ln3333">        /* Get syntax attribute, unless still at the start of the line</a>
<a name="ln3334">         * (double-wide char that doesn't fit). */</a>
<a name="ln3335">        v = (long)(ptr - line);</a>
<a name="ln3336">        if (has_syntax &amp;&amp; v &gt; 0) {</a>
<a name="ln3337">          /* Get the syntax attribute for the character.  If there</a>
<a name="ln3338">           * is an error, disable syntax highlighting. */</a>
<a name="ln3339">          save_did_emsg = did_emsg;</a>
<a name="ln3340">          did_emsg = FALSE;</a>
<a name="ln3341"> </a>
<a name="ln3342">          syntax_attr = get_syntax_attr((colnr_T)v - 1,</a>
<a name="ln3343">                                        has_spell ? &amp;can_spell : NULL, false);</a>
<a name="ln3344"> </a>
<a name="ln3345">          if (did_emsg) {</a>
<a name="ln3346">            wp-&gt;w_s-&gt;b_syn_error = TRUE;</a>
<a name="ln3347">            has_syntax = FALSE;</a>
<a name="ln3348">          } else</a>
<a name="ln3349">            did_emsg = save_did_emsg;</a>
<a name="ln3350"> </a>
<a name="ln3351">          /* Need to get the line again, a multi-line regexp may</a>
<a name="ln3352">           * have made it invalid. */</a>
<a name="ln3353">          line = ml_get_buf(wp-&gt;w_buffer, lnum, FALSE);</a>
<a name="ln3354">          ptr = line + v;</a>
<a name="ln3355"> </a>
<a name="ln3356">          if (!attr_pri) {</a>
<a name="ln3357">            char_attr = syntax_attr;</a>
<a name="ln3358">          } else {</a>
<a name="ln3359">            char_attr = hl_combine_attr(syntax_attr, char_attr);</a>
<a name="ln3360">          }</a>
<a name="ln3361">          // no concealing past the end of the line, it interferes</a>
<a name="ln3362">          // with line highlighting.</a>
<a name="ln3363">          if (c == NUL) {</a>
<a name="ln3364">            syntax_flags = 0;</a>
<a name="ln3365">          } else {</a>
<a name="ln3366">            syntax_flags = get_syntax_info(&amp;syntax_seqnr);</a>
<a name="ln3367">          }</a>
<a name="ln3368">        } else if (!attr_pri) {</a>
<a name="ln3369">          char_attr = 0;</a>
<a name="ln3370">        }</a>
<a name="ln3371"> </a>
<a name="ln3372">        /* Check spelling (unless at the end of the line).</a>
<a name="ln3373">         * Only do this when there is no syntax highlighting, the</a>
<a name="ln3374">         * @Spell cluster is not used or the current syntax item</a>
<a name="ln3375">         * contains the @Spell cluster. */</a>
<a name="ln3376">        v = (long)(ptr - line);</a>
<a name="ln3377">        if (has_spell &amp;&amp; v &gt;= word_end &amp;&amp; v &gt; cur_checked_col) {</a>
<a name="ln3378">          spell_attr = 0;</a>
<a name="ln3379">          if (!attr_pri) {</a>
<a name="ln3380">            char_attr = syntax_attr;</a>
<a name="ln3381">          }</a>
<a name="ln3382">          if (c != 0 &amp;&amp; (!has_syntax || can_spell)) {</a>
<a name="ln3383">            char_u *prev_ptr;</a>
<a name="ln3384">            char_u *p;</a>
<a name="ln3385">            int len;</a>
<a name="ln3386">            hlf_T spell_hlf = HLF_COUNT;</a>
<a name="ln3387">            prev_ptr = ptr - mb_l;</a>
<a name="ln3388">            v -= mb_l - 1;</a>
<a name="ln3389"> </a>
<a name="ln3390">            /* Use nextline[] if possible, it has the start of the</a>
<a name="ln3391">             * next line concatenated. */</a>
<a name="ln3392">            if ((prev_ptr - line) - nextlinecol &gt;= 0) {</a>
<a name="ln3393">              p = nextline + ((prev_ptr - line) - nextlinecol);</a>
<a name="ln3394">            } else {</a>
<a name="ln3395">              p = prev_ptr;</a>
<a name="ln3396">            }</a>
<a name="ln3397">            cap_col -= (int)(prev_ptr - line);</a>
<a name="ln3398">            size_t tmplen = spell_check(wp, p, &amp;spell_hlf, &amp;cap_col, nochange);</a>
<a name="ln3399">            assert(tmplen &lt;= INT_MAX);</a>
<a name="ln3400">            len = (int)tmplen;</a>
<a name="ln3401">            word_end = v + len;</a>
<a name="ln3402"> </a>
<a name="ln3403">            /* In Insert mode only highlight a word that</a>
<a name="ln3404">             * doesn't touch the cursor. */</a>
<a name="ln3405">            if (spell_hlf != HLF_COUNT</a>
<a name="ln3406">                &amp;&amp; (State &amp; INSERT) != 0</a>
<a name="ln3407">                &amp;&amp; wp-&gt;w_cursor.lnum == lnum</a>
<a name="ln3408">                &amp;&amp; wp-&gt;w_cursor.col &gt;=</a>
<a name="ln3409">                (colnr_T)(prev_ptr - line)</a>
<a name="ln3410">                &amp;&amp; wp-&gt;w_cursor.col &lt; (colnr_T)word_end) {</a>
<a name="ln3411">              spell_hlf = HLF_COUNT;</a>
<a name="ln3412">              spell_redraw_lnum = lnum;</a>
<a name="ln3413">            }</a>
<a name="ln3414"> </a>
<a name="ln3415">            if (spell_hlf == HLF_COUNT &amp;&amp; p != prev_ptr</a>
<a name="ln3416">                &amp;&amp; (p - nextline) + len &gt; nextline_idx) {</a>
<a name="ln3417">              /* Remember that the good word continues at the</a>
<a name="ln3418">               * start of the next line. */</a>
<a name="ln3419">              checked_lnum = lnum + 1;</a>
<a name="ln3420">              checked_col = (int)((p - nextline) + len - nextline_idx);</a>
<a name="ln3421">            }</a>
<a name="ln3422"> </a>
<a name="ln3423">            /* Turn index into actual attributes. */</a>
<a name="ln3424">            if (spell_hlf != HLF_COUNT)</a>
<a name="ln3425">              spell_attr = highlight_attr[spell_hlf];</a>
<a name="ln3426"> </a>
<a name="ln3427">            if (cap_col &gt; 0) {</a>
<a name="ln3428">              if (p != prev_ptr</a>
<a name="ln3429">                  &amp;&amp; (p - nextline) + cap_col &gt;= nextline_idx) {</a>
<a name="ln3430">                /* Remember that the word in the next line</a>
<a name="ln3431">                 * must start with a capital. */</a>
<a name="ln3432">                capcol_lnum = lnum + 1;</a>
<a name="ln3433">                cap_col = (int)((p - nextline) + cap_col</a>
<a name="ln3434">                                - nextline_idx);</a>
<a name="ln3435">              } else</a>
<a name="ln3436">                /* Compute the actual column. */</a>
<a name="ln3437">                cap_col += (int)(prev_ptr - line);</a>
<a name="ln3438">            }</a>
<a name="ln3439">          }</a>
<a name="ln3440">        }</a>
<a name="ln3441">        if (spell_attr != 0) {</a>
<a name="ln3442">          if (!attr_pri)</a>
<a name="ln3443">            char_attr = hl_combine_attr(char_attr, spell_attr);</a>
<a name="ln3444">          else</a>
<a name="ln3445">            char_attr = hl_combine_attr(spell_attr, char_attr);</a>
<a name="ln3446">        }</a>
<a name="ln3447"> </a>
<a name="ln3448">        if (wp-&gt;w_buffer-&gt;terminal) {</a>
<a name="ln3449">          char_attr = hl_combine_attr(term_attrs[vcol], char_attr);</a>
<a name="ln3450">        }</a>
<a name="ln3451"> </a>
<a name="ln3452">        if (has_decor &amp;&amp; v &gt; 0) {</a>
<a name="ln3453">          bool selected = (area_active || (area_highlighting &amp;&amp; noinvcur</a>
<a name="ln3454">                                           &amp;&amp; (colnr_T)vcol == wp-&gt;w_virtcol));</a>
<a name="ln3455">          int extmark_attr = decor_redraw_col(wp-&gt;w_buffer, (colnr_T)v-1, off,</a>
<a name="ln3456">                                              selected, &amp;decor_state);</a>
<a name="ln3457">          if (extmark_attr != 0) {</a>
<a name="ln3458">            if (!attr_pri) {</a>
<a name="ln3459">              char_attr = hl_combine_attr(char_attr, extmark_attr);</a>
<a name="ln3460">            } else {</a>
<a name="ln3461">              char_attr = hl_combine_attr(extmark_attr, char_attr);</a>
<a name="ln3462">            }</a>
<a name="ln3463">          }</a>
<a name="ln3464">        }</a>
<a name="ln3465"> </a>
<a name="ln3466">        // Found last space before word: check for line break.</a>
<a name="ln3467">        if (wp-&gt;w_p_lbr &amp;&amp; c0 == c &amp;&amp; vim_isbreak(c)</a>
<a name="ln3468">            &amp;&amp; !vim_isbreak((int)(*ptr))) {</a>
<a name="ln3469">          int mb_off = utf_head_off(line, ptr - 1);</a>
<a name="ln3470">          char_u *p = ptr - (mb_off + 1);</a>
<a name="ln3471">          // TODO: is passing p for start of the line OK?</a>
<a name="ln3472">          n_extra = win_lbr_chartabsize(wp, line, p, (colnr_T)vcol, NULL) - 1;</a>
<a name="ln3473">          if (c == TAB &amp;&amp; n_extra + col &gt; grid-&gt;Columns) {</a>
<a name="ln3474">            n_extra = tabstop_padding(vcol, wp-&gt;w_buffer-&gt;b_p_ts,</a>
<a name="ln3475">                                      wp-&gt;w_buffer-&gt;b_p_vts_array) - 1;</a>
<a name="ln3476">          }</a>
<a name="ln3477">          c_extra = mb_off &gt; 0 ? MB_FILLER_CHAR : ' ';</a>
<a name="ln3478">          c_final = NUL;</a>
<a name="ln3479">          if (ascii_iswhite(c)) {</a>
<a name="ln3480">            if (c == TAB)</a>
<a name="ln3481">              /* See &quot;Tab alignment&quot; below. */</a>
<a name="ln3482">              FIX_FOR_BOGUSCOLS;</a>
<a name="ln3483">            if (!wp-&gt;w_p_list) {</a>
<a name="ln3484">              c = ' ';</a>
<a name="ln3485">            }</a>
<a name="ln3486">          }</a>
<a name="ln3487">        }</a>
<a name="ln3488"> </a>
<a name="ln3489">        // 'list': change char 160 to 'nbsp' and space to 'space'.</a>
<a name="ln3490">        if (wp-&gt;w_p_list</a>
<a name="ln3491">            &amp;&amp; (((c == 160</a>
<a name="ln3492">                  || (mb_utf8 &amp;&amp; (mb_c == 160 || mb_c == 0x202f)))</a>
<a name="ln3493">                 &amp;&amp; curwin-&gt;w_p_lcs_chars.nbsp)</a>
<a name="ln3494">                || (c == ' ' &amp;&amp; curwin-&gt;w_p_lcs_chars.space</a>
<a name="ln3495">                    &amp;&amp; ptr - line &gt;= leadcol</a>
<a name="ln3496">                    &amp;&amp; ptr - line &lt;= trailcol))) {</a>
<a name="ln3497">          c = (c == ' ') ? wp-&gt;w_p_lcs_chars.space : wp-&gt;w_p_lcs_chars.nbsp;</a>
<a name="ln3498">          n_attr = 1;</a>
<a name="ln3499">          extra_attr = win_hl_attr(wp, HLF_0);</a>
<a name="ln3500">          saved_attr2 = char_attr;  // save current attr</a>
<a name="ln3501">          mb_c = c;</a>
<a name="ln3502">          if (utf_char2len(c) &gt; 1) {</a>
<a name="ln3503">            mb_utf8 = true;</a>
<a name="ln3504">            u8cc[0] = 0;</a>
<a name="ln3505">            c = 0xc0;</a>
<a name="ln3506">          } else {</a>
<a name="ln3507">            mb_utf8 = false;</a>
<a name="ln3508">          }</a>
<a name="ln3509">        }</a>
<a name="ln3510"> </a>
<a name="ln3511">        if ((trailcol != MAXCOL &amp;&amp; ptr &gt; line + trailcol &amp;&amp; c == ' ')</a>
<a name="ln3512">            || (leadcol != 0 &amp;&amp; ptr &lt; line + leadcol &amp;&amp; c == ' ')) {</a>
<a name="ln3513">          c = (ptr &gt; line + trailcol) ? wp-&gt;w_p_lcs_chars.trail</a>
<a name="ln3514">                                      : wp-&gt;w_p_lcs_chars.lead;</a>
<a name="ln3515">          n_attr = 1;</a>
<a name="ln3516">          extra_attr = win_hl_attr(wp, HLF_0);</a>
<a name="ln3517">          saved_attr2 = char_attr;  // save current attr</a>
<a name="ln3518">          mb_c = c;</a>
<a name="ln3519">          if (utf_char2len(c) &gt; 1) {</a>
<a name="ln3520">            mb_utf8 = true;</a>
<a name="ln3521">            u8cc[0] = 0;</a>
<a name="ln3522">            c = 0xc0;</a>
<a name="ln3523">          } else {</a>
<a name="ln3524">            mb_utf8 = false;</a>
<a name="ln3525">          }</a>
<a name="ln3526">        }</a>
<a name="ln3527">      }</a>
<a name="ln3528"> </a>
<a name="ln3529">      /*</a>
<a name="ln3530">       * Handling of non-printable characters.</a>
<a name="ln3531">       */</a>
<a name="ln3532">      if (!vim_isprintc(c)) {</a>
<a name="ln3533">        // when getting a character from the file, we may have to</a>
<a name="ln3534">        // turn it into something else on the way to putting it on the screen.</a>
<a name="ln3535">        if (c == TAB &amp;&amp; (!wp-&gt;w_p_list || wp-&gt;w_p_lcs_chars.tab1)) {</a>
<a name="ln3536">          int tab_len = 0;</a>
<a name="ln3537">          long vcol_adjusted = vcol;  // removed showbreak length</a>
<a name="ln3538">          // Only adjust the tab_len, when at the first column after the</a>
<a name="ln3539">          // showbreak value was drawn.</a>
<a name="ln3540">          if (*p_sbr != NUL &amp;&amp; vcol == vcol_sbr &amp;&amp; wp-&gt;w_p_wrap) {</a>
<a name="ln3541">            vcol_adjusted = vcol - MB_CHARLEN(p_sbr);</a>
<a name="ln3542">          }</a>
<a name="ln3543">          // tab amount depends on current column</a>
<a name="ln3544">          tab_len = tabstop_padding(vcol_adjusted,</a>
<a name="ln3545">                                    wp-&gt;w_buffer-&gt;b_p_ts,</a>
<a name="ln3546">                                    wp-&gt;w_buffer-&gt;b_p_vts_array) - 1;</a>
<a name="ln3547"> </a>
<a name="ln3548">          if (!wp-&gt;w_p_lbr || !wp-&gt;w_p_list) {</a>
<a name="ln3549">            n_extra = tab_len;</a>
<a name="ln3550">          } else {</a>
<a name="ln3551">            char_u *p;</a>
<a name="ln3552">            int    i;</a>
<a name="ln3553">            int    saved_nextra = n_extra;</a>
<a name="ln3554"> </a>
<a name="ln3555">            if (vcol_off &gt; 0) {</a>
<a name="ln3556">              // there are characters to conceal</a>
<a name="ln3557">              tab_len += vcol_off;</a>
<a name="ln3558">            }</a>
<a name="ln3559">            // boguscols before FIX_FOR_BOGUSCOLS macro from above.</a>
<a name="ln3560">            if (wp-&gt;w_p_lcs_chars.tab1 &amp;&amp; old_boguscols &gt; 0</a>
<a name="ln3561">                &amp;&amp; n_extra &gt; tab_len) {</a>
<a name="ln3562">              tab_len += n_extra - tab_len;</a>
<a name="ln3563">            }</a>
<a name="ln3564"> </a>
<a name="ln3565">            // if n_extra &gt; 0, it gives the number of chars</a>
<a name="ln3566">            // to use for a tab, else we need to calculate the width</a>
<a name="ln3567">            // for a tab</a>
<a name="ln3568">            int len = (tab_len * mb_char2len(wp-&gt;w_p_lcs_chars.tab2));</a>
<a name="ln3569">            if (n_extra &gt; 0) {</a>
<a name="ln3570">              len += n_extra - tab_len;</a>
<a name="ln3571">            }</a>
<a name="ln3572">            c = wp-&gt;w_p_lcs_chars.tab1;</a>
<a name="ln3573">            p = xmalloc(len + 1);</a>
<a name="ln3574">            memset(p, ' ', len);</a>
<a name="ln3575">            p[len] = NUL;</a>
<a name="ln3576">            xfree(p_extra_free);</a>
<a name="ln3577">            p_extra_free = p;</a>
<a name="ln3578">            for (i = 0; i &lt; tab_len; i++) {</a>
<a name="ln3579">              if (*p == NUL) {</a>
<a name="ln3580">                tab_len = i;</a>
<a name="ln3581">                break;</a>
<a name="ln3582">              }</a>
<a name="ln3583">              int lcs = wp-&gt;w_p_lcs_chars.tab2;</a>
<a name="ln3584"> </a>
<a name="ln3585">              // if tab3 is given, need to change the char</a>
<a name="ln3586">              // for tab</a>
<a name="ln3587">              if (wp-&gt;w_p_lcs_chars.tab3 &amp;&amp; i == tab_len - 1) {</a>
<a name="ln3588">                lcs = wp-&gt;w_p_lcs_chars.tab3;</a>
<a name="ln3589">              }</a>
<a name="ln3590">              utf_char2bytes(lcs, p);</a>
<a name="ln3591">              p += mb_char2len(lcs);</a>
<a name="ln3592">              n_extra += mb_char2len(lcs) - (saved_nextra &gt; 0 ? 1 : 0);</a>
<a name="ln3593">            }</a>
<a name="ln3594">            p_extra = p_extra_free;</a>
<a name="ln3595"> </a>
<a name="ln3596">            // n_extra will be increased by FIX_FOX_BOGUSCOLS</a>
<a name="ln3597">            // macro below, so need to adjust for that here</a>
<a name="ln3598">            if (vcol_off &gt; 0) {</a>
<a name="ln3599">              n_extra -= vcol_off;</a>
<a name="ln3600">            }</a>
<a name="ln3601">          }</a>
<a name="ln3602"> </a>
<a name="ln3603">          {</a>
<a name="ln3604">            int vc_saved = vcol_off;</a>
<a name="ln3605"> </a>
<a name="ln3606">            // Tab alignment should be identical regardless of</a>
<a name="ln3607">            // 'conceallevel' value. So tab compensates of all</a>
<a name="ln3608">            // previous concealed characters, and thus resets</a>
<a name="ln3609">            // vcol_off and boguscols accumulated so far in the</a>
<a name="ln3610">            // line. Note that the tab can be longer than</a>
<a name="ln3611">            // 'tabstop' when there are concealed characters.</a>
<a name="ln3612">            FIX_FOR_BOGUSCOLS;</a>
<a name="ln3613"> </a>
<a name="ln3614">            // Make sure, the highlighting for the tab char will be</a>
<a name="ln3615">            // correctly set further below (effectively reverts the</a>
<a name="ln3616">            // FIX_FOR_BOGSUCOLS macro.</a>
<a name="ln3617">            if (n_extra == tab_len + vc_saved &amp;&amp; wp-&gt;w_p_list</a>
<a name="ln3618">                &amp;&amp; wp-&gt;w_p_lcs_chars.tab1) {</a>
<a name="ln3619">              tab_len += vc_saved;</a>
<a name="ln3620">            }</a>
<a name="ln3621">          }</a>
<a name="ln3622"> </a>
<a name="ln3623">          mb_utf8 = false;  // don't draw as UTF-8</a>
<a name="ln3624">          if (wp-&gt;w_p_list) {</a>
<a name="ln3625">            c = (n_extra == 0 &amp;&amp; wp-&gt;w_p_lcs_chars.tab3)</a>
<a name="ln3626">                 ? wp-&gt;w_p_lcs_chars.tab3</a>
<a name="ln3627">                 : wp-&gt;w_p_lcs_chars.tab1;</a>
<a name="ln3628">            if (wp-&gt;w_p_lbr) {</a>
<a name="ln3629">              c_extra = NUL; /* using p_extra from above */</a>
<a name="ln3630">            } else {</a>
<a name="ln3631">              c_extra = wp-&gt;w_p_lcs_chars.tab2;</a>
<a name="ln3632">            }</a>
<a name="ln3633">            c_final = wp-&gt;w_p_lcs_chars.tab3;</a>
<a name="ln3634">            n_attr = tab_len + 1;</a>
<a name="ln3635">            extra_attr = win_hl_attr(wp, HLF_0);</a>
<a name="ln3636">            saved_attr2 = char_attr;  // save current attr</a>
<a name="ln3637">            mb_c = c;</a>
<a name="ln3638">            if (utf_char2len(c) &gt; 1) {</a>
<a name="ln3639">              mb_utf8 = true;</a>
<a name="ln3640">              u8cc[0] = 0;</a>
<a name="ln3641">              c = 0xc0;</a>
<a name="ln3642">            }</a>
<a name="ln3643">          } else {</a>
<a name="ln3644">            c_final = NUL;</a>
<a name="ln3645">            c_extra = ' ';</a>
<a name="ln3646">            c = ' ';</a>
<a name="ln3647">          }</a>
<a name="ln3648">        } else if (c == NUL</a>
<a name="ln3649">                   &amp;&amp; (wp-&gt;w_p_list</a>
<a name="ln3650">                       || ((fromcol &gt;= 0 || fromcol_prev &gt;= 0)</a>
<a name="ln3651">                           &amp;&amp; tocol &gt; vcol</a>
<a name="ln3652">                           &amp;&amp; VIsual_mode != Ctrl_V</a>
<a name="ln3653">                           &amp;&amp; (wp-&gt;w_p_rl ? (col &gt;= 0) : (col &lt; grid-&gt;Columns))</a>
<a name="ln3654">                           &amp;&amp; !(noinvcur</a>
<a name="ln3655">                                &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln3656">                                &amp;&amp; (colnr_T)vcol == wp-&gt;w_virtcol)))</a>
<a name="ln3657">                   &amp;&amp; lcs_eol_one &gt; 0) {</a>
<a name="ln3658">          // Display a '$' after the line or highlight an extra</a>
<a name="ln3659">          // character if the line break is included.</a>
<a name="ln3660">          // For a diff line the highlighting continues after the &quot;$&quot;.</a>
<a name="ln3661">          if (diff_hlf == (hlf_T)0</a>
<a name="ln3662">              &amp;&amp; line_attr == 0</a>
<a name="ln3663">              &amp;&amp; line_attr_lowprio == 0) {</a>
<a name="ln3664">            // In virtualedit, visual selections may extend beyond end of line</a>
<a name="ln3665">            if (area_highlighting &amp;&amp; virtual_active()</a>
<a name="ln3666">                &amp;&amp; tocol != MAXCOL &amp;&amp; vcol &lt; tocol) {</a>
<a name="ln3667">              n_extra = 0;</a>
<a name="ln3668">            } else {</a>
<a name="ln3669">              p_extra = at_end_str;</a>
<a name="ln3670">              n_extra = 1;</a>
<a name="ln3671">              c_extra = NUL;</a>
<a name="ln3672">              c_final = NUL;</a>
<a name="ln3673">            }</a>
<a name="ln3674">          }</a>
<a name="ln3675">          if (wp-&gt;w_p_list &amp;&amp; wp-&gt;w_p_lcs_chars.eol &gt; 0) {</a>
<a name="ln3676">            c = wp-&gt;w_p_lcs_chars.eol;</a>
<a name="ln3677">          } else {</a>
<a name="ln3678">            c = ' ';</a>
<a name="ln3679">          }</a>
<a name="ln3680">          lcs_eol_one = -1;</a>
<a name="ln3681">          ptr--;  // put it back at the NUL</a>
<a name="ln3682">          extra_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln3683">          n_attr = 1;</a>
<a name="ln3684">          mb_c = c;</a>
<a name="ln3685">          if (utf_char2len(c) &gt; 1) {</a>
<a name="ln3686">            mb_utf8 = true;</a>
<a name="ln3687">            u8cc[0] = 0;</a>
<a name="ln3688">            c = 0xc0;</a>
<a name="ln3689">          } else {</a>
<a name="ln3690">            mb_utf8 = false;                    // don't draw as UTF-8</a>
<a name="ln3691">          }</a>
<a name="ln3692">        } else if (c != NUL) {</a>
<a name="ln3693">          p_extra = transchar_buf(wp-&gt;w_buffer, c);</a>
<a name="ln3694">          if (n_extra == 0) {</a>
<a name="ln3695">              n_extra = byte2cells(c) - 1;</a>
<a name="ln3696">          }</a>
<a name="ln3697">          if ((dy_flags &amp; DY_UHEX) &amp;&amp; wp-&gt;w_p_rl)</a>
<a name="ln3698">            rl_mirror(p_extra);                 /* reverse &quot;&lt;12&gt;&quot; */</a>
<a name="ln3699">          c_extra = NUL;</a>
<a name="ln3700">          c_final = NUL;</a>
<a name="ln3701">          if (wp-&gt;w_p_lbr) {</a>
<a name="ln3702">            char_u *p;</a>
<a name="ln3703"> </a>
<a name="ln3704">            c = *p_extra;</a>
<a name="ln3705">            p = xmalloc(n_extra + 1);</a>
<a name="ln3706">            memset(p, ' ', n_extra);</a>
<a name="ln3707">            STRNCPY(p, p_extra + 1, STRLEN(p_extra) - 1);</a>
<a name="ln3708">            p[n_extra] = NUL;</a>
<a name="ln3709">            xfree(p_extra_free);</a>
<a name="ln3710">            p_extra_free = p_extra = p;</a>
<a name="ln3711">          } else {</a>
<a name="ln3712">            n_extra = byte2cells(c) - 1;</a>
<a name="ln3713">            c = *p_extra++;</a>
<a name="ln3714">          }</a>
<a name="ln3715">          n_attr = n_extra + 1;</a>
<a name="ln3716">          extra_attr = win_hl_attr(wp, HLF_8);</a>
<a name="ln3717">          saved_attr2 = char_attr;  // save current attr</a>
<a name="ln3718">          mb_utf8 = false;   // don't draw as UTF-8</a>
<a name="ln3719">        } else if (VIsual_active</a>
<a name="ln3720">                   &amp;&amp; (VIsual_mode == Ctrl_V || VIsual_mode == 'v')</a>
<a name="ln3721">                   &amp;&amp; virtual_active()</a>
<a name="ln3722">                   &amp;&amp; tocol != MAXCOL</a>
<a name="ln3723">                   &amp;&amp; vcol &lt; tocol</a>
<a name="ln3724">                   &amp;&amp; (wp-&gt;w_p_rl ? (col &gt;= 0) : (col &lt; grid-&gt;Columns))) {</a>
<a name="ln3725">          c = ' ';</a>
<a name="ln3726">          ptr--;  // put it back at the NUL</a>
<a name="ln3727">        }</a>
<a name="ln3728">      }</a>
<a name="ln3729"> </a>
<a name="ln3730">      if (wp-&gt;w_p_cole &gt; 0</a>
<a name="ln3731">          &amp;&amp; (wp != curwin || lnum != wp-&gt;w_cursor.lnum</a>
<a name="ln3732">              || conceal_cursor_line(wp))</a>
<a name="ln3733">          &amp;&amp; ((syntax_flags &amp; HL_CONCEAL) != 0 || has_match_conc &gt; 0)</a>
<a name="ln3734">          &amp;&amp; !(lnum_in_visual_area</a>
<a name="ln3735">               &amp;&amp; vim_strchr(wp-&gt;w_p_cocu, 'v') == NULL)) {</a>
<a name="ln3736">        char_attr = conceal_attr;</a>
<a name="ln3737">        if ((prev_syntax_id != syntax_seqnr || has_match_conc &gt; 1)</a>
<a name="ln3738">            &amp;&amp; (syn_get_sub_char() != NUL</a>
<a name="ln3739">                || (has_match_conc &amp;&amp; match_conc)</a>
<a name="ln3740">                || wp-&gt;w_p_cole == 1)</a>
<a name="ln3741">            &amp;&amp; wp-&gt;w_p_cole != 3) {</a>
<a name="ln3742">          // First time at this concealed item: display one</a>
<a name="ln3743">          // character.</a>
<a name="ln3744">          if (has_match_conc &amp;&amp; match_conc) {</a>
<a name="ln3745">            c = match_conc;</a>
<a name="ln3746">          } else if (syn_get_sub_char() != NUL) {</a>
<a name="ln3747">            c = syn_get_sub_char();</a>
<a name="ln3748">          } else if (wp-&gt;w_p_lcs_chars.conceal != NUL) {</a>
<a name="ln3749">            c = wp-&gt;w_p_lcs_chars.conceal;</a>
<a name="ln3750">          } else {</a>
<a name="ln3751">            c = ' ';</a>
<a name="ln3752">          }</a>
<a name="ln3753"> </a>
<a name="ln3754">          prev_syntax_id = syntax_seqnr;</a>
<a name="ln3755"> </a>
<a name="ln3756">          if (n_extra &gt; 0)</a>
<a name="ln3757">            vcol_off += n_extra;</a>
<a name="ln3758">          vcol += n_extra;</a>
<a name="ln3759">          if (wp-&gt;w_p_wrap &amp;&amp; n_extra &gt; 0) {</a>
<a name="ln3760">            if (wp-&gt;w_p_rl) {</a>
<a name="ln3761">              col -= n_extra;</a>
<a name="ln3762">              boguscols -= n_extra;</a>
<a name="ln3763">            } else {</a>
<a name="ln3764">              boguscols += n_extra;</a>
<a name="ln3765">              col += n_extra;</a>
<a name="ln3766">            }</a>
<a name="ln3767">          }</a>
<a name="ln3768">          n_extra = 0;</a>
<a name="ln3769">          n_attr = 0;</a>
<a name="ln3770">        } else if (n_skip == 0) {</a>
<a name="ln3771">          is_concealing = TRUE;</a>
<a name="ln3772">          n_skip = 1;</a>
<a name="ln3773">        }</a>
<a name="ln3774">        mb_c = c;</a>
<a name="ln3775">        if (utf_char2len(c) &gt; 1) {</a>
<a name="ln3776">          mb_utf8 = true;</a>
<a name="ln3777">          u8cc[0] = 0;</a>
<a name="ln3778">          c = 0xc0;</a>
<a name="ln3779">        } else {</a>
<a name="ln3780">          mb_utf8 = false;              // don't draw as UTF-8</a>
<a name="ln3781">        }</a>
<a name="ln3782">      } else {</a>
<a name="ln3783">        prev_syntax_id = 0;</a>
<a name="ln3784">        is_concealing = FALSE;</a>
<a name="ln3785">      }</a>
<a name="ln3786"> </a>
<a name="ln3787">      if (n_skip &gt; 0 &amp;&amp; did_decrement_ptr) {</a>
<a name="ln3788">        // not showing the '&gt;', put pointer back to avoid getting stuck</a>
<a name="ln3789">        ptr++;</a>
<a name="ln3790">      }</a>
<a name="ln3791">    }  // end of printing from buffer content</a>
<a name="ln3792"> </a>
<a name="ln3793">    /* In the cursor line and we may be concealing characters: correct</a>
<a name="ln3794">     * the cursor column when we reach its position. */</a>
<a name="ln3795">    if (!did_wcol &amp;&amp; draw_state == WL_LINE</a>
<a name="ln3796">        &amp;&amp; wp == curwin &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln3797">        &amp;&amp; conceal_cursor_line(wp)</a>
<a name="ln3798">        &amp;&amp; (int)wp-&gt;w_virtcol &lt;= vcol + n_skip) {</a>
<a name="ln3799">      if (wp-&gt;w_p_rl) {</a>
<a name="ln3800">        wp-&gt;w_wcol = grid-&gt;Columns - col + boguscols - 1;</a>
<a name="ln3801">      } else {</a>
<a name="ln3802">        wp-&gt;w_wcol = col - boguscols;</a>
<a name="ln3803">      }</a>
<a name="ln3804">      wp-&gt;w_wrow = row;</a>
<a name="ln3805">      did_wcol = true;</a>
<a name="ln3806">      wp-&gt;w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;</a>
<a name="ln3807">    }</a>
<a name="ln3808"> </a>
<a name="ln3809">    // Don't override visual selection highlighting.</a>
<a name="ln3810">    if (n_attr &gt; 0 &amp;&amp; draw_state == WL_LINE &amp;&amp; !search_attr_from_match) {</a>
<a name="ln3811">      char_attr = hl_combine_attr(char_attr, extra_attr);</a>
<a name="ln3812">    }</a>
<a name="ln3813"> </a>
<a name="ln3814">    // Handle the case where we are in column 0 but not on the first</a>
<a name="ln3815">    // character of the line and the user wants us to show us a</a>
<a name="ln3816">    // special character (via 'listchars' option &quot;precedes:&lt;char&gt;&quot;.</a>
<a name="ln3817">    if (lcs_prec_todo != NUL</a>
<a name="ln3818">        &amp;&amp; wp-&gt;w_p_list</a>
<a name="ln3819">        &amp;&amp; (wp-&gt;w_p_wrap ? (wp-&gt;w_skipcol &gt; 0 &amp;&amp; row == 0) : wp-&gt;w_leftcol &gt; 0)</a>
<a name="ln3820">        &amp;&amp; filler_todo &lt;= 0</a>
<a name="ln3821">        &amp;&amp; draw_state &gt; WL_NR</a>
<a name="ln3822">        &amp;&amp; c != NUL) {</a>
<a name="ln3823">      c = wp-&gt;w_p_lcs_chars.prec;</a>
<a name="ln3824">      lcs_prec_todo = NUL;</a>
<a name="ln3825">      if ((*mb_char2cells)(mb_c) &gt; 1) {</a>
<a name="ln3826">        // Double-width character being overwritten by the &quot;precedes&quot;</a>
<a name="ln3827">        // character, need to fill up half the character.</a>
<a name="ln3828">        c_extra = MB_FILLER_CHAR;</a>
<a name="ln3829">        c_final = NUL;</a>
<a name="ln3830">        n_extra = 1;</a>
<a name="ln3831">        n_attr = 2;</a>
<a name="ln3832">        extra_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln3833">      }</a>
<a name="ln3834">      mb_c = c;</a>
<a name="ln3835">      if (utf_char2len(c) &gt; 1) {</a>
<a name="ln3836">        mb_utf8 = true;</a>
<a name="ln3837">        u8cc[0] = 0;</a>
<a name="ln3838">        c = 0xc0;</a>
<a name="ln3839">      } else {</a>
<a name="ln3840">        mb_utf8 = false;  // don't draw as UTF-8</a>
<a name="ln3841">      }</a>
<a name="ln3842">      saved_attr3 = char_attr;  // save current attr</a>
<a name="ln3843">      char_attr = win_hl_attr(wp, HLF_AT);  // overwriting char_attr</a>
<a name="ln3844">      n_attr3 = 1;</a>
<a name="ln3845">    }</a>
<a name="ln3846"> </a>
<a name="ln3847">    // At end of the text line or just after the last character.</a>
<a name="ln3848">    if (c == NUL &amp;&amp; eol_hl_off == 0) {</a>
<a name="ln3849">      long prevcol = (long)(ptr - line) - 1;</a>
<a name="ln3850"> </a>
<a name="ln3851">      // we're not really at that column when skipping some text</a>
<a name="ln3852">      if ((long)(wp-&gt;w_p_wrap ? wp-&gt;w_skipcol : wp-&gt;w_leftcol) &gt; prevcol) {</a>
<a name="ln3853">        prevcol++;</a>
<a name="ln3854">      }</a>
<a name="ln3855"> </a>
<a name="ln3856">      // Invert at least one char, used for Visual and empty line or</a>
<a name="ln3857">      // highlight match at end of line. If it's beyond the last</a>
<a name="ln3858">      // char on the screen, just overwrite that one (tricky!)  Not</a>
<a name="ln3859">      // needed when a '$' was displayed for 'list'.</a>
<a name="ln3860">      prevcol_hl_flag = false;</a>
<a name="ln3861">      if (!search_hl.is_addpos &amp;&amp; prevcol == (long)search_hl.startcol) {</a>
<a name="ln3862">        prevcol_hl_flag = true;</a>
<a name="ln3863">      } else {</a>
<a name="ln3864">        cur = wp-&gt;w_match_head;</a>
<a name="ln3865">        while (cur != NULL) {</a>
<a name="ln3866">          if (!cur-&gt;hl.is_addpos &amp;&amp; prevcol == (long)cur-&gt;hl.startcol) {</a>
<a name="ln3867">            prevcol_hl_flag = true;</a>
<a name="ln3868">            break;</a>
<a name="ln3869">          }</a>
<a name="ln3870">          cur = cur-&gt;next;</a>
<a name="ln3871">        }</a>
<a name="ln3872">      }</a>
<a name="ln3873">      if (wp-&gt;w_p_lcs_chars.eol == lcs_eol_one</a>
<a name="ln3874">          &amp;&amp; ((area_attr != 0 &amp;&amp; vcol == fromcol</a>
<a name="ln3875">               &amp;&amp; (VIsual_mode != Ctrl_V</a>
<a name="ln3876">                   || lnum == VIsual.lnum</a>
<a name="ln3877">                   || lnum == curwin-&gt;w_cursor.lnum))</a>
<a name="ln3878">              // highlight 'hlsearch' match at end of line</a>
<a name="ln3879">              || prevcol_hl_flag)) {</a>
<a name="ln3880">        int n = 0;</a>
<a name="ln3881"> </a>
<a name="ln3882">        if (wp-&gt;w_p_rl) {</a>
<a name="ln3883">          if (col &lt; 0)</a>
<a name="ln3884">            n = 1;</a>
<a name="ln3885">        } else {</a>
<a name="ln3886">          if (col &gt;= grid-&gt;Columns) {</a>
<a name="ln3887">            n = -1;</a>
<a name="ln3888">          }</a>
<a name="ln3889">        }</a>
<a name="ln3890">        if (n != 0) {</a>
<a name="ln3891">          /* At the window boundary, highlight the last character</a>
<a name="ln3892">           * instead (better than nothing). */</a>
<a name="ln3893">          off += n;</a>
<a name="ln3894">          col += n;</a>
<a name="ln3895">        } else {</a>
<a name="ln3896">          // Add a blank character to highlight.</a>
<a name="ln3897">          schar_from_ascii(linebuf_char[off], ' ');</a>
<a name="ln3898">        }</a>
<a name="ln3899">        if (area_attr == 0 &amp;&amp; !has_fold) {</a>
<a name="ln3900">          // Use attributes from match with highest priority among</a>
<a name="ln3901">          // 'search_hl' and the match list.</a>
<a name="ln3902">          char_attr = search_hl.attr;</a>
<a name="ln3903">          cur = wp-&gt;w_match_head;</a>
<a name="ln3904">          shl_flag = false;</a>
<a name="ln3905">          while (cur != NULL || !shl_flag) {</a>
<a name="ln3906">            if (!shl_flag</a>
<a name="ln3907">                &amp;&amp; (cur == NULL || cur-&gt;priority &gt; SEARCH_HL_PRIORITY)) {</a>
<a name="ln3908">              shl = &amp;search_hl;</a>
<a name="ln3909">              shl_flag = true;</a>
<a name="ln3910">            } else {</a>
<a name="ln3911">              shl = &amp;cur-&gt;hl;</a>
<a name="ln3912">            }</a>
<a name="ln3913">            if ((ptr - line) - 1 == (long)shl-&gt;startcol</a>
<a name="ln3914">                &amp;&amp; (shl == &amp;search_hl || !shl-&gt;is_addpos)) {</a>
<a name="ln3915">              char_attr = shl-&gt;attr;</a>
<a name="ln3916">            }</a>
<a name="ln3917">            if (shl != &amp;search_hl &amp;&amp; cur != NULL) {</a>
<a name="ln3918">              cur = cur-&gt;next;</a>
<a name="ln3919">            }</a>
<a name="ln3920">          }</a>
<a name="ln3921">        }</a>
<a name="ln3922"> </a>
<a name="ln3923">        int eol_attr = char_attr;</a>
<a name="ln3924">        if (wp-&gt;w_p_cul &amp;&amp; lnum == wp-&gt;w_cursor.lnum) {</a>
<a name="ln3925">          eol_attr = hl_combine_attr(win_hl_attr(wp, HLF_CUL), eol_attr);</a>
<a name="ln3926">        }</a>
<a name="ln3927">        linebuf_attr[off] = eol_attr;</a>
<a name="ln3928">        if (wp-&gt;w_p_rl) {</a>
<a name="ln3929">          --col;</a>
<a name="ln3930">          --off;</a>
<a name="ln3931">        } else {</a>
<a name="ln3932">          ++col;</a>
<a name="ln3933">          ++off;</a>
<a name="ln3934">        }</a>
<a name="ln3935">        ++vcol;</a>
<a name="ln3936">        eol_hl_off = 1;</a>
<a name="ln3937">      }</a>
<a name="ln3938">      // Highlight 'cursorcolumn' &amp; 'colorcolumn' past end of the line.</a>
<a name="ln3939">      if (wp-&gt;w_p_wrap) {</a>
<a name="ln3940">        v = wp-&gt;w_skipcol;</a>
<a name="ln3941">      } else {</a>
<a name="ln3942">        v = wp-&gt;w_leftcol;</a>
<a name="ln3943">      }</a>
<a name="ln3944"> </a>
<a name="ln3945">      /* check if line ends before left margin */</a>
<a name="ln3946">      if (vcol &lt; v + col - win_col_off(wp))</a>
<a name="ln3947">        vcol = v + col - win_col_off(wp);</a>
<a name="ln3948">      // Get rid of the boguscols now, we want to draw until the right</a>
<a name="ln3949">      // edge for 'cursorcolumn'.</a>
<a name="ln3950">      col -= boguscols;</a>
<a name="ln3951">      // boguscols = 0;  // Disabled because value never read after this</a>
<a name="ln3952"> </a>
<a name="ln3953">      if (draw_color_col)</a>
<a name="ln3954">        draw_color_col = advance_color_col(VCOL_HLC, &amp;color_cols);</a>
<a name="ln3955"> </a>
<a name="ln3956">      VirtText virt_text = KV_INITIAL_VALUE;</a>
<a name="ln3957">      bool has_aligned = false;</a>
<a name="ln3958">      if (err_text) {</a>
<a name="ln3959">        int hl_err = syn_check_group((char_u *)S_LEN(&quot;ErrorMsg&quot;));</a>
<a name="ln3960">        kv_push(virt_text, ((VirtTextChunk){ .text = err_text,</a>
<a name="ln3961">                                             .hl_id = hl_err }));</a>
<a name="ln3962">        do_virttext = true;</a>
<a name="ln3963">      } else if (has_decor) {</a>
<a name="ln3964">        virt_text = decor_redraw_eol(wp-&gt;w_buffer, &amp;decor_state, &amp;line_attr,</a>
<a name="ln3965">                                     &amp;has_aligned);</a>
<a name="ln3966">        if (kv_size(virt_text)) {</a>
<a name="ln3967">          do_virttext = true;</a>
<a name="ln3968">        }</a>
<a name="ln3969">      }</a>
<a name="ln3970"> </a>
<a name="ln3971">      if (((wp-&gt;w_p_cuc</a>
<a name="ln3972">            &amp;&amp; (int)wp-&gt;w_virtcol &gt;= VCOL_HLC - eol_hl_off</a>
<a name="ln3973">            &amp;&amp; (int)wp-&gt;w_virtcol &lt;</a>
<a name="ln3974">            grid-&gt;Columns * (row - startrow + 1) + v</a>
<a name="ln3975">            &amp;&amp; lnum != wp-&gt;w_cursor.lnum)</a>
<a name="ln3976">           || draw_color_col || line_attr_lowprio || line_attr</a>
<a name="ln3977">           || diff_hlf != (hlf_T)0 || do_virttext</a>
<a name="ln3978">           || has_aligned)) {</a>
<a name="ln3979">        int rightmost_vcol = 0;</a>
<a name="ln3980">        int i;</a>
<a name="ln3981"> </a>
<a name="ln3982">        size_t virt_pos = 0;</a>
<a name="ln3983">        LineState s = LINE_STATE(&quot;&quot;);</a>
<a name="ln3984">        int virt_attr = 0;</a>
<a name="ln3985"> </a>
<a name="ln3986">        // Make sure alignment is the same regardless</a>
<a name="ln3987">        // if listchars=eol:X is used or not.</a>
<a name="ln3988">        bool delay_virttext = wp-&gt;w_p_lcs_chars.eol == lcs_eol_one</a>
<a name="ln3989">                              &amp;&amp; eol_hl_off == 0;</a>
<a name="ln3990"> </a>
<a name="ln3991">        if (wp-&gt;w_p_cuc) {</a>
<a name="ln3992">          rightmost_vcol = wp-&gt;w_virtcol;</a>
<a name="ln3993">        }</a>
<a name="ln3994"> </a>
<a name="ln3995">        if (draw_color_col) {</a>
<a name="ln3996">          // determine rightmost colorcolumn to possibly draw</a>
<a name="ln3997">          for (i = 0; color_cols[i] &gt;= 0; i++) {</a>
<a name="ln3998">            if (rightmost_vcol &lt; color_cols[i]) {</a>
<a name="ln3999">              rightmost_vcol = color_cols[i];</a>
<a name="ln4000">            }</a>
<a name="ln4001">          }</a>
<a name="ln4002">        }</a>
<a name="ln4003"> </a>
<a name="ln4004">        int cuc_attr = win_hl_attr(wp, HLF_CUC);</a>
<a name="ln4005">        int mc_attr = win_hl_attr(wp, HLF_MC);</a>
<a name="ln4006"> </a>
<a name="ln4007">        int diff_attr = 0;</a>
<a name="ln4008">        if (diff_hlf == HLF_TXD) {</a>
<a name="ln4009">          diff_hlf = HLF_CHD;</a>
<a name="ln4010">        }</a>
<a name="ln4011">        if (diff_hlf != 0) {</a>
<a name="ln4012">          diff_attr = win_hl_attr(wp, diff_hlf);</a>
<a name="ln4013">        }</a>
<a name="ln4014"> </a>
<a name="ln4015">        int base_attr = hl_combine_attr(line_attr_lowprio, diff_attr);</a>
<a name="ln4016">        if (base_attr || line_attr || has_aligned) {</a>
<a name="ln4017">          rightmost_vcol = INT_MAX;</a>
<a name="ln4018">        }</a>
<a name="ln4019"> </a>
<a name="ln4020">        int col_stride = wp-&gt;w_p_rl ? -1 : 1;</a>
<a name="ln4021"> </a>
<a name="ln4022">        while (wp-&gt;w_p_rl ? col &gt;= 0 : col &lt; grid-&gt;Columns) {</a>
<a name="ln4023">          int cells = -1;</a>
<a name="ln4024">          if (do_virttext &amp;&amp; !delay_virttext) {</a>
<a name="ln4025">            if (*s.p == NUL) {</a>
<a name="ln4026">              if (virt_pos &lt; virt_text.size) {</a>
<a name="ln4027">                s.p = kv_A(virt_text, virt_pos).text;</a>
<a name="ln4028">                int hl_id = kv_A(virt_text, virt_pos).hl_id;</a>
<a name="ln4029">                virt_attr = hl_id &gt; 0 ? syn_id2attr(hl_id) : 0;</a>
<a name="ln4030">                virt_pos++;</a>
<a name="ln4031">              } else {</a>
<a name="ln4032">               do_virttext = false;</a>
<a name="ln4033">              }</a>
<a name="ln4034">            }</a>
<a name="ln4035">            if (*s.p != NUL) {</a>
<a name="ln4036">              cells = line_putchar(&amp;s, &amp;linebuf_char[off], grid-&gt;Columns - col,</a>
<a name="ln4037">                                   false);</a>
<a name="ln4038">            }</a>
<a name="ln4039">          }</a>
<a name="ln4040">          delay_virttext = false;</a>
<a name="ln4041"> </a>
<a name="ln4042">          if (cells == -1) {</a>
<a name="ln4043">            schar_from_ascii(linebuf_char[off], ' ');</a>
<a name="ln4044">            cells = 1;</a>
<a name="ln4045">          }</a>
<a name="ln4046">          col += cells * col_stride;</a>
<a name="ln4047">          if (draw_color_col) {</a>
<a name="ln4048">            draw_color_col = advance_color_col(VCOL_HLC, &amp;color_cols);</a>
<a name="ln4049">          }</a>
<a name="ln4050"> </a>
<a name="ln4051">          int col_attr = base_attr;</a>
<a name="ln4052"> </a>
<a name="ln4053">          if (wp-&gt;w_p_cuc &amp;&amp; VCOL_HLC == (long)wp-&gt;w_virtcol) {</a>
<a name="ln4054">            col_attr = cuc_attr;</a>
<a name="ln4055">          } else if (draw_color_col &amp;&amp; VCOL_HLC == *color_cols) {</a>
<a name="ln4056">            col_attr = mc_attr;</a>
<a name="ln4057">          }</a>
<a name="ln4058"> </a>
<a name="ln4059">          if (do_virttext) {</a>
<a name="ln4060">            col_attr = hl_combine_attr(col_attr, virt_attr);</a>
<a name="ln4061">          }</a>
<a name="ln4062"> </a>
<a name="ln4063">          col_attr = hl_combine_attr(col_attr, line_attr);</a>
<a name="ln4064"> </a>
<a name="ln4065">          linebuf_attr[off] = col_attr;</a>
<a name="ln4066">          if (cells == 2) {</a>
<a name="ln4067">            linebuf_attr[off+1] = col_attr;</a>
<a name="ln4068">          }</a>
<a name="ln4069">          off += cells * col_stride;</a>
<a name="ln4070"> </a>
<a name="ln4071">          if (VCOL_HLC &gt;= rightmost_vcol &amp;&amp; *s.p == NUL</a>
<a name="ln4072">              &amp;&amp; virt_pos &gt;= virt_text.size) {</a>
<a name="ln4073">            break;</a>
<a name="ln4074">          }</a>
<a name="ln4075"> </a>
<a name="ln4076">          vcol += cells;</a>
<a name="ln4077">        }</a>
<a name="ln4078">      }</a>
<a name="ln4079"> </a>
<a name="ln4080">      // TODO(bfredl): integrate with the common beyond-the-end-loop</a>
<a name="ln4081">      if (wp-&gt;w_buffer-&gt;terminal) {</a>
<a name="ln4082">        // terminal buffers may need to highlight beyond the end of the</a>
<a name="ln4083">        // logical line</a>
<a name="ln4084">        int n = wp-&gt;w_p_rl ? -1 : 1;</a>
<a name="ln4085">        while (col &gt;= 0 &amp;&amp; col &lt; grid-&gt;Columns) {</a>
<a name="ln4086">          schar_from_ascii(linebuf_char[off], ' ');</a>
<a name="ln4087">          linebuf_attr[off] = vcol &gt;= TERM_ATTRS_MAX ? 0 : term_attrs[vcol];</a>
<a name="ln4088">          off += n;</a>
<a name="ln4089">          vcol += n;</a>
<a name="ln4090">          col += n;</a>
<a name="ln4091">        }</a>
<a name="ln4092">      }</a>
<a name="ln4093"> </a>
<a name="ln4094">      draw_virt_text(buf, win_col_offset, &amp;col, grid-&gt;Columns);</a>
<a name="ln4095">      grid_put_linebuf(grid, row, 0, col, grid-&gt;Columns, wp-&gt;w_p_rl, wp,</a>
<a name="ln4096">                       wp-&gt;w_hl_attr_normal, false);</a>
<a name="ln4097">      row++;</a>
<a name="ln4098"> </a>
<a name="ln4099">      /*</a>
<a name="ln4100">       * Update w_cline_height and w_cline_folded if the cursor line was</a>
<a name="ln4101">       * updated (saves a call to plines() later).</a>
<a name="ln4102">       */</a>
<a name="ln4103">      if (wp == curwin &amp;&amp; lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln4104">        curwin-&gt;w_cline_row = startrow;</a>
<a name="ln4105">        curwin-&gt;w_cline_height = row - startrow;</a>
<a name="ln4106">        curwin-&gt;w_cline_folded = foldinfo.fi_lines &gt; 0;</a>
<a name="ln4107">        curwin-&gt;w_valid |= (VALID_CHEIGHT|VALID_CROW);</a>
<a name="ln4108">        conceal_cursor_used = conceal_cursor_line(curwin);</a>
<a name="ln4109">      }</a>
<a name="ln4110">      break;</a>
<a name="ln4111">    }</a>
<a name="ln4112"> </a>
<a name="ln4113">    // Show &quot;extends&quot; character from 'listchars' if beyond the line end and</a>
<a name="ln4114">    // 'list' is set.</a>
<a name="ln4115">    if (wp-&gt;w_p_lcs_chars.ext != NUL</a>
<a name="ln4116">        &amp;&amp; wp-&gt;w_p_list</a>
<a name="ln4117">        &amp;&amp; !wp-&gt;w_p_wrap</a>
<a name="ln4118">        &amp;&amp; filler_todo &lt;= 0</a>
<a name="ln4119">        &amp;&amp; (wp-&gt;w_p_rl ? col == 0 : col == grid-&gt;Columns - 1)</a>
<a name="ln4120">        &amp;&amp; !has_fold</a>
<a name="ln4121">        &amp;&amp; (*ptr != NUL</a>
<a name="ln4122">            || lcs_eol_one &gt; 0</a>
<a name="ln4123">            || (n_extra &amp;&amp; (c_extra != NUL || *p_extra != NUL)))) {</a>
<a name="ln4124">      c = wp-&gt;w_p_lcs_chars.ext;</a>
<a name="ln4125">      char_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln4126">      mb_c = c;</a>
<a name="ln4127">      if (utf_char2len(c) &gt; 1) {</a>
<a name="ln4128">        mb_utf8 = true;</a>
<a name="ln4129">        u8cc[0] = 0;</a>
<a name="ln4130">        c = 0xc0;</a>
<a name="ln4131">      } else {</a>
<a name="ln4132">        mb_utf8 = false;</a>
<a name="ln4133">      }</a>
<a name="ln4134">    }</a>
<a name="ln4135"> </a>
<a name="ln4136">    // advance to the next 'colorcolumn'</a>
<a name="ln4137">    if (draw_color_col) {</a>
<a name="ln4138">      draw_color_col = advance_color_col(VCOL_HLC, &amp;color_cols);</a>
<a name="ln4139">    }</a>
<a name="ln4140"> </a>
<a name="ln4141">    // Highlight the cursor column if 'cursorcolumn' is set.  But don't</a>
<a name="ln4142">    // highlight the cursor position itself.</a>
<a name="ln4143">    // Also highlight the 'colorcolumn' if it is different than</a>
<a name="ln4144">    // 'cursorcolumn'</a>
<a name="ln4145">    // Also highlight the 'colorcolumn' if 'breakindent' and/or 'showbreak'</a>
<a name="ln4146">    // options are set</a>
<a name="ln4147">    vcol_save_attr = -1;</a>
<a name="ln4148">    if ((draw_state == WL_LINE</a>
<a name="ln4149">         || draw_state == WL_BRI</a>
<a name="ln4150">         || draw_state == WL_SBR)</a>
<a name="ln4151">        &amp;&amp; !lnum_in_visual_area</a>
<a name="ln4152">        &amp;&amp; search_attr == 0</a>
<a name="ln4153">        &amp;&amp; area_attr == 0</a>
<a name="ln4154">        &amp;&amp; filler_todo &lt;= 0) {</a>
<a name="ln4155">      if (wp-&gt;w_p_cuc &amp;&amp; VCOL_HLC == (long)wp-&gt;w_virtcol</a>
<a name="ln4156">          &amp;&amp; lnum != wp-&gt;w_cursor.lnum) {</a>
<a name="ln4157">        vcol_save_attr = char_attr;</a>
<a name="ln4158">        char_attr = hl_combine_attr(win_hl_attr(wp, HLF_CUC), char_attr);</a>
<a name="ln4159">      } else if (draw_color_col &amp;&amp; VCOL_HLC == *color_cols) {</a>
<a name="ln4160">        vcol_save_attr = char_attr;</a>
<a name="ln4161">        char_attr = hl_combine_attr(win_hl_attr(wp, HLF_MC), char_attr);</a>
<a name="ln4162">      }</a>
<a name="ln4163">    }</a>
<a name="ln4164"> </a>
<a name="ln4165">    // Apply lowest-priority line attr now, so everything can override it.</a>
<a name="ln4166">    if (draw_state == WL_LINE) {</a>
<a name="ln4167">      char_attr = hl_combine_attr(line_attr_lowprio, char_attr);</a>
<a name="ln4168">    }</a>
<a name="ln4169"> </a>
<a name="ln4170">    // Store character to be displayed.</a>
<a name="ln4171">    // Skip characters that are left of the screen for 'nowrap'.</a>
<a name="ln4172">    vcol_prev = vcol;</a>
<a name="ln4173">    if (draw_state &lt; WL_LINE || n_skip &lt;= 0) {</a>
<a name="ln4174">      //</a>
<a name="ln4175">      // Store the character.</a>
<a name="ln4176">      //</a>
<a name="ln4177">      if (wp-&gt;w_p_rl &amp;&amp; (*mb_char2cells)(mb_c) &gt; 1) {</a>
<a name="ln4178">        // A double-wide character is: put first halve in left cell.</a>
<a name="ln4179">        off--;</a>
<a name="ln4180">        col--;</a>
<a name="ln4181">      }</a>
<a name="ln4182">      if (mb_utf8) {</a>
<a name="ln4183">        schar_from_cc(linebuf_char[off], mb_c, u8cc);</a>
<a name="ln4184">      } else {</a>
<a name="ln4185">        schar_from_ascii(linebuf_char[off], c);</a>
<a name="ln4186">      }</a>
<a name="ln4187">      if (multi_attr) {</a>
<a name="ln4188">        linebuf_attr[off] = multi_attr;</a>
<a name="ln4189">        multi_attr = 0;</a>
<a name="ln4190">      } else {</a>
<a name="ln4191">        linebuf_attr[off] = char_attr;</a>
<a name="ln4192">      }</a>
<a name="ln4193"> </a>
<a name="ln4194">      if ((*mb_char2cells)(mb_c) &gt; 1) {</a>
<a name="ln4195">        // Need to fill two screen columns.</a>
<a name="ln4196">        off++;</a>
<a name="ln4197">        col++;</a>
<a name="ln4198">        // UTF-8: Put a 0 in the second screen char.</a>
<a name="ln4199">        linebuf_char[off][0] = 0;</a>
<a name="ln4200">        if (draw_state &gt; WL_NR &amp;&amp; filler_todo &lt;= 0) {</a>
<a name="ln4201">          vcol++;</a>
<a name="ln4202">        }</a>
<a name="ln4203">        // When &quot;tocol&quot; is halfway through a character, set it to the end of</a>
<a name="ln4204">        // the character, otherwise highlighting won't stop.</a>
<a name="ln4205">        if (tocol == vcol) {</a>
<a name="ln4206">          tocol++;</a>
<a name="ln4207">        }</a>
<a name="ln4208">        if (wp-&gt;w_p_rl) {</a>
<a name="ln4209">          /* now it's time to backup one cell */</a>
<a name="ln4210">          --off;</a>
<a name="ln4211">          --col;</a>
<a name="ln4212">        }</a>
<a name="ln4213">      }</a>
<a name="ln4214">      if (wp-&gt;w_p_rl) {</a>
<a name="ln4215">        --off;</a>
<a name="ln4216">        --col;</a>
<a name="ln4217">      } else {</a>
<a name="ln4218">        ++off;</a>
<a name="ln4219">        ++col;</a>
<a name="ln4220">      }</a>
<a name="ln4221">    } else if (wp-&gt;w_p_cole &gt; 0 &amp;&amp; is_concealing) {</a>
<a name="ln4222">      --n_skip;</a>
<a name="ln4223">      ++vcol_off;</a>
<a name="ln4224">      if (n_extra &gt; 0)</a>
<a name="ln4225">        vcol_off += n_extra;</a>
<a name="ln4226">      if (wp-&gt;w_p_wrap) {</a>
<a name="ln4227">        /*</a>
<a name="ln4228">         * Special voodoo required if 'wrap' is on.</a>
<a name="ln4229">         *</a>
<a name="ln4230">         * Advance the column indicator to force the line</a>
<a name="ln4231">         * drawing to wrap early. This will make the line</a>
<a name="ln4232">         * take up the same screen space when parts are concealed,</a>
<a name="ln4233">         * so that cursor line computations aren't messed up.</a>
<a name="ln4234">         *</a>
<a name="ln4235">         * To avoid the fictitious advance of 'col' causing</a>
<a name="ln4236">         * trailing junk to be written out of the screen line</a>
<a name="ln4237">         * we are building, 'boguscols' keeps track of the number</a>
<a name="ln4238">         * of bad columns we have advanced.</a>
<a name="ln4239">         */</a>
<a name="ln4240">        if (n_extra &gt; 0) {</a>
<a name="ln4241">          vcol += n_extra;</a>
<a name="ln4242">          if (wp-&gt;w_p_rl) {</a>
<a name="ln4243">            col -= n_extra;</a>
<a name="ln4244">            boguscols -= n_extra;</a>
<a name="ln4245">          } else {</a>
<a name="ln4246">            col += n_extra;</a>
<a name="ln4247">            boguscols += n_extra;</a>
<a name="ln4248">          }</a>
<a name="ln4249">          n_extra = 0;</a>
<a name="ln4250">          n_attr = 0;</a>
<a name="ln4251">        }</a>
<a name="ln4252"> </a>
<a name="ln4253"> </a>
<a name="ln4254">        if ((*mb_char2cells)(mb_c) &gt; 1) {</a>
<a name="ln4255">          // Need to fill two screen columns.</a>
<a name="ln4256">          if (wp-&gt;w_p_rl) {</a>
<a name="ln4257">            --boguscols;</a>
<a name="ln4258">            --col;</a>
<a name="ln4259">          } else {</a>
<a name="ln4260">            ++boguscols;</a>
<a name="ln4261">            ++col;</a>
<a name="ln4262">          }</a>
<a name="ln4263">        }</a>
<a name="ln4264"> </a>
<a name="ln4265">        if (wp-&gt;w_p_rl) {</a>
<a name="ln4266">          --boguscols;</a>
<a name="ln4267">          --col;</a>
<a name="ln4268">        } else {</a>
<a name="ln4269">          ++boguscols;</a>
<a name="ln4270">          ++col;</a>
<a name="ln4271">        }</a>
<a name="ln4272">      } else {</a>
<a name="ln4273">        if (n_extra &gt; 0) {</a>
<a name="ln4274">          vcol += n_extra;</a>
<a name="ln4275">          n_extra = 0;</a>
<a name="ln4276">          n_attr = 0;</a>
<a name="ln4277">        }</a>
<a name="ln4278">      }</a>
<a name="ln4279"> </a>
<a name="ln4280">    } else</a>
<a name="ln4281">      --n_skip;</a>
<a name="ln4282"> </a>
<a name="ln4283">    /* Only advance the &quot;vcol&quot; when after the 'number' or 'relativenumber'</a>
<a name="ln4284">     * column. */</a>
<a name="ln4285">    if (draw_state &gt; WL_NR</a>
<a name="ln4286">        &amp;&amp; filler_todo &lt;= 0</a>
<a name="ln4287">        )</a>
<a name="ln4288">      ++vcol;</a>
<a name="ln4289"> </a>
<a name="ln4290">    if (vcol_save_attr &gt;= 0)</a>
<a name="ln4291">      char_attr = vcol_save_attr;</a>
<a name="ln4292"> </a>
<a name="ln4293">    /* restore attributes after &quot;predeces&quot; in 'listchars' */</a>
<a name="ln4294">    if (draw_state &gt; WL_NR &amp;&amp; n_attr3 &gt; 0 &amp;&amp; --n_attr3 == 0)</a>
<a name="ln4295">      char_attr = saved_attr3;</a>
<a name="ln4296"> </a>
<a name="ln4297">    /* restore attributes after last 'listchars' or 'number' char */</a>
<a name="ln4298">    if (n_attr &gt; 0 &amp;&amp; draw_state == WL_LINE &amp;&amp; --n_attr == 0)</a>
<a name="ln4299">      char_attr = saved_attr2;</a>
<a name="ln4300"> </a>
<a name="ln4301">    /*</a>
<a name="ln4302">     * At end of screen line and there is more to come: Display the line</a>
<a name="ln4303">     * so far.  If there is no more to display it is caught above.</a>
<a name="ln4304">     */</a>
<a name="ln4305">    if ((wp-&gt;w_p_rl ? (col &lt; 0) : (col &gt;= grid-&gt;Columns))</a>
<a name="ln4306">        &amp;&amp; foldinfo.fi_lines == 0</a>
<a name="ln4307">        &amp;&amp; (*ptr != NUL</a>
<a name="ln4308">            || filler_todo &gt; 0</a>
<a name="ln4309">            || (wp-&gt;w_p_list &amp;&amp; wp-&gt;w_p_lcs_chars.eol != NUL</a>
<a name="ln4310">                &amp;&amp; p_extra != at_end_str)</a>
<a name="ln4311">            || (n_extra != 0 &amp;&amp; (c_extra != NUL || *p_extra != NUL)))</a>
<a name="ln4312">        ) {</a>
<a name="ln4313">      bool wrap = wp-&gt;w_p_wrap       // Wrapping enabled.</a>
<a name="ln4314">        &amp;&amp; filler_todo &lt;= 0          // Not drawing diff filler lines.</a>
<a name="ln4315">        &amp;&amp; lcs_eol_one != -1         // Haven't printed the lcs_eol character.</a>
<a name="ln4316">        &amp;&amp; row != endrow - 1         // Not the last line being displayed.</a>
<a name="ln4317">        &amp;&amp; (grid-&gt;Columns == Columns  // Window spans the width of the screen,</a>
<a name="ln4318">            || ui_has(kUIMultigrid))  // or has dedicated grid.</a>
<a name="ln4319">        &amp;&amp; !wp-&gt;w_p_rl;              // Not right-to-left.</a>
<a name="ln4320"> </a>
<a name="ln4321">      int draw_col = col - boguscols;</a>
<a name="ln4322">      draw_virt_text(buf, win_col_offset, &amp;draw_col, grid-&gt;Columns);</a>
<a name="ln4323">      grid_put_linebuf(grid, row, 0, draw_col, grid-&gt;Columns, wp-&gt;w_p_rl,</a>
<a name="ln4324">                       wp, wp-&gt;w_hl_attr_normal, wrap);</a>
<a name="ln4325">      if (wrap) {</a>
<a name="ln4326">        ScreenGrid *current_grid = grid;</a>
<a name="ln4327">        int current_row = row, dummy_col = 0;  // dummy_col unused</a>
<a name="ln4328">        screen_adjust_grid(&amp;current_grid, &amp;current_row, &amp;dummy_col);</a>
<a name="ln4329"> </a>
<a name="ln4330">        // Force a redraw of the first column of the next line.</a>
<a name="ln4331">        current_grid-&gt;attrs[current_grid-&gt;line_offset[current_row+1]] = -1;</a>
<a name="ln4332"> </a>
<a name="ln4333">        // Remember that the line wraps, used for modeless copy.</a>
<a name="ln4334">        current_grid-&gt;line_wraps[current_row] = true;</a>
<a name="ln4335">      }</a>
<a name="ln4336"> </a>
<a name="ln4337">      boguscols = 0;</a>
<a name="ln4338">      row++;</a>
<a name="ln4339"> </a>
<a name="ln4340">      /* When not wrapping and finished diff lines, or when displayed</a>
<a name="ln4341">       * '$' and highlighting until last column, break here. */</a>
<a name="ln4342">      if ((!wp-&gt;w_p_wrap</a>
<a name="ln4343">           &amp;&amp; filler_todo &lt;= 0</a>
<a name="ln4344">           ) || lcs_eol_one == -1)</a>
<a name="ln4345">        break;</a>
<a name="ln4346"> </a>
<a name="ln4347">      // When the window is too narrow draw all &quot;@&quot; lines.</a>
<a name="ln4348">      if (draw_state != WL_LINE &amp;&amp; filler_todo &lt;= 0) {</a>
<a name="ln4349">        win_draw_end(wp, '@', ' ', true, row, wp-&gt;w_grid.Rows, HLF_AT);</a>
<a name="ln4350">        row = endrow;</a>
<a name="ln4351">      }</a>
<a name="ln4352"> </a>
<a name="ln4353">      /* When line got too long for screen break here. */</a>
<a name="ln4354">      if (row == endrow) {</a>
<a name="ln4355">        ++row;</a>
<a name="ln4356">        break;</a>
<a name="ln4357">      }</a>
<a name="ln4358"> </a>
<a name="ln4359">      col = 0;</a>
<a name="ln4360">      off = 0;</a>
<a name="ln4361">      if (wp-&gt;w_p_rl) {</a>
<a name="ln4362">        col = grid-&gt;Columns - 1;  // col is not used if breaking!</a>
<a name="ln4363">        off += col;</a>
<a name="ln4364">      }</a>
<a name="ln4365"> </a>
<a name="ln4366">      /* reset the drawing state for the start of a wrapped line */</a>
<a name="ln4367">      draw_state = WL_START;</a>
<a name="ln4368">      saved_n_extra = n_extra;</a>
<a name="ln4369">      saved_p_extra = p_extra;</a>
<a name="ln4370">      saved_c_extra = c_extra;</a>
<a name="ln4371">      saved_c_final = c_final;</a>
<a name="ln4372">      saved_char_attr = char_attr;</a>
<a name="ln4373">      n_extra = 0;</a>
<a name="ln4374">      lcs_prec_todo = wp-&gt;w_p_lcs_chars.prec;</a>
<a name="ln4375">      if (filler_todo &lt;= 0) {</a>
<a name="ln4376">        need_showbreak = true;</a>
<a name="ln4377">      }</a>
<a name="ln4378">      filler_todo--;</a>
<a name="ln4379">      // When the filler lines are actually below the last line of the</a>
<a name="ln4380">      // file, don't draw the line itself, break here.</a>
<a name="ln4381">      if (filler_todo == 0 &amp;&amp; wp-&gt;w_botfill) {</a>
<a name="ln4382">        break;</a>
<a name="ln4383">      }</a>
<a name="ln4384">    }</a>
<a name="ln4385"> </a>
<a name="ln4386">  }     /* for every character in the line */</a>
<a name="ln4387"> </a>
<a name="ln4388">  /* After an empty line check first word for capital. */</a>
<a name="ln4389">  if (*skipwhite(line) == NUL) {</a>
<a name="ln4390">    capcol_lnum = lnum + 1;</a>
<a name="ln4391">    cap_col = 0;</a>
<a name="ln4392">  }</a>
<a name="ln4393"> </a>
<a name="ln4394">  xfree(p_extra_free);</a>
<a name="ln4395">  xfree(err_text);</a>
<a name="ln4396">  return row;</a>
<a name="ln4397">}</a>
<a name="ln4398"> </a>
<a name="ln4399">void draw_virt_text(buf_T *buf, int col_off, int *end_col, int max_col)</a>
<a name="ln4400">{</a>
<a name="ln4401">  DecorState *state = &amp;decor_state;</a>
<a name="ln4402">  int right_pos = max_col;</a>
<a name="ln4403">  for (size_t i = 0; i &lt; kv_size(state-&gt;active); i++) {</a>
<a name="ln4404">    DecorRange *item = &amp;kv_A(state-&gt;active, i);</a>
<a name="ln4405">    if (item-&gt;start_row == state-&gt;row &amp;&amp; kv_size(item-&gt;decor.virt_text)) {</a>
<a name="ln4406">      if (item-&gt;win_col == -1) {</a>
<a name="ln4407">        if (item-&gt;decor.virt_text_pos == kVTRightAlign) {</a>
<a name="ln4408">          right_pos -= item-&gt;decor.col;</a>
<a name="ln4409">          item-&gt;win_col = right_pos;</a>
<a name="ln4410">        } else if (item-&gt;decor.virt_text_pos == kVTWinCol) {</a>
<a name="ln4411">          item-&gt;win_col = MAX(item-&gt;decor.col+col_off, 0);</a>
<a name="ln4412">        }</a>
<a name="ln4413">      }</a>
<a name="ln4414">      if (item-&gt;win_col &lt; 0) {</a>
<a name="ln4415">        continue;</a>
<a name="ln4416">      }</a>
<a name="ln4417">      VirtText vt = item-&gt;decor.virt_text;</a>
<a name="ln4418">      HlMode hl_mode = item-&gt;decor.hl_mode;</a>
<a name="ln4419">      LineState s = LINE_STATE(&quot;&quot;);</a>
<a name="ln4420">      int virt_attr = 0;</a>
<a name="ln4421">      int col = item-&gt;win_col;</a>
<a name="ln4422">      size_t virt_pos = 0;</a>
<a name="ln4423">      item-&gt;win_col = -2;  // deactivate</a>
<a name="ln4424"> </a>
<a name="ln4425">      while (col &lt; max_col) {</a>
<a name="ln4426">        if (!*s.p) {</a>
<a name="ln4427">          if (virt_pos == kv_size(vt)) {</a>
<a name="ln4428">            break;</a>
<a name="ln4429">          }</a>
<a name="ln4430">          s.p = kv_A(vt, virt_pos).text;</a>
<a name="ln4431">          int hl_id = kv_A(vt, virt_pos).hl_id;</a>
<a name="ln4432">          virt_attr = hl_id &gt; 0 ? syn_id2attr(hl_id) : 0;</a>
<a name="ln4433">          virt_pos++;</a>
<a name="ln4434">          continue;</a>
<a name="ln4435">        }</a>
<a name="ln4436">        int attr;</a>
<a name="ln4437">        bool through = false;</a>
<a name="ln4438">        if (hl_mode == kHlModeCombine) {</a>
<a name="ln4439">          attr = hl_combine_attr(linebuf_attr[col], virt_attr);</a>
<a name="ln4440">        } else if (hl_mode == kHlModeBlend) {</a>
<a name="ln4441">          through = (*s.p == ' ');</a>
<a name="ln4442">          attr = hl_blend_attrs(linebuf_attr[col], virt_attr, &amp;through);</a>
<a name="ln4443">        } else {</a>
<a name="ln4444">          attr = virt_attr;</a>
<a name="ln4445">        }</a>
<a name="ln4446">        schar_T dummy[2];</a>
<a name="ln4447">        int cells = line_putchar(&amp;s, through ? dummy : &amp;linebuf_char[col],</a>
<a name="ln4448">                                 max_col-col, false);</a>
<a name="ln4449">        linebuf_attr[col++] = attr;</a>
<a name="ln4450">        if (cells &gt; 1) {</a>
<a name="ln4451">          linebuf_attr[col++] = attr;</a>
<a name="ln4452">        }</a>
<a name="ln4453">      }</a>
<a name="ln4454">      *end_col = MAX(*end_col, col);</a>
<a name="ln4455">    }</a>
<a name="ln4456">  }</a>
<a name="ln4457">}</a>
<a name="ln4458"> </a>
<a name="ln4459">/// Determine if dedicated window grid should be used or the default_grid</a>
<a name="ln4460">///</a>
<a name="ln4461">/// If UI did not request multigrid support, draw all windows on the</a>
<a name="ln4462">/// default_grid.</a>
<a name="ln4463">///</a>
<a name="ln4464">/// NB: this function can only been used with window grids in a context where</a>
<a name="ln4465">/// win_grid_alloc already has been called!</a>
<a name="ln4466">///</a>
<a name="ln4467">/// If the default_grid is used, adjust window relative positions to global</a>
<a name="ln4468">/// screen positions.</a>
<a name="ln4469">void screen_adjust_grid(ScreenGrid **grid, int *row_off, int *col_off)</a>
<a name="ln4470">{</a>
<a name="ln4471">  if ((*grid)-&gt;target) {</a>
<a name="ln4472">    *row_off += (*grid)-&gt;row_offset;</a>
<a name="ln4473">    *col_off += (*grid)-&gt;col_offset;</a>
<a name="ln4474">    *grid = (*grid)-&gt;target;</a>
<a name="ln4475">  }</a>
<a name="ln4476">}</a>
<a name="ln4477"> </a>
<a name="ln4478">// Get information needed to display the sign in line 'lnum' in window 'wp'.</a>
<a name="ln4479">// If 'nrcol' is TRUE, the sign is going to be displayed in the number column.</a>
<a name="ln4480">// Otherwise the sign is going to be displayed in the sign column.</a>
<a name="ln4481">//</a>
<a name="ln4482">// @param count max number of signs</a>
<a name="ln4483">// @param[out] n_extrap number of characters from pp_extra to display</a>
<a name="ln4484">// @param[in, out] sign_idxp Index of the displayed sign</a>
<a name="ln4485">static void get_sign_display_info(</a>
<a name="ln4486">    bool nrcol,</a>
<a name="ln4487">    win_T *wp,</a>
<a name="ln4488">    sign_attrs_T sattrs[],</a>
<a name="ln4489">    int row,</a>
<a name="ln4490">    int startrow,</a>
<a name="ln4491">    int filler_lines,</a>
<a name="ln4492">    int filler_todo,</a>
<a name="ln4493">    int count,</a>
<a name="ln4494">    int *c_extrap,</a>
<a name="ln4495">    int *c_finalp,</a>
<a name="ln4496">    char_u *extra,</a>
<a name="ln4497">    size_t extra_size,</a>
<a name="ln4498">    char_u **pp_extra,</a>
<a name="ln4499">    int *n_extrap,</a>
<a name="ln4500">    int *char_attrp,</a>
<a name="ln4501">    int *draw_statep,</a>
<a name="ln4502">    int *sign_idxp</a>
<a name="ln4503">)</a>
<a name="ln4504">{</a>
<a name="ln4505">  // Draw cells with the sign value or blank.</a>
<a name="ln4506">  *c_extrap = ' ';</a>
<a name="ln4507">  *c_finalp = NUL;</a>
<a name="ln4508">  if (nrcol) {</a>
<a name="ln4509">    *n_extrap = number_width(wp) + 1;</a>
<a name="ln4510">  } else {</a>
<a name="ln4511">    *char_attrp = win_hl_attr(wp, HLF_SC);</a>
<a name="ln4512">    *n_extrap = win_signcol_width(wp);</a>
<a name="ln4513">  }</a>
<a name="ln4514"> </a>
<a name="ln4515">  if (row == startrow + filler_lines &amp;&amp; filler_todo &lt;= 0) {</a>
<a name="ln4516">    sign_attrs_T *sattr = sign_get_attr(SIGN_TEXT, sattrs, *sign_idxp, count);</a>
<a name="ln4517">    if (sattr != NULL) {</a>
<a name="ln4518">      *pp_extra = sattr-&gt;sat_text;</a>
<a name="ln4519">      if (*pp_extra != NULL) {</a>
<a name="ln4520">        *c_extrap = NUL;</a>
<a name="ln4521">        *c_finalp = NUL;</a>
<a name="ln4522"> </a>
<a name="ln4523">        if (nrcol) {</a>
<a name="ln4524">          int n, width = number_width(wp) - 2;</a>
<a name="ln4525">          for (n = 0; n &lt; width; n++) {</a>
<a name="ln4526">            extra[n] = ' ';</a>
<a name="ln4527">          }</a>
<a name="ln4528">          extra[n] = NUL;</a>
<a name="ln4529">          STRCAT(extra, *pp_extra);</a>
<a name="ln4530">          STRCAT(extra, &quot; &quot;);</a>
<a name="ln4531">          *pp_extra = extra;</a>
<a name="ln4532">          *n_extrap = (int)STRLEN(*pp_extra);</a>
<a name="ln4533">        } else {</a>
<a name="ln4534">          int symbol_blen = (int)STRLEN(*pp_extra);</a>
<a name="ln4535"> </a>
<a name="ln4536">          // TODO(oni-link): Is sign text already extended to</a>
<a name="ln4537">          // full cell width?</a>
<a name="ln4538">          assert((size_t)win_signcol_width(wp) &gt;= mb_string2cells(*pp_extra));</a>
<a name="ln4539">          // symbol(s) bytes + (filling spaces) (one byte each)</a>
<a name="ln4540">          *n_extrap = symbol_blen +</a>
<a name="ln4541">            (win_signcol_width(wp) - mb_string2cells(*pp_extra));</a>
<a name="ln4542"> </a>
<a name="ln4543">          assert(extra_size &gt; (size_t)symbol_blen);</a>
<a name="ln4544">          memset(extra, ' ', extra_size);</a>
<a name="ln4545">          memcpy(extra, *pp_extra, symbol_blen);</a>
<a name="ln4546"> </a>
<a name="ln4547">          *pp_extra = extra;</a>
<a name="ln4548">          (*pp_extra)[*n_extrap] = NUL;</a>
<a name="ln4549">        }</a>
<a name="ln4550">      }</a>
<a name="ln4551">      *char_attrp = sattr-&gt;sat_texthl;</a>
<a name="ln4552">    }</a>
<a name="ln4553">  }</a>
<a name="ln4554"> </a>
<a name="ln4555">  (*sign_idxp)++;</a>
<a name="ln4556">  if (*sign_idxp &lt; count) {</a>
<a name="ln4557">    *draw_statep = WL_SIGN - 1;</a>
<a name="ln4558">  } else {</a>
<a name="ln4559">    *sign_idxp = 0;</a>
<a name="ln4560">  }</a>
<a name="ln4561">}</a>
<a name="ln4562"> </a>
<a name="ln4563"> </a>
<a name="ln4564">/*</a>
<a name="ln4565"> * Check whether the given character needs redrawing:</a>
<a name="ln4566"> * - the (first byte of the) character is different</a>
<a name="ln4567"> * - the attributes are different</a>
<a name="ln4568"> * - the character is multi-byte and the next byte is different</a>
<a name="ln4569"> * - the character is two cells wide and the second cell differs.</a>
<a name="ln4570"> */</a>
<a name="ln4571">static int grid_char_needs_redraw(ScreenGrid *grid, int off_from, int off_to,</a>
<a name="ln4572">                                  int cols)</a>
<a name="ln4573">{</a>
<a name="ln4574">  return (cols &gt; 0</a>
<a name="ln4575">          &amp;&amp; ((schar_cmp(linebuf_char[off_from], grid-&gt;chars[off_to])</a>
<a name="ln4576">               || linebuf_attr[off_from] != grid-&gt;attrs[off_to]</a>
<a name="ln4577">               || (line_off2cells(linebuf_char, off_from, off_from + cols) &gt; 1</a>
<a name="ln4578">                   &amp;&amp; schar_cmp(linebuf_char[off_from + 1],</a>
<a name="ln4579">                                grid-&gt;chars[off_to + 1])))</a>
<a name="ln4580">              || rdb_flags &amp; RDB_NODELTA));</a>
<a name="ln4581">}</a>
<a name="ln4582"> </a>
<a name="ln4583">/// Move one buffered line to the window grid, but only the characters that</a>
<a name="ln4584">/// have actually changed.  Handle insert/delete character.</a>
<a name="ln4585">/// &quot;coloff&quot; gives the first column on the grid for this line.</a>
<a name="ln4586">/// &quot;endcol&quot; gives the columns where valid characters are.</a>
<a name="ln4587">/// &quot;clear_width&quot; is the width of the window.  It's &gt; 0 if the rest of the line</a>
<a name="ln4588">/// needs to be cleared, negative otherwise.</a>
<a name="ln4589">/// &quot;rlflag&quot; is TRUE in a rightleft window:</a>
<a name="ln4590">///    When TRUE and &quot;clear_width&quot; &gt; 0, clear columns 0 to &quot;endcol&quot;</a>
<a name="ln4591">///    When FALSE and &quot;clear_width&quot; &gt; 0, clear columns &quot;endcol&quot; to &quot;clear_width&quot;</a>
<a name="ln4592">/// If &quot;wrap&quot; is true, then hint to the UI that &quot;row&quot; contains a line</a>
<a name="ln4593">/// which has wrapped into the next row.</a>
<a name="ln4594">static void grid_put_linebuf(ScreenGrid *grid, int row, int coloff, int endcol,</a>
<a name="ln4595">                             int clear_width, int rlflag, win_T *wp,</a>
<a name="ln4596">                             int bg_attr, bool wrap)</a>
<a name="ln4597">{</a>
<a name="ln4598">  unsigned off_from;</a>
<a name="ln4599">  unsigned off_to;</a>
<a name="ln4600">  unsigned max_off_from;</a>
<a name="ln4601">  unsigned max_off_to;</a>
<a name="ln4602">  int col = 0;</a>
<a name="ln4603">  bool redraw_this;                         // Does character need redraw?</a>
<a name="ln4604">  bool redraw_next;                         // redraw_this for next character</a>
<a name="ln4605">  bool clear_next = false;</a>
<a name="ln4606">  int char_cells;                           // 1: normal char</a>
<a name="ln4607">                                            // 2: occupies two display cells</a>
<a name="ln4608">  int start_dirty = -1, end_dirty = 0;</a>
<a name="ln4609"> </a>
<a name="ln4610">  // TODO(bfredl): check all callsites and eliminate</a>
<a name="ln4611">  // Check for illegal row and col, just in case</a>
<a name="ln4612">  if (row &gt;= grid-&gt;Rows) {</a>
<a name="ln4613">    row = grid-&gt;Rows - 1;</a>
<a name="ln4614">  }</a>
<a name="ln4615">  if (endcol &gt; grid-&gt;Columns) {</a>
<a name="ln4616">    endcol = grid-&gt;Columns;</a>
<a name="ln4617">  }</a>
<a name="ln4618"> </a>
<a name="ln4619">  screen_adjust_grid(&amp;grid, &amp;row, &amp;coloff);</a>
<a name="ln4620"> </a>
<a name="ln4621">  // Safety check. Avoids clang warnings down the call stack.</a>
<a name="ln4622">  if (grid-&gt;chars == NULL || row &gt;= grid-&gt;Rows || coloff &gt;= grid-&gt;Columns) {</a>
<a name="ln4623">    DLOG(&quot;invalid state, skipped&quot;);</a>
<a name="ln4624">    return;</a>
<a name="ln4625">  }</a>
<a name="ln4626"> </a>
<a name="ln4627">  off_from = 0;</a>
<a name="ln4628">  off_to = grid-&gt;line_offset[row] + coloff;</a>
<a name="ln4629">  max_off_from = linebuf_size;</a>
<a name="ln4630">  max_off_to = grid-&gt;line_offset[row] + grid-&gt;Columns;</a>
<a name="ln4631"> </a>
<a name="ln4632">  if (rlflag) {</a>
<a name="ln4633">    /* Clear rest first, because it's left of the text. */</a>
<a name="ln4634">    if (clear_width &gt; 0) {</a>
<a name="ln4635">      while (col &lt;= endcol &amp;&amp; grid-&gt;chars[off_to][0] == ' '</a>
<a name="ln4636">             &amp;&amp; grid-&gt;chars[off_to][1] == NUL</a>
<a name="ln4637">             &amp;&amp; grid-&gt;attrs[off_to] == bg_attr</a>
<a name="ln4638">             ) {</a>
<a name="ln4639">        ++off_to;</a>
<a name="ln4640">        ++col;</a>
<a name="ln4641">      }</a>
<a name="ln4642">      if (col &lt;= endcol) {</a>
<a name="ln4643">        grid_fill(grid, row, row + 1, col + coloff, endcol + coloff + 1,</a>
<a name="ln4644">                  ' ', ' ', bg_attr);</a>
<a name="ln4645">      }</a>
<a name="ln4646">    }</a>
<a name="ln4647">    col = endcol + 1;</a>
<a name="ln4648">    off_to = grid-&gt;line_offset[row] + col + coloff;</a>
<a name="ln4649">    off_from += col;</a>
<a name="ln4650">    endcol = (clear_width &gt; 0 ? clear_width : -clear_width);</a>
<a name="ln4651">  }</a>
<a name="ln4652"> </a>
<a name="ln4653">  if (bg_attr) {</a>
<a name="ln4654">    for (int c = col; c &lt; endcol; c++) {</a>
<a name="ln4655">      linebuf_attr[off_from+c] =</a>
<a name="ln4656">        hl_combine_attr(bg_attr, linebuf_attr[off_from+c]);</a>
<a name="ln4657">    }</a>
<a name="ln4658">  }</a>
<a name="ln4659"> </a>
<a name="ln4660">  redraw_next = grid_char_needs_redraw(grid, off_from, off_to, endcol - col);</a>
<a name="ln4661"> </a>
<a name="ln4662">  while (col &lt; endcol) {</a>
<a name="ln4663">    char_cells = 1;</a>
<a name="ln4664">    if (col + 1 &lt; endcol) {</a>
<a name="ln4665">      char_cells = line_off2cells(linebuf_char, off_from, max_off_from);</a>
<a name="ln4666">    }</a>
<a name="ln4667">    redraw_this = redraw_next;</a>
<a name="ln4668">    redraw_next = grid_char_needs_redraw(grid, off_from + char_cells,</a>
<a name="ln4669">                                         off_to + char_cells,</a>
<a name="ln4670">                                         endcol - col - char_cells);</a>
<a name="ln4671"> </a>
<a name="ln4672">    if (redraw_this) {</a>
<a name="ln4673">      if (start_dirty == -1) {</a>
<a name="ln4674">        start_dirty = col;</a>
<a name="ln4675">      }</a>
<a name="ln4676">      end_dirty = col + char_cells;</a>
<a name="ln4677">      // When writing a single-width character over a double-width</a>
<a name="ln4678">      // character and at the end of the redrawn text, need to clear out</a>
<a name="ln4679">      // the right halve of the old character.</a>
<a name="ln4680">      // Also required when writing the right halve of a double-width</a>
<a name="ln4681">      // char over the left halve of an existing one</a>
<a name="ln4682">      if (col + char_cells == endcol</a>
<a name="ln4683">          &amp;&amp; ((char_cells == 1</a>
<a name="ln4684">               &amp;&amp; grid_off2cells(grid, off_to, max_off_to) &gt; 1)</a>
<a name="ln4685">              || (char_cells == 2</a>
<a name="ln4686">                  &amp;&amp; grid_off2cells(grid, off_to, max_off_to) == 1</a>
<a name="ln4687">                  &amp;&amp; grid_off2cells(grid, off_to + 1, max_off_to) &gt; 1))) {</a>
<a name="ln4688">        clear_next = true;</a>
<a name="ln4689">      }</a>
<a name="ln4690"> </a>
<a name="ln4691">      schar_copy(grid-&gt;chars[off_to], linebuf_char[off_from]);</a>
<a name="ln4692">      if (char_cells == 2) {</a>
<a name="ln4693">        schar_copy(grid-&gt;chars[off_to+1], linebuf_char[off_from+1]);</a>
<a name="ln4694">      }</a>
<a name="ln4695"> </a>
<a name="ln4696">      grid-&gt;attrs[off_to] = linebuf_attr[off_from];</a>
<a name="ln4697">      // For simplicity set the attributes of second half of a</a>
<a name="ln4698">      // double-wide character equal to the first half.</a>
<a name="ln4699">      if (char_cells == 2) {</a>
<a name="ln4700">        grid-&gt;attrs[off_to + 1] = linebuf_attr[off_from];</a>
<a name="ln4701">      }</a>
<a name="ln4702">    }</a>
<a name="ln4703"> </a>
<a name="ln4704">    off_to += char_cells;</a>
<a name="ln4705">    off_from += char_cells;</a>
<a name="ln4706">    col += char_cells;</a>
<a name="ln4707">  }</a>
<a name="ln4708"> </a>
<a name="ln4709">  if (clear_next) {</a>
<a name="ln4710">    /* Clear the second half of a double-wide character of which the left</a>
<a name="ln4711">     * half was overwritten with a single-wide character. */</a>
<a name="ln4712">    schar_from_ascii(grid-&gt;chars[off_to], ' ');</a>
<a name="ln4713">    end_dirty++;</a>
<a name="ln4714">  }</a>
<a name="ln4715"> </a>
<a name="ln4716">  int clear_end = -1;</a>
<a name="ln4717">  if (clear_width &gt; 0 &amp;&amp; !rlflag) {</a>
<a name="ln4718">    // blank out the rest of the line</a>
<a name="ln4719">    // TODO(bfredl): we could cache winline widths</a>
<a name="ln4720">    while (col &lt; clear_width) {</a>
<a name="ln4721">      if (grid-&gt;chars[off_to][0] != ' '</a>
<a name="ln4722">          || grid-&gt;chars[off_to][1] != NUL</a>
<a name="ln4723">          || grid-&gt;attrs[off_to] != bg_attr) {</a>
<a name="ln4724">        grid-&gt;chars[off_to][0] = ' ';</a>
<a name="ln4725">        grid-&gt;chars[off_to][1] = NUL;</a>
<a name="ln4726">        grid-&gt;attrs[off_to] = bg_attr;</a>
<a name="ln4727">        if (start_dirty == -1) {</a>
<a name="ln4728">          start_dirty = col;</a>
<a name="ln4729">          end_dirty = col;</a>
<a name="ln4730">        } else if (clear_end == -1) {</a>
<a name="ln4731">          end_dirty = endcol;</a>
<a name="ln4732">        }</a>
<a name="ln4733">        clear_end = col+1;</a>
<a name="ln4734">      }</a>
<a name="ln4735">      col++;</a>
<a name="ln4736">      off_to++;</a>
<a name="ln4737">    }</a>
<a name="ln4738">  }</a>
<a name="ln4739"> </a>
<a name="ln4740">  if (clear_width &gt; 0 || wp-&gt;w_width != grid-&gt;Columns) {</a>
<a name="ln4741">    // If we cleared after the end of the line, it did not wrap.</a>
<a name="ln4742">    // For vsplit, line wrapping is not possible.</a>
<a name="ln4743">    grid-&gt;line_wraps[row] = false;</a>
<a name="ln4744">  }</a>
<a name="ln4745"> </a>
<a name="ln4746">  if (clear_end &lt; end_dirty) {</a>
<a name="ln4747">    clear_end = end_dirty;</a>
<a name="ln4748">  }</a>
<a name="ln4749">  if (start_dirty == -1) {</a>
<a name="ln4750">    start_dirty = end_dirty;</a>
<a name="ln4751">  }</a>
<a name="ln4752">  if (clear_end &gt; start_dirty) {</a>
<a name="ln4753">    ui_line(grid, row, coloff+start_dirty, coloff+end_dirty, coloff+clear_end,</a>
<a name="ln4754">            bg_attr, wrap);</a>
<a name="ln4755">  }</a>
<a name="ln4756">}</a>
<a name="ln4757"> </a>
<a name="ln4758">/*</a>
<a name="ln4759"> * Mirror text &quot;str&quot; for right-left displaying.</a>
<a name="ln4760"> * Only works for single-byte characters (e.g., numbers).</a>
<a name="ln4761"> */</a>
<a name="ln4762">void rl_mirror(char_u *str)</a>
<a name="ln4763">{</a>
<a name="ln4764">  char_u      *p1, *p2;</a>
<a name="ln4765">  int t;</a>
<a name="ln4766"> </a>
<a name="ln4767">  for (p1 = str, p2 = str + STRLEN(str) - 1; p1 &lt; p2; ++p1, --p2) {</a>
<a name="ln4768">    t = *p1;</a>
<a name="ln4769">    *p1 = *p2;</a>
<a name="ln4770">    *p2 = t;</a>
<a name="ln4771">  }</a>
<a name="ln4772">}</a>
<a name="ln4773"> </a>
<a name="ln4774">/*</a>
<a name="ln4775"> * mark all status lines for redraw; used after first :cd</a>
<a name="ln4776"> */</a>
<a name="ln4777">void status_redraw_all(void)</a>
<a name="ln4778">{</a>
<a name="ln4779"> </a>
<a name="ln4780">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4781">    if (wp-&gt;w_status_height) {</a>
<a name="ln4782">      wp-&gt;w_redr_status = true;</a>
<a name="ln4783">      redraw_later(wp, VALID);</a>
<a name="ln4784">    }</a>
<a name="ln4785">  }</a>
<a name="ln4786">}</a>
<a name="ln4787"> </a>
<a name="ln4788">/// Marks all status lines of the current buffer for redraw.</a>
<a name="ln4789">void status_redraw_curbuf(void)</a>
<a name="ln4790">{</a>
<a name="ln4791">  status_redraw_buf(curbuf);</a>
<a name="ln4792">}</a>
<a name="ln4793"> </a>
<a name="ln4794">/// Marks all status lines of the specified buffer for redraw.</a>
<a name="ln4795">void status_redraw_buf(buf_T *buf)</a>
<a name="ln4796">{</a>
<a name="ln4797">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4798">    if (wp-&gt;w_status_height != 0 &amp;&amp; wp-&gt;w_buffer == buf) {</a>
<a name="ln4799">      wp-&gt;w_redr_status = true;</a>
<a name="ln4800">      redraw_later(wp, VALID);</a>
<a name="ln4801">    }</a>
<a name="ln4802">  }</a>
<a name="ln4803">}</a>
<a name="ln4804"> </a>
<a name="ln4805">/*</a>
<a name="ln4806"> * Redraw all status lines that need to be redrawn.</a>
<a name="ln4807"> */</a>
<a name="ln4808">void redraw_statuslines(void)</a>
<a name="ln4809">{</a>
<a name="ln4810">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4811">    if (wp-&gt;w_redr_status) {</a>
<a name="ln4812">      win_redr_status(wp);</a>
<a name="ln4813">    }</a>
<a name="ln4814">  }</a>
<a name="ln4815">  if (redraw_tabline)</a>
<a name="ln4816">    draw_tabline();</a>
<a name="ln4817">}</a>
<a name="ln4818"> </a>
<a name="ln4819">/*</a>
<a name="ln4820"> * Redraw all status lines at the bottom of frame &quot;frp&quot;.</a>
<a name="ln4821"> */</a>
<a name="ln4822">void win_redraw_last_status(const frame_T *frp)</a>
<a name="ln4823">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln4824">{</a>
<a name="ln4825">  if (frp-&gt;fr_layout == FR_LEAF) {</a>
<a name="ln4826">    frp-&gt;fr_win-&gt;w_redr_status = true;</a>
<a name="ln4827">  } else if (frp-&gt;fr_layout == FR_ROW) {</a>
<a name="ln4828">    FOR_ALL_FRAMES(frp, frp-&gt;fr_child) {</a>
<a name="ln4829">      win_redraw_last_status(frp);</a>
<a name="ln4830">    }</a>
<a name="ln4831">  } else {</a>
<a name="ln4832">    assert(frp-&gt;fr_layout == FR_COL);</a>
<a name="ln4833">    frp = frp-&gt;fr_child;</a>
<a name="ln4834">    while (frp-&gt;fr_next != NULL) {</a>
<a name="ln4835">      frp = frp-&gt;fr_next;</a>
<a name="ln4836">    }</a>
<a name="ln4837">    win_redraw_last_status(frp);</a>
<a name="ln4838">  }</a>
<a name="ln4839">}</a>
<a name="ln4840"> </a>
<a name="ln4841">/*</a>
<a name="ln4842"> * Draw the verticap separator right of window &quot;wp&quot; starting with line &quot;row&quot;.</a>
<a name="ln4843"> */</a>
<a name="ln4844">static void draw_vsep_win(win_T *wp, int row)</a>
<a name="ln4845">{</a>
<a name="ln4846">  int hl;</a>
<a name="ln4847">  int c;</a>
<a name="ln4848"> </a>
<a name="ln4849">  if (wp-&gt;w_vsep_width) {</a>
<a name="ln4850">    // draw the vertical separator right of this window</a>
<a name="ln4851">    c = fillchar_vsep(wp, &amp;hl);</a>
<a name="ln4852">    grid_fill(&amp;default_grid, wp-&gt;w_winrow + row, W_ENDROW(wp),</a>
<a name="ln4853">              W_ENDCOL(wp), W_ENDCOL(wp) + 1, c, ' ', hl);</a>
<a name="ln4854">  }</a>
<a name="ln4855">}</a>
<a name="ln4856"> </a>
<a name="ln4857"> </a>
<a name="ln4858">/*</a>
<a name="ln4859"> * Get the length of an item as it will be shown in the status line.</a>
<a name="ln4860"> */</a>
<a name="ln4861">static int status_match_len(expand_T *xp, char_u *s)</a>
<a name="ln4862">{</a>
<a name="ln4863">  int len = 0;</a>
<a name="ln4864"> </a>
<a name="ln4865">  int emenu = (xp-&gt;xp_context == EXPAND_MENUS</a>
<a name="ln4866">               || xp-&gt;xp_context == EXPAND_MENUNAMES);</a>
<a name="ln4867"> </a>
<a name="ln4868">  /* Check for menu separators - replace with '|'. */</a>
<a name="ln4869">  if (emenu &amp;&amp; menu_is_separator(s))</a>
<a name="ln4870">    return 1;</a>
<a name="ln4871"> </a>
<a name="ln4872">  while (*s != NUL) {</a>
<a name="ln4873">    s += skip_status_match_char(xp, s);</a>
<a name="ln4874">    len += ptr2cells(s);</a>
<a name="ln4875">    MB_PTR_ADV(s);</a>
<a name="ln4876">  }</a>
<a name="ln4877"> </a>
<a name="ln4878">  return len;</a>
<a name="ln4879">}</a>
<a name="ln4880"> </a>
<a name="ln4881">/*</a>
<a name="ln4882"> * Return the number of characters that should be skipped in a status match.</a>
<a name="ln4883"> * These are backslashes used for escaping.  Do show backslashes in help tags.</a>
<a name="ln4884"> */</a>
<a name="ln4885">static int skip_status_match_char(expand_T *xp, char_u *s)</a>
<a name="ln4886">{</a>
<a name="ln4887">  if ((rem_backslash(s) &amp;&amp; xp-&gt;xp_context != EXPAND_HELP)</a>
<a name="ln4888">      || ((xp-&gt;xp_context == EXPAND_MENUS</a>
<a name="ln4889">           || xp-&gt;xp_context == EXPAND_MENUNAMES)</a>
<a name="ln4890">          &amp;&amp; (s[0] == '\t' || (s[0] == '\\' &amp;&amp; s[1] != NUL)))</a>
<a name="ln4891">      ) {</a>
<a name="ln4892">#ifndef BACKSLASH_IN_FILENAME</a>
<a name="ln4893">    if (xp-&gt;xp_shell &amp;&amp; csh_like_shell() &amp;&amp; s[1] == '\\' &amp;&amp; s[2] == '!')</a>
<a name="ln4894">      return 2;</a>
<a name="ln4895">#endif</a>
<a name="ln4896">    return 1;</a>
<a name="ln4897">  }</a>
<a name="ln4898">  return 0;</a>
<a name="ln4899">}</a>
<a name="ln4900"> </a>
<a name="ln4901">/*</a>
<a name="ln4902"> * Show wildchar matches in the status line.</a>
<a name="ln4903"> * Show at least the &quot;match&quot; item.</a>
<a name="ln4904"> * We start at item 'first_match' in the list and show all matches that fit.</a>
<a name="ln4905"> *</a>
<a name="ln4906"> * If inversion is possible we use it. Else '=' characters are used.</a>
<a name="ln4907"> */</a>
<a name="ln4908">void</a>
<a name="ln4909">win_redr_status_matches (</a>
<a name="ln4910">    expand_T *xp,</a>
<a name="ln4911">    int num_matches,</a>
<a name="ln4912">    char_u **matches,          /* list of matches */</a>
<a name="ln4913">    int match,</a>
<a name="ln4914">    int showtail</a>
<a name="ln4915">)</a>
<a name="ln4916">{</a>
<a name="ln4917">#define L_MATCH(m) (showtail ? sm_gettail(matches[m], false) : matches[m])</a>
<a name="ln4918">  int row;</a>
<a name="ln4919">  char_u      *buf;</a>
<a name="ln4920">  int len;</a>
<a name="ln4921">  int clen;                     /* length in screen cells */</a>
<a name="ln4922">  int fillchar;</a>
<a name="ln4923">  int attr;</a>
<a name="ln4924">  int i;</a>
<a name="ln4925">  int highlight = TRUE;</a>
<a name="ln4926">  char_u      *selstart = NULL;</a>
<a name="ln4927">  int selstart_col = 0;</a>
<a name="ln4928">  char_u      *selend = NULL;</a>
<a name="ln4929">  static int first_match = 0;</a>
<a name="ln4930">  int add_left = FALSE;</a>
<a name="ln4931">  char_u      *s;</a>
<a name="ln4932">  int emenu;</a>
<a name="ln4933">  int l;</a>
<a name="ln4934"> </a>
<a name="ln4935">  if (matches == NULL)          /* interrupted completion? */</a>
<a name="ln4936">    return;</a>
<a name="ln4937"> </a>
<a name="ln4938">  buf = xmalloc(Columns * MB_MAXBYTES + 1);</a>
<a name="ln4939"> </a>
<a name="ln4940">  if (match == -1) {    /* don't show match but original text */</a>
<a name="ln4941">    match = 0;</a>
<a name="ln4942">    highlight = FALSE;</a>
<a name="ln4943">  }</a>
<a name="ln4944">  /* count 1 for the ending &quot;&gt;&quot; */</a>
<a name="ln4945">  clen = status_match_len(xp, L_MATCH(match)) + 3;</a>
<a name="ln4946">  if (match == 0)</a>
<a name="ln4947">    first_match = 0;</a>
<a name="ln4948">  else if (match &lt; first_match) {</a>
<a name="ln4949">    /* jumping left, as far as we can go */</a>
<a name="ln4950">    first_match = match;</a>
<a name="ln4951">    add_left = TRUE;</a>
<a name="ln4952">  } else {</a>
<a name="ln4953">    /* check if match fits on the screen */</a>
<a name="ln4954">    for (i = first_match; i &lt; match; ++i)</a>
<a name="ln4955">      clen += status_match_len(xp, L_MATCH(i)) + 2;</a>
<a name="ln4956">    if (first_match &gt; 0)</a>
<a name="ln4957">      clen += 2;</a>
<a name="ln4958">    // jumping right, put match at the left</a>
<a name="ln4959">    if ((long)clen &gt; Columns) {</a>
<a name="ln4960">      first_match = match;</a>
<a name="ln4961">      /* if showing the last match, we can add some on the left */</a>
<a name="ln4962">      clen = 2;</a>
<a name="ln4963">      for (i = match; i &lt; num_matches; ++i) {</a>
<a name="ln4964">        clen += status_match_len(xp, L_MATCH(i)) + 2;</a>
<a name="ln4965">        if ((long)clen &gt;= Columns) {</a>
<a name="ln4966">          break;</a>
<a name="ln4967">        }</a>
<a name="ln4968">      }</a>
<a name="ln4969">      if (i == num_matches)</a>
<a name="ln4970">        add_left = TRUE;</a>
<a name="ln4971">    }</a>
<a name="ln4972">  }</a>
<a name="ln4973">  if (add_left)</a>
<a name="ln4974">    while (first_match &gt; 0) {</a>
<a name="ln4975">      clen += status_match_len(xp, L_MATCH(first_match - 1)) + 2;</a>
<a name="ln4976">      if ((long)clen &gt;= Columns) {</a>
<a name="ln4977">        break;</a>
<a name="ln4978">      }</a>
<a name="ln4979">      first_match--;</a>
<a name="ln4980">    }</a>
<a name="ln4981"> </a>
<a name="ln4982">  fillchar = fillchar_status(&amp;attr, curwin);</a>
<a name="ln4983"> </a>
<a name="ln4984">  if (first_match == 0) {</a>
<a name="ln4985">    *buf = NUL;</a>
<a name="ln4986">    len = 0;</a>
<a name="ln4987">  } else {</a>
<a name="ln4988">    STRCPY(buf, &quot;&lt; &quot;);</a>
<a name="ln4989">    len = 2;</a>
<a name="ln4990">  }</a>
<a name="ln4991">  clen = len;</a>
<a name="ln4992"> </a>
<a name="ln4993">  i = first_match;</a>
<a name="ln4994">  while ((long)(clen + status_match_len(xp, L_MATCH(i)) + 2) &lt; Columns) {</a>
<a name="ln4995">    if (i == match) {</a>
<a name="ln4996">      selstart = buf + len;</a>
<a name="ln4997">      selstart_col = clen;</a>
<a name="ln4998">    }</a>
<a name="ln4999"> </a>
<a name="ln5000">    s = L_MATCH(i);</a>
<a name="ln5001">    /* Check for menu separators - replace with '|' */</a>
<a name="ln5002">    emenu = (xp-&gt;xp_context == EXPAND_MENUS</a>
<a name="ln5003">             || xp-&gt;xp_context == EXPAND_MENUNAMES);</a>
<a name="ln5004">    if (emenu &amp;&amp; menu_is_separator(s)) {</a>
<a name="ln5005">      STRCPY(buf + len, transchar('|'));</a>
<a name="ln5006">      l = (int)STRLEN(buf + len);</a>
<a name="ln5007">      len += l;</a>
<a name="ln5008">      clen += l;</a>
<a name="ln5009">    } else</a>
<a name="ln5010">      for (; *s != NUL; ++s) {</a>
<a name="ln5011">        s += skip_status_match_char(xp, s);</a>
<a name="ln5012">        clen += ptr2cells(s);</a>
<a name="ln5013">        if ((l = (*mb_ptr2len)(s)) &gt; 1) {</a>
<a name="ln5014">          STRNCPY(buf + len, s, l);  // NOLINT(runtime/printf)</a>
<a name="ln5015">          s += l - 1;</a>
<a name="ln5016">          len += l;</a>
<a name="ln5017">        } else {</a>
<a name="ln5018">          STRCPY(buf + len, transchar_byte(*s));</a>
<a name="ln5019">          len += (int)STRLEN(buf + len);</a>
<a name="ln5020">        }</a>
<a name="ln5021">      }</a>
<a name="ln5022">    if (i == match)</a>
<a name="ln5023">      selend = buf + len;</a>
<a name="ln5024"> </a>
<a name="ln5025">    *(buf + len++) = ' ';</a>
<a name="ln5026">    *(buf + len++) = ' ';</a>
<a name="ln5027">    clen += 2;</a>
<a name="ln5028">    if (++i == num_matches)</a>
<a name="ln5029">      break;</a>
<a name="ln5030">  }</a>
<a name="ln5031"> </a>
<a name="ln5032">  if (i != num_matches) {</a>
<a name="ln5033">    *(buf + len++) = '&gt;';</a>
<a name="ln5034">    ++clen;</a>
<a name="ln5035">  }</a>
<a name="ln5036"> </a>
<a name="ln5037">  buf[len] = NUL;</a>
<a name="ln5038"> </a>
<a name="ln5039">  row = cmdline_row - 1;</a>
<a name="ln5040">  if (row &gt;= 0) {</a>
<a name="ln5041">    if (wild_menu_showing == 0 || wild_menu_showing == WM_LIST) {</a>
<a name="ln5042">      if (msg_scrolled &gt; 0) {</a>
<a name="ln5043">        /* Put the wildmenu just above the command line.  If there is</a>
<a name="ln5044">         * no room, scroll the screen one line up. */</a>
<a name="ln5045">        if (cmdline_row == Rows - 1) {</a>
<a name="ln5046">          msg_scroll_up(false);</a>
<a name="ln5047">          msg_scrolled++;</a>
<a name="ln5048">        } else {</a>
<a name="ln5049">          cmdline_row++;</a>
<a name="ln5050">          row++;</a>
<a name="ln5051">        }</a>
<a name="ln5052">        wild_menu_showing = WM_SCROLLED;</a>
<a name="ln5053">      } else {</a>
<a name="ln5054">        /* Create status line if needed by setting 'laststatus' to 2.</a>
<a name="ln5055">         * Set 'winminheight' to zero to avoid that the window is</a>
<a name="ln5056">         * resized. */</a>
<a name="ln5057">        if (lastwin-&gt;w_status_height == 0) {</a>
<a name="ln5058">          save_p_ls = p_ls;</a>
<a name="ln5059">          save_p_wmh = p_wmh;</a>
<a name="ln5060">          p_ls = 2;</a>
<a name="ln5061">          p_wmh = 0;</a>
<a name="ln5062">          last_status(FALSE);</a>
<a name="ln5063">        }</a>
<a name="ln5064">        wild_menu_showing = WM_SHOWN;</a>
<a name="ln5065">      }</a>
<a name="ln5066">    }</a>
<a name="ln5067"> </a>
<a name="ln5068">    // Tricky: wildmenu can be drawn either over a status line, or at empty</a>
<a name="ln5069">    // scrolled space in the message output</a>
<a name="ln5070">    ScreenGrid *grid = (wild_menu_showing == WM_SCROLLED)</a>
<a name="ln5071">                        ? &amp;msg_grid_adj : &amp;default_grid;</a>
<a name="ln5072"> </a>
<a name="ln5073">    grid_puts(grid, buf, row, 0, attr);</a>
<a name="ln5074">    if (selstart != NULL &amp;&amp; highlight) {</a>
<a name="ln5075">      *selend = NUL;</a>
<a name="ln5076">      grid_puts(grid, selstart, row, selstart_col, HL_ATTR(HLF_WM));</a>
<a name="ln5077">    }</a>
<a name="ln5078"> </a>
<a name="ln5079">    grid_fill(grid, row, row + 1, clen, Columns,</a>
<a name="ln5080">              fillchar, fillchar, attr);</a>
<a name="ln5081">  }</a>
<a name="ln5082"> </a>
<a name="ln5083">  win_redraw_last_status(topframe);</a>
<a name="ln5084">  xfree(buf);</a>
<a name="ln5085">}</a>
<a name="ln5086"> </a>
<a name="ln5087">/// Redraw the status line of window `wp`.</a>
<a name="ln5088">///</a>
<a name="ln5089">/// If inversion is possible we use it. Else '=' characters are used.</a>
<a name="ln5090">static void win_redr_status(win_T *wp)</a>
<a name="ln5091">{</a>
<a name="ln5092">  int row;</a>
<a name="ln5093">  char_u      *p;</a>
<a name="ln5094">  int len;</a>
<a name="ln5095">  int fillchar;</a>
<a name="ln5096">  int attr;</a>
<a name="ln5097">  int this_ru_col;</a>
<a name="ln5098">  static int busy = FALSE;</a>
<a name="ln5099"> </a>
<a name="ln5100">  // May get here recursively when 'statusline' (indirectly)</a>
<a name="ln5101">  // invokes &quot;:redrawstatus&quot;.  Simply ignore the call then.</a>
<a name="ln5102">  if (busy</a>
<a name="ln5103">      // Also ignore if wildmenu is showing.</a>
<a name="ln5104">      || (wild_menu_showing != 0 &amp;&amp; !ui_has(kUIWildmenu))) {</a>
<a name="ln5105">    return;</a>
<a name="ln5106">  }</a>
<a name="ln5107">  busy = true;</a>
<a name="ln5108"> </a>
<a name="ln5109">  wp-&gt;w_redr_status = FALSE;</a>
<a name="ln5110">  if (wp-&gt;w_status_height == 0) {</a>
<a name="ln5111">    // no status line, can only be last window</a>
<a name="ln5112">    redraw_cmdline = true;</a>
<a name="ln5113">  } else if (!redrawing()) {</a>
<a name="ln5114">    // Don't redraw right now, do it later. Don't update status line when</a>
<a name="ln5115">    // popup menu is visible and may be drawn over it</a>
<a name="ln5116">    wp-&gt;w_redr_status = true;</a>
<a name="ln5117">  } else if (*p_stl != NUL || *wp-&gt;w_p_stl != NUL) {</a>
<a name="ln5118">    /* redraw custom status line */</a>
<a name="ln5119">    redraw_custom_statusline(wp);</a>
<a name="ln5120">  } else {</a>
<a name="ln5121">    fillchar = fillchar_status(&amp;attr, wp);</a>
<a name="ln5122"> </a>
<a name="ln5123">    get_trans_bufname(wp-&gt;w_buffer);</a>
<a name="ln5124">    p = NameBuff;</a>
<a name="ln5125">    len = (int)STRLEN(p);</a>
<a name="ln5126"> </a>
<a name="ln5127">    if (bt_help(wp-&gt;w_buffer)</a>
<a name="ln5128">        || wp-&gt;w_p_pvw</a>
<a name="ln5129">        || bufIsChanged(wp-&gt;w_buffer)</a>
<a name="ln5130">        || wp-&gt;w_buffer-&gt;b_p_ro) {</a>
<a name="ln5131">      *(p + len++) = ' ';</a>
<a name="ln5132">    }</a>
<a name="ln5133">    if (bt_help(wp-&gt;w_buffer)) {</a>
<a name="ln5134">      STRCPY(p + len, _(&quot;[Help]&quot;));</a>
<a name="ln5135">      len += (int)STRLEN(p + len);</a>
<a name="ln5136">    }</a>
<a name="ln5137">    if (wp-&gt;w_p_pvw) {</a>
<a name="ln5138">      STRCPY(p + len, _(&quot;[Preview]&quot;));</a>
<a name="ln5139">      len += (int)STRLEN(p + len);</a>
<a name="ln5140">    }</a>
<a name="ln5141">    if (bufIsChanged(wp-&gt;w_buffer)) {</a>
<a name="ln5142">      STRCPY(p + len, &quot;[+]&quot;);</a>
<a name="ln5143">      len += 3;</a>
<a name="ln5144">    }</a>
<a name="ln5145">    if (wp-&gt;w_buffer-&gt;b_p_ro) {</a>
<a name="ln5146">      STRCPY(p + len, _(&quot;[RO]&quot;));</a>
<a name="ln5147">      // len += (int)STRLEN(p + len);  // dead assignment</a>
<a name="ln5148">    }</a>
<a name="ln5149"> </a>
<a name="ln5150">    this_ru_col = ru_col - (Columns - wp-&gt;w_width);</a>
<a name="ln5151">    if (this_ru_col &lt; (wp-&gt;w_width + 1) / 2) {</a>
<a name="ln5152">      this_ru_col = (wp-&gt;w_width + 1) / 2;</a>
<a name="ln5153">    }</a>
<a name="ln5154">    if (this_ru_col &lt;= 1) {</a>
<a name="ln5155">      p = (char_u *)&quot;&lt;&quot;;                // No room for file name!</a>
<a name="ln5156">      len = 1;</a>
<a name="ln5157">    } else {</a>
<a name="ln5158">      int clen = 0, i;</a>
<a name="ln5159"> </a>
<a name="ln5160">      // Count total number of display cells.</a>
<a name="ln5161">      clen = (int)mb_string2cells(p);</a>
<a name="ln5162"> </a>
<a name="ln5163">      // Find first character that will fit.</a>
<a name="ln5164">      // Going from start to end is much faster for DBCS.</a>
<a name="ln5165">      for (i = 0; p[i] != NUL &amp;&amp; clen &gt;= this_ru_col - 1;</a>
<a name="ln5166">           i += utfc_ptr2len(p + i)) {</a>
<a name="ln5167">        clen -= utf_ptr2cells(p + i);</a>
<a name="ln5168">      }</a>
<a name="ln5169">      len = clen;</a>
<a name="ln5170">      if (i &gt; 0) {</a>
<a name="ln5171">        p = p + i - 1;</a>
<a name="ln5172">        *p = '&lt;';</a>
<a name="ln5173">        ++len;</a>
<a name="ln5174">      }</a>
<a name="ln5175">    }</a>
<a name="ln5176"> </a>
<a name="ln5177">    row = W_ENDROW(wp);</a>
<a name="ln5178">    grid_puts(&amp;default_grid, p, row, wp-&gt;w_wincol, attr);</a>
<a name="ln5179">    grid_fill(&amp;default_grid, row, row + 1, len + wp-&gt;w_wincol,</a>
<a name="ln5180">              this_ru_col + wp-&gt;w_wincol, fillchar, fillchar, attr);</a>
<a name="ln5181"> </a>
<a name="ln5182">    if (get_keymap_str(wp, (char_u *)&quot;&lt;%s&gt;&quot;, NameBuff, MAXPATHL)</a>
<a name="ln5183">        &amp;&amp; this_ru_col - len &gt; (int)(STRLEN(NameBuff) + 1))</a>
<a name="ln5184">      grid_puts(&amp;default_grid, NameBuff, row,</a>
<a name="ln5185">                (int)(this_ru_col - STRLEN(NameBuff) - 1), attr);</a>
<a name="ln5186"> </a>
<a name="ln5187">    win_redr_ruler(wp, TRUE);</a>
<a name="ln5188">  }</a>
<a name="ln5189"> </a>
<a name="ln5190">  /*</a>
<a name="ln5191">   * May need to draw the character below the vertical separator.</a>
<a name="ln5192">   */</a>
<a name="ln5193">  if (wp-&gt;w_vsep_width != 0 &amp;&amp; wp-&gt;w_status_height != 0 &amp;&amp; redrawing()) {</a>
<a name="ln5194">    if (stl_connected(wp)) {</a>
<a name="ln5195">      fillchar = fillchar_status(&amp;attr, wp);</a>
<a name="ln5196">    } else {</a>
<a name="ln5197">      fillchar = fillchar_vsep(wp, &amp;attr);</a>
<a name="ln5198">    }</a>
<a name="ln5199">    grid_putchar(&amp;default_grid, fillchar, W_ENDROW(wp), W_ENDCOL(wp), attr);</a>
<a name="ln5200">  }</a>
<a name="ln5201">  busy = FALSE;</a>
<a name="ln5202">}</a>
<a name="ln5203"> </a>
<a name="ln5204">/*</a>
<a name="ln5205"> * Redraw the status line according to 'statusline' and take care of any</a>
<a name="ln5206"> * errors encountered.</a>
<a name="ln5207"> */</a>
<a name="ln5208">static void redraw_custom_statusline(win_T *wp)</a>
<a name="ln5209">{</a>
<a name="ln5210">  static int entered = false;</a>
<a name="ln5211">  int saved_did_emsg = did_emsg;</a>
<a name="ln5212"> </a>
<a name="ln5213">  /* When called recursively return.  This can happen when the statusline</a>
<a name="ln5214">   * contains an expression that triggers a redraw. */</a>
<a name="ln5215">  if (entered)</a>
<a name="ln5216">    return;</a>
<a name="ln5217">  entered = TRUE;</a>
<a name="ln5218"> </a>
<a name="ln5219">  did_emsg = false;</a>
<a name="ln5220">  win_redr_custom(wp, false);</a>
<a name="ln5221">  if (did_emsg) {</a>
<a name="ln5222">    // When there is an error disable the statusline, otherwise the</a>
<a name="ln5223">    // display is messed up with errors and a redraw triggers the problem</a>
<a name="ln5224">    // again and again.</a>
<a name="ln5225">    set_string_option_direct(&quot;statusline&quot;, -1, (char_u *)&quot;&quot;,</a>
<a name="ln5226">                             OPT_FREE | (*wp-&gt;w_p_stl != NUL</a>
<a name="ln5227">                                         ? OPT_LOCAL : OPT_GLOBAL), SID_ERROR);</a>
<a name="ln5228">  }</a>
<a name="ln5229">  did_emsg |= saved_did_emsg;</a>
<a name="ln5230">  entered = false;</a>
<a name="ln5231">}</a>
<a name="ln5232"> </a>
<a name="ln5233">/*</a>
<a name="ln5234"> * Return TRUE if the status line of window &quot;wp&quot; is connected to the status</a>
<a name="ln5235"> * line of the window right of it.  If not, then it's a vertical separator.</a>
<a name="ln5236"> * Only call if (wp-&gt;w_vsep_width != 0).</a>
<a name="ln5237"> */</a>
<a name="ln5238">int stl_connected(win_T *wp)</a>
<a name="ln5239">{</a>
<a name="ln5240">  frame_T     *fr;</a>
<a name="ln5241"> </a>
<a name="ln5242">  fr = wp-&gt;w_frame;</a>
<a name="ln5243">  while (fr-&gt;fr_parent != NULL) {</a>
<a name="ln5244">    if (fr-&gt;fr_parent-&gt;fr_layout == FR_COL) {</a>
<a name="ln5245">      if (fr-&gt;fr_next != NULL)</a>
<a name="ln5246">        break;</a>
<a name="ln5247">    } else {</a>
<a name="ln5248">      if (fr-&gt;fr_next != NULL)</a>
<a name="ln5249">        return TRUE;</a>
<a name="ln5250">    }</a>
<a name="ln5251">    fr = fr-&gt;fr_parent;</a>
<a name="ln5252">  }</a>
<a name="ln5253">  return FALSE;</a>
<a name="ln5254">}</a>
<a name="ln5255"> </a>
<a name="ln5256"> </a>
<a name="ln5257">/*</a>
<a name="ln5258"> * Get the value to show for the language mappings, active 'keymap'.</a>
<a name="ln5259"> */</a>
<a name="ln5260">int</a>
<a name="ln5261">get_keymap_str (</a>
<a name="ln5262">    win_T *wp,</a>
<a name="ln5263">    char_u *fmt,        // format string containing one %s item</a>
<a name="ln5264">    char_u *buf,        // buffer for the result</a>
<a name="ln5265">    int len             // length of buffer</a>
<a name="ln5266">)</a>
<a name="ln5267">{</a>
<a name="ln5268">  char_u      *p;</a>
<a name="ln5269"> </a>
<a name="ln5270">  if (wp-&gt;w_buffer-&gt;b_p_iminsert != B_IMODE_LMAP)</a>
<a name="ln5271">    return FALSE;</a>
<a name="ln5272"> </a>
<a name="ln5273">  {</a>
<a name="ln5274">    buf_T   *old_curbuf = curbuf;</a>
<a name="ln5275">    win_T   *old_curwin = curwin;</a>
<a name="ln5276">    char_u  *s;</a>
<a name="ln5277"> </a>
<a name="ln5278">    curbuf = wp-&gt;w_buffer;</a>
<a name="ln5279">    curwin = wp;</a>
<a name="ln5280">    STRCPY(buf, &quot;b:keymap_name&quot;);       /* must be writable */</a>
<a name="ln5281">    ++emsg_skip;</a>
<a name="ln5282">    s = p = eval_to_string(buf, NULL, FALSE);</a>
<a name="ln5283">    --emsg_skip;</a>
<a name="ln5284">    curbuf = old_curbuf;</a>
<a name="ln5285">    curwin = old_curwin;</a>
<a name="ln5286">    if (p == NULL || *p == NUL) {</a>
<a name="ln5287">      if (wp-&gt;w_buffer-&gt;b_kmap_state &amp; KEYMAP_LOADED) {</a>
<a name="ln5288">        p = wp-&gt;w_buffer-&gt;b_p_keymap;</a>
<a name="ln5289">      } else {</a>
<a name="ln5290">        p = (char_u *)&quot;lang&quot;;</a>
<a name="ln5291">      }</a>
<a name="ln5292">    }</a>
<a name="ln5293">    if (vim_snprintf((char *)buf, len, (char *)fmt, p) &gt; len - 1) {</a>
<a name="ln5294">      buf[0] = NUL;</a>
<a name="ln5295">    }</a>
<a name="ln5296">    xfree(s);</a>
<a name="ln5297">  }</a>
<a name="ln5298">  return buf[0] != NUL;</a>
<a name="ln5299">}</a>
<a name="ln5300"> </a>
<a name="ln5301">/*</a>
<a name="ln5302"> * Redraw the status line or ruler of window &quot;wp&quot;.</a>
<a name="ln5303"> * When &quot;wp&quot; is NULL redraw the tab pages line from 'tabline'.</a>
<a name="ln5304"> */</a>
<a name="ln5305">static void</a>
<a name="ln5306">win_redr_custom (</a>
<a name="ln5307">    win_T *wp,</a>
<a name="ln5308">    bool draw_ruler</a>
<a name="ln5309">)</a>
<a name="ln5310">{</a>
<a name="ln5311">  static int entered = FALSE;</a>
<a name="ln5312">  int attr;</a>
<a name="ln5313">  int curattr;</a>
<a name="ln5314">  int row;</a>
<a name="ln5315">  int col = 0;</a>
<a name="ln5316">  int maxwidth;</a>
<a name="ln5317">  int width;</a>
<a name="ln5318">  int n;</a>
<a name="ln5319">  int len;</a>
<a name="ln5320">  int fillchar;</a>
<a name="ln5321">  char_u buf[MAXPATHL];</a>
<a name="ln5322">  char_u      *stl;</a>
<a name="ln5323">  char_u      *p;</a>
<a name="ln5324">  stl_hlrec_t *hltab;</a>
<a name="ln5325">  StlClickRecord *tabtab;</a>
<a name="ln5326">  int use_sandbox = false;</a>
<a name="ln5327">  win_T       *ewp;</a>
<a name="ln5328">  int p_crb_save;</a>
<a name="ln5329"> </a>
<a name="ln5330">  ScreenGrid *grid = &amp;default_grid;</a>
<a name="ln5331"> </a>
<a name="ln5332">  /* There is a tiny chance that this gets called recursively: When</a>
<a name="ln5333">   * redrawing a status line triggers redrawing the ruler or tabline.</a>
<a name="ln5334">   * Avoid trouble by not allowing recursion. */</a>
<a name="ln5335">  if (entered)</a>
<a name="ln5336">    return;</a>
<a name="ln5337">  entered = TRUE;</a>
<a name="ln5338"> </a>
<a name="ln5339">  /* setup environment for the task at hand */</a>
<a name="ln5340">  if (wp == NULL) {</a>
<a name="ln5341">    /* Use 'tabline'.  Always at the first line of the screen. */</a>
<a name="ln5342">    stl = p_tal;</a>
<a name="ln5343">    row = 0;</a>
<a name="ln5344">    fillchar = ' ';</a>
<a name="ln5345">    attr = HL_ATTR(HLF_TPF);</a>
<a name="ln5346">    maxwidth = Columns;</a>
<a name="ln5347">    use_sandbox = was_set_insecurely(wp, (char_u *)&quot;tabline&quot;, 0);</a>
<a name="ln5348">  } else {</a>
<a name="ln5349">    row = W_ENDROW(wp);</a>
<a name="ln5350">    fillchar = fillchar_status(&amp;attr, wp);</a>
<a name="ln5351">    maxwidth = wp-&gt;w_width;</a>
<a name="ln5352"> </a>
<a name="ln5353">    if (draw_ruler) {</a>
<a name="ln5354">      stl = p_ruf;</a>
<a name="ln5355">      /* advance past any leading group spec - implicit in ru_col */</a>
<a name="ln5356">      if (*stl == '%') {</a>
<a name="ln5357">        if (*++stl == '-')</a>
<a name="ln5358">          stl++;</a>
<a name="ln5359">        if (atoi((char *)stl))</a>
<a name="ln5360">          while (ascii_isdigit(*stl))</a>
<a name="ln5361">            stl++;</a>
<a name="ln5362">        if (*stl++ != '(')</a>
<a name="ln5363">          stl = p_ruf;</a>
<a name="ln5364">      }</a>
<a name="ln5365">      col = ru_col - (Columns - wp-&gt;w_width);</a>
<a name="ln5366">      if (col &lt; (wp-&gt;w_width + 1) / 2) {</a>
<a name="ln5367">        col = (wp-&gt;w_width + 1) / 2;</a>
<a name="ln5368">      }</a>
<a name="ln5369">      maxwidth = wp-&gt;w_width - col;</a>
<a name="ln5370">      if (!wp-&gt;w_status_height) {</a>
<a name="ln5371">        grid = &amp;msg_grid_adj;</a>
<a name="ln5372">        row = Rows - 1;</a>
<a name="ln5373">        maxwidth--;  // writing in last column may cause scrolling</a>
<a name="ln5374">        fillchar = ' ';</a>
<a name="ln5375">        attr = HL_ATTR(HLF_MSG);</a>
<a name="ln5376">      }</a>
<a name="ln5377"> </a>
<a name="ln5378">      use_sandbox = was_set_insecurely(wp, (char_u *)&quot;rulerformat&quot;, 0);</a>
<a name="ln5379">    } else {</a>
<a name="ln5380">      if (*wp-&gt;w_p_stl != NUL)</a>
<a name="ln5381">        stl = wp-&gt;w_p_stl;</a>
<a name="ln5382">      else</a>
<a name="ln5383">        stl = p_stl;</a>
<a name="ln5384">      use_sandbox = was_set_insecurely(</a>
<a name="ln5385">          wp, (char_u *)&quot;statusline&quot;, *wp-&gt;w_p_stl == NUL ? 0 : OPT_LOCAL);</a>
<a name="ln5386">    }</a>
<a name="ln5387"> </a>
<a name="ln5388">    col += wp-&gt;w_wincol;</a>
<a name="ln5389">  }</a>
<a name="ln5390"> </a>
<a name="ln5391">  if (maxwidth &lt;= 0)</a>
<a name="ln5392">    goto theend;</a>
<a name="ln5393"> </a>
<a name="ln5394">  /* Temporarily reset 'cursorbind', we don't want a side effect from moving</a>
<a name="ln5395">   * the cursor away and back. */</a>
<a name="ln5396">  ewp = wp == NULL ? curwin : wp;</a>
<a name="ln5397">  p_crb_save = ewp-&gt;w_p_crb;</a>
<a name="ln5398">  ewp-&gt;w_p_crb = FALSE;</a>
<a name="ln5399"> </a>
<a name="ln5400">  /* Make a copy, because the statusline may include a function call that</a>
<a name="ln5401">   * might change the option value and free the memory. */</a>
<a name="ln5402">  stl = vim_strsave(stl);</a>
<a name="ln5403">  width =</a>
<a name="ln5404">    build_stl_str_hl(ewp, buf, sizeof(buf), stl, use_sandbox,</a>
<a name="ln5405">                     fillchar, maxwidth, &amp;hltab, &amp;tabtab);</a>
<a name="ln5406">  xfree(stl);</a>
<a name="ln5407">  ewp-&gt;w_p_crb = p_crb_save;</a>
<a name="ln5408"> </a>
<a name="ln5409">  // Make all characters printable.</a>
<a name="ln5410">  p = (char_u *)transstr((const char *)buf);</a>
<a name="ln5411">  len = STRLCPY(buf, p, sizeof(buf));</a>
<a name="ln5412">  len = (size_t)len &lt; sizeof(buf) ? len : (int)sizeof(buf) - 1;</a>
<a name="ln5413">  xfree(p);</a>
<a name="ln5414"> </a>
<a name="ln5415">  /* fill up with &quot;fillchar&quot; */</a>
<a name="ln5416">  while (width &lt; maxwidth &amp;&amp; len &lt; (int)sizeof(buf) - 1) {</a>
<a name="ln5417">    len += utf_char2bytes(fillchar, buf + len);</a>
<a name="ln5418">    width++;</a>
<a name="ln5419">  }</a>
<a name="ln5420">  buf[len] = NUL;</a>
<a name="ln5421"> </a>
<a name="ln5422">  /*</a>
<a name="ln5423">   * Draw each snippet with the specified highlighting.</a>
<a name="ln5424">   */</a>
<a name="ln5425">  grid_puts_line_start(grid, row);</a>
<a name="ln5426"> </a>
<a name="ln5427">  curattr = attr;</a>
<a name="ln5428">  p = buf;</a>
<a name="ln5429">  for (n = 0; hltab[n].start != NULL; n++) {</a>
<a name="ln5430">    int textlen = (int)(hltab[n].start - p);</a>
<a name="ln5431">    grid_puts_len(grid, p, textlen, row, col, curattr);</a>
<a name="ln5432">    col += vim_strnsize(p, textlen);</a>
<a name="ln5433">    p = hltab[n].start;</a>
<a name="ln5434"> </a>
<a name="ln5435">    if (hltab[n].userhl == 0)</a>
<a name="ln5436">      curattr = attr;</a>
<a name="ln5437">    else if (hltab[n].userhl &lt; 0)</a>
<a name="ln5438">      curattr = syn_id2attr(-hltab[n].userhl);</a>
<a name="ln5439">    else if (wp != NULL &amp;&amp; wp != curwin &amp;&amp; wp-&gt;w_status_height != 0)</a>
<a name="ln5440">      curattr = highlight_stlnc[hltab[n].userhl - 1];</a>
<a name="ln5441">    else</a>
<a name="ln5442">      curattr = highlight_user[hltab[n].userhl - 1];</a>
<a name="ln5443">  }</a>
<a name="ln5444">  // Make sure to use an empty string instead of p, if p is beyond buf + len.</a>
<a name="ln5445">  grid_puts(grid, p &gt;= buf + len ? (char_u *)&quot;&quot; : p, row, col,</a>
<a name="ln5446">            curattr);</a>
<a name="ln5447"> </a>
<a name="ln5448">  grid_puts_line_flush(false);</a>
<a name="ln5449"> </a>
<a name="ln5450">  if (wp == NULL) {</a>
<a name="ln5451">    // Fill the tab_page_click_defs array for clicking in the tab pages line.</a>
<a name="ln5452">    col = 0;</a>
<a name="ln5453">    len = 0;</a>
<a name="ln5454">    p = buf;</a>
<a name="ln5455">    StlClickDefinition cur_click_def = {</a>
<a name="ln5456">      .type = kStlClickDisabled,</a>
<a name="ln5457">    };</a>
<a name="ln5458">    for (n = 0; tabtab[n].start != NULL; n++) {</a>
<a name="ln5459">      len += vim_strnsize(p, (int)(tabtab[n].start - (char *) p));</a>
<a name="ln5460">      while (col &lt; len) {</a>
<a name="ln5461">        tab_page_click_defs[col++] = cur_click_def;</a>
<a name="ln5462">      }</a>
<a name="ln5463">      p = (char_u *) tabtab[n].start;</a>
<a name="ln5464">      cur_click_def = tabtab[n].def;</a>
<a name="ln5465">    }</a>
<a name="ln5466">    while (col &lt; Columns) {</a>
<a name="ln5467">      tab_page_click_defs[col++] = cur_click_def;</a>
<a name="ln5468">    }</a>
<a name="ln5469">  }</a>
<a name="ln5470"> </a>
<a name="ln5471">theend:</a>
<a name="ln5472">  entered = FALSE;</a>
<a name="ln5473">}</a>
<a name="ln5474"> </a>
<a name="ln5475">static void win_redr_border(win_T *wp)</a>
<a name="ln5476">{</a>
<a name="ln5477">  wp-&gt;w_redr_border = false;</a>
<a name="ln5478">  if (!(wp-&gt;w_floating &amp;&amp; wp-&gt;w_float_config.border)) {</a>
<a name="ln5479">    return;</a>
<a name="ln5480">  }</a>
<a name="ln5481"> </a>
<a name="ln5482">  ScreenGrid *grid = &amp;wp-&gt;w_grid_alloc;</a>
<a name="ln5483"> </a>
<a name="ln5484">  schar_T *chars = wp-&gt;w_float_config.border_chars;</a>
<a name="ln5485">  int *attrs = wp-&gt;w_float_config.border_attr;</a>
<a name="ln5486"> </a>
<a name="ln5487"> </a>
<a name="ln5488">  int *adj = wp-&gt;w_border_adj;</a>
<a name="ln5489">  int irow = wp-&gt;w_height_inner, icol = wp-&gt;w_width_inner;</a>
<a name="ln5490"> </a>
<a name="ln5491">  if (adj[0]) {</a>
<a name="ln5492">    grid_puts_line_start(grid, 0);</a>
<a name="ln5493">    if (adj[3]) {</a>
<a name="ln5494">      grid_put_schar(grid, 0, 0, chars[0], attrs[0]);</a>
<a name="ln5495">    }</a>
<a name="ln5496">    for (int i = 0; i &lt; icol; i++) {</a>
<a name="ln5497">      grid_put_schar(grid, 0, i+adj[3], chars[1], attrs[1]);</a>
<a name="ln5498">    }</a>
<a name="ln5499">    if (adj[1]) {</a>
<a name="ln5500">      grid_put_schar(grid, 0, icol+adj[3], chars[2], attrs[2]);</a>
<a name="ln5501">    }</a>
<a name="ln5502">    grid_puts_line_flush(false);</a>
<a name="ln5503">  }</a>
<a name="ln5504"> </a>
<a name="ln5505">  for (int i = 0; i &lt; irow; i++) {</a>
<a name="ln5506">    if (adj[3]) {</a>
<a name="ln5507">      grid_puts_line_start(grid, i+adj[0]);</a>
<a name="ln5508">      grid_put_schar(grid, i+adj[0], 0, chars[7], attrs[7]);</a>
<a name="ln5509">      grid_puts_line_flush(false);</a>
<a name="ln5510">    }</a>
<a name="ln5511">    if (adj[1]) {</a>
<a name="ln5512">      int ic = (i == 0 &amp;&amp; !adj[0] &amp;&amp; chars[2][0]) ? 2 : 3;</a>
<a name="ln5513">      grid_puts_line_start(grid, i+adj[0]);</a>
<a name="ln5514">      grid_put_schar(grid, i+adj[0], icol+adj[3], chars[ic], attrs[ic]);</a>
<a name="ln5515">      grid_puts_line_flush(false);</a>
<a name="ln5516">    }</a>
<a name="ln5517">  }</a>
<a name="ln5518"> </a>
<a name="ln5519">  if (adj[2]) {</a>
<a name="ln5520">    grid_puts_line_start(grid, irow+adj[0]);</a>
<a name="ln5521">    if (adj[3]) {</a>
<a name="ln5522">      grid_put_schar(grid, irow+adj[0], 0, chars[6], attrs[6]);</a>
<a name="ln5523">    }</a>
<a name="ln5524">    for (int i = 0; i &lt; icol; i++) {</a>
<a name="ln5525">      int ic = (i == 0 &amp;&amp; !adj[3] &amp;&amp; chars[6][0]) ? 6 : 5;</a>
<a name="ln5526">      grid_put_schar(grid, irow+adj[0], i+adj[3], chars[ic], attrs[ic]);</a>
<a name="ln5527">    }</a>
<a name="ln5528">    grid_put_schar(grid, irow+adj[0], icol+adj[3], chars[4], attrs[4]);</a>
<a name="ln5529">    grid_puts_line_flush(false);</a>
<a name="ln5530">  }</a>
<a name="ln5531">}</a>
<a name="ln5532"> </a>
<a name="ln5533">// Low-level functions to manipulate invidual character cells on the</a>
<a name="ln5534">// screen grid.</a>
<a name="ln5535"> </a>
<a name="ln5536">/// Put a ASCII character in a screen cell.</a>
<a name="ln5537">static void schar_from_ascii(char_u *p, const char c)</a>
<a name="ln5538">{</a>
<a name="ln5539">  p[0] = c;</a>
<a name="ln5540">  p[1] = 0;</a>
<a name="ln5541">}</a>
<a name="ln5542"> </a>
<a name="ln5543">/// Put a unicode character in a screen cell.</a>
<a name="ln5544">static int schar_from_char(char_u *p, int c)</a>
<a name="ln5545">{</a>
<a name="ln5546">  int len = utf_char2bytes(c, p);</a>
<a name="ln5547">  p[len] = NUL;</a>
<a name="ln5548">  return len;</a>
<a name="ln5549">}</a>
<a name="ln5550"> </a>
<a name="ln5551">/// Put a unicode char, and up to MAX_MCO composing chars, in a screen cell.</a>
<a name="ln5552">static int schar_from_cc(char_u *p, int c, int u8cc[MAX_MCO])</a>
<a name="ln5553">{</a>
<a name="ln5554">  int len = utf_char2bytes(c, p);</a>
<a name="ln5555">  for (int i = 0; i &lt; MAX_MCO; i++) {</a>
<a name="ln5556">    if (u8cc[i] == 0) {</a>
<a name="ln5557">      break;</a>
<a name="ln5558">    }</a>
<a name="ln5559">    len += utf_char2bytes(u8cc[i], p + len);</a>
<a name="ln5560">  }</a>
<a name="ln5561">  p[len] = 0;</a>
<a name="ln5562">  return len;</a>
<a name="ln5563">}</a>
<a name="ln5564"> </a>
<a name="ln5565">/// compare the contents of two screen cells.</a>
<a name="ln5566">static int schar_cmp(char_u *sc1, char_u *sc2)</a>
<a name="ln5567">{</a>
<a name="ln5568">  return STRNCMP(sc1, sc2, sizeof(schar_T));</a>
<a name="ln5569">}</a>
<a name="ln5570"> </a>
<a name="ln5571">/// copy the contents of screen cell `sc2` into cell `sc1`</a>
<a name="ln5572">static void schar_copy(char_u *sc1, char_u *sc2)</a>
<a name="ln5573">{</a>
<a name="ln5574">  STRLCPY(sc1, sc2, sizeof(schar_T));</a>
<a name="ln5575">}</a>
<a name="ln5576"> </a>
<a name="ln5577">static int line_off2cells(schar_T *line, size_t off, size_t max_off)</a>
<a name="ln5578">{</a>
<a name="ln5579">  return (off + 1 &lt; max_off &amp;&amp; line[off + 1][0] == 0) ? 2 : 1;</a>
<a name="ln5580">}</a>
<a name="ln5581"> </a>
<a name="ln5582">/// Return number of display cells for char at grid-&gt;chars[off].</a>
<a name="ln5583">/// We make sure that the offset used is less than &quot;max_off&quot;.</a>
<a name="ln5584">static int grid_off2cells(ScreenGrid *grid, size_t off, size_t max_off)</a>
<a name="ln5585">{</a>
<a name="ln5586">  return line_off2cells(grid-&gt;chars, off, max_off);</a>
<a name="ln5587">}</a>
<a name="ln5588"> </a>
<a name="ln5589">/// Return true if the character at &quot;row&quot;/&quot;col&quot; on the screen is the left side</a>
<a name="ln5590">/// of a double-width character.</a>
<a name="ln5591">///</a>
<a name="ln5592">/// Caller must make sure &quot;row&quot; and &quot;col&quot; are not invalid!</a>
<a name="ln5593">bool grid_lefthalve(ScreenGrid *grid, int row, int col)</a>
<a name="ln5594">{</a>
<a name="ln5595">  screen_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln5596"> </a>
<a name="ln5597">  return grid_off2cells(grid, grid-&gt;line_offset[row] + col,</a>
<a name="ln5598">                        grid-&gt;line_offset[row] + grid-&gt;Columns) &gt; 1;</a>
<a name="ln5599">}</a>
<a name="ln5600"> </a>
<a name="ln5601">/// Correct a position on the screen, if it's the right half of a double-wide</a>
<a name="ln5602">/// char move it to the left half.  Returns the corrected column.</a>
<a name="ln5603">int grid_fix_col(ScreenGrid *grid, int col, int row)</a>
<a name="ln5604">{</a>
<a name="ln5605">  int coloff = 0;</a>
<a name="ln5606">  screen_adjust_grid(&amp;grid, &amp;row, &amp;coloff);</a>
<a name="ln5607"> </a>
<a name="ln5608">  col += coloff;</a>
<a name="ln5609">  if (grid-&gt;chars != NULL &amp;&amp; col &gt; 0</a>
<a name="ln5610">      &amp;&amp; grid-&gt;chars[grid-&gt;line_offset[row] + col][0] == 0) {</a>
<a name="ln5611">    return col - 1 - coloff;</a>
<a name="ln5612">  }</a>
<a name="ln5613">  return col - coloff;</a>
<a name="ln5614">}</a>
<a name="ln5615"> </a>
<a name="ln5616">/// output a single character directly to the grid</a>
<a name="ln5617">void grid_putchar(ScreenGrid *grid, int c, int row, int col, int attr)</a>
<a name="ln5618">{</a>
<a name="ln5619">  char_u buf[MB_MAXBYTES + 1];</a>
<a name="ln5620"> </a>
<a name="ln5621">  buf[utf_char2bytes(c, buf)] = NUL;</a>
<a name="ln5622">  grid_puts(grid, buf, row, col, attr);</a>
<a name="ln5623">}</a>
<a name="ln5624"> </a>
<a name="ln5625">/// get a single character directly from grid.chars into &quot;bytes[]&quot;.</a>
<a name="ln5626">/// Also return its attribute in *attrp;</a>
<a name="ln5627">void grid_getbytes(ScreenGrid *grid, int row, int col, char_u *bytes,</a>
<a name="ln5628">                   int *attrp)</a>
<a name="ln5629">{</a>
<a name="ln5630">  unsigned off;</a>
<a name="ln5631"> </a>
<a name="ln5632">  screen_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln5633"> </a>
<a name="ln5634">  // safety check</a>
<a name="ln5635">  if (grid-&gt;chars != NULL &amp;&amp; row &lt; grid-&gt;Rows &amp;&amp; col &lt; grid-&gt;Columns) {</a>
<a name="ln5636">    off = grid-&gt;line_offset[row] + col;</a>
<a name="ln5637">    *attrp = grid-&gt;attrs[off];</a>
<a name="ln5638">    schar_copy(bytes, grid-&gt;chars[off]);</a>
<a name="ln5639">  }</a>
<a name="ln5640">}</a>
<a name="ln5641"> </a>
<a name="ln5642"> </a>
<a name="ln5643">/// put string '*text' on the window grid at position 'row' and 'col', with</a>
<a name="ln5644">/// attributes 'attr', and update chars[] and attrs[].</a>
<a name="ln5645">/// Note: only outputs within one row, message is truncated at grid boundary!</a>
<a name="ln5646">/// Note: if grid, row and/or col is invalid, nothing is done.</a>
<a name="ln5647">void grid_puts(ScreenGrid *grid, char_u *text, int row, int col, int attr)</a>
<a name="ln5648">{</a>
<a name="ln5649">  grid_puts_len(grid, text, -1, row, col, attr);</a>
<a name="ln5650">}</a>
<a name="ln5651"> </a>
<a name="ln5652">static ScreenGrid *put_dirty_grid = NULL;</a>
<a name="ln5653">static int put_dirty_row = -1;</a>
<a name="ln5654">static int put_dirty_first = INT_MAX;</a>
<a name="ln5655">static int put_dirty_last = 0;</a>
<a name="ln5656"> </a>
<a name="ln5657">/// Start a group of grid_puts_len calls that builds a single grid line.</a>
<a name="ln5658">///</a>
<a name="ln5659">/// Must be matched with a grid_puts_line_flush call before moving to</a>
<a name="ln5660">/// another line.</a>
<a name="ln5661">void grid_puts_line_start(ScreenGrid *grid, int row)</a>
<a name="ln5662">{</a>
<a name="ln5663">  int col = 0;  // unused</a>
<a name="ln5664">  screen_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln5665">  assert(put_dirty_row == -1);</a>
<a name="ln5666">  put_dirty_row = row;</a>
<a name="ln5667">  put_dirty_grid = grid;</a>
<a name="ln5668">}</a>
<a name="ln5669"> </a>
<a name="ln5670">void grid_put_schar(ScreenGrid *grid, int row, int col, char_u *schar, int attr)</a>
<a name="ln5671">{</a>
<a name="ln5672">  assert(put_dirty_row == row);</a>
<a name="ln5673">  unsigned int off = grid-&gt;line_offset[row] + col;</a>
<a name="ln5674">  if (grid-&gt;attrs[off] != attr || schar_cmp(grid-&gt;chars[off], schar)) {</a>
<a name="ln5675">      schar_copy(grid-&gt;chars[off], schar);</a>
<a name="ln5676">      grid-&gt;attrs[off] = attr;</a>
<a name="ln5677"> </a>
<a name="ln5678">      put_dirty_first = MIN(put_dirty_first, col);</a>
<a name="ln5679">      // TODO(bfredl): Y U NO DOUBLEWIDTH?</a>
<a name="ln5680">      put_dirty_last = MAX(put_dirty_last, col+1);</a>
<a name="ln5681">  }</a>
<a name="ln5682">}</a>
<a name="ln5683"> </a>
<a name="ln5684">/// like grid_puts(), but output &quot;text[len]&quot;.  When &quot;len&quot; is -1 output up to</a>
<a name="ln5685">/// a NUL.</a>
<a name="ln5686">void grid_puts_len(ScreenGrid *grid, char_u *text, int textlen, int row,</a>
<a name="ln5687">                   int col, int attr)</a>
<a name="ln5688">{</a>
<a name="ln5689">  unsigned off;</a>
<a name="ln5690">  char_u      *ptr = text;</a>
<a name="ln5691">  int len = textlen;</a>
<a name="ln5692">  int c;</a>
<a name="ln5693">  unsigned max_off;</a>
<a name="ln5694">  int mbyte_blen = 1;</a>
<a name="ln5695">  int mbyte_cells = 1;</a>
<a name="ln5696">  int u8c = 0;</a>
<a name="ln5697">  int u8cc[MAX_MCO];</a>
<a name="ln5698">  int clear_next_cell = FALSE;</a>
<a name="ln5699">  int prev_c = 0;                       /* previous Arabic character */</a>
<a name="ln5700">  int pc, nc, nc1;</a>
<a name="ln5701">  int pcc[MAX_MCO];</a>
<a name="ln5702">  int need_redraw;</a>
<a name="ln5703">  bool do_flush = false;</a>
<a name="ln5704"> </a>
<a name="ln5705">  screen_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln5706"> </a>
<a name="ln5707">  // Safety check. The check for negative row and column is to fix issue</a>
<a name="ln5708">  // vim/vim#4102. TODO(neovim): find out why row/col could be negative.</a>
<a name="ln5709">  if (grid-&gt;chars == NULL</a>
<a name="ln5710">      || row &gt;= grid-&gt;Rows || row &lt; 0</a>
<a name="ln5711">      || col &gt;= grid-&gt;Columns || col &lt; 0) {</a>
<a name="ln5712">    return;</a>
<a name="ln5713">  }</a>
<a name="ln5714"> </a>
<a name="ln5715">  if (put_dirty_row == -1) {</a>
<a name="ln5716">    grid_puts_line_start(grid, row);</a>
<a name="ln5717">    do_flush = true;</a>
<a name="ln5718">  } else {</a>
<a name="ln5719">    if (grid != put_dirty_grid || row != put_dirty_row) {</a>
<a name="ln5720">      abort();</a>
<a name="ln5721">    }</a>
<a name="ln5722">  }</a>
<a name="ln5723">  off = grid-&gt;line_offset[row] + col;</a>
<a name="ln5724"> </a>
<a name="ln5725">  /* When drawing over the right halve of a double-wide char clear out the</a>
<a name="ln5726">   * left halve.  Only needed in a terminal. */</a>
<a name="ln5727">  if (grid != &amp;default_grid &amp;&amp; col == 0 &amp;&amp; grid_invalid_row(grid, row)) {</a>
<a name="ln5728">    // redraw the previous cell, make it empty</a>
<a name="ln5729">    put_dirty_first = -1;</a>
<a name="ln5730">    put_dirty_last = MAX(put_dirty_last, 1);</a>
<a name="ln5731">  }</a>
<a name="ln5732"> </a>
<a name="ln5733">  max_off = grid-&gt;line_offset[row] + grid-&gt;Columns;</a>
<a name="ln5734">  while (col &lt; grid-&gt;Columns</a>
<a name="ln5735">         &amp;&amp; (len &lt; 0 || (int)(ptr - text) &lt; len)</a>
<a name="ln5736">         &amp;&amp; *ptr != NUL) {</a>
<a name="ln5737">    c = *ptr;</a>
<a name="ln5738">    // check if this is the first byte of a multibyte</a>
<a name="ln5739">    if (len &gt; 0) {</a>
<a name="ln5740">      mbyte_blen = utfc_ptr2len_len(ptr, (int)((text + len) - ptr));</a>
<a name="ln5741">    } else {</a>
<a name="ln5742">      mbyte_blen = utfc_ptr2len(ptr);</a>
<a name="ln5743">    }</a>
<a name="ln5744">    if (len &gt;= 0) {</a>
<a name="ln5745">      u8c = utfc_ptr2char_len(ptr, u8cc, (int)((text + len) - ptr));</a>
<a name="ln5746">    } else {</a>
<a name="ln5747">      u8c = utfc_ptr2char(ptr, u8cc);</a>
<a name="ln5748">    }</a>
<a name="ln5749">    mbyte_cells = utf_char2cells(u8c);</a>
<a name="ln5750">    if (p_arshape &amp;&amp; !p_tbidi &amp;&amp; arabic_char(u8c)) {</a>
<a name="ln5751">      // Do Arabic shaping.</a>
<a name="ln5752">      if (len &gt;= 0 &amp;&amp; (int)(ptr - text) + mbyte_blen &gt;= len) {</a>
<a name="ln5753">        // Past end of string to be displayed.</a>
<a name="ln5754">        nc = NUL;</a>
<a name="ln5755">        nc1 = NUL;</a>
<a name="ln5756">      } else {</a>
<a name="ln5757">        nc = utfc_ptr2char_len(ptr + mbyte_blen, pcc,</a>
<a name="ln5758">                               (int)((text + len) - ptr - mbyte_blen));</a>
<a name="ln5759">        nc1 = pcc[0];</a>
<a name="ln5760">      }</a>
<a name="ln5761">      pc = prev_c;</a>
<a name="ln5762">      prev_c = u8c;</a>
<a name="ln5763">      u8c = arabic_shape(u8c, &amp;c, &amp;u8cc[0], nc, nc1, pc);</a>
<a name="ln5764">    } else {</a>
<a name="ln5765">      prev_c = u8c;</a>
<a name="ln5766">    }</a>
<a name="ln5767">    if (col + mbyte_cells &gt; grid-&gt;Columns) {</a>
<a name="ln5768">      // Only 1 cell left, but character requires 2 cells:</a>
<a name="ln5769">      // display a '&gt;' in the last column to avoid wrapping. */</a>
<a name="ln5770">      c = '&gt;';</a>
<a name="ln5771">      mbyte_cells = 1;</a>
<a name="ln5772">    }</a>
<a name="ln5773"> </a>
<a name="ln5774">    schar_T buf;</a>
<a name="ln5775">    schar_from_cc(buf, u8c, u8cc);</a>
<a name="ln5776"> </a>
<a name="ln5777"> </a>
<a name="ln5778">    need_redraw = schar_cmp(grid-&gt;chars[off], buf)</a>
<a name="ln5779">                  || (mbyte_cells == 2 &amp;&amp; grid-&gt;chars[off + 1][0] != 0)</a>
<a name="ln5780">                  || grid-&gt;attrs[off] != attr</a>
<a name="ln5781">                  || exmode_active;</a>
<a name="ln5782"> </a>
<a name="ln5783">    if (need_redraw) {</a>
<a name="ln5784">      // When at the end of the text and overwriting a two-cell</a>
<a name="ln5785">      // character with a one-cell character, need to clear the next</a>
<a name="ln5786">      // cell.  Also when overwriting the left halve of a two-cell char</a>
<a name="ln5787">      // with the right halve of a two-cell char.  Do this only once</a>
<a name="ln5788">      // (utf8_off2cells() may return 2 on the right halve).</a>
<a name="ln5789">      if (clear_next_cell) {</a>
<a name="ln5790">        clear_next_cell = false;</a>
<a name="ln5791">      } else if ((len &lt; 0 ? ptr[mbyte_blen] == NUL</a>
<a name="ln5792">                  : ptr + mbyte_blen &gt;= text + len)</a>
<a name="ln5793">                 &amp;&amp; ((mbyte_cells == 1</a>
<a name="ln5794">                      &amp;&amp; grid_off2cells(grid, off, max_off) &gt; 1)</a>
<a name="ln5795">                     || (mbyte_cells == 2</a>
<a name="ln5796">                         &amp;&amp; grid_off2cells(grid, off, max_off) == 1</a>
<a name="ln5797">                         &amp;&amp; grid_off2cells(grid, off + 1, max_off) &gt; 1))) {</a>
<a name="ln5798">        clear_next_cell = true;</a>
<a name="ln5799">      }</a>
<a name="ln5800"> </a>
<a name="ln5801">      schar_copy(grid-&gt;chars[off], buf);</a>
<a name="ln5802">      grid-&gt;attrs[off] = attr;</a>
<a name="ln5803">      if (mbyte_cells == 2) {</a>
<a name="ln5804">        grid-&gt;chars[off + 1][0] = 0;</a>
<a name="ln5805">        grid-&gt;attrs[off + 1] = attr;</a>
<a name="ln5806">      }</a>
<a name="ln5807">      put_dirty_first = MIN(put_dirty_first, col);</a>
<a name="ln5808">      put_dirty_last = MAX(put_dirty_last, col+mbyte_cells);</a>
<a name="ln5809">    }</a>
<a name="ln5810"> </a>
<a name="ln5811">    off += mbyte_cells;</a>
<a name="ln5812">    col += mbyte_cells;</a>
<a name="ln5813">    ptr += mbyte_blen;</a>
<a name="ln5814">    if (clear_next_cell) {</a>
<a name="ln5815">      // This only happens at the end, display one space next.</a>
<a name="ln5816">      ptr = (char_u *)&quot; &quot;;</a>
<a name="ln5817">      len = -1;</a>
<a name="ln5818">    }</a>
<a name="ln5819">  }</a>
<a name="ln5820"> </a>
<a name="ln5821">  if (do_flush) {</a>
<a name="ln5822">    grid_puts_line_flush(true);</a>
<a name="ln5823">  }</a>
<a name="ln5824">}</a>
<a name="ln5825"> </a>
<a name="ln5826">/// End a group of grid_puts_len calls and send the screen buffer to the UI</a>
<a name="ln5827">/// layer.</a>
<a name="ln5828">///</a>
<a name="ln5829">/// @param set_cursor Move the visible cursor to the end of the changed region.</a>
<a name="ln5830">///                   This is a workaround for not yet refactored code paths</a>
<a name="ln5831">///                   and shouldn't be used in new code.</a>
<a name="ln5832">void grid_puts_line_flush(bool set_cursor)</a>
<a name="ln5833">{</a>
<a name="ln5834">  assert(put_dirty_row != -1);</a>
<a name="ln5835">  if (put_dirty_first &lt; put_dirty_last) {</a>
<a name="ln5836">    if (set_cursor) {</a>
<a name="ln5837">      ui_grid_cursor_goto(put_dirty_grid-&gt;handle, put_dirty_row,</a>
<a name="ln5838">                          MIN(put_dirty_last, put_dirty_grid-&gt;Columns-1));</a>
<a name="ln5839">    }</a>
<a name="ln5840">    if (!put_dirty_grid-&gt;throttled) {</a>
<a name="ln5841">      ui_line(put_dirty_grid, put_dirty_row, put_dirty_first, put_dirty_last,</a>
<a name="ln5842">              put_dirty_last, 0, false);</a>
<a name="ln5843">    } else if (put_dirty_grid-&gt;dirty_col) {</a>
<a name="ln5844">      if (put_dirty_last &gt; put_dirty_grid-&gt;dirty_col[put_dirty_row]) {</a>
<a name="ln5845">        put_dirty_grid-&gt;dirty_col[put_dirty_row] = put_dirty_last;</a>
<a name="ln5846">      }</a>
<a name="ln5847">    }</a>
<a name="ln5848">    put_dirty_first = INT_MAX;</a>
<a name="ln5849">    put_dirty_last = 0;</a>
<a name="ln5850">  }</a>
<a name="ln5851">  put_dirty_row = -1;</a>
<a name="ln5852">  put_dirty_grid = NULL;</a>
<a name="ln5853">}</a>
<a name="ln5854"> </a>
<a name="ln5855">/*</a>
<a name="ln5856"> * Prepare for 'hlsearch' highlighting.</a>
<a name="ln5857"> */</a>
<a name="ln5858">static void start_search_hl(void)</a>
<a name="ln5859">{</a>
<a name="ln5860">  if (p_hls &amp;&amp; !no_hlsearch) {</a>
<a name="ln5861">    end_search_hl();  // just in case it wasn't called before</a>
<a name="ln5862">    last_pat_prog(&amp;search_hl.rm);</a>
<a name="ln5863">    // Set the time limit to 'redrawtime'.</a>
<a name="ln5864">    search_hl.tm = profile_setlimit(p_rdt);</a>
<a name="ln5865">  }</a>
<a name="ln5866">}</a>
<a name="ln5867"> </a>
<a name="ln5868">/*</a>
<a name="ln5869"> * Clean up for 'hlsearch' highlighting.</a>
<a name="ln5870"> */</a>
<a name="ln5871">static void end_search_hl(void)</a>
<a name="ln5872">{</a>
<a name="ln5873">  if (search_hl.rm.regprog != NULL) {</a>
<a name="ln5874">    vim_regfree(search_hl.rm.regprog);</a>
<a name="ln5875">    search_hl.rm.regprog = NULL;</a>
<a name="ln5876">  }</a>
<a name="ln5877">}</a>
<a name="ln5878"> </a>
<a name="ln5879"> </a>
<a name="ln5880">/*</a>
<a name="ln5881"> * Init for calling prepare_search_hl().</a>
<a name="ln5882"> */</a>
<a name="ln5883">static void init_search_hl(win_T *wp)</a>
<a name="ln5884">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5885">{</a>
<a name="ln5886">  // Setup for match and 'hlsearch' highlighting.  Disable any previous</a>
<a name="ln5887">  // match</a>
<a name="ln5888">  matchitem_T *cur = wp-&gt;w_match_head;</a>
<a name="ln5889">  while (cur != NULL) {</a>
<a name="ln5890">    cur-&gt;hl.rm = cur-&gt;match;</a>
<a name="ln5891">    if (cur-&gt;hlg_id == 0)</a>
<a name="ln5892">      cur-&gt;hl.attr = 0;</a>
<a name="ln5893">    else</a>
<a name="ln5894">      cur-&gt;hl.attr = syn_id2attr(cur-&gt;hlg_id);</a>
<a name="ln5895">    cur-&gt;hl.buf = wp-&gt;w_buffer;</a>
<a name="ln5896">    cur-&gt;hl.lnum = 0;</a>
<a name="ln5897">    cur-&gt;hl.first_lnum = 0;</a>
<a name="ln5898">    // Set the time limit to 'redrawtime'.</a>
<a name="ln5899">    cur-&gt;hl.tm = profile_setlimit(p_rdt);</a>
<a name="ln5900">    cur = cur-&gt;next;</a>
<a name="ln5901">  }</a>
<a name="ln5902">  search_hl.buf = wp-&gt;w_buffer;</a>
<a name="ln5903">  search_hl.lnum = 0;</a>
<a name="ln5904">  search_hl.first_lnum = 0;</a>
<a name="ln5905">  search_hl.attr = win_hl_attr(wp, HLF_L);</a>
<a name="ln5906"> </a>
<a name="ln5907">  // time limit is set at the toplevel, for all windows</a>
<a name="ln5908">}</a>
<a name="ln5909"> </a>
<a name="ln5910">/*</a>
<a name="ln5911"> * Advance to the match in window &quot;wp&quot; line &quot;lnum&quot; or past it.</a>
<a name="ln5912"> */</a>
<a name="ln5913">static void prepare_search_hl(win_T *wp, linenr_T lnum)</a>
<a name="ln5914">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5915">{</a>
<a name="ln5916">  matchitem_T *cur;             // points to the match list</a>
<a name="ln5917">  match_T     *shl;             // points to search_hl or a match</a>
<a name="ln5918">  bool shl_flag;                // flag to indicate whether search_hl</a>
<a name="ln5919">                                // has been processed or not</a>
<a name="ln5920"> </a>
<a name="ln5921">  // When using a multi-line pattern, start searching at the top</a>
<a name="ln5922">  // of the window or just after a closed fold.</a>
<a name="ln5923">  // Do this both for search_hl and the match list.</a>
<a name="ln5924">  cur = wp-&gt;w_match_head;</a>
<a name="ln5925">  shl_flag = false;</a>
<a name="ln5926">  while (cur != NULL || shl_flag == false) {</a>
<a name="ln5927">    if (shl_flag == false) {</a>
<a name="ln5928">      shl = &amp;search_hl;</a>
<a name="ln5929">      shl_flag = true;</a>
<a name="ln5930">    } else {</a>
<a name="ln5931">      shl = &amp;cur-&gt;hl;  // -V595</a>
<a name="ln5932">    }</a>
<a name="ln5933">    if (shl-&gt;rm.regprog != NULL</a>
<a name="ln5934">        &amp;&amp; shl-&gt;lnum == 0</a>
<a name="ln5935">        &amp;&amp; re_multiline(shl-&gt;rm.regprog)) {</a>
<a name="ln5936">      if (shl-&gt;first_lnum == 0) {</a>
<a name="ln5937">        for (shl-&gt;first_lnum = lnum;</a>
<a name="ln5938">             shl-&gt;first_lnum &gt; wp-&gt;w_topline;</a>
<a name="ln5939">             shl-&gt;first_lnum--) {</a>
<a name="ln5940">          if (hasFoldingWin(wp, shl-&gt;first_lnum - 1, NULL, NULL, true, NULL)) {</a>
<a name="ln5941">            break;</a>
<a name="ln5942">          }</a>
<a name="ln5943">        }</a>
<a name="ln5944">      }</a>
<a name="ln5945">      if (cur != NULL) {</a>
<a name="ln5946">        cur-&gt;pos.cur = 0;</a>
<a name="ln5947">      }</a>
<a name="ln5948">      bool pos_inprogress = true; // mark that a position match search is</a>
<a name="ln5949">                                  // in progress</a>
<a name="ln5950">      int n = 0;</a>
<a name="ln5951">      while (shl-&gt;first_lnum &lt; lnum &amp;&amp; (shl-&gt;rm.regprog != NULL</a>
<a name="ln5952">                                        || (cur != NULL &amp;&amp; pos_inprogress))) {</a>
<a name="ln5953">        next_search_hl(wp, shl, shl-&gt;first_lnum, (colnr_T)n,</a>
<a name="ln5954">                       shl == &amp;search_hl ? NULL : cur);</a>
<a name="ln5955">        pos_inprogress = !(cur == NULL ||  cur-&gt;pos.cur == 0);</a>
<a name="ln5956">        if (shl-&gt;lnum != 0) {</a>
<a name="ln5957">          shl-&gt;first_lnum = shl-&gt;lnum</a>
<a name="ln5958">                            + shl-&gt;rm.endpos[0].lnum</a>
<a name="ln5959">                            - shl-&gt;rm.startpos[0].lnum;</a>
<a name="ln5960">          n = shl-&gt;rm.endpos[0].col;</a>
<a name="ln5961">        } else {</a>
<a name="ln5962">          ++shl-&gt;first_lnum;</a>
<a name="ln5963">          n = 0;</a>
<a name="ln5964">        }</a>
<a name="ln5965">      }</a>
<a name="ln5966">    }</a>
<a name="ln5967">    if (shl != &amp;search_hl &amp;&amp; cur != NULL)</a>
<a name="ln5968">      cur = cur-&gt;next;</a>
<a name="ln5969">  }</a>
<a name="ln5970">}</a>
<a name="ln5971"> </a>
<a name="ln5972">/*</a>
<a name="ln5973"> * Search for a next 'hlsearch' or match.</a>
<a name="ln5974"> * Uses shl-&gt;buf.</a>
<a name="ln5975"> * Sets shl-&gt;lnum and shl-&gt;rm contents.</a>
<a name="ln5976"> * Note: Assumes a previous match is always before &quot;lnum&quot;, unless</a>
<a name="ln5977"> * shl-&gt;lnum is zero.</a>
<a name="ln5978"> * Careful: Any pointers for buffer lines will become invalid.</a>
<a name="ln5979"> */</a>
<a name="ln5980">static void</a>
<a name="ln5981">next_search_hl (</a>
<a name="ln5982">    win_T *win,</a>
<a name="ln5983">    match_T *shl,               /* points to search_hl or a match */</a>
<a name="ln5984">    linenr_T lnum,</a>
<a name="ln5985">    colnr_T mincol,                /* minimal column for a match */</a>
<a name="ln5986">    matchitem_T *cur               /* to retrieve match positions if any */</a>
<a name="ln5987">)</a>
<a name="ln5988">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln5989">{</a>
<a name="ln5990">  linenr_T l;</a>
<a name="ln5991">  colnr_T matchcol;</a>
<a name="ln5992">  long nmatched = 0;</a>
<a name="ln5993">  int save_called_emsg = called_emsg;</a>
<a name="ln5994"> </a>
<a name="ln5995">  // for :{range}s/pat only highlight inside the range</a>
<a name="ln5996">  if (lnum &lt; search_first_line || lnum &gt; search_last_line) {</a>
<a name="ln5997">    shl-&gt;lnum = 0;</a>
<a name="ln5998">    return;</a>
<a name="ln5999">  }</a>
<a name="ln6000"> </a>
<a name="ln6001">  if (shl-&gt;lnum != 0) {</a>
<a name="ln6002">    // Check for three situations:</a>
<a name="ln6003">    // 1. If the &quot;lnum&quot; is below a previous match, start a new search.</a>
<a name="ln6004">    // 2. If the previous match includes &quot;mincol&quot;, use it.</a>
<a name="ln6005">    // 3. Continue after the previous match.</a>
<a name="ln6006">    l = shl-&gt;lnum + shl-&gt;rm.endpos[0].lnum - shl-&gt;rm.startpos[0].lnum;</a>
<a name="ln6007">    if (lnum &gt; l)</a>
<a name="ln6008">      shl-&gt;lnum = 0;</a>
<a name="ln6009">    else if (lnum &lt; l || shl-&gt;rm.endpos[0].col &gt; mincol)</a>
<a name="ln6010">      return;</a>
<a name="ln6011">  }</a>
<a name="ln6012"> </a>
<a name="ln6013">  /*</a>
<a name="ln6014">   * Repeat searching for a match until one is found that includes &quot;mincol&quot;</a>
<a name="ln6015">   * or none is found in this line.</a>
<a name="ln6016">   */</a>
<a name="ln6017">  called_emsg = FALSE;</a>
<a name="ln6018">  for (;; ) {</a>
<a name="ln6019">    // Stop searching after passing the time limit.</a>
<a name="ln6020">    if (profile_passed_limit(shl-&gt;tm)) {</a>
<a name="ln6021">      shl-&gt;lnum = 0;                    /* no match found in time */</a>
<a name="ln6022">      break;</a>
<a name="ln6023">    }</a>
<a name="ln6024">    // Three situations:</a>
<a name="ln6025">    // 1. No useful previous match: search from start of line.</a>
<a name="ln6026">    // 2. Not Vi compatible or empty match: continue at next character.</a>
<a name="ln6027">    //    Break the loop if this is beyond the end of the line.</a>
<a name="ln6028">    // 3. Vi compatible searching: continue at end of previous match.</a>
<a name="ln6029">    if (shl-&gt;lnum == 0) {</a>
<a name="ln6030">      matchcol = 0;</a>
<a name="ln6031">    } else if (vim_strchr(p_cpo, CPO_SEARCH) == NULL</a>
<a name="ln6032">               || (shl-&gt;rm.endpos[0].lnum == 0</a>
<a name="ln6033">                   &amp;&amp; shl-&gt;rm.endpos[0].col &lt;= shl-&gt;rm.startpos[0].col)) {</a>
<a name="ln6034">      char_u      *ml;</a>
<a name="ln6035"> </a>
<a name="ln6036">      matchcol = shl-&gt;rm.startpos[0].col;</a>
<a name="ln6037">      ml = ml_get_buf(shl-&gt;buf, lnum, FALSE) + matchcol;</a>
<a name="ln6038">      if (*ml == NUL) {</a>
<a name="ln6039">        ++matchcol;</a>
<a name="ln6040">        shl-&gt;lnum = 0;</a>
<a name="ln6041">        break;</a>
<a name="ln6042">      }</a>
<a name="ln6043">      matchcol += mb_ptr2len(ml);</a>
<a name="ln6044">    } else {</a>
<a name="ln6045">      matchcol = shl-&gt;rm.endpos[0].col;</a>
<a name="ln6046">    }</a>
<a name="ln6047"> </a>
<a name="ln6048">    shl-&gt;lnum = lnum;</a>
<a name="ln6049">    if (shl-&gt;rm.regprog != NULL) {</a>
<a name="ln6050">      // Remember whether shl-&gt;rm is using a copy of the regprog in</a>
<a name="ln6051">      // cur-&gt;match.</a>
<a name="ln6052">      bool regprog_is_copy = (shl != &amp;search_hl</a>
<a name="ln6053">                              &amp;&amp; cur != NULL</a>
<a name="ln6054">                              &amp;&amp; shl == &amp;cur-&gt;hl</a>
<a name="ln6055">                              &amp;&amp; cur-&gt;match.regprog == cur-&gt;hl.rm.regprog);</a>
<a name="ln6056">      int timed_out = false;</a>
<a name="ln6057"> </a>
<a name="ln6058">      nmatched = vim_regexec_multi(&amp;shl-&gt;rm, win, shl-&gt;buf, lnum, matchcol,</a>
<a name="ln6059">                                   &amp;(shl-&gt;tm), &amp;timed_out);</a>
<a name="ln6060">      // Copy the regprog, in case it got freed and recompiled.</a>
<a name="ln6061">      if (regprog_is_copy) {</a>
<a name="ln6062">        cur-&gt;match.regprog = cur-&gt;hl.rm.regprog;</a>
<a name="ln6063">      }</a>
<a name="ln6064">      if (called_emsg || got_int || timed_out) {</a>
<a name="ln6065">        // Error while handling regexp: stop using this regexp.</a>
<a name="ln6066">        if (shl == &amp;search_hl) {</a>
<a name="ln6067">          // don't free regprog in the match list, it's a copy</a>
<a name="ln6068">          vim_regfree(shl-&gt;rm.regprog);</a>
<a name="ln6069">          set_no_hlsearch(true);</a>
<a name="ln6070">        }</a>
<a name="ln6071">        shl-&gt;rm.regprog = NULL;</a>
<a name="ln6072">        shl-&gt;lnum = 0;</a>
<a name="ln6073">        got_int = FALSE; // avoid the &quot;Type :quit to exit Vim&quot; message</a>
<a name="ln6074">        break;</a>
<a name="ln6075">      }</a>
<a name="ln6076">    } else if (cur != NULL) {</a>
<a name="ln6077">      nmatched = next_search_hl_pos(shl, lnum, &amp;(cur-&gt;pos), matchcol);</a>
<a name="ln6078">    }</a>
<a name="ln6079">    if (nmatched == 0) {</a>
<a name="ln6080">      shl-&gt;lnum = 0;                    // no match found</a>
<a name="ln6081">      break;</a>
<a name="ln6082">    }</a>
<a name="ln6083">    if (shl-&gt;rm.startpos[0].lnum &gt; 0</a>
<a name="ln6084">        || shl-&gt;rm.startpos[0].col &gt;= mincol</a>
<a name="ln6085">        || nmatched &gt; 1</a>
<a name="ln6086">        || shl-&gt;rm.endpos[0].col &gt; mincol) {</a>
<a name="ln6087">      shl-&gt;lnum += shl-&gt;rm.startpos[0].lnum;</a>
<a name="ln6088">      break;                            // useful match found</a>
<a name="ln6089">    }</a>
<a name="ln6090"> </a>
<a name="ln6091">    // Restore called_emsg for assert_fails().</a>
<a name="ln6092">    called_emsg = save_called_emsg;</a>
<a name="ln6093">  }</a>
<a name="ln6094">}</a>
<a name="ln6095"> </a>
<a name="ln6096">/// If there is a match fill &quot;shl&quot; and return one.</a>
<a name="ln6097">/// Return zero otherwise.</a>
<a name="ln6098">static int</a>
<a name="ln6099">next_search_hl_pos(</a>
<a name="ln6100">    match_T *shl,         // points to a match</a>
<a name="ln6101">    linenr_T lnum,</a>
<a name="ln6102">    posmatch_T *posmatch, // match positions</a>
<a name="ln6103">    colnr_T mincol        // minimal column for a match</a>
<a name="ln6104">)</a>
<a name="ln6105">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6106">{</a>
<a name="ln6107">  int i;</a>
<a name="ln6108">  int found = -1;</a>
<a name="ln6109"> </a>
<a name="ln6110">  shl-&gt;lnum = 0;</a>
<a name="ln6111">  for (i = posmatch-&gt;cur; i &lt; MAXPOSMATCH; i++) {</a>
<a name="ln6112">    llpos_T *pos = &amp;posmatch-&gt;pos[i];</a>
<a name="ln6113"> </a>
<a name="ln6114">    if (pos-&gt;lnum == 0) {</a>
<a name="ln6115">      break;</a>
<a name="ln6116">    }</a>
<a name="ln6117">    if (pos-&gt;len == 0 &amp;&amp; pos-&gt;col &lt; mincol) {</a>
<a name="ln6118">      continue;</a>
<a name="ln6119">    }</a>
<a name="ln6120">    if (pos-&gt;lnum == lnum) {</a>
<a name="ln6121">      if (found &gt;= 0) {</a>
<a name="ln6122">        // if this match comes before the one at &quot;found&quot; then swap</a>
<a name="ln6123">        // them</a>
<a name="ln6124">        if (pos-&gt;col &lt; posmatch-&gt;pos[found].col) {</a>
<a name="ln6125">          llpos_T tmp = *pos;</a>
<a name="ln6126"> </a>
<a name="ln6127">          *pos = posmatch-&gt;pos[found];</a>
<a name="ln6128">          posmatch-&gt;pos[found] = tmp;</a>
<a name="ln6129">        }</a>
<a name="ln6130">      } else {</a>
<a name="ln6131">        found = i;</a>
<a name="ln6132">      }</a>
<a name="ln6133">    }</a>
<a name="ln6134">  }</a>
<a name="ln6135">  posmatch-&gt;cur = 0;</a>
<a name="ln6136">  if (found &gt;= 0) {</a>
<a name="ln6137">    colnr_T start = posmatch-&gt;pos[found].col == 0</a>
<a name="ln6138">                    ? 0: posmatch-&gt;pos[found].col - 1;</a>
<a name="ln6139">    colnr_T end = posmatch-&gt;pos[found].col == 0</a>
<a name="ln6140">                  ? MAXCOL : start + posmatch-&gt;pos[found].len;</a>
<a name="ln6141"> </a>
<a name="ln6142">    shl-&gt;lnum = lnum;</a>
<a name="ln6143">    shl-&gt;rm.startpos[0].lnum = 0;</a>
<a name="ln6144">    shl-&gt;rm.startpos[0].col = start;</a>
<a name="ln6145">    shl-&gt;rm.endpos[0].lnum = 0;</a>
<a name="ln6146">    shl-&gt;rm.endpos[0].col = end;</a>
<a name="ln6147">    shl-&gt;is_addpos = true;</a>
<a name="ln6148">    posmatch-&gt;cur = found + 1;</a>
<a name="ln6149">    return 1;</a>
<a name="ln6150">  }</a>
<a name="ln6151">  return 0;</a>
<a name="ln6152">}</a>
<a name="ln6153"> </a>
<a name="ln6154"> </a>
<a name="ln6155">/// Fill the grid from 'start_row' to 'end_row', from 'start_col' to 'end_col'</a>
<a name="ln6156">/// with character 'c1' in first column followed by 'c2' in the other columns.</a>
<a name="ln6157">/// Use attributes 'attr'.</a>
<a name="ln6158">void grid_fill(ScreenGrid *grid, int start_row, int end_row, int start_col,</a>
<a name="ln6159">               int end_col, int c1, int c2, int attr)</a>
<a name="ln6160">{</a>
<a name="ln6161">  schar_T sc;</a>
<a name="ln6162"> </a>
<a name="ln6163">  int row_off = 0, col_off = 0;</a>
<a name="ln6164">  screen_adjust_grid(&amp;grid, &amp;row_off, &amp;col_off);</a>
<a name="ln6165">  start_row += row_off;</a>
<a name="ln6166">  end_row += row_off;</a>
<a name="ln6167">  start_col += col_off;</a>
<a name="ln6168">  end_col += col_off;</a>
<a name="ln6169"> </a>
<a name="ln6170">  // safety check</a>
<a name="ln6171">  if (end_row &gt; grid-&gt;Rows) {</a>
<a name="ln6172">    end_row = grid-&gt;Rows;</a>
<a name="ln6173">  }</a>
<a name="ln6174">  if (end_col &gt; grid-&gt;Columns) {</a>
<a name="ln6175">    end_col = grid-&gt;Columns;</a>
<a name="ln6176">  }</a>
<a name="ln6177"> </a>
<a name="ln6178">  // nothing to do</a>
<a name="ln6179">  if (start_row &gt;= end_row || start_col &gt;= end_col) {</a>
<a name="ln6180">    return;</a>
<a name="ln6181">  }</a>
<a name="ln6182"> </a>
<a name="ln6183">  for (int row = start_row; row &lt; end_row; row++) {</a>
<a name="ln6184">    // When drawing over the right halve of a double-wide char clear</a>
<a name="ln6185">    // out the left halve.  When drawing over the left halve of a</a>
<a name="ln6186">    // double wide-char clear out the right halve.  Only needed in a</a>
<a name="ln6187">    // terminal.</a>
<a name="ln6188">    if (start_col &gt; 0 &amp;&amp; grid_fix_col(grid, start_col, row) != start_col) {</a>
<a name="ln6189">      grid_puts_len(grid, (char_u *)&quot; &quot;, 1, row, start_col - 1, 0);</a>
<a name="ln6190">    }</a>
<a name="ln6191">    if (end_col &lt; grid-&gt;Columns</a>
<a name="ln6192">        &amp;&amp; grid_fix_col(grid, end_col, row) != end_col) {</a>
<a name="ln6193">      grid_puts_len(grid, (char_u *)&quot; &quot;, 1, row, end_col, 0);</a>
<a name="ln6194">    }</a>
<a name="ln6195"> </a>
<a name="ln6196">    // if grid was resized (in ext_multigrid mode), the UI has no redraw updates</a>
<a name="ln6197">    // for the newly resized grid. It is better mark everything as dirty and</a>
<a name="ln6198">    // send all the updates.</a>
<a name="ln6199">    int dirty_first = INT_MAX;</a>
<a name="ln6200">    int dirty_last = 0;</a>
<a name="ln6201"> </a>
<a name="ln6202">    int col = start_col;</a>
<a name="ln6203">    schar_from_char(sc, c1);</a>
<a name="ln6204">    int lineoff = grid-&gt;line_offset[row];</a>
<a name="ln6205">    for (col = start_col; col &lt; end_col; col++) {</a>
<a name="ln6206">      int off = lineoff + col;</a>
<a name="ln6207">      if (schar_cmp(grid-&gt;chars[off], sc)</a>
<a name="ln6208">          || grid-&gt;attrs[off] != attr) {</a>
<a name="ln6209">        schar_copy(grid-&gt;chars[off], sc);</a>
<a name="ln6210">        grid-&gt;attrs[off] = attr;</a>
<a name="ln6211">        if (dirty_first == INT_MAX) {</a>
<a name="ln6212">          dirty_first = col;</a>
<a name="ln6213">        }</a>
<a name="ln6214">        dirty_last = col+1;</a>
<a name="ln6215">      }</a>
<a name="ln6216">      if (col == start_col) {</a>
<a name="ln6217">        schar_from_char(sc, c2);</a>
<a name="ln6218">      }</a>
<a name="ln6219">    }</a>
<a name="ln6220">    if (dirty_last &gt; dirty_first) {</a>
<a name="ln6221">      // TODO(bfredl): support a cleared suffix even with a batched line?</a>
<a name="ln6222">      if (put_dirty_row == row) {</a>
<a name="ln6223">        put_dirty_first = MIN(put_dirty_first, dirty_first);</a>
<a name="ln6224">        put_dirty_last = MAX(put_dirty_last, dirty_last);</a>
<a name="ln6225">      } else if (grid-&gt;throttled) {</a>
<a name="ln6226">        // Note: assumes msg_grid is the only throttled grid</a>
<a name="ln6227">        assert(grid == &amp;msg_grid);</a>
<a name="ln6228">        int dirty = 0;</a>
<a name="ln6229">        if (attr != HL_ATTR(HLF_MSG) || c2 != ' ') {</a>
<a name="ln6230">          dirty = dirty_last;</a>
<a name="ln6231">        } else if (c1 != ' ') {</a>
<a name="ln6232">          dirty = dirty_first + 1;</a>
<a name="ln6233">        }</a>
<a name="ln6234">        if (grid-&gt;dirty_col &amp;&amp; dirty &gt; grid-&gt;dirty_col[row]) {</a>
<a name="ln6235">          grid-&gt;dirty_col[row] = dirty;</a>
<a name="ln6236">        }</a>
<a name="ln6237">      } else {</a>
<a name="ln6238">        int last = c2 != ' ' ? dirty_last : dirty_first + (c1 != ' ');</a>
<a name="ln6239">        ui_line(grid, row, dirty_first, last, dirty_last, attr, false);</a>
<a name="ln6240">      }</a>
<a name="ln6241">    }</a>
<a name="ln6242"> </a>
<a name="ln6243">    if (end_col == grid-&gt;Columns) {</a>
<a name="ln6244">      grid-&gt;line_wraps[row] = false;</a>
<a name="ln6245">    }</a>
<a name="ln6246">  }</a>
<a name="ln6247">}</a>
<a name="ln6248"> </a>
<a name="ln6249">/*</a>
<a name="ln6250"> * Check if there should be a delay.  Used before clearing or redrawing the</a>
<a name="ln6251"> * screen or the command line.</a>
<a name="ln6252"> */</a>
<a name="ln6253">void check_for_delay(int check_msg_scroll)</a>
<a name="ln6254">{</a>
<a name="ln6255">  if ((emsg_on_display || (check_msg_scroll &amp;&amp; msg_scroll))</a>
<a name="ln6256">      &amp;&amp; !did_wait_return</a>
<a name="ln6257">      &amp;&amp; emsg_silent == 0) {</a>
<a name="ln6258">    ui_flush();</a>
<a name="ln6259">    os_delay(1006L, true);</a>
<a name="ln6260">    emsg_on_display = false;</a>
<a name="ln6261">    if (check_msg_scroll) {</a>
<a name="ln6262">      msg_scroll = false;</a>
<a name="ln6263">    }</a>
<a name="ln6264">  }</a>
<a name="ln6265">}</a>
<a name="ln6266"> </a>
<a name="ln6267">/// (Re)allocates a window grid if size changed while in ext_multigrid mode.</a>
<a name="ln6268">/// Updates size, offsets and handle for the grid regardless.</a>
<a name="ln6269">///</a>
<a name="ln6270">/// If &quot;doclear&quot; is true, don't try to copy from the old grid rather clear the</a>
<a name="ln6271">/// resized grid.</a>
<a name="ln6272">void win_grid_alloc(win_T *wp)</a>
<a name="ln6273">{</a>
<a name="ln6274">  ScreenGrid *grid = &amp;wp-&gt;w_grid;</a>
<a name="ln6275">  ScreenGrid *grid_allocated = &amp;wp-&gt;w_grid_alloc;</a>
<a name="ln6276"> </a>
<a name="ln6277">  int rows = wp-&gt;w_height_inner;</a>
<a name="ln6278">  int cols = wp-&gt;w_width_inner;</a>
<a name="ln6279">  int total_rows = wp-&gt;w_height_outer;</a>
<a name="ln6280">  int total_cols = wp-&gt;w_width_outer;</a>
<a name="ln6281"> </a>
<a name="ln6282">  bool want_allocation = ui_has(kUIMultigrid) || wp-&gt;w_floating;</a>
<a name="ln6283">  bool has_allocation = (grid_allocated-&gt;chars != NULL);</a>
<a name="ln6284"> </a>
<a name="ln6285">  if (grid-&gt;Rows != rows) {</a>
<a name="ln6286">    wp-&gt;w_lines_valid = 0;</a>
<a name="ln6287">    xfree(wp-&gt;w_lines);</a>
<a name="ln6288">    wp-&gt;w_lines = xcalloc(rows+1, sizeof(wline_T));</a>
<a name="ln6289">  }</a>
<a name="ln6290"> </a>
<a name="ln6291">  int was_resized = false;</a>
<a name="ln6292">  if (want_allocation &amp;&amp; (!has_allocation</a>
<a name="ln6293">                          || grid_allocated-&gt;Rows != total_rows</a>
<a name="ln6294">                          || grid_allocated-&gt;Columns != total_cols)) {</a>
<a name="ln6295">    grid_alloc(grid_allocated, total_rows, total_cols,</a>
<a name="ln6296">               wp-&gt;w_grid_alloc.valid, false);</a>
<a name="ln6297">    grid_allocated-&gt;valid = true;</a>
<a name="ln6298">    if (wp-&gt;w_floating &amp;&amp; wp-&gt;w_float_config.border) {</a>
<a name="ln6299">      wp-&gt;w_redr_border = true;</a>
<a name="ln6300">    }</a>
<a name="ln6301">    was_resized = true;</a>
<a name="ln6302">  } else if (!want_allocation &amp;&amp; has_allocation) {</a>
<a name="ln6303">    // Single grid mode, all rendering will be redirected to default_grid.</a>
<a name="ln6304">    // Only keep track of the size and offset of the window.</a>
<a name="ln6305">    grid_free(grid_allocated);</a>
<a name="ln6306">    grid_allocated-&gt;valid = false;</a>
<a name="ln6307">    was_resized = true;</a>
<a name="ln6308">  } else if (want_allocation &amp;&amp; has_allocation &amp;&amp; !wp-&gt;w_grid_alloc.valid) {</a>
<a name="ln6309">    grid_invalidate(grid_allocated);</a>
<a name="ln6310">    grid_allocated-&gt;valid = true;</a>
<a name="ln6311">  }</a>
<a name="ln6312"> </a>
<a name="ln6313">  grid-&gt;Rows = rows;</a>
<a name="ln6314">  grid-&gt;Columns = cols;</a>
<a name="ln6315"> </a>
<a name="ln6316">  if (want_allocation) {</a>
<a name="ln6317">    grid-&gt;target = grid_allocated;</a>
<a name="ln6318">    grid-&gt;row_offset = wp-&gt;w_border_adj[0];</a>
<a name="ln6319">    grid-&gt;col_offset = wp-&gt;w_border_adj[3];</a>
<a name="ln6320">  } else {</a>
<a name="ln6321">    grid-&gt;target = &amp;default_grid;</a>
<a name="ln6322">    grid-&gt;row_offset = wp-&gt;w_winrow;</a>
<a name="ln6323">    grid-&gt;col_offset = wp-&gt;w_wincol;</a>
<a name="ln6324">  }</a>
<a name="ln6325"> </a>
<a name="ln6326">  // send grid resize event if:</a>
<a name="ln6327">  // - a grid was just resized</a>
<a name="ln6328">  // - screen_resize was called and all grid sizes must be sent</a>
<a name="ln6329">  // - the UI wants multigrid event (necessary)</a>
<a name="ln6330">  if ((send_grid_resize || was_resized) &amp;&amp; want_allocation) {</a>
<a name="ln6331">    ui_call_grid_resize(grid_allocated-&gt;handle,</a>
<a name="ln6332">                        grid_allocated-&gt;Columns, grid_allocated-&gt;Rows);</a>
<a name="ln6333">  }</a>
<a name="ln6334">}</a>
<a name="ln6335"> </a>
<a name="ln6336">/// assign a handle to the grid. The grid need not be allocated.</a>
<a name="ln6337">void grid_assign_handle(ScreenGrid *grid)</a>
<a name="ln6338">{</a>
<a name="ln6339">  static int last_grid_handle = DEFAULT_GRID_HANDLE;</a>
<a name="ln6340"> </a>
<a name="ln6341">  // only assign a grid handle if not already</a>
<a name="ln6342">  if (grid-&gt;handle == 0) {</a>
<a name="ln6343">    grid-&gt;handle = ++last_grid_handle;</a>
<a name="ln6344">  }</a>
<a name="ln6345">}</a>
<a name="ln6346"> </a>
<a name="ln6347">/// Resize the screen to Rows and Columns.</a>
<a name="ln6348">///</a>
<a name="ln6349">/// Allocate default_grid.chars[] and other grid arrays.</a>
<a name="ln6350">///</a>
<a name="ln6351">/// There may be some time between setting Rows and Columns and (re)allocating</a>
<a name="ln6352">/// default_grid arrays.  This happens when starting up and when</a>
<a name="ln6353">/// (manually) changing the shell size.  Always use default_grid.Rows and</a>
<a name="ln6354">/// default_grid.Columns to access items in default_grid.chars[].  Use Rows</a>
<a name="ln6355">/// and Columns for positioning text etc. where the final size of the shell is</a>
<a name="ln6356">/// needed.</a>
<a name="ln6357">void screenalloc(void)</a>
<a name="ln6358">{</a>
<a name="ln6359">  // It's possible that we produce an out-of-memory message below, which</a>
<a name="ln6360">  // will cause this function to be called again.  To break the loop, just</a>
<a name="ln6361">  // return here.</a>
<a name="ln6362">  if (resizing) {</a>
<a name="ln6363">    return;</a>
<a name="ln6364">  }</a>
<a name="ln6365">  resizing = true;</a>
<a name="ln6366"> </a>
<a name="ln6367">  int retry_count = 0;</a>
<a name="ln6368"> </a>
<a name="ln6369">retry:</a>
<a name="ln6370">  // Allocation of the screen buffers is done only when the size changes and</a>
<a name="ln6371">  // when Rows and Columns have been set and we have started doing full</a>
<a name="ln6372">  // screen stuff.</a>
<a name="ln6373">  if ((default_grid.chars != NULL</a>
<a name="ln6374">       &amp;&amp; Rows == default_grid.Rows</a>
<a name="ln6375">       &amp;&amp; Columns == default_grid.Columns</a>
<a name="ln6376">       )</a>
<a name="ln6377">      || Rows == 0</a>
<a name="ln6378">      || Columns == 0</a>
<a name="ln6379">      || (!full_screen &amp;&amp; default_grid.chars == NULL)) {</a>
<a name="ln6380">    resizing = false;</a>
<a name="ln6381">    return;</a>
<a name="ln6382">  }</a>
<a name="ln6383"> </a>
<a name="ln6384">  /*</a>
<a name="ln6385">   * Note that the window sizes are updated before reallocating the arrays,</a>
<a name="ln6386">   * thus we must not redraw here!</a>
<a name="ln6387">   */</a>
<a name="ln6388">  ++RedrawingDisabled;</a>
<a name="ln6389"> </a>
<a name="ln6390">  // win_new_shellsize will recompute floats position, but tell the</a>
<a name="ln6391">  // compositor to not redraw them yet</a>
<a name="ln6392">  ui_comp_set_screen_valid(false);</a>
<a name="ln6393">  if (msg_grid.chars) {</a>
<a name="ln6394">    msg_grid_invalid = true;</a>
<a name="ln6395">  }</a>
<a name="ln6396"> </a>
<a name="ln6397">  win_new_shellsize();      /* fit the windows in the new sized shell */</a>
<a name="ln6398"> </a>
<a name="ln6399">  comp_col();           /* recompute columns for shown command and ruler */</a>
<a name="ln6400"> </a>
<a name="ln6401">  // We're changing the size of the screen.</a>
<a name="ln6402">  // - Allocate new arrays for default_grid</a>
<a name="ln6403">  // - Move lines from the old arrays into the new arrays, clear extra</a>
<a name="ln6404">  //   lines (unless the screen is going to be cleared).</a>
<a name="ln6405">  // - Free the old arrays.</a>
<a name="ln6406">  //</a>
<a name="ln6407">  // If anything fails, make grid arrays NULL, so we don't do anything!</a>
<a name="ln6408">  // Continuing with the old arrays may result in a crash, because the</a>
<a name="ln6409">  // size is wrong.</a>
<a name="ln6410"> </a>
<a name="ln6411">  grid_alloc(&amp;default_grid, Rows, Columns, true, true);</a>
<a name="ln6412">  StlClickDefinition *new_tab_page_click_defs = xcalloc(</a>
<a name="ln6413">      (size_t)Columns, sizeof(*new_tab_page_click_defs));</a>
<a name="ln6414"> </a>
<a name="ln6415">  clear_tab_page_click_defs(tab_page_click_defs, tab_page_click_defs_size);</a>
<a name="ln6416">  xfree(tab_page_click_defs);</a>
<a name="ln6417"> </a>
<a name="ln6418">  tab_page_click_defs = new_tab_page_click_defs;</a>
<a name="ln6419">  tab_page_click_defs_size = Columns;</a>
<a name="ln6420"> </a>
<a name="ln6421">  default_grid.comp_height = Rows;</a>
<a name="ln6422">  default_grid.comp_width = Columns;</a>
<a name="ln6423"> </a>
<a name="ln6424">  default_grid.row_offset = 0;</a>
<a name="ln6425">  default_grid.col_offset = 0;</a>
<a name="ln6426">  default_grid.handle = DEFAULT_GRID_HANDLE;</a>
<a name="ln6427"> </a>
<a name="ln6428">  must_redraw = CLEAR;  // need to clear the screen later</a>
<a name="ln6429"> </a>
<a name="ln6430">  RedrawingDisabled--;</a>
<a name="ln6431"> </a>
<a name="ln6432">  /*</a>
<a name="ln6433">   * Do not apply autocommands more than 3 times to avoid an endless loop</a>
<a name="ln6434">   * in case applying autocommands always changes Rows or Columns.</a>
<a name="ln6435">   */</a>
<a name="ln6436">  if (starting == 0 &amp;&amp; ++retry_count &lt;= 3) {</a>
<a name="ln6437">    apply_autocmds(EVENT_VIMRESIZED, NULL, NULL, FALSE, curbuf);</a>
<a name="ln6438">    /* In rare cases, autocommands may have altered Rows or Columns,</a>
<a name="ln6439">    * jump back to check if we need to allocate the screen again. */</a>
<a name="ln6440">    goto retry;</a>
<a name="ln6441">  }</a>
<a name="ln6442"> </a>
<a name="ln6443">  resizing = false;</a>
<a name="ln6444">}</a>
<a name="ln6445"> </a>
<a name="ln6446">void grid_alloc(ScreenGrid *grid, int rows, int columns, bool copy, bool valid)</a>
<a name="ln6447">{</a>
<a name="ln6448">  int new_row;</a>
<a name="ln6449">  ScreenGrid new = *grid;</a>
<a name="ln6450">  assert(rows &gt;= 0 &amp;&amp; columns &gt;= 0);</a>
<a name="ln6451">  size_t ncells = (size_t)rows * columns;</a>
<a name="ln6452">  new.chars = xmalloc(ncells * sizeof(schar_T));</a>
<a name="ln6453">  new.attrs = xmalloc(ncells * sizeof(sattr_T));</a>
<a name="ln6454">  new.line_offset = xmalloc((size_t)(rows * sizeof(unsigned)));</a>
<a name="ln6455">  new.line_wraps = xmalloc((size_t)(rows * sizeof(char_u)));</a>
<a name="ln6456"> </a>
<a name="ln6457">  new.Rows = rows;</a>
<a name="ln6458">  new.Columns = columns;</a>
<a name="ln6459"> </a>
<a name="ln6460">  for (new_row = 0; new_row &lt; new.Rows; new_row++) {</a>
<a name="ln6461">    new.line_offset[new_row] = new_row * new.Columns;</a>
<a name="ln6462">    new.line_wraps[new_row] = false;</a>
<a name="ln6463"> </a>
<a name="ln6464">    grid_clear_line(&amp;new, new.line_offset[new_row], columns, valid);</a>
<a name="ln6465"> </a>
<a name="ln6466">    if (copy) {</a>
<a name="ln6467">      // If the screen is not going to be cleared, copy as much as</a>
<a name="ln6468">      // possible from the old screen to the new one and clear the rest</a>
<a name="ln6469">      // (used when resizing the window at the &quot;--more--&quot; prompt or when</a>
<a name="ln6470">      // executing an external command, for the GUI).</a>
<a name="ln6471">      if (new_row &lt; grid-&gt;Rows &amp;&amp; grid-&gt;chars != NULL) {</a>
<a name="ln6472">        int len = MIN(grid-&gt;Columns, new.Columns);</a>
<a name="ln6473">        memmove(new.chars + new.line_offset[new_row],</a>
<a name="ln6474">                grid-&gt;chars + grid-&gt;line_offset[new_row],</a>
<a name="ln6475">                (size_t)len * sizeof(schar_T));</a>
<a name="ln6476">        memmove(new.attrs + new.line_offset[new_row],</a>
<a name="ln6477">                grid-&gt;attrs + grid-&gt;line_offset[new_row],</a>
<a name="ln6478">                (size_t)len * sizeof(sattr_T));</a>
<a name="ln6479">      }</a>
<a name="ln6480">    }</a>
<a name="ln6481">  }</a>
<a name="ln6482">  grid_free(grid);</a>
<a name="ln6483">  *grid = new;</a>
<a name="ln6484"> </a>
<a name="ln6485">  // Share a single scratch buffer for all grids, by</a>
<a name="ln6486">  // ensuring it is as wide as the widest grid.</a>
<a name="ln6487">  if (linebuf_size &lt; (size_t)columns) {</a>
<a name="ln6488">    xfree(linebuf_char);</a>
<a name="ln6489">    xfree(linebuf_attr);</a>
<a name="ln6490">    linebuf_char = xmalloc(columns * sizeof(schar_T));</a>
<a name="ln6491">    linebuf_attr = xmalloc(columns * sizeof(sattr_T));</a>
<a name="ln6492">    linebuf_size = columns;</a>
<a name="ln6493">  }</a>
<a name="ln6494">}</a>
<a name="ln6495"> </a>
<a name="ln6496">void grid_free(ScreenGrid *grid)</a>
<a name="ln6497">{</a>
<a name="ln6498">  xfree(grid-&gt;chars);</a>
<a name="ln6499">  xfree(grid-&gt;attrs);</a>
<a name="ln6500">  xfree(grid-&gt;line_offset);</a>
<a name="ln6501">  xfree(grid-&gt;line_wraps);</a>
<a name="ln6502"> </a>
<a name="ln6503">  grid-&gt;chars = NULL;</a>
<a name="ln6504">  grid-&gt;attrs = NULL;</a>
<a name="ln6505">  grid-&gt;line_offset = NULL;</a>
<a name="ln6506">  grid-&gt;line_wraps = NULL;</a>
<a name="ln6507">}</a>
<a name="ln6508"> </a>
<a name="ln6509">/// Doesn't allow reinit, so must only be called by free_all_mem!</a>
<a name="ln6510">void screen_free_all_mem(void)</a>
<a name="ln6511">{</a>
<a name="ln6512">  grid_free(&amp;default_grid);</a>
<a name="ln6513">  xfree(linebuf_char);</a>
<a name="ln6514">  xfree(linebuf_attr);</a>
<a name="ln6515">}</a>
<a name="ln6516"> </a>
<a name="ln6517">/// Clear tab_page_click_defs table</a>
<a name="ln6518">///</a>
<a name="ln6519">/// @param[out]  tpcd  Table to clear.</a>
<a name="ln6520">/// @param[in]  tpcd_size  Size of the table.</a>
<a name="ln6521">void clear_tab_page_click_defs(StlClickDefinition *const tpcd,</a>
<a name="ln6522">                               const long tpcd_size)</a>
<a name="ln6523">{</a>
<a name="ln6524">  if (tpcd != NULL) {</a>
<a name="ln6525">    for (long i = 0; i &lt; tpcd_size; i++) {</a>
<a name="ln6526">      if (i == 0 || tpcd[i].func != tpcd[i - 1].func) {</a>
<a name="ln6527">        xfree(tpcd[i].func);</a>
<a name="ln6528">      }</a>
<a name="ln6529">    }</a>
<a name="ln6530">    memset(tpcd, 0, (size_t) tpcd_size * sizeof(tpcd[0]));</a>
<a name="ln6531">  }</a>
<a name="ln6532">}</a>
<a name="ln6533"> </a>
<a name="ln6534">void screenclear(void)</a>
<a name="ln6535">{</a>
<a name="ln6536">  check_for_delay(false);</a>
<a name="ln6537">  screenalloc();  // allocate screen buffers if size changed</a>
<a name="ln6538"> </a>
<a name="ln6539">  int i;</a>
<a name="ln6540"> </a>
<a name="ln6541">  if (starting == NO_SCREEN || default_grid.chars == NULL) {</a>
<a name="ln6542">    return;</a>
<a name="ln6543">  }</a>
<a name="ln6544"> </a>
<a name="ln6545">  // blank out the default grid</a>
<a name="ln6546">  for (i = 0; i &lt; default_grid.Rows; i++) {</a>
<a name="ln6547">    grid_clear_line(&amp;default_grid, default_grid.line_offset[i],</a>
<a name="ln6548">                    (int)default_grid.Columns, true);</a>
<a name="ln6549">    default_grid.line_wraps[i] = false;</a>
<a name="ln6550">  }</a>
<a name="ln6551"> </a>
<a name="ln6552">  ui_call_grid_clear(1);  // clear the display</a>
<a name="ln6553">  ui_comp_set_screen_valid(true);</a>
<a name="ln6554"> </a>
<a name="ln6555">  clear_cmdline = false;</a>
<a name="ln6556">  mode_displayed = false;</a>
<a name="ln6557"> </a>
<a name="ln6558">  redraw_all_later(NOT_VALID);</a>
<a name="ln6559">  redraw_cmdline = true;</a>
<a name="ln6560">  redraw_tabline = true;</a>
<a name="ln6561">  redraw_popupmenu = true;</a>
<a name="ln6562">  pum_invalidate();</a>
<a name="ln6563">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln6564">    if (wp-&gt;w_floating) {</a>
<a name="ln6565">      wp-&gt;w_redr_type = CLEAR;</a>
<a name="ln6566">    }</a>
<a name="ln6567">  }</a>
<a name="ln6568">  if (must_redraw == CLEAR) {</a>
<a name="ln6569">    must_redraw = NOT_VALID;  // no need to clear again</a>
<a name="ln6570">  }</a>
<a name="ln6571">  compute_cmdrow();</a>
<a name="ln6572">  msg_row = cmdline_row;  // put cursor on last line for messages</a>
<a name="ln6573">  msg_col = 0;</a>
<a name="ln6574">  msg_scrolled = 0;  // can't scroll back</a>
<a name="ln6575">  msg_didany = false;</a>
<a name="ln6576">  msg_didout = false;</a>
<a name="ln6577">  if (HL_ATTR(HLF_MSG) &gt; 0 &amp;&amp; msg_use_grid() &amp;&amp; msg_grid.chars) {</a>
<a name="ln6578">    grid_invalidate(&amp;msg_grid);</a>
<a name="ln6579">    msg_grid_validate();</a>
<a name="ln6580">    msg_grid_invalid = false;</a>
<a name="ln6581">    clear_cmdline = true;</a>
<a name="ln6582">  }</a>
<a name="ln6583">}</a>
<a name="ln6584"> </a>
<a name="ln6585">/// clear a line in the grid starting at &quot;off&quot; until &quot;width&quot; characters</a>
<a name="ln6586">/// are cleared.</a>
<a name="ln6587">void grid_clear_line(ScreenGrid *grid, unsigned off, int width, bool valid)</a>
<a name="ln6588">{</a>
<a name="ln6589">  for (int col = 0; col &lt; width; col++) {</a>
<a name="ln6590">    schar_from_ascii(grid-&gt;chars[off + col], ' ');</a>
<a name="ln6591">  }</a>
<a name="ln6592">  int fill = valid ? 0 : -1;</a>
<a name="ln6593">  (void)memset(grid-&gt;attrs + off, fill, (size_t)width * sizeof(sattr_T));</a>
<a name="ln6594">}</a>
<a name="ln6595"> </a>
<a name="ln6596">void grid_invalidate(ScreenGrid *grid)</a>
<a name="ln6597">{</a>
<a name="ln6598">  (void)memset(grid-&gt;attrs, -1, grid-&gt;Rows * grid-&gt;Columns * sizeof(sattr_T));</a>
<a name="ln6599">}</a>
<a name="ln6600"> </a>
<a name="ln6601">bool grid_invalid_row(ScreenGrid *grid, int row)</a>
<a name="ln6602">{</a>
<a name="ln6603">  return grid-&gt;attrs[grid-&gt;line_offset[row]] &lt; 0;</a>
<a name="ln6604">}</a>
<a name="ln6605"> </a>
<a name="ln6606"> </a>
<a name="ln6607"> </a>
<a name="ln6608">/// Copy part of a grid line for vertically split window.</a>
<a name="ln6609">static void linecopy(ScreenGrid *grid, int to, int from, int col, int width)</a>
<a name="ln6610">{</a>
<a name="ln6611">  unsigned off_to = grid-&gt;line_offset[to] + col;</a>
<a name="ln6612">  unsigned off_from = grid-&gt;line_offset[from] + col;</a>
<a name="ln6613"> </a>
<a name="ln6614">  memmove(grid-&gt;chars + off_to, grid-&gt;chars + off_from,</a>
<a name="ln6615">          width * sizeof(schar_T));</a>
<a name="ln6616">  memmove(grid-&gt;attrs + off_to, grid-&gt;attrs + off_from,</a>
<a name="ln6617">          width * sizeof(sattr_T));</a>
<a name="ln6618">}</a>
<a name="ln6619"> </a>
<a name="ln6620">/*</a>
<a name="ln6621"> * Set cursor to its position in the current window.</a>
<a name="ln6622"> */</a>
<a name="ln6623">void setcursor(void)</a>
<a name="ln6624">{</a>
<a name="ln6625">  if (redrawing()) {</a>
<a name="ln6626">    validate_cursor();</a>
<a name="ln6627"> </a>
<a name="ln6628">    ScreenGrid *grid = &amp;curwin-&gt;w_grid;</a>
<a name="ln6629">    int row = curwin-&gt;w_wrow;</a>
<a name="ln6630">    int col = curwin-&gt;w_wcol;</a>
<a name="ln6631">    if (curwin-&gt;w_p_rl) {</a>
<a name="ln6632">      // With 'rightleft' set and the cursor on a double-wide character,</a>
<a name="ln6633">      // position it on the leftmost column.</a>
<a name="ln6634">      col = curwin-&gt;w_width_inner - curwin-&gt;w_wcol</a>
<a name="ln6635">                    - ((utf_ptr2cells(get_cursor_pos_ptr()) == 2</a>
<a name="ln6636">                        &amp;&amp; vim_isprintc(gchar_cursor())) ? 2 : 1);</a>
<a name="ln6637">    }</a>
<a name="ln6638"> </a>
<a name="ln6639">    screen_adjust_grid(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln6640">    ui_grid_cursor_goto(grid-&gt;handle, row, col);</a>
<a name="ln6641">  }</a>
<a name="ln6642">}</a>
<a name="ln6643"> </a>
<a name="ln6644">/// Scroll 'line_count' lines at 'row' in window 'wp'.</a>
<a name="ln6645">///</a>
<a name="ln6646">/// Positive `line_count' means scrolling down, so that more space is available</a>
<a name="ln6647">/// at 'row'. Negative `line_count` implies deleting lines at `row`.</a>
<a name="ln6648">void win_scroll_lines(win_T *wp, int row, int line_count)</a>
<a name="ln6649">{</a>
<a name="ln6650">  if (!redrawing() || line_count == 0) {</a>
<a name="ln6651">    return;</a>
<a name="ln6652">  }</a>
<a name="ln6653"> </a>
<a name="ln6654">  // No lines are being moved, just draw over the entire area</a>
<a name="ln6655">  if (row + abs(line_count) &gt;= wp-&gt;w_grid.Rows) {</a>
<a name="ln6656">    return;</a>
<a name="ln6657">  }</a>
<a name="ln6658"> </a>
<a name="ln6659">  if (line_count &lt; 0) {</a>
<a name="ln6660">    grid_del_lines(&amp;wp-&gt;w_grid, row, -line_count,</a>
<a name="ln6661">                   wp-&gt;w_grid.Rows, 0, wp-&gt;w_grid.Columns);</a>
<a name="ln6662">  } else {</a>
<a name="ln6663">    grid_ins_lines(&amp;wp-&gt;w_grid, row, line_count,</a>
<a name="ln6664">                   wp-&gt;w_grid.Rows, 0, wp-&gt;w_grid.Columns);</a>
<a name="ln6665">  }</a>
<a name="ln6666">}</a>
<a name="ln6667"> </a>
<a name="ln6668">/*</a>
<a name="ln6669"> * The rest of the routines in this file perform screen manipulations. The</a>
<a name="ln6670"> * given operation is performed physically on the screen. The corresponding</a>
<a name="ln6671"> * change is also made to the internal screen image. In this way, the editor</a>
<a name="ln6672"> * anticipates the effect of editing changes on the appearance of the screen.</a>
<a name="ln6673"> * That way, when we call screenupdate a complete redraw isn't usually</a>
<a name="ln6674"> * necessary. Another advantage is that we can keep adding code to anticipate</a>
<a name="ln6675"> * screen changes, and in the meantime, everything still works.</a>
<a name="ln6676"> */</a>
<a name="ln6677"> </a>
<a name="ln6678"> </a>
<a name="ln6679">/// insert lines on the screen and move the existing lines down</a>
<a name="ln6680">/// 'line_count' is the number of lines to be inserted.</a>
<a name="ln6681">/// 'end' is the line after the scrolled part. Normally it is Rows.</a>
<a name="ln6682">/// 'col' is the column from with we start inserting.</a>
<a name="ln6683">//</a>
<a name="ln6684">/// 'row', 'col' and 'end' are relative to the start of the region.</a>
<a name="ln6685">void grid_ins_lines(ScreenGrid *grid, int row, int line_count, int end, int col,</a>
<a name="ln6686">                    int width)</a>
<a name="ln6687">{</a>
<a name="ln6688">  int i;</a>
<a name="ln6689">  int j;</a>
<a name="ln6690">  unsigned temp;</a>
<a name="ln6691"> </a>
<a name="ln6692">  int row_off = 0;</a>
<a name="ln6693">  screen_adjust_grid(&amp;grid, &amp;row_off, &amp;col);</a>
<a name="ln6694">  row += row_off;</a>
<a name="ln6695">  end += row_off;</a>
<a name="ln6696"> </a>
<a name="ln6697">  if (line_count &lt;= 0) {</a>
<a name="ln6698">    return;</a>
<a name="ln6699">  }</a>
<a name="ln6700"> </a>
<a name="ln6701">  // Shift line_offset[] line_count down to reflect the inserted lines.</a>
<a name="ln6702">  // Clear the inserted lines.</a>
<a name="ln6703">  for (i = 0; i &lt; line_count; i++) {</a>
<a name="ln6704">    if (width != grid-&gt;Columns) {</a>
<a name="ln6705">      // need to copy part of a line</a>
<a name="ln6706">      j = end - 1 - i;</a>
<a name="ln6707">      while ((j -= line_count) &gt;= row) {</a>
<a name="ln6708">        linecopy(grid, j + line_count, j, col, width);</a>
<a name="ln6709">      }</a>
<a name="ln6710">      j += line_count;</a>
<a name="ln6711">      grid_clear_line(grid, grid-&gt;line_offset[j] + col, width, false);</a>
<a name="ln6712">      grid-&gt;line_wraps[j] = false;</a>
<a name="ln6713">    } else {</a>
<a name="ln6714">      j = end - 1 - i;</a>
<a name="ln6715">      temp = grid-&gt;line_offset[j];</a>
<a name="ln6716">      while ((j -= line_count) &gt;= row) {</a>
<a name="ln6717">        grid-&gt;line_offset[j + line_count] = grid-&gt;line_offset[j];</a>
<a name="ln6718">        grid-&gt;line_wraps[j + line_count] = grid-&gt;line_wraps[j];</a>
<a name="ln6719">      }</a>
<a name="ln6720">      grid-&gt;line_offset[j + line_count] = temp;</a>
<a name="ln6721">      grid-&gt;line_wraps[j + line_count] = false;</a>
<a name="ln6722">      grid_clear_line(grid, temp, (int)grid-&gt;Columns, false);</a>
<a name="ln6723">    }</a>
<a name="ln6724">  }</a>
<a name="ln6725"> </a>
<a name="ln6726">  if (!grid-&gt;throttled) {</a>
<a name="ln6727">    ui_call_grid_scroll(grid-&gt;handle, row, end, col, col+width, -line_count, 0);</a>
<a name="ln6728">  }</a>
<a name="ln6729"> </a>
<a name="ln6730">  return;</a>
<a name="ln6731">}</a>
<a name="ln6732"> </a>
<a name="ln6733">/// delete lines on the screen and move lines up.</a>
<a name="ln6734">/// 'end' is the line after the scrolled part. Normally it is Rows.</a>
<a name="ln6735">/// When scrolling region used 'off' is the offset from the top for the region.</a>
<a name="ln6736">/// 'row' and 'end' are relative to the start of the region.</a>
<a name="ln6737">void grid_del_lines(ScreenGrid *grid, int row, int line_count, int end, int col,</a>
<a name="ln6738">                    int width)</a>
<a name="ln6739">{</a>
<a name="ln6740">  int j;</a>
<a name="ln6741">  int i;</a>
<a name="ln6742">  unsigned temp;</a>
<a name="ln6743"> </a>
<a name="ln6744">  int row_off = 0;</a>
<a name="ln6745">  screen_adjust_grid(&amp;grid, &amp;row_off, &amp;col);</a>
<a name="ln6746">  row += row_off;</a>
<a name="ln6747">  end += row_off;</a>
<a name="ln6748"> </a>
<a name="ln6749">  if (line_count &lt;= 0) {</a>
<a name="ln6750">    return;</a>
<a name="ln6751">  }</a>
<a name="ln6752"> </a>
<a name="ln6753">  // Now shift line_offset[] line_count up to reflect the deleted lines.</a>
<a name="ln6754">  // Clear the inserted lines.</a>
<a name="ln6755">  for (i = 0; i &lt; line_count; i++) {</a>
<a name="ln6756">    if (width != grid-&gt;Columns) {</a>
<a name="ln6757">      // need to copy part of a line</a>
<a name="ln6758">      j = row + i;</a>
<a name="ln6759">      while ((j += line_count) &lt;= end - 1) {</a>
<a name="ln6760">        linecopy(grid, j - line_count, j, col, width);</a>
<a name="ln6761">      }</a>
<a name="ln6762">      j -= line_count;</a>
<a name="ln6763">      grid_clear_line(grid, grid-&gt;line_offset[j] + col, width, false);</a>
<a name="ln6764">      grid-&gt;line_wraps[j] = false;</a>
<a name="ln6765">    } else {</a>
<a name="ln6766">      // whole width, moving the line pointers is faster</a>
<a name="ln6767">      j = row + i;</a>
<a name="ln6768">      temp = grid-&gt;line_offset[j];</a>
<a name="ln6769">      while ((j += line_count) &lt;= end - 1) {</a>
<a name="ln6770">        grid-&gt;line_offset[j - line_count] = grid-&gt;line_offset[j];</a>
<a name="ln6771">        grid-&gt;line_wraps[j - line_count] = grid-&gt;line_wraps[j];</a>
<a name="ln6772">      }</a>
<a name="ln6773">      grid-&gt;line_offset[j - line_count] = temp;</a>
<a name="ln6774">      grid-&gt;line_wraps[j - line_count] = false;</a>
<a name="ln6775">      grid_clear_line(grid, temp, (int)grid-&gt;Columns, false);</a>
<a name="ln6776">    }</a>
<a name="ln6777">  }</a>
<a name="ln6778"> </a>
<a name="ln6779">  if (!grid-&gt;throttled) {</a>
<a name="ln6780">    ui_call_grid_scroll(grid-&gt;handle, row, end, col, col+width, line_count, 0);</a>
<a name="ln6781">  }</a>
<a name="ln6782"> </a>
<a name="ln6783">  return;</a>
<a name="ln6784">}</a>
<a name="ln6785"> </a>
<a name="ln6786"> </a>
<a name="ln6787">// Show the current mode and ruler.</a>
<a name="ln6788">//</a>
<a name="ln6789">// If clear_cmdline is TRUE, clear the rest of the cmdline.</a>
<a name="ln6790">// If clear_cmdline is FALSE there may be a message there that needs to be</a>
<a name="ln6791">// cleared only if a mode is shown.</a>
<a name="ln6792">// Return the length of the message (0 if no message).</a>
<a name="ln6793">int showmode(void)</a>
<a name="ln6794">{</a>
<a name="ln6795">  int need_clear;</a>
<a name="ln6796">  int length = 0;</a>
<a name="ln6797">  int do_mode;</a>
<a name="ln6798">  int attr;</a>
<a name="ln6799">  int nwr_save;</a>
<a name="ln6800">  int sub_attr;</a>
<a name="ln6801"> </a>
<a name="ln6802">  if (ui_has(kUIMessages) &amp;&amp; clear_cmdline) {</a>
<a name="ln6803">    msg_ext_clear(true);</a>
<a name="ln6804">  }</a>
<a name="ln6805"> </a>
<a name="ln6806">  // don't make non-flushed message part of the showmode</a>
<a name="ln6807">  msg_ext_ui_flush();</a>
<a name="ln6808"> </a>
<a name="ln6809">  msg_grid_validate();</a>
<a name="ln6810"> </a>
<a name="ln6811">  do_mode = ((p_smd &amp;&amp; msg_silent == 0)</a>
<a name="ln6812">             &amp;&amp; ((State &amp; TERM_FOCUS)</a>
<a name="ln6813">                 || (State &amp; INSERT)</a>
<a name="ln6814">                 || restart_edit</a>
<a name="ln6815">                 || VIsual_active));</a>
<a name="ln6816">  if (do_mode || reg_recording != 0) {</a>
<a name="ln6817">    // Don't show mode right now, when not redrawing or inside a mapping.</a>
<a name="ln6818">    // Call char_avail() only when we are going to show something, because</a>
<a name="ln6819">    // it takes a bit of time.</a>
<a name="ln6820">    if (!redrawing() || (char_avail() &amp;&amp; !KeyTyped) || msg_silent != 0) {</a>
<a name="ln6821">      redraw_cmdline = TRUE;                    /* show mode later */</a>
<a name="ln6822">      return 0;</a>
<a name="ln6823">    }</a>
<a name="ln6824"> </a>
<a name="ln6825">    nwr_save = need_wait_return;</a>
<a name="ln6826"> </a>
<a name="ln6827">    /* wait a bit before overwriting an important message */</a>
<a name="ln6828">    check_for_delay(FALSE);</a>
<a name="ln6829"> </a>
<a name="ln6830">    /* if the cmdline is more than one line high, erase top lines */</a>
<a name="ln6831">    need_clear = clear_cmdline;</a>
<a name="ln6832">    if (clear_cmdline &amp;&amp; cmdline_row &lt; Rows - 1) {</a>
<a name="ln6833">      msg_clr_cmdline();  // will reset clear_cmdline</a>
<a name="ln6834">    }</a>
<a name="ln6835"> </a>
<a name="ln6836">    /* Position on the last line in the window, column 0 */</a>
<a name="ln6837">    msg_pos_mode();</a>
<a name="ln6838">    attr = HL_ATTR(HLF_CM);                     // Highlight mode</a>
<a name="ln6839"> </a>
<a name="ln6840">    // When the screen is too narrow to show the entire mode messsage,</a>
<a name="ln6841">    // avoid scrolling and truncate instead.</a>
<a name="ln6842">    msg_no_more = true;</a>
<a name="ln6843">    int save_lines_left = lines_left;</a>
<a name="ln6844">    lines_left = 0;</a>
<a name="ln6845"> </a>
<a name="ln6846">    if (do_mode) {</a>
<a name="ln6847">      MSG_PUTS_ATTR(&quot;--&quot;, attr);</a>
<a name="ln6848">      // CTRL-X in Insert mode</a>
<a name="ln6849">      if (edit_submode != NULL &amp;&amp; !shortmess(SHM_COMPLETIONMENU)) {</a>
<a name="ln6850">        // These messages can get long, avoid a wrap in a narrow window.</a>
<a name="ln6851">        // Prefer showing edit_submode_extra. With external messages there</a>
<a name="ln6852">        // is no imposed limit.</a>
<a name="ln6853">        if (ui_has(kUIMessages)) {</a>
<a name="ln6854">          length = INT_MAX;</a>
<a name="ln6855">        } else {</a>
<a name="ln6856">          length = (Rows - msg_row) * Columns - 3;</a>
<a name="ln6857">        }</a>
<a name="ln6858">        if (edit_submode_extra != NULL) {</a>
<a name="ln6859">          length -= vim_strsize(edit_submode_extra);</a>
<a name="ln6860">        }</a>
<a name="ln6861">        if (length &gt; 0) {</a>
<a name="ln6862">          if (edit_submode_pre != NULL)</a>
<a name="ln6863">            length -= vim_strsize(edit_submode_pre);</a>
<a name="ln6864">          if (length - vim_strsize(edit_submode) &gt; 0) {</a>
<a name="ln6865">            if (edit_submode_pre != NULL) {</a>
<a name="ln6866">              msg_puts_attr((const char *)edit_submode_pre, attr);</a>
<a name="ln6867">            }</a>
<a name="ln6868">            msg_puts_attr((const char *)edit_submode, attr);</a>
<a name="ln6869">          }</a>
<a name="ln6870">          if (edit_submode_extra != NULL) {</a>
<a name="ln6871">            MSG_PUTS_ATTR(&quot; &quot;, attr);  // Add a space in between.</a>
<a name="ln6872">            if ((int)edit_submode_highl &lt; (int)HLF_COUNT) {</a>
<a name="ln6873">              sub_attr = win_hl_attr(curwin, edit_submode_highl);</a>
<a name="ln6874">            } else {</a>
<a name="ln6875">              sub_attr = attr;</a>
<a name="ln6876">            }</a>
<a name="ln6877">            msg_puts_attr((const char *)edit_submode_extra, sub_attr);</a>
<a name="ln6878">          }</a>
<a name="ln6879">        }</a>
<a name="ln6880">      } else {</a>
<a name="ln6881">        if (State &amp; TERM_FOCUS) {</a>
<a name="ln6882">          MSG_PUTS_ATTR(_(&quot; TERMINAL&quot;), attr);</a>
<a name="ln6883">        } else if (State &amp; VREPLACE_FLAG)</a>
<a name="ln6884">          MSG_PUTS_ATTR(_(&quot; VREPLACE&quot;), attr);</a>
<a name="ln6885">        else if (State &amp; REPLACE_FLAG)</a>
<a name="ln6886">          MSG_PUTS_ATTR(_(&quot; REPLACE&quot;), attr);</a>
<a name="ln6887">        else if (State &amp; INSERT) {</a>
<a name="ln6888">          if (p_ri)</a>
<a name="ln6889">            MSG_PUTS_ATTR(_(&quot; REVERSE&quot;), attr);</a>
<a name="ln6890">          MSG_PUTS_ATTR(_(&quot; INSERT&quot;), attr);</a>
<a name="ln6891">        } else if (restart_edit == 'I' || restart_edit == 'i'</a>
<a name="ln6892">                   || restart_edit == 'a') {</a>
<a name="ln6893">          MSG_PUTS_ATTR(_(&quot; (insert)&quot;), attr);</a>
<a name="ln6894">        } else if (restart_edit == 'R') {</a>
<a name="ln6895">          MSG_PUTS_ATTR(_(&quot; (replace)&quot;), attr);</a>
<a name="ln6896">        } else if (restart_edit == 'V') {</a>
<a name="ln6897">          MSG_PUTS_ATTR(_(&quot; (vreplace)&quot;), attr);</a>
<a name="ln6898">        }</a>
<a name="ln6899">        if (p_hkmap) {</a>
<a name="ln6900">          MSG_PUTS_ATTR(_(&quot; Hebrew&quot;), attr);</a>
<a name="ln6901">        }</a>
<a name="ln6902">        if (State &amp; LANGMAP) {</a>
<a name="ln6903">          if (curwin-&gt;w_p_arab) {</a>
<a name="ln6904">            MSG_PUTS_ATTR(_(&quot; Arabic&quot;), attr);</a>
<a name="ln6905">          } else if (get_keymap_str(curwin, (char_u *)&quot; (%s)&quot;,</a>
<a name="ln6906">                                    NameBuff, MAXPATHL)) {</a>
<a name="ln6907">            MSG_PUTS_ATTR(NameBuff, attr);</a>
<a name="ln6908">          }</a>
<a name="ln6909">        }</a>
<a name="ln6910">        if ((State &amp; INSERT) &amp;&amp; p_paste)</a>
<a name="ln6911">          MSG_PUTS_ATTR(_(&quot; (paste)&quot;), attr);</a>
<a name="ln6912"> </a>
<a name="ln6913">        if (VIsual_active) {</a>
<a name="ln6914">          char *p;</a>
<a name="ln6915"> </a>
<a name="ln6916">          /* Don't concatenate separate words to avoid translation</a>
<a name="ln6917">           * problems. */</a>
<a name="ln6918">          switch ((VIsual_select ? 4 : 0)</a>
<a name="ln6919">                  + (VIsual_mode == Ctrl_V) * 2</a>
<a name="ln6920">                  + (VIsual_mode == 'V')) {</a>
<a name="ln6921">          case 0: p = N_(&quot; VISUAL&quot;); break;</a>
<a name="ln6922">          case 1: p = N_(&quot; VISUAL LINE&quot;); break;</a>
<a name="ln6923">          case 2: p = N_(&quot; VISUAL BLOCK&quot;); break;</a>
<a name="ln6924">          case 4: p = N_(&quot; SELECT&quot;); break;</a>
<a name="ln6925">          case 5: p = N_(&quot; SELECT LINE&quot;); break;</a>
<a name="ln6926">          default: p = N_(&quot; SELECT BLOCK&quot;); break;</a>
<a name="ln6927">          }</a>
<a name="ln6928">          MSG_PUTS_ATTR(_(p), attr);</a>
<a name="ln6929">        }</a>
<a name="ln6930">        MSG_PUTS_ATTR(&quot; --&quot;, attr);</a>
<a name="ln6931">      }</a>
<a name="ln6932"> </a>
<a name="ln6933">      need_clear = TRUE;</a>
<a name="ln6934">    }</a>
<a name="ln6935">    if (reg_recording != 0</a>
<a name="ln6936">        &amp;&amp; edit_submode == NULL             // otherwise it gets too long</a>
<a name="ln6937">        ) {</a>
<a name="ln6938">      recording_mode(attr);</a>
<a name="ln6939">      need_clear = true;</a>
<a name="ln6940">    }</a>
<a name="ln6941"> </a>
<a name="ln6942">    mode_displayed = TRUE;</a>
<a name="ln6943">    if (need_clear || clear_cmdline)</a>
<a name="ln6944">      msg_clr_eos();</a>
<a name="ln6945">    msg_didout = FALSE;                 /* overwrite this message */</a>
<a name="ln6946">    length = msg_col;</a>
<a name="ln6947">    msg_col = 0;</a>
<a name="ln6948">    msg_no_more = false;</a>
<a name="ln6949">    lines_left = save_lines_left;</a>
<a name="ln6950">    need_wait_return = nwr_save;        // never ask for hit-return for this</a>
<a name="ln6951">  } else if (clear_cmdline &amp;&amp; msg_silent == 0) {</a>
<a name="ln6952">    // Clear the whole command line.  Will reset &quot;clear_cmdline&quot;.</a>
<a name="ln6953">    msg_clr_cmdline();</a>
<a name="ln6954">  }</a>
<a name="ln6955"> </a>
<a name="ln6956">  // NB: also handles clearing the showmode if it was emtpy or disabled</a>
<a name="ln6957">  msg_ext_flush_showmode();</a>
<a name="ln6958"> </a>
<a name="ln6959">  /* In Visual mode the size of the selected area must be redrawn. */</a>
<a name="ln6960">  if (VIsual_active)</a>
<a name="ln6961">    clear_showcmd();</a>
<a name="ln6962"> </a>
<a name="ln6963">  // If the last window has no status line, the ruler is after the mode</a>
<a name="ln6964">  // message and must be redrawn</a>
<a name="ln6965">  win_T *last = lastwin_nofloating();</a>
<a name="ln6966">  if (redrawing() &amp;&amp; last-&gt;w_status_height == 0) {</a>
<a name="ln6967">    win_redr_ruler(last, true);</a>
<a name="ln6968">  }</a>
<a name="ln6969">  redraw_cmdline = false;</a>
<a name="ln6970">  clear_cmdline = false;</a>
<a name="ln6971"> </a>
<a name="ln6972">  return length;</a>
<a name="ln6973">}</a>
<a name="ln6974"> </a>
<a name="ln6975">/*</a>
<a name="ln6976"> * Position for a mode message.</a>
<a name="ln6977"> */</a>
<a name="ln6978">static void msg_pos_mode(void)</a>
<a name="ln6979">{</a>
<a name="ln6980">  msg_col = 0;</a>
<a name="ln6981">  msg_row = Rows - 1;</a>
<a name="ln6982">}</a>
<a name="ln6983"> </a>
<a name="ln6984">/// Delete mode message.  Used when ESC is typed which is expected to end</a>
<a name="ln6985">/// Insert mode (but Insert mode didn't end yet!).</a>
<a name="ln6986">/// Caller should check &quot;mode_displayed&quot;.</a>
<a name="ln6987">void unshowmode(bool force)</a>
<a name="ln6988">{</a>
<a name="ln6989">  // Don't delete it right now, when not redrawing or inside a mapping.</a>
<a name="ln6990">  if (!redrawing() || (!force &amp;&amp; char_avail() &amp;&amp; !KeyTyped)) {</a>
<a name="ln6991">    redraw_cmdline = true;  // delete mode later</a>
<a name="ln6992">  } else {</a>
<a name="ln6993">    clearmode();</a>
<a name="ln6994">  }</a>
<a name="ln6995">}</a>
<a name="ln6996"> </a>
<a name="ln6997">// Clear the mode message.</a>
<a name="ln6998">void clearmode(void)</a>
<a name="ln6999">{</a>
<a name="ln7000">  const int save_msg_row = msg_row;</a>
<a name="ln7001">  const int save_msg_col = msg_col;</a>
<a name="ln7002"> </a>
<a name="ln7003">  msg_ext_ui_flush();</a>
<a name="ln7004">  msg_pos_mode();</a>
<a name="ln7005">  if (reg_recording != 0) {</a>
<a name="ln7006">    recording_mode(HL_ATTR(HLF_CM));</a>
<a name="ln7007">  }</a>
<a name="ln7008">  msg_clr_eos();</a>
<a name="ln7009">  msg_ext_flush_showmode();</a>
<a name="ln7010"> </a>
<a name="ln7011">  msg_col = save_msg_col;</a>
<a name="ln7012">  msg_row = save_msg_row;</a>
<a name="ln7013">}</a>
<a name="ln7014"> </a>
<a name="ln7015">static void recording_mode(int attr)</a>
<a name="ln7016">{</a>
<a name="ln7017">  MSG_PUTS_ATTR(_(&quot;recording&quot;), attr);</a>
<a name="ln7018">  if (!shortmess(SHM_RECORDING)) {</a>
<a name="ln7019">    char_u s[4];</a>
<a name="ln7020">    snprintf((char *)s, ARRAY_SIZE(s), &quot; @%c&quot;, reg_recording);</a>
<a name="ln7021">    MSG_PUTS_ATTR(s, attr);</a>
<a name="ln7022">  }</a>
<a name="ln7023">}</a>
<a name="ln7024"> </a>
<a name="ln7025">/*</a>
<a name="ln7026"> * Draw the tab pages line at the top of the Vim window.</a>
<a name="ln7027"> */</a>
<a name="ln7028">void draw_tabline(void)</a>
<a name="ln7029">{</a>
<a name="ln7030">  int tabcount = 0;</a>
<a name="ln7031">  int tabwidth = 0;</a>
<a name="ln7032">  int col = 0;</a>
<a name="ln7033">  int scol = 0;</a>
<a name="ln7034">  int attr;</a>
<a name="ln7035">  win_T       *wp;</a>
<a name="ln7036">  win_T       *cwp;</a>
<a name="ln7037">  int wincount;</a>
<a name="ln7038">  int modified;</a>
<a name="ln7039">  int c;</a>
<a name="ln7040">  int len;</a>
<a name="ln7041">  int attr_nosel = HL_ATTR(HLF_TP);</a>
<a name="ln7042">  int attr_fill = HL_ATTR(HLF_TPF);</a>
<a name="ln7043">  char_u      *p;</a>
<a name="ln7044">  int room;</a>
<a name="ln7045">  int use_sep_chars = (t_colors &lt; 8</a>
<a name="ln7046">                       );</a>
<a name="ln7047"> </a>
<a name="ln7048">  if (default_grid.chars == NULL) {</a>
<a name="ln7049">    return;</a>
<a name="ln7050">  }</a>
<a name="ln7051">  redraw_tabline = false;</a>
<a name="ln7052"> </a>
<a name="ln7053">  if (ui_has(kUITabline)) {</a>
<a name="ln7054">    ui_ext_tabline_update();</a>
<a name="ln7055">    return;</a>
<a name="ln7056">  }</a>
<a name="ln7057"> </a>
<a name="ln7058">  if (tabline_height() &lt; 1)</a>
<a name="ln7059">    return;</a>
<a name="ln7060"> </a>
<a name="ln7061"> </a>
<a name="ln7062">  // Init TabPageIdxs[] to zero: Clicking outside of tabs has no effect.</a>
<a name="ln7063">  assert(Columns == tab_page_click_defs_size);</a>
<a name="ln7064">  clear_tab_page_click_defs(tab_page_click_defs, tab_page_click_defs_size);</a>
<a name="ln7065"> </a>
<a name="ln7066">  /* Use the 'tabline' option if it's set. */</a>
<a name="ln7067">  if (*p_tal != NUL) {</a>
<a name="ln7068">    int saved_did_emsg = did_emsg;</a>
<a name="ln7069"> </a>
<a name="ln7070">    // Check for an error.  If there is one we would loop in redrawing the</a>
<a name="ln7071">    // screen.  Avoid that by making 'tabline' empty.</a>
<a name="ln7072">    did_emsg = false;</a>
<a name="ln7073">    win_redr_custom(NULL, false);</a>
<a name="ln7074">    if (did_emsg) {</a>
<a name="ln7075">      set_string_option_direct(&quot;tabline&quot;, -1,</a>
<a name="ln7076">                               (char_u *)&quot;&quot;, OPT_FREE, SID_ERROR);</a>
<a name="ln7077">    }</a>
<a name="ln7078">    did_emsg |= saved_did_emsg;</a>
<a name="ln7079">  } else {</a>
<a name="ln7080">    FOR_ALL_TABS(tp) {</a>
<a name="ln7081">      ++tabcount;</a>
<a name="ln7082">    }</a>
<a name="ln7083"> </a>
<a name="ln7084">    if (tabcount &gt; 0) {</a>
<a name="ln7085">      tabwidth = (Columns - 1 + tabcount / 2) / tabcount;</a>
<a name="ln7086">    }</a>
<a name="ln7087"> </a>
<a name="ln7088">    if (tabwidth &lt; 6) {</a>
<a name="ln7089">      tabwidth = 6;</a>
<a name="ln7090">    }</a>
<a name="ln7091"> </a>
<a name="ln7092">    attr = attr_nosel;</a>
<a name="ln7093">    tabcount = 0;</a>
<a name="ln7094"> </a>
<a name="ln7095">    FOR_ALL_TABS(tp) {</a>
<a name="ln7096">      if (col &gt;= Columns - 4) {</a>
<a name="ln7097">        break;</a>
<a name="ln7098">      }</a>
<a name="ln7099"> </a>
<a name="ln7100">      scol = col;</a>
<a name="ln7101"> </a>
<a name="ln7102">      if (tp == curtab) {</a>
<a name="ln7103">        cwp = curwin;</a>
<a name="ln7104">        wp = firstwin;</a>
<a name="ln7105">      } else {</a>
<a name="ln7106">        cwp = tp-&gt;tp_curwin;</a>
<a name="ln7107">        wp = tp-&gt;tp_firstwin;</a>
<a name="ln7108">      }</a>
<a name="ln7109"> </a>
<a name="ln7110"> </a>
<a name="ln7111">      if (tp-&gt;tp_topframe == topframe) {</a>
<a name="ln7112">        attr = win_hl_attr(cwp, HLF_TPS);</a>
<a name="ln7113">      }</a>
<a name="ln7114">      if (use_sep_chars &amp;&amp; col &gt; 0) {</a>
<a name="ln7115">        grid_putchar(&amp;default_grid, '|', 0, col++, attr);</a>
<a name="ln7116">      }</a>
<a name="ln7117"> </a>
<a name="ln7118">      if (tp-&gt;tp_topframe != topframe) {</a>
<a name="ln7119">        attr = win_hl_attr(cwp, HLF_TP);</a>
<a name="ln7120">      }</a>
<a name="ln7121"> </a>
<a name="ln7122">      grid_putchar(&amp;default_grid, ' ', 0, col++, attr);</a>
<a name="ln7123"> </a>
<a name="ln7124">      modified = false;</a>
<a name="ln7125"> </a>
<a name="ln7126">      for (wincount = 0; wp != NULL; wp = wp-&gt;w_next, ++wincount) {</a>
<a name="ln7127">        if (bufIsChanged(wp-&gt;w_buffer)) {</a>
<a name="ln7128">          modified = true;</a>
<a name="ln7129">        }</a>
<a name="ln7130">      }</a>
<a name="ln7131"> </a>
<a name="ln7132"> </a>
<a name="ln7133">      if (modified || wincount &gt; 1) {</a>
<a name="ln7134">        if (wincount &gt; 1) {</a>
<a name="ln7135">          vim_snprintf((char *)NameBuff, MAXPATHL, &quot;%d&quot;, wincount);</a>
<a name="ln7136">          len = (int)STRLEN(NameBuff);</a>
<a name="ln7137">          if (col + len &gt;= Columns - 3) {</a>
<a name="ln7138">            break;</a>
<a name="ln7139">          }</a>
<a name="ln7140">          grid_puts_len(&amp;default_grid, NameBuff, len, 0, col,</a>
<a name="ln7141">                        hl_combine_attr(attr, win_hl_attr(cwp, HLF_T)));</a>
<a name="ln7142">          col += len;</a>
<a name="ln7143">        }</a>
<a name="ln7144">        if (modified) {</a>
<a name="ln7145">          grid_puts_len(&amp;default_grid, (char_u *)&quot;+&quot;, 1, 0, col++, attr);</a>
<a name="ln7146">        }</a>
<a name="ln7147">        grid_putchar(&amp;default_grid, ' ', 0, col++, attr);</a>
<a name="ln7148">      }</a>
<a name="ln7149"> </a>
<a name="ln7150">      room = scol - col + tabwidth - 1;</a>
<a name="ln7151">      if (room &gt; 0) {</a>
<a name="ln7152">        /* Get buffer name in NameBuff[] */</a>
<a name="ln7153">        get_trans_bufname(cwp-&gt;w_buffer);</a>
<a name="ln7154">        (void)shorten_dir(NameBuff);</a>
<a name="ln7155">        len = vim_strsize(NameBuff);</a>
<a name="ln7156">        p = NameBuff;</a>
<a name="ln7157">        while (len &gt; room) {</a>
<a name="ln7158">          len -= ptr2cells(p);</a>
<a name="ln7159">          MB_PTR_ADV(p);</a>
<a name="ln7160">        }</a>
<a name="ln7161">        if (len &gt; Columns - col - 1) {</a>
<a name="ln7162">          len = Columns - col - 1;</a>
<a name="ln7163">        }</a>
<a name="ln7164"> </a>
<a name="ln7165">        grid_puts_len(&amp;default_grid, p, (int)STRLEN(p), 0, col, attr);</a>
<a name="ln7166">        col += len;</a>
<a name="ln7167">      }</a>
<a name="ln7168">      grid_putchar(&amp;default_grid, ' ', 0, col++, attr);</a>
<a name="ln7169"> </a>
<a name="ln7170">      // Store the tab page number in tab_page_click_defs[], so that</a>
<a name="ln7171">      // jump_to_mouse() knows where each one is.</a>
<a name="ln7172">      tabcount++;</a>
<a name="ln7173">      while (scol &lt; col) {</a>
<a name="ln7174">        tab_page_click_defs[scol++] = (StlClickDefinition) {</a>
<a name="ln7175">          .type = kStlClickTabSwitch,</a>
<a name="ln7176">          .tabnr = tabcount,</a>
<a name="ln7177">          .func = NULL,</a>
<a name="ln7178">        };</a>
<a name="ln7179">      }</a>
<a name="ln7180">    }</a>
<a name="ln7181"> </a>
<a name="ln7182">    if (use_sep_chars)</a>
<a name="ln7183">      c = '_';</a>
<a name="ln7184">    else</a>
<a name="ln7185">      c = ' ';</a>
<a name="ln7186">    grid_fill(&amp;default_grid, 0, 1, col, Columns, c, c, attr_fill);</a>
<a name="ln7187"> </a>
<a name="ln7188">    /* Put an &quot;X&quot; for closing the current tab if there are several. */</a>
<a name="ln7189">    if (first_tabpage-&gt;tp_next != NULL) {</a>
<a name="ln7190">      grid_putchar(&amp;default_grid, 'X', 0, Columns - 1, attr_nosel);</a>
<a name="ln7191">      tab_page_click_defs[Columns - 1] = (StlClickDefinition) {</a>
<a name="ln7192">        .type = kStlClickTabClose,</a>
<a name="ln7193">        .tabnr = 999,</a>
<a name="ln7194">        .func = NULL,</a>
<a name="ln7195">      };</a>
<a name="ln7196">    }</a>
<a name="ln7197">  }</a>
<a name="ln7198"> </a>
<a name="ln7199">  /* Reset the flag here again, in case evaluating 'tabline' causes it to be</a>
<a name="ln7200">   * set. */</a>
<a name="ln7201">  redraw_tabline = FALSE;</a>
<a name="ln7202">}</a>
<a name="ln7203"> </a>
<a name="ln7204">void ui_ext_tabline_update(void)</a>
<a name="ln7205">{</a>
<a name="ln7206">  Array tabs = ARRAY_DICT_INIT;</a>
<a name="ln7207">  FOR_ALL_TABS(tp) {</a>
<a name="ln7208">    Dictionary tab_info = ARRAY_DICT_INIT;</a>
<a name="ln7209">    PUT(tab_info, &quot;tab&quot;, TABPAGE_OBJ(tp-&gt;handle));</a>
<a name="ln7210"> </a>
<a name="ln7211">    win_T *cwp = (tp == curtab) ? curwin : tp-&gt;tp_curwin;</a>
<a name="ln7212">    get_trans_bufname(cwp-&gt;w_buffer);</a>
<a name="ln7213">    PUT(tab_info, &quot;name&quot;, STRING_OBJ(cstr_to_string((char *)NameBuff)));</a>
<a name="ln7214"> </a>
<a name="ln7215">    ADD(tabs, DICTIONARY_OBJ(tab_info));</a>
<a name="ln7216">  }</a>
<a name="ln7217"> </a>
<a name="ln7218">  Array buffers = ARRAY_DICT_INIT;</a>
<a name="ln7219">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln7220">    // Do not include unlisted buffers</a>
<a name="ln7221">    if (!buf-&gt;b_p_bl) {</a>
<a name="ln7222">      continue;</a>
<a name="ln7223">    }</a>
<a name="ln7224"> </a>
<a name="ln7225">    Dictionary buffer_info = ARRAY_DICT_INIT;</a>
<a name="ln7226">    PUT(buffer_info, &quot;buffer&quot;, BUFFER_OBJ(buf-&gt;handle));</a>
<a name="ln7227"> </a>
<a name="ln7228">    get_trans_bufname(buf);</a>
<a name="ln7229">    PUT(buffer_info, &quot;name&quot;, STRING_OBJ(cstr_to_string((char *)NameBuff)));</a>
<a name="ln7230"> </a>
<a name="ln7231">    ADD(buffers, DICTIONARY_OBJ(buffer_info));</a>
<a name="ln7232">  }</a>
<a name="ln7233"> </a>
<a name="ln7234">  ui_call_tabline_update(curtab-&gt;handle, tabs, curbuf-&gt;handle, buffers);</a>
<a name="ln7235">}</a>
<a name="ln7236"> </a>
<a name="ln7237">/*</a>
<a name="ln7238"> * Get buffer name for &quot;buf&quot; into NameBuff[].</a>
<a name="ln7239"> * Takes care of special buffer names and translates special characters.</a>
<a name="ln7240"> */</a>
<a name="ln7241">void get_trans_bufname(buf_T *buf)</a>
<a name="ln7242">{</a>
<a name="ln7243">  if (buf_spname(buf) != NULL)</a>
<a name="ln7244">    STRLCPY(NameBuff, buf_spname(buf), MAXPATHL);</a>
<a name="ln7245">  else</a>
<a name="ln7246">    home_replace(buf, buf-&gt;b_fname, NameBuff, MAXPATHL, TRUE);</a>
<a name="ln7247">  trans_characters(NameBuff, MAXPATHL);</a>
<a name="ln7248">}</a>
<a name="ln7249"> </a>
<a name="ln7250">/*</a>
<a name="ln7251"> * Get the character to use in a status line.  Get its attributes in &quot;*attr&quot;.</a>
<a name="ln7252"> */</a>
<a name="ln7253">static int fillchar_status(int *attr, win_T *wp)</a>
<a name="ln7254">{</a>
<a name="ln7255">  int fill;</a>
<a name="ln7256">  bool is_curwin = (wp == curwin);</a>
<a name="ln7257">  if (is_curwin) {</a>
<a name="ln7258">    *attr = win_hl_attr(wp, HLF_S);</a>
<a name="ln7259">    fill = wp-&gt;w_p_fcs_chars.stl;</a>
<a name="ln7260">  } else {</a>
<a name="ln7261">    *attr = win_hl_attr(wp, HLF_SNC);</a>
<a name="ln7262">    fill = wp-&gt;w_p_fcs_chars.stlnc;</a>
<a name="ln7263">  }</a>
<a name="ln7264">  /* Use fill when there is highlighting, and highlighting of current</a>
<a name="ln7265">   * window differs, or the fillchars differ, or this is not the</a>
<a name="ln7266">   * current window */</a>
<a name="ln7267">  if (*attr != 0 &amp;&amp; ((win_hl_attr(wp, HLF_S) != win_hl_attr(wp, HLF_SNC)</a>
<a name="ln7268">                      || !is_curwin || ONE_WINDOW)</a>
<a name="ln7269">                     || (wp-&gt;w_p_fcs_chars.stl != wp-&gt;w_p_fcs_chars.stlnc))) {</a>
<a name="ln7270">    return fill;</a>
<a name="ln7271">  }</a>
<a name="ln7272">  if (is_curwin) {</a>
<a name="ln7273">    return '^';</a>
<a name="ln7274">  }</a>
<a name="ln7275">  return '=';</a>
<a name="ln7276">}</a>
<a name="ln7277"> </a>
<a name="ln7278">/*</a>
<a name="ln7279"> * Get the character to use in a separator between vertically split windows.</a>
<a name="ln7280"> * Get its attributes in &quot;*attr&quot;.</a>
<a name="ln7281"> */</a>
<a name="ln7282">static int fillchar_vsep(win_T *wp, int *attr)</a>
<a name="ln7283">{</a>
<a name="ln7284">  *attr = win_hl_attr(wp, HLF_C);</a>
<a name="ln7285">  return wp-&gt;w_p_fcs_chars.vert;</a>
<a name="ln7286">}</a>
<a name="ln7287"> </a>
<a name="ln7288">/*</a>
<a name="ln7289"> * Return TRUE if redrawing should currently be done.</a>
<a name="ln7290"> */</a>
<a name="ln7291">int redrawing(void)</a>
<a name="ln7292">{</a>
<a name="ln7293">  return !RedrawingDisabled</a>
<a name="ln7294">         &amp;&amp; !(p_lz &amp;&amp; char_avail() &amp;&amp; !KeyTyped &amp;&amp; !do_redraw);</a>
<a name="ln7295">}</a>
<a name="ln7296"> </a>
<a name="ln7297">/*</a>
<a name="ln7298"> * Return TRUE if printing messages should currently be done.</a>
<a name="ln7299"> */</a>
<a name="ln7300">int messaging(void)</a>
<a name="ln7301">{</a>
<a name="ln7302">  return !(p_lz &amp;&amp; char_avail() &amp;&amp; !KeyTyped);</a>
<a name="ln7303">}</a>
<a name="ln7304"> </a>
<a name="ln7305">/*</a>
<a name="ln7306"> * Show current status info in ruler and various other places</a>
<a name="ln7307"> * If always is FALSE, only show ruler if position has changed.</a>
<a name="ln7308"> */</a>
<a name="ln7309">void showruler(int always)</a>
<a name="ln7310">{</a>
<a name="ln7311">  if (!always &amp;&amp; !redrawing())</a>
<a name="ln7312">    return;</a>
<a name="ln7313">  if ((*p_stl != NUL || *curwin-&gt;w_p_stl != NUL) &amp;&amp; curwin-&gt;w_status_height) {</a>
<a name="ln7314">    redraw_custom_statusline(curwin);</a>
<a name="ln7315">  } else {</a>
<a name="ln7316">    win_redr_ruler(curwin, always);</a>
<a name="ln7317">  }</a>
<a name="ln7318"> </a>
<a name="ln7319">  if (need_maketitle</a>
<a name="ln7320">      || (p_icon &amp;&amp; (stl_syntax &amp; STL_IN_ICON))</a>
<a name="ln7321">      || (p_title &amp;&amp; (stl_syntax &amp; STL_IN_TITLE))</a>
<a name="ln7322">      )</a>
<a name="ln7323">    maketitle();</a>
<a name="ln7324">  /* Redraw the tab pages line if needed. */</a>
<a name="ln7325">  if (redraw_tabline)</a>
<a name="ln7326">    draw_tabline();</a>
<a name="ln7327">}</a>
<a name="ln7328"> </a>
<a name="ln7329">static void win_redr_ruler(win_T *wp, int always)</a>
<a name="ln7330">{</a>
<a name="ln7331">  static bool did_show_ext_ruler = false;</a>
<a name="ln7332"> </a>
<a name="ln7333">  // If 'ruler' off or redrawing disabled, don't do anything</a>
<a name="ln7334">  if (!p_ru) {</a>
<a name="ln7335">    return;</a>
<a name="ln7336">  }</a>
<a name="ln7337"> </a>
<a name="ln7338">  /*</a>
<a name="ln7339">   * Check if cursor.lnum is valid, since win_redr_ruler() may be called</a>
<a name="ln7340">   * after deleting lines, before cursor.lnum is corrected.</a>
<a name="ln7341">   */</a>
<a name="ln7342">  if (wp-&gt;w_cursor.lnum &gt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count)</a>
<a name="ln7343">    return;</a>
<a name="ln7344"> </a>
<a name="ln7345">  // Don't draw the ruler while doing insert-completion, it might overwrite</a>
<a name="ln7346">  // the (long) mode message.</a>
<a name="ln7347">  if (wp == lastwin &amp;&amp; lastwin-&gt;w_status_height == 0) {</a>
<a name="ln7348">    if (edit_submode != NULL) {</a>
<a name="ln7349">      return;</a>
<a name="ln7350">    }</a>
<a name="ln7351">  }</a>
<a name="ln7352"> </a>
<a name="ln7353">  if (*p_ruf) {</a>
<a name="ln7354">    int save_called_emsg = called_emsg;</a>
<a name="ln7355"> </a>
<a name="ln7356">    called_emsg = false;</a>
<a name="ln7357">    win_redr_custom(wp, true);</a>
<a name="ln7358">    if (called_emsg) {</a>
<a name="ln7359">      set_string_option_direct(&quot;rulerformat&quot;, -1, (char_u *)&quot;&quot;,</a>
<a name="ln7360">                               OPT_FREE, SID_ERROR);</a>
<a name="ln7361">    }</a>
<a name="ln7362">    called_emsg |= save_called_emsg;</a>
<a name="ln7363">    return;</a>
<a name="ln7364">  }</a>
<a name="ln7365"> </a>
<a name="ln7366">  /*</a>
<a name="ln7367">   * Check if not in Insert mode and the line is empty (will show &quot;0-1&quot;).</a>
<a name="ln7368">   */</a>
<a name="ln7369">  int empty_line = FALSE;</a>
<a name="ln7370">  if (!(State &amp; INSERT)</a>
<a name="ln7371">      &amp;&amp; *ml_get_buf(wp-&gt;w_buffer, wp-&gt;w_cursor.lnum, FALSE) == NUL)</a>
<a name="ln7372">    empty_line = TRUE;</a>
<a name="ln7373"> </a>
<a name="ln7374">  /*</a>
<a name="ln7375">   * Only draw the ruler when something changed.</a>
<a name="ln7376">   */</a>
<a name="ln7377">  validate_virtcol_win(wp);</a>
<a name="ln7378">  if (       redraw_cmdline</a>
<a name="ln7379">             || always</a>
<a name="ln7380">             || wp-&gt;w_cursor.lnum != wp-&gt;w_ru_cursor.lnum</a>
<a name="ln7381">             || wp-&gt;w_cursor.col != wp-&gt;w_ru_cursor.col</a>
<a name="ln7382">             || wp-&gt;w_virtcol != wp-&gt;w_ru_virtcol</a>
<a name="ln7383">             || wp-&gt;w_cursor.coladd != wp-&gt;w_ru_cursor.coladd</a>
<a name="ln7384">             || wp-&gt;w_topline != wp-&gt;w_ru_topline</a>
<a name="ln7385">             || wp-&gt;w_buffer-&gt;b_ml.ml_line_count != wp-&gt;w_ru_line_count</a>
<a name="ln7386">             || wp-&gt;w_topfill != wp-&gt;w_ru_topfill</a>
<a name="ln7387">             || empty_line != wp-&gt;w_ru_empty) {</a>
<a name="ln7388"> </a>
<a name="ln7389">    int width;</a>
<a name="ln7390">    int row;</a>
<a name="ln7391">    int fillchar;</a>
<a name="ln7392">    int attr;</a>
<a name="ln7393">    int off;</a>
<a name="ln7394">    bool part_of_status = false;</a>
<a name="ln7395"> </a>
<a name="ln7396">    if (wp-&gt;w_status_height) {</a>
<a name="ln7397">      row = W_ENDROW(wp);</a>
<a name="ln7398">      fillchar = fillchar_status(&amp;attr, wp);</a>
<a name="ln7399">      off = wp-&gt;w_wincol;</a>
<a name="ln7400">      width = wp-&gt;w_width;</a>
<a name="ln7401">      part_of_status = true;</a>
<a name="ln7402">    } else {</a>
<a name="ln7403">      row = Rows - 1;</a>
<a name="ln7404">      fillchar = ' ';</a>
<a name="ln7405">      attr = HL_ATTR(HLF_MSG);</a>
<a name="ln7406">      width = Columns;</a>
<a name="ln7407">      off = 0;</a>
<a name="ln7408">    }</a>
<a name="ln7409"> </a>
<a name="ln7410">    // In list mode virtcol needs to be recomputed</a>
<a name="ln7411">    colnr_T virtcol = wp-&gt;w_virtcol;</a>
<a name="ln7412">    if (wp-&gt;w_p_list &amp;&amp; wp-&gt;w_p_lcs_chars.tab1 == NUL) {</a>
<a name="ln7413">      wp-&gt;w_p_list = false;</a>
<a name="ln7414">      getvvcol(wp, &amp;wp-&gt;w_cursor, NULL, &amp;virtcol, NULL);</a>
<a name="ln7415">      wp-&gt;w_p_list = true;</a>
<a name="ln7416">    }</a>
<a name="ln7417"> </a>
<a name="ln7418">#define RULER_BUF_LEN 70</a>
<a name="ln7419">    char_u buffer[RULER_BUF_LEN];</a>
<a name="ln7420"> </a>
<a name="ln7421">    /*</a>
<a name="ln7422">     * Some sprintfs return the length, some return a pointer.</a>
<a name="ln7423">     * To avoid portability problems we use strlen() here.</a>
<a name="ln7424">     */</a>
<a name="ln7425">    vim_snprintf((char *)buffer, RULER_BUF_LEN, &quot;%&quot; PRId64 &quot;,&quot;,</a>
<a name="ln7426">        (wp-&gt;w_buffer-&gt;b_ml.ml_flags &amp; ML_EMPTY) ? (int64_t)0L</a>
<a name="ln7427">                                                 : (int64_t)wp-&gt;w_cursor.lnum);</a>
<a name="ln7428">    size_t len = STRLEN(buffer);</a>
<a name="ln7429">    col_print(buffer + len, RULER_BUF_LEN - len,</a>
<a name="ln7430">        empty_line ? 0 : (int)wp-&gt;w_cursor.col + 1,</a>
<a name="ln7431">        (int)virtcol + 1);</a>
<a name="ln7432"> </a>
<a name="ln7433">    /*</a>
<a name="ln7434">     * Add a &quot;50%&quot; if there is room for it.</a>
<a name="ln7435">     * On the last line, don't print in the last column (scrolls the</a>
<a name="ln7436">     * screen up on some terminals).</a>
<a name="ln7437">     */</a>
<a name="ln7438">    int i = (int)STRLEN(buffer);</a>
<a name="ln7439">    get_rel_pos(wp, buffer + i + 1, RULER_BUF_LEN - i - 1);</a>
<a name="ln7440">    int o = i + vim_strsize(buffer + i + 1);</a>
<a name="ln7441">    if (wp-&gt;w_status_height == 0) {  // can't use last char of screen</a>
<a name="ln7442">      o++;</a>
<a name="ln7443">    }</a>
<a name="ln7444">    int this_ru_col = ru_col - (Columns - width);</a>
<a name="ln7445">    if (this_ru_col &lt; 0) {</a>
<a name="ln7446">      this_ru_col = 0;</a>
<a name="ln7447">    }</a>
<a name="ln7448">    // Never use more than half the window/screen width, leave the other half</a>
<a name="ln7449">    // for the filename.</a>
<a name="ln7450">    if (this_ru_col &lt; (width + 1) / 2) {</a>
<a name="ln7451">      this_ru_col = (width + 1) / 2;</a>
<a name="ln7452">    }</a>
<a name="ln7453">    if (this_ru_col + o &lt; width) {</a>
<a name="ln7454">      // Need at least 3 chars left for get_rel_pos() + NUL.</a>
<a name="ln7455">      while (this_ru_col + o &lt; width &amp;&amp; RULER_BUF_LEN &gt; i + 4) {</a>
<a name="ln7456">        i += utf_char2bytes(fillchar, buffer + i);</a>
<a name="ln7457">        o++;</a>
<a name="ln7458">      }</a>
<a name="ln7459">      get_rel_pos(wp, buffer + i, RULER_BUF_LEN - i);</a>
<a name="ln7460">    }</a>
<a name="ln7461"> </a>
<a name="ln7462">    if (ui_has(kUIMessages) &amp;&amp; !part_of_status) {</a>
<a name="ln7463">      Array content = ARRAY_DICT_INIT;</a>
<a name="ln7464">      Array chunk = ARRAY_DICT_INIT;</a>
<a name="ln7465">      ADD(chunk, INTEGER_OBJ(attr));</a>
<a name="ln7466">      ADD(chunk, STRING_OBJ(cstr_to_string((char *)buffer)));</a>
<a name="ln7467">      ADD(content, ARRAY_OBJ(chunk));</a>
<a name="ln7468">      ui_call_msg_ruler(content);</a>
<a name="ln7469">      did_show_ext_ruler = true;</a>
<a name="ln7470">    } else {</a>
<a name="ln7471">      if (did_show_ext_ruler) {</a>
<a name="ln7472">        ui_call_msg_ruler((Array)ARRAY_DICT_INIT);</a>
<a name="ln7473">        did_show_ext_ruler = false;</a>
<a name="ln7474">      }</a>
<a name="ln7475">      // Truncate at window boundary.</a>
<a name="ln7476">      o = 0;</a>
<a name="ln7477">      for (i = 0; buffer[i] != NUL; i += utfc_ptr2len(buffer + i)) {</a>
<a name="ln7478">        o += utf_ptr2cells(buffer + i);</a>
<a name="ln7479">        if (this_ru_col + o &gt; width) {</a>
<a name="ln7480">          buffer[i] = NUL;</a>
<a name="ln7481">          break;</a>
<a name="ln7482">        }</a>
<a name="ln7483">      }</a>
<a name="ln7484"> </a>
<a name="ln7485">      ScreenGrid *grid = part_of_status ? &amp;default_grid : &amp;msg_grid_adj;</a>
<a name="ln7486">      grid_puts(grid, buffer, row, this_ru_col + off, attr);</a>
<a name="ln7487">      grid_fill(grid, row, row + 1,</a>
<a name="ln7488">                this_ru_col + off + (int)STRLEN(buffer), off + width, fillchar,</a>
<a name="ln7489">                fillchar, attr);</a>
<a name="ln7490">    }</a>
<a name="ln7491"> </a>
<a name="ln7492">    wp-&gt;w_ru_cursor = wp-&gt;w_cursor;</a>
<a name="ln7493">    wp-&gt;w_ru_virtcol = wp-&gt;w_virtcol;</a>
<a name="ln7494">    wp-&gt;w_ru_empty = empty_line;</a>
<a name="ln7495">    wp-&gt;w_ru_topline = wp-&gt;w_topline;</a>
<a name="ln7496">    wp-&gt;w_ru_line_count = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln7497">    wp-&gt;w_ru_topfill = wp-&gt;w_topfill;</a>
<a name="ln7498">  }</a>
<a name="ln7499">}</a>
<a name="ln7500"> </a>
<a name="ln7501">/*</a>
<a name="ln7502"> * Return the width of the 'number' and 'relativenumber' column.</a>
<a name="ln7503"> * Caller may need to check if 'number' or 'relativenumber' is set.</a>
<a name="ln7504"> * Otherwise it depends on 'numberwidth' and the line count.</a>
<a name="ln7505"> */</a>
<a name="ln7506">int number_width(win_T *wp)</a>
<a name="ln7507">{</a>
<a name="ln7508">  int n;</a>
<a name="ln7509">  linenr_T lnum;</a>
<a name="ln7510"> </a>
<a name="ln7511">  if (wp-&gt;w_p_rnu &amp;&amp; !wp-&gt;w_p_nu) {</a>
<a name="ln7512">    // cursor line shows &quot;0&quot;</a>
<a name="ln7513">    lnum = wp-&gt;w_height_inner;</a>
<a name="ln7514">  } else {</a>
<a name="ln7515">    // cursor line shows absolute line number</a>
<a name="ln7516">    lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln7517">  }</a>
<a name="ln7518"> </a>
<a name="ln7519">  if (lnum == wp-&gt;w_nrwidth_line_count)</a>
<a name="ln7520">    return wp-&gt;w_nrwidth_width;</a>
<a name="ln7521">  wp-&gt;w_nrwidth_line_count = lnum;</a>
<a name="ln7522"> </a>
<a name="ln7523">  n = 0;</a>
<a name="ln7524">  do {</a>
<a name="ln7525">    lnum /= 10;</a>
<a name="ln7526">    ++n;</a>
<a name="ln7527">  } while (lnum &gt; 0);</a>
<a name="ln7528"> </a>
<a name="ln7529">  // 'numberwidth' gives the minimal width plus one</a>
<a name="ln7530">  if (n &lt; wp-&gt;w_p_nuw - 1) {</a>
<a name="ln7531">    n = wp-&gt;w_p_nuw - 1;</a>
<a name="ln7532">  }</a>
<a name="ln7533"> </a>
<a name="ln7534">  // If 'signcolumn' is set to 'number' and there is a sign to display, then</a>
<a name="ln7535">  // the minimal width for the number column is 2.</a>
<a name="ln7536">  if (n &lt; 2 &amp;&amp; (wp-&gt;w_buffer-&gt;b_signlist != NULL)</a>
<a name="ln7537">      &amp;&amp; (*wp-&gt;w_p_scl == 'n' &amp;&amp; *(wp-&gt;w_p_scl + 1) == 'u')) {</a>
<a name="ln7538">    n = 2;</a>
<a name="ln7539">  }</a>
<a name="ln7540"> </a>
<a name="ln7541">  wp-&gt;w_nrwidth_width = n;</a>
<a name="ln7542">  return n;</a>
<a name="ln7543">}</a>
<a name="ln7544"> </a>
<a name="ln7545">/// Set dimensions of the Nvim application &quot;shell&quot;.</a>
<a name="ln7546">void screen_resize(int width, int height)</a>
<a name="ln7547">{</a>
<a name="ln7548">  static int busy = FALSE;</a>
<a name="ln7549"> </a>
<a name="ln7550">  // Avoid recursiveness, can happen when setting the window size causes</a>
<a name="ln7551">  // another window-changed signal.</a>
<a name="ln7552">  if (updating_screen || busy) {</a>
<a name="ln7553">    return;</a>
<a name="ln7554">  }</a>
<a name="ln7555"> </a>
<a name="ln7556">  if (width &lt; 0 || height &lt; 0)      /* just checking... */</a>
<a name="ln7557">    return;</a>
<a name="ln7558"> </a>
<a name="ln7559">  if (State == HITRETURN || State == SETWSIZE) {</a>
<a name="ln7560">    /* postpone the resizing */</a>
<a name="ln7561">    State = SETWSIZE;</a>
<a name="ln7562">    return;</a>
<a name="ln7563">  }</a>
<a name="ln7564"> </a>
<a name="ln7565">  /* curwin-&gt;w_buffer can be NULL when we are closing a window and the</a>
<a name="ln7566">   * buffer has already been closed and removing a scrollbar causes a resize</a>
<a name="ln7567">   * event. Don't resize then, it will happen after entering another buffer.</a>
<a name="ln7568">   */</a>
<a name="ln7569">  if (curwin-&gt;w_buffer == NULL)</a>
<a name="ln7570">    return;</a>
<a name="ln7571"> </a>
<a name="ln7572">  ++busy;</a>
<a name="ln7573"> </a>
<a name="ln7574">  Rows = height;</a>
<a name="ln7575">  Columns = width;</a>
<a name="ln7576">  check_shellsize();</a>
<a name="ln7577">  int max_p_ch = Rows - min_rows() + 1;</a>
<a name="ln7578">  if (!ui_has(kUIMessages) &amp;&amp; p_ch &gt; max_p_ch) {</a>
<a name="ln7579">    p_ch = max_p_ch ? max_p_ch : 1;</a>
<a name="ln7580">  }</a>
<a name="ln7581">  height = Rows;</a>
<a name="ln7582">  width = Columns;</a>
<a name="ln7583">  p_lines = Rows;</a>
<a name="ln7584">  p_columns = Columns;</a>
<a name="ln7585">  ui_call_grid_resize(1, width, height);</a>
<a name="ln7586"> </a>
<a name="ln7587">  send_grid_resize = true;</a>
<a name="ln7588"> </a>
<a name="ln7589">  /* The window layout used to be adjusted here, but it now happens in</a>
<a name="ln7590">   * screenalloc() (also invoked from screenclear()).  That is because the</a>
<a name="ln7591">   * &quot;busy&quot; check above may skip this, but not screenalloc(). */</a>
<a name="ln7592"> </a>
<a name="ln7593">  if (State != ASKMORE &amp;&amp; State != EXTERNCMD &amp;&amp; State != CONFIRM) {</a>
<a name="ln7594">    screenclear();</a>
<a name="ln7595">  }</a>
<a name="ln7596"> </a>
<a name="ln7597">  if (starting != NO_SCREEN) {</a>
<a name="ln7598">    maketitle();</a>
<a name="ln7599">    changed_line_abv_curs();</a>
<a name="ln7600">    invalidate_botline();</a>
<a name="ln7601"> </a>
<a name="ln7602">    /*</a>
<a name="ln7603">     * We only redraw when it's needed:</a>
<a name="ln7604">     * - While at the more prompt or executing an external command, don't</a>
<a name="ln7605">     *   redraw, but position the cursor.</a>
<a name="ln7606">     * - While editing the command line, only redraw that.</a>
<a name="ln7607">     * - in Ex mode, don't redraw anything.</a>
<a name="ln7608">     * - Otherwise, redraw right now, and position the cursor.</a>
<a name="ln7609">     * Always need to call update_screen() or screenalloc(), to make</a>
<a name="ln7610">     * sure Rows/Columns and the size of the screen is correct!</a>
<a name="ln7611">     */</a>
<a name="ln7612">    if (State == ASKMORE || State == EXTERNCMD || State == CONFIRM</a>
<a name="ln7613">        || exmode_active) {</a>
<a name="ln7614">      screenalloc();</a>
<a name="ln7615">      if (msg_grid.chars) {</a>
<a name="ln7616">        msg_grid_validate();</a>
<a name="ln7617">      }</a>
<a name="ln7618">      // TODO(bfredl): sometimes messes up the output. Implement clear+redraw</a>
<a name="ln7619">      // also for the pager? (or: what if the pager was just a modal window?)</a>
<a name="ln7620">      ui_comp_set_screen_valid(true);</a>
<a name="ln7621">      repeat_message();</a>
<a name="ln7622">    } else {</a>
<a name="ln7623">      if (curwin-&gt;w_p_scb)</a>
<a name="ln7624">        do_check_scrollbind(TRUE);</a>
<a name="ln7625">      if (State &amp; CMDLINE) {</a>
<a name="ln7626">        redraw_popupmenu = false;</a>
<a name="ln7627">        update_screen(NOT_VALID);</a>
<a name="ln7628">        redrawcmdline();</a>
<a name="ln7629">        if (pum_drawn()) {</a>
<a name="ln7630">          cmdline_pum_display(false);</a>
<a name="ln7631">        }</a>
<a name="ln7632">      } else {</a>
<a name="ln7633">        update_topline(curwin);</a>
<a name="ln7634">        if (pum_drawn()) {</a>
<a name="ln7635">          // TODO(bfredl): ins_compl_show_pum wants to redraw the screen first.</a>
<a name="ln7636">          // For now make sure the nested update_screen(0) won't redraw the</a>
<a name="ln7637">          // pum at the old position. Try to untangle this later.</a>
<a name="ln7638">          redraw_popupmenu = false;</a>
<a name="ln7639">          ins_compl_show_pum();</a>
<a name="ln7640">        }</a>
<a name="ln7641">        update_screen(NOT_VALID);</a>
<a name="ln7642">        if (redrawing()) {</a>
<a name="ln7643">          setcursor();</a>
<a name="ln7644">        }</a>
<a name="ln7645">      }</a>
<a name="ln7646">    }</a>
<a name="ln7647">    ui_flush();</a>
<a name="ln7648">  }</a>
<a name="ln7649">  busy--;</a>
<a name="ln7650">}</a>
<a name="ln7651"> </a>
<a name="ln7652">/// Check if the new Nvim application &quot;shell&quot; dimensions are valid.</a>
<a name="ln7653">/// Correct it if it's too small or way too big.</a>
<a name="ln7654">void check_shellsize(void)</a>
<a name="ln7655">{</a>
<a name="ln7656">  if (Rows &lt; min_rows()) {</a>
<a name="ln7657">    // need room for one window and command line</a>
<a name="ln7658">    Rows = min_rows();</a>
<a name="ln7659">  }</a>
<a name="ln7660">  limit_screen_size();</a>
<a name="ln7661">}</a>
<a name="ln7662"> </a>
<a name="ln7663">// Limit Rows and Columns to avoid an overflow in Rows * Columns.</a>
<a name="ln7664">void limit_screen_size(void)</a>
<a name="ln7665">{</a>
<a name="ln7666">  if (Columns &lt; MIN_COLUMNS) {</a>
<a name="ln7667">    Columns = MIN_COLUMNS;</a>
<a name="ln7668">  } else if (Columns &gt; 10000) {</a>
<a name="ln7669">    Columns = 10000;</a>
<a name="ln7670">  }</a>
<a name="ln7671"> </a>
<a name="ln7672">  if (Rows &gt; 1000) {</a>
<a name="ln7673">    Rows = 1000;</a>
<a name="ln7674">  }</a>
<a name="ln7675">}</a>
<a name="ln7676"> </a>
<a name="ln7677">void win_new_shellsize(void)</a>
<a name="ln7678">{</a>
<a name="ln7679">  static long old_Rows = 0;</a>
<a name="ln7680">  static long old_Columns = 0;</a>
<a name="ln7681"> </a>
<a name="ln7682">  if (old_Rows != Rows) {</a>
<a name="ln7683">    // If 'window' uses the whole screen, keep it using that.</a>
<a name="ln7684">    // Don't change it when set with &quot;-w size&quot; on the command line.</a>
<a name="ln7685">    if (p_window == old_Rows - 1 || (old_Rows == 0 &amp;&amp; p_window == 0)) {</a>
<a name="ln7686">      p_window = Rows - 1;</a>
<a name="ln7687">    }</a>
<a name="ln7688">    old_Rows = Rows;</a>
<a name="ln7689">    shell_new_rows();  // update window sizes</a>
<a name="ln7690">  }</a>
<a name="ln7691">  if (old_Columns != Columns) {</a>
<a name="ln7692">    old_Columns = Columns;</a>
<a name="ln7693">    shell_new_columns();  // update window sizes</a>
<a name="ln7694">  }</a>
<a name="ln7695">}</a>
<a name="ln7696"> </a>
<a name="ln7697">win_T *get_win_by_grid_handle(handle_T handle)</a>
<a name="ln7698">{</a>
<a name="ln7699">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln7700">    if (wp-&gt;w_grid_alloc.handle == handle) {</a>
<a name="ln7701">      return wp;</a>
<a name="ln7702">    }</a>
<a name="ln7703">  }</a>
<a name="ln7704">  return NULL;</a>
<a name="ln7705">}</a>
<a name="ln7706"> </a>
<a name="ln7707"> </a>

</code></pre>
<div class="balloon" rel="1723"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always false: wp->w_wcol == old_wcol.</p></div>
<div class="balloon" rel="1725"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: old_topline == wp->w_topline.</p></div>
<div class="balloon" rel="2878"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'vcol_sbr' should be checked here.</p></div>
<div class="balloon" rel="2937"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v512/" target="_blank">V512</a> A call of the 'memset' function will lead to underflow of the buffer 'buf_fold'.</p></div>
<div class="balloon" rel="3848"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: eol_hl_off == 0.</p></div>
<div class="balloon" rel="4672"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'redraw_next' should be checked here.</p></div>
<div class="balloon" rel="5142"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v512/" target="_blank">V512</a> A call of the 'strcpy' function will lead to overflow of the buffer '(char *)(p + len)'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
