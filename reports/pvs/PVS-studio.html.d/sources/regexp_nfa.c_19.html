
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>regexp_nfa.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * NFA regular expression implementation.</a>
<a name="ln6"> *</a>
<a name="ln7"> * This file is included in &quot;regexp.c&quot;.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;assert.h&gt;</a>
<a name="ln11">#include &lt;inttypes.h&gt;</a>
<a name="ln12">#include &lt;stdbool.h&gt;</a>
<a name="ln13">#include &lt;limits.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/garray.h&quot;</a>
<a name="ln17"> </a>
<a name="ln18">/*</a>
<a name="ln19"> * Logging of NFA engine.</a>
<a name="ln20"> *</a>
<a name="ln21"> * The NFA engine can write four log files:</a>
<a name="ln22"> * - Error log: Contains NFA engine's fatal errors.</a>
<a name="ln23"> * - Dump log: Contains compiled NFA state machine's information.</a>
<a name="ln24"> * - Run log: Contains information of matching procedure.</a>
<a name="ln25"> * - Debug log: Contains detailed information of matching procedure. Can be</a>
<a name="ln26"> *   disabled by undefining NFA_REGEXP_DEBUG_LOG.</a>
<a name="ln27"> * The first one can also be used without debug mode.</a>
<a name="ln28"> * The last three are enabled when compiled as debug mode and individually</a>
<a name="ln29"> * disabled by commenting them out.</a>
<a name="ln30"> * The log files can get quite big!</a>
<a name="ln31"> * Do disable all of this when compiling Vim for debugging, undefine REGEXP_DEBUG in</a>
<a name="ln32"> * regexp.c</a>
<a name="ln33"> */</a>
<a name="ln34">#ifdef REGEXP_DEBUG</a>
<a name="ln35"># define NFA_REGEXP_ERROR_LOG   &quot;nfa_regexp_error.log&quot;</a>
<a name="ln36"># define NFA_REGEXP_DUMP_LOG    &quot;nfa_regexp_dump.log&quot;</a>
<a name="ln37"># define NFA_REGEXP_RUN_LOG     &quot;nfa_regexp_run.log&quot;</a>
<a name="ln38"># define NFA_REGEXP_DEBUG_LOG   &quot;nfa_regexp_debug.log&quot;</a>
<a name="ln39">#endif</a>
<a name="ln40"> </a>
<a name="ln41">/* Added to NFA_ANY - NFA_NUPPER_IC to include a NL. */</a>
<a name="ln42">#define NFA_ADD_NL              31</a>
<a name="ln43"> </a>
<a name="ln44">enum {</a>
<a name="ln45">  NFA_SPLIT = -1024,</a>
<a name="ln46">  NFA_MATCH,</a>
<a name="ln47">  NFA_EMPTY,                        /* matches 0-length */</a>
<a name="ln48"> </a>
<a name="ln49">  NFA_START_COLL,                   /* [abc] start */</a>
<a name="ln50">  NFA_END_COLL,                     /* [abc] end */</a>
<a name="ln51">  NFA_START_NEG_COLL,               /* [^abc] start */</a>
<a name="ln52">  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */</a>
<a name="ln53">  NFA_RANGE,                        /* range of the two previous items</a>
<a name="ln54">                                     * (postfix only) */</a>
<a name="ln55">  NFA_RANGE_MIN,                    /* low end of a range  */</a>
<a name="ln56">  NFA_RANGE_MAX,                    /* high end of a range  */</a>
<a name="ln57"> </a>
<a name="ln58">  NFA_CONCAT,                       // concatenate two previous items (postfix</a>
<a name="ln59">                                    // only)</a>
<a name="ln60">  NFA_OR,                           // \| (postfix only)</a>
<a name="ln61">  NFA_STAR,                         // greedy * (postfix only)</a>
<a name="ln62">  NFA_STAR_NONGREEDY,               // non-greedy * (postfix only)</a>
<a name="ln63">  NFA_QUEST,                        // greedy \? (postfix only)</a>
<a name="ln64">  NFA_QUEST_NONGREEDY,              // non-greedy \? (postfix only)</a>
<a name="ln65"> </a>
<a name="ln66">  NFA_BOL,                          /* ^    Begin line */</a>
<a name="ln67">  NFA_EOL,                          /* $    End line */</a>
<a name="ln68">  NFA_BOW,                          /* \&lt;   Begin word */</a>
<a name="ln69">  NFA_EOW,                          /* \&gt;   End word */</a>
<a name="ln70">  NFA_BOF,                          /* \%^  Begin file */</a>
<a name="ln71">  NFA_EOF,                          /* \%$  End file */</a>
<a name="ln72">  NFA_NEWL,</a>
<a name="ln73">  NFA_ZSTART,                       /* Used for \zs */</a>
<a name="ln74">  NFA_ZEND,                         /* Used for \ze */</a>
<a name="ln75">  NFA_NOPEN,                        /* Start of subexpression marked with \%( */</a>
<a name="ln76">  NFA_NCLOSE,                       /* End of subexpr. marked with \%( ... \) */</a>
<a name="ln77">  NFA_START_INVISIBLE,</a>
<a name="ln78">  NFA_START_INVISIBLE_FIRST,</a>
<a name="ln79">  NFA_START_INVISIBLE_NEG,</a>
<a name="ln80">  NFA_START_INVISIBLE_NEG_FIRST,</a>
<a name="ln81">  NFA_START_INVISIBLE_BEFORE,</a>
<a name="ln82">  NFA_START_INVISIBLE_BEFORE_FIRST,</a>
<a name="ln83">  NFA_START_INVISIBLE_BEFORE_NEG,</a>
<a name="ln84">  NFA_START_INVISIBLE_BEFORE_NEG_FIRST,</a>
<a name="ln85">  NFA_START_PATTERN,</a>
<a name="ln86">  NFA_END_INVISIBLE,</a>
<a name="ln87">  NFA_END_INVISIBLE_NEG,</a>
<a name="ln88">  NFA_END_PATTERN,</a>
<a name="ln89">  NFA_COMPOSING,                    /* Next nodes in NFA are part of the</a>
<a name="ln90">                                       composing multibyte char */</a>
<a name="ln91">  NFA_END_COMPOSING,                /* End of a composing char in the NFA */</a>
<a name="ln92">  NFA_ANY_COMPOSING,                // \%C: Any composing characters.</a>
<a name="ln93">  NFA_OPT_CHARS,                    /* \%[abc] */</a>
<a name="ln94"> </a>
<a name="ln95">  /* The following are used only in the postfix form, not in the NFA */</a>
<a name="ln96">  NFA_PREV_ATOM_NO_WIDTH,           /* Used for \@= */</a>
<a name="ln97">  NFA_PREV_ATOM_NO_WIDTH_NEG,       /* Used for \@! */</a>
<a name="ln98">  NFA_PREV_ATOM_JUST_BEFORE,        /* Used for \@&lt;= */</a>
<a name="ln99">  NFA_PREV_ATOM_JUST_BEFORE_NEG,    /* Used for \@&lt;! */</a>
<a name="ln100">  NFA_PREV_ATOM_LIKE_PATTERN,       /* Used for \@&gt; */</a>
<a name="ln101"> </a>
<a name="ln102">  NFA_BACKREF1,                     /* \1 */</a>
<a name="ln103">  NFA_BACKREF2,                     /* \2 */</a>
<a name="ln104">  NFA_BACKREF3,                     /* \3 */</a>
<a name="ln105">  NFA_BACKREF4,                     /* \4 */</a>
<a name="ln106">  NFA_BACKREF5,                     /* \5 */</a>
<a name="ln107">  NFA_BACKREF6,                     /* \6 */</a>
<a name="ln108">  NFA_BACKREF7,                     /* \7 */</a>
<a name="ln109">  NFA_BACKREF8,                     /* \8 */</a>
<a name="ln110">  NFA_BACKREF9,                     /* \9 */</a>
<a name="ln111">  NFA_ZREF1,                        /* \z1 */</a>
<a name="ln112">  NFA_ZREF2,                        /* \z2 */</a>
<a name="ln113">  NFA_ZREF3,                        /* \z3 */</a>
<a name="ln114">  NFA_ZREF4,                        /* \z4 */</a>
<a name="ln115">  NFA_ZREF5,                        /* \z5 */</a>
<a name="ln116">  NFA_ZREF6,                        /* \z6 */</a>
<a name="ln117">  NFA_ZREF7,                        /* \z7 */</a>
<a name="ln118">  NFA_ZREF8,                        /* \z8 */</a>
<a name="ln119">  NFA_ZREF9,                        /* \z9 */</a>
<a name="ln120">  NFA_SKIP,                         /* Skip characters */</a>
<a name="ln121"> </a>
<a name="ln122">  NFA_MOPEN,</a>
<a name="ln123">  NFA_MOPEN1,</a>
<a name="ln124">  NFA_MOPEN2,</a>
<a name="ln125">  NFA_MOPEN3,</a>
<a name="ln126">  NFA_MOPEN4,</a>
<a name="ln127">  NFA_MOPEN5,</a>
<a name="ln128">  NFA_MOPEN6,</a>
<a name="ln129">  NFA_MOPEN7,</a>
<a name="ln130">  NFA_MOPEN8,</a>
<a name="ln131">  NFA_MOPEN9,</a>
<a name="ln132"> </a>
<a name="ln133">  NFA_MCLOSE,</a>
<a name="ln134">  NFA_MCLOSE1,</a>
<a name="ln135">  NFA_MCLOSE2,</a>
<a name="ln136">  NFA_MCLOSE3,</a>
<a name="ln137">  NFA_MCLOSE4,</a>
<a name="ln138">  NFA_MCLOSE5,</a>
<a name="ln139">  NFA_MCLOSE6,</a>
<a name="ln140">  NFA_MCLOSE7,</a>
<a name="ln141">  NFA_MCLOSE8,</a>
<a name="ln142">  NFA_MCLOSE9,</a>
<a name="ln143"> </a>
<a name="ln144">  NFA_ZOPEN,</a>
<a name="ln145">  NFA_ZOPEN1,</a>
<a name="ln146">  NFA_ZOPEN2,</a>
<a name="ln147">  NFA_ZOPEN3,</a>
<a name="ln148">  NFA_ZOPEN4,</a>
<a name="ln149">  NFA_ZOPEN5,</a>
<a name="ln150">  NFA_ZOPEN6,</a>
<a name="ln151">  NFA_ZOPEN7,</a>
<a name="ln152">  NFA_ZOPEN8,</a>
<a name="ln153">  NFA_ZOPEN9,</a>
<a name="ln154"> </a>
<a name="ln155">  NFA_ZCLOSE,</a>
<a name="ln156">  NFA_ZCLOSE1,</a>
<a name="ln157">  NFA_ZCLOSE2,</a>
<a name="ln158">  NFA_ZCLOSE3,</a>
<a name="ln159">  NFA_ZCLOSE4,</a>
<a name="ln160">  NFA_ZCLOSE5,</a>
<a name="ln161">  NFA_ZCLOSE6,</a>
<a name="ln162">  NFA_ZCLOSE7,</a>
<a name="ln163">  NFA_ZCLOSE8,</a>
<a name="ln164">  NFA_ZCLOSE9,</a>
<a name="ln165"> </a>
<a name="ln166">  /* NFA_FIRST_NL */</a>
<a name="ln167">  NFA_ANY,              /*	Match any one character. */</a>
<a name="ln168">  NFA_IDENT,            /*	Match identifier char */</a>
<a name="ln169">  NFA_SIDENT,           /*	Match identifier char but no digit */</a>
<a name="ln170">  NFA_KWORD,            /*	Match keyword char */</a>
<a name="ln171">  NFA_SKWORD,           /*	Match word char but no digit */</a>
<a name="ln172">  NFA_FNAME,            /*	Match file name char */</a>
<a name="ln173">  NFA_SFNAME,           /*	Match file name char but no digit */</a>
<a name="ln174">  NFA_PRINT,            /*	Match printable char */</a>
<a name="ln175">  NFA_SPRINT,           /*	Match printable char but no digit */</a>
<a name="ln176">  NFA_WHITE,            /*	Match whitespace char */</a>
<a name="ln177">  NFA_NWHITE,           /*	Match non-whitespace char */</a>
<a name="ln178">  NFA_DIGIT,            /*	Match digit char */</a>
<a name="ln179">  NFA_NDIGIT,           /*	Match non-digit char */</a>
<a name="ln180">  NFA_HEX,              /*	Match hex char */</a>
<a name="ln181">  NFA_NHEX,             /*	Match non-hex char */</a>
<a name="ln182">  NFA_OCTAL,            /*	Match octal char */</a>
<a name="ln183">  NFA_NOCTAL,           /*	Match non-octal char */</a>
<a name="ln184">  NFA_WORD,             /*	Match word char */</a>
<a name="ln185">  NFA_NWORD,            /*	Match non-word char */</a>
<a name="ln186">  NFA_HEAD,             /*	Match head char */</a>
<a name="ln187">  NFA_NHEAD,            /*	Match non-head char */</a>
<a name="ln188">  NFA_ALPHA,            /*	Match alpha char */</a>
<a name="ln189">  NFA_NALPHA,           /*	Match non-alpha char */</a>
<a name="ln190">  NFA_LOWER,            /*	Match lowercase char */</a>
<a name="ln191">  NFA_NLOWER,           /*	Match non-lowercase char */</a>
<a name="ln192">  NFA_UPPER,            /*	Match uppercase char */</a>
<a name="ln193">  NFA_NUPPER,           /*	Match non-uppercase char */</a>
<a name="ln194">  NFA_LOWER_IC,         /*	Match [a-z] */</a>
<a name="ln195">  NFA_NLOWER_IC,        /*	Match [^a-z] */</a>
<a name="ln196">  NFA_UPPER_IC,         /*	Match [A-Z] */</a>
<a name="ln197">  NFA_NUPPER_IC,        /*	Match [^A-Z] */</a>
<a name="ln198"> </a>
<a name="ln199">  NFA_FIRST_NL = NFA_ANY + NFA_ADD_NL,</a>
<a name="ln200">  NFA_LAST_NL = NFA_NUPPER_IC + NFA_ADD_NL,</a>
<a name="ln201"> </a>
<a name="ln202">  NFA_CURSOR,           /*	Match cursor pos */</a>
<a name="ln203">  NFA_LNUM,             /*	Match line number */</a>
<a name="ln204">  NFA_LNUM_GT,          /*	Match &gt; line number */</a>
<a name="ln205">  NFA_LNUM_LT,          /*	Match &lt; line number */</a>
<a name="ln206">  NFA_COL,              /*	Match cursor column */</a>
<a name="ln207">  NFA_COL_GT,           /*	Match &gt; cursor column */</a>
<a name="ln208">  NFA_COL_LT,           /*	Match &lt; cursor column */</a>
<a name="ln209">  NFA_VCOL,             /*	Match cursor virtual column */</a>
<a name="ln210">  NFA_VCOL_GT,          /*	Match &gt; cursor virtual column */</a>
<a name="ln211">  NFA_VCOL_LT,          /*	Match &lt; cursor virtual column */</a>
<a name="ln212">  NFA_MARK,             /*	Match mark */</a>
<a name="ln213">  NFA_MARK_GT,          /*	Match &gt; mark */</a>
<a name="ln214">  NFA_MARK_LT,          /*	Match &lt; mark */</a>
<a name="ln215">  NFA_VISUAL,           /*	Match Visual area */</a>
<a name="ln216"> </a>
<a name="ln217">  /* Character classes [:alnum:] etc */</a>
<a name="ln218">  NFA_CLASS_ALNUM,</a>
<a name="ln219">  NFA_CLASS_ALPHA,</a>
<a name="ln220">  NFA_CLASS_BLANK,</a>
<a name="ln221">  NFA_CLASS_CNTRL,</a>
<a name="ln222">  NFA_CLASS_DIGIT,</a>
<a name="ln223">  NFA_CLASS_GRAPH,</a>
<a name="ln224">  NFA_CLASS_LOWER,</a>
<a name="ln225">  NFA_CLASS_PRINT,</a>
<a name="ln226">  NFA_CLASS_PUNCT,</a>
<a name="ln227">  NFA_CLASS_SPACE,</a>
<a name="ln228">  NFA_CLASS_UPPER,</a>
<a name="ln229">  NFA_CLASS_XDIGIT,</a>
<a name="ln230">  NFA_CLASS_TAB,</a>
<a name="ln231">  NFA_CLASS_RETURN,</a>
<a name="ln232">  NFA_CLASS_BACKSPACE,</a>
<a name="ln233">  NFA_CLASS_ESCAPE,</a>
<a name="ln234">  NFA_CLASS_IDENT,</a>
<a name="ln235">  NFA_CLASS_KEYWORD,</a>
<a name="ln236">  NFA_CLASS_FNAME,</a>
<a name="ln237">};</a>
<a name="ln238"> </a>
<a name="ln239">/* Keep in sync with classchars. */</a>
<a name="ln240">static int nfa_classcodes[] = {</a>
<a name="ln241">  NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD,NFA_SKWORD,</a>
<a name="ln242">  NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,</a>
<a name="ln243">  NFA_WHITE, NFA_NWHITE, NFA_DIGIT, NFA_NDIGIT,</a>
<a name="ln244">  NFA_HEX, NFA_NHEX, NFA_OCTAL, NFA_NOCTAL,</a>
<a name="ln245">  NFA_WORD, NFA_NWORD, NFA_HEAD, NFA_NHEAD,</a>
<a name="ln246">  NFA_ALPHA, NFA_NALPHA, NFA_LOWER, NFA_NLOWER,</a>
<a name="ln247">  NFA_UPPER, NFA_NUPPER</a>
<a name="ln248">};</a>
<a name="ln249"> </a>
<a name="ln250">static char_u e_nul_found[] = N_(</a>
<a name="ln251">    &quot;E865: (NFA) Regexp end encountered prematurely&quot;);</a>
<a name="ln252">static char_u e_misplaced[] = N_(&quot;E866: (NFA regexp) Misplaced %c&quot;);</a>
<a name="ln253">static char_u e_ill_char_class[] = N_(</a>
<a name="ln254">    &quot;E877: (NFA regexp) Invalid character class: %&quot; PRId64);</a>
<a name="ln255">static char_u e_value_too_large[] = N_(&quot;E951: \\% value too large&quot;);</a>
<a name="ln256"> </a>
<a name="ln257">/* Since the out pointers in the list are always</a>
<a name="ln258"> * uninitialized, we use the pointers themselves</a>
<a name="ln259"> * as storage for the Ptrlists. */</a>
<a name="ln260">typedef union Ptrlist Ptrlist;</a>
<a name="ln261">union Ptrlist {</a>
<a name="ln262">  Ptrlist     *next;</a>
<a name="ln263">  nfa_state_T *s;</a>
<a name="ln264">};</a>
<a name="ln265"> </a>
<a name="ln266">struct Frag {</a>
<a name="ln267">  nfa_state_T *start;</a>
<a name="ln268">  Ptrlist     *out;</a>
<a name="ln269">};</a>
<a name="ln270">typedef struct Frag Frag_T;</a>
<a name="ln271"> </a>
<a name="ln272">typedef struct {</a>
<a name="ln273">  int in_use;       ///&lt; number of subexpr with useful info</a>
<a name="ln274"> </a>
<a name="ln275">  // When REG_MULTI is true list.multi is used, otherwise list.line.</a>
<a name="ln276">  union {</a>
<a name="ln277">    struct multipos {</a>
<a name="ln278">      linenr_T  start_lnum;</a>
<a name="ln279">      linenr_T  end_lnum;</a>
<a name="ln280">      colnr_T start_col;</a>
<a name="ln281">      colnr_T end_col;</a>
<a name="ln282">    } multi[NSUBEXP];</a>
<a name="ln283">    struct linepos {</a>
<a name="ln284">      char_u      *start;</a>
<a name="ln285">      char_u      *end;</a>
<a name="ln286">    } line[NSUBEXP];</a>
<a name="ln287">  } list;</a>
<a name="ln288">} regsub_T;</a>
<a name="ln289"> </a>
<a name="ln290">typedef struct {</a>
<a name="ln291">  regsub_T norm;      /* \( .. \) matches */</a>
<a name="ln292">  regsub_T synt;      /* \z( .. \) matches */</a>
<a name="ln293">} regsubs_T;</a>
<a name="ln294"> </a>
<a name="ln295">/* nfa_pim_T stores a Postponed Invisible Match. */</a>
<a name="ln296">typedef struct nfa_pim_S nfa_pim_T;</a>
<a name="ln297">struct nfa_pim_S {</a>
<a name="ln298">  int result;                   /* NFA_PIM_*, see below */</a>
<a name="ln299">  nfa_state_T *state;           /* the invisible match start state */</a>
<a name="ln300">  regsubs_T subs;               /* submatch info, only party used */</a>
<a name="ln301">  union {</a>
<a name="ln302">    lpos_T pos;</a>
<a name="ln303">    char_u  *ptr;</a>
<a name="ln304">  } end;                        /* where the match must end */</a>
<a name="ln305">};</a>
<a name="ln306"> </a>
<a name="ln307">/* nfa_thread_T contains execution information of a NFA state */</a>
<a name="ln308">typedef struct {</a>
<a name="ln309">  nfa_state_T *state;</a>
<a name="ln310">  int count;</a>
<a name="ln311">  nfa_pim_T pim;                /* if pim.result != NFA_PIM_UNUSED: postponed</a>
<a name="ln312">                                 * invisible match */</a>
<a name="ln313">  regsubs_T subs;               /* submatch info, only party used */</a>
<a name="ln314">} nfa_thread_T;</a>
<a name="ln315"> </a>
<a name="ln316">// nfa_list_T contains the alternative NFA execution states.</a>
<a name="ln317">typedef struct {</a>
<a name="ln318">  nfa_thread_T    *t;           ///&lt; allocated array of states</a>
<a name="ln319">  int n;                        ///&lt; nr of states currently in &quot;t&quot;</a>
<a name="ln320">  int len;                      ///&lt; max nr of states in &quot;t&quot;</a>
<a name="ln321">  int id;                       ///&lt; ID of the list</a>
<a name="ln322">  int has_pim;                  ///&lt; true when any state has a PIM</a>
<a name="ln323">} nfa_list_T;</a>
<a name="ln324"> </a>
<a name="ln325">// Variables only used in nfa_regcomp() and descendants.</a>
<a name="ln326">static int nfa_re_flags;  ///&lt; re_flags passed to nfa_regcomp().</a>
<a name="ln327">static int *post_start;   ///&lt; holds the postfix form of r.e.</a>
<a name="ln328">static int *post_end;</a>
<a name="ln329">static int *post_ptr;</a>
<a name="ln330"> </a>
<a name="ln331">// Set when the pattern should use the NFA engine.</a>
<a name="ln332">// E.g. [[:upper:]] only allows 8bit characters for BT engine,</a>
<a name="ln333">// while NFA engine handles multibyte characters correctly.</a>
<a name="ln334">static bool wants_nfa;</a>
<a name="ln335"> </a>
<a name="ln336">static int nstate;  ///&lt; Number of states in the NFA. Also used when executing.</a>
<a name="ln337">static int istate;  ///&lt; Index in the state vector, used in alloc_state()</a>
<a name="ln338"> </a>
<a name="ln339">/* If not NULL match must end at this position */</a>
<a name="ln340">static save_se_T *nfa_endp = NULL;</a>
<a name="ln341"> </a>
<a name="ln342">/* 0 for first call to nfa_regmatch(), 1 for recursive call. */</a>
<a name="ln343">static int nfa_ll_index = 0;</a>
<a name="ln344"> </a>
<a name="ln345">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln346"># include &quot;regexp_nfa.c.generated.h&quot;</a>
<a name="ln347">#endif</a>
<a name="ln348"> </a>
<a name="ln349">// Helper functions used when doing re2post() ... regatom() parsing</a>
<a name="ln350">#define EMIT(c) \</a>
<a name="ln351">    do { \</a>
<a name="ln352">      if (post_ptr &gt;= post_end) { \</a>
<a name="ln353">        realloc_post_list(); \</a>
<a name="ln354">      } \</a>
<a name="ln355">      *post_ptr++ = c; \</a>
<a name="ln356">    } while (0)</a>
<a name="ln357"> </a>
<a name="ln358">/*</a>
<a name="ln359"> * Initialize internal variables before NFA compilation.</a>
<a name="ln360"> */</a>
<a name="ln361">static void</a>
<a name="ln362">nfa_regcomp_start (</a>
<a name="ln363">    char_u *expr,</a>
<a name="ln364">    int re_flags                       /* see vim_regcomp() */</a>
<a name="ln365">)</a>
<a name="ln366">{</a>
<a name="ln367">  size_t postfix_size;</a>
<a name="ln368">  size_t nstate_max;</a>
<a name="ln369"> </a>
<a name="ln370">  nstate = 0;</a>
<a name="ln371">  istate = 0;</a>
<a name="ln372">  /* A reasonable estimation for maximum size */</a>
<a name="ln373">  nstate_max = (STRLEN(expr) + 1) * 25;</a>
<a name="ln374"> </a>
<a name="ln375">  /* Some items blow up in size, such as [A-z].  Add more space for that.</a>
<a name="ln376">   * When it is still not enough realloc_post_list() will be used. */</a>
<a name="ln377">  nstate_max += 1000;</a>
<a name="ln378"> </a>
<a name="ln379">  /* Size for postfix representation of expr. */</a>
<a name="ln380">  postfix_size = sizeof(int) * nstate_max;</a>
<a name="ln381"> </a>
<a name="ln382">  post_start = (int *)xmalloc(postfix_size);</a>
<a name="ln383">  post_ptr = post_start;</a>
<a name="ln384">  post_end = post_start + nstate_max;</a>
<a name="ln385">  wants_nfa = false;</a>
<a name="ln386">  rex.nfa_has_zend = false;</a>
<a name="ln387">  rex.nfa_has_backref = false;</a>
<a name="ln388"> </a>
<a name="ln389">  /* shared with BT engine */</a>
<a name="ln390">  regcomp_start(expr, re_flags);</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">/*</a>
<a name="ln394"> * Figure out if the NFA state list starts with an anchor, must match at start</a>
<a name="ln395"> * of the line.</a>
<a name="ln396"> */</a>
<a name="ln397">static int nfa_get_reganch(nfa_state_T *start, int depth)</a>
<a name="ln398">{</a>
<a name="ln399">  nfa_state_T *p = start;</a>
<a name="ln400"> </a>
<a name="ln401">  if (depth &gt; 4)</a>
<a name="ln402">    return 0;</a>
<a name="ln403"> </a>
<a name="ln404">  while (p != NULL) {</a>
<a name="ln405">    switch (p-&gt;c) {</a>
<a name="ln406">    case NFA_BOL:</a>
<a name="ln407">    case NFA_BOF:</a>
<a name="ln408">      return 1;           /* yes! */</a>
<a name="ln409"> </a>
<a name="ln410">    case NFA_ZSTART:</a>
<a name="ln411">    case NFA_ZEND:</a>
<a name="ln412">    case NFA_CURSOR:</a>
<a name="ln413">    case NFA_VISUAL:</a>
<a name="ln414"> </a>
<a name="ln415">    case NFA_MOPEN:</a>
<a name="ln416">    case NFA_MOPEN1:</a>
<a name="ln417">    case NFA_MOPEN2:</a>
<a name="ln418">    case NFA_MOPEN3:</a>
<a name="ln419">    case NFA_MOPEN4:</a>
<a name="ln420">    case NFA_MOPEN5:</a>
<a name="ln421">    case NFA_MOPEN6:</a>
<a name="ln422">    case NFA_MOPEN7:</a>
<a name="ln423">    case NFA_MOPEN8:</a>
<a name="ln424">    case NFA_MOPEN9:</a>
<a name="ln425">    case NFA_NOPEN:</a>
<a name="ln426">    case NFA_ZOPEN:</a>
<a name="ln427">    case NFA_ZOPEN1:</a>
<a name="ln428">    case NFA_ZOPEN2:</a>
<a name="ln429">    case NFA_ZOPEN3:</a>
<a name="ln430">    case NFA_ZOPEN4:</a>
<a name="ln431">    case NFA_ZOPEN5:</a>
<a name="ln432">    case NFA_ZOPEN6:</a>
<a name="ln433">    case NFA_ZOPEN7:</a>
<a name="ln434">    case NFA_ZOPEN8:</a>
<a name="ln435">    case NFA_ZOPEN9:</a>
<a name="ln436">      p = p-&gt;out;</a>
<a name="ln437">      break;</a>
<a name="ln438"> </a>
<a name="ln439">    case NFA_SPLIT:</a>
<a name="ln440">      return nfa_get_reganch(p-&gt;out, depth + 1)</a>
<a name="ln441">             &amp;&amp; nfa_get_reganch(p-&gt;out1, depth + 1);</a>
<a name="ln442"> </a>
<a name="ln443">    default:</a>
<a name="ln444">      return 0;           /* noooo */</a>
<a name="ln445">    }</a>
<a name="ln446">  }</a>
<a name="ln447">  return 0;</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">/*</a>
<a name="ln451"> * Figure out if the NFA state list starts with a character which must match</a>
<a name="ln452"> * at start of the match.</a>
<a name="ln453"> */</a>
<a name="ln454">static int nfa_get_regstart(nfa_state_T *start, int depth)</a>
<a name="ln455">{</a>
<a name="ln456">  nfa_state_T *p = start;</a>
<a name="ln457"> </a>
<a name="ln458">  if (depth &gt; 4)</a>
<a name="ln459">    return 0;</a>
<a name="ln460"> </a>
<a name="ln461">  while (p != NULL) {</a>
<a name="ln462">    switch (p-&gt;c) {</a>
<a name="ln463">    /* all kinds of zero-width matches */</a>
<a name="ln464">    case NFA_BOL:</a>
<a name="ln465">    case NFA_BOF:</a>
<a name="ln466">    case NFA_BOW:</a>
<a name="ln467">    case NFA_EOW:</a>
<a name="ln468">    case NFA_ZSTART:</a>
<a name="ln469">    case NFA_ZEND:</a>
<a name="ln470">    case NFA_CURSOR:</a>
<a name="ln471">    case NFA_VISUAL:</a>
<a name="ln472">    case NFA_LNUM:</a>
<a name="ln473">    case NFA_LNUM_GT:</a>
<a name="ln474">    case NFA_LNUM_LT:</a>
<a name="ln475">    case NFA_COL:</a>
<a name="ln476">    case NFA_COL_GT:</a>
<a name="ln477">    case NFA_COL_LT:</a>
<a name="ln478">    case NFA_VCOL:</a>
<a name="ln479">    case NFA_VCOL_GT:</a>
<a name="ln480">    case NFA_VCOL_LT:</a>
<a name="ln481">    case NFA_MARK:</a>
<a name="ln482">    case NFA_MARK_GT:</a>
<a name="ln483">    case NFA_MARK_LT:</a>
<a name="ln484"> </a>
<a name="ln485">    case NFA_MOPEN:</a>
<a name="ln486">    case NFA_MOPEN1:</a>
<a name="ln487">    case NFA_MOPEN2:</a>
<a name="ln488">    case NFA_MOPEN3:</a>
<a name="ln489">    case NFA_MOPEN4:</a>
<a name="ln490">    case NFA_MOPEN5:</a>
<a name="ln491">    case NFA_MOPEN6:</a>
<a name="ln492">    case NFA_MOPEN7:</a>
<a name="ln493">    case NFA_MOPEN8:</a>
<a name="ln494">    case NFA_MOPEN9:</a>
<a name="ln495">    case NFA_NOPEN:</a>
<a name="ln496">    case NFA_ZOPEN:</a>
<a name="ln497">    case NFA_ZOPEN1:</a>
<a name="ln498">    case NFA_ZOPEN2:</a>
<a name="ln499">    case NFA_ZOPEN3:</a>
<a name="ln500">    case NFA_ZOPEN4:</a>
<a name="ln501">    case NFA_ZOPEN5:</a>
<a name="ln502">    case NFA_ZOPEN6:</a>
<a name="ln503">    case NFA_ZOPEN7:</a>
<a name="ln504">    case NFA_ZOPEN8:</a>
<a name="ln505">    case NFA_ZOPEN9:</a>
<a name="ln506">      p = p-&gt;out;</a>
<a name="ln507">      break;</a>
<a name="ln508"> </a>
<a name="ln509">    case NFA_SPLIT:</a>
<a name="ln510">    {</a>
<a name="ln511">      int c1 = nfa_get_regstart(p-&gt;out, depth + 1);</a>
<a name="ln512">      int c2 = nfa_get_regstart(p-&gt;out1, depth + 1);</a>
<a name="ln513"> </a>
<a name="ln514">      if (c1 == c2)</a>
<a name="ln515">        return c1;             /* yes! */</a>
<a name="ln516">      return 0;</a>
<a name="ln517">    }</a>
<a name="ln518"> </a>
<a name="ln519">    default:</a>
<a name="ln520">      if (p-&gt;c &gt; 0)</a>
<a name="ln521">        return p-&gt;c;             /* yes! */</a>
<a name="ln522">      return 0;</a>
<a name="ln523">    }</a>
<a name="ln524">  }</a>
<a name="ln525">  return 0;</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">/*</a>
<a name="ln529"> * Figure out if the NFA state list contains just literal text and nothing</a>
<a name="ln530"> * else.  If so return a string in allocated memory with what must match after</a>
<a name="ln531"> * regstart.  Otherwise return NULL.</a>
<a name="ln532"> */</a>
<a name="ln533">static char_u *nfa_get_match_text(nfa_state_T *start)</a>
<a name="ln534">{</a>
<a name="ln535">  nfa_state_T *p = start;</a>
<a name="ln536">  int len = 0;</a>
<a name="ln537">  char_u      *ret;</a>
<a name="ln538">  char_u      *s;</a>
<a name="ln539"> </a>
<a name="ln540">  if (p-&gt;c != NFA_MOPEN)</a>
<a name="ln541">    return NULL;     /* just in case */</a>
<a name="ln542">  p = p-&gt;out;</a>
<a name="ln543">  while (p-&gt;c &gt; 0) {</a>
<a name="ln544">    len += MB_CHAR2LEN(p-&gt;c);</a>
<a name="ln545">    p = p-&gt;out;</a>
<a name="ln546">  }</a>
<a name="ln547">  if (p-&gt;c != NFA_MCLOSE || p-&gt;out-&gt;c != NFA_MATCH)</a>
<a name="ln548">    return NULL;</a>
<a name="ln549"> </a>
<a name="ln550">  ret = xmalloc(len);</a>
<a name="ln551">  p = start-&gt;out-&gt;out;     /* skip first char, it goes into regstart */</a>
<a name="ln552">  s = ret;</a>
<a name="ln553">  while (p-&gt;c &gt; 0) {</a>
<a name="ln554">    s += utf_char2bytes(p-&gt;c, s);</a>
<a name="ln555">    p = p-&gt;out;</a>
<a name="ln556">  }</a>
<a name="ln557">  *s = NUL;</a>
<a name="ln558"> </a>
<a name="ln559">  return ret;</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">/*</a>
<a name="ln563"> * Allocate more space for post_start.  Called when</a>
<a name="ln564"> * running above the estimated number of states.</a>
<a name="ln565"> */</a>
<a name="ln566">static void realloc_post_list(void)</a>
<a name="ln567">{</a>
<a name="ln568">  // For weird patterns the number of states can be very high. Increasing by</a>
<a name="ln569">  // 50% seems a reasonable compromise between memory use and speed.</a>
<a name="ln570">  const size_t new_max = (post_end - post_start) * 3 / 2;</a>
<a name="ln571">  int *new_start = xrealloc(post_start, new_max * sizeof(int));</a>
<a name="ln572">  post_ptr = new_start + (post_ptr - post_start);</a>
<a name="ln573">  post_end = new_start + new_max;</a>
<a name="ln574">  post_start = new_start;</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">/*</a>
<a name="ln578"> * Search between &quot;start&quot; and &quot;end&quot; and try to recognize a</a>
<a name="ln579"> * character class in expanded form. For example [0-9].</a>
<a name="ln580"> * On success, return the id the character class to be emitted.</a>
<a name="ln581"> * On failure, return 0 (=FAIL)</a>
<a name="ln582"> * Start points to the first char of the range, while end should point</a>
<a name="ln583"> * to the closing brace.</a>
<a name="ln584"> * Keep in mind that 'ignorecase' applies at execution time, thus [a-z] may</a>
<a name="ln585"> * need to be interpreted as [a-zA-Z].</a>
<a name="ln586"> */</a>
<a name="ln587">static int nfa_recognize_char_class(char_u *start, char_u *end, int extra_newl)</a>
<a name="ln588">{</a>
<a name="ln589">#   define CLASS_not            0x80</a>
<a name="ln590">#   define CLASS_af             0x40</a>
<a name="ln591">#   define CLASS_AF             0x20</a>
<a name="ln592">#   define CLASS_az             0x10</a>
<a name="ln593">#   define CLASS_AZ             0x08</a>
<a name="ln594">#   define CLASS_o7             0x04</a>
<a name="ln595">#   define CLASS_o9             0x02</a>
<a name="ln596">#   define CLASS_underscore     0x01</a>
<a name="ln597"> </a>
<a name="ln598">  char_u      *p;</a>
<a name="ln599">  int config = 0;</a>
<a name="ln600"> </a>
<a name="ln601">  bool newl = extra_newl == true;</a>
<a name="ln602"> </a>
<a name="ln603">  if (*end != ']')</a>
<a name="ln604">    return FAIL;</a>
<a name="ln605">  p = start;</a>
<a name="ln606">  if (*p == '^') {</a>
<a name="ln607">    config |= CLASS_not;</a>
<a name="ln608">    p++;</a>
<a name="ln609">  }</a>
<a name="ln610"> </a>
<a name="ln611">  while (p &lt; end) {</a>
<a name="ln612">    if (p + 2 &lt; end &amp;&amp; *(p + 1) == '-') {</a>
<a name="ln613">      switch (*p) {</a>
<a name="ln614">      case '0':</a>
<a name="ln615">        if (*(p + 2) == '9') {</a>
<a name="ln616">          config |= CLASS_o9;</a>
<a name="ln617">          break;</a>
<a name="ln618">        } else if (*(p + 2) == '7') {</a>
<a name="ln619">          config |= CLASS_o7;</a>
<a name="ln620">          break;</a>
<a name="ln621">        }</a>
<a name="ln622">        return FAIL;</a>
<a name="ln623">      case 'a':</a>
<a name="ln624">        if (*(p + 2) == 'z') {</a>
<a name="ln625">          config |= CLASS_az;</a>
<a name="ln626">          break;</a>
<a name="ln627">        } else if (*(p + 2) == 'f') {</a>
<a name="ln628">          config |= CLASS_af;</a>
<a name="ln629">          break;</a>
<a name="ln630">        }</a>
<a name="ln631">        return FAIL;</a>
<a name="ln632">      case 'A':</a>
<a name="ln633">        if (*(p + 2) == 'Z') {</a>
<a name="ln634">          config |= CLASS_AZ;</a>
<a name="ln635">          break;</a>
<a name="ln636">        } else if (*(p + 2) == 'F') {</a>
<a name="ln637">          config |= CLASS_AF;</a>
<a name="ln638">          break;</a>
<a name="ln639">        }</a>
<a name="ln640">        return FAIL;</a>
<a name="ln641">      default:</a>
<a name="ln642">        return FAIL;</a>
<a name="ln643">      }</a>
<a name="ln644">      p += 3;</a>
<a name="ln645">    } else if (p + 1 &lt; end &amp;&amp; *p == '\\' &amp;&amp; *(p + 1) == 'n') {</a>
<a name="ln646">      newl = true;</a>
<a name="ln647">      p += 2;</a>
<a name="ln648">    } else if (*p == '_') {</a>
<a name="ln649">      config |= CLASS_underscore;</a>
<a name="ln650">      p++;</a>
<a name="ln651">    } else if (*p == '\n') {</a>
<a name="ln652">      newl = true;</a>
<a name="ln653">      p++;</a>
<a name="ln654">    } else</a>
<a name="ln655">      return FAIL;</a>
<a name="ln656">  }   /* while (p &lt; end) */</a>
<a name="ln657"> </a>
<a name="ln658">  if (p != end)</a>
<a name="ln659">    return FAIL;</a>
<a name="ln660"> </a>
<a name="ln661">  if (newl == true) {</a>
<a name="ln662">    extra_newl = NFA_ADD_NL;</a>
<a name="ln663">  }</a>
<a name="ln664"> </a>
<a name="ln665">  switch (config) {</a>
<a name="ln666">  case CLASS_o9:</a>
<a name="ln667">    return extra_newl + NFA_DIGIT;</a>
<a name="ln668">  case CLASS_not |  CLASS_o9:</a>
<a name="ln669">    return extra_newl + NFA_NDIGIT;</a>
<a name="ln670">  case CLASS_af | CLASS_AF | CLASS_o9:</a>
<a name="ln671">    return extra_newl + NFA_HEX;</a>
<a name="ln672">  case CLASS_not | CLASS_af | CLASS_AF | CLASS_o9:</a>
<a name="ln673">    return extra_newl + NFA_NHEX;</a>
<a name="ln674">  case CLASS_o7:</a>
<a name="ln675">    return extra_newl + NFA_OCTAL;</a>
<a name="ln676">  case CLASS_not | CLASS_o7:</a>
<a name="ln677">    return extra_newl + NFA_NOCTAL;</a>
<a name="ln678">  case CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:</a>
<a name="ln679">    return extra_newl + NFA_WORD;</a>
<a name="ln680">  case CLASS_not | CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:</a>
<a name="ln681">    return extra_newl + NFA_NWORD;</a>
<a name="ln682">  case CLASS_az | CLASS_AZ | CLASS_underscore:</a>
<a name="ln683">    return extra_newl + NFA_HEAD;</a>
<a name="ln684">  case CLASS_not | CLASS_az | CLASS_AZ | CLASS_underscore:</a>
<a name="ln685">    return extra_newl + NFA_NHEAD;</a>
<a name="ln686">  case CLASS_az | CLASS_AZ:</a>
<a name="ln687">    return extra_newl + NFA_ALPHA;</a>
<a name="ln688">  case CLASS_not | CLASS_az | CLASS_AZ:</a>
<a name="ln689">    return extra_newl + NFA_NALPHA;</a>
<a name="ln690">  case CLASS_az:</a>
<a name="ln691">    return extra_newl + NFA_LOWER_IC;</a>
<a name="ln692">  case CLASS_not | CLASS_az:</a>
<a name="ln693">    return extra_newl + NFA_NLOWER_IC;</a>
<a name="ln694">  case CLASS_AZ:</a>
<a name="ln695">    return extra_newl + NFA_UPPER_IC;</a>
<a name="ln696">  case CLASS_not | CLASS_AZ:</a>
<a name="ln697">    return extra_newl + NFA_NUPPER_IC;</a>
<a name="ln698">  }</a>
<a name="ln699">  return FAIL;</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">/*</a>
<a name="ln703"> * Produce the bytes for equivalence class &quot;c&quot;.</a>
<a name="ln704"> * Currently only handles latin1, latin9 and utf-8.</a>
<a name="ln705"> * Emits bytes in postfix notation: 'a,b,NFA_OR,c,NFA_OR' is</a>
<a name="ln706"> * equivalent to 'a OR b OR c'</a>
<a name="ln707"> *</a>
<a name="ln708"> * NOTE! When changing this function, also update reg_equi_class()</a>
<a name="ln709"> */</a>
<a name="ln710">static void nfa_emit_equi_class(int c)</a>
<a name="ln711">{</a>
<a name="ln712">#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);</a>
<a name="ln713">#define EMITMBC(c) EMIT(c); EMIT(NFA_CONCAT);</a>
<a name="ln714"> </a>
<a name="ln715">  {</a>
<a name="ln716">#define A_grave 0xc0</a>
<a name="ln717">#define A_acute 0xc1</a>
<a name="ln718">#define A_circumflex 0xc2</a>
<a name="ln719">#define A_virguilla 0xc3</a>
<a name="ln720">#define A_diaeresis 0xc4</a>
<a name="ln721">#define A_ring 0xc5</a>
<a name="ln722">#define C_cedilla 0xc7</a>
<a name="ln723">#define E_grave 0xc8</a>
<a name="ln724">#define E_acute 0xc9</a>
<a name="ln725">#define E_circumflex 0xca</a>
<a name="ln726">#define E_diaeresis 0xcb</a>
<a name="ln727">#define I_grave 0xcc</a>
<a name="ln728">#define I_acute 0xcd</a>
<a name="ln729">#define I_circumflex 0xce</a>
<a name="ln730">#define I_diaeresis 0xcf</a>
<a name="ln731">#define N_virguilla 0xd1</a>
<a name="ln732">#define O_grave 0xd2</a>
<a name="ln733">#define O_acute 0xd3</a>
<a name="ln734">#define O_circumflex 0xd4</a>
<a name="ln735">#define O_virguilla 0xd5</a>
<a name="ln736">#define O_diaeresis 0xd6</a>
<a name="ln737">#define O_slash 0xd8</a>
<a name="ln738">#define U_grave 0xd9</a>
<a name="ln739">#define U_acute 0xda</a>
<a name="ln740">#define U_circumflex 0xdb</a>
<a name="ln741">#define U_diaeresis 0xdc</a>
<a name="ln742">#define Y_acute 0xdd</a>
<a name="ln743">#define a_grave 0xe0</a>
<a name="ln744">#define a_acute 0xe1</a>
<a name="ln745">#define a_circumflex 0xe2</a>
<a name="ln746">#define a_virguilla 0xe3</a>
<a name="ln747">#define a_diaeresis 0xe4</a>
<a name="ln748">#define a_ring 0xe5</a>
<a name="ln749">#define c_cedilla 0xe7</a>
<a name="ln750">#define e_grave 0xe8</a>
<a name="ln751">#define e_acute 0xe9</a>
<a name="ln752">#define e_circumflex 0xea</a>
<a name="ln753">#define e_diaeresis 0xeb</a>
<a name="ln754">#define i_grave 0xec</a>
<a name="ln755">#define i_acute 0xed</a>
<a name="ln756">#define i_circumflex 0xee</a>
<a name="ln757">#define i_diaeresis 0xef</a>
<a name="ln758">#define n_virguilla 0xf1</a>
<a name="ln759">#define o_grave 0xf2</a>
<a name="ln760">#define o_acute 0xf3</a>
<a name="ln761">#define o_circumflex 0xf4</a>
<a name="ln762">#define o_virguilla 0xf5</a>
<a name="ln763">#define o_diaeresis 0xf6</a>
<a name="ln764">#define o_slash 0xf8</a>
<a name="ln765">#define u_grave 0xf9</a>
<a name="ln766">#define u_acute 0xfa</a>
<a name="ln767">#define u_circumflex 0xfb</a>
<a name="ln768">#define u_diaeresis 0xfc</a>
<a name="ln769">#define y_acute 0xfd</a>
<a name="ln770">#define y_diaeresis 0xff</a>
<a name="ln771">    switch (c) {</a>
<a name="ln772">    case 'A': case A_grave: case A_acute: case A_circumflex:</a>
<a name="ln773">              case A_virguilla: case A_diaeresis: case A_ring:</a>
<a name="ln774">              CASEMBC(0x100) CASEMBC(0x102) CASEMBC(0x104)</a>
<a name="ln775">              CASEMBC(0x1cd) CASEMBC(0x1de) CASEMBC(0x1e0)</a>
<a name="ln776">              CASEMBC(0x1ea2)</a>
<a name="ln777">      EMIT2('A'); EMIT2(A_grave); EMIT2(A_acute);</a>
<a name="ln778">      EMIT2(A_circumflex); EMIT2(A_virguilla);</a>
<a name="ln779">      EMIT2(A_diaeresis); EMIT2(A_ring);</a>
<a name="ln780">      EMITMBC(0x100) EMITMBC(0x102) EMITMBC(0x104)</a>
<a name="ln781">      EMITMBC(0x1cd) EMITMBC(0x1de) EMITMBC(0x1e0)</a>
<a name="ln782">      EMITMBC(0x1ea2)</a>
<a name="ln783">      return;</a>
<a name="ln784"> </a>
<a name="ln785">    case 'B': CASEMBC(0x1e02) CASEMBC(0x1e06)</a>
<a name="ln786">      EMIT2('B'); EMITMBC(0x1e02) EMITMBC(0x1e06)</a>
<a name="ln787">      return;</a>
<a name="ln788"> </a>
<a name="ln789">    case 'C': case C_cedilla: CASEMBC(0x106) CASEMBC(0x108) CASEMBC(0x10a)</a>
<a name="ln790">              CASEMBC(0x10c)</a>
<a name="ln791">      EMIT2('C'); EMIT2(C_cedilla); EMITMBC(0x106) EMITMBC(0x108)</a>
<a name="ln792">      EMITMBC(0x10a) EMITMBC(0x10c)</a>
<a name="ln793">      return;</a>
<a name="ln794"> </a>
<a name="ln795">    case 'D': CASEMBC(0x10e) CASEMBC(0x110) CASEMBC(0x1e0a)</a>
<a name="ln796">              CASEMBC(0x1e0e) CASEMBC(0x1e10)</a>
<a name="ln797">      EMIT2('D'); EMITMBC(0x10e) EMITMBC(0x110) EMITMBC(0x1e0a)</a>
<a name="ln798">      EMITMBC(0x1e0e) EMITMBC(0x1e10)</a>
<a name="ln799">      return;</a>
<a name="ln800"> </a>
<a name="ln801">    case 'E': case E_grave: case E_acute: case E_circumflex:</a>
<a name="ln802">              case E_diaeresis: CASEMBC(0x112) CASEMBC(0x114)</a>
<a name="ln803">              CASEMBC(0x116) CASEMBC(0x118) CASEMBC(0x11a)</a>
<a name="ln804">              CASEMBC(0x1eba) CASEMBC(0x1ebc)</a>
<a name="ln805">      EMIT2('E'); EMIT2(E_grave); EMIT2(E_acute);</a>
<a name="ln806">      EMIT2(E_circumflex); EMIT2(E_diaeresis);</a>
<a name="ln807">      EMITMBC(0x112) EMITMBC(0x114) EMITMBC(0x116)</a>
<a name="ln808">      EMITMBC(0x118) EMITMBC(0x11a) EMITMBC(0x1eba)</a>
<a name="ln809">      EMITMBC(0x1ebc)</a>
<a name="ln810">      return;</a>
<a name="ln811"> </a>
<a name="ln812">    case 'F': CASEMBC(0x1e1e)</a>
<a name="ln813">      EMIT2('F'); EMITMBC(0x1e1e)</a>
<a name="ln814">      return;</a>
<a name="ln815"> </a>
<a name="ln816">    case 'G': CASEMBC(0x11c) CASEMBC(0x11e) CASEMBC(0x120)</a>
<a name="ln817">              CASEMBC(0x122) CASEMBC(0x1e4) CASEMBC(0x1e6)</a>
<a name="ln818">              CASEMBC(0x1f4) CASEMBC(0x1e20)</a>
<a name="ln819">      EMIT2('G'); EMITMBC(0x11c) EMITMBC(0x11e) EMITMBC(0x120)</a>
<a name="ln820">      EMITMBC(0x122) EMITMBC(0x1e4) EMITMBC(0x1e6)</a>
<a name="ln821">      EMITMBC(0x1f4) EMITMBC(0x1e20)</a>
<a name="ln822">      return;</a>
<a name="ln823"> </a>
<a name="ln824">    case 'H': CASEMBC(0x124) CASEMBC(0x126) CASEMBC(0x1e22)</a>
<a name="ln825">              CASEMBC(0x1e26) CASEMBC(0x1e28)</a>
<a name="ln826">      EMIT2('H'); EMITMBC(0x124) EMITMBC(0x126) EMITMBC(0x1e22)</a>
<a name="ln827">      EMITMBC(0x1e26) EMITMBC(0x1e28)</a>
<a name="ln828">      return;</a>
<a name="ln829"> </a>
<a name="ln830">    case 'I': case I_grave: case I_acute: case I_circumflex:</a>
<a name="ln831">              case I_diaeresis: CASEMBC(0x128) CASEMBC(0x12a)</a>
<a name="ln832">              CASEMBC(0x12c) CASEMBC(0x12e) CASEMBC(0x130)</a>
<a name="ln833">              CASEMBC(0x1cf) CASEMBC(0x1ec8)</a>
<a name="ln834">      EMIT2('I'); EMIT2(I_grave); EMIT2(I_acute);</a>
<a name="ln835">      EMIT2(I_circumflex); EMIT2(I_diaeresis);</a>
<a name="ln836">      EMITMBC(0x128) EMITMBC(0x12a)</a>
<a name="ln837">      EMITMBC(0x12c) EMITMBC(0x12e) EMITMBC(0x130)</a>
<a name="ln838">      EMITMBC(0x1cf) EMITMBC(0x1ec8)</a>
<a name="ln839">      return;</a>
<a name="ln840"> </a>
<a name="ln841">    case 'J': CASEMBC(0x134)</a>
<a name="ln842">      EMIT2('J'); EMITMBC(0x134)</a>
<a name="ln843">      return;</a>
<a name="ln844"> </a>
<a name="ln845">    case 'K': CASEMBC(0x136) CASEMBC(0x1e8) CASEMBC(0x1e30)</a>
<a name="ln846">              CASEMBC(0x1e34)</a>
<a name="ln847">      EMIT2('K'); EMITMBC(0x136) EMITMBC(0x1e8) EMITMBC(0x1e30)</a>
<a name="ln848">      EMITMBC(0x1e34)</a>
<a name="ln849">      return;</a>
<a name="ln850"> </a>
<a name="ln851">    case 'L': CASEMBC(0x139) CASEMBC(0x13b) CASEMBC(0x13d)</a>
<a name="ln852">              CASEMBC(0x13f) CASEMBC(0x141) CASEMBC(0x1e3a)</a>
<a name="ln853">      EMIT2('L'); EMITMBC(0x139) EMITMBC(0x13b) EMITMBC(0x13d)</a>
<a name="ln854">      EMITMBC(0x13f) EMITMBC(0x141) EMITMBC(0x1e3a)</a>
<a name="ln855">      return;</a>
<a name="ln856"> </a>
<a name="ln857">    case 'M': CASEMBC(0x1e3e) CASEMBC(0x1e40)</a>
<a name="ln858">      EMIT2('M'); EMITMBC(0x1e3e) EMITMBC(0x1e40)</a>
<a name="ln859">      return;</a>
<a name="ln860"> </a>
<a name="ln861">    case 'N': case N_virguilla: CASEMBC(0x143) CASEMBC(0x145)</a>
<a name="ln862">              CASEMBC(0x147) CASEMBC(0x1e44) CASEMBC(0x1e48)</a>
<a name="ln863">      EMIT2('N'); EMIT2(N_virguilla);</a>
<a name="ln864">      EMITMBC(0x143) EMITMBC(0x145)</a>
<a name="ln865">      EMITMBC(0x147) EMITMBC(0x1e44) EMITMBC(0x1e48)</a>
<a name="ln866">      return;</a>
<a name="ln867"> </a>
<a name="ln868">    case 'O': case O_grave: case O_acute: case O_circumflex:</a>
<a name="ln869">              case O_virguilla: case O_diaeresis: case O_slash:</a>
<a name="ln870">              CASEMBC(0x14c) CASEMBC(0x14e) CASEMBC(0x150)</a>
<a name="ln871">              CASEMBC(0x1a0) CASEMBC(0x1d1) CASEMBC(0x1ea)</a>
<a name="ln872">              CASEMBC(0x1ec) CASEMBC(0x1ece)</a>
<a name="ln873">      EMIT2('O'); EMIT2(O_grave); EMIT2(O_acute);</a>
<a name="ln874">      EMIT2(O_circumflex); EMIT2(O_virguilla);</a>
<a name="ln875">      EMIT2(O_diaeresis); EMIT2(O_slash);</a>
<a name="ln876">      EMITMBC(0x14c) EMITMBC(0x14e) EMITMBC(0x150)</a>
<a name="ln877">      EMITMBC(0x1a0) EMITMBC(0x1d1) EMITMBC(0x1ea)</a>
<a name="ln878">      EMITMBC(0x1ec) EMITMBC(0x1ece)</a>
<a name="ln879">      return;</a>
<a name="ln880"> </a>
<a name="ln881">    case 'P': case 0x1e54: case 0x1e56:</a>
<a name="ln882">      EMIT2('P'); EMITMBC(0x1e54) EMITMBC(0x1e56)</a>
<a name="ln883">      return;</a>
<a name="ln884"> </a>
<a name="ln885">    case 'R': CASEMBC(0x154) CASEMBC(0x156) CASEMBC(0x158)</a>
<a name="ln886">              CASEMBC(0x1e58) CASEMBC(0x1e5e)</a>
<a name="ln887">      EMIT2('R'); EMITMBC(0x154) EMITMBC(0x156) EMITMBC(0x158)</a>
<a name="ln888">      EMITMBC(0x1e58) EMITMBC(0x1e5e)</a>
<a name="ln889">      return;</a>
<a name="ln890"> </a>
<a name="ln891">    case 'S': CASEMBC(0x15a) CASEMBC(0x15c) CASEMBC(0x15e)</a>
<a name="ln892">              CASEMBC(0x160) CASEMBC(0x1e60)</a>
<a name="ln893">      EMIT2('S'); EMITMBC(0x15a) EMITMBC(0x15c) EMITMBC(0x15e)</a>
<a name="ln894">      EMITMBC(0x160) EMITMBC(0x1e60)</a>
<a name="ln895">      return;</a>
<a name="ln896"> </a>
<a name="ln897">    case 'T': CASEMBC(0x162) CASEMBC(0x164) CASEMBC(0x166)</a>
<a name="ln898">              CASEMBC(0x1e6a) CASEMBC(0x1e6e)</a>
<a name="ln899">      EMIT2('T'); EMITMBC(0x162) EMITMBC(0x164) EMITMBC(0x166)</a>
<a name="ln900">      EMITMBC(0x1e6a) EMITMBC(0x1e6e)</a>
<a name="ln901">      return;</a>
<a name="ln902"> </a>
<a name="ln903">    case 'U': case U_grave: case U_acute: case U_diaeresis:</a>
<a name="ln904">              case U_circumflex: CASEMBC(0x168) CASEMBC(0x16a)</a>
<a name="ln905">              CASEMBC(0x16c) CASEMBC(0x16e) CASEMBC(0x170)</a>
<a name="ln906">              CASEMBC(0x172) CASEMBC(0x1af) CASEMBC(0x1d3)</a>
<a name="ln907">              CASEMBC(0x1ee6)</a>
<a name="ln908">      EMIT2('U'); EMIT2(U_grave); EMIT2(U_acute);</a>
<a name="ln909">      EMIT2(U_diaeresis); EMIT2(U_circumflex);</a>
<a name="ln910">      EMITMBC(0x168) EMITMBC(0x16a)</a>
<a name="ln911">      EMITMBC(0x16c) EMITMBC(0x16e) EMITMBC(0x170)</a>
<a name="ln912">      EMITMBC(0x172) EMITMBC(0x1af) EMITMBC(0x1d3)</a>
<a name="ln913">      EMITMBC(0x1ee6)</a>
<a name="ln914">      return;</a>
<a name="ln915"> </a>
<a name="ln916">    case 'V': CASEMBC(0x1e7c)</a>
<a name="ln917">      EMIT2('V'); EMITMBC(0x1e7c)</a>
<a name="ln918">      return;</a>
<a name="ln919"> </a>
<a name="ln920">    case 'W': CASEMBC(0x174) CASEMBC(0x1e80) CASEMBC(0x1e82)</a>
<a name="ln921">              CASEMBC(0x1e84) CASEMBC(0x1e86)</a>
<a name="ln922">      EMIT2('W'); EMITMBC(0x174) EMITMBC(0x1e80) EMITMBC(0x1e82)</a>
<a name="ln923">      EMITMBC(0x1e84) EMITMBC(0x1e86)</a>
<a name="ln924">      return;</a>
<a name="ln925"> </a>
<a name="ln926">    case 'X': CASEMBC(0x1e8a) CASEMBC(0x1e8c)</a>
<a name="ln927">      EMIT2('X'); EMITMBC(0x1e8a) EMITMBC(0x1e8c)</a>
<a name="ln928">      return;</a>
<a name="ln929"> </a>
<a name="ln930">    case 'Y': case Y_acute: CASEMBC(0x176) CASEMBC(0x178)</a>
<a name="ln931">              CASEMBC(0x1e8e) CASEMBC(0x1ef2) CASEMBC(0x1ef6)</a>
<a name="ln932">              CASEMBC(0x1ef8)</a>
<a name="ln933">      EMIT2('Y'); EMIT2(Y_acute);</a>
<a name="ln934">      EMITMBC(0x176) EMITMBC(0x178)</a>
<a name="ln935">      EMITMBC(0x1e8e) EMITMBC(0x1ef2) EMITMBC(0x1ef6)</a>
<a name="ln936">      EMITMBC(0x1ef8)</a>
<a name="ln937">      return;</a>
<a name="ln938"> </a>
<a name="ln939">    case 'Z': CASEMBC(0x179) CASEMBC(0x17b) CASEMBC(0x17d)</a>
<a name="ln940">              CASEMBC(0x1b5) CASEMBC(0x1e90) CASEMBC(0x1e94)</a>
<a name="ln941">      EMIT2('Z'); EMITMBC(0x179) EMITMBC(0x17b) EMITMBC(0x17d)</a>
<a name="ln942">      EMITMBC(0x1b5) EMITMBC(0x1e90) EMITMBC(0x1e94)</a>
<a name="ln943">      return;</a>
<a name="ln944"> </a>
<a name="ln945">    case 'a': case a_grave: case a_acute: case a_circumflex:</a>
<a name="ln946">              case a_virguilla: case a_diaeresis: case a_ring:</a>
<a name="ln947">              CASEMBC(0x101) CASEMBC(0x103) CASEMBC(0x105)</a>
<a name="ln948">              CASEMBC(0x1ce) CASEMBC(0x1df) CASEMBC(0x1e1)</a>
<a name="ln949">              CASEMBC(0x1ea3)</a>
<a name="ln950">      EMIT2('a'); EMIT2(a_grave); EMIT2(a_acute);</a>
<a name="ln951">      EMIT2(a_circumflex); EMIT2(a_virguilla);</a>
<a name="ln952">      EMIT2(a_diaeresis); EMIT2(a_ring);</a>
<a name="ln953">      EMITMBC(0x101) EMITMBC(0x103) EMITMBC(0x105)</a>
<a name="ln954">      EMITMBC(0x1ce) EMITMBC(0x1df) EMITMBC(0x1e1)</a>
<a name="ln955">      EMITMBC(0x1ea3)</a>
<a name="ln956">      return;</a>
<a name="ln957"> </a>
<a name="ln958">    case 'b': CASEMBC(0x1e03) CASEMBC(0x1e07)</a>
<a name="ln959">      EMIT2('b'); EMITMBC(0x1e03) EMITMBC(0x1e07)</a>
<a name="ln960">      return;</a>
<a name="ln961"> </a>
<a name="ln962">    case 'c': case c_cedilla: CASEMBC(0x107) CASEMBC(0x109)</a>
<a name="ln963">              CASEMBC(0x10b) CASEMBC(0x10d)</a>
<a name="ln964">      EMIT2('c'); EMIT2(c_cedilla);</a>
<a name="ln965">      EMITMBC(0x107) EMITMBC(0x109)</a>
<a name="ln966">      EMITMBC(0x10b) EMITMBC(0x10d)</a>
<a name="ln967">      return;</a>
<a name="ln968"> </a>
<a name="ln969">    case 'd': CASEMBC(0x10f) CASEMBC(0x111) CASEMBC(0x1e0b)</a>
<a name="ln970">              CASEMBC(0x1e0f) CASEMBC(0x1e11)</a>
<a name="ln971">      EMIT2('d'); EMITMBC(0x10f) EMITMBC(0x111) EMITMBC(0x1e0b)</a>
<a name="ln972">      EMITMBC(0x1e0f) EMITMBC(0x1e11)</a>
<a name="ln973">      return;</a>
<a name="ln974"> </a>
<a name="ln975">    case 'e': case e_grave: case e_acute: case e_circumflex:</a>
<a name="ln976">              case e_diaeresis: CASEMBC(0x113) CASEMBC(0x115)</a>
<a name="ln977">              CASEMBC(0x117) CASEMBC(0x119) CASEMBC(0x11b)</a>
<a name="ln978">              CASEMBC(0x1ebb) CASEMBC(0x1ebd)</a>
<a name="ln979">      EMIT2('e'); EMIT2(e_grave); EMIT2(e_acute);</a>
<a name="ln980">      EMIT2(e_circumflex); EMIT2(e_diaeresis);</a>
<a name="ln981">      EMITMBC(0x113) EMITMBC(0x115)</a>
<a name="ln982">      EMITMBC(0x117) EMITMBC(0x119) EMITMBC(0x11b)</a>
<a name="ln983">      EMITMBC(0x1ebb) EMITMBC(0x1ebd)</a>
<a name="ln984">      return;</a>
<a name="ln985"> </a>
<a name="ln986">    case 'f': CASEMBC(0x1e1f)</a>
<a name="ln987">      EMIT2('f'); EMITMBC(0x1e1f)</a>
<a name="ln988">      return;</a>
<a name="ln989"> </a>
<a name="ln990">    case 'g': CASEMBC(0x11d) CASEMBC(0x11f) CASEMBC(0x121)</a>
<a name="ln991">              CASEMBC(0x123) CASEMBC(0x1e5) CASEMBC(0x1e7)</a>
<a name="ln992">              CASEMBC(0x1f5) CASEMBC(0x1e21)</a>
<a name="ln993">      EMIT2('g'); EMITMBC(0x11d) EMITMBC(0x11f) EMITMBC(0x121)</a>
<a name="ln994">      EMITMBC(0x123) EMITMBC(0x1e5) EMITMBC(0x1e7)</a>
<a name="ln995">      EMITMBC(0x1f5) EMITMBC(0x1e21)</a>
<a name="ln996">      return;</a>
<a name="ln997"> </a>
<a name="ln998">    case 'h': CASEMBC(0x125) CASEMBC(0x127) CASEMBC(0x1e23)</a>
<a name="ln999">              CASEMBC(0x1e27) CASEMBC(0x1e29) CASEMBC(0x1e96)</a>
<a name="ln1000">      EMIT2('h'); EMITMBC(0x125) EMITMBC(0x127) EMITMBC(0x1e23)</a>
<a name="ln1001">      EMITMBC(0x1e27) EMITMBC(0x1e29) EMITMBC(0x1e96)</a>
<a name="ln1002">      return;</a>
<a name="ln1003"> </a>
<a name="ln1004">    case 'i': case i_grave: case i_acute: case i_circumflex:</a>
<a name="ln1005">              case i_diaeresis: CASEMBC(0x129) CASEMBC(0x12b)</a>
<a name="ln1006">              CASEMBC(0x12d) CASEMBC(0x12f) CASEMBC(0x1d0)</a>
<a name="ln1007">              CASEMBC(0x1ec9)</a>
<a name="ln1008">      EMIT2('i'); EMIT2(i_grave); EMIT2(i_acute);</a>
<a name="ln1009">      EMIT2(i_circumflex); EMIT2(i_diaeresis);</a>
<a name="ln1010">      EMITMBC(0x129) EMITMBC(0x12b)</a>
<a name="ln1011">      EMITMBC(0x12d) EMITMBC(0x12f) EMITMBC(0x1d0)</a>
<a name="ln1012">      EMITMBC(0x1ec9)</a>
<a name="ln1013">      return;</a>
<a name="ln1014"> </a>
<a name="ln1015">    case 'j': CASEMBC(0x135) CASEMBC(0x1f0)</a>
<a name="ln1016">      EMIT2('j'); EMITMBC(0x135) EMITMBC(0x1f0)</a>
<a name="ln1017">      return;</a>
<a name="ln1018"> </a>
<a name="ln1019">    case 'k': CASEMBC(0x137) CASEMBC(0x1e9) CASEMBC(0x1e31)</a>
<a name="ln1020">              CASEMBC(0x1e35)</a>
<a name="ln1021">      EMIT2('k'); EMITMBC(0x137) EMITMBC(0x1e9) EMITMBC(0x1e31)</a>
<a name="ln1022">      EMITMBC(0x1e35)</a>
<a name="ln1023">      return;</a>
<a name="ln1024"> </a>
<a name="ln1025">    case 'l': CASEMBC(0x13a) CASEMBC(0x13c) CASEMBC(0x13e)</a>
<a name="ln1026">              CASEMBC(0x140) CASEMBC(0x142) CASEMBC(0x1e3b)</a>
<a name="ln1027">      EMIT2('l'); EMITMBC(0x13a) EMITMBC(0x13c) EMITMBC(0x13e)</a>
<a name="ln1028">      EMITMBC(0x140) EMITMBC(0x142) EMITMBC(0x1e3b)</a>
<a name="ln1029">      return;</a>
<a name="ln1030"> </a>
<a name="ln1031">    case 'm': CASEMBC(0x1e3f) CASEMBC(0x1e41)</a>
<a name="ln1032">      EMIT2('m'); EMITMBC(0x1e3f) EMITMBC(0x1e41)</a>
<a name="ln1033">      return;</a>
<a name="ln1034"> </a>
<a name="ln1035">    case 'n': case n_virguilla: CASEMBC(0x144) CASEMBC(0x146)</a>
<a name="ln1036">              CASEMBC(0x148) CASEMBC(0x149) CASEMBC(0x1e45)</a>
<a name="ln1037">              CASEMBC(0x1e49)</a>
<a name="ln1038">      EMIT2('n'); EMIT2(n_virguilla);</a>
<a name="ln1039">      EMITMBC(0x144) EMITMBC(0x146)</a>
<a name="ln1040">      EMITMBC(0x148) EMITMBC(0x149) EMITMBC(0x1e45)</a>
<a name="ln1041">      EMITMBC(0x1e49)</a>
<a name="ln1042">      return;</a>
<a name="ln1043"> </a>
<a name="ln1044">    case 'o': case o_grave: case o_acute: case o_circumflex:</a>
<a name="ln1045">              case o_virguilla: case o_diaeresis: case o_slash:</a>
<a name="ln1046">              CASEMBC(0x14d) CASEMBC(0x14f) CASEMBC(0x151)</a>
<a name="ln1047">              CASEMBC(0x1a1) CASEMBC(0x1d2) CASEMBC(0x1eb)</a>
<a name="ln1048">              CASEMBC(0x1ed) CASEMBC(0x1ecf)</a>
<a name="ln1049">      EMIT2('o'); EMIT2(o_grave); EMIT2(o_acute);</a>
<a name="ln1050">      EMIT2(o_circumflex); EMIT2(o_virguilla);</a>
<a name="ln1051">      EMIT2(o_diaeresis); EMIT2(o_slash);</a>
<a name="ln1052">      EMITMBC(0x14d) EMITMBC(0x14f) EMITMBC(0x151)</a>
<a name="ln1053">      EMITMBC(0x1a1) EMITMBC(0x1d2) EMITMBC(0x1eb)</a>
<a name="ln1054">      EMITMBC(0x1ed) EMITMBC(0x1ecf)</a>
<a name="ln1055">      return;</a>
<a name="ln1056"> </a>
<a name="ln1057">    case 'p': CASEMBC(0x1e55) CASEMBC(0x1e57)</a>
<a name="ln1058">      EMIT2('p'); EMITMBC(0x1e55) EMITMBC(0x1e57)</a>
<a name="ln1059">      return;</a>
<a name="ln1060"> </a>
<a name="ln1061">    case 'r': CASEMBC(0x155) CASEMBC(0x157) CASEMBC(0x159)</a>
<a name="ln1062">              CASEMBC(0x1e59) CASEMBC(0x1e5f)</a>
<a name="ln1063">      EMIT2('r'); EMITMBC(0x155) EMITMBC(0x157) EMITMBC(0x159)</a>
<a name="ln1064">      EMITMBC(0x1e59) EMITMBC(0x1e5f)</a>
<a name="ln1065">      return;</a>
<a name="ln1066"> </a>
<a name="ln1067">    case 's': CASEMBC(0x15b) CASEMBC(0x15d) CASEMBC(0x15f)</a>
<a name="ln1068">              CASEMBC(0x161) CASEMBC(0x1e61)</a>
<a name="ln1069">      EMIT2('s'); EMITMBC(0x15b) EMITMBC(0x15d) EMITMBC(0x15f)</a>
<a name="ln1070">      EMITMBC(0x161) EMITMBC(0x1e61)</a>
<a name="ln1071">      return;</a>
<a name="ln1072"> </a>
<a name="ln1073">    case 't': CASEMBC(0x163) CASEMBC(0x165) CASEMBC(0x167)</a>
<a name="ln1074">              CASEMBC(0x1e6b) CASEMBC(0x1e6f) CASEMBC(0x1e97)</a>
<a name="ln1075">      EMIT2('t'); EMITMBC(0x163) EMITMBC(0x165) EMITMBC(0x167)</a>
<a name="ln1076">      EMITMBC(0x1e6b) EMITMBC(0x1e6f) EMITMBC(0x1e97)</a>
<a name="ln1077">      return;</a>
<a name="ln1078"> </a>
<a name="ln1079">    case 'u': case u_grave: case u_acute: case u_circumflex:</a>
<a name="ln1080">              case u_diaeresis: CASEMBC(0x169) CASEMBC(0x16b)</a>
<a name="ln1081">              CASEMBC(0x16d) CASEMBC(0x16f) CASEMBC(0x171)</a>
<a name="ln1082">              CASEMBC(0x173) CASEMBC(0x1b0) CASEMBC(0x1d4)</a>
<a name="ln1083">              CASEMBC(0x1ee7)</a>
<a name="ln1084">      EMIT2('u'); EMIT2(u_grave); EMIT2(u_acute);</a>
<a name="ln1085">      EMIT2(u_circumflex); EMIT2(u_diaeresis);</a>
<a name="ln1086">      EMITMBC(0x169) EMITMBC(0x16b)</a>
<a name="ln1087">      EMITMBC(0x16d) EMITMBC(0x16f) EMITMBC(0x171)</a>
<a name="ln1088">      EMITMBC(0x173) EMITMBC(0x1b0) EMITMBC(0x1d4)</a>
<a name="ln1089">      EMITMBC(0x1ee7)</a>
<a name="ln1090">      return;</a>
<a name="ln1091"> </a>
<a name="ln1092">    case 'v': CASEMBC(0x1e7d)</a>
<a name="ln1093">      EMIT2('v'); EMITMBC(0x1e7d)</a>
<a name="ln1094">      return;</a>
<a name="ln1095"> </a>
<a name="ln1096">    case 'w': CASEMBC(0x175) CASEMBC(0x1e81) CASEMBC(0x1e83)</a>
<a name="ln1097">              CASEMBC(0x1e85) CASEMBC(0x1e87) CASEMBC(0x1e98)</a>
<a name="ln1098">      EMIT2('w'); EMITMBC(0x175) EMITMBC(0x1e81) EMITMBC(0x1e83)</a>
<a name="ln1099">      EMITMBC(0x1e85) EMITMBC(0x1e87) EMITMBC(0x1e98)</a>
<a name="ln1100">      return;</a>
<a name="ln1101"> </a>
<a name="ln1102">    case 'x': CASEMBC(0x1e8b) CASEMBC(0x1e8d)</a>
<a name="ln1103">      EMIT2('x'); EMITMBC(0x1e8b) EMITMBC(0x1e8d)</a>
<a name="ln1104">      return;</a>
<a name="ln1105"> </a>
<a name="ln1106">    case 'y': case y_acute: case y_diaeresis: CASEMBC(0x177)</a>
<a name="ln1107">              CASEMBC(0x1e8f) CASEMBC(0x1e99) CASEMBC(0x1ef3)</a>
<a name="ln1108">              CASEMBC(0x1ef7) CASEMBC(0x1ef9)</a>
<a name="ln1109">      EMIT2('y'); EMIT2(y_acute); EMIT2(y_diaeresis);</a>
<a name="ln1110">      EMITMBC(0x177)</a>
<a name="ln1111">      EMITMBC(0x1e8f) EMITMBC(0x1e99) EMITMBC(0x1ef3)</a>
<a name="ln1112">      EMITMBC(0x1ef7) EMITMBC(0x1ef9)</a>
<a name="ln1113">      return;</a>
<a name="ln1114"> </a>
<a name="ln1115">    case 'z': CASEMBC(0x17a) CASEMBC(0x17c) CASEMBC(0x17e)</a>
<a name="ln1116">              CASEMBC(0x1b6) CASEMBC(0x1e91) CASEMBC(0x1e95)</a>
<a name="ln1117">      EMIT2('z'); EMITMBC(0x17a) EMITMBC(0x17c) EMITMBC(0x17e)</a>
<a name="ln1118">      EMITMBC(0x1b6) EMITMBC(0x1e91) EMITMBC(0x1e95)</a>
<a name="ln1119">      return;</a>
<a name="ln1120"> </a>
<a name="ln1121">      /* default: character itself */</a>
<a name="ln1122">    }</a>
<a name="ln1123">  }</a>
<a name="ln1124"> </a>
<a name="ln1125">  EMIT2(c);</a>
<a name="ln1126">#undef EMIT2</a>
<a name="ln1127">#undef EMITMBC</a>
<a name="ln1128">}</a>
<a name="ln1129"> </a>
<a name="ln1130">/*</a>
<a name="ln1131"> * Code to parse regular expression.</a>
<a name="ln1132"> *</a>
<a name="ln1133"> * We try to reuse parsing functions in regexp.c to</a>
<a name="ln1134"> * minimize surprise and keep the syntax consistent.</a>
<a name="ln1135"> */</a>
<a name="ln1136"> </a>
<a name="ln1137">/*</a>
<a name="ln1138"> * Parse the lowest level.</a>
<a name="ln1139"> *</a>
<a name="ln1140"> * An atom can be one of a long list of items.  Many atoms match one character</a>
<a name="ln1141"> * in the text.  It is often an ordinary character or a character class.</a>
<a name="ln1142"> * Braces can be used to make a pattern into an atom.  The &quot;\z(\)&quot; construct</a>
<a name="ln1143"> * is only for syntax highlighting.</a>
<a name="ln1144"> *</a>
<a name="ln1145"> * atom    ::=     ordinary-atom</a>
<a name="ln1146"> *     or  \( pattern \)</a>
<a name="ln1147"> *     or  \%( pattern \)</a>
<a name="ln1148"> *     or  \z( pattern \)</a>
<a name="ln1149"> */</a>
<a name="ln1150">static int nfa_regatom(void)</a>
<a name="ln1151">{</a>
<a name="ln1152">  int c;</a>
<a name="ln1153">  int charclass;</a>
<a name="ln1154">  int equiclass;</a>
<a name="ln1155">  int collclass;</a>
<a name="ln1156">  int got_coll_char;</a>
<a name="ln1157">  char_u      *p;</a>
<a name="ln1158">  char_u      *endp;</a>
<a name="ln1159">  char_u      *old_regparse = regparse;</a>
<a name="ln1160">  int extra = 0;</a>
<a name="ln1161">  int emit_range;</a>
<a name="ln1162">  int negated;</a>
<a name="ln1163">  int startc = -1;</a>
<a name="ln1164">  int endc = -1;</a>
<a name="ln1165">  int oldstartc = -1;</a>
<a name="ln1166">  int save_prev_at_start = prev_at_start;</a>
<a name="ln1167"> </a>
<a name="ln1168">  c = getchr();</a>
<a name="ln1169">  switch (c) {</a>
<a name="ln1170">  case NUL:</a>
<a name="ln1171">    EMSG_RET_FAIL(_(e_nul_found));</a>
<a name="ln1172"> </a>
<a name="ln1173">  case Magic('^'):</a>
<a name="ln1174">    EMIT(NFA_BOL);</a>
<a name="ln1175">    break;</a>
<a name="ln1176"> </a>
<a name="ln1177">  case Magic('$'):</a>
<a name="ln1178">    EMIT(NFA_EOL);</a>
<a name="ln1179">    had_eol = true;</a>
<a name="ln1180">    break;</a>
<a name="ln1181"> </a>
<a name="ln1182">  case Magic('&lt;'):</a>
<a name="ln1183">    EMIT(NFA_BOW);</a>
<a name="ln1184">    break;</a>
<a name="ln1185"> </a>
<a name="ln1186">  case Magic('&gt;'):</a>
<a name="ln1187">    EMIT(NFA_EOW);</a>
<a name="ln1188">    break;</a>
<a name="ln1189"> </a>
<a name="ln1190">  case Magic('_'):</a>
<a name="ln1191">    c = no_Magic(getchr());</a>
<a name="ln1192">    if (c == NUL)</a>
<a name="ln1193">      EMSG_RET_FAIL(_(e_nul_found));</a>
<a name="ln1194"> </a>
<a name="ln1195">    if (c == '^') {             /* &quot;\_^&quot; is start-of-line */</a>
<a name="ln1196">      EMIT(NFA_BOL);</a>
<a name="ln1197">      break;</a>
<a name="ln1198">    }</a>
<a name="ln1199">    if (c == '$') {             /* &quot;\_$&quot; is end-of-line */</a>
<a name="ln1200">      EMIT(NFA_EOL);</a>
<a name="ln1201">      had_eol = true;</a>
<a name="ln1202">      break;</a>
<a name="ln1203">    }</a>
<a name="ln1204"> </a>
<a name="ln1205">    extra = NFA_ADD_NL;</a>
<a name="ln1206"> </a>
<a name="ln1207">    /* &quot;\_[&quot; is collection plus newline */</a>
<a name="ln1208">    if (c == '[')</a>
<a name="ln1209">      goto collection;</a>
<a name="ln1210"> </a>
<a name="ln1211">  // &quot;\_x&quot; is character class plus newline</a>
<a name="ln1212">  FALLTHROUGH;</a>
<a name="ln1213"> </a>
<a name="ln1214">  /*</a>
<a name="ln1215">   * Character classes.</a>
<a name="ln1216">   */</a>
<a name="ln1217">  case Magic('.'):</a>
<a name="ln1218">  case Magic('i'):</a>
<a name="ln1219">  case Magic('I'):</a>
<a name="ln1220">  case Magic('k'):</a>
<a name="ln1221">  case Magic('K'):</a>
<a name="ln1222">  case Magic('f'):</a>
<a name="ln1223">  case Magic('F'):</a>
<a name="ln1224">  case Magic('p'):</a>
<a name="ln1225">  case Magic('P'):</a>
<a name="ln1226">  case Magic('s'):</a>
<a name="ln1227">  case Magic('S'):</a>
<a name="ln1228">  case Magic('d'):</a>
<a name="ln1229">  case Magic('D'):</a>
<a name="ln1230">  case Magic('x'):</a>
<a name="ln1231">  case Magic('X'):</a>
<a name="ln1232">  case Magic('o'):</a>
<a name="ln1233">  case Magic('O'):</a>
<a name="ln1234">  case Magic('w'):</a>
<a name="ln1235">  case Magic('W'):</a>
<a name="ln1236">  case Magic('h'):</a>
<a name="ln1237">  case Magic('H'):</a>
<a name="ln1238">  case Magic('a'):</a>
<a name="ln1239">  case Magic('A'):</a>
<a name="ln1240">  case Magic('l'):</a>
<a name="ln1241">  case Magic('L'):</a>
<a name="ln1242">  case Magic('u'):</a>
<a name="ln1243">  case Magic('U'):</a>
<a name="ln1244">    p = vim_strchr(classchars, no_Magic(c));</a>
<a name="ln1245">    if (p == NULL) {</a>
<a name="ln1246">      if (extra == NFA_ADD_NL) {</a>
<a name="ln1247">        EMSGN(_(e_ill_char_class), c);</a>
<a name="ln1248">        rc_did_emsg = true;</a>
<a name="ln1249">        return FAIL;</a>
<a name="ln1250">      }</a>
<a name="ln1251">      IEMSGN(&quot;INTERNAL: Unknown character class char: %&quot; PRId64, c);</a>
<a name="ln1252">      return FAIL;</a>
<a name="ln1253">    }</a>
<a name="ln1254">    // When '.' is followed by a composing char ignore the dot, so that</a>
<a name="ln1255">    // the composing char is matched here.</a>
<a name="ln1256">    if (c == Magic('.') &amp;&amp; utf_iscomposing(peekchr())) {</a>
<a name="ln1257">      old_regparse = regparse;</a>
<a name="ln1258">      c = getchr();</a>
<a name="ln1259">      goto nfa_do_multibyte;</a>
<a name="ln1260">    }</a>
<a name="ln1261">    EMIT(nfa_classcodes[p - classchars]);</a>
<a name="ln1262">    if (extra == NFA_ADD_NL) {</a>
<a name="ln1263">      EMIT(NFA_NEWL);</a>
<a name="ln1264">      EMIT(NFA_OR);</a>
<a name="ln1265">      regflags |= RF_HASNL;</a>
<a name="ln1266">    }</a>
<a name="ln1267">    break;</a>
<a name="ln1268"> </a>
<a name="ln1269">  case Magic('n'):</a>
<a name="ln1270">    if (reg_string) {</a>
<a name="ln1271">      // In a string &quot;\n&quot; matches a newline character.</a>
<a name="ln1272">      EMIT(NL);</a>
<a name="ln1273">    } else {</a>
<a name="ln1274">      // In buffer text &quot;\n&quot; matches the end of a line.</a>
<a name="ln1275">      EMIT(NFA_NEWL);</a>
<a name="ln1276">      regflags |= RF_HASNL;</a>
<a name="ln1277">    }</a>
<a name="ln1278">    break;</a>
<a name="ln1279"> </a>
<a name="ln1280">  case Magic('('):</a>
<a name="ln1281">    if (nfa_reg(REG_PAREN) == FAIL) {</a>
<a name="ln1282">      return FAIL;                  // cascaded error</a>
<a name="ln1283">    }</a>
<a name="ln1284">    break;</a>
<a name="ln1285"> </a>
<a name="ln1286">  case Magic('|'):</a>
<a name="ln1287">  case Magic('&amp;'):</a>
<a name="ln1288">  case Magic(')'):</a>
<a name="ln1289">    EMSGN(_(e_misplaced), no_Magic(c));  // -V1037</a>
<a name="ln1290">    return FAIL;</a>
<a name="ln1291"> </a>
<a name="ln1292">  case Magic('='):</a>
<a name="ln1293">  case Magic('?'):</a>
<a name="ln1294">  case Magic('+'):</a>
<a name="ln1295">  case Magic('@'):</a>
<a name="ln1296">  case Magic('*'):</a>
<a name="ln1297">  case Magic('{'):</a>
<a name="ln1298">    // these should follow an atom, not form an atom</a>
<a name="ln1299">    EMSGN(_(e_misplaced), no_Magic(c));</a>
<a name="ln1300">    return FAIL;</a>
<a name="ln1301"> </a>
<a name="ln1302">  case Magic('~'):</a>
<a name="ln1303">  {</a>
<a name="ln1304">    char_u      *lp;</a>
<a name="ln1305"> </a>
<a name="ln1306">    // Previous substitute pattern.</a>
<a name="ln1307">    // Generated as &quot;\%(pattern\)&quot;.</a>
<a name="ln1308">    if (reg_prev_sub == NULL) {</a>
<a name="ln1309">      EMSG(_(e_nopresub));</a>
<a name="ln1310">      return FAIL;</a>
<a name="ln1311">    }</a>
<a name="ln1312">    for (lp = reg_prev_sub; *lp != NUL; MB_CPTR_ADV(lp)) {</a>
<a name="ln1313">      EMIT(PTR2CHAR(lp));</a>
<a name="ln1314">      if (lp != reg_prev_sub)</a>
<a name="ln1315">        EMIT(NFA_CONCAT);</a>
<a name="ln1316">    }</a>
<a name="ln1317">    EMIT(NFA_NOPEN);</a>
<a name="ln1318">    break;</a>
<a name="ln1319">  }</a>
<a name="ln1320"> </a>
<a name="ln1321">  case Magic('1'):</a>
<a name="ln1322">  case Magic('2'):</a>
<a name="ln1323">  case Magic('3'):</a>
<a name="ln1324">  case Magic('4'):</a>
<a name="ln1325">  case Magic('5'):</a>
<a name="ln1326">  case Magic('6'):</a>
<a name="ln1327">  case Magic('7'):</a>
<a name="ln1328">  case Magic('8'):</a>
<a name="ln1329">  case Magic('9'):</a>
<a name="ln1330">    {</a>
<a name="ln1331">      int refnum = no_Magic(c) - '1';</a>
<a name="ln1332"> </a>
<a name="ln1333">      if (!seen_endbrace(refnum + 1)) {</a>
<a name="ln1334">          return FAIL;</a>
<a name="ln1335">      }</a>
<a name="ln1336">      EMIT(NFA_BACKREF1 + refnum);</a>
<a name="ln1337">      rex.nfa_has_backref = true;</a>
<a name="ln1338">    }</a>
<a name="ln1339">    break;</a>
<a name="ln1340"> </a>
<a name="ln1341">  case Magic('z'):</a>
<a name="ln1342">    c = no_Magic(getchr());</a>
<a name="ln1343">    switch (c) {</a>
<a name="ln1344">    case 's':</a>
<a name="ln1345">      EMIT(NFA_ZSTART);</a>
<a name="ln1346">      if (!re_mult_next(&quot;\\zs&quot;)) {</a>
<a name="ln1347">        return false;</a>
<a name="ln1348">      }</a>
<a name="ln1349">      break;</a>
<a name="ln1350">    case 'e':</a>
<a name="ln1351">      EMIT(NFA_ZEND);</a>
<a name="ln1352">      rex.nfa_has_zend = true;</a>
<a name="ln1353">      if (!re_mult_next(&quot;\\zs&quot;)) {</a>
<a name="ln1354">        return false;</a>
<a name="ln1355">      }</a>
<a name="ln1356">      break;</a>
<a name="ln1357">    case '1':</a>
<a name="ln1358">    case '2':</a>
<a name="ln1359">    case '3':</a>
<a name="ln1360">    case '4':</a>
<a name="ln1361">    case '5':</a>
<a name="ln1362">    case '6':</a>
<a name="ln1363">    case '7':</a>
<a name="ln1364">    case '8':</a>
<a name="ln1365">    case '9':</a>
<a name="ln1366">      // \z1...\z9</a>
<a name="ln1367">      if ((reg_do_extmatch &amp; REX_USE) == 0) {</a>
<a name="ln1368">        EMSG_RET_FAIL(_(e_z1_not_allowed));</a>
<a name="ln1369">      }</a>
<a name="ln1370">      EMIT(NFA_ZREF1 + (no_Magic(c) - '1'));</a>
<a name="ln1371">      // No need to set rex.nfa_has_backref, the sub-matches don't</a>
<a name="ln1372">      // change when \z1 .. \z9 matches or not.</a>
<a name="ln1373">      re_has_z = REX_USE;</a>
<a name="ln1374">      break;</a>
<a name="ln1375">    case '(':</a>
<a name="ln1376">      // \z(</a>
<a name="ln1377">      if (reg_do_extmatch != REX_SET) {</a>
<a name="ln1378">        EMSG_RET_FAIL(_(e_z_not_allowed));</a>
<a name="ln1379">      }</a>
<a name="ln1380">      if (nfa_reg(REG_ZPAREN) == FAIL) {</a>
<a name="ln1381">        return FAIL;                        // cascaded error</a>
<a name="ln1382">      }</a>
<a name="ln1383">      re_has_z = REX_SET;</a>
<a name="ln1384">      break;</a>
<a name="ln1385">    default:</a>
<a name="ln1386">      emsgf(_(&quot;E867: (NFA) Unknown operator '\\z%c'&quot;),</a>
<a name="ln1387">            no_Magic(c));</a>
<a name="ln1388">      return FAIL;</a>
<a name="ln1389">    }</a>
<a name="ln1390">    break;</a>
<a name="ln1391"> </a>
<a name="ln1392">  case Magic('%'):</a>
<a name="ln1393">    c = no_Magic(getchr());</a>
<a name="ln1394">    switch (c) {</a>
<a name="ln1395">    /* () without a back reference */</a>
<a name="ln1396">    case '(':</a>
<a name="ln1397">      if (nfa_reg(REG_NPAREN) == FAIL)</a>
<a name="ln1398">        return FAIL;</a>
<a name="ln1399">      EMIT(NFA_NOPEN);</a>
<a name="ln1400">      break;</a>
<a name="ln1401"> </a>
<a name="ln1402">    case 'd':               /* %d123 decimal */</a>
<a name="ln1403">    case 'o':               /* %o123 octal */</a>
<a name="ln1404">    case 'x':               /* %xab hex 2 */</a>
<a name="ln1405">    case 'u':               /* %uabcd hex 4 */</a>
<a name="ln1406">    case 'U':               /* %U1234abcd hex 8 */</a>
<a name="ln1407">    {</a>
<a name="ln1408">      int64_t nr;</a>
<a name="ln1409"> </a>
<a name="ln1410">      switch (c) {</a>
<a name="ln1411">      case 'd': nr = getdecchrs(); break;</a>
<a name="ln1412">      case 'o': nr = getoctchrs(); break;</a>
<a name="ln1413">      case 'x': nr = gethexchrs(2); break;</a>
<a name="ln1414">      case 'u': nr = gethexchrs(4); break;</a>
<a name="ln1415">      case 'U': nr = gethexchrs(8); break;</a>
<a name="ln1416">      default:  nr = -1; break;</a>
<a name="ln1417">      }</a>
<a name="ln1418"> </a>
<a name="ln1419">      if (nr &lt; 0 || nr &gt; INT_MAX) {</a>
<a name="ln1420">        EMSG2_RET_FAIL(_(&quot;E678: Invalid character after %s%%[dxouU]&quot;),</a>
<a name="ln1421">                       reg_magic == MAGIC_ALL);</a>
<a name="ln1422">      }</a>
<a name="ln1423">      // A NUL is stored in the text as NL</a>
<a name="ln1424">      // TODO(vim): what if a composing character follows?</a>
<a name="ln1425">      EMIT(nr == 0 ? 0x0a : nr);</a>
<a name="ln1426">    }</a>
<a name="ln1427">    break;</a>
<a name="ln1428"> </a>
<a name="ln1429">    /* Catch \%^ and \%$ regardless of where they appear in the</a>
<a name="ln1430">     * pattern -- regardless of whether or not it makes sense. */</a>
<a name="ln1431">    case '^':</a>
<a name="ln1432">      EMIT(NFA_BOF);</a>
<a name="ln1433">      break;</a>
<a name="ln1434"> </a>
<a name="ln1435">    case '$':</a>
<a name="ln1436">      EMIT(NFA_EOF);</a>
<a name="ln1437">      break;</a>
<a name="ln1438"> </a>
<a name="ln1439">    case '#':</a>
<a name="ln1440">      EMIT(NFA_CURSOR);</a>
<a name="ln1441">      break;</a>
<a name="ln1442"> </a>
<a name="ln1443">    case 'V':</a>
<a name="ln1444">      EMIT(NFA_VISUAL);</a>
<a name="ln1445">      break;</a>
<a name="ln1446"> </a>
<a name="ln1447">    case 'C':</a>
<a name="ln1448">      EMIT(NFA_ANY_COMPOSING);</a>
<a name="ln1449">      break;</a>
<a name="ln1450"> </a>
<a name="ln1451">    case '[':</a>
<a name="ln1452">    {</a>
<a name="ln1453">      int n;</a>
<a name="ln1454"> </a>
<a name="ln1455">      /* \%[abc] */</a>
<a name="ln1456">      for (n = 0; (c = peekchr()) != ']'; ++n) {</a>
<a name="ln1457">        if (c == NUL)</a>
<a name="ln1458">          EMSG2_RET_FAIL(_(e_missing_sb),</a>
<a name="ln1459">              reg_magic == MAGIC_ALL);</a>
<a name="ln1460">        /* recursive call! */</a>
<a name="ln1461">        if (nfa_regatom() == FAIL)</a>
<a name="ln1462">          return FAIL;</a>
<a name="ln1463">      }</a>
<a name="ln1464">      (void)getchr();  // get the ]</a>
<a name="ln1465">      if (n == 0) {</a>
<a name="ln1466">        EMSG2_RET_FAIL(_(e_empty_sb), reg_magic == MAGIC_ALL);</a>
<a name="ln1467">      }</a>
<a name="ln1468">      EMIT(NFA_OPT_CHARS);</a>
<a name="ln1469">      EMIT(n);</a>
<a name="ln1470"> </a>
<a name="ln1471">      /* Emit as &quot;\%(\%[abc]\)&quot; to be able to handle</a>
<a name="ln1472">       * &quot;\%[abc]*&quot; which would cause the empty string to be</a>
<a name="ln1473">       * matched an unlimited number of times. NFA_NOPEN is</a>
<a name="ln1474">       * added only once at a position, while NFA_SPLIT is</a>
<a name="ln1475">       * added multiple times.  This is more efficient than</a>
<a name="ln1476">       * not allowing NFA_SPLIT multiple times, it is used</a>
<a name="ln1477">       * a lot. */</a>
<a name="ln1478">      EMIT(NFA_NOPEN);</a>
<a name="ln1479">      break;</a>
<a name="ln1480">    }</a>
<a name="ln1481"> </a>
<a name="ln1482">    default:</a>
<a name="ln1483">    {</a>
<a name="ln1484">      int64_t n = 0;</a>
<a name="ln1485">      const int cmp = c;</a>
<a name="ln1486"> </a>
<a name="ln1487">      if (c == '&lt;' || c == '&gt;')</a>
<a name="ln1488">        c = getchr();</a>
<a name="ln1489">      while (ascii_isdigit(c)) {</a>
<a name="ln1490">        if (n &gt; (INT32_MAX - (c - '0')) / 10) {</a>
<a name="ln1491">          // overflow.</a>
<a name="ln1492">          EMSG(_(e_value_too_large));</a>
<a name="ln1493">          return FAIL;</a>
<a name="ln1494">        }</a>
<a name="ln1495">        n = n * 10 + (c - '0');</a>
<a name="ln1496">        c = getchr();</a>
<a name="ln1497">      }</a>
<a name="ln1498">      if (c == 'l' || c == 'c' || c == 'v') {</a>
<a name="ln1499">        int32_t limit = INT32_MAX;</a>
<a name="ln1500"> </a>
<a name="ln1501">        if (c == 'l') {</a>
<a name="ln1502">          // \%{n}l  \%{n}&lt;l  \%{n}&gt;l</a>
<a name="ln1503">          EMIT(cmp == '&lt;' ? NFA_LNUM_LT :</a>
<a name="ln1504">               cmp == '&gt;' ? NFA_LNUM_GT : NFA_LNUM);</a>
<a name="ln1505">          if (save_prev_at_start) {</a>
<a name="ln1506">            at_start = true;</a>
<a name="ln1507">          }</a>
<a name="ln1508">        } else if (c == 'c') {</a>
<a name="ln1509">          // \%{n}c  \%{n}&lt;c  \%{n}&gt;c</a>
<a name="ln1510">          EMIT(cmp == '&lt;' ? NFA_COL_LT :</a>
<a name="ln1511">               cmp == '&gt;' ? NFA_COL_GT : NFA_COL);</a>
<a name="ln1512">        } else {</a>
<a name="ln1513">          // \%{n}v  \%{n}&lt;v  \%{n}&gt;v</a>
<a name="ln1514">          EMIT(cmp == '&lt;' ? NFA_VCOL_LT :</a>
<a name="ln1515">               cmp == '&gt;' ? NFA_VCOL_GT : NFA_VCOL);</a>
<a name="ln1516">          limit = INT32_MAX / MB_MAXBYTES;</a>
<a name="ln1517">        }</a>
<a name="ln1518">        if (n &gt;= limit) {</a>
<a name="ln1519">          EMSG(_(e_value_too_large));</a>
<a name="ln1520">          return FAIL;</a>
<a name="ln1521">        }</a>
<a name="ln1522">        EMIT((int)n);</a>
<a name="ln1523">        break;</a>
<a name="ln1524">      } else if (c == '\'' &amp;&amp; n == 0) {</a>
<a name="ln1525">        /* \%'m  \%&lt;'m  \%&gt;'m  */</a>
<a name="ln1526">        EMIT(cmp == '&lt;' ? NFA_MARK_LT :</a>
<a name="ln1527">            cmp == '&gt;' ? NFA_MARK_GT : NFA_MARK);</a>
<a name="ln1528">        EMIT(getchr());</a>
<a name="ln1529">        break;</a>
<a name="ln1530">      }</a>
<a name="ln1531">    }</a>
<a name="ln1532">      emsgf(_(&quot;E867: (NFA) Unknown operator '\\%%%c'&quot;),</a>
<a name="ln1533">            no_Magic(c));</a>
<a name="ln1534">      return FAIL;</a>
<a name="ln1535">    }</a>
<a name="ln1536">    break;</a>
<a name="ln1537"> </a>
<a name="ln1538">  case Magic('['):</a>
<a name="ln1539">collection:</a>
<a name="ln1540">    /*</a>
<a name="ln1541">     * [abc]  uses NFA_START_COLL - NFA_END_COLL</a>
<a name="ln1542">     * [^abc] uses NFA_START_NEG_COLL - NFA_END_NEG_COLL</a>
<a name="ln1543">     * Each character is produced as a regular state, using</a>
<a name="ln1544">     * NFA_CONCAT to bind them together.</a>
<a name="ln1545">     * Besides normal characters there can be:</a>
<a name="ln1546">     * - character classes  NFA_CLASS_*</a>
<a name="ln1547">     * - ranges, two characters followed by NFA_RANGE.</a>
<a name="ln1548">     */</a>
<a name="ln1549"> </a>
<a name="ln1550">    p = regparse;</a>
<a name="ln1551">    endp = skip_anyof(p);</a>
<a name="ln1552">    if (*endp == ']') {</a>
<a name="ln1553">      /*</a>
<a name="ln1554">       * Try to reverse engineer character classes. For example,</a>
<a name="ln1555">       * recognize that [0-9] stands for \d and [A-Za-z_] for \h,</a>
<a name="ln1556">       * and perform the necessary substitutions in the NFA.</a>
<a name="ln1557">       */</a>
<a name="ln1558">      int result = nfa_recognize_char_class(regparse, endp,</a>
<a name="ln1559">                                            extra == NFA_ADD_NL);</a>
<a name="ln1560">      if (result != FAIL) {</a>
<a name="ln1561">        if (result &gt;= NFA_FIRST_NL &amp;&amp; result &lt;= NFA_LAST_NL) {</a>
<a name="ln1562">          EMIT(result - NFA_ADD_NL);</a>
<a name="ln1563">          EMIT(NFA_NEWL);</a>
<a name="ln1564">          EMIT(NFA_OR);</a>
<a name="ln1565">        } else</a>
<a name="ln1566">          EMIT(result);</a>
<a name="ln1567">        regparse = endp;</a>
<a name="ln1568">        MB_PTR_ADV(regparse);</a>
<a name="ln1569">        return OK;</a>
<a name="ln1570">      }</a>
<a name="ln1571">      /*</a>
<a name="ln1572">       * Failed to recognize a character class. Use the simple</a>
<a name="ln1573">       * version that turns [abc] into 'a' OR 'b' OR 'c'</a>
<a name="ln1574">       */</a>
<a name="ln1575">      startc = endc = oldstartc = -1;</a>
<a name="ln1576">      negated = false;</a>
<a name="ln1577">      if (*regparse == '^') {                           // negated range</a>
<a name="ln1578">        negated = true;</a>
<a name="ln1579">        MB_PTR_ADV(regparse);</a>
<a name="ln1580">        EMIT(NFA_START_NEG_COLL);</a>
<a name="ln1581">      } else</a>
<a name="ln1582">        EMIT(NFA_START_COLL);</a>
<a name="ln1583">      if (*regparse == '-') {</a>
<a name="ln1584">        startc = '-';</a>
<a name="ln1585">        EMIT(startc);</a>
<a name="ln1586">        EMIT(NFA_CONCAT);</a>
<a name="ln1587">        MB_PTR_ADV(regparse);</a>
<a name="ln1588">      }</a>
<a name="ln1589">      // Emit the OR branches for each character in the []</a>
<a name="ln1590">      emit_range = false;</a>
<a name="ln1591">      while (regparse &lt; endp) {</a>
<a name="ln1592">        oldstartc = startc;</a>
<a name="ln1593">        startc = -1;</a>
<a name="ln1594">        got_coll_char = false;</a>
<a name="ln1595">        if (*regparse == '[') {</a>
<a name="ln1596">          /* Check for [: :], [= =], [. .] */</a>
<a name="ln1597">          equiclass = collclass = 0;</a>
<a name="ln1598">          charclass = get_char_class(&amp;regparse);</a>
<a name="ln1599">          if (charclass == CLASS_NONE) {</a>
<a name="ln1600">            equiclass = get_equi_class(&amp;regparse);</a>
<a name="ln1601">            if (equiclass == 0)</a>
<a name="ln1602">              collclass = get_coll_element(&amp;regparse);</a>
<a name="ln1603">          }</a>
<a name="ln1604"> </a>
<a name="ln1605">          /* Character class like [:alpha:]  */</a>
<a name="ln1606">          if (charclass != CLASS_NONE) {</a>
<a name="ln1607">            switch (charclass) {</a>
<a name="ln1608">            case CLASS_ALNUM:</a>
<a name="ln1609">              EMIT(NFA_CLASS_ALNUM);</a>
<a name="ln1610">              break;</a>
<a name="ln1611">            case CLASS_ALPHA:</a>
<a name="ln1612">              EMIT(NFA_CLASS_ALPHA);</a>
<a name="ln1613">              break;</a>
<a name="ln1614">            case CLASS_BLANK:</a>
<a name="ln1615">              EMIT(NFA_CLASS_BLANK);</a>
<a name="ln1616">              break;</a>
<a name="ln1617">            case CLASS_CNTRL:</a>
<a name="ln1618">              EMIT(NFA_CLASS_CNTRL);</a>
<a name="ln1619">              break;</a>
<a name="ln1620">            case CLASS_DIGIT:</a>
<a name="ln1621">              EMIT(NFA_CLASS_DIGIT);</a>
<a name="ln1622">              break;</a>
<a name="ln1623">            case CLASS_GRAPH:</a>
<a name="ln1624">              EMIT(NFA_CLASS_GRAPH);</a>
<a name="ln1625">              break;</a>
<a name="ln1626">            case CLASS_LOWER:</a>
<a name="ln1627">              wants_nfa = true;</a>
<a name="ln1628">              EMIT(NFA_CLASS_LOWER);</a>
<a name="ln1629">              break;</a>
<a name="ln1630">            case CLASS_PRINT:</a>
<a name="ln1631">              EMIT(NFA_CLASS_PRINT);</a>
<a name="ln1632">              break;</a>
<a name="ln1633">            case CLASS_PUNCT:</a>
<a name="ln1634">              EMIT(NFA_CLASS_PUNCT);</a>
<a name="ln1635">              break;</a>
<a name="ln1636">            case CLASS_SPACE:</a>
<a name="ln1637">              EMIT(NFA_CLASS_SPACE);</a>
<a name="ln1638">              break;</a>
<a name="ln1639">            case CLASS_UPPER:</a>
<a name="ln1640">              wants_nfa = true;</a>
<a name="ln1641">              EMIT(NFA_CLASS_UPPER);</a>
<a name="ln1642">              break;</a>
<a name="ln1643">            case CLASS_XDIGIT:</a>
<a name="ln1644">              EMIT(NFA_CLASS_XDIGIT);</a>
<a name="ln1645">              break;</a>
<a name="ln1646">            case CLASS_TAB:</a>
<a name="ln1647">              EMIT(NFA_CLASS_TAB);</a>
<a name="ln1648">              break;</a>
<a name="ln1649">            case CLASS_RETURN:</a>
<a name="ln1650">              EMIT(NFA_CLASS_RETURN);</a>
<a name="ln1651">              break;</a>
<a name="ln1652">            case CLASS_BACKSPACE:</a>
<a name="ln1653">              EMIT(NFA_CLASS_BACKSPACE);</a>
<a name="ln1654">              break;</a>
<a name="ln1655">            case CLASS_ESCAPE:</a>
<a name="ln1656">              EMIT(NFA_CLASS_ESCAPE);</a>
<a name="ln1657">              break;</a>
<a name="ln1658">            case CLASS_IDENT:</a>
<a name="ln1659">              EMIT(NFA_CLASS_IDENT);</a>
<a name="ln1660">              break;</a>
<a name="ln1661">            case CLASS_KEYWORD:</a>
<a name="ln1662">              EMIT(NFA_CLASS_KEYWORD);</a>
<a name="ln1663">              break;</a>
<a name="ln1664">            case CLASS_FNAME:</a>
<a name="ln1665">              EMIT(NFA_CLASS_FNAME);</a>
<a name="ln1666">              break;</a>
<a name="ln1667">            }</a>
<a name="ln1668">            EMIT(NFA_CONCAT);</a>
<a name="ln1669">            continue;</a>
<a name="ln1670">          }</a>
<a name="ln1671">          /* Try equivalence class [=a=] and the like */</a>
<a name="ln1672">          if (equiclass != 0) {</a>
<a name="ln1673">            nfa_emit_equi_class(equiclass);</a>
<a name="ln1674">            continue;</a>
<a name="ln1675">          }</a>
<a name="ln1676">          /* Try collating class like [. .]  */</a>
<a name="ln1677">          if (collclass != 0) {</a>
<a name="ln1678">            startc = collclass;                  /* allow [.a.]-x as a range */</a>
<a name="ln1679">            /* Will emit the proper atom at the end of the</a>
<a name="ln1680">             * while loop. */</a>
<a name="ln1681">          }</a>
<a name="ln1682">        }</a>
<a name="ln1683">        /* Try a range like 'a-x' or '\t-z'. Also allows '-' as a</a>
<a name="ln1684">         * start character. */</a>
<a name="ln1685">        if (*regparse == '-' &amp;&amp; oldstartc != -1) {</a>
<a name="ln1686">          emit_range = true;</a>
<a name="ln1687">          startc = oldstartc;</a>
<a name="ln1688">          MB_PTR_ADV(regparse);</a>
<a name="ln1689">          continue;                         // reading the end of the range</a>
<a name="ln1690">        }</a>
<a name="ln1691"> </a>
<a name="ln1692">        /* Now handle simple and escaped characters.</a>
<a name="ln1693">         * Only &quot;\]&quot;, &quot;\^&quot;, &quot;\]&quot; and &quot;\\&quot; are special in Vi.  Vim</a>
<a name="ln1694">         * accepts &quot;\t&quot;, &quot;\e&quot;, etc., but only when the 'l' flag in</a>
<a name="ln1695">         * 'cpoptions' is not included.</a>
<a name="ln1696">         */</a>
<a name="ln1697">        if (*regparse == '\\'</a>
<a name="ln1698">            &amp;&amp; regparse + 1 &lt;= endp</a>
<a name="ln1699">            &amp;&amp; (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL</a>
<a name="ln1700">                || (!reg_cpo_lit</a>
<a name="ln1701">                    &amp;&amp; vim_strchr(REGEXP_ABBR, regparse[1])</a>
<a name="ln1702">                    != NULL)</a>
<a name="ln1703">                )</a>
<a name="ln1704">            ) {</a>
<a name="ln1705">          MB_PTR_ADV(regparse);</a>
<a name="ln1706"> </a>
<a name="ln1707">          if (*regparse == 'n') {</a>
<a name="ln1708">            startc = (reg_string || emit_range || regparse[1] == '-')</a>
<a name="ln1709">              ? NL : NFA_NEWL;</a>
<a name="ln1710">          } else if  (*regparse == 'd'</a>
<a name="ln1711">                      || *regparse == 'o'</a>
<a name="ln1712">                      || *regparse == 'x'</a>
<a name="ln1713">                      || *regparse == 'u'</a>
<a name="ln1714">                      || *regparse == 'U'</a>
<a name="ln1715">                      ) {</a>
<a name="ln1716">            // TODO(RE): This needs more testing</a>
<a name="ln1717">            startc = coll_get_char();</a>
<a name="ln1718">            got_coll_char = true;</a>
<a name="ln1719">            MB_PTR_BACK(old_regparse, regparse);</a>
<a name="ln1720">          } else {</a>
<a name="ln1721">            /* \r,\t,\e,\b */</a>
<a name="ln1722">            startc = backslash_trans(*regparse);</a>
<a name="ln1723">          }</a>
<a name="ln1724">        }</a>
<a name="ln1725"> </a>
<a name="ln1726">        /* Normal printable char */</a>
<a name="ln1727">        if (startc == -1)</a>
<a name="ln1728">          startc = PTR2CHAR(regparse);</a>
<a name="ln1729"> </a>
<a name="ln1730">        /* Previous char was '-', so this char is end of range. */</a>
<a name="ln1731">        if (emit_range) {</a>
<a name="ln1732">          endc = startc;</a>
<a name="ln1733">          startc = oldstartc;</a>
<a name="ln1734">          if (startc &gt; endc) {</a>
<a name="ln1735">            EMSG_RET_FAIL(_(e_reverse_range));</a>
<a name="ln1736">          }</a>
<a name="ln1737"> </a>
<a name="ln1738">          if (endc &gt; startc + 2) {</a>
<a name="ln1739">            /* Emit a range instead of the sequence of</a>
<a name="ln1740">             * individual characters. */</a>
<a name="ln1741">            if (startc == 0)</a>
<a name="ln1742">              /* \x00 is translated to \x0a, start at \x01. */</a>
<a name="ln1743">              EMIT(1);</a>
<a name="ln1744">            else</a>
<a name="ln1745">              --post_ptr;                   /* remove NFA_CONCAT */</a>
<a name="ln1746">            EMIT(endc);</a>
<a name="ln1747">            EMIT(NFA_RANGE);</a>
<a name="ln1748">            EMIT(NFA_CONCAT);</a>
<a name="ln1749">          } else if ((*mb_char2len)(startc) &gt; 1</a>
<a name="ln1750">                     || (*mb_char2len)(endc) &gt; 1) {</a>
<a name="ln1751">            // Emit the characters in the range.</a>
<a name="ln1752">            // &quot;startc&quot; was already emitted, so skip it.</a>
<a name="ln1753">            for (c = startc + 1; c &lt;= endc; c++) {</a>
<a name="ln1754">              EMIT(c);</a>
<a name="ln1755">              EMIT(NFA_CONCAT);</a>
<a name="ln1756">            }</a>
<a name="ln1757">          } else {</a>
<a name="ln1758">            /* Emit the range. &quot;startc&quot; was already emitted, so</a>
<a name="ln1759">             * skip it. */</a>
<a name="ln1760">            for (c = startc + 1; c &lt;= endc; c++) {</a>
<a name="ln1761">              EMIT(c);</a>
<a name="ln1762">              EMIT(NFA_CONCAT);</a>
<a name="ln1763">            }</a>
<a name="ln1764">          }</a>
<a name="ln1765">          emit_range = false;</a>
<a name="ln1766">          startc = -1;</a>
<a name="ln1767">        } else {</a>
<a name="ln1768">          /* This char (startc) is not part of a range. Just</a>
<a name="ln1769">           * emit it.</a>
<a name="ln1770">           * Normally, simply emit startc. But if we get char</a>
<a name="ln1771">           * code=0 from a collating char, then replace it with</a>
<a name="ln1772">           * 0x0a.</a>
<a name="ln1773">           * This is needed to completely mimic the behaviour of</a>
<a name="ln1774">           * the backtracking engine. */</a>
<a name="ln1775">          if (startc == NFA_NEWL) {</a>
<a name="ln1776">            /* Line break can't be matched as part of the</a>
<a name="ln1777">             * collection, add an OR below. But not for negated</a>
<a name="ln1778">             * range. */</a>
<a name="ln1779">            if (!negated)</a>
<a name="ln1780">              extra = NFA_ADD_NL;</a>
<a name="ln1781">          } else {</a>
<a name="ln1782">            if (got_coll_char == true &amp;&amp; startc == 0) {</a>
<a name="ln1783">              EMIT(0x0a);</a>
<a name="ln1784">            } else {</a>
<a name="ln1785">              EMIT(startc);</a>
<a name="ln1786">            }</a>
<a name="ln1787">            EMIT(NFA_CONCAT);</a>
<a name="ln1788">          }</a>
<a name="ln1789">        }</a>
<a name="ln1790"> </a>
<a name="ln1791">        MB_PTR_ADV(regparse);</a>
<a name="ln1792">      }           // while (p &lt; endp)</a>
<a name="ln1793"> </a>
<a name="ln1794">      MB_PTR_BACK(old_regparse, regparse);</a>
<a name="ln1795">      if (*regparse == '-') {               // if last, '-' is just a char</a>
<a name="ln1796">        EMIT('-');</a>
<a name="ln1797">        EMIT(NFA_CONCAT);</a>
<a name="ln1798">      }</a>
<a name="ln1799"> </a>
<a name="ln1800">      /* skip the trailing ] */</a>
<a name="ln1801">      regparse = endp;</a>
<a name="ln1802">      MB_PTR_ADV(regparse);</a>
<a name="ln1803"> </a>
<a name="ln1804">      // Mark end of the collection.</a>
<a name="ln1805">      if (negated == true) {</a>
<a name="ln1806">        EMIT(NFA_END_NEG_COLL);</a>
<a name="ln1807">      } else {</a>
<a name="ln1808">        EMIT(NFA_END_COLL);</a>
<a name="ln1809">      }</a>
<a name="ln1810"> </a>
<a name="ln1811">      // \_[] also matches \n but it's not negated</a>
<a name="ln1812">      if (extra == NFA_ADD_NL) {</a>
<a name="ln1813">        EMIT(reg_string ? NL : NFA_NEWL);</a>
<a name="ln1814">        EMIT(NFA_OR);</a>
<a name="ln1815">      }</a>
<a name="ln1816"> </a>
<a name="ln1817">      return OK;</a>
<a name="ln1818">    }         /* if exists closing ] */</a>
<a name="ln1819"> </a>
<a name="ln1820">    if (reg_strict)</a>
<a name="ln1821">      EMSG_RET_FAIL(_(e_missingbracket));</a>
<a name="ln1822">    FALLTHROUGH;</a>
<a name="ln1823"> </a>
<a name="ln1824">  default:</a>
<a name="ln1825">  {</a>
<a name="ln1826">    int plen;</a>
<a name="ln1827"> </a>
<a name="ln1828">nfa_do_multibyte:</a>
<a name="ln1829">    // plen is length of current char with composing chars</a>
<a name="ln1830">    if ((*mb_char2len)(c) != (plen = utfc_ptr2len(old_regparse))</a>
<a name="ln1831">        || utf_iscomposing(c)) {</a>
<a name="ln1832">      int i = 0;</a>
<a name="ln1833"> </a>
<a name="ln1834">      /* A base character plus composing characters, or just one</a>
<a name="ln1835">       * or more composing characters.</a>
<a name="ln1836">       * This requires creating a separate atom as if enclosing</a>
<a name="ln1837">       * the characters in (), where NFA_COMPOSING is the ( and</a>
<a name="ln1838">       * NFA_END_COMPOSING is the ). Note that right now we are</a>
<a name="ln1839">       * building the postfix form, not the NFA itself;</a>
<a name="ln1840">       * a composing char could be: a, b, c, NFA_COMPOSING</a>
<a name="ln1841">       * where 'b' and 'c' are chars with codes &gt; 256. */</a>
<a name="ln1842">      for (;; ) {</a>
<a name="ln1843">        EMIT(c);</a>
<a name="ln1844">        if (i &gt; 0)</a>
<a name="ln1845">          EMIT(NFA_CONCAT);</a>
<a name="ln1846">        if ((i += utf_char2len(c)) &gt;= plen)</a>
<a name="ln1847">          break;</a>
<a name="ln1848">        c = utf_ptr2char(old_regparse + i);</a>
<a name="ln1849">      }</a>
<a name="ln1850">      EMIT(NFA_COMPOSING);</a>
<a name="ln1851">      regparse = old_regparse + plen;</a>
<a name="ln1852">    } else {</a>
<a name="ln1853">      c = no_Magic(c);</a>
<a name="ln1854">      EMIT(c);</a>
<a name="ln1855">    }</a>
<a name="ln1856">    return OK;</a>
<a name="ln1857">  }</a>
<a name="ln1858">  }</a>
<a name="ln1859"> </a>
<a name="ln1860">  return OK;</a>
<a name="ln1861">}</a>
<a name="ln1862"> </a>
<a name="ln1863">/*</a>
<a name="ln1864"> * Parse something followed by possible [*+=].</a>
<a name="ln1865"> *</a>
<a name="ln1866"> * A piece is an atom, possibly followed by a multi, an indication of how many</a>
<a name="ln1867"> * times the atom can be matched.  Example: &quot;a*&quot; matches any sequence of &quot;a&quot;</a>
<a name="ln1868"> * characters: &quot;&quot;, &quot;a&quot;, &quot;aa&quot;, etc.</a>
<a name="ln1869"> *</a>
<a name="ln1870"> * piece   ::=	    atom</a>
<a name="ln1871"> *	or  atom  multi</a>
<a name="ln1872"> */</a>
<a name="ln1873">static int nfa_regpiece(void)</a>
<a name="ln1874">{</a>
<a name="ln1875">  int i;</a>
<a name="ln1876">  int op;</a>
<a name="ln1877">  int ret;</a>
<a name="ln1878">  long minval, maxval;</a>
<a name="ln1879">  bool greedy = true;  // Braces are prefixed with '-' ?</a>
<a name="ln1880">  parse_state_T old_state;</a>
<a name="ln1881">  parse_state_T new_state;</a>
<a name="ln1882">  int64_t c2;</a>
<a name="ln1883">  int old_post_pos;</a>
<a name="ln1884">  int my_post_start;</a>
<a name="ln1885">  int quest;</a>
<a name="ln1886"> </a>
<a name="ln1887">  /* Save the current parse state, so that we can use it if &lt;atom&gt;{m,n} is</a>
<a name="ln1888">   * next. */</a>
<a name="ln1889">  save_parse_state(&amp;old_state);</a>
<a name="ln1890"> </a>
<a name="ln1891">  /* store current pos in the postfix form, for \{m,n} involving 0s */</a>
<a name="ln1892">  my_post_start = (int)(post_ptr - post_start);</a>
<a name="ln1893"> </a>
<a name="ln1894">  ret = nfa_regatom();</a>
<a name="ln1895">  if (ret == FAIL)</a>
<a name="ln1896">    return FAIL;            /* cascaded error */</a>
<a name="ln1897"> </a>
<a name="ln1898">  op = peekchr();</a>
<a name="ln1899">  if (re_multi_type(op) == NOT_MULTI)</a>
<a name="ln1900">    return OK;</a>
<a name="ln1901"> </a>
<a name="ln1902">  skipchr();</a>
<a name="ln1903">  switch (op) {</a>
<a name="ln1904">  case Magic('*'):</a>
<a name="ln1905">    EMIT(NFA_STAR);</a>
<a name="ln1906">    break;</a>
<a name="ln1907"> </a>
<a name="ln1908">  case Magic('+'):</a>
<a name="ln1909">    /*</a>
<a name="ln1910">     * Trick: Normally, (a*)\+ would match the whole input &quot;aaa&quot;.  The</a>
<a name="ln1911">     * first and only submatch would be &quot;aaa&quot;. But the backtracking</a>
<a name="ln1912">     * engine interprets the plus as &quot;try matching one more time&quot;, and</a>
<a name="ln1913">     * a* matches a second time at the end of the input, the empty</a>
<a name="ln1914">     * string.</a>
<a name="ln1915">     * The submatch will be the empty string.</a>
<a name="ln1916">     *</a>
<a name="ln1917">     * In order to be consistent with the old engine, we replace</a>
<a name="ln1918">     * &lt;atom&gt;+ with &lt;atom&gt;&lt;atom&gt;*</a>
<a name="ln1919">     */</a>
<a name="ln1920">    restore_parse_state(&amp;old_state);</a>
<a name="ln1921">    curchr = -1;</a>
<a name="ln1922">    if (nfa_regatom() == FAIL)</a>
<a name="ln1923">      return FAIL;</a>
<a name="ln1924">    EMIT(NFA_STAR);</a>
<a name="ln1925">    EMIT(NFA_CONCAT);</a>
<a name="ln1926">    skipchr();                  /* skip the \+	*/</a>
<a name="ln1927">    break;</a>
<a name="ln1928"> </a>
<a name="ln1929">  case Magic('@'):</a>
<a name="ln1930">    c2 = getdecchrs();</a>
<a name="ln1931">    op = no_Magic(getchr());</a>
<a name="ln1932">    i = 0;</a>
<a name="ln1933">    switch(op) {</a>
<a name="ln1934">    case '=':</a>
<a name="ln1935">      /* \@= */</a>
<a name="ln1936">      i = NFA_PREV_ATOM_NO_WIDTH;</a>
<a name="ln1937">      break;</a>
<a name="ln1938">    case '!':</a>
<a name="ln1939">      /* \@! */</a>
<a name="ln1940">      i = NFA_PREV_ATOM_NO_WIDTH_NEG;</a>
<a name="ln1941">      break;</a>
<a name="ln1942">    case '&lt;':</a>
<a name="ln1943">      op = no_Magic(getchr());</a>
<a name="ln1944">      if (op == '=')</a>
<a name="ln1945">        /* \@&lt;= */</a>
<a name="ln1946">        i = NFA_PREV_ATOM_JUST_BEFORE;</a>
<a name="ln1947">      else if (op == '!')</a>
<a name="ln1948">        /* \@&lt;! */</a>
<a name="ln1949">        i = NFA_PREV_ATOM_JUST_BEFORE_NEG;</a>
<a name="ln1950">      break;</a>
<a name="ln1951">    case '&gt;':</a>
<a name="ln1952">      /* \@&gt;  */</a>
<a name="ln1953">      i = NFA_PREV_ATOM_LIKE_PATTERN;</a>
<a name="ln1954">      break;</a>
<a name="ln1955">    }</a>
<a name="ln1956">    if (i == 0) {</a>
<a name="ln1957">      emsgf(_(&quot;E869: (NFA) Unknown operator '\\@%c'&quot;), op);</a>
<a name="ln1958">      return FAIL;</a>
<a name="ln1959">    }</a>
<a name="ln1960">    EMIT(i);</a>
<a name="ln1961">    if (i == NFA_PREV_ATOM_JUST_BEFORE</a>
<a name="ln1962">        || i == NFA_PREV_ATOM_JUST_BEFORE_NEG)</a>
<a name="ln1963">      EMIT(c2);</a>
<a name="ln1964">    break;</a>
<a name="ln1965"> </a>
<a name="ln1966">  case Magic('?'):</a>
<a name="ln1967">  case Magic('='):</a>
<a name="ln1968">    EMIT(NFA_QUEST);</a>
<a name="ln1969">    break;</a>
<a name="ln1970"> </a>
<a name="ln1971">  case Magic('{'):</a>
<a name="ln1972">    /* a{2,5} will expand to 'aaa?a?a?'</a>
<a name="ln1973">     * a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy</a>
<a name="ln1974">     * version of '?'</a>
<a name="ln1975">     * \v(ab){2,3} will expand to '(ab)(ab)(ab)?', where all the</a>
<a name="ln1976">     * parenthesis have the same id</a>
<a name="ln1977">     */</a>
<a name="ln1978"> </a>
<a name="ln1979">    greedy = true;</a>
<a name="ln1980">    c2 = peekchr();</a>
<a name="ln1981">    if (c2 == '-' || c2 == Magic('-')) {</a>
<a name="ln1982">      skipchr();</a>
<a name="ln1983">      greedy = false;</a>
<a name="ln1984">    }</a>
<a name="ln1985">    if (!read_limits(&amp;minval, &amp;maxval))</a>
<a name="ln1986">      EMSG_RET_FAIL(_(&quot;E870: (NFA regexp) Error reading repetition limits&quot;));</a>
<a name="ln1987"> </a>
<a name="ln1988">    /*  &lt;atom&gt;{0,inf}, &lt;atom&gt;{0,} and &lt;atom&gt;{}  are equivalent to</a>
<a name="ln1989">     *  &lt;atom&gt;*  */</a>
<a name="ln1990">    if (minval == 0 &amp;&amp; maxval == MAX_LIMIT) {</a>
<a name="ln1991">      if (greedy)</a>
<a name="ln1992">        /* \{}, \{0,} */</a>
<a name="ln1993">        EMIT(NFA_STAR);</a>
<a name="ln1994">      else</a>
<a name="ln1995">        /* \{-}, \{-0,} */</a>
<a name="ln1996">        EMIT(NFA_STAR_NONGREEDY);</a>
<a name="ln1997">      break;</a>
<a name="ln1998">    }</a>
<a name="ln1999"> </a>
<a name="ln2000">    /* Special case: x{0} or x{-0} */</a>
<a name="ln2001">    if (maxval == 0) {</a>
<a name="ln2002">      /* Ignore result of previous call to nfa_regatom() */</a>
<a name="ln2003">      post_ptr = post_start + my_post_start;</a>
<a name="ln2004">      /* NFA_EMPTY is 0-length and works everywhere */</a>
<a name="ln2005">      EMIT(NFA_EMPTY);</a>
<a name="ln2006">      return OK;</a>
<a name="ln2007">    }</a>
<a name="ln2008"> </a>
<a name="ln2009">    // The engine is very inefficient (uses too many states) when the</a>
<a name="ln2010">    // maximum is much larger than the minimum and when the maximum is</a>
<a name="ln2011">    // large.  However, when maxval is MAX_LIMIT, it is okay, as this</a>
<a name="ln2012">    // will emit NFA_STAR.</a>
<a name="ln2013">    // Bail out if we can use the other engine, but only, when the</a>
<a name="ln2014">    // pattern does not need the NFA engine like (e.g. [[:upper:]]\{2,\}</a>
<a name="ln2015">    // does not work with with characters &gt; 8 bit with the BT engine)</a>
<a name="ln2016">    if ((nfa_re_flags &amp; RE_AUTO)</a>
<a name="ln2017">        &amp;&amp; (maxval &gt; 500 || maxval &gt; minval + 200)</a>
<a name="ln2018">        &amp;&amp; (maxval != MAX_LIMIT &amp;&amp; minval &lt; 200)</a>
<a name="ln2019">        &amp;&amp; !wants_nfa) {</a>
<a name="ln2020">      return FAIL;</a>
<a name="ln2021">    }</a>
<a name="ln2022"> </a>
<a name="ln2023">    /* Ignore previous call to nfa_regatom() */</a>
<a name="ln2024">    post_ptr = post_start + my_post_start;</a>
<a name="ln2025">    /* Save parse state after the repeated atom and the \{} */</a>
<a name="ln2026">    save_parse_state(&amp;new_state);</a>
<a name="ln2027"> </a>
<a name="ln2028">    quest = (greedy == true ? NFA_QUEST : NFA_QUEST_NONGREEDY);</a>
<a name="ln2029">    for (i = 0; i &lt; maxval; i++) {</a>
<a name="ln2030">      /* Goto beginning of the repeated atom */</a>
<a name="ln2031">      restore_parse_state(&amp;old_state);</a>
<a name="ln2032">      old_post_pos = (int)(post_ptr - post_start);</a>
<a name="ln2033">      if (nfa_regatom() == FAIL)</a>
<a name="ln2034">        return FAIL;</a>
<a name="ln2035">      /* after &quot;minval&quot; times, atoms are optional */</a>
<a name="ln2036">      if (i + 1 &gt; minval) {</a>
<a name="ln2037">        if (maxval == MAX_LIMIT) {</a>
<a name="ln2038">          if (greedy)</a>
<a name="ln2039">            EMIT(NFA_STAR);</a>
<a name="ln2040">          else</a>
<a name="ln2041">            EMIT(NFA_STAR_NONGREEDY);</a>
<a name="ln2042">        } else</a>
<a name="ln2043">          EMIT(quest);</a>
<a name="ln2044">      }</a>
<a name="ln2045">      if (old_post_pos != my_post_start)</a>
<a name="ln2046">        EMIT(NFA_CONCAT);</a>
<a name="ln2047">      if (i + 1 &gt; minval &amp;&amp; maxval == MAX_LIMIT)</a>
<a name="ln2048">        break;</a>
<a name="ln2049">    }</a>
<a name="ln2050"> </a>
<a name="ln2051">    /* Go to just after the repeated atom and the \{} */</a>
<a name="ln2052">    restore_parse_state(&amp;new_state);</a>
<a name="ln2053">    curchr = -1;</a>
<a name="ln2054"> </a>
<a name="ln2055">    break;</a>
<a name="ln2056"> </a>
<a name="ln2057"> </a>
<a name="ln2058">  default:</a>
<a name="ln2059">    break;</a>
<a name="ln2060">  }     /* end switch */</a>
<a name="ln2061"> </a>
<a name="ln2062">  if (re_multi_type(peekchr()) != NOT_MULTI) {</a>
<a name="ln2063">    // Can't have a multi follow a multi.</a>
<a name="ln2064">    EMSG_RET_FAIL(_(&quot;E871: (NFA regexp) Can't have a multi follow a multi&quot;));</a>
<a name="ln2065">  }</a>
<a name="ln2066"> </a>
<a name="ln2067">  return OK;</a>
<a name="ln2068">}</a>
<a name="ln2069"> </a>
<a name="ln2070">/*</a>
<a name="ln2071"> * Parse one or more pieces, concatenated.  It matches a match for the</a>
<a name="ln2072"> * first piece, followed by a match for the second piece, etc.  Example:</a>
<a name="ln2073"> * &quot;f[0-9]b&quot;, first matches &quot;f&quot;, then a digit and then &quot;b&quot;.</a>
<a name="ln2074"> *</a>
<a name="ln2075"> * concat  ::=	    piece</a>
<a name="ln2076"> *	or  piece piece</a>
<a name="ln2077"> *	or  piece piece piece</a>
<a name="ln2078"> *	etc.</a>
<a name="ln2079"> */</a>
<a name="ln2080">static int nfa_regconcat(void)</a>
<a name="ln2081">{</a>
<a name="ln2082">  bool cont = true;</a>
<a name="ln2083">  bool first = true;</a>
<a name="ln2084"> </a>
<a name="ln2085">  while (cont) {</a>
<a name="ln2086">    switch (peekchr()) {</a>
<a name="ln2087">    case NUL:</a>
<a name="ln2088">    case Magic('|'):</a>
<a name="ln2089">    case Magic('&amp;'):</a>
<a name="ln2090">    case Magic(')'):</a>
<a name="ln2091">      cont = false;</a>
<a name="ln2092">      break;</a>
<a name="ln2093"> </a>
<a name="ln2094">    case Magic('Z'):</a>
<a name="ln2095">      regflags |= RF_ICOMBINE;</a>
<a name="ln2096">      skipchr_keepstart();</a>
<a name="ln2097">      break;</a>
<a name="ln2098">    case Magic('c'):</a>
<a name="ln2099">      regflags |= RF_ICASE;</a>
<a name="ln2100">      skipchr_keepstart();</a>
<a name="ln2101">      break;</a>
<a name="ln2102">    case Magic('C'):</a>
<a name="ln2103">      regflags |= RF_NOICASE;</a>
<a name="ln2104">      skipchr_keepstart();</a>
<a name="ln2105">      break;</a>
<a name="ln2106">    case Magic('v'):</a>
<a name="ln2107">      reg_magic = MAGIC_ALL;</a>
<a name="ln2108">      skipchr_keepstart();</a>
<a name="ln2109">      curchr = -1;</a>
<a name="ln2110">      break;</a>
<a name="ln2111">    case Magic('m'):</a>
<a name="ln2112">      reg_magic = MAGIC_ON;</a>
<a name="ln2113">      skipchr_keepstart();</a>
<a name="ln2114">      curchr = -1;</a>
<a name="ln2115">      break;</a>
<a name="ln2116">    case Magic('M'):</a>
<a name="ln2117">      reg_magic = MAGIC_OFF;</a>
<a name="ln2118">      skipchr_keepstart();</a>
<a name="ln2119">      curchr = -1;</a>
<a name="ln2120">      break;</a>
<a name="ln2121">    case Magic('V'):</a>
<a name="ln2122">      reg_magic = MAGIC_NONE;</a>
<a name="ln2123">      skipchr_keepstart();</a>
<a name="ln2124">      curchr = -1;</a>
<a name="ln2125">      break;</a>
<a name="ln2126"> </a>
<a name="ln2127">    default:</a>
<a name="ln2128">      if (nfa_regpiece() == FAIL) {</a>
<a name="ln2129">        return FAIL;</a>
<a name="ln2130">      }</a>
<a name="ln2131">      if (first == false) {</a>
<a name="ln2132">        EMIT(NFA_CONCAT);</a>
<a name="ln2133">      } else {</a>
<a name="ln2134">        first = false;</a>
<a name="ln2135">      }</a>
<a name="ln2136">      break;</a>
<a name="ln2137">    }</a>
<a name="ln2138">  }</a>
<a name="ln2139"> </a>
<a name="ln2140">  return OK;</a>
<a name="ln2141">}</a>
<a name="ln2142"> </a>
<a name="ln2143">/*</a>
<a name="ln2144"> * Parse a branch, one or more concats, separated by &quot;\&amp;&quot;.  It matches the</a>
<a name="ln2145"> * last concat, but only if all the preceding concats also match at the same</a>
<a name="ln2146"> * position.  Examples:</a>
<a name="ln2147"> *      &quot;foobeep\&amp;...&quot; matches &quot;foo&quot; in &quot;foobeep&quot;.</a>
<a name="ln2148"> *      &quot;.*Peter\&amp;.*Bob&quot; matches in a line containing both &quot;Peter&quot; and &quot;Bob&quot;</a>
<a name="ln2149"> *</a>
<a name="ln2150"> * branch ::=	    concat</a>
<a name="ln2151"> *		or  concat \&amp; concat</a>
<a name="ln2152"> *		or  concat \&amp; concat \&amp; concat</a>
<a name="ln2153"> *		etc.</a>
<a name="ln2154"> */</a>
<a name="ln2155">static int nfa_regbranch(void)</a>
<a name="ln2156">{</a>
<a name="ln2157">  int old_post_pos;</a>
<a name="ln2158"> </a>
<a name="ln2159">  old_post_pos = (int)(post_ptr - post_start);</a>
<a name="ln2160"> </a>
<a name="ln2161">  /* First branch, possibly the only one */</a>
<a name="ln2162">  if (nfa_regconcat() == FAIL)</a>
<a name="ln2163">    return FAIL;</a>
<a name="ln2164"> </a>
<a name="ln2165">  // Try next concats</a>
<a name="ln2166">  while (peekchr() == Magic('&amp;')) {</a>
<a name="ln2167">    skipchr();</a>
<a name="ln2168">    // if concat is empty do emit a node</a>
<a name="ln2169">    if (old_post_pos == (int)(post_ptr - post_start)) {</a>
<a name="ln2170">      EMIT(NFA_EMPTY);</a>
<a name="ln2171">    }</a>
<a name="ln2172">    EMIT(NFA_NOPEN);</a>
<a name="ln2173">    EMIT(NFA_PREV_ATOM_NO_WIDTH);</a>
<a name="ln2174">    old_post_pos = (int)(post_ptr - post_start);</a>
<a name="ln2175">    if (nfa_regconcat() == FAIL)</a>
<a name="ln2176">      return FAIL;</a>
<a name="ln2177">    /* if concat is empty do emit a node */</a>
<a name="ln2178">    if (old_post_pos == (int)(post_ptr - post_start))</a>
<a name="ln2179">      EMIT(NFA_EMPTY);</a>
<a name="ln2180">    EMIT(NFA_CONCAT);</a>
<a name="ln2181">  }</a>
<a name="ln2182"> </a>
<a name="ln2183">  /* if a branch is empty, emit one node for it */</a>
<a name="ln2184">  if (old_post_pos == (int)(post_ptr - post_start))</a>
<a name="ln2185">    EMIT(NFA_EMPTY);</a>
<a name="ln2186"> </a>
<a name="ln2187">  return OK;</a>
<a name="ln2188">}</a>
<a name="ln2189"> </a>
<a name="ln2190">/*</a>
<a name="ln2191"> *  Parse a pattern, one or more branches, separated by &quot;\|&quot;.  It matches</a>
<a name="ln2192"> *  anything that matches one of the branches.  Example: &quot;foo\|beep&quot; matches</a>
<a name="ln2193"> *  &quot;foo&quot; and matches &quot;beep&quot;.  If more than one branch matches, the first one</a>
<a name="ln2194"> *  is used.</a>
<a name="ln2195"> *</a>
<a name="ln2196"> *  pattern ::=	    branch</a>
<a name="ln2197"> *	or  branch \| branch</a>
<a name="ln2198"> *	or  branch \| branch \| branch</a>
<a name="ln2199"> *	etc.</a>
<a name="ln2200"> */</a>
<a name="ln2201">static int </a>
<a name="ln2202">nfa_reg (</a>
<a name="ln2203">    int paren              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */</a>
<a name="ln2204">)</a>
<a name="ln2205">{</a>
<a name="ln2206">  int parno = 0;</a>
<a name="ln2207"> </a>
<a name="ln2208">  if (paren == REG_PAREN) {</a>
<a name="ln2209">    if (regnpar &gt;= NSUBEXP)     /* Too many `(' */</a>
<a name="ln2210">      EMSG_RET_FAIL(_(&quot;E872: (NFA regexp) Too many '('&quot;));</a>
<a name="ln2211">    parno = regnpar++;</a>
<a name="ln2212">  } else if (paren == REG_ZPAREN) {</a>
<a name="ln2213">    /* Make a ZOPEN node. */</a>
<a name="ln2214">    if (regnzpar &gt;= NSUBEXP)</a>
<a name="ln2215">      EMSG_RET_FAIL(_(&quot;E879: (NFA regexp) Too many \\z(&quot;));</a>
<a name="ln2216">    parno = regnzpar++;</a>
<a name="ln2217">  }</a>
<a name="ln2218"> </a>
<a name="ln2219">  if (nfa_regbranch() == FAIL)</a>
<a name="ln2220">    return FAIL;            /* cascaded error */</a>
<a name="ln2221"> </a>
<a name="ln2222">  while (peekchr() == Magic('|')) {</a>
<a name="ln2223">    skipchr();</a>
<a name="ln2224">    if (nfa_regbranch() == FAIL)</a>
<a name="ln2225">      return FAIL;          /* cascaded error */</a>
<a name="ln2226">    EMIT(NFA_OR);</a>
<a name="ln2227">  }</a>
<a name="ln2228"> </a>
<a name="ln2229">  /* Check for proper termination. */</a>
<a name="ln2230">  if (paren != REG_NOPAREN &amp;&amp; getchr() != Magic(')')) {</a>
<a name="ln2231">    if (paren == REG_NPAREN)</a>
<a name="ln2232">      EMSG2_RET_FAIL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);</a>
<a name="ln2233">    else</a>
<a name="ln2234">      EMSG2_RET_FAIL(_(e_unmatchedp), reg_magic == MAGIC_ALL);</a>
<a name="ln2235">  } else if (paren == REG_NOPAREN &amp;&amp; peekchr() != NUL) {</a>
<a name="ln2236">    if (peekchr() == Magic(')'))</a>
<a name="ln2237">      EMSG2_RET_FAIL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);</a>
<a name="ln2238">    else</a>
<a name="ln2239">      EMSG_RET_FAIL(_(&quot;E873: (NFA regexp) proper termination error&quot;));</a>
<a name="ln2240">  }</a>
<a name="ln2241">  // Here we set the flag allowing back references to this set of</a>
<a name="ln2242">  // parentheses.</a>
<a name="ln2243">  if (paren == REG_PAREN) {</a>
<a name="ln2244">    had_endbrace[parno] = true;  // have seen the close paren</a>
<a name="ln2245">    EMIT(NFA_MOPEN + parno);</a>
<a name="ln2246">  } else if (paren == REG_ZPAREN) {</a>
<a name="ln2247">    EMIT(NFA_ZOPEN + parno);</a>
<a name="ln2248">  }</a>
<a name="ln2249"> </a>
<a name="ln2250">  return OK;</a>
<a name="ln2251">}</a>
<a name="ln2252"> </a>
<a name="ln2253">#ifdef REGEXP_DEBUG</a>
<a name="ln2254">static char_u code[50];</a>
<a name="ln2255"> </a>
<a name="ln2256">static void nfa_set_code(int c)</a>
<a name="ln2257">{</a>
<a name="ln2258">  int addnl = false;</a>
<a name="ln2259"> </a>
<a name="ln2260">  if (c &gt;= NFA_FIRST_NL &amp;&amp; c &lt;= NFA_LAST_NL) {</a>
<a name="ln2261">    addnl = true;</a>
<a name="ln2262">    c -= NFA_ADD_NL;</a>
<a name="ln2263">  }</a>
<a name="ln2264"> </a>
<a name="ln2265">  STRCPY(code, &quot;&quot;);</a>
<a name="ln2266">  switch (c) {</a>
<a name="ln2267">  case NFA_MATCH:     STRCPY(code, &quot;NFA_MATCH &quot;); break;</a>
<a name="ln2268">  case NFA_SPLIT:     STRCPY(code, &quot;NFA_SPLIT &quot;); break;</a>
<a name="ln2269">  case NFA_CONCAT:    STRCPY(code, &quot;NFA_CONCAT &quot;); break;</a>
<a name="ln2270">  case NFA_NEWL:      STRCPY(code, &quot;NFA_NEWL &quot;); break;</a>
<a name="ln2271">  case NFA_ZSTART:    STRCPY(code, &quot;NFA_ZSTART&quot;); break;</a>
<a name="ln2272">  case NFA_ZEND:      STRCPY(code, &quot;NFA_ZEND&quot;); break;</a>
<a name="ln2273"> </a>
<a name="ln2274">  case NFA_BACKREF1:  STRCPY(code, &quot;NFA_BACKREF1&quot;); break;</a>
<a name="ln2275">  case NFA_BACKREF2:  STRCPY(code, &quot;NFA_BACKREF2&quot;); break;</a>
<a name="ln2276">  case NFA_BACKREF3:  STRCPY(code, &quot;NFA_BACKREF3&quot;); break;</a>
<a name="ln2277">  case NFA_BACKREF4:  STRCPY(code, &quot;NFA_BACKREF4&quot;); break;</a>
<a name="ln2278">  case NFA_BACKREF5:  STRCPY(code, &quot;NFA_BACKREF5&quot;); break;</a>
<a name="ln2279">  case NFA_BACKREF6:  STRCPY(code, &quot;NFA_BACKREF6&quot;); break;</a>
<a name="ln2280">  case NFA_BACKREF7:  STRCPY(code, &quot;NFA_BACKREF7&quot;); break;</a>
<a name="ln2281">  case NFA_BACKREF8:  STRCPY(code, &quot;NFA_BACKREF8&quot;); break;</a>
<a name="ln2282">  case NFA_BACKREF9:  STRCPY(code, &quot;NFA_BACKREF9&quot;); break;</a>
<a name="ln2283">  case NFA_ZREF1:     STRCPY(code, &quot;NFA_ZREF1&quot;); break;</a>
<a name="ln2284">  case NFA_ZREF2:     STRCPY(code, &quot;NFA_ZREF2&quot;); break;</a>
<a name="ln2285">  case NFA_ZREF3:     STRCPY(code, &quot;NFA_ZREF3&quot;); break;</a>
<a name="ln2286">  case NFA_ZREF4:     STRCPY(code, &quot;NFA_ZREF4&quot;); break;</a>
<a name="ln2287">  case NFA_ZREF5:     STRCPY(code, &quot;NFA_ZREF5&quot;); break;</a>
<a name="ln2288">  case NFA_ZREF6:     STRCPY(code, &quot;NFA_ZREF6&quot;); break;</a>
<a name="ln2289">  case NFA_ZREF7:     STRCPY(code, &quot;NFA_ZREF7&quot;); break;</a>
<a name="ln2290">  case NFA_ZREF8:     STRCPY(code, &quot;NFA_ZREF8&quot;); break;</a>
<a name="ln2291">  case NFA_ZREF9:     STRCPY(code, &quot;NFA_ZREF9&quot;); break;</a>
<a name="ln2292">  case NFA_SKIP:      STRCPY(code, &quot;NFA_SKIP&quot;); break;</a>
<a name="ln2293"> </a>
<a name="ln2294">  case NFA_PREV_ATOM_NO_WIDTH:</a>
<a name="ln2295">    STRCPY(code, &quot;NFA_PREV_ATOM_NO_WIDTH&quot;); break;</a>
<a name="ln2296">  case NFA_PREV_ATOM_NO_WIDTH_NEG:</a>
<a name="ln2297">    STRCPY(code, &quot;NFA_PREV_ATOM_NO_WIDTH_NEG&quot;); break;</a>
<a name="ln2298">  case NFA_PREV_ATOM_JUST_BEFORE:</a>
<a name="ln2299">    STRCPY(code, &quot;NFA_PREV_ATOM_JUST_BEFORE&quot;); break;</a>
<a name="ln2300">  case NFA_PREV_ATOM_JUST_BEFORE_NEG:</a>
<a name="ln2301">    STRCPY(code, &quot;NFA_PREV_ATOM_JUST_BEFORE_NEG&quot;); break;</a>
<a name="ln2302">  case NFA_PREV_ATOM_LIKE_PATTERN:</a>
<a name="ln2303">    STRCPY(code, &quot;NFA_PREV_ATOM_LIKE_PATTERN&quot;); break;</a>
<a name="ln2304"> </a>
<a name="ln2305">  case NFA_NOPEN:             STRCPY(code, &quot;NFA_NOPEN&quot;); break;</a>
<a name="ln2306">  case NFA_NCLOSE:            STRCPY(code, &quot;NFA_NCLOSE&quot;); break;</a>
<a name="ln2307">  case NFA_START_INVISIBLE:   STRCPY(code, &quot;NFA_START_INVISIBLE&quot;); break;</a>
<a name="ln2308">  case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln2309">    STRCPY(code, &quot;NFA_START_INVISIBLE_FIRST&quot;); break;</a>
<a name="ln2310">  case NFA_START_INVISIBLE_NEG:</a>
<a name="ln2311">    STRCPY(code, &quot;NFA_START_INVISIBLE_NEG&quot;); break;</a>
<a name="ln2312">  case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln2313">    STRCPY(code, &quot;NFA_START_INVISIBLE_NEG_FIRST&quot;); break;</a>
<a name="ln2314">  case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln2315">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE&quot;); break;</a>
<a name="ln2316">  case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln2317">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE_FIRST&quot;); break;</a>
<a name="ln2318">  case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln2319">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE_NEG&quot;); break;</a>
<a name="ln2320">  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln2321">    STRCPY(code, &quot;NFA_START_INVISIBLE_BEFORE_NEG_FIRST&quot;); break;</a>
<a name="ln2322">  case NFA_START_PATTERN:   STRCPY(code, &quot;NFA_START_PATTERN&quot;); break;</a>
<a name="ln2323">  case NFA_END_INVISIBLE:     STRCPY(code, &quot;NFA_END_INVISIBLE&quot;); break;</a>
<a name="ln2324">  case NFA_END_INVISIBLE_NEG: STRCPY(code, &quot;NFA_END_INVISIBLE_NEG&quot;); break;</a>
<a name="ln2325">  case NFA_END_PATTERN:       STRCPY(code, &quot;NFA_END_PATTERN&quot;); break;</a>
<a name="ln2326"> </a>
<a name="ln2327">  case NFA_COMPOSING:         STRCPY(code, &quot;NFA_COMPOSING&quot;); break;</a>
<a name="ln2328">  case NFA_END_COMPOSING:     STRCPY(code, &quot;NFA_END_COMPOSING&quot;); break;</a>
<a name="ln2329">  case NFA_OPT_CHARS:         STRCPY(code, &quot;NFA_OPT_CHARS&quot;); break;</a>
<a name="ln2330"> </a>
<a name="ln2331">  case NFA_MOPEN:</a>
<a name="ln2332">  case NFA_MOPEN1:</a>
<a name="ln2333">  case NFA_MOPEN2:</a>
<a name="ln2334">  case NFA_MOPEN3:</a>
<a name="ln2335">  case NFA_MOPEN4:</a>
<a name="ln2336">  case NFA_MOPEN5:</a>
<a name="ln2337">  case NFA_MOPEN6:</a>
<a name="ln2338">  case NFA_MOPEN7:</a>
<a name="ln2339">  case NFA_MOPEN8:</a>
<a name="ln2340">  case NFA_MOPEN9:</a>
<a name="ln2341">    STRCPY(code, &quot;NFA_MOPEN(x)&quot;);</a>
<a name="ln2342">    code[10] = c - NFA_MOPEN + '0';</a>
<a name="ln2343">    break;</a>
<a name="ln2344">  case NFA_MCLOSE:</a>
<a name="ln2345">  case NFA_MCLOSE1:</a>
<a name="ln2346">  case NFA_MCLOSE2:</a>
<a name="ln2347">  case NFA_MCLOSE3:</a>
<a name="ln2348">  case NFA_MCLOSE4:</a>
<a name="ln2349">  case NFA_MCLOSE5:</a>
<a name="ln2350">  case NFA_MCLOSE6:</a>
<a name="ln2351">  case NFA_MCLOSE7:</a>
<a name="ln2352">  case NFA_MCLOSE8:</a>
<a name="ln2353">  case NFA_MCLOSE9:</a>
<a name="ln2354">    STRCPY(code, &quot;NFA_MCLOSE(x)&quot;);</a>
<a name="ln2355">    code[11] = c - NFA_MCLOSE + '0';</a>
<a name="ln2356">    break;</a>
<a name="ln2357">  case NFA_ZOPEN:</a>
<a name="ln2358">  case NFA_ZOPEN1:</a>
<a name="ln2359">  case NFA_ZOPEN2:</a>
<a name="ln2360">  case NFA_ZOPEN3:</a>
<a name="ln2361">  case NFA_ZOPEN4:</a>
<a name="ln2362">  case NFA_ZOPEN5:</a>
<a name="ln2363">  case NFA_ZOPEN6:</a>
<a name="ln2364">  case NFA_ZOPEN7:</a>
<a name="ln2365">  case NFA_ZOPEN8:</a>
<a name="ln2366">  case NFA_ZOPEN9:</a>
<a name="ln2367">    STRCPY(code, &quot;NFA_ZOPEN(x)&quot;);</a>
<a name="ln2368">    code[10] = c - NFA_ZOPEN + '0';</a>
<a name="ln2369">    break;</a>
<a name="ln2370">  case NFA_ZCLOSE:</a>
<a name="ln2371">  case NFA_ZCLOSE1:</a>
<a name="ln2372">  case NFA_ZCLOSE2:</a>
<a name="ln2373">  case NFA_ZCLOSE3:</a>
<a name="ln2374">  case NFA_ZCLOSE4:</a>
<a name="ln2375">  case NFA_ZCLOSE5:</a>
<a name="ln2376">  case NFA_ZCLOSE6:</a>
<a name="ln2377">  case NFA_ZCLOSE7:</a>
<a name="ln2378">  case NFA_ZCLOSE8:</a>
<a name="ln2379">  case NFA_ZCLOSE9:</a>
<a name="ln2380">    STRCPY(code, &quot;NFA_ZCLOSE(x)&quot;);</a>
<a name="ln2381">    code[11] = c - NFA_ZCLOSE + '0';</a>
<a name="ln2382">    break;</a>
<a name="ln2383">  case NFA_EOL:           STRCPY(code, &quot;NFA_EOL &quot;); break;</a>
<a name="ln2384">  case NFA_BOL:           STRCPY(code, &quot;NFA_BOL &quot;); break;</a>
<a name="ln2385">  case NFA_EOW:           STRCPY(code, &quot;NFA_EOW &quot;); break;</a>
<a name="ln2386">  case NFA_BOW:           STRCPY(code, &quot;NFA_BOW &quot;); break;</a>
<a name="ln2387">  case NFA_EOF:           STRCPY(code, &quot;NFA_EOF &quot;); break;</a>
<a name="ln2388">  case NFA_BOF:           STRCPY(code, &quot;NFA_BOF &quot;); break;</a>
<a name="ln2389">  case NFA_LNUM:          STRCPY(code, &quot;NFA_LNUM &quot;); break;</a>
<a name="ln2390">  case NFA_LNUM_GT:       STRCPY(code, &quot;NFA_LNUM_GT &quot;); break;</a>
<a name="ln2391">  case NFA_LNUM_LT:       STRCPY(code, &quot;NFA_LNUM_LT &quot;); break;</a>
<a name="ln2392">  case NFA_COL:           STRCPY(code, &quot;NFA_COL &quot;); break;</a>
<a name="ln2393">  case NFA_COL_GT:        STRCPY(code, &quot;NFA_COL_GT &quot;); break;</a>
<a name="ln2394">  case NFA_COL_LT:        STRCPY(code, &quot;NFA_COL_LT &quot;); break;</a>
<a name="ln2395">  case NFA_VCOL:          STRCPY(code, &quot;NFA_VCOL &quot;); break;</a>
<a name="ln2396">  case NFA_VCOL_GT:       STRCPY(code, &quot;NFA_VCOL_GT &quot;); break;</a>
<a name="ln2397">  case NFA_VCOL_LT:       STRCPY(code, &quot;NFA_VCOL_LT &quot;); break;</a>
<a name="ln2398">  case NFA_MARK:          STRCPY(code, &quot;NFA_MARK &quot;); break;</a>
<a name="ln2399">  case NFA_MARK_GT:       STRCPY(code, &quot;NFA_MARK_GT &quot;); break;</a>
<a name="ln2400">  case NFA_MARK_LT:       STRCPY(code, &quot;NFA_MARK_LT &quot;); break;</a>
<a name="ln2401">  case NFA_CURSOR:        STRCPY(code, &quot;NFA_CURSOR &quot;); break;</a>
<a name="ln2402">  case NFA_VISUAL:        STRCPY(code, &quot;NFA_VISUAL &quot;); break;</a>
<a name="ln2403">  case NFA_ANY_COMPOSING: STRCPY(code, &quot;NFA_ANY_COMPOSING &quot;); break;</a>
<a name="ln2404"> </a>
<a name="ln2405">  case NFA_STAR:          STRCPY(code, &quot;NFA_STAR &quot;); break;</a>
<a name="ln2406">  case NFA_STAR_NONGREEDY: STRCPY(code, &quot;NFA_STAR_NONGREEDY &quot;); break;</a>
<a name="ln2407">  case NFA_QUEST:         STRCPY(code, &quot;NFA_QUEST&quot;); break;</a>
<a name="ln2408">  case NFA_QUEST_NONGREEDY: STRCPY(code, &quot;NFA_QUEST_NON_GREEDY&quot;); break;</a>
<a name="ln2409">  case NFA_EMPTY:         STRCPY(code, &quot;NFA_EMPTY&quot;); break;</a>
<a name="ln2410">  case NFA_OR:            STRCPY(code, &quot;NFA_OR&quot;); break;</a>
<a name="ln2411"> </a>
<a name="ln2412">  case NFA_START_COLL:    STRCPY(code, &quot;NFA_START_COLL&quot;); break;</a>
<a name="ln2413">  case NFA_END_COLL:      STRCPY(code, &quot;NFA_END_COLL&quot;); break;</a>
<a name="ln2414">  case NFA_START_NEG_COLL: STRCPY(code, &quot;NFA_START_NEG_COLL&quot;); break;</a>
<a name="ln2415">  case NFA_END_NEG_COLL:  STRCPY(code, &quot;NFA_END_NEG_COLL&quot;); break;</a>
<a name="ln2416">  case NFA_RANGE:         STRCPY(code, &quot;NFA_RANGE&quot;); break;</a>
<a name="ln2417">  case NFA_RANGE_MIN:     STRCPY(code, &quot;NFA_RANGE_MIN&quot;); break;</a>
<a name="ln2418">  case NFA_RANGE_MAX:     STRCPY(code, &quot;NFA_RANGE_MAX&quot;); break;</a>
<a name="ln2419"> </a>
<a name="ln2420">  case NFA_CLASS_ALNUM:   STRCPY(code, &quot;NFA_CLASS_ALNUM&quot;); break;</a>
<a name="ln2421">  case NFA_CLASS_ALPHA:   STRCPY(code, &quot;NFA_CLASS_ALPHA&quot;); break;</a>
<a name="ln2422">  case NFA_CLASS_BLANK:   STRCPY(code, &quot;NFA_CLASS_BLANK&quot;); break;</a>
<a name="ln2423">  case NFA_CLASS_CNTRL:   STRCPY(code, &quot;NFA_CLASS_CNTRL&quot;); break;</a>
<a name="ln2424">  case NFA_CLASS_DIGIT:   STRCPY(code, &quot;NFA_CLASS_DIGIT&quot;); break;</a>
<a name="ln2425">  case NFA_CLASS_GRAPH:   STRCPY(code, &quot;NFA_CLASS_GRAPH&quot;); break;</a>
<a name="ln2426">  case NFA_CLASS_LOWER:   STRCPY(code, &quot;NFA_CLASS_LOWER&quot;); break;</a>
<a name="ln2427">  case NFA_CLASS_PRINT:   STRCPY(code, &quot;NFA_CLASS_PRINT&quot;); break;</a>
<a name="ln2428">  case NFA_CLASS_PUNCT:   STRCPY(code, &quot;NFA_CLASS_PUNCT&quot;); break;</a>
<a name="ln2429">  case NFA_CLASS_SPACE:   STRCPY(code, &quot;NFA_CLASS_SPACE&quot;); break;</a>
<a name="ln2430">  case NFA_CLASS_UPPER:   STRCPY(code, &quot;NFA_CLASS_UPPER&quot;); break;</a>
<a name="ln2431">  case NFA_CLASS_XDIGIT:  STRCPY(code, &quot;NFA_CLASS_XDIGIT&quot;); break;</a>
<a name="ln2432">  case NFA_CLASS_TAB:     STRCPY(code, &quot;NFA_CLASS_TAB&quot;); break;</a>
<a name="ln2433">  case NFA_CLASS_RETURN:  STRCPY(code, &quot;NFA_CLASS_RETURN&quot;); break;</a>
<a name="ln2434">  case NFA_CLASS_BACKSPACE:   STRCPY(code, &quot;NFA_CLASS_BACKSPACE&quot;); break;</a>
<a name="ln2435">  case NFA_CLASS_ESCAPE:  STRCPY(code, &quot;NFA_CLASS_ESCAPE&quot;); break;</a>
<a name="ln2436">  case NFA_CLASS_IDENT:   STRCPY(code, &quot;NFA_CLASS_IDENT&quot;); break;</a>
<a name="ln2437">  case NFA_CLASS_KEYWORD: STRCPY(code, &quot;NFA_CLASS_KEYWORD&quot;); break;</a>
<a name="ln2438">  case NFA_CLASS_FNAME:   STRCPY(code, &quot;NFA_CLASS_FNAME&quot;); break;</a>
<a name="ln2439"> </a>
<a name="ln2440">  case NFA_ANY:   STRCPY(code, &quot;NFA_ANY&quot;); break;</a>
<a name="ln2441">  case NFA_IDENT: STRCPY(code, &quot;NFA_IDENT&quot;); break;</a>
<a name="ln2442">  case NFA_SIDENT: STRCPY(code, &quot;NFA_SIDENT&quot;); break;</a>
<a name="ln2443">  case NFA_KWORD: STRCPY(code, &quot;NFA_KWORD&quot;); break;</a>
<a name="ln2444">  case NFA_SKWORD: STRCPY(code, &quot;NFA_SKWORD&quot;); break;</a>
<a name="ln2445">  case NFA_FNAME: STRCPY(code, &quot;NFA_FNAME&quot;); break;</a>
<a name="ln2446">  case NFA_SFNAME: STRCPY(code, &quot;NFA_SFNAME&quot;); break;</a>
<a name="ln2447">  case NFA_PRINT: STRCPY(code, &quot;NFA_PRINT&quot;); break;</a>
<a name="ln2448">  case NFA_SPRINT: STRCPY(code, &quot;NFA_SPRINT&quot;); break;</a>
<a name="ln2449">  case NFA_WHITE: STRCPY(code, &quot;NFA_WHITE&quot;); break;</a>
<a name="ln2450">  case NFA_NWHITE: STRCPY(code, &quot;NFA_NWHITE&quot;); break;</a>
<a name="ln2451">  case NFA_DIGIT: STRCPY(code, &quot;NFA_DIGIT&quot;); break;</a>
<a name="ln2452">  case NFA_NDIGIT: STRCPY(code, &quot;NFA_NDIGIT&quot;); break;</a>
<a name="ln2453">  case NFA_HEX:   STRCPY(code, &quot;NFA_HEX&quot;); break;</a>
<a name="ln2454">  case NFA_NHEX:  STRCPY(code, &quot;NFA_NHEX&quot;); break;</a>
<a name="ln2455">  case NFA_OCTAL: STRCPY(code, &quot;NFA_OCTAL&quot;); break;</a>
<a name="ln2456">  case NFA_NOCTAL: STRCPY(code, &quot;NFA_NOCTAL&quot;); break;</a>
<a name="ln2457">  case NFA_WORD:  STRCPY(code, &quot;NFA_WORD&quot;); break;</a>
<a name="ln2458">  case NFA_NWORD: STRCPY(code, &quot;NFA_NWORD&quot;); break;</a>
<a name="ln2459">  case NFA_HEAD:  STRCPY(code, &quot;NFA_HEAD&quot;); break;</a>
<a name="ln2460">  case NFA_NHEAD: STRCPY(code, &quot;NFA_NHEAD&quot;); break;</a>
<a name="ln2461">  case NFA_ALPHA: STRCPY(code, &quot;NFA_ALPHA&quot;); break;</a>
<a name="ln2462">  case NFA_NALPHA: STRCPY(code, &quot;NFA_NALPHA&quot;); break;</a>
<a name="ln2463">  case NFA_LOWER: STRCPY(code, &quot;NFA_LOWER&quot;); break;</a>
<a name="ln2464">  case NFA_NLOWER: STRCPY(code, &quot;NFA_NLOWER&quot;); break;</a>
<a name="ln2465">  case NFA_UPPER: STRCPY(code, &quot;NFA_UPPER&quot;); break;</a>
<a name="ln2466">  case NFA_NUPPER: STRCPY(code, &quot;NFA_NUPPER&quot;); break;</a>
<a name="ln2467">  case NFA_LOWER_IC:  STRCPY(code, &quot;NFA_LOWER_IC&quot;); break;</a>
<a name="ln2468">  case NFA_NLOWER_IC: STRCPY(code, &quot;NFA_NLOWER_IC&quot;); break;</a>
<a name="ln2469">  case NFA_UPPER_IC:  STRCPY(code, &quot;NFA_UPPER_IC&quot;); break;</a>
<a name="ln2470">  case NFA_NUPPER_IC: STRCPY(code, &quot;NFA_NUPPER_IC&quot;); break;</a>
<a name="ln2471"> </a>
<a name="ln2472">  default:</a>
<a name="ln2473">    STRCPY(code, &quot;CHAR(x)&quot;);</a>
<a name="ln2474">    code[5] = c;</a>
<a name="ln2475">  }</a>
<a name="ln2476"> </a>
<a name="ln2477">  if (addnl == true) {</a>
<a name="ln2478">    STRCAT(code, &quot; + NEWLINE &quot;);</a>
<a name="ln2479">  }</a>
<a name="ln2480">}</a>
<a name="ln2481"> </a>
<a name="ln2482">static FILE *log_fd;</a>
<a name="ln2483">static char_u e_log_open_failed[] = N_(</a>
<a name="ln2484">    &quot;Could not open temporary log file for writing, displaying on stderr... &quot;);</a>
<a name="ln2485"> </a>
<a name="ln2486">/*</a>
<a name="ln2487"> * Print the postfix notation of the current regexp.</a>
<a name="ln2488"> */</a>
<a name="ln2489">static void nfa_postfix_dump(char_u *expr, int retval)</a>
<a name="ln2490">{</a>
<a name="ln2491">  int *p;</a>
<a name="ln2492">  FILE *f;</a>
<a name="ln2493"> </a>
<a name="ln2494">  f = fopen(NFA_REGEXP_DUMP_LOG, &quot;a&quot;);</a>
<a name="ln2495">  if (f != NULL) {</a>
<a name="ln2496">    fprintf(f, &quot;\n-------------------------\n&quot;);</a>
<a name="ln2497">    if (retval == FAIL) {</a>
<a name="ln2498">      fprintf(f, &quot;&gt;&gt;&gt; NFA engine failed... \n&quot;);</a>
<a name="ln2499">    } else if (retval == OK) {</a>
<a name="ln2500">      fprintf(f, &quot;&gt;&gt;&gt; NFA engine succeeded !\n&quot;);</a>
<a name="ln2501">    }</a>
<a name="ln2502">    fprintf(f, &quot;Regexp: \&quot;%s\&quot;\nPostfix notation (char): \&quot;&quot;, expr);</a>
<a name="ln2503">    for (p = post_start; *p &amp;&amp; p &lt; post_ptr; p++) {</a>
<a name="ln2504">      nfa_set_code(*p);</a>
<a name="ln2505">      fprintf(f, &quot;%s, &quot;, code);</a>
<a name="ln2506">    }</a>
<a name="ln2507">    fprintf(f, &quot;\&quot;\nPostfix notation (int): &quot;);</a>
<a name="ln2508">    for (p = post_start; *p &amp;&amp; p &lt; post_ptr; p++)</a>
<a name="ln2509">      fprintf(f, &quot;%d &quot;, *p);</a>
<a name="ln2510">    fprintf(f, &quot;\n\n&quot;);</a>
<a name="ln2511">    fclose(f);</a>
<a name="ln2512">  }</a>
<a name="ln2513">}</a>
<a name="ln2514"> </a>
<a name="ln2515">/*</a>
<a name="ln2516"> * Print the NFA starting with a root node &quot;state&quot;.</a>
<a name="ln2517"> */</a>
<a name="ln2518">static void nfa_print_state(FILE *debugf, nfa_state_T *state)</a>
<a name="ln2519">{</a>
<a name="ln2520">  garray_T indent;</a>
<a name="ln2521"> </a>
<a name="ln2522">  ga_init(&amp;indent, 1, 64);</a>
<a name="ln2523">  ga_append(&amp;indent, '\0');</a>
<a name="ln2524">  nfa_print_state2(debugf, state, &amp;indent);</a>
<a name="ln2525">  ga_clear(&amp;indent);</a>
<a name="ln2526">}</a>
<a name="ln2527"> </a>
<a name="ln2528">static void nfa_print_state2(FILE *debugf, nfa_state_T *state, garray_T *indent)</a>
<a name="ln2529">{</a>
<a name="ln2530">  char_u  *p;</a>
<a name="ln2531"> </a>
<a name="ln2532">  if (state == NULL)</a>
<a name="ln2533">    return;</a>
<a name="ln2534"> </a>
<a name="ln2535">  fprintf(debugf, &quot;(%2d)&quot;, abs(state-&gt;id));</a>
<a name="ln2536"> </a>
<a name="ln2537">  /* Output indent */</a>
<a name="ln2538">  p = (char_u *)indent-&gt;ga_data;</a>
<a name="ln2539">  if (indent-&gt;ga_len &gt;= 3) {</a>
<a name="ln2540">    int last = indent-&gt;ga_len - 3;</a>
<a name="ln2541">    char_u save[2];</a>
<a name="ln2542"> </a>
<a name="ln2543">    STRNCPY(save, &amp;p[last], 2);</a>
<a name="ln2544">    STRNCPY(&amp;p[last], &quot;+-&quot;, 2);</a>
<a name="ln2545">    fprintf(debugf, &quot; %s&quot;, p);</a>
<a name="ln2546">    STRNCPY(&amp;p[last], save, 2);</a>
<a name="ln2547">  } else</a>
<a name="ln2548">    fprintf(debugf, &quot; %s&quot;, p);</a>
<a name="ln2549"> </a>
<a name="ln2550">  nfa_set_code(state-&gt;c);</a>
<a name="ln2551">  fprintf(debugf, &quot;%s (%d) (id=%d) val=%d\n&quot;,</a>
<a name="ln2552">      code,</a>
<a name="ln2553">      state-&gt;c,</a>
<a name="ln2554">      abs(state-&gt;id),</a>
<a name="ln2555">      state-&gt;val);</a>
<a name="ln2556">  if (state-&gt;id &lt; 0)</a>
<a name="ln2557">    return;</a>
<a name="ln2558"> </a>
<a name="ln2559">  state-&gt;id = abs(state-&gt;id) * -1;</a>
<a name="ln2560"> </a>
<a name="ln2561">  /* grow indent for state-&gt;out */</a>
<a name="ln2562">  indent-&gt;ga_len -= 1;</a>
<a name="ln2563">  if (state-&gt;out1)</a>
<a name="ln2564">    ga_concat(indent, (char_u *)&quot;| &quot;);</a>
<a name="ln2565">  else</a>
<a name="ln2566">    ga_concat(indent, (char_u *)&quot;  &quot;);</a>
<a name="ln2567">  ga_append(indent, '\0');</a>
<a name="ln2568"> </a>
<a name="ln2569">  nfa_print_state2(debugf, state-&gt;out, indent);</a>
<a name="ln2570"> </a>
<a name="ln2571">  /* replace last part of indent for state-&gt;out1 */</a>
<a name="ln2572">  indent-&gt;ga_len -= 3;</a>
<a name="ln2573">  ga_concat(indent, (char_u *)&quot;  &quot;);</a>
<a name="ln2574">  ga_append(indent, '\0');</a>
<a name="ln2575"> </a>
<a name="ln2576">  nfa_print_state2(debugf, state-&gt;out1, indent);</a>
<a name="ln2577"> </a>
<a name="ln2578">  /* shrink indent */</a>
<a name="ln2579">  indent-&gt;ga_len -= 3;</a>
<a name="ln2580">  ga_append(indent, '\0');</a>
<a name="ln2581">}</a>
<a name="ln2582"> </a>
<a name="ln2583">/*</a>
<a name="ln2584"> * Print the NFA state machine.</a>
<a name="ln2585"> */</a>
<a name="ln2586">static void nfa_dump(nfa_regprog_T *prog)</a>
<a name="ln2587">{</a>
<a name="ln2588">  FILE *debugf = fopen(NFA_REGEXP_DUMP_LOG, &quot;a&quot;);</a>
<a name="ln2589"> </a>
<a name="ln2590">  if (debugf != NULL) {</a>
<a name="ln2591">    nfa_print_state(debugf, prog-&gt;start);</a>
<a name="ln2592"> </a>
<a name="ln2593">    if (prog-&gt;reganch)</a>
<a name="ln2594">      fprintf(debugf, &quot;reganch: %d\n&quot;, prog-&gt;reganch);</a>
<a name="ln2595">    if (prog-&gt;regstart != NUL)</a>
<a name="ln2596">      fprintf(debugf, &quot;regstart: %c (decimal: %d)\n&quot;,</a>
<a name="ln2597">          prog-&gt;regstart, prog-&gt;regstart);</a>
<a name="ln2598">    if (prog-&gt;match_text != NULL)</a>
<a name="ln2599">      fprintf(debugf, &quot;match_text: \&quot;%s\&quot;\n&quot;, prog-&gt;match_text);</a>
<a name="ln2600"> </a>
<a name="ln2601">    fclose(debugf);</a>
<a name="ln2602">  }</a>
<a name="ln2603">}</a>
<a name="ln2604">#endif      /* REGEXP_DEBUG */</a>
<a name="ln2605"> </a>
<a name="ln2606">/*</a>
<a name="ln2607"> * Parse r.e. @expr and convert it into postfix form.</a>
<a name="ln2608"> * Return the postfix string on success, NULL otherwise.</a>
<a name="ln2609"> */</a>
<a name="ln2610">static int *re2post(void)</a>
<a name="ln2611">{</a>
<a name="ln2612">  if (nfa_reg(REG_NOPAREN) == FAIL)</a>
<a name="ln2613">    return NULL;</a>
<a name="ln2614">  EMIT(NFA_MOPEN);</a>
<a name="ln2615">  return post_start;</a>
<a name="ln2616">}</a>
<a name="ln2617"> </a>
<a name="ln2618">/* NB. Some of the code below is inspired by Russ's. */</a>
<a name="ln2619"> </a>
<a name="ln2620">/*</a>
<a name="ln2621"> * Represents an NFA state plus zero or one or two arrows exiting.</a>
<a name="ln2622"> * if c == MATCH, no arrows out; matching state.</a>
<a name="ln2623"> * If c == SPLIT, unlabeled arrows to out and out1 (if != NULL).</a>
<a name="ln2624"> * If c &lt; 256, labeled arrow with character c to out.</a>
<a name="ln2625"> */</a>
<a name="ln2626"> </a>
<a name="ln2627">static nfa_state_T      *state_ptr; /* points to nfa_prog-&gt;state */</a>
<a name="ln2628"> </a>
<a name="ln2629">/*</a>
<a name="ln2630"> * Allocate and initialize nfa_state_T.</a>
<a name="ln2631"> */</a>
<a name="ln2632">static nfa_state_T *alloc_state(int c, nfa_state_T *out, nfa_state_T *out1)</a>
<a name="ln2633">{</a>
<a name="ln2634">  nfa_state_T *s;</a>
<a name="ln2635"> </a>
<a name="ln2636">  if (istate &gt;= nstate)</a>
<a name="ln2637">    return NULL;</a>
<a name="ln2638"> </a>
<a name="ln2639">  s = &amp;state_ptr[istate++];</a>
<a name="ln2640"> </a>
<a name="ln2641">  s-&gt;c    = c;</a>
<a name="ln2642">  s-&gt;out  = out;</a>
<a name="ln2643">  s-&gt;out1 = out1;</a>
<a name="ln2644">  s-&gt;val  = 0;</a>
<a name="ln2645"> </a>
<a name="ln2646">  s-&gt;id   = istate;</a>
<a name="ln2647">  s-&gt;lastlist[0] = 0;</a>
<a name="ln2648">  s-&gt;lastlist[1] = 0;</a>
<a name="ln2649"> </a>
<a name="ln2650">  return s;</a>
<a name="ln2651">}</a>
<a name="ln2652"> </a>
<a name="ln2653">/*</a>
<a name="ln2654"> * A partially built NFA without the matching state filled in.</a>
<a name="ln2655"> * Frag_T.start points at the start state.</a>
<a name="ln2656"> * Frag_T.out is a list of places that need to be set to the</a>
<a name="ln2657"> * next state for this fragment.</a>
<a name="ln2658"> */</a>
<a name="ln2659"> </a>
<a name="ln2660"> </a>
<a name="ln2661">/*</a>
<a name="ln2662"> * Initialize a Frag_T struct and return it.</a>
<a name="ln2663"> */</a>
<a name="ln2664">static Frag_T frag(nfa_state_T *start, Ptrlist *out)</a>
<a name="ln2665">{</a>
<a name="ln2666">  Frag_T n;</a>
<a name="ln2667"> </a>
<a name="ln2668">  n.start = start;</a>
<a name="ln2669">  n.out = out;</a>
<a name="ln2670">  return n;</a>
<a name="ln2671">}</a>
<a name="ln2672"> </a>
<a name="ln2673">/*</a>
<a name="ln2674"> * Create singleton list containing just outp.</a>
<a name="ln2675"> */</a>
<a name="ln2676">static Ptrlist *list1(nfa_state_T **outp)</a>
<a name="ln2677">{</a>
<a name="ln2678">  Ptrlist *l;</a>
<a name="ln2679"> </a>
<a name="ln2680">  l = (Ptrlist *)outp;</a>
<a name="ln2681">  l-&gt;next = NULL;</a>
<a name="ln2682">  return l;</a>
<a name="ln2683">}</a>
<a name="ln2684"> </a>
<a name="ln2685">/*</a>
<a name="ln2686"> * Patch the list of states at out to point to start.</a>
<a name="ln2687"> */</a>
<a name="ln2688">static void patch(Ptrlist *l, nfa_state_T *s)</a>
<a name="ln2689">{</a>
<a name="ln2690">  Ptrlist *next;</a>
<a name="ln2691"> </a>
<a name="ln2692">  for (; l; l = next) {</a>
<a name="ln2693">    next = l-&gt;next;</a>
<a name="ln2694">    l-&gt;s = s;</a>
<a name="ln2695">  }</a>
<a name="ln2696">}</a>
<a name="ln2697"> </a>
<a name="ln2698"> </a>
<a name="ln2699">/*</a>
<a name="ln2700"> * Join the two lists l1 and l2, returning the combination.</a>
<a name="ln2701"> */</a>
<a name="ln2702">static Ptrlist *append(Ptrlist *l1, Ptrlist *l2)</a>
<a name="ln2703">{</a>
<a name="ln2704">  Ptrlist *oldl1;</a>
<a name="ln2705"> </a>
<a name="ln2706">  oldl1 = l1;</a>
<a name="ln2707">  while (l1-&gt;next)</a>
<a name="ln2708">    l1 = l1-&gt;next;</a>
<a name="ln2709">  l1-&gt;next = l2;</a>
<a name="ln2710">  return oldl1;</a>
<a name="ln2711">}</a>
<a name="ln2712"> </a>
<a name="ln2713">/*</a>
<a name="ln2714"> * Stack used for transforming postfix form into NFA.</a>
<a name="ln2715"> */</a>
<a name="ln2716">static Frag_T empty;</a>
<a name="ln2717"> </a>
<a name="ln2718">static void st_error(int *postfix, int *end, int *p)</a>
<a name="ln2719">{</a>
<a name="ln2720">#ifdef NFA_REGEXP_ERROR_LOG</a>
<a name="ln2721">  FILE *df;</a>
<a name="ln2722">  int *p2;</a>
<a name="ln2723"> </a>
<a name="ln2724">  df = fopen(NFA_REGEXP_ERROR_LOG, &quot;a&quot;);</a>
<a name="ln2725">  if (df) {</a>
<a name="ln2726">    fprintf(df, &quot;Error popping the stack!\n&quot;);</a>
<a name="ln2727">#ifdef REGEXP_DEBUG</a>
<a name="ln2728">    fprintf(df, &quot;Current regexp is \&quot;%s\&quot;\n&quot;, nfa_regengine.expr);</a>
<a name="ln2729">#endif</a>
<a name="ln2730">    fprintf(df, &quot;Postfix form is: &quot;);</a>
<a name="ln2731">#ifdef REGEXP_DEBUG</a>
<a name="ln2732">    for (p2 = postfix; p2 &lt; end; p2++) {</a>
<a name="ln2733">      nfa_set_code(*p2);</a>
<a name="ln2734">      fprintf(df, &quot;%s, &quot;, code);</a>
<a name="ln2735">    }</a>
<a name="ln2736">    nfa_set_code(*p);</a>
<a name="ln2737">    fprintf(df, &quot;\nCurrent position is: &quot;);</a>
<a name="ln2738">    for (p2 = postfix; p2 &lt;= p; p2++) {</a>
<a name="ln2739">      nfa_set_code(*p2);</a>
<a name="ln2740">      fprintf(df, &quot;%s, &quot;, code);</a>
<a name="ln2741">    }</a>
<a name="ln2742">#else</a>
<a name="ln2743">    for (p2 = postfix; p2 &lt; end; p2++) {</a>
<a name="ln2744">      fprintf(df, &quot;%d, &quot;, *p2);</a>
<a name="ln2745">    }</a>
<a name="ln2746">    fprintf(df, &quot;\nCurrent position is: &quot;);</a>
<a name="ln2747">    for (p2 = postfix; p2 &lt;= p; p2++) {</a>
<a name="ln2748">      fprintf(df, &quot;%d, &quot;, *p2);</a>
<a name="ln2749">    }</a>
<a name="ln2750">#endif</a>
<a name="ln2751">    fprintf(df, &quot;\n--------------------------\n&quot;);</a>
<a name="ln2752">    fclose(df);</a>
<a name="ln2753">  }</a>
<a name="ln2754">#endif</a>
<a name="ln2755">  EMSG(_(&quot;E874: (NFA) Could not pop the stack!&quot;));</a>
<a name="ln2756">}</a>
<a name="ln2757"> </a>
<a name="ln2758">/*</a>
<a name="ln2759"> * Push an item onto the stack.</a>
<a name="ln2760"> */</a>
<a name="ln2761">static void st_push(Frag_T s, Frag_T **p, Frag_T *stack_end)</a>
<a name="ln2762">{</a>
<a name="ln2763">  Frag_T *stackp = *p;</a>
<a name="ln2764"> </a>
<a name="ln2765">  if (stackp &gt;= stack_end)</a>
<a name="ln2766">    return;</a>
<a name="ln2767">  *stackp = s;</a>
<a name="ln2768">  *p = *p + 1;</a>
<a name="ln2769">}</a>
<a name="ln2770"> </a>
<a name="ln2771">/*</a>
<a name="ln2772"> * Pop an item from the stack.</a>
<a name="ln2773"> */</a>
<a name="ln2774">static Frag_T st_pop(Frag_T **p, Frag_T *stack)</a>
<a name="ln2775">{</a>
<a name="ln2776">  Frag_T *stackp;</a>
<a name="ln2777"> </a>
<a name="ln2778">  *p = *p - 1;</a>
<a name="ln2779">  stackp = *p;</a>
<a name="ln2780">  if (stackp &lt; stack)</a>
<a name="ln2781">    return empty;</a>
<a name="ln2782">  return **p;</a>
<a name="ln2783">}</a>
<a name="ln2784"> </a>
<a name="ln2785">/*</a>
<a name="ln2786"> * Estimate the maximum byte length of anything matching &quot;state&quot;.</a>
<a name="ln2787"> * When unknown or unlimited return -1.</a>
<a name="ln2788"> */</a>
<a name="ln2789">static int nfa_max_width(nfa_state_T *startstate, int depth)</a>
<a name="ln2790">{</a>
<a name="ln2791">  int l, r;</a>
<a name="ln2792">  nfa_state_T     *state = startstate;</a>
<a name="ln2793">  int len = 0;</a>
<a name="ln2794"> </a>
<a name="ln2795">  /* detect looping in a NFA_SPLIT */</a>
<a name="ln2796">  if (depth &gt; 4)</a>
<a name="ln2797">    return -1;</a>
<a name="ln2798"> </a>
<a name="ln2799">  while (state != NULL) {</a>
<a name="ln2800">    switch (state-&gt;c) {</a>
<a name="ln2801">    case NFA_END_INVISIBLE:</a>
<a name="ln2802">    case NFA_END_INVISIBLE_NEG:</a>
<a name="ln2803">      /* the end, return what we have */</a>
<a name="ln2804">      return len;</a>
<a name="ln2805"> </a>
<a name="ln2806">    case NFA_SPLIT:</a>
<a name="ln2807">      /* two alternatives, use the maximum */</a>
<a name="ln2808">      l = nfa_max_width(state-&gt;out, depth + 1);</a>
<a name="ln2809">      r = nfa_max_width(state-&gt;out1, depth + 1);</a>
<a name="ln2810">      if (l &lt; 0 || r &lt; 0)</a>
<a name="ln2811">        return -1;</a>
<a name="ln2812">      return len + (l &gt; r ? l : r);</a>
<a name="ln2813"> </a>
<a name="ln2814">    case NFA_ANY:</a>
<a name="ln2815">    case NFA_START_COLL:</a>
<a name="ln2816">    case NFA_START_NEG_COLL:</a>
<a name="ln2817">      // Matches some character, including composing chars.</a>
<a name="ln2818">      len += MB_MAXBYTES;</a>
<a name="ln2819">      if (state-&gt;c != NFA_ANY) {</a>
<a name="ln2820">        // Skip over the characters.</a>
<a name="ln2821">        state = state-&gt;out1-&gt;out;</a>
<a name="ln2822">        continue;</a>
<a name="ln2823">      }</a>
<a name="ln2824">      break;</a>
<a name="ln2825"> </a>
<a name="ln2826">    case NFA_DIGIT:</a>
<a name="ln2827">    case NFA_WHITE:</a>
<a name="ln2828">    case NFA_HEX:</a>
<a name="ln2829">    case NFA_OCTAL:</a>
<a name="ln2830">      /* ascii */</a>
<a name="ln2831">      ++len;</a>
<a name="ln2832">      break;</a>
<a name="ln2833"> </a>
<a name="ln2834">    case NFA_IDENT:</a>
<a name="ln2835">    case NFA_SIDENT:</a>
<a name="ln2836">    case NFA_KWORD:</a>
<a name="ln2837">    case NFA_SKWORD:</a>
<a name="ln2838">    case NFA_FNAME:</a>
<a name="ln2839">    case NFA_SFNAME:</a>
<a name="ln2840">    case NFA_PRINT:</a>
<a name="ln2841">    case NFA_SPRINT:</a>
<a name="ln2842">    case NFA_NWHITE:</a>
<a name="ln2843">    case NFA_NDIGIT:</a>
<a name="ln2844">    case NFA_NHEX:</a>
<a name="ln2845">    case NFA_NOCTAL:</a>
<a name="ln2846">    case NFA_WORD:</a>
<a name="ln2847">    case NFA_NWORD:</a>
<a name="ln2848">    case NFA_HEAD:</a>
<a name="ln2849">    case NFA_NHEAD:</a>
<a name="ln2850">    case NFA_ALPHA:</a>
<a name="ln2851">    case NFA_NALPHA:</a>
<a name="ln2852">    case NFA_LOWER:</a>
<a name="ln2853">    case NFA_NLOWER:</a>
<a name="ln2854">    case NFA_UPPER:</a>
<a name="ln2855">    case NFA_NUPPER:</a>
<a name="ln2856">    case NFA_LOWER_IC:</a>
<a name="ln2857">    case NFA_NLOWER_IC:</a>
<a name="ln2858">    case NFA_UPPER_IC:</a>
<a name="ln2859">    case NFA_NUPPER_IC:</a>
<a name="ln2860">    case NFA_ANY_COMPOSING:</a>
<a name="ln2861">      // possibly non-ascii</a>
<a name="ln2862">      len += 3;</a>
<a name="ln2863">      break;</a>
<a name="ln2864"> </a>
<a name="ln2865">    case NFA_START_INVISIBLE:</a>
<a name="ln2866">    case NFA_START_INVISIBLE_NEG:</a>
<a name="ln2867">    case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln2868">    case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln2869">      /* zero-width, out1 points to the END state */</a>
<a name="ln2870">      state = state-&gt;out1-&gt;out;</a>
<a name="ln2871">      continue;</a>
<a name="ln2872"> </a>
<a name="ln2873">    case NFA_BACKREF1:</a>
<a name="ln2874">    case NFA_BACKREF2:</a>
<a name="ln2875">    case NFA_BACKREF3:</a>
<a name="ln2876">    case NFA_BACKREF4:</a>
<a name="ln2877">    case NFA_BACKREF5:</a>
<a name="ln2878">    case NFA_BACKREF6:</a>
<a name="ln2879">    case NFA_BACKREF7:</a>
<a name="ln2880">    case NFA_BACKREF8:</a>
<a name="ln2881">    case NFA_BACKREF9:</a>
<a name="ln2882">    case NFA_ZREF1:</a>
<a name="ln2883">    case NFA_ZREF2:</a>
<a name="ln2884">    case NFA_ZREF3:</a>
<a name="ln2885">    case NFA_ZREF4:</a>
<a name="ln2886">    case NFA_ZREF5:</a>
<a name="ln2887">    case NFA_ZREF6:</a>
<a name="ln2888">    case NFA_ZREF7:</a>
<a name="ln2889">    case NFA_ZREF8:</a>
<a name="ln2890">    case NFA_ZREF9:</a>
<a name="ln2891">    case NFA_NEWL:</a>
<a name="ln2892">    case NFA_SKIP:</a>
<a name="ln2893">      /* unknown width */</a>
<a name="ln2894">      return -1;</a>
<a name="ln2895"> </a>
<a name="ln2896">    case NFA_BOL:</a>
<a name="ln2897">    case NFA_EOL:</a>
<a name="ln2898">    case NFA_BOF:</a>
<a name="ln2899">    case NFA_EOF:</a>
<a name="ln2900">    case NFA_BOW:</a>
<a name="ln2901">    case NFA_EOW:</a>
<a name="ln2902">    case NFA_MOPEN:</a>
<a name="ln2903">    case NFA_MOPEN1:</a>
<a name="ln2904">    case NFA_MOPEN2:</a>
<a name="ln2905">    case NFA_MOPEN3:</a>
<a name="ln2906">    case NFA_MOPEN4:</a>
<a name="ln2907">    case NFA_MOPEN5:</a>
<a name="ln2908">    case NFA_MOPEN6:</a>
<a name="ln2909">    case NFA_MOPEN7:</a>
<a name="ln2910">    case NFA_MOPEN8:</a>
<a name="ln2911">    case NFA_MOPEN9:</a>
<a name="ln2912">    case NFA_ZOPEN:</a>
<a name="ln2913">    case NFA_ZOPEN1:</a>
<a name="ln2914">    case NFA_ZOPEN2:</a>
<a name="ln2915">    case NFA_ZOPEN3:</a>
<a name="ln2916">    case NFA_ZOPEN4:</a>
<a name="ln2917">    case NFA_ZOPEN5:</a>
<a name="ln2918">    case NFA_ZOPEN6:</a>
<a name="ln2919">    case NFA_ZOPEN7:</a>
<a name="ln2920">    case NFA_ZOPEN8:</a>
<a name="ln2921">    case NFA_ZOPEN9:</a>
<a name="ln2922">    case NFA_ZCLOSE:</a>
<a name="ln2923">    case NFA_ZCLOSE1:</a>
<a name="ln2924">    case NFA_ZCLOSE2:</a>
<a name="ln2925">    case NFA_ZCLOSE3:</a>
<a name="ln2926">    case NFA_ZCLOSE4:</a>
<a name="ln2927">    case NFA_ZCLOSE5:</a>
<a name="ln2928">    case NFA_ZCLOSE6:</a>
<a name="ln2929">    case NFA_ZCLOSE7:</a>
<a name="ln2930">    case NFA_ZCLOSE8:</a>
<a name="ln2931">    case NFA_ZCLOSE9:</a>
<a name="ln2932">    case NFA_MCLOSE:</a>
<a name="ln2933">    case NFA_MCLOSE1:</a>
<a name="ln2934">    case NFA_MCLOSE2:</a>
<a name="ln2935">    case NFA_MCLOSE3:</a>
<a name="ln2936">    case NFA_MCLOSE4:</a>
<a name="ln2937">    case NFA_MCLOSE5:</a>
<a name="ln2938">    case NFA_MCLOSE6:</a>
<a name="ln2939">    case NFA_MCLOSE7:</a>
<a name="ln2940">    case NFA_MCLOSE8:</a>
<a name="ln2941">    case NFA_MCLOSE9:</a>
<a name="ln2942">    case NFA_NOPEN:</a>
<a name="ln2943">    case NFA_NCLOSE:</a>
<a name="ln2944"> </a>
<a name="ln2945">    case NFA_LNUM_GT:</a>
<a name="ln2946">    case NFA_LNUM_LT:</a>
<a name="ln2947">    case NFA_COL_GT:</a>
<a name="ln2948">    case NFA_COL_LT:</a>
<a name="ln2949">    case NFA_VCOL_GT:</a>
<a name="ln2950">    case NFA_VCOL_LT:</a>
<a name="ln2951">    case NFA_MARK_GT:</a>
<a name="ln2952">    case NFA_MARK_LT:</a>
<a name="ln2953">    case NFA_VISUAL:</a>
<a name="ln2954">    case NFA_LNUM:</a>
<a name="ln2955">    case NFA_CURSOR:</a>
<a name="ln2956">    case NFA_COL:</a>
<a name="ln2957">    case NFA_VCOL:</a>
<a name="ln2958">    case NFA_MARK:</a>
<a name="ln2959"> </a>
<a name="ln2960">    case NFA_ZSTART:</a>
<a name="ln2961">    case NFA_ZEND:</a>
<a name="ln2962">    case NFA_OPT_CHARS:</a>
<a name="ln2963">    case NFA_EMPTY:</a>
<a name="ln2964">    case NFA_START_PATTERN:</a>
<a name="ln2965">    case NFA_END_PATTERN:</a>
<a name="ln2966">    case NFA_COMPOSING:</a>
<a name="ln2967">    case NFA_END_COMPOSING:</a>
<a name="ln2968">      /* zero-width */</a>
<a name="ln2969">      break;</a>
<a name="ln2970"> </a>
<a name="ln2971">    default:</a>
<a name="ln2972">      if (state-&gt;c &lt; 0)</a>
<a name="ln2973">        /* don't know what this is */</a>
<a name="ln2974">        return -1;</a>
<a name="ln2975">      /* normal character */</a>
<a name="ln2976">      len += MB_CHAR2LEN(state-&gt;c);</a>
<a name="ln2977">      break;</a>
<a name="ln2978">    }</a>
<a name="ln2979"> </a>
<a name="ln2980">    /* normal way to continue */</a>
<a name="ln2981">    state = state-&gt;out;</a>
<a name="ln2982">  }</a>
<a name="ln2983"> </a>
<a name="ln2984">  /* unrecognized, &quot;cannot happen&quot; */</a>
<a name="ln2985">  return -1;</a>
<a name="ln2986">}</a>
<a name="ln2987"> </a>
<a name="ln2988">/*</a>
<a name="ln2989"> * Convert a postfix form into its equivalent NFA.</a>
<a name="ln2990"> * Return the NFA start state on success, NULL otherwise.</a>
<a name="ln2991"> */</a>
<a name="ln2992">static nfa_state_T *post2nfa(int *postfix, int *end, int nfa_calc_size)</a>
<a name="ln2993">{</a>
<a name="ln2994">  int         *p;</a>
<a name="ln2995">  int mopen;</a>
<a name="ln2996">  int mclose;</a>
<a name="ln2997">  Frag_T      *stack = NULL;</a>
<a name="ln2998">  Frag_T      *stackp = NULL;</a>
<a name="ln2999">  Frag_T      *stack_end = NULL;</a>
<a name="ln3000">  Frag_T e1;</a>
<a name="ln3001">  Frag_T e2;</a>
<a name="ln3002">  Frag_T e;</a>
<a name="ln3003">  nfa_state_T *s;</a>
<a name="ln3004">  nfa_state_T *s1;</a>
<a name="ln3005">  nfa_state_T *matchstate;</a>
<a name="ln3006">  nfa_state_T *ret = NULL;</a>
<a name="ln3007"> </a>
<a name="ln3008">  if (postfix == NULL)</a>
<a name="ln3009">    return NULL;</a>
<a name="ln3010"> </a>
<a name="ln3011">#define PUSH(s)     st_push((s), &amp;stackp, stack_end)</a>
<a name="ln3012">#define POP()       st_pop(&amp;stackp, stack); \</a>
<a name="ln3013">  if (stackp &lt; stack) { \</a>
<a name="ln3014">    st_error(postfix, end, p); \</a>
<a name="ln3015">    xfree(stack); \</a>
<a name="ln3016">    return NULL; \</a>
<a name="ln3017">  }</a>
<a name="ln3018"> </a>
<a name="ln3019">  if (nfa_calc_size == false) {</a>
<a name="ln3020">    // Allocate space for the stack. Max states on the stack: &quot;nstate&quot;.</a>
<a name="ln3021">    stack = xmalloc((nstate + 1) * sizeof(Frag_T));</a>
<a name="ln3022">    stackp = stack;</a>
<a name="ln3023">    stack_end = stack + (nstate + 1);</a>
<a name="ln3024">  }</a>
<a name="ln3025"> </a>
<a name="ln3026">  for (p = postfix; p &lt; end; ++p) {</a>
<a name="ln3027">    switch (*p) {</a>
<a name="ln3028">    case NFA_CONCAT:</a>
<a name="ln3029">      // Concatenation.</a>
<a name="ln3030">      // Pay attention: this operator does not exist in the r.e. itself</a>
<a name="ln3031">      // (it is implicit, really).  It is added when r.e. is translated</a>
<a name="ln3032">      // to postfix form in re2post().</a>
<a name="ln3033">      if (nfa_calc_size == true) {</a>
<a name="ln3034">        // nstate += 0;</a>
<a name="ln3035">        break;</a>
<a name="ln3036">      }</a>
<a name="ln3037">      e2 = POP();</a>
<a name="ln3038">      e1 = POP();</a>
<a name="ln3039">      patch(e1.out, e2.start);</a>
<a name="ln3040">      PUSH(frag(e1.start, e2.out));</a>
<a name="ln3041">      break;</a>
<a name="ln3042"> </a>
<a name="ln3043">    case NFA_OR:</a>
<a name="ln3044">      // Alternation</a>
<a name="ln3045">      if (nfa_calc_size == true) {</a>
<a name="ln3046">        nstate++;</a>
<a name="ln3047">        break;</a>
<a name="ln3048">      }</a>
<a name="ln3049">      e2 = POP();</a>
<a name="ln3050">      e1 = POP();</a>
<a name="ln3051">      s = alloc_state(NFA_SPLIT, e1.start, e2.start);</a>
<a name="ln3052">      if (s == NULL)</a>
<a name="ln3053">        goto theend;</a>
<a name="ln3054">      PUSH(frag(s, append(e1.out, e2.out)));</a>
<a name="ln3055">      break;</a>
<a name="ln3056"> </a>
<a name="ln3057">    case NFA_STAR:</a>
<a name="ln3058">      // Zero or more, prefer more</a>
<a name="ln3059">      if (nfa_calc_size == true) {</a>
<a name="ln3060">        nstate++;</a>
<a name="ln3061">        break;</a>
<a name="ln3062">      }</a>
<a name="ln3063">      e = POP();</a>
<a name="ln3064">      s = alloc_state(NFA_SPLIT, e.start, NULL);</a>
<a name="ln3065">      if (s == NULL)</a>
<a name="ln3066">        goto theend;</a>
<a name="ln3067">      patch(e.out, s);</a>
<a name="ln3068">      PUSH(frag(s, list1(&amp;s-&gt;out1)));</a>
<a name="ln3069">      break;</a>
<a name="ln3070"> </a>
<a name="ln3071">    case NFA_STAR_NONGREEDY:</a>
<a name="ln3072">      // Zero or more, prefer zero</a>
<a name="ln3073">      if (nfa_calc_size == true) {</a>
<a name="ln3074">        nstate++;</a>
<a name="ln3075">        break;</a>
<a name="ln3076">      }</a>
<a name="ln3077">      e = POP();</a>
<a name="ln3078">      s = alloc_state(NFA_SPLIT, NULL, e.start);</a>
<a name="ln3079">      if (s == NULL)</a>
<a name="ln3080">        goto theend;</a>
<a name="ln3081">      patch(e.out, s);</a>
<a name="ln3082">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3083">      break;</a>
<a name="ln3084"> </a>
<a name="ln3085">    case NFA_QUEST:</a>
<a name="ln3086">      // one or zero atoms=&gt; greedy match</a>
<a name="ln3087">      if (nfa_calc_size == true) {</a>
<a name="ln3088">        nstate++;</a>
<a name="ln3089">        break;</a>
<a name="ln3090">      }</a>
<a name="ln3091">      e = POP();</a>
<a name="ln3092">      s = alloc_state(NFA_SPLIT, e.start, NULL);</a>
<a name="ln3093">      if (s == NULL)</a>
<a name="ln3094">        goto theend;</a>
<a name="ln3095">      PUSH(frag(s, append(e.out, list1(&amp;s-&gt;out1))));</a>
<a name="ln3096">      break;</a>
<a name="ln3097"> </a>
<a name="ln3098">    case NFA_QUEST_NONGREEDY:</a>
<a name="ln3099">      // zero or one atoms =&gt; non-greedy match</a>
<a name="ln3100">      if (nfa_calc_size == true) {</a>
<a name="ln3101">        nstate++;</a>
<a name="ln3102">        break;</a>
<a name="ln3103">      }</a>
<a name="ln3104">      e = POP();</a>
<a name="ln3105">      s = alloc_state(NFA_SPLIT, NULL, e.start);</a>
<a name="ln3106">      if (s == NULL)</a>
<a name="ln3107">        goto theend;</a>
<a name="ln3108">      PUSH(frag(s, append(e.out, list1(&amp;s-&gt;out))));</a>
<a name="ln3109">      break;</a>
<a name="ln3110"> </a>
<a name="ln3111">    case NFA_END_COLL:</a>
<a name="ln3112">    case NFA_END_NEG_COLL:</a>
<a name="ln3113">      /* On the stack is the sequence starting with NFA_START_COLL or</a>
<a name="ln3114">       * NFA_START_NEG_COLL and all possible characters. Patch it to</a>
<a name="ln3115">       * add the output to the start. */</a>
<a name="ln3116">      if (nfa_calc_size == true) {</a>
<a name="ln3117">        nstate++;</a>
<a name="ln3118">        break;</a>
<a name="ln3119">      }</a>
<a name="ln3120">      e = POP();</a>
<a name="ln3121">      s = alloc_state(NFA_END_COLL, NULL, NULL);</a>
<a name="ln3122">      if (s == NULL)</a>
<a name="ln3123">        goto theend;</a>
<a name="ln3124">      patch(e.out, s);</a>
<a name="ln3125">      e.start-&gt;out1 = s;</a>
<a name="ln3126">      PUSH(frag(e.start, list1(&amp;s-&gt;out)));</a>
<a name="ln3127">      break;</a>
<a name="ln3128"> </a>
<a name="ln3129">    case NFA_RANGE:</a>
<a name="ln3130">      // Before this are two characters, the low and high end of a</a>
<a name="ln3131">      // range.  Turn them into two states with MIN and MAX.</a>
<a name="ln3132">      if (nfa_calc_size == true) {</a>
<a name="ln3133">        // nstate += 0;</a>
<a name="ln3134">        break;</a>
<a name="ln3135">      }</a>
<a name="ln3136">      e2 = POP();</a>
<a name="ln3137">      e1 = POP();</a>
<a name="ln3138">      e2.start-&gt;val = e2.start-&gt;c;</a>
<a name="ln3139">      e2.start-&gt;c = NFA_RANGE_MAX;</a>
<a name="ln3140">      e1.start-&gt;val = e1.start-&gt;c;</a>
<a name="ln3141">      e1.start-&gt;c = NFA_RANGE_MIN;</a>
<a name="ln3142">      patch(e1.out, e2.start);</a>
<a name="ln3143">      PUSH(frag(e1.start, e2.out));</a>
<a name="ln3144">      break;</a>
<a name="ln3145"> </a>
<a name="ln3146">    case NFA_EMPTY:</a>
<a name="ln3147">      // 0-length, used in a repetition with max/min count of 0</a>
<a name="ln3148">      if (nfa_calc_size == true) {</a>
<a name="ln3149">        nstate++;</a>
<a name="ln3150">        break;</a>
<a name="ln3151">      }</a>
<a name="ln3152">      s = alloc_state(NFA_EMPTY, NULL, NULL);</a>
<a name="ln3153">      if (s == NULL)</a>
<a name="ln3154">        goto theend;</a>
<a name="ln3155">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3156">      break;</a>
<a name="ln3157"> </a>
<a name="ln3158">    case NFA_OPT_CHARS:</a>
<a name="ln3159">    {</a>
<a name="ln3160">      int n;</a>
<a name="ln3161"> </a>
<a name="ln3162">      // \%[abc] implemented as:</a>
<a name="ln3163">      //    NFA_SPLIT</a>
<a name="ln3164">      //    +-CHAR(a)</a>
<a name="ln3165">      //    | +-NFA_SPLIT</a>
<a name="ln3166">      //    |   +-CHAR(b)</a>
<a name="ln3167">      //    |   | +-NFA_SPLIT</a>
<a name="ln3168">      //    |   |   +-CHAR(c)</a>
<a name="ln3169">      //    |   |   | +-next</a>
<a name="ln3170">      //    |   |   +- next</a>
<a name="ln3171">      //    |   +- next</a>
<a name="ln3172">      //    +- next</a>
<a name="ln3173">      n = *++p;  // get number of characters</a>
<a name="ln3174">      if (nfa_calc_size == true) {</a>
<a name="ln3175">        nstate += n;</a>
<a name="ln3176">        break;</a>
<a name="ln3177">      }</a>
<a name="ln3178">      s = NULL;       /* avoid compiler warning */</a>
<a name="ln3179">      e1.out = NULL;       /* stores list with out1's */</a>
<a name="ln3180">      s1 = NULL;       /* previous NFA_SPLIT to connect to */</a>
<a name="ln3181">      while (n-- &gt; 0) {</a>
<a name="ln3182">        e = POP();         /* get character */</a>
<a name="ln3183">        s = alloc_state(NFA_SPLIT, e.start, NULL);</a>
<a name="ln3184">        if (s == NULL)</a>
<a name="ln3185">          goto theend;</a>
<a name="ln3186">        if (e1.out == NULL)</a>
<a name="ln3187">          e1 = e;</a>
<a name="ln3188">        patch(e.out, s1);</a>
<a name="ln3189">        append(e1.out, list1(&amp;s-&gt;out1));</a>
<a name="ln3190">        s1 = s;</a>
<a name="ln3191">      }</a>
<a name="ln3192">      PUSH(frag(s, e1.out));</a>
<a name="ln3193">      break;</a>
<a name="ln3194">    }</a>
<a name="ln3195"> </a>
<a name="ln3196">    case NFA_PREV_ATOM_NO_WIDTH:</a>
<a name="ln3197">    case NFA_PREV_ATOM_NO_WIDTH_NEG:</a>
<a name="ln3198">    case NFA_PREV_ATOM_JUST_BEFORE:</a>
<a name="ln3199">    case NFA_PREV_ATOM_JUST_BEFORE_NEG:</a>
<a name="ln3200">    case NFA_PREV_ATOM_LIKE_PATTERN:</a>
<a name="ln3201">    {</a>
<a name="ln3202">      int before = (*p == NFA_PREV_ATOM_JUST_BEFORE</a>
<a name="ln3203">                    || *p == NFA_PREV_ATOM_JUST_BEFORE_NEG);</a>
<a name="ln3204">      int pattern = (*p == NFA_PREV_ATOM_LIKE_PATTERN);</a>
<a name="ln3205">      int start_state;</a>
<a name="ln3206">      int end_state;</a>
<a name="ln3207">      int n = 0;</a>
<a name="ln3208">      nfa_state_T *zend;</a>
<a name="ln3209">      nfa_state_T *skip;</a>
<a name="ln3210"> </a>
<a name="ln3211">      switch (*p) {</a>
<a name="ln3212">      case NFA_PREV_ATOM_NO_WIDTH:</a>
<a name="ln3213">        start_state = NFA_START_INVISIBLE;</a>
<a name="ln3214">        end_state = NFA_END_INVISIBLE;</a>
<a name="ln3215">        break;</a>
<a name="ln3216">      case NFA_PREV_ATOM_NO_WIDTH_NEG:</a>
<a name="ln3217">        start_state = NFA_START_INVISIBLE_NEG;</a>
<a name="ln3218">        end_state = NFA_END_INVISIBLE_NEG;</a>
<a name="ln3219">        break;</a>
<a name="ln3220">      case NFA_PREV_ATOM_JUST_BEFORE:</a>
<a name="ln3221">        start_state = NFA_START_INVISIBLE_BEFORE;</a>
<a name="ln3222">        end_state = NFA_END_INVISIBLE;</a>
<a name="ln3223">        break;</a>
<a name="ln3224">      case NFA_PREV_ATOM_JUST_BEFORE_NEG:</a>
<a name="ln3225">        start_state = NFA_START_INVISIBLE_BEFORE_NEG;</a>
<a name="ln3226">        end_state = NFA_END_INVISIBLE_NEG;</a>
<a name="ln3227">        break;</a>
<a name="ln3228">      default:           /* NFA_PREV_ATOM_LIKE_PATTERN: */</a>
<a name="ln3229">        start_state = NFA_START_PATTERN;</a>
<a name="ln3230">        end_state = NFA_END_PATTERN;</a>
<a name="ln3231">        break;</a>
<a name="ln3232">      }</a>
<a name="ln3233"> </a>
<a name="ln3234">      if (before)</a>
<a name="ln3235">        n = *++p;         /* get the count */</a>
<a name="ln3236"> </a>
<a name="ln3237">      /* The \@= operator: match the preceding atom with zero width.</a>
<a name="ln3238">       * The \@! operator: no match for the preceding atom.</a>
<a name="ln3239">       * The \@&lt;= operator: match for the preceding atom.</a>
<a name="ln3240">       * The \@&lt;! operator: no match for the preceding atom.</a>
<a name="ln3241">       * Surrounds the preceding atom with START_INVISIBLE and</a>
<a name="ln3242">       * END_INVISIBLE, similarly to MOPEN. */</a>
<a name="ln3243"> </a>
<a name="ln3244">      if (nfa_calc_size == true) {</a>
<a name="ln3245">        nstate += pattern ? 4 : 2;</a>
<a name="ln3246">        break;</a>
<a name="ln3247">      }</a>
<a name="ln3248">      e = POP();</a>
<a name="ln3249">      s1 = alloc_state(end_state, NULL, NULL);</a>
<a name="ln3250">      if (s1 == NULL)</a>
<a name="ln3251">        goto theend;</a>
<a name="ln3252"> </a>
<a name="ln3253">      s = alloc_state(start_state, e.start, s1);</a>
<a name="ln3254">      if (s == NULL)</a>
<a name="ln3255">        goto theend;</a>
<a name="ln3256">      if (pattern) {</a>
<a name="ln3257">        /* NFA_ZEND -&gt; NFA_END_PATTERN -&gt; NFA_SKIP -&gt; what follows. */</a>
<a name="ln3258">        skip = alloc_state(NFA_SKIP, NULL, NULL);</a>
<a name="ln3259">        if (skip == NULL) {</a>
<a name="ln3260">          goto theend;</a>
<a name="ln3261">        }</a>
<a name="ln3262">        zend = alloc_state(NFA_ZEND, s1, NULL);</a>
<a name="ln3263">        if (zend == NULL) {</a>
<a name="ln3264">          goto theend;</a>
<a name="ln3265">        }</a>
<a name="ln3266">        s1-&gt;out= skip;</a>
<a name="ln3267">        patch(e.out, zend);</a>
<a name="ln3268">        PUSH(frag(s, list1(&amp;skip-&gt;out)));</a>
<a name="ln3269">      } else {</a>
<a name="ln3270">        patch(e.out, s1);</a>
<a name="ln3271">        PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3272">        if (before) {</a>
<a name="ln3273">          if (n &lt;= 0)</a>
<a name="ln3274">            /* See if we can guess the maximum width, it avoids a</a>
<a name="ln3275">             * lot of pointless tries. */</a>
<a name="ln3276">            n = nfa_max_width(e.start, 0);</a>
<a name="ln3277">          s-&gt;val = n;           /* store the count */</a>
<a name="ln3278">        }</a>
<a name="ln3279">      }</a>
<a name="ln3280">      break;</a>
<a name="ln3281">    }</a>
<a name="ln3282"> </a>
<a name="ln3283">    case NFA_COMPOSING:         // char with composing char</a>
<a name="ln3284">      FALLTHROUGH;</a>
<a name="ln3285"> </a>
<a name="ln3286">    case NFA_MOPEN:     /* \( \) Submatch */</a>
<a name="ln3287">    case NFA_MOPEN1:</a>
<a name="ln3288">    case NFA_MOPEN2:</a>
<a name="ln3289">    case NFA_MOPEN3:</a>
<a name="ln3290">    case NFA_MOPEN4:</a>
<a name="ln3291">    case NFA_MOPEN5:</a>
<a name="ln3292">    case NFA_MOPEN6:</a>
<a name="ln3293">    case NFA_MOPEN7:</a>
<a name="ln3294">    case NFA_MOPEN8:</a>
<a name="ln3295">    case NFA_MOPEN9:</a>
<a name="ln3296">    case NFA_ZOPEN:     /* \z( \) Submatch */</a>
<a name="ln3297">    case NFA_ZOPEN1:</a>
<a name="ln3298">    case NFA_ZOPEN2:</a>
<a name="ln3299">    case NFA_ZOPEN3:</a>
<a name="ln3300">    case NFA_ZOPEN4:</a>
<a name="ln3301">    case NFA_ZOPEN5:</a>
<a name="ln3302">    case NFA_ZOPEN6:</a>
<a name="ln3303">    case NFA_ZOPEN7:</a>
<a name="ln3304">    case NFA_ZOPEN8:</a>
<a name="ln3305">    case NFA_ZOPEN9:</a>
<a name="ln3306">    case NFA_NOPEN:     // \%( \) &quot;Invisible Submatch&quot;</a>
<a name="ln3307">      if (nfa_calc_size == true) {</a>
<a name="ln3308">        nstate += 2;</a>
<a name="ln3309">        break;</a>
<a name="ln3310">      }</a>
<a name="ln3311"> </a>
<a name="ln3312">      mopen = *p;</a>
<a name="ln3313">      switch (*p) {</a>
<a name="ln3314">      case NFA_NOPEN: mclose = NFA_NCLOSE; break;</a>
<a name="ln3315">      case NFA_ZOPEN: mclose = NFA_ZCLOSE; break;</a>
<a name="ln3316">      case NFA_ZOPEN1: mclose = NFA_ZCLOSE1; break;</a>
<a name="ln3317">      case NFA_ZOPEN2: mclose = NFA_ZCLOSE2; break;</a>
<a name="ln3318">      case NFA_ZOPEN3: mclose = NFA_ZCLOSE3; break;</a>
<a name="ln3319">      case NFA_ZOPEN4: mclose = NFA_ZCLOSE4; break;</a>
<a name="ln3320">      case NFA_ZOPEN5: mclose = NFA_ZCLOSE5; break;</a>
<a name="ln3321">      case NFA_ZOPEN6: mclose = NFA_ZCLOSE6; break;</a>
<a name="ln3322">      case NFA_ZOPEN7: mclose = NFA_ZCLOSE7; break;</a>
<a name="ln3323">      case NFA_ZOPEN8: mclose = NFA_ZCLOSE8; break;</a>
<a name="ln3324">      case NFA_ZOPEN9: mclose = NFA_ZCLOSE9; break;</a>
<a name="ln3325">      case NFA_COMPOSING: mclose = NFA_END_COMPOSING; break;</a>
<a name="ln3326">      default:</a>
<a name="ln3327">        /* NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9 */</a>
<a name="ln3328">        mclose = *p + NSUBEXP;</a>
<a name="ln3329">        break;</a>
<a name="ln3330">      }</a>
<a name="ln3331"> </a>
<a name="ln3332">      /* Allow &quot;NFA_MOPEN&quot; as a valid postfix representation for</a>
<a name="ln3333">       * the empty regexp &quot;&quot;. In this case, the NFA will be</a>
<a name="ln3334">       * NFA_MOPEN -&gt; NFA_MCLOSE. Note that this also allows</a>
<a name="ln3335">       * empty groups of parenthesis, and empty mbyte chars */</a>
<a name="ln3336">      if (stackp == stack) {</a>
<a name="ln3337">        s = alloc_state(mopen, NULL, NULL);</a>
<a name="ln3338">        if (s == NULL)</a>
<a name="ln3339">          goto theend;</a>
<a name="ln3340">        s1 = alloc_state(mclose, NULL, NULL);</a>
<a name="ln3341">        if (s1 == NULL)</a>
<a name="ln3342">          goto theend;</a>
<a name="ln3343">        patch(list1(&amp;s-&gt;out), s1);</a>
<a name="ln3344">        PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3345">        break;</a>
<a name="ln3346">      }</a>
<a name="ln3347"> </a>
<a name="ln3348">      /* At least one node was emitted before NFA_MOPEN, so</a>
<a name="ln3349">       * at least one node will be between NFA_MOPEN and NFA_MCLOSE */</a>
<a name="ln3350">      e = POP();</a>
<a name="ln3351">      s = alloc_state(mopen, e.start, NULL);         /* `(' */</a>
<a name="ln3352">      if (s == NULL)</a>
<a name="ln3353">        goto theend;</a>
<a name="ln3354"> </a>
<a name="ln3355">      s1 = alloc_state(mclose, NULL, NULL);         /* `)' */</a>
<a name="ln3356">      if (s1 == NULL)</a>
<a name="ln3357">        goto theend;</a>
<a name="ln3358">      patch(e.out, s1);</a>
<a name="ln3359"> </a>
<a name="ln3360">      if (mopen == NFA_COMPOSING)</a>
<a name="ln3361">        /* COMPOSING-&gt;out1 = END_COMPOSING */</a>
<a name="ln3362">        patch(list1(&amp;s-&gt;out1), s1);</a>
<a name="ln3363"> </a>
<a name="ln3364">      PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3365">      break;</a>
<a name="ln3366"> </a>
<a name="ln3367">    case NFA_BACKREF1:</a>
<a name="ln3368">    case NFA_BACKREF2:</a>
<a name="ln3369">    case NFA_BACKREF3:</a>
<a name="ln3370">    case NFA_BACKREF4:</a>
<a name="ln3371">    case NFA_BACKREF5:</a>
<a name="ln3372">    case NFA_BACKREF6:</a>
<a name="ln3373">    case NFA_BACKREF7:</a>
<a name="ln3374">    case NFA_BACKREF8:</a>
<a name="ln3375">    case NFA_BACKREF9:</a>
<a name="ln3376">    case NFA_ZREF1:</a>
<a name="ln3377">    case NFA_ZREF2:</a>
<a name="ln3378">    case NFA_ZREF3:</a>
<a name="ln3379">    case NFA_ZREF4:</a>
<a name="ln3380">    case NFA_ZREF5:</a>
<a name="ln3381">    case NFA_ZREF6:</a>
<a name="ln3382">    case NFA_ZREF7:</a>
<a name="ln3383">    case NFA_ZREF8:</a>
<a name="ln3384">    case NFA_ZREF9:</a>
<a name="ln3385">      if (nfa_calc_size == true) {</a>
<a name="ln3386">        nstate += 2;</a>
<a name="ln3387">        break;</a>
<a name="ln3388">      }</a>
<a name="ln3389">      s = alloc_state(*p, NULL, NULL);</a>
<a name="ln3390">      if (s == NULL)</a>
<a name="ln3391">        goto theend;</a>
<a name="ln3392">      s1 = alloc_state(NFA_SKIP, NULL, NULL);</a>
<a name="ln3393">      if (s1 == NULL)</a>
<a name="ln3394">        goto theend;</a>
<a name="ln3395">      patch(list1(&amp;s-&gt;out), s1);</a>
<a name="ln3396">      PUSH(frag(s, list1(&amp;s1-&gt;out)));</a>
<a name="ln3397">      break;</a>
<a name="ln3398"> </a>
<a name="ln3399">    case NFA_LNUM:</a>
<a name="ln3400">    case NFA_LNUM_GT:</a>
<a name="ln3401">    case NFA_LNUM_LT:</a>
<a name="ln3402">    case NFA_VCOL:</a>
<a name="ln3403">    case NFA_VCOL_GT:</a>
<a name="ln3404">    case NFA_VCOL_LT:</a>
<a name="ln3405">    case NFA_COL:</a>
<a name="ln3406">    case NFA_COL_GT:</a>
<a name="ln3407">    case NFA_COL_LT:</a>
<a name="ln3408">    case NFA_MARK:</a>
<a name="ln3409">    case NFA_MARK_GT:</a>
<a name="ln3410">    case NFA_MARK_LT:</a>
<a name="ln3411">    {</a>
<a name="ln3412">      int n = *++p;       /* lnum, col or mark name */</a>
<a name="ln3413"> </a>
<a name="ln3414">      if (nfa_calc_size == true) {</a>
<a name="ln3415">        nstate += 1;</a>
<a name="ln3416">        break;</a>
<a name="ln3417">      }</a>
<a name="ln3418">      s = alloc_state(p[-1], NULL, NULL);</a>
<a name="ln3419">      if (s == NULL)</a>
<a name="ln3420">        goto theend;</a>
<a name="ln3421">      s-&gt;val = n;</a>
<a name="ln3422">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3423">      break;</a>
<a name="ln3424">    }</a>
<a name="ln3425"> </a>
<a name="ln3426">    case NFA_ZSTART:</a>
<a name="ln3427">    case NFA_ZEND:</a>
<a name="ln3428">    default:</a>
<a name="ln3429">      // Operands</a>
<a name="ln3430">      if (nfa_calc_size == true) {</a>
<a name="ln3431">        nstate++;</a>
<a name="ln3432">        break;</a>
<a name="ln3433">      }</a>
<a name="ln3434">      s = alloc_state(*p, NULL, NULL);</a>
<a name="ln3435">      if (s == NULL)</a>
<a name="ln3436">        goto theend;</a>
<a name="ln3437">      PUSH(frag(s, list1(&amp;s-&gt;out)));</a>
<a name="ln3438">      break;</a>
<a name="ln3439"> </a>
<a name="ln3440">    }     /* switch(*p) */</a>
<a name="ln3441"> </a>
<a name="ln3442">  }   /* for(p = postfix; *p; ++p) */</a>
<a name="ln3443"> </a>
<a name="ln3444">  if (nfa_calc_size == true) {</a>
<a name="ln3445">    nstate++;</a>
<a name="ln3446">    goto theend;        /* Return value when counting size is ignored anyway */</a>
<a name="ln3447">  }</a>
<a name="ln3448"> </a>
<a name="ln3449">  e = POP();</a>
<a name="ln3450">  if (stackp != stack) {</a>
<a name="ln3451">    xfree(stack);</a>
<a name="ln3452">    EMSG_RET_NULL(_(&quot;E875: (NFA regexp) (While converting from postfix to NFA),&quot;</a>
<a name="ln3453">                    &quot;too many states left on stack&quot;));</a>
<a name="ln3454">  }</a>
<a name="ln3455"> </a>
<a name="ln3456">  if (istate &gt;= nstate) {</a>
<a name="ln3457">    xfree(stack);</a>
<a name="ln3458">    EMSG_RET_NULL(_(&quot;E876: (NFA regexp) &quot;</a>
<a name="ln3459">                    &quot;Not enough space to store the whole NFA &quot;));</a>
<a name="ln3460">  }</a>
<a name="ln3461"> </a>
<a name="ln3462">  matchstate = &amp;state_ptr[istate++];   /* the match state */</a>
<a name="ln3463">  matchstate-&gt;c = NFA_MATCH;</a>
<a name="ln3464">  matchstate-&gt;out = matchstate-&gt;out1 = NULL;</a>
<a name="ln3465">  matchstate-&gt;id = 0;</a>
<a name="ln3466"> </a>
<a name="ln3467">  patch(e.out, matchstate);</a>
<a name="ln3468">  ret = e.start;</a>
<a name="ln3469"> </a>
<a name="ln3470">theend:</a>
<a name="ln3471">  xfree(stack);</a>
<a name="ln3472">  return ret;</a>
<a name="ln3473"> </a>
<a name="ln3474">#undef POP1</a>
<a name="ln3475">#undef PUSH1</a>
<a name="ln3476">#undef POP2</a>
<a name="ln3477">#undef PUSH2</a>
<a name="ln3478">#undef POP</a>
<a name="ln3479">#undef PUSH</a>
<a name="ln3480">}</a>
<a name="ln3481"> </a>
<a name="ln3482">/*</a>
<a name="ln3483"> * After building the NFA program, inspect it to add optimization hints.</a>
<a name="ln3484"> */</a>
<a name="ln3485">static void nfa_postprocess(nfa_regprog_T *prog)</a>
<a name="ln3486">{</a>
<a name="ln3487">  int i;</a>
<a name="ln3488">  int c;</a>
<a name="ln3489"> </a>
<a name="ln3490">  for (i = 0; i &lt; prog-&gt;nstate; ++i) {</a>
<a name="ln3491">    c = prog-&gt;state[i].c;</a>
<a name="ln3492">    if (c == NFA_START_INVISIBLE</a>
<a name="ln3493">        || c == NFA_START_INVISIBLE_NEG</a>
<a name="ln3494">        || c == NFA_START_INVISIBLE_BEFORE</a>
<a name="ln3495">        || c == NFA_START_INVISIBLE_BEFORE_NEG) {</a>
<a name="ln3496">      int directly;</a>
<a name="ln3497"> </a>
<a name="ln3498">      // Do it directly when what follows is possibly the end of the</a>
<a name="ln3499">      // match.</a>
<a name="ln3500">      if (match_follows(prog-&gt;state[i].out1-&gt;out, 0)) {</a>
<a name="ln3501">        directly = true;</a>
<a name="ln3502">      } else {</a>
<a name="ln3503">        int ch_invisible = failure_chance(prog-&gt;state[i].out, 0);</a>
<a name="ln3504">        int ch_follows = failure_chance(prog-&gt;state[i].out1-&gt;out, 0);</a>
<a name="ln3505"> </a>
<a name="ln3506">        /* Postpone when the invisible match is expensive or has a</a>
<a name="ln3507">         * lower chance of failing. */</a>
<a name="ln3508">        if (c == NFA_START_INVISIBLE_BEFORE</a>
<a name="ln3509">            || c == NFA_START_INVISIBLE_BEFORE_NEG) {</a>
<a name="ln3510">          /* &quot;before&quot; matches are very expensive when</a>
<a name="ln3511">           * unbounded, always prefer what follows then,</a>
<a name="ln3512">           * unless what follows will always match.</a>
<a name="ln3513">           * Otherwise strongly prefer what follows. */</a>
<a name="ln3514">          if (prog-&gt;state[i].val &lt;= 0 &amp;&amp; ch_follows &gt; 0) {</a>
<a name="ln3515">            directly = false;</a>
<a name="ln3516">          } else {</a>
<a name="ln3517">            directly = ch_follows * 10 &lt; ch_invisible;</a>
<a name="ln3518">          }</a>
<a name="ln3519">        } else {</a>
<a name="ln3520">          /* normal invisible, first do the one with the</a>
<a name="ln3521">           * highest failure chance */</a>
<a name="ln3522">          directly = ch_follows &lt; ch_invisible;</a>
<a name="ln3523">        }</a>
<a name="ln3524">      }</a>
<a name="ln3525">      if (directly)</a>
<a name="ln3526">        /* switch to the _FIRST state */</a>
<a name="ln3527">        ++prog-&gt;state[i].c;</a>
<a name="ln3528">    }</a>
<a name="ln3529">  }</a>
<a name="ln3530">}</a>
<a name="ln3531"> </a>
<a name="ln3532">/****************************************************************</a>
<a name="ln3533">* NFA execution code.</a>
<a name="ln3534">****************************************************************/</a>
<a name="ln3535"> </a>
<a name="ln3536">/* Values for done in nfa_pim_T. */</a>
<a name="ln3537">#define NFA_PIM_UNUSED   0      /* pim not used */</a>
<a name="ln3538">#define NFA_PIM_TODO     1      /* pim not done yet */</a>
<a name="ln3539">#define NFA_PIM_MATCH    2      /* pim executed, matches */</a>
<a name="ln3540">#define NFA_PIM_NOMATCH  3      /* pim executed, no match */</a>
<a name="ln3541"> </a>
<a name="ln3542"> </a>
<a name="ln3543">#ifdef REGEXP_DEBUG</a>
<a name="ln3544">static void log_subsexpr(regsubs_T *subs)</a>
<a name="ln3545">{</a>
<a name="ln3546">  log_subexpr(&amp;subs-&gt;norm);</a>
<a name="ln3547">  if (rex.nfa_has_zsubexpr) {</a>
<a name="ln3548">    log_subexpr(&amp;subs-&gt;synt);</a>
<a name="ln3549">  }</a>
<a name="ln3550">}</a>
<a name="ln3551"> </a>
<a name="ln3552">static void log_subexpr(regsub_T *sub)</a>
<a name="ln3553">{</a>
<a name="ln3554">  int j;</a>
<a name="ln3555"> </a>
<a name="ln3556">  for (j = 0; j &lt; sub-&gt;in_use; j++)</a>
<a name="ln3557">    if (REG_MULTI)</a>
<a name="ln3558">      fprintf(log_fd, &quot;*** group %d, start: c=%d, l=%d, end: c=%d, l=%d\n&quot;,</a>
<a name="ln3559">          j,</a>
<a name="ln3560">          sub-&gt;list.multi[j].start_col,</a>
<a name="ln3561">          (int)sub-&gt;list.multi[j].start_lnum,</a>
<a name="ln3562">          sub-&gt;list.multi[j].end_col,</a>
<a name="ln3563">          (int)sub-&gt;list.multi[j].end_lnum);</a>
<a name="ln3564">    else {</a>
<a name="ln3565">      char *s = (char *)sub-&gt;list.line[j].start;</a>
<a name="ln3566">      char *e = (char *)sub-&gt;list.line[j].end;</a>
<a name="ln3567"> </a>
<a name="ln3568">      fprintf(log_fd, &quot;*** group %d, start: \&quot;%s\&quot;, end: \&quot;%s\&quot;\n&quot;,</a>
<a name="ln3569">          j,</a>
<a name="ln3570">          s == NULL ? &quot;NULL&quot; : s,</a>
<a name="ln3571">          e == NULL ? &quot;NULL&quot; : e);</a>
<a name="ln3572">    }</a>
<a name="ln3573">}</a>
<a name="ln3574"> </a>
<a name="ln3575">static char *pim_info(const nfa_pim_T *pim)</a>
<a name="ln3576">{</a>
<a name="ln3577">  static char buf[30];</a>
<a name="ln3578"> </a>
<a name="ln3579">  if (pim == NULL || pim-&gt;result == NFA_PIM_UNUSED) {</a>
<a name="ln3580">    buf[0] = NUL;</a>
<a name="ln3581">  } else {</a>
<a name="ln3582">    snprintf(buf, sizeof(buf), &quot; PIM col %d&quot;,</a>
<a name="ln3583">             REG_MULTI</a>
<a name="ln3584">             ? (int)pim-&gt;end.pos.col</a>
<a name="ln3585">             : (int)(pim-&gt;end.ptr - rex.input));</a>
<a name="ln3586">  }</a>
<a name="ln3587">  return buf;</a>
<a name="ln3588">}</a>
<a name="ln3589"> </a>
<a name="ln3590">#endif</a>
<a name="ln3591"> </a>
<a name="ln3592">// Used during execution: whether a match has been found.</a>
<a name="ln3593">static int nfa_match;</a>
<a name="ln3594">static proftime_T *nfa_time_limit;</a>
<a name="ln3595">static int *nfa_timed_out;</a>
<a name="ln3596">static int nfa_time_count;</a>
<a name="ln3597"> </a>
<a name="ln3598">// Copy postponed invisible match info from &quot;from&quot; to &quot;to&quot;.</a>
<a name="ln3599">static void copy_pim(nfa_pim_T *to, nfa_pim_T *from)</a>
<a name="ln3600">{</a>
<a name="ln3601">  to-&gt;result = from-&gt;result;</a>
<a name="ln3602">  to-&gt;state = from-&gt;state;</a>
<a name="ln3603">  copy_sub(&amp;to-&gt;subs.norm, &amp;from-&gt;subs.norm);</a>
<a name="ln3604">  if (rex.nfa_has_zsubexpr) {</a>
<a name="ln3605">    copy_sub(&amp;to-&gt;subs.synt, &amp;from-&gt;subs.synt);</a>
<a name="ln3606">  }</a>
<a name="ln3607">  to-&gt;end = from-&gt;end;</a>
<a name="ln3608">}</a>
<a name="ln3609"> </a>
<a name="ln3610">static void clear_sub(regsub_T *sub)</a>
<a name="ln3611">{</a>
<a name="ln3612">  if (REG_MULTI) {</a>
<a name="ln3613">    // Use 0xff to set lnum to -1</a>
<a name="ln3614">    memset(sub-&gt;list.multi, 0xff,</a>
<a name="ln3615">           sizeof(struct multipos) * rex.nfa_nsubexpr);</a>
<a name="ln3616">  } else {</a>
<a name="ln3617">    memset(sub-&gt;list.line, 0, sizeof(struct linepos) * rex.nfa_nsubexpr);</a>
<a name="ln3618">  }</a>
<a name="ln3619">  sub-&gt;in_use = 0;</a>
<a name="ln3620">}</a>
<a name="ln3621"> </a>
<a name="ln3622">/*</a>
<a name="ln3623"> * Copy the submatches from &quot;from&quot; to &quot;to&quot;.</a>
<a name="ln3624"> */</a>
<a name="ln3625">static void copy_sub(regsub_T *to, regsub_T *from)</a>
<a name="ln3626">{</a>
<a name="ln3627">  to-&gt;in_use = from-&gt;in_use;</a>
<a name="ln3628">  if (from-&gt;in_use &gt; 0) {</a>
<a name="ln3629">    /* Copy the match start and end positions. */</a>
<a name="ln3630">    if (REG_MULTI)</a>
<a name="ln3631">      memmove(&amp;to-&gt;list.multi[0],</a>
<a name="ln3632">          &amp;from-&gt;list.multi[0],</a>
<a name="ln3633">          sizeof(struct multipos) * from-&gt;in_use);</a>
<a name="ln3634">    else</a>
<a name="ln3635">      memmove(&amp;to-&gt;list.line[0],</a>
<a name="ln3636">          &amp;from-&gt;list.line[0],</a>
<a name="ln3637">          sizeof(struct linepos) * from-&gt;in_use);</a>
<a name="ln3638">  }</a>
<a name="ln3639">}</a>
<a name="ln3640"> </a>
<a name="ln3641">/*</a>
<a name="ln3642"> * Like copy_sub() but exclude the main match.</a>
<a name="ln3643"> */</a>
<a name="ln3644">static void copy_sub_off(regsub_T *to, regsub_T *from)</a>
<a name="ln3645">{</a>
<a name="ln3646">  if (to-&gt;in_use &lt; from-&gt;in_use)</a>
<a name="ln3647">    to-&gt;in_use = from-&gt;in_use;</a>
<a name="ln3648">  if (from-&gt;in_use &gt; 1) {</a>
<a name="ln3649">    /* Copy the match start and end positions. */</a>
<a name="ln3650">    if (REG_MULTI)</a>
<a name="ln3651">      memmove(&amp;to-&gt;list.multi[1],</a>
<a name="ln3652">          &amp;from-&gt;list.multi[1],</a>
<a name="ln3653">          sizeof(struct multipos) * (from-&gt;in_use - 1));</a>
<a name="ln3654">    else</a>
<a name="ln3655">      memmove(&amp;to-&gt;list.line[1],</a>
<a name="ln3656">          &amp;from-&gt;list.line[1],</a>
<a name="ln3657">          sizeof(struct linepos) * (from-&gt;in_use - 1));</a>
<a name="ln3658">  }</a>
<a name="ln3659">}</a>
<a name="ln3660"> </a>
<a name="ln3661">/*</a>
<a name="ln3662"> * Like copy_sub() but only do the end of the main match if \ze is present.</a>
<a name="ln3663"> */</a>
<a name="ln3664">static void copy_ze_off(regsub_T *to, regsub_T *from)</a>
<a name="ln3665">{</a>
<a name="ln3666">  if (rex.nfa_has_zend) {</a>
<a name="ln3667">    if (REG_MULTI) {</a>
<a name="ln3668">      if (from-&gt;list.multi[0].end_lnum &gt;= 0){</a>
<a name="ln3669">        to-&gt;list.multi[0].end_lnum = from-&gt;list.multi[0].end_lnum;</a>
<a name="ln3670">        to-&gt;list.multi[0].end_col = from-&gt;list.multi[0].end_col;</a>
<a name="ln3671">      }</a>
<a name="ln3672">    } else {</a>
<a name="ln3673">      if (from-&gt;list.line[0].end != NULL)</a>
<a name="ln3674">        to-&gt;list.line[0].end = from-&gt;list.line[0].end;</a>
<a name="ln3675">    }</a>
<a name="ln3676">  }</a>
<a name="ln3677">}</a>
<a name="ln3678"> </a>
<a name="ln3679">// Return true if &quot;sub1&quot; and &quot;sub2&quot; have the same start positions.</a>
<a name="ln3680">// When using back-references also check the end position.</a>
<a name="ln3681">static bool sub_equal(regsub_T *sub1, regsub_T *sub2)</a>
<a name="ln3682">{</a>
<a name="ln3683">  int i;</a>
<a name="ln3684">  int todo;</a>
<a name="ln3685">  linenr_T s1;</a>
<a name="ln3686">  linenr_T s2;</a>
<a name="ln3687">  char_u      *sp1;</a>
<a name="ln3688">  char_u      *sp2;</a>
<a name="ln3689"> </a>
<a name="ln3690">  todo = sub1-&gt;in_use &gt; sub2-&gt;in_use ? sub1-&gt;in_use : sub2-&gt;in_use;</a>
<a name="ln3691">  if (REG_MULTI) {</a>
<a name="ln3692">    for (i = 0; i &lt; todo; i++) {</a>
<a name="ln3693">      if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3694">        s1 = sub1-&gt;list.multi[i].start_lnum;</a>
<a name="ln3695">      } else {</a>
<a name="ln3696">        s1 = -1;</a>
<a name="ln3697">      }</a>
<a name="ln3698">      if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3699">        s2 = sub2-&gt;list.multi[i].start_lnum;</a>
<a name="ln3700">      } else {</a>
<a name="ln3701">        s2 = -1;</a>
<a name="ln3702">      }</a>
<a name="ln3703">      if (s1 != s2) {</a>
<a name="ln3704">        return false;</a>
<a name="ln3705">      }</a>
<a name="ln3706">      if (s1 != -1 &amp;&amp; sub1-&gt;list.multi[i].start_col</a>
<a name="ln3707">          != sub2-&gt;list.multi[i].start_col) {</a>
<a name="ln3708">        return false;</a>
<a name="ln3709">      }</a>
<a name="ln3710">      if (rex.nfa_has_backref) {</a>
<a name="ln3711">        if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3712">          s1 = sub1-&gt;list.multi[i].end_lnum;</a>
<a name="ln3713">        } else {</a>
<a name="ln3714">          s1 = -1;</a>
<a name="ln3715">        }</a>
<a name="ln3716">        if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3717">          s2 = sub2-&gt;list.multi[i].end_lnum;</a>
<a name="ln3718">        } else {</a>
<a name="ln3719">          s2 = -1;</a>
<a name="ln3720">        }</a>
<a name="ln3721">        if (s1 != s2) {</a>
<a name="ln3722">          return false;</a>
<a name="ln3723">        }</a>
<a name="ln3724">        if (s1 != -1</a>
<a name="ln3725">            &amp;&amp; sub1-&gt;list.multi[i].end_col != sub2-&gt;list.multi[i].end_col) {</a>
<a name="ln3726">          return false;</a>
<a name="ln3727">        }</a>
<a name="ln3728">      }</a>
<a name="ln3729">    }</a>
<a name="ln3730">  } else {</a>
<a name="ln3731">    for (i = 0; i &lt; todo; i++) {</a>
<a name="ln3732">      if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3733">        sp1 = sub1-&gt;list.line[i].start;</a>
<a name="ln3734">      } else {</a>
<a name="ln3735">        sp1 = NULL;</a>
<a name="ln3736">      }</a>
<a name="ln3737">      if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3738">        sp2 = sub2-&gt;list.line[i].start;</a>
<a name="ln3739">      } else {</a>
<a name="ln3740">        sp2 = NULL;</a>
<a name="ln3741">      }</a>
<a name="ln3742">      if (sp1 != sp2) {</a>
<a name="ln3743">        return false;</a>
<a name="ln3744">      }</a>
<a name="ln3745">      if (rex.nfa_has_backref) {</a>
<a name="ln3746">        if (i &lt; sub1-&gt;in_use) {</a>
<a name="ln3747">          sp1 = sub1-&gt;list.line[i].end;</a>
<a name="ln3748">        } else {</a>
<a name="ln3749">          sp1 = NULL;</a>
<a name="ln3750">        }</a>
<a name="ln3751">        if (i &lt; sub2-&gt;in_use) {</a>
<a name="ln3752">          sp2 = sub2-&gt;list.line[i].end;</a>
<a name="ln3753">        } else {</a>
<a name="ln3754">          sp2 = NULL;</a>
<a name="ln3755">        }</a>
<a name="ln3756">        if (sp1 != sp2) {</a>
<a name="ln3757">          return false;</a>
<a name="ln3758">        }</a>
<a name="ln3759">      }</a>
<a name="ln3760">    }</a>
<a name="ln3761">  }</a>
<a name="ln3762"> </a>
<a name="ln3763">  return true;</a>
<a name="ln3764">}</a>
<a name="ln3765"> </a>
<a name="ln3766">#ifdef REGEXP_DEBUG</a>
<a name="ln3767">static void report_state(char *action,</a>
<a name="ln3768">    regsub_T *sub,</a>
<a name="ln3769">    nfa_state_T *state,</a>
<a name="ln3770">    int lid,</a>
<a name="ln3771">    nfa_pim_T *pim) {</a>
<a name="ln3772">  int col;</a>
<a name="ln3773"> </a>
<a name="ln3774">  if (sub-&gt;in_use &lt;= 0) {</a>
<a name="ln3775">    col = -1;</a>
<a name="ln3776">  } else if (REG_MULTI) {</a>
<a name="ln3777">    col = sub-&gt;list.multi[0].start_col;</a>
<a name="ln3778">  } else {</a>
<a name="ln3779">    col = (int)(sub-&gt;list.line[0].start - rex.line);</a>
<a name="ln3780">  }</a>
<a name="ln3781">  nfa_set_code(state-&gt;c);</a>
<a name="ln3782">  fprintf(log_fd, &quot;&gt; %s state %d to list %d. char %d: %s (start col %d)%s\n&quot;,</a>
<a name="ln3783">          action, abs(state-&gt;id), lid, state-&gt;c, code, col,</a>
<a name="ln3784">          pim_info(pim));</a>
<a name="ln3785">}</a>
<a name="ln3786"> </a>
<a name="ln3787">#endif</a>
<a name="ln3788"> </a>
<a name="ln3789">// Return true if the same state is already in list &quot;l&quot; with the same</a>
<a name="ln3790">// positions as &quot;subs&quot;.</a>
<a name="ln3791">static bool has_state_with_pos(</a>
<a name="ln3792">    nfa_list_T *l,        // runtime state list</a>
<a name="ln3793">    nfa_state_T *state,   // state to update</a>
<a name="ln3794">    regsubs_T *subs,      // pointers to subexpressions</a>
<a name="ln3795">    nfa_pim_T *pim        // postponed match or NULL</a>
<a name="ln3796">)</a>
<a name="ln3797">  FUNC_ATTR_NONNULL_ARG(1, 2, 3)</a>
<a name="ln3798">{</a>
<a name="ln3799">  for (int i = 0; i &lt; l-&gt;n; i++) {</a>
<a name="ln3800">    nfa_thread_T *thread = &amp;l-&gt;t[i];</a>
<a name="ln3801">    if (thread-&gt;state-&gt;id == state-&gt;id</a>
<a name="ln3802">        &amp;&amp; sub_equal(&amp;thread-&gt;subs.norm, &amp;subs-&gt;norm)</a>
<a name="ln3803">        &amp;&amp; (!rex.nfa_has_zsubexpr</a>
<a name="ln3804">            || sub_equal(&amp;thread-&gt;subs.synt, &amp;subs-&gt;synt))</a>
<a name="ln3805">        &amp;&amp; pim_equal(&amp;thread-&gt;pim, pim)) {</a>
<a name="ln3806">      return true;</a>
<a name="ln3807">    }</a>
<a name="ln3808">  }</a>
<a name="ln3809">  return false;</a>
<a name="ln3810">}</a>
<a name="ln3811"> </a>
<a name="ln3812">// Return true if &quot;one&quot; and &quot;two&quot; are equal.  That includes when both are not</a>
<a name="ln3813">// set.</a>
<a name="ln3814">static bool pim_equal(const nfa_pim_T *one, const nfa_pim_T *two)</a>
<a name="ln3815">{</a>
<a name="ln3816">  const bool one_unused = (one == NULL || one-&gt;result == NFA_PIM_UNUSED);</a>
<a name="ln3817">  const bool two_unused = (two == NULL || two-&gt;result == NFA_PIM_UNUSED);</a>
<a name="ln3818"> </a>
<a name="ln3819">  if (one_unused) {</a>
<a name="ln3820">    // one is unused: equal when two is also unused</a>
<a name="ln3821">    return two_unused;</a>
<a name="ln3822">  }</a>
<a name="ln3823">  if (two_unused) {</a>
<a name="ln3824">    // one is used and two is not: not equal</a>
<a name="ln3825">    return false;</a>
<a name="ln3826">  }</a>
<a name="ln3827">  // compare the state id</a>
<a name="ln3828">  if (one-&gt;state-&gt;id != two-&gt;state-&gt;id) {</a>
<a name="ln3829">    return false;</a>
<a name="ln3830">  }</a>
<a name="ln3831">  // compare the position</a>
<a name="ln3832">  if (REG_MULTI) {</a>
<a name="ln3833">    return one-&gt;end.pos.lnum == two-&gt;end.pos.lnum</a>
<a name="ln3834">           &amp;&amp; one-&gt;end.pos.col == two-&gt;end.pos.col;</a>
<a name="ln3835">  }</a>
<a name="ln3836">  return one-&gt;end.ptr == two-&gt;end.ptr;</a>
<a name="ln3837">}</a>
<a name="ln3838"> </a>
<a name="ln3839">// Return true if &quot;state&quot; leads to a NFA_MATCH without advancing the input.</a>
<a name="ln3840">static bool match_follows(const nfa_state_T *startstate, int depth)</a>
<a name="ln3841">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3842">{</a>
<a name="ln3843">  const nfa_state_T *state = startstate;</a>
<a name="ln3844"> </a>
<a name="ln3845">  // avoid too much recursion</a>
<a name="ln3846">  if (depth &gt; 10) {</a>
<a name="ln3847">    return false;</a>
<a name="ln3848">  }</a>
<a name="ln3849">  while (state != NULL) {</a>
<a name="ln3850">    switch (state-&gt;c) {</a>
<a name="ln3851">    case NFA_MATCH:</a>
<a name="ln3852">    case NFA_MCLOSE:</a>
<a name="ln3853">    case NFA_END_INVISIBLE:</a>
<a name="ln3854">    case NFA_END_INVISIBLE_NEG:</a>
<a name="ln3855">    case NFA_END_PATTERN:</a>
<a name="ln3856">      return true;</a>
<a name="ln3857"> </a>
<a name="ln3858">    case NFA_SPLIT:</a>
<a name="ln3859">      return match_follows(state-&gt;out, depth + 1)</a>
<a name="ln3860">             || match_follows(state-&gt;out1, depth + 1);</a>
<a name="ln3861"> </a>
<a name="ln3862">    case NFA_START_INVISIBLE:</a>
<a name="ln3863">    case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln3864">    case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln3865">    case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln3866">    case NFA_START_INVISIBLE_NEG:</a>
<a name="ln3867">    case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln3868">    case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln3869">    case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln3870">    case NFA_COMPOSING:</a>
<a name="ln3871">      /* skip ahead to next state */</a>
<a name="ln3872">      state = state-&gt;out1-&gt;out;</a>
<a name="ln3873">      continue;</a>
<a name="ln3874"> </a>
<a name="ln3875">    case NFA_ANY:</a>
<a name="ln3876">    case NFA_ANY_COMPOSING:</a>
<a name="ln3877">    case NFA_IDENT:</a>
<a name="ln3878">    case NFA_SIDENT:</a>
<a name="ln3879">    case NFA_KWORD:</a>
<a name="ln3880">    case NFA_SKWORD:</a>
<a name="ln3881">    case NFA_FNAME:</a>
<a name="ln3882">    case NFA_SFNAME:</a>
<a name="ln3883">    case NFA_PRINT:</a>
<a name="ln3884">    case NFA_SPRINT:</a>
<a name="ln3885">    case NFA_WHITE:</a>
<a name="ln3886">    case NFA_NWHITE:</a>
<a name="ln3887">    case NFA_DIGIT:</a>
<a name="ln3888">    case NFA_NDIGIT:</a>
<a name="ln3889">    case NFA_HEX:</a>
<a name="ln3890">    case NFA_NHEX:</a>
<a name="ln3891">    case NFA_OCTAL:</a>
<a name="ln3892">    case NFA_NOCTAL:</a>
<a name="ln3893">    case NFA_WORD:</a>
<a name="ln3894">    case NFA_NWORD:</a>
<a name="ln3895">    case NFA_HEAD:</a>
<a name="ln3896">    case NFA_NHEAD:</a>
<a name="ln3897">    case NFA_ALPHA:</a>
<a name="ln3898">    case NFA_NALPHA:</a>
<a name="ln3899">    case NFA_LOWER:</a>
<a name="ln3900">    case NFA_NLOWER:</a>
<a name="ln3901">    case NFA_UPPER:</a>
<a name="ln3902">    case NFA_NUPPER:</a>
<a name="ln3903">    case NFA_LOWER_IC:</a>
<a name="ln3904">    case NFA_NLOWER_IC:</a>
<a name="ln3905">    case NFA_UPPER_IC:</a>
<a name="ln3906">    case NFA_NUPPER_IC:</a>
<a name="ln3907">    case NFA_START_COLL:</a>
<a name="ln3908">    case NFA_START_NEG_COLL:</a>
<a name="ln3909">    case NFA_NEWL:</a>
<a name="ln3910">      // state will advance input</a>
<a name="ln3911">      return false;</a>
<a name="ln3912"> </a>
<a name="ln3913">    default:</a>
<a name="ln3914">      if (state-&gt;c &gt; 0) {</a>
<a name="ln3915">        // state will advance input</a>
<a name="ln3916">        return false;</a>
<a name="ln3917">      }</a>
<a name="ln3918">      // Others: zero-width or possibly zero-width, might still find</a>
<a name="ln3919">      // a match at the same position, keep looking.</a>
<a name="ln3920">      break;</a>
<a name="ln3921">    }</a>
<a name="ln3922">    state = state-&gt;out;</a>
<a name="ln3923">  }</a>
<a name="ln3924">  return false;</a>
<a name="ln3925">}</a>
<a name="ln3926"> </a>
<a name="ln3927"> </a>
<a name="ln3928">// Return true if &quot;state&quot; is already in list &quot;l&quot;.</a>
<a name="ln3929">static bool state_in_list(</a>
<a name="ln3930">    nfa_list_T *l,        // runtime state list</a>
<a name="ln3931">    nfa_state_T *state,   // state to update</a>
<a name="ln3932">    regsubs_T *subs       // pointers to subexpressions</a>
<a name="ln3933">)</a>
<a name="ln3934">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3935">{</a>
<a name="ln3936">  if (state-&gt;lastlist[nfa_ll_index] == l-&gt;id) {</a>
<a name="ln3937">    if (!rex.nfa_has_backref || has_state_with_pos(l, state, subs, NULL)) {</a>
<a name="ln3938">      return true;</a>
<a name="ln3939">    }</a>
<a name="ln3940">  }</a>
<a name="ln3941">  return false;</a>
<a name="ln3942">}</a>
<a name="ln3943"> </a>
<a name="ln3944">// Offset used for &quot;off&quot; by addstate_here().</a>
<a name="ln3945">#define ADDSTATE_HERE_OFFSET 10</a>
<a name="ln3946"> </a>
<a name="ln3947">// Add &quot;state&quot; and possibly what follows to state list &quot;.&quot;.</a>
<a name="ln3948">// Returns &quot;subs_arg&quot;, possibly copied into temp_subs.</a>
<a name="ln3949">// Returns NULL when recursiveness is too deep.</a>
<a name="ln3950">static regsubs_T *addstate(</a>
<a name="ln3951">    nfa_list_T *l,        // runtime state list</a>
<a name="ln3952">    nfa_state_T *state,   // state to update</a>
<a name="ln3953">    regsubs_T *subs_arg,  // pointers to subexpressions</a>
<a name="ln3954">    nfa_pim_T *pim,       // postponed look-behind match</a>
<a name="ln3955">    int off_arg)          // byte offset, when -1 go to next line</a>
<a name="ln3956">  FUNC_ATTR_NONNULL_ARG(1, 2) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3957">{</a>
<a name="ln3958">  int subidx;</a>
<a name="ln3959">  int off = off_arg;</a>
<a name="ln3960">  int add_here = false;</a>
<a name="ln3961">  int listindex = 0;</a>
<a name="ln3962">  int k;</a>
<a name="ln3963">  int found = false;</a>
<a name="ln3964">  nfa_thread_T        *thread;</a>
<a name="ln3965">  struct multipos     save_multipos;</a>
<a name="ln3966">  int save_in_use;</a>
<a name="ln3967">  char_u              *save_ptr;</a>
<a name="ln3968">  int i;</a>
<a name="ln3969">  regsub_T            *sub;</a>
<a name="ln3970">  regsubs_T           *subs = subs_arg;</a>
<a name="ln3971">  static regsubs_T temp_subs;</a>
<a name="ln3972">#ifdef REGEXP_DEBUG</a>
<a name="ln3973">  int did_print = false;</a>
<a name="ln3974">#endif</a>
<a name="ln3975">  static int depth = 0;</a>
<a name="ln3976"> </a>
<a name="ln3977">  // This function is called recursively.  When the depth is too much we run</a>
<a name="ln3978">  // out of stack and crash, limit recursiveness here.</a>
<a name="ln3979">  if (++depth &gt;= 5000 || subs == NULL) {</a>
<a name="ln3980">    depth--;</a>
<a name="ln3981">    return NULL;</a>
<a name="ln3982">  }</a>
<a name="ln3983"> </a>
<a name="ln3984">  if (off_arg &lt;= -ADDSTATE_HERE_OFFSET) {</a>
<a name="ln3985">    add_here = true;</a>
<a name="ln3986">    off = 0;</a>
<a name="ln3987">    listindex = -(off_arg + ADDSTATE_HERE_OFFSET);</a>
<a name="ln3988">  }</a>
<a name="ln3989"> </a>
<a name="ln3990">  switch (state-&gt;c) {</a>
<a name="ln3991">  case NFA_NCLOSE:</a>
<a name="ln3992">  case NFA_MCLOSE:</a>
<a name="ln3993">  case NFA_MCLOSE1:</a>
<a name="ln3994">  case NFA_MCLOSE2:</a>
<a name="ln3995">  case NFA_MCLOSE3:</a>
<a name="ln3996">  case NFA_MCLOSE4:</a>
<a name="ln3997">  case NFA_MCLOSE5:</a>
<a name="ln3998">  case NFA_MCLOSE6:</a>
<a name="ln3999">  case NFA_MCLOSE7:</a>
<a name="ln4000">  case NFA_MCLOSE8:</a>
<a name="ln4001">  case NFA_MCLOSE9:</a>
<a name="ln4002">  case NFA_ZCLOSE:</a>
<a name="ln4003">  case NFA_ZCLOSE1:</a>
<a name="ln4004">  case NFA_ZCLOSE2:</a>
<a name="ln4005">  case NFA_ZCLOSE3:</a>
<a name="ln4006">  case NFA_ZCLOSE4:</a>
<a name="ln4007">  case NFA_ZCLOSE5:</a>
<a name="ln4008">  case NFA_ZCLOSE6:</a>
<a name="ln4009">  case NFA_ZCLOSE7:</a>
<a name="ln4010">  case NFA_ZCLOSE8:</a>
<a name="ln4011">  case NFA_ZCLOSE9:</a>
<a name="ln4012">  case NFA_MOPEN:</a>
<a name="ln4013">  case NFA_ZEND:</a>
<a name="ln4014">  case NFA_SPLIT:</a>
<a name="ln4015">  case NFA_EMPTY:</a>
<a name="ln4016">    /* These nodes are not added themselves but their &quot;out&quot; and/or</a>
<a name="ln4017">     * &quot;out1&quot; may be added below.  */</a>
<a name="ln4018">    break;</a>
<a name="ln4019"> </a>
<a name="ln4020">  case NFA_BOL:</a>
<a name="ln4021">  case NFA_BOF:</a>
<a name="ln4022">    // &quot;^&quot; won't match past end-of-line, don't bother trying.</a>
<a name="ln4023">    // Except when at the end of the line, or when we are going to the</a>
<a name="ln4024">    // next line for a look-behind match.</a>
<a name="ln4025">    if (rex.input &gt; rex.line</a>
<a name="ln4026">        &amp;&amp; *rex.input != NUL</a>
<a name="ln4027">        &amp;&amp; (nfa_endp == NULL</a>
<a name="ln4028">            || !REG_MULTI</a>
<a name="ln4029">            || rex.lnum == nfa_endp-&gt;se_u.pos.lnum)) {</a>
<a name="ln4030">      goto skip_add;</a>
<a name="ln4031">    }</a>
<a name="ln4032">    FALLTHROUGH;</a>
<a name="ln4033"> </a>
<a name="ln4034">  case NFA_MOPEN1:</a>
<a name="ln4035">  case NFA_MOPEN2:</a>
<a name="ln4036">  case NFA_MOPEN3:</a>
<a name="ln4037">  case NFA_MOPEN4:</a>
<a name="ln4038">  case NFA_MOPEN5:</a>
<a name="ln4039">  case NFA_MOPEN6:</a>
<a name="ln4040">  case NFA_MOPEN7:</a>
<a name="ln4041">  case NFA_MOPEN8:</a>
<a name="ln4042">  case NFA_MOPEN9:</a>
<a name="ln4043">  case NFA_ZOPEN:</a>
<a name="ln4044">  case NFA_ZOPEN1:</a>
<a name="ln4045">  case NFA_ZOPEN2:</a>
<a name="ln4046">  case NFA_ZOPEN3:</a>
<a name="ln4047">  case NFA_ZOPEN4:</a>
<a name="ln4048">  case NFA_ZOPEN5:</a>
<a name="ln4049">  case NFA_ZOPEN6:</a>
<a name="ln4050">  case NFA_ZOPEN7:</a>
<a name="ln4051">  case NFA_ZOPEN8:</a>
<a name="ln4052">  case NFA_ZOPEN9:</a>
<a name="ln4053">  case NFA_NOPEN:</a>
<a name="ln4054">  case NFA_ZSTART:</a>
<a name="ln4055">  /* These nodes need to be added so that we can bail out when it</a>
<a name="ln4056">   * was added to this list before at the same position to avoid an</a>
<a name="ln4057">   * endless loop for &quot;\(\)*&quot; */</a>
<a name="ln4058"> </a>
<a name="ln4059">  default:</a>
<a name="ln4060">    if (state-&gt;lastlist[nfa_ll_index] == l-&gt;id &amp;&amp; state-&gt;c != NFA_SKIP) {</a>
<a name="ln4061">      /* This state is already in the list, don't add it again,</a>
<a name="ln4062">       * unless it is an MOPEN that is used for a backreference or</a>
<a name="ln4063">       * when there is a PIM. For NFA_MATCH check the position,</a>
<a name="ln4064">       * lower position is preferred. */</a>
<a name="ln4065">      if (!rex.nfa_has_backref &amp;&amp; pim == NULL &amp;&amp; !l-&gt;has_pim</a>
<a name="ln4066">          &amp;&amp; state-&gt;c != NFA_MATCH) {</a>
<a name="ln4067"> </a>
<a name="ln4068">        /* When called from addstate_here() do insert before</a>
<a name="ln4069">         * existing states. */</a>
<a name="ln4070">        if (add_here) {</a>
<a name="ln4071">          for (k = 0; k &lt; l-&gt;n &amp;&amp; k &lt; listindex; ++k) {</a>
<a name="ln4072">            if (l-&gt;t[k].state-&gt;id == state-&gt;id) {</a>
<a name="ln4073">              found = true;</a>
<a name="ln4074">              break;</a>
<a name="ln4075">            }</a>
<a name="ln4076">          }</a>
<a name="ln4077">        }</a>
<a name="ln4078"> </a>
<a name="ln4079">        if (!add_here || found) {</a>
<a name="ln4080">skip_add:</a>
<a name="ln4081">#ifdef REGEXP_DEBUG</a>
<a name="ln4082">          nfa_set_code(state-&gt;c);</a>
<a name="ln4083">          fprintf(log_fd, &quot;&gt; Not adding state %d to list %d. char %d: %s pim: %s has_pim: %d found: %d\n&quot;,</a>
<a name="ln4084">                  abs(state-&gt;id), l-&gt;id, state-&gt;c, code,</a>
<a name="ln4085">                  pim == NULL ? &quot;NULL&quot; : &quot;yes&quot;, l-&gt;has_pim, found);</a>
<a name="ln4086">#endif</a>
<a name="ln4087">        depth--;</a>
<a name="ln4088">        return subs;</a>
<a name="ln4089">        }</a>
<a name="ln4090">      }</a>
<a name="ln4091"> </a>
<a name="ln4092">      /* Do not add the state again when it exists with the same</a>
<a name="ln4093">       * positions. */</a>
<a name="ln4094">      if (has_state_with_pos(l, state, subs, pim))</a>
<a name="ln4095">        goto skip_add;</a>
<a name="ln4096">    }</a>
<a name="ln4097"> </a>
<a name="ln4098">    // When there are backreferences or PIMs the number of states may</a>
<a name="ln4099">    // be (a lot) bigger than anticipated.</a>
<a name="ln4100">    if (l-&gt;n == l-&gt;len) {</a>
<a name="ln4101">      const int newlen = l-&gt;len * 3 / 2 + 50;</a>
<a name="ln4102">      const size_t newsize = newlen * sizeof(nfa_thread_T);</a>
<a name="ln4103"> </a>
<a name="ln4104">      if ((long)(newsize &gt;&gt; 10) &gt;= p_mmp) {</a>
<a name="ln4105">        EMSG(_(e_maxmempat));</a>
<a name="ln4106">        depth--;</a>
<a name="ln4107">        return NULL;</a>
<a name="ln4108">      }</a>
<a name="ln4109">      if (subs != &amp;temp_subs) {</a>
<a name="ln4110">        // &quot;subs&quot; may point into the current array, need to make a</a>
<a name="ln4111">        // copy before it becomes invalid.</a>
<a name="ln4112">        copy_sub(&amp;temp_subs.norm, &amp;subs-&gt;norm);</a>
<a name="ln4113">        if (rex.nfa_has_zsubexpr) {</a>
<a name="ln4114">          copy_sub(&amp;temp_subs.synt, &amp;subs-&gt;synt);</a>
<a name="ln4115">        }</a>
<a name="ln4116">        subs = &amp;temp_subs;</a>
<a name="ln4117">      }</a>
<a name="ln4118"> </a>
<a name="ln4119">      nfa_thread_T *const newt = xrealloc(l-&gt;t, newsize);</a>
<a name="ln4120">      l-&gt;t = newt;</a>
<a name="ln4121">      l-&gt;len = newlen;</a>
<a name="ln4122">    }</a>
<a name="ln4123"> </a>
<a name="ln4124">    /* add the state to the list */</a>
<a name="ln4125">    state-&gt;lastlist[nfa_ll_index] = l-&gt;id;</a>
<a name="ln4126">    thread = &amp;l-&gt;t[l-&gt;n++];</a>
<a name="ln4127">    thread-&gt;state = state;</a>
<a name="ln4128">    if (pim == NULL)</a>
<a name="ln4129">      thread-&gt;pim.result = NFA_PIM_UNUSED;</a>
<a name="ln4130">    else {</a>
<a name="ln4131">      copy_pim(&amp;thread-&gt;pim, pim);</a>
<a name="ln4132">      l-&gt;has_pim = true;</a>
<a name="ln4133">    }</a>
<a name="ln4134">    copy_sub(&amp;thread-&gt;subs.norm, &amp;subs-&gt;norm);</a>
<a name="ln4135">    if (rex.nfa_has_zsubexpr) {</a>
<a name="ln4136">      copy_sub(&amp;thread-&gt;subs.synt, &amp;subs-&gt;synt);</a>
<a name="ln4137">    }</a>
<a name="ln4138">#ifdef REGEXP_DEBUG</a>
<a name="ln4139">    report_state(&quot;Adding&quot;, &amp;thread-&gt;subs.norm, state, l-&gt;id, pim);</a>
<a name="ln4140">    did_print = true;</a>
<a name="ln4141">#endif</a>
<a name="ln4142">  }</a>
<a name="ln4143"> </a>
<a name="ln4144">#ifdef REGEXP_DEBUG</a>
<a name="ln4145">  if (!did_print)</a>
<a name="ln4146">    report_state(&quot;Processing&quot;, &amp;subs-&gt;norm, state, l-&gt;id, pim);</a>
<a name="ln4147">#endif</a>
<a name="ln4148">  switch (state-&gt;c) {</a>
<a name="ln4149">  case NFA_MATCH:</a>
<a name="ln4150">    break;</a>
<a name="ln4151"> </a>
<a name="ln4152">  case NFA_SPLIT:</a>
<a name="ln4153">    /* order matters here */</a>
<a name="ln4154">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4155">    subs = addstate(l, state-&gt;out1, subs, pim, off_arg);</a>
<a name="ln4156">    break;</a>
<a name="ln4157"> </a>
<a name="ln4158">  case NFA_EMPTY:</a>
<a name="ln4159">  case NFA_NOPEN:</a>
<a name="ln4160">  case NFA_NCLOSE:</a>
<a name="ln4161">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4162">    break;</a>
<a name="ln4163"> </a>
<a name="ln4164">  case NFA_MOPEN:</a>
<a name="ln4165">  case NFA_MOPEN1:</a>
<a name="ln4166">  case NFA_MOPEN2:</a>
<a name="ln4167">  case NFA_MOPEN3:</a>
<a name="ln4168">  case NFA_MOPEN4:</a>
<a name="ln4169">  case NFA_MOPEN5:</a>
<a name="ln4170">  case NFA_MOPEN6:</a>
<a name="ln4171">  case NFA_MOPEN7:</a>
<a name="ln4172">  case NFA_MOPEN8:</a>
<a name="ln4173">  case NFA_MOPEN9:</a>
<a name="ln4174">  case NFA_ZOPEN:</a>
<a name="ln4175">  case NFA_ZOPEN1:</a>
<a name="ln4176">  case NFA_ZOPEN2:</a>
<a name="ln4177">  case NFA_ZOPEN3:</a>
<a name="ln4178">  case NFA_ZOPEN4:</a>
<a name="ln4179">  case NFA_ZOPEN5:</a>
<a name="ln4180">  case NFA_ZOPEN6:</a>
<a name="ln4181">  case NFA_ZOPEN7:</a>
<a name="ln4182">  case NFA_ZOPEN8:</a>
<a name="ln4183">  case NFA_ZOPEN9:</a>
<a name="ln4184">  case NFA_ZSTART:</a>
<a name="ln4185">    if (state-&gt;c == NFA_ZSTART) {</a>
<a name="ln4186">      subidx = 0;</a>
<a name="ln4187">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4188">    } else if (state-&gt;c &gt;= NFA_ZOPEN &amp;&amp; state-&gt;c &lt;= NFA_ZOPEN9) {  // -V560</a>
<a name="ln4189">      subidx = state-&gt;c - NFA_ZOPEN;</a>
<a name="ln4190">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4191">    } else {</a>
<a name="ln4192">      subidx = state-&gt;c - NFA_MOPEN;</a>
<a name="ln4193">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4194">    }</a>
<a name="ln4195"> </a>
<a name="ln4196">    /* avoid compiler warnings */</a>
<a name="ln4197">    save_ptr = NULL;</a>
<a name="ln4198">    memset(&amp;save_multipos, 0, sizeof(save_multipos));</a>
<a name="ln4199"> </a>
<a name="ln4200">    /* Set the position (with &quot;off&quot; added) in the subexpression.  Save</a>
<a name="ln4201">     * and restore it when it was in use.  Otherwise fill any gap. */</a>
<a name="ln4202">    if (REG_MULTI) {</a>
<a name="ln4203">      if (subidx &lt; sub-&gt;in_use) {</a>
<a name="ln4204">        save_multipos = sub-&gt;list.multi[subidx];</a>
<a name="ln4205">        save_in_use = -1;</a>
<a name="ln4206">      } else {</a>
<a name="ln4207">        save_in_use = sub-&gt;in_use;</a>
<a name="ln4208">        for (i = sub-&gt;in_use; i &lt; subidx; ++i) {</a>
<a name="ln4209">          sub-&gt;list.multi[i].start_lnum = -1;</a>
<a name="ln4210">          sub-&gt;list.multi[i].end_lnum = -1;</a>
<a name="ln4211">        }</a>
<a name="ln4212">        sub-&gt;in_use = subidx + 1;</a>
<a name="ln4213">      }</a>
<a name="ln4214">      if (off == -1) {</a>
<a name="ln4215">        sub-&gt;list.multi[subidx].start_lnum = rex.lnum + 1;</a>
<a name="ln4216">        sub-&gt;list.multi[subidx].start_col = 0;</a>
<a name="ln4217">      } else {</a>
<a name="ln4218">        sub-&gt;list.multi[subidx].start_lnum = rex.lnum;</a>
<a name="ln4219">        sub-&gt;list.multi[subidx].start_col =</a>
<a name="ln4220">          (colnr_T)(rex.input - rex.line + off);</a>
<a name="ln4221">      }</a>
<a name="ln4222">      sub-&gt;list.multi[subidx].end_lnum = -1;</a>
<a name="ln4223">    } else {</a>
<a name="ln4224">      if (subidx &lt; sub-&gt;in_use) {</a>
<a name="ln4225">        save_ptr = sub-&gt;list.line[subidx].start;</a>
<a name="ln4226">        save_in_use = -1;</a>
<a name="ln4227">      } else {</a>
<a name="ln4228">        save_in_use = sub-&gt;in_use;</a>
<a name="ln4229">        for (i = sub-&gt;in_use; i &lt; subidx; ++i) {</a>
<a name="ln4230">          sub-&gt;list.line[i].start = NULL;</a>
<a name="ln4231">          sub-&gt;list.line[i].end = NULL;</a>
<a name="ln4232">        }</a>
<a name="ln4233">        sub-&gt;in_use = subidx + 1;</a>
<a name="ln4234">      }</a>
<a name="ln4235">      sub-&gt;list.line[subidx].start = rex.input + off;</a>
<a name="ln4236">    }</a>
<a name="ln4237"> </a>
<a name="ln4238">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4239">    if (subs == NULL) {</a>
<a name="ln4240">      break;</a>
<a name="ln4241">    }</a>
<a name="ln4242">    // &quot;subs&quot; may have changed, need to set &quot;sub&quot; again.</a>
<a name="ln4243">    if (state-&gt;c &gt;= NFA_ZOPEN &amp;&amp; state-&gt;c &lt;= NFA_ZOPEN9) {  // -V560</a>
<a name="ln4244">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4245">    } else {</a>
<a name="ln4246">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4247">    }</a>
<a name="ln4248"> </a>
<a name="ln4249">    if (save_in_use == -1) {</a>
<a name="ln4250">      if (REG_MULTI) {</a>
<a name="ln4251">        sub-&gt;list.multi[subidx] = save_multipos;</a>
<a name="ln4252">      }</a>
<a name="ln4253">      else</a>
<a name="ln4254">        sub-&gt;list.line[subidx].start = save_ptr;</a>
<a name="ln4255">    } else</a>
<a name="ln4256">      sub-&gt;in_use = save_in_use;</a>
<a name="ln4257">    break;</a>
<a name="ln4258"> </a>
<a name="ln4259">  case NFA_MCLOSE:</a>
<a name="ln4260">    if (rex.nfa_has_zend</a>
<a name="ln4261">        &amp;&amp; (REG_MULTI</a>
<a name="ln4262">            ? subs-&gt;norm.list.multi[0].end_lnum &gt;= 0</a>
<a name="ln4263">            : subs-&gt;norm.list.line[0].end != NULL)) {</a>
<a name="ln4264">      // Do not overwrite the position set by \ze.</a>
<a name="ln4265">      subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4266">      break;</a>
<a name="ln4267">    }</a>
<a name="ln4268">    FALLTHROUGH;</a>
<a name="ln4269">  case NFA_MCLOSE1:</a>
<a name="ln4270">  case NFA_MCLOSE2:</a>
<a name="ln4271">  case NFA_MCLOSE3:</a>
<a name="ln4272">  case NFA_MCLOSE4:</a>
<a name="ln4273">  case NFA_MCLOSE5:</a>
<a name="ln4274">  case NFA_MCLOSE6:</a>
<a name="ln4275">  case NFA_MCLOSE7:</a>
<a name="ln4276">  case NFA_MCLOSE8:</a>
<a name="ln4277">  case NFA_MCLOSE9:</a>
<a name="ln4278">  case NFA_ZCLOSE:</a>
<a name="ln4279">  case NFA_ZCLOSE1:</a>
<a name="ln4280">  case NFA_ZCLOSE2:</a>
<a name="ln4281">  case NFA_ZCLOSE3:</a>
<a name="ln4282">  case NFA_ZCLOSE4:</a>
<a name="ln4283">  case NFA_ZCLOSE5:</a>
<a name="ln4284">  case NFA_ZCLOSE6:</a>
<a name="ln4285">  case NFA_ZCLOSE7:</a>
<a name="ln4286">  case NFA_ZCLOSE8:</a>
<a name="ln4287">  case NFA_ZCLOSE9:</a>
<a name="ln4288">  case NFA_ZEND:</a>
<a name="ln4289">    if (state-&gt;c == NFA_ZEND) {</a>
<a name="ln4290">      subidx = 0;</a>
<a name="ln4291">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4292">    } else if (state-&gt;c &gt;= NFA_ZCLOSE &amp;&amp; state-&gt;c &lt;= NFA_ZCLOSE9) {  // -V560</a>
<a name="ln4293">      subidx = state-&gt;c - NFA_ZCLOSE;</a>
<a name="ln4294">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4295">    } else {</a>
<a name="ln4296">      subidx = state-&gt;c - NFA_MCLOSE;</a>
<a name="ln4297">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4298">    }</a>
<a name="ln4299"> </a>
<a name="ln4300">    /* We don't fill in gaps here, there must have been an MOPEN that</a>
<a name="ln4301">     * has done that. */</a>
<a name="ln4302">    save_in_use = sub-&gt;in_use;</a>
<a name="ln4303">    if (sub-&gt;in_use &lt;= subidx)</a>
<a name="ln4304">      sub-&gt;in_use = subidx + 1;</a>
<a name="ln4305">    if (REG_MULTI) {</a>
<a name="ln4306">      save_multipos = sub-&gt;list.multi[subidx];</a>
<a name="ln4307">      if (off == -1) {</a>
<a name="ln4308">        sub-&gt;list.multi[subidx].end_lnum = rex.lnum + 1;</a>
<a name="ln4309">        sub-&gt;list.multi[subidx].end_col = 0;</a>
<a name="ln4310">      } else {</a>
<a name="ln4311">        sub-&gt;list.multi[subidx].end_lnum = rex.lnum;</a>
<a name="ln4312">        sub-&gt;list.multi[subidx].end_col =</a>
<a name="ln4313">          (colnr_T)(rex.input - rex.line + off);</a>
<a name="ln4314">      }</a>
<a name="ln4315">      /* avoid compiler warnings */</a>
<a name="ln4316">      save_ptr = NULL;</a>
<a name="ln4317">    } else {</a>
<a name="ln4318">      save_ptr = sub-&gt;list.line[subidx].end;</a>
<a name="ln4319">      sub-&gt;list.line[subidx].end = rex.input + off;</a>
<a name="ln4320">      // avoid compiler warnings</a>
<a name="ln4321">      memset(&amp;save_multipos, 0, sizeof(save_multipos));</a>
<a name="ln4322">    }</a>
<a name="ln4323"> </a>
<a name="ln4324">    subs = addstate(l, state-&gt;out, subs, pim, off_arg);</a>
<a name="ln4325">    if (subs == NULL) {</a>
<a name="ln4326">      break;</a>
<a name="ln4327">    }</a>
<a name="ln4328">    // &quot;subs&quot; may have changed, need to set &quot;sub&quot; again.</a>
<a name="ln4329">    if (state-&gt;c &gt;= NFA_ZCLOSE &amp;&amp; state-&gt;c &lt;= NFA_ZCLOSE9) {  // -V560</a>
<a name="ln4330">      sub = &amp;subs-&gt;synt;</a>
<a name="ln4331">    } else {</a>
<a name="ln4332">      sub = &amp;subs-&gt;norm;</a>
<a name="ln4333">    }</a>
<a name="ln4334"> </a>
<a name="ln4335">    if (REG_MULTI) {</a>
<a name="ln4336">      sub-&gt;list.multi[subidx] = save_multipos;</a>
<a name="ln4337">    }</a>
<a name="ln4338">    else</a>
<a name="ln4339">      sub-&gt;list.line[subidx].end = save_ptr;</a>
<a name="ln4340">    sub-&gt;in_use = save_in_use;</a>
<a name="ln4341">    break;</a>
<a name="ln4342">  }</a>
<a name="ln4343">  depth--;</a>
<a name="ln4344">  return subs;</a>
<a name="ln4345">}</a>
<a name="ln4346"> </a>
<a name="ln4347">/*</a>
<a name="ln4348"> * Like addstate(), but the new state(s) are put at position &quot;*ip&quot;.</a>
<a name="ln4349"> * Used for zero-width matches, next state to use is the added one.</a>
<a name="ln4350"> * This makes sure the order of states to be tried does not change, which</a>
<a name="ln4351"> * matters for alternatives.</a>
<a name="ln4352"> */</a>
<a name="ln4353">static regsubs_T *addstate_here(</a>
<a name="ln4354">    nfa_list_T *l,        // runtime state list</a>
<a name="ln4355">    nfa_state_T *state,   // state to update</a>
<a name="ln4356">    regsubs_T *subs,      // pointers to subexpressions</a>
<a name="ln4357">    nfa_pim_T *pim,       // postponed look-behind match</a>
<a name="ln4358">    int *ip</a>
<a name="ln4359">)</a>
<a name="ln4360">  FUNC_ATTR_NONNULL_ARG(1, 2, 5) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4361">{</a>
<a name="ln4362">  int tlen = l-&gt;n;</a>
<a name="ln4363">  int count;</a>
<a name="ln4364">  int listidx = *ip;</a>
<a name="ln4365"> </a>
<a name="ln4366">  /* First add the state(s) at the end, so that we know how many there are.</a>
<a name="ln4367">   * Pass the listidx as offset (avoids adding another argument to</a>
<a name="ln4368">   * addstate(). */</a>
<a name="ln4369">  regsubs_T *r = addstate(l, state, subs, pim, -listidx - ADDSTATE_HERE_OFFSET);</a>
<a name="ln4370">  if (r == NULL) {</a>
<a name="ln4371">    return NULL;</a>
<a name="ln4372">  }</a>
<a name="ln4373"> </a>
<a name="ln4374">  // when &quot;*ip&quot; was at the end of the list, nothing to do</a>
<a name="ln4375">  if (listidx + 1 == tlen) {</a>
<a name="ln4376">    return r;</a>
<a name="ln4377">  }</a>
<a name="ln4378"> </a>
<a name="ln4379">  // re-order to put the new state at the current position</a>
<a name="ln4380">  count = l-&gt;n - tlen;</a>
<a name="ln4381">  if (count == 0) {</a>
<a name="ln4382">    return r;  // no state got added</a>
<a name="ln4383">  }</a>
<a name="ln4384">  if (count == 1) {</a>
<a name="ln4385">    // overwrite the current state</a>
<a name="ln4386">    l-&gt;t[listidx] = l-&gt;t[l-&gt;n - 1];</a>
<a name="ln4387">  } else if (count &gt; 1) {</a>
<a name="ln4388">    if (l-&gt;n + count - 1 &gt;= l-&gt;len) {</a>
<a name="ln4389">      /* not enough space to move the new states, reallocate the list</a>
<a name="ln4390">       * and move the states to the right position */</a>
<a name="ln4391">      const int newlen = l-&gt;len * 3 / 2 + 50;</a>
<a name="ln4392">      const size_t newsize = newlen * sizeof(nfa_thread_T);</a>
<a name="ln4393"> </a>
<a name="ln4394">      if ((long)(newsize &gt;&gt; 10) &gt;= p_mmp) {</a>
<a name="ln4395">        EMSG(_(e_maxmempat));</a>
<a name="ln4396">        return NULL;</a>
<a name="ln4397">      }</a>
<a name="ln4398">      nfa_thread_T *const newl = xmalloc(newsize);</a>
<a name="ln4399">      l-&gt;len = newlen;</a>
<a name="ln4400">      memmove(&amp;(newl[0]),</a>
<a name="ln4401">          &amp;(l-&gt;t[0]),</a>
<a name="ln4402">          sizeof(nfa_thread_T) * listidx);</a>
<a name="ln4403">      memmove(&amp;(newl[listidx]),</a>
<a name="ln4404">          &amp;(l-&gt;t[l-&gt;n - count]),</a>
<a name="ln4405">          sizeof(nfa_thread_T) * count);</a>
<a name="ln4406">      memmove(&amp;(newl[listidx + count]),</a>
<a name="ln4407">          &amp;(l-&gt;t[listidx + 1]),</a>
<a name="ln4408">          sizeof(nfa_thread_T) * (l-&gt;n - count - listidx - 1));</a>
<a name="ln4409">      xfree(l-&gt;t);</a>
<a name="ln4410">      l-&gt;t = newl;</a>
<a name="ln4411">    } else {</a>
<a name="ln4412">      /* make space for new states, then move them from the</a>
<a name="ln4413">       * end to the current position */</a>
<a name="ln4414">      memmove(&amp;(l-&gt;t[listidx + count]),</a>
<a name="ln4415">          &amp;(l-&gt;t[listidx + 1]),</a>
<a name="ln4416">          sizeof(nfa_thread_T) * (l-&gt;n - listidx - 1));</a>
<a name="ln4417">      memmove(&amp;(l-&gt;t[listidx]),</a>
<a name="ln4418">          &amp;(l-&gt;t[l-&gt;n - 1]),</a>
<a name="ln4419">          sizeof(nfa_thread_T) * count);</a>
<a name="ln4420">    }</a>
<a name="ln4421">  }</a>
<a name="ln4422">  --l-&gt;n;</a>
<a name="ln4423">  *ip = listidx - 1;</a>
<a name="ln4424"> </a>
<a name="ln4425">  return r;</a>
<a name="ln4426">}</a>
<a name="ln4427"> </a>
<a name="ln4428">/*</a>
<a name="ln4429"> * Check character class &quot;class&quot; against current character c.</a>
<a name="ln4430"> */</a>
<a name="ln4431">static int check_char_class(int class, int c)</a>
<a name="ln4432">{</a>
<a name="ln4433">  switch (class) {</a>
<a name="ln4434">  case NFA_CLASS_ALNUM:</a>
<a name="ln4435">    if (c &gt;= 1 &amp;&amp; c &lt; 128 &amp;&amp; isalnum(c)) {</a>
<a name="ln4436">      return OK;</a>
<a name="ln4437">    }</a>
<a name="ln4438">    break;</a>
<a name="ln4439">  case NFA_CLASS_ALPHA:</a>
<a name="ln4440">    if (c &gt;= 1 &amp;&amp; c &lt; 128 &amp;&amp; isalpha(c)) {</a>
<a name="ln4441">      return OK;</a>
<a name="ln4442">    }</a>
<a name="ln4443">    break;</a>
<a name="ln4444">  case NFA_CLASS_BLANK:</a>
<a name="ln4445">    if (c == ' ' || c == '\t')</a>
<a name="ln4446">      return OK;</a>
<a name="ln4447">    break;</a>
<a name="ln4448">  case NFA_CLASS_CNTRL:</a>
<a name="ln4449">    if (c &gt;= 1 &amp;&amp; c &lt;= 127 &amp;&amp; iscntrl(c)) {</a>
<a name="ln4450">      return OK;</a>
<a name="ln4451">    }</a>
<a name="ln4452">    break;</a>
<a name="ln4453">  case NFA_CLASS_DIGIT:</a>
<a name="ln4454">    if (ascii_isdigit(c))</a>
<a name="ln4455">      return OK;</a>
<a name="ln4456">    break;</a>
<a name="ln4457">  case NFA_CLASS_GRAPH:</a>
<a name="ln4458">    if (c &gt;= 1 &amp;&amp; c &lt;= 127 &amp;&amp; isgraph(c)) {</a>
<a name="ln4459">      return OK;</a>
<a name="ln4460">    }</a>
<a name="ln4461">    break;</a>
<a name="ln4462">  case NFA_CLASS_LOWER:</a>
<a name="ln4463">    if (mb_islower(c) &amp;&amp; c != 170 &amp;&amp; c != 186) {</a>
<a name="ln4464">      return OK;</a>
<a name="ln4465">    }</a>
<a name="ln4466">    break;</a>
<a name="ln4467">  case NFA_CLASS_PRINT:</a>
<a name="ln4468">    if (vim_isprintc(c))</a>
<a name="ln4469">      return OK;</a>
<a name="ln4470">    break;</a>
<a name="ln4471">  case NFA_CLASS_PUNCT:</a>
<a name="ln4472">    if (c &gt;= 1 &amp;&amp; c &lt; 128 &amp;&amp; ispunct(c)) {</a>
<a name="ln4473">      return OK;</a>
<a name="ln4474">    }</a>
<a name="ln4475">    break;</a>
<a name="ln4476">  case NFA_CLASS_SPACE:</a>
<a name="ln4477">    if ((c &gt;= 9 &amp;&amp; c &lt;= 13) || (c == ' '))</a>
<a name="ln4478">      return OK;</a>
<a name="ln4479">    break;</a>
<a name="ln4480">  case NFA_CLASS_UPPER:</a>
<a name="ln4481">    if (mb_isupper(c)) {</a>
<a name="ln4482">      return OK;</a>
<a name="ln4483">    }</a>
<a name="ln4484">    break;</a>
<a name="ln4485">  case NFA_CLASS_XDIGIT:</a>
<a name="ln4486">    if (ascii_isxdigit(c))</a>
<a name="ln4487">      return OK;</a>
<a name="ln4488">    break;</a>
<a name="ln4489">  case NFA_CLASS_TAB:</a>
<a name="ln4490">    if (c == '\t')</a>
<a name="ln4491">      return OK;</a>
<a name="ln4492">    break;</a>
<a name="ln4493">  case NFA_CLASS_RETURN:</a>
<a name="ln4494">    if (c == '\r')</a>
<a name="ln4495">      return OK;</a>
<a name="ln4496">    break;</a>
<a name="ln4497">  case NFA_CLASS_BACKSPACE:</a>
<a name="ln4498">    if (c == '\b')</a>
<a name="ln4499">      return OK;</a>
<a name="ln4500">    break;</a>
<a name="ln4501">  case NFA_CLASS_ESCAPE:</a>
<a name="ln4502">    if (c == ESC) {</a>
<a name="ln4503">      return OK;</a>
<a name="ln4504">    }</a>
<a name="ln4505">    break;</a>
<a name="ln4506">  case NFA_CLASS_IDENT:</a>
<a name="ln4507">    if (vim_isIDc(c)) {</a>
<a name="ln4508">      return OK;</a>
<a name="ln4509">    }</a>
<a name="ln4510">    break;</a>
<a name="ln4511">  case NFA_CLASS_KEYWORD:</a>
<a name="ln4512">    if (reg_iswordc(c)) {</a>
<a name="ln4513">      return OK;</a>
<a name="ln4514">    }</a>
<a name="ln4515">    break;</a>
<a name="ln4516">  case NFA_CLASS_FNAME:</a>
<a name="ln4517">    if (vim_isfilec(c)) {</a>
<a name="ln4518">      return OK;</a>
<a name="ln4519">    }</a>
<a name="ln4520">    break;</a>
<a name="ln4521"> </a>
<a name="ln4522">  default:</a>
<a name="ln4523">    // should not be here :P</a>
<a name="ln4524">    IEMSGN(_(e_ill_char_class), class);</a>
<a name="ln4525">    return FAIL;</a>
<a name="ln4526">  }</a>
<a name="ln4527">  return FAIL;</a>
<a name="ln4528">}</a>
<a name="ln4529"> </a>
<a name="ln4530">/*</a>
<a name="ln4531"> * Check for a match with subexpression &quot;subidx&quot;.</a>
<a name="ln4532"> * Return true if it matches.</a>
<a name="ln4533"> */</a>
<a name="ln4534">static int </a>
<a name="ln4535">match_backref (</a>
<a name="ln4536">    regsub_T *sub,           /* pointers to subexpressions */</a>
<a name="ln4537">    int subidx,</a>
<a name="ln4538">    int *bytelen       /* out: length of match in bytes */</a>
<a name="ln4539">)</a>
<a name="ln4540">{</a>
<a name="ln4541">  int len;</a>
<a name="ln4542"> </a>
<a name="ln4543">  if (sub-&gt;in_use &lt;= subidx) {</a>
<a name="ln4544">retempty:</a>
<a name="ln4545">    /* backref was not set, match an empty string */</a>
<a name="ln4546">    *bytelen = 0;</a>
<a name="ln4547">    return true;</a>
<a name="ln4548">  }</a>
<a name="ln4549"> </a>
<a name="ln4550">  if (REG_MULTI) {</a>
<a name="ln4551">    if (sub-&gt;list.multi[subidx].start_lnum &lt; 0</a>
<a name="ln4552">        || sub-&gt;list.multi[subidx].end_lnum &lt; 0)</a>
<a name="ln4553">      goto retempty;</a>
<a name="ln4554">    if (sub-&gt;list.multi[subidx].start_lnum == rex.lnum</a>
<a name="ln4555">        &amp;&amp; sub-&gt;list.multi[subidx].end_lnum == rex.lnum) {</a>
<a name="ln4556">      len = sub-&gt;list.multi[subidx].end_col</a>
<a name="ln4557">            - sub-&gt;list.multi[subidx].start_col;</a>
<a name="ln4558">      if (cstrncmp(rex.line + sub-&gt;list.multi[subidx].start_col,</a>
<a name="ln4559">                   rex.input, &amp;len) == 0) {</a>
<a name="ln4560">        *bytelen = len;</a>
<a name="ln4561">        return true;</a>
<a name="ln4562">      }</a>
<a name="ln4563">    } else {</a>
<a name="ln4564">      if (match_with_backref(sub-&gt;list.multi[subidx].start_lnum,</a>
<a name="ln4565">                             sub-&gt;list.multi[subidx].start_col,</a>
<a name="ln4566">                             sub-&gt;list.multi[subidx].end_lnum,</a>
<a name="ln4567">                             sub-&gt;list.multi[subidx].end_col,</a>
<a name="ln4568">                             bytelen) == RA_MATCH) {</a>
<a name="ln4569">        return true;</a>
<a name="ln4570">      }</a>
<a name="ln4571">    }</a>
<a name="ln4572">  } else {</a>
<a name="ln4573">    if (sub-&gt;list.line[subidx].start == NULL</a>
<a name="ln4574">        || sub-&gt;list.line[subidx].end == NULL)</a>
<a name="ln4575">      goto retempty;</a>
<a name="ln4576">    len = (int)(sub-&gt;list.line[subidx].end - sub-&gt;list.line[subidx].start);</a>
<a name="ln4577">    if (cstrncmp(sub-&gt;list.line[subidx].start, rex.input, &amp;len) == 0) {</a>
<a name="ln4578">      *bytelen = len;</a>
<a name="ln4579">      return true;</a>
<a name="ln4580">    }</a>
<a name="ln4581">  }</a>
<a name="ln4582">  return false;</a>
<a name="ln4583">}</a>
<a name="ln4584"> </a>
<a name="ln4585"> </a>
<a name="ln4586"> </a>
<a name="ln4587">/*</a>
<a name="ln4588"> * Check for a match with \z subexpression &quot;subidx&quot;.</a>
<a name="ln4589"> * Return true if it matches.</a>
<a name="ln4590"> */</a>
<a name="ln4591">static int </a>
<a name="ln4592">match_zref (</a>
<a name="ln4593">    int subidx,</a>
<a name="ln4594">    int *bytelen       /* out: length of match in bytes */</a>
<a name="ln4595">)</a>
<a name="ln4596">{</a>
<a name="ln4597">  int len;</a>
<a name="ln4598"> </a>
<a name="ln4599">  cleanup_zsubexpr();</a>
<a name="ln4600">  if (re_extmatch_in == NULL || re_extmatch_in-&gt;matches[subidx] == NULL) {</a>
<a name="ln4601">    /* backref was not set, match an empty string */</a>
<a name="ln4602">    *bytelen = 0;</a>
<a name="ln4603">    return true;</a>
<a name="ln4604">  }</a>
<a name="ln4605"> </a>
<a name="ln4606">  len = (int)STRLEN(re_extmatch_in-&gt;matches[subidx]);</a>
<a name="ln4607">  if (cstrncmp(re_extmatch_in-&gt;matches[subidx], rex.input, &amp;len) == 0) {</a>
<a name="ln4608">    *bytelen = len;</a>
<a name="ln4609">    return true;</a>
<a name="ln4610">  }</a>
<a name="ln4611">  return false;</a>
<a name="ln4612">}</a>
<a name="ln4613"> </a>
<a name="ln4614">/*</a>
<a name="ln4615"> * Save list IDs for all NFA states of &quot;prog&quot; into &quot;list&quot;.</a>
<a name="ln4616"> * Also reset the IDs to zero.</a>
<a name="ln4617"> * Only used for the recursive value lastlist[1].</a>
<a name="ln4618"> */</a>
<a name="ln4619">static void nfa_save_listids(nfa_regprog_T *prog, int *list)</a>
<a name="ln4620">{</a>
<a name="ln4621">  int i;</a>
<a name="ln4622">  nfa_state_T     *p;</a>
<a name="ln4623"> </a>
<a name="ln4624">  /* Order in the list is reverse, it's a bit faster that way. */</a>
<a name="ln4625">  p = &amp;prog-&gt;state[0];</a>
<a name="ln4626">  for (i = prog-&gt;nstate; --i &gt;= 0; ) {</a>
<a name="ln4627">    list[i] = p-&gt;lastlist[1];</a>
<a name="ln4628">    p-&gt;lastlist[1] = 0;</a>
<a name="ln4629">    ++p;</a>
<a name="ln4630">  }</a>
<a name="ln4631">}</a>
<a name="ln4632"> </a>
<a name="ln4633">/*</a>
<a name="ln4634"> * Restore list IDs from &quot;list&quot; to all NFA states.</a>
<a name="ln4635"> */</a>
<a name="ln4636">static void nfa_restore_listids(nfa_regprog_T *prog, int *list)</a>
<a name="ln4637">{</a>
<a name="ln4638">  int i;</a>
<a name="ln4639">  nfa_state_T     *p;</a>
<a name="ln4640"> </a>
<a name="ln4641">  p = &amp;prog-&gt;state[0];</a>
<a name="ln4642">  for (i = prog-&gt;nstate; --i &gt;= 0; ) {</a>
<a name="ln4643">    p-&gt;lastlist[1] = list[i];</a>
<a name="ln4644">    ++p;</a>
<a name="ln4645">  }</a>
<a name="ln4646">}</a>
<a name="ln4647"> </a>
<a name="ln4648">static bool nfa_re_num_cmp(uintmax_t val, int op, uintmax_t pos)</a>
<a name="ln4649">{</a>
<a name="ln4650">  if (op == 1) return pos &gt; val;</a>
<a name="ln4651">  if (op == 2) return pos &lt; val;</a>
<a name="ln4652">  return val == pos;</a>
<a name="ln4653">}</a>
<a name="ln4654"> </a>
<a name="ln4655"> </a>
<a name="ln4656">/*</a>
<a name="ln4657"> * Recursively call nfa_regmatch()</a>
<a name="ln4658"> * &quot;pim&quot; is NULL or contains info about a Postponed Invisible Match (start</a>
<a name="ln4659"> * position).</a>
<a name="ln4660"> */</a>
<a name="ln4661">static int recursive_regmatch(</a>
<a name="ln4662">    nfa_state_T *state, nfa_pim_T *pim, nfa_regprog_T *prog,</a>
<a name="ln4663">    regsubs_T *submatch, regsubs_T *m, int **listids, int *listids_len)</a>
<a name="ln4664">  FUNC_ATTR_NONNULL_ARG(1, 3, 5, 6, 7)</a>
<a name="ln4665">{</a>
<a name="ln4666">  const int save_reginput_col = (int)(rex.input - rex.line);</a>
<a name="ln4667">  const int save_reglnum = rex.lnum;</a>
<a name="ln4668">  const int save_nfa_match = nfa_match;</a>
<a name="ln4669">  const int save_nfa_listid = rex.nfa_listid;</a>
<a name="ln4670">  save_se_T *const save_nfa_endp = nfa_endp;</a>
<a name="ln4671">  save_se_T endpos;</a>
<a name="ln4672">  save_se_T   *endposp = NULL;</a>
<a name="ln4673">  int need_restore = false;</a>
<a name="ln4674"> </a>
<a name="ln4675">  if (pim != NULL) {</a>
<a name="ln4676">    // start at the position where the postponed match was</a>
<a name="ln4677">    if (REG_MULTI) {</a>
<a name="ln4678">      rex.input = rex.line + pim-&gt;end.pos.col;</a>
<a name="ln4679">    } else {</a>
<a name="ln4680">      rex.input = pim-&gt;end.ptr;</a>
<a name="ln4681">    }</a>
<a name="ln4682">  }</a>
<a name="ln4683"> </a>
<a name="ln4684">  if (state-&gt;c == NFA_START_INVISIBLE_BEFORE</a>
<a name="ln4685">      || state-&gt;c == NFA_START_INVISIBLE_BEFORE_FIRST</a>
<a name="ln4686">      || state-&gt;c == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln4687">      || state-&gt;c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST) {</a>
<a name="ln4688">    // The recursive match must end at the current position. When &quot;pim&quot; is</a>
<a name="ln4689">    // not NULL it specifies the current position.</a>
<a name="ln4690">    endposp = &amp;endpos;</a>
<a name="ln4691">    if (REG_MULTI) {</a>
<a name="ln4692">      if (pim == NULL) {</a>
<a name="ln4693">        endpos.se_u.pos.col = (int)(rex.input - rex.line);</a>
<a name="ln4694">        endpos.se_u.pos.lnum = rex.lnum;</a>
<a name="ln4695">      } else {</a>
<a name="ln4696">        endpos.se_u.pos = pim-&gt;end.pos;</a>
<a name="ln4697">      }</a>
<a name="ln4698">    } else {</a>
<a name="ln4699">      if (pim == NULL) {</a>
<a name="ln4700">        endpos.se_u.ptr = rex.input;</a>
<a name="ln4701">      } else {</a>
<a name="ln4702">        endpos.se_u.ptr = pim-&gt;end.ptr;</a>
<a name="ln4703">      }</a>
<a name="ln4704">    }</a>
<a name="ln4705"> </a>
<a name="ln4706">    // Go back the specified number of bytes, or as far as the</a>
<a name="ln4707">    // start of the previous line, to try matching &quot;\@&lt;=&quot; or</a>
<a name="ln4708">    // not matching &quot;\@&lt;!&quot;. This is very inefficient, limit the number of</a>
<a name="ln4709">    // bytes if possible.</a>
<a name="ln4710">    if (state-&gt;val &lt;= 0) {</a>
<a name="ln4711">      if (REG_MULTI) {</a>
<a name="ln4712">        rex.line = reg_getline(--rex.lnum);</a>
<a name="ln4713">        if (rex.line == NULL) {</a>
<a name="ln4714">          // can't go before the first line</a>
<a name="ln4715">          rex.line = reg_getline(++rex.lnum);</a>
<a name="ln4716">        }</a>
<a name="ln4717">      }</a>
<a name="ln4718">      rex.input = rex.line;</a>
<a name="ln4719">    } else {</a>
<a name="ln4720">      if (REG_MULTI &amp;&amp; (int)(rex.input - rex.line) &lt; state-&gt;val) {</a>
<a name="ln4721">        // Not enough bytes in this line, go to end of</a>
<a name="ln4722">        // previous line.</a>
<a name="ln4723">        rex.line = reg_getline(--rex.lnum);</a>
<a name="ln4724">        if (rex.line == NULL) {</a>
<a name="ln4725">          // can't go before the first line</a>
<a name="ln4726">          rex.line = reg_getline(++rex.lnum);</a>
<a name="ln4727">          rex.input = rex.line;</a>
<a name="ln4728">        } else {</a>
<a name="ln4729">          rex.input = rex.line + STRLEN(rex.line);</a>
<a name="ln4730">        }</a>
<a name="ln4731">      }</a>
<a name="ln4732">      if ((int)(rex.input - rex.line) &gt;= state-&gt;val) {</a>
<a name="ln4733">        rex.input -= state-&gt;val;</a>
<a name="ln4734">        rex.input -= utf_head_off(rex.line, rex.input);</a>
<a name="ln4735">      } else {</a>
<a name="ln4736">        rex.input = rex.line;</a>
<a name="ln4737">      }</a>
<a name="ln4738">    }</a>
<a name="ln4739">  }</a>
<a name="ln4740"> </a>
<a name="ln4741">#ifdef REGEXP_DEBUG</a>
<a name="ln4742">  if (log_fd != stderr)</a>
<a name="ln4743">    fclose(log_fd);</a>
<a name="ln4744">  log_fd = NULL;</a>
<a name="ln4745">#endif</a>
<a name="ln4746">  // Have to clear the lastlist field of the NFA nodes, so that</a>
<a name="ln4747">  // nfa_regmatch() and addstate() can run properly after recursion.</a>
<a name="ln4748">  if (nfa_ll_index == 1) {</a>
<a name="ln4749">    // Already calling nfa_regmatch() recursively.  Save the lastlist[1]</a>
<a name="ln4750">    // values and clear them.</a>
<a name="ln4751">    if (*listids == NULL || *listids_len &lt; prog-&gt;nstate) {</a>
<a name="ln4752">      xfree(*listids);</a>
<a name="ln4753">      *listids = xmalloc(sizeof(**listids) * prog-&gt;nstate);</a>
<a name="ln4754">      *listids_len = prog-&gt;nstate;</a>
<a name="ln4755">    }</a>
<a name="ln4756">    nfa_save_listids(prog, *listids);</a>
<a name="ln4757">    need_restore = true;</a>
<a name="ln4758">    // any value of rex.nfa_listid will do</a>
<a name="ln4759">  } else {</a>
<a name="ln4760">    // First recursive nfa_regmatch() call, switch to the second lastlist</a>
<a name="ln4761">    // entry.  Make sure rex.nfa_listid is different from a previous</a>
<a name="ln4762">    // recursive call, because some states may still have this ID.</a>
<a name="ln4763">    nfa_ll_index++;</a>
<a name="ln4764">    if (rex.nfa_listid &lt;= rex.nfa_alt_listid) {</a>
<a name="ln4765">      rex.nfa_listid = rex.nfa_alt_listid;</a>
<a name="ln4766">    }</a>
<a name="ln4767">  }</a>
<a name="ln4768"> </a>
<a name="ln4769">  // Call nfa_regmatch() to check if the current concat matches at this</a>
<a name="ln4770">  // position. The concat ends with the node NFA_END_INVISIBLE</a>
<a name="ln4771">  nfa_endp = endposp;</a>
<a name="ln4772">  const int result = nfa_regmatch(prog, state-&gt;out, submatch, m);</a>
<a name="ln4773"> </a>
<a name="ln4774">  if (need_restore) {</a>
<a name="ln4775">    nfa_restore_listids(prog, *listids);</a>
<a name="ln4776">  } else {</a>
<a name="ln4777">    nfa_ll_index--;</a>
<a name="ln4778">    rex.nfa_alt_listid = rex.nfa_listid;</a>
<a name="ln4779">  }</a>
<a name="ln4780"> </a>
<a name="ln4781">  // restore position in input text</a>
<a name="ln4782">  rex.lnum = save_reglnum;</a>
<a name="ln4783">  if (REG_MULTI) {</a>
<a name="ln4784">    rex.line = reg_getline(rex.lnum);</a>
<a name="ln4785">  }</a>
<a name="ln4786">  rex.input = rex.line + save_reginput_col;</a>
<a name="ln4787">  if (result != NFA_TOO_EXPENSIVE) {</a>
<a name="ln4788">    nfa_match = save_nfa_match;</a>
<a name="ln4789">    rex.nfa_listid = save_nfa_listid;</a>
<a name="ln4790">  }</a>
<a name="ln4791">  nfa_endp = save_nfa_endp;</a>
<a name="ln4792"> </a>
<a name="ln4793">#ifdef REGEXP_DEBUG</a>
<a name="ln4794">  log_fd = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln4795">  if (log_fd != NULL) {</a>
<a name="ln4796">    fprintf(log_fd, &quot;****************************\n&quot;);</a>
<a name="ln4797">    fprintf(log_fd, &quot;FINISHED RUNNING nfa_regmatch() recursively\n&quot;);</a>
<a name="ln4798">    fprintf(log_fd, &quot;MATCH = %s\n&quot;, !result ? &quot;false&quot; : &quot;OK&quot;);</a>
<a name="ln4799">    fprintf(log_fd, &quot;****************************\n&quot;);</a>
<a name="ln4800">  } else {</a>
<a name="ln4801">    EMSG(_(e_log_open_failed));</a>
<a name="ln4802">    log_fd = stderr;</a>
<a name="ln4803">  }</a>
<a name="ln4804">#endif</a>
<a name="ln4805"> </a>
<a name="ln4806">  return result;</a>
<a name="ln4807">}</a>
<a name="ln4808"> </a>
<a name="ln4809"> </a>
<a name="ln4810">/*</a>
<a name="ln4811"> * Estimate the chance of a match with &quot;state&quot; failing.</a>
<a name="ln4812"> * empty match: 0</a>
<a name="ln4813"> * NFA_ANY: 1</a>
<a name="ln4814"> * specific character: 99</a>
<a name="ln4815"> */</a>
<a name="ln4816">static int failure_chance(nfa_state_T *state, int depth)</a>
<a name="ln4817">{</a>
<a name="ln4818">  int c = state-&gt;c;</a>
<a name="ln4819">  int l, r;</a>
<a name="ln4820"> </a>
<a name="ln4821">  /* detect looping */</a>
<a name="ln4822">  if (depth &gt; 4)</a>
<a name="ln4823">    return 1;</a>
<a name="ln4824"> </a>
<a name="ln4825">  switch (c) {</a>
<a name="ln4826">  case NFA_SPLIT:</a>
<a name="ln4827">    if (state-&gt;out-&gt;c == NFA_SPLIT || state-&gt;out1-&gt;c == NFA_SPLIT)</a>
<a name="ln4828">      /* avoid recursive stuff */</a>
<a name="ln4829">      return 1;</a>
<a name="ln4830">    /* two alternatives, use the lowest failure chance */</a>
<a name="ln4831">    l = failure_chance(state-&gt;out, depth + 1);</a>
<a name="ln4832">    r = failure_chance(state-&gt;out1, depth + 1);</a>
<a name="ln4833">    return l &lt; r ? l : r;</a>
<a name="ln4834"> </a>
<a name="ln4835">  case NFA_ANY:</a>
<a name="ln4836">    /* matches anything, unlikely to fail */</a>
<a name="ln4837">    return 1;</a>
<a name="ln4838"> </a>
<a name="ln4839">  case NFA_MATCH:</a>
<a name="ln4840">  case NFA_MCLOSE:</a>
<a name="ln4841">  case NFA_ANY_COMPOSING:</a>
<a name="ln4842">    /* empty match works always */</a>
<a name="ln4843">    return 0;</a>
<a name="ln4844"> </a>
<a name="ln4845">  case NFA_START_INVISIBLE:</a>
<a name="ln4846">  case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln4847">  case NFA_START_INVISIBLE_NEG:</a>
<a name="ln4848">  case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln4849">  case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln4850">  case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln4851">  case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln4852">  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln4853">  case NFA_START_PATTERN:</a>
<a name="ln4854">    /* recursive regmatch is expensive, use low failure chance */</a>
<a name="ln4855">    return 5;</a>
<a name="ln4856"> </a>
<a name="ln4857">  case NFA_BOL:</a>
<a name="ln4858">  case NFA_EOL:</a>
<a name="ln4859">  case NFA_BOF:</a>
<a name="ln4860">  case NFA_EOF:</a>
<a name="ln4861">  case NFA_NEWL:</a>
<a name="ln4862">    return 99;</a>
<a name="ln4863"> </a>
<a name="ln4864">  case NFA_BOW:</a>
<a name="ln4865">  case NFA_EOW:</a>
<a name="ln4866">    return 90;</a>
<a name="ln4867"> </a>
<a name="ln4868">  case NFA_MOPEN:</a>
<a name="ln4869">  case NFA_MOPEN1:</a>
<a name="ln4870">  case NFA_MOPEN2:</a>
<a name="ln4871">  case NFA_MOPEN3:</a>
<a name="ln4872">  case NFA_MOPEN4:</a>
<a name="ln4873">  case NFA_MOPEN5:</a>
<a name="ln4874">  case NFA_MOPEN6:</a>
<a name="ln4875">  case NFA_MOPEN7:</a>
<a name="ln4876">  case NFA_MOPEN8:</a>
<a name="ln4877">  case NFA_MOPEN9:</a>
<a name="ln4878">  case NFA_ZOPEN:</a>
<a name="ln4879">  case NFA_ZOPEN1:</a>
<a name="ln4880">  case NFA_ZOPEN2:</a>
<a name="ln4881">  case NFA_ZOPEN3:</a>
<a name="ln4882">  case NFA_ZOPEN4:</a>
<a name="ln4883">  case NFA_ZOPEN5:</a>
<a name="ln4884">  case NFA_ZOPEN6:</a>
<a name="ln4885">  case NFA_ZOPEN7:</a>
<a name="ln4886">  case NFA_ZOPEN8:</a>
<a name="ln4887">  case NFA_ZOPEN9:</a>
<a name="ln4888">  case NFA_ZCLOSE:</a>
<a name="ln4889">  case NFA_ZCLOSE1:</a>
<a name="ln4890">  case NFA_ZCLOSE2:</a>
<a name="ln4891">  case NFA_ZCLOSE3:</a>
<a name="ln4892">  case NFA_ZCLOSE4:</a>
<a name="ln4893">  case NFA_ZCLOSE5:</a>
<a name="ln4894">  case NFA_ZCLOSE6:</a>
<a name="ln4895">  case NFA_ZCLOSE7:</a>
<a name="ln4896">  case NFA_ZCLOSE8:</a>
<a name="ln4897">  case NFA_ZCLOSE9:</a>
<a name="ln4898">  case NFA_NOPEN:</a>
<a name="ln4899">  case NFA_MCLOSE1:</a>
<a name="ln4900">  case NFA_MCLOSE2:</a>
<a name="ln4901">  case NFA_MCLOSE3:</a>
<a name="ln4902">  case NFA_MCLOSE4:</a>
<a name="ln4903">  case NFA_MCLOSE5:</a>
<a name="ln4904">  case NFA_MCLOSE6:</a>
<a name="ln4905">  case NFA_MCLOSE7:</a>
<a name="ln4906">  case NFA_MCLOSE8:</a>
<a name="ln4907">  case NFA_MCLOSE9:</a>
<a name="ln4908">  case NFA_NCLOSE:</a>
<a name="ln4909">    return failure_chance(state-&gt;out, depth + 1);</a>
<a name="ln4910"> </a>
<a name="ln4911">  case NFA_BACKREF1:</a>
<a name="ln4912">  case NFA_BACKREF2:</a>
<a name="ln4913">  case NFA_BACKREF3:</a>
<a name="ln4914">  case NFA_BACKREF4:</a>
<a name="ln4915">  case NFA_BACKREF5:</a>
<a name="ln4916">  case NFA_BACKREF6:</a>
<a name="ln4917">  case NFA_BACKREF7:</a>
<a name="ln4918">  case NFA_BACKREF8:</a>
<a name="ln4919">  case NFA_BACKREF9:</a>
<a name="ln4920">  case NFA_ZREF1:</a>
<a name="ln4921">  case NFA_ZREF2:</a>
<a name="ln4922">  case NFA_ZREF3:</a>
<a name="ln4923">  case NFA_ZREF4:</a>
<a name="ln4924">  case NFA_ZREF5:</a>
<a name="ln4925">  case NFA_ZREF6:</a>
<a name="ln4926">  case NFA_ZREF7:</a>
<a name="ln4927">  case NFA_ZREF8:</a>
<a name="ln4928">  case NFA_ZREF9:</a>
<a name="ln4929">    /* backreferences don't match in many places */</a>
<a name="ln4930">    return 94;</a>
<a name="ln4931"> </a>
<a name="ln4932">  case NFA_LNUM_GT:</a>
<a name="ln4933">  case NFA_LNUM_LT:</a>
<a name="ln4934">  case NFA_COL_GT:</a>
<a name="ln4935">  case NFA_COL_LT:</a>
<a name="ln4936">  case NFA_VCOL_GT:</a>
<a name="ln4937">  case NFA_VCOL_LT:</a>
<a name="ln4938">  case NFA_MARK_GT:</a>
<a name="ln4939">  case NFA_MARK_LT:</a>
<a name="ln4940">  case NFA_VISUAL:</a>
<a name="ln4941">    /* before/after positions don't match very often */</a>
<a name="ln4942">    return 85;</a>
<a name="ln4943"> </a>
<a name="ln4944">  case NFA_LNUM:</a>
<a name="ln4945">    return 90;</a>
<a name="ln4946"> </a>
<a name="ln4947">  case NFA_CURSOR:</a>
<a name="ln4948">  case NFA_COL:</a>
<a name="ln4949">  case NFA_VCOL:</a>
<a name="ln4950">  case NFA_MARK:</a>
<a name="ln4951">    /* specific positions rarely match */</a>
<a name="ln4952">    return 98;</a>
<a name="ln4953"> </a>
<a name="ln4954">  case NFA_COMPOSING:</a>
<a name="ln4955">    return 95;</a>
<a name="ln4956"> </a>
<a name="ln4957">  default:</a>
<a name="ln4958">    if (c &gt; 0)</a>
<a name="ln4959">      /* character match fails often */</a>
<a name="ln4960">      return 95;</a>
<a name="ln4961">  }</a>
<a name="ln4962"> </a>
<a name="ln4963">  /* something else, includes character classes */</a>
<a name="ln4964">  return 50;</a>
<a name="ln4965">}</a>
<a name="ln4966"> </a>
<a name="ln4967">/*</a>
<a name="ln4968"> * Skip until the char &quot;c&quot; we know a match must start with.</a>
<a name="ln4969"> */</a>
<a name="ln4970">static int skip_to_start(int c, colnr_T *colp)</a>
<a name="ln4971">{</a>
<a name="ln4972">  const char_u *const s = cstrchr(rex.line + *colp, c);</a>
<a name="ln4973">  if (s == NULL) {</a>
<a name="ln4974">    return FAIL;</a>
<a name="ln4975">  }</a>
<a name="ln4976">  *colp = (int)(s - rex.line);</a>
<a name="ln4977">  return OK;</a>
<a name="ln4978">}</a>
<a name="ln4979"> </a>
<a name="ln4980">/*</a>
<a name="ln4981"> * Check for a match with match_text.</a>
<a name="ln4982"> * Called after skip_to_start() has found regstart.</a>
<a name="ln4983"> * Returns zero for no match, 1 for a match.</a>
<a name="ln4984"> */</a>
<a name="ln4985">static long find_match_text(colnr_T startcol, int regstart, char_u *match_text)</a>
<a name="ln4986">{</a>
<a name="ln4987">#define PTR2LEN(x) utf_ptr2len(x)</a>
<a name="ln4988"> </a>
<a name="ln4989">  colnr_T col = startcol;</a>
<a name="ln4990">  int regstart_len = PTR2LEN(rex.line + startcol);</a>
<a name="ln4991"> </a>
<a name="ln4992">  for (;;) {</a>
<a name="ln4993">    bool match = true;</a>
<a name="ln4994">    char_u *s1 = match_text;</a>
<a name="ln4995">    char_u *s2 = rex.line + col + regstart_len;  // skip regstart</a>
<a name="ln4996">    while (*s1) {</a>
<a name="ln4997">      int c1_len = PTR2LEN(s1);</a>
<a name="ln4998">      int c1 = PTR2CHAR(s1);</a>
<a name="ln4999">      int c2_len = PTR2LEN(s2);</a>
<a name="ln5000">      int c2 = PTR2CHAR(s2);</a>
<a name="ln5001"> </a>
<a name="ln5002">      if ((c1 != c2 &amp;&amp; (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))</a>
<a name="ln5003">          || c1_len != c2_len) {</a>
<a name="ln5004">        match = false;</a>
<a name="ln5005">        break;</a>
<a name="ln5006">      }</a>
<a name="ln5007">      s1 += c1_len;</a>
<a name="ln5008">      s2 += c2_len;</a>
<a name="ln5009">    }</a>
<a name="ln5010">    if (match</a>
<a name="ln5011">        // check that no composing char follows</a>
<a name="ln5012">        &amp;&amp; !utf_iscomposing(PTR2CHAR(s2))) {</a>
<a name="ln5013">      cleanup_subexpr();</a>
<a name="ln5014">      if (REG_MULTI) {</a>
<a name="ln5015">        rex.reg_startpos[0].lnum = rex.lnum;</a>
<a name="ln5016">        rex.reg_startpos[0].col = col;</a>
<a name="ln5017">        rex.reg_endpos[0].lnum = rex.lnum;</a>
<a name="ln5018">        rex.reg_endpos[0].col = s2 - rex.line;</a>
<a name="ln5019">      } else {</a>
<a name="ln5020">        rex.reg_startp[0] = rex.line + col;</a>
<a name="ln5021">        rex.reg_endp[0] = s2;</a>
<a name="ln5022">      }</a>
<a name="ln5023">      return 1L;</a>
<a name="ln5024">    }</a>
<a name="ln5025"> </a>
<a name="ln5026">    // Try finding regstart after the current match.</a>
<a name="ln5027">    col += regstart_len;  // skip regstart</a>
<a name="ln5028">    if (skip_to_start(regstart, &amp;col) == FAIL) {</a>
<a name="ln5029">      break;</a>
<a name="ln5030">    }</a>
<a name="ln5031">  }</a>
<a name="ln5032">  return 0L;</a>
<a name="ln5033"> </a>
<a name="ln5034">#undef PTR2LEN</a>
<a name="ln5035">}</a>
<a name="ln5036"> </a>
<a name="ln5037">static int nfa_did_time_out(void)</a>
<a name="ln5038">{</a>
<a name="ln5039">  if (nfa_time_limit != NULL &amp;&amp; profile_passed_limit(*nfa_time_limit)) {</a>
<a name="ln5040">    if (nfa_timed_out != NULL) {</a>
<a name="ln5041">      *nfa_timed_out = true;</a>
<a name="ln5042">    }</a>
<a name="ln5043">    return true;</a>
<a name="ln5044">  }</a>
<a name="ln5045">  return false;</a>
<a name="ln5046">}</a>
<a name="ln5047"> </a>
<a name="ln5048">/// Main matching routine.</a>
<a name="ln5049">///</a>
<a name="ln5050">/// Run NFA to determine whether it matches rex.input.</a>
<a name="ln5051">///</a>
<a name="ln5052">/// When &quot;nfa_endp&quot; is not NULL it is a required end-of-match position.</a>
<a name="ln5053">///</a>
<a name="ln5054">/// Return true if there is a match, false if there is no match,</a>
<a name="ln5055">/// NFA_TOO_EXPENSIVE if we end up with too many states.</a>
<a name="ln5056">/// When there is a match &quot;submatch&quot; contains the positions.</a>
<a name="ln5057">///</a>
<a name="ln5058">/// Note: Caller must ensure that: start != NULL.</a>
<a name="ln5059">static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start,</a>
<a name="ln5060">                        regsubs_T *submatch, regsubs_T *m)</a>
<a name="ln5061">  FUNC_ATTR_NONNULL_ARG(1, 2, 4)</a>
<a name="ln5062">{</a>
<a name="ln5063">  int result = false;</a>
<a name="ln5064">  int flag = 0;</a>
<a name="ln5065">  bool go_to_nextline = false;</a>
<a name="ln5066">  nfa_thread_T *t;</a>
<a name="ln5067">  nfa_list_T list[2];</a>
<a name="ln5068">  int listidx;</a>
<a name="ln5069">  nfa_list_T  *thislist;</a>
<a name="ln5070">  nfa_list_T  *nextlist;</a>
<a name="ln5071">  int         *listids = NULL;</a>
<a name="ln5072">  int listids_len = 0;</a>
<a name="ln5073">  nfa_state_T *add_state;</a>
<a name="ln5074">  bool add_here;</a>
<a name="ln5075">  int add_count;</a>
<a name="ln5076">  int add_off = 0;</a>
<a name="ln5077">  int toplevel = start-&gt;c == NFA_MOPEN;</a>
<a name="ln5078">  regsubs_T *r;</a>
<a name="ln5079">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5080">  FILE        *debug = fopen(NFA_REGEXP_DEBUG_LOG, &quot;a&quot;);</a>
<a name="ln5081"> </a>
<a name="ln5082">  if (debug == NULL) {</a>
<a name="ln5083">    EMSG2(&quot;(NFA) COULD NOT OPEN %s!&quot;, NFA_REGEXP_DEBUG_LOG);</a>
<a name="ln5084">    return false;</a>
<a name="ln5085">  }</a>
<a name="ln5086">#endif</a>
<a name="ln5087">  // Some patterns may take a long time to match, especially when using</a>
<a name="ln5088">  // recursive_regmatch(). Allow interrupting them with CTRL-C.</a>
<a name="ln5089">  fast_breakcheck();</a>
<a name="ln5090">  if (got_int) {</a>
<a name="ln5091">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5092">    fclose(debug);</a>
<a name="ln5093">#endif</a>
<a name="ln5094">    return false;</a>
<a name="ln5095">  }</a>
<a name="ln5096">  if (nfa_did_time_out()) {</a>
<a name="ln5097">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5098">    fclose(debug);</a>
<a name="ln5099">#endif</a>
<a name="ln5100">    return false;</a>
<a name="ln5101">  }</a>
<a name="ln5102"> </a>
<a name="ln5103">  nfa_match = false;</a>
<a name="ln5104"> </a>
<a name="ln5105">  // Allocate memory for the lists of nodes.</a>
<a name="ln5106">  size_t size = (prog-&gt;nstate + 1) * sizeof(nfa_thread_T);</a>
<a name="ln5107">  list[0].t = xmalloc(size);</a>
<a name="ln5108">  list[0].len = prog-&gt;nstate + 1;</a>
<a name="ln5109">  list[1].t = xmalloc(size);</a>
<a name="ln5110">  list[1].len = prog-&gt;nstate + 1;</a>
<a name="ln5111"> </a>
<a name="ln5112">#ifdef REGEXP_DEBUG</a>
<a name="ln5113">  log_fd = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln5114">  if (log_fd != NULL) {</a>
<a name="ln5115">    fprintf(log_fd, &quot;**********************************\n&quot;);</a>
<a name="ln5116">    nfa_set_code(start-&gt;c);</a>
<a name="ln5117">    fprintf(log_fd, &quot; RUNNING nfa_regmatch() starting with state %d, code %s\n&quot;,</a>
<a name="ln5118">        abs(start-&gt;id), code);</a>
<a name="ln5119">    fprintf(log_fd, &quot;**********************************\n&quot;);</a>
<a name="ln5120">  } else {</a>
<a name="ln5121">    EMSG(_(e_log_open_failed));</a>
<a name="ln5122">    log_fd = stderr;</a>
<a name="ln5123">  }</a>
<a name="ln5124">#endif</a>
<a name="ln5125"> </a>
<a name="ln5126">  thislist = &amp;list[0];</a>
<a name="ln5127">  thislist-&gt;n = 0;</a>
<a name="ln5128">  thislist-&gt;has_pim = false;</a>
<a name="ln5129">  nextlist = &amp;list[1];</a>
<a name="ln5130">  nextlist-&gt;n = 0;</a>
<a name="ln5131">  nextlist-&gt;has_pim = false;</a>
<a name="ln5132">#ifdef REGEXP_DEBUG</a>
<a name="ln5133">  fprintf(log_fd, &quot;(---) STARTSTATE first\n&quot;);</a>
<a name="ln5134">#endif</a>
<a name="ln5135">  thislist-&gt;id = rex.nfa_listid + 1;</a>
<a name="ln5136"> </a>
<a name="ln5137">  // Inline optimized code for addstate(thislist, start, m, 0) if we know</a>
<a name="ln5138">  // it's the first MOPEN.</a>
<a name="ln5139">  if (toplevel) {</a>
<a name="ln5140">    if (REG_MULTI) {</a>
<a name="ln5141">      m-&gt;norm.list.multi[0].start_lnum = rex.lnum;</a>
<a name="ln5142">      m-&gt;norm.list.multi[0].start_col = (colnr_T)(rex.input - rex.line);</a>
<a name="ln5143">    } else {</a>
<a name="ln5144">      m-&gt;norm.list.line[0].start = rex.input;</a>
<a name="ln5145">    }</a>
<a name="ln5146">    m-&gt;norm.in_use = 1;</a>
<a name="ln5147">    r = addstate(thislist, start-&gt;out, m, NULL, 0);</a>
<a name="ln5148">  } else {</a>
<a name="ln5149">    r = addstate(thislist, start, m, NULL, 0);</a>
<a name="ln5150">  }</a>
<a name="ln5151">  if (r == NULL) {</a>
<a name="ln5152">    nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln5153">    goto theend;</a>
<a name="ln5154">  }</a>
<a name="ln5155"> </a>
<a name="ln5156">#define ADD_STATE_IF_MATCH(state) \</a>
<a name="ln5157">  if (result) { \</a>
<a name="ln5158">    add_state = state-&gt;out; \</a>
<a name="ln5159">    add_off = clen; \</a>
<a name="ln5160">  }</a>
<a name="ln5161"> </a>
<a name="ln5162">  /*</a>
<a name="ln5163">   * Run for each character.</a>
<a name="ln5164">   */</a>
<a name="ln5165">  for (;; ) {</a>
<a name="ln5166">    int curc = utf_ptr2char(rex.input);</a>
<a name="ln5167">    int clen = utfc_ptr2len(rex.input);</a>
<a name="ln5168">    if (curc == NUL) {</a>
<a name="ln5169">      clen = 0;</a>
<a name="ln5170">      go_to_nextline = false;</a>
<a name="ln5171">    }</a>
<a name="ln5172"> </a>
<a name="ln5173">    /* swap lists */</a>
<a name="ln5174">    thislist = &amp;list[flag];</a>
<a name="ln5175">    nextlist = &amp;list[flag ^= 1];</a>
<a name="ln5176">    nextlist-&gt;n = 0;                // clear nextlist</a>
<a name="ln5177">    nextlist-&gt;has_pim = false;</a>
<a name="ln5178">    rex.nfa_listid++;</a>
<a name="ln5179">    if (prog-&gt;re_engine == AUTOMATIC_ENGINE</a>
<a name="ln5180">        &amp;&amp; (rex.nfa_listid &gt;= NFA_MAX_STATES)) {</a>
<a name="ln5181">      // Too many states, retry with old engine.</a>
<a name="ln5182">      nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln5183">      goto theend;</a>
<a name="ln5184">    }</a>
<a name="ln5185"> </a>
<a name="ln5186">    thislist-&gt;id = rex.nfa_listid;</a>
<a name="ln5187">    nextlist-&gt;id = rex.nfa_listid + 1;</a>
<a name="ln5188"> </a>
<a name="ln5189">#ifdef REGEXP_DEBUG</a>
<a name="ln5190">    fprintf(log_fd, &quot;------------------------------------------\n&quot;);</a>
<a name="ln5191">    fprintf(log_fd, &quot;&gt;&gt;&gt; Reginput is \&quot;%s\&quot;\n&quot;, rex.input);</a>
<a name="ln5192">    fprintf(log_fd,</a>
<a name="ln5193">            &quot;&gt;&gt;&gt; Advanced one character... Current char is %c (code %d) \n&quot;,</a>
<a name="ln5194">            curc,</a>
<a name="ln5195">            (int)curc);</a>
<a name="ln5196">    fprintf(log_fd, &quot;&gt;&gt;&gt; Thislist has %d states available: &quot;, thislist-&gt;n);</a>
<a name="ln5197">    {</a>
<a name="ln5198">      int i;</a>
<a name="ln5199"> </a>
<a name="ln5200">      for (i = 0; i &lt; thislist-&gt;n; i++)</a>
<a name="ln5201">        fprintf(log_fd, &quot;%d  &quot;, abs(thislist-&gt;t[i].state-&gt;id));</a>
<a name="ln5202">    }</a>
<a name="ln5203">    fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln5204">#endif</a>
<a name="ln5205"> </a>
<a name="ln5206">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5207">    fprintf(debug, &quot;\n-------------------\n&quot;);</a>
<a name="ln5208">#endif</a>
<a name="ln5209">    /*</a>
<a name="ln5210">     * If the state lists are empty we can stop.</a>
<a name="ln5211">     */</a>
<a name="ln5212">    if (thislist-&gt;n == 0)</a>
<a name="ln5213">      break;</a>
<a name="ln5214"> </a>
<a name="ln5215">    // compute nextlist</a>
<a name="ln5216">    for (listidx = 0; listidx &lt; thislist-&gt;n; listidx++) {</a>
<a name="ln5217">      // If the list gets very long there probably is something wrong.</a>
<a name="ln5218">      // At least allow interrupting with CTRL-C.</a>
<a name="ln5219">      fast_breakcheck();</a>
<a name="ln5220">      if (got_int) {</a>
<a name="ln5221">        break;</a>
<a name="ln5222">      }</a>
<a name="ln5223">      if (nfa_time_limit != NULL &amp;&amp; ++nfa_time_count == 20) {</a>
<a name="ln5224">        nfa_time_count = 0;</a>
<a name="ln5225">        if (nfa_did_time_out()) {</a>
<a name="ln5226">          break;</a>
<a name="ln5227">        }</a>
<a name="ln5228">      }</a>
<a name="ln5229">      t = &amp;thislist-&gt;t[listidx];</a>
<a name="ln5230"> </a>
<a name="ln5231">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln5232">      nfa_set_code(t-&gt;state-&gt;c);</a>
<a name="ln5233">      fprintf(debug, &quot;%s, &quot;, code);</a>
<a name="ln5234">#endif</a>
<a name="ln5235">#ifdef REGEXP_DEBUG</a>
<a name="ln5236">      {</a>
<a name="ln5237">        int col;</a>
<a name="ln5238"> </a>
<a name="ln5239">        if (t-&gt;subs.norm.in_use &lt;= 0) {</a>
<a name="ln5240">          col = -1;</a>
<a name="ln5241">        } else if (REG_MULTI) {</a>
<a name="ln5242">          col = t-&gt;subs.norm.list.multi[0].start_col;</a>
<a name="ln5243">        } else {</a>
<a name="ln5244">          col = (int)(t-&gt;subs.norm.list.line[0].start - rex.line);</a>
<a name="ln5245">        }</a>
<a name="ln5246">        nfa_set_code(t-&gt;state-&gt;c);</a>
<a name="ln5247">        fprintf(log_fd, &quot;(%d) char %d %s (start col %d)%s... \n&quot;,</a>
<a name="ln5248">                abs(t-&gt;state-&gt;id), (int)t-&gt;state-&gt;c, code, col,</a>
<a name="ln5249">                pim_info(&amp;t-&gt;pim));</a>
<a name="ln5250">      }</a>
<a name="ln5251">#endif</a>
<a name="ln5252"> </a>
<a name="ln5253">      /*</a>
<a name="ln5254">       * Handle the possible codes of the current state.</a>
<a name="ln5255">       * The most important is NFA_MATCH.</a>
<a name="ln5256">       */</a>
<a name="ln5257">      add_state = NULL;</a>
<a name="ln5258">      add_here = false;</a>
<a name="ln5259">      add_count = 0;</a>
<a name="ln5260">      switch (t-&gt;state-&gt;c) {</a>
<a name="ln5261">      case NFA_MATCH:</a>
<a name="ln5262">      {</a>
<a name="ln5263">        // If the match is not at the start of the line, ends before a</a>
<a name="ln5264">        // composing characters and rex.reg_icombine is not set, that</a>
<a name="ln5265">        // is not really a match.</a>
<a name="ln5266">        if (!rex.reg_icombine</a>
<a name="ln5267">            &amp;&amp; rex.input != rex.line</a>
<a name="ln5268">            &amp;&amp; utf_iscomposing(curc)) {</a>
<a name="ln5269">          break;</a>
<a name="ln5270">        }</a>
<a name="ln5271">        nfa_match = true;</a>
<a name="ln5272">        copy_sub(&amp;submatch-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5273">        if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5274">          copy_sub(&amp;submatch-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5275">        }</a>
<a name="ln5276">#ifdef REGEXP_DEBUG</a>
<a name="ln5277">        log_subsexpr(&amp;t-&gt;subs);</a>
<a name="ln5278">#endif</a>
<a name="ln5279">        // Found the left-most longest match, do not look at any other</a>
<a name="ln5280">        // states at this position.  When the list of states is going</a>
<a name="ln5281">        // to be empty quit without advancing, so that &quot;rex.input&quot; is</a>
<a name="ln5282">        // correct.</a>
<a name="ln5283">        if (nextlist-&gt;n == 0) {</a>
<a name="ln5284">          clen = 0;</a>
<a name="ln5285">        }</a>
<a name="ln5286">        goto nextchar;</a>
<a name="ln5287">      }</a>
<a name="ln5288"> </a>
<a name="ln5289">      case NFA_END_INVISIBLE:</a>
<a name="ln5290">      case NFA_END_INVISIBLE_NEG:</a>
<a name="ln5291">      case NFA_END_PATTERN:</a>
<a name="ln5292">        // This is only encountered after a NFA_START_INVISIBLE or</a>
<a name="ln5293">        // NFA_START_INVISIBLE_BEFORE node.</a>
<a name="ln5294">        // They surround a zero-width group, used with &quot;\@=&quot;, &quot;\&amp;&quot;,</a>
<a name="ln5295">        // &quot;\@!&quot;, &quot;\@&lt;=&quot; and &quot;\@&lt;!&quot;.</a>
<a name="ln5296">        // If we got here, it means that the current &quot;invisible&quot; group</a>
<a name="ln5297">        // finished successfully, so return control to the parent</a>
<a name="ln5298">        // nfa_regmatch().  For a look-behind match only when it ends</a>
<a name="ln5299">        // in the position in &quot;nfa_endp&quot;.</a>
<a name="ln5300">        // Submatches are stored in *m, and used in the parent call.</a>
<a name="ln5301">#ifdef REGEXP_DEBUG</a>
<a name="ln5302">        if (nfa_endp != NULL) {</a>
<a name="ln5303">          if (REG_MULTI) {</a>
<a name="ln5304">            fprintf(log_fd,</a>
<a name="ln5305">                    &quot;Current lnum: %d, endp lnum: %d;&quot;</a>
<a name="ln5306">                    &quot; current col: %d, endp col: %d\n&quot;,</a>
<a name="ln5307">                    (int)rex.lnum,</a>
<a name="ln5308">                    (int)nfa_endp-&gt;se_u.pos.lnum,</a>
<a name="ln5309">                    (int)(rex.input - rex.line),</a>
<a name="ln5310">                    nfa_endp-&gt;se_u.pos.col);</a>
<a name="ln5311">          } else {</a>
<a name="ln5312">            fprintf(log_fd, &quot;Current col: %d, endp col: %d\n&quot;,</a>
<a name="ln5313">                    (int)(rex.input - rex.line),</a>
<a name="ln5314">                    (int)(nfa_endp-&gt;se_u.ptr - rex.input));</a>
<a name="ln5315">          }</a>
<a name="ln5316">        }</a>
<a name="ln5317">#endif</a>
<a name="ln5318">        // If &quot;nfa_endp&quot; is set it's only a match if it ends at</a>
<a name="ln5319">        // &quot;nfa_endp&quot;</a>
<a name="ln5320">        if (nfa_endp != NULL</a>
<a name="ln5321">            &amp;&amp; (REG_MULTI</a>
<a name="ln5322">                ? (rex.lnum != nfa_endp-&gt;se_u.pos.lnum</a>
<a name="ln5323">                   || (int)(rex.input - rex.line) != nfa_endp-&gt;se_u.pos.col)</a>
<a name="ln5324">                : rex.input != nfa_endp-&gt;se_u.ptr)) {</a>
<a name="ln5325">          break;</a>
<a name="ln5326">        }</a>
<a name="ln5327">        // do not set submatches for \@!</a>
<a name="ln5328">        if (t-&gt;state-&gt;c != NFA_END_INVISIBLE_NEG) {</a>
<a name="ln5329">          copy_sub(&amp;m-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5330">          if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5331">            copy_sub(&amp;m-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5332">          }</a>
<a name="ln5333">        }</a>
<a name="ln5334">#ifdef REGEXP_DEBUG</a>
<a name="ln5335">        fprintf(log_fd, &quot;Match found:\n&quot;);</a>
<a name="ln5336">        log_subsexpr(m);</a>
<a name="ln5337">#endif</a>
<a name="ln5338">        nfa_match = true;</a>
<a name="ln5339">        // See comment above at &quot;goto nextchar&quot;.</a>
<a name="ln5340">        if (nextlist-&gt;n == 0) {</a>
<a name="ln5341">          clen = 0;</a>
<a name="ln5342">        }</a>
<a name="ln5343">        goto nextchar;</a>
<a name="ln5344"> </a>
<a name="ln5345">      case NFA_START_INVISIBLE:</a>
<a name="ln5346">      case NFA_START_INVISIBLE_FIRST:</a>
<a name="ln5347">      case NFA_START_INVISIBLE_NEG:</a>
<a name="ln5348">      case NFA_START_INVISIBLE_NEG_FIRST:</a>
<a name="ln5349">      case NFA_START_INVISIBLE_BEFORE:</a>
<a name="ln5350">      case NFA_START_INVISIBLE_BEFORE_FIRST:</a>
<a name="ln5351">      case NFA_START_INVISIBLE_BEFORE_NEG:</a>
<a name="ln5352">      case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:</a>
<a name="ln5353">      {</a>
<a name="ln5354">#ifdef REGEXP_DEBUG</a>
<a name="ln5355">        fprintf(log_fd, &quot;Failure chance invisible: %d, what follows: %d\n&quot;,</a>
<a name="ln5356">            failure_chance(t-&gt;state-&gt;out, 0),</a>
<a name="ln5357">            failure_chance(t-&gt;state-&gt;out1-&gt;out, 0));</a>
<a name="ln5358">#endif</a>
<a name="ln5359">        // Do it directly if there already is a PIM or when</a>
<a name="ln5360">        // nfa_postprocess() detected it will work better.</a>
<a name="ln5361">        if (t-&gt;pim.result != NFA_PIM_UNUSED</a>
<a name="ln5362">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_FIRST</a>
<a name="ln5363">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln5364">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_BEFORE_FIRST</a>
<a name="ln5365">            || t-&gt;state-&gt;c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST) {</a>
<a name="ln5366">          int in_use = m-&gt;norm.in_use;</a>
<a name="ln5367"> </a>
<a name="ln5368">          // Copy submatch info for the recursive call, opposite</a>
<a name="ln5369">          // of what happens on success below.</a>
<a name="ln5370">          copy_sub_off(&amp;m-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5371">          if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5372">            copy_sub_off(&amp;m-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5373">          }</a>
<a name="ln5374">          // First try matching the invisible match, then what</a>
<a name="ln5375">          // follows.</a>
<a name="ln5376">          result = recursive_regmatch(t-&gt;state, NULL, prog, submatch, m,</a>
<a name="ln5377">                                      &amp;listids, &amp;listids_len);</a>
<a name="ln5378">          if (result == NFA_TOO_EXPENSIVE) {</a>
<a name="ln5379">            nfa_match = result;</a>
<a name="ln5380">            goto theend;</a>
<a name="ln5381">          }</a>
<a name="ln5382"> </a>
<a name="ln5383">          // for \@! and \@&lt;! it is a match when the result is</a>
<a name="ln5384">          // false</a>
<a name="ln5385">          if (result != (t-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG</a>
<a name="ln5386">                         || t-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln5387">                         || t-&gt;state-&gt;c</a>
<a name="ln5388">                         == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln5389">                         || t-&gt;state-&gt;c</a>
<a name="ln5390">                         == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {</a>
<a name="ln5391">            // Copy submatch info from the recursive call</a>
<a name="ln5392">            copy_sub_off(&amp;t-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln5393">            if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5394">              copy_sub_off(&amp;t-&gt;subs.synt, &amp;m-&gt;synt);</a>
<a name="ln5395">            }</a>
<a name="ln5396">            // If the pattern has \ze and it matched in the</a>
<a name="ln5397">            // sub pattern, use it.</a>
<a name="ln5398">            copy_ze_off(&amp;t-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln5399"> </a>
<a name="ln5400">            // t-&gt;state-&gt;out1 is the corresponding</a>
<a name="ln5401">            // END_INVISIBLE node; Add its out to the current</a>
<a name="ln5402">            // list (zero-width match).</a>
<a name="ln5403">            add_here = true;</a>
<a name="ln5404">            add_state = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5405">          }</a>
<a name="ln5406">          m-&gt;norm.in_use = in_use;</a>
<a name="ln5407">        } else {</a>
<a name="ln5408">          nfa_pim_T pim;</a>
<a name="ln5409"> </a>
<a name="ln5410">          // First try matching what follows.  Only if a match</a>
<a name="ln5411">          // is found verify the invisible match matches.  Add a</a>
<a name="ln5412">          // nfa_pim_T to the following states, it contains info</a>
<a name="ln5413">          // about the invisible match.</a>
<a name="ln5414">          pim.state = t-&gt;state;</a>
<a name="ln5415">          pim.result = NFA_PIM_TODO;</a>
<a name="ln5416">          pim.subs.norm.in_use = 0;</a>
<a name="ln5417">          pim.subs.synt.in_use = 0;</a>
<a name="ln5418">          if (REG_MULTI) {</a>
<a name="ln5419">            pim.end.pos.col = (int)(rex.input - rex.line);</a>
<a name="ln5420">            pim.end.pos.lnum = rex.lnum;</a>
<a name="ln5421">          } else {</a>
<a name="ln5422">            pim.end.ptr = rex.input;</a>
<a name="ln5423">          }</a>
<a name="ln5424">          // t-&gt;state-&gt;out1 is the corresponding END_INVISIBLE</a>
<a name="ln5425">          // node; Add its out to the current list (zero-width</a>
<a name="ln5426">          // match).</a>
<a name="ln5427">          if (addstate_here(thislist, t-&gt;state-&gt;out1-&gt;out, &amp;t-&gt;subs,</a>
<a name="ln5428">                            &amp;pim, &amp;listidx) == NULL) {</a>
<a name="ln5429">            nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln5430">            goto theend;</a>
<a name="ln5431">          }</a>
<a name="ln5432">        }</a>
<a name="ln5433">      }</a>
<a name="ln5434">      break;</a>
<a name="ln5435"> </a>
<a name="ln5436">      case NFA_START_PATTERN:</a>
<a name="ln5437">      {</a>
<a name="ln5438">        nfa_state_T *skip = NULL;</a>
<a name="ln5439">#ifdef REGEXP_DEBUG</a>
<a name="ln5440">        int skip_lid = 0;</a>
<a name="ln5441">#endif</a>
<a name="ln5442"> </a>
<a name="ln5443">        // There is no point in trying to match the pattern if the</a>
<a name="ln5444">        // output state is not going to be added to the list.</a>
<a name="ln5445">        if (state_in_list(nextlist, t-&gt;state-&gt;out1-&gt;out, &amp;t-&gt;subs)) {</a>
<a name="ln5446">          skip = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5447">#ifdef REGEXP_DEBUG</a>
<a name="ln5448">          skip_lid = nextlist-&gt;id;</a>
<a name="ln5449">#endif</a>
<a name="ln5450">        } else if (state_in_list(nextlist,</a>
<a name="ln5451">                       t-&gt;state-&gt;out1-&gt;out-&gt;out, &amp;t-&gt;subs)) {</a>
<a name="ln5452">          skip = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5453">#ifdef REGEXP_DEBUG</a>
<a name="ln5454">          skip_lid = nextlist-&gt;id;</a>
<a name="ln5455">#endif</a>
<a name="ln5456">        } else if (state_in_list(thislist,</a>
<a name="ln5457">                       t-&gt;state-&gt;out1-&gt;out-&gt;out, &amp;t-&gt;subs)) {</a>
<a name="ln5458">          skip = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5459">#ifdef REGEXP_DEBUG</a>
<a name="ln5460">          skip_lid = thislist-&gt;id;</a>
<a name="ln5461">#endif</a>
<a name="ln5462">        }</a>
<a name="ln5463">        if (skip != NULL) {</a>
<a name="ln5464">#ifdef REGEXP_DEBUG</a>
<a name="ln5465">          nfa_set_code(skip-&gt;c);</a>
<a name="ln5466">          fprintf(</a>
<a name="ln5467">              log_fd,</a>
<a name="ln5468">              &quot;&gt; Not trying to match pattern, output state %d is already in list %d. char %d: %s\n&quot;,</a>
<a name="ln5469">              abs(skip-&gt;id), skip_lid, skip-&gt;c, code);</a>
<a name="ln5470">#endif</a>
<a name="ln5471">          break;</a>
<a name="ln5472">        }</a>
<a name="ln5473">        // Copy submatch info to the recursive call, opposite of what</a>
<a name="ln5474">        // happens afterwards.</a>
<a name="ln5475">        copy_sub_off(&amp;m-&gt;norm, &amp;t-&gt;subs.norm);</a>
<a name="ln5476">        if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5477">          copy_sub_off(&amp;m-&gt;synt, &amp;t-&gt;subs.synt);</a>
<a name="ln5478">        }</a>
<a name="ln5479"> </a>
<a name="ln5480">        // First try matching the pattern.</a>
<a name="ln5481">        result = recursive_regmatch(t-&gt;state, NULL, prog, submatch, m,</a>
<a name="ln5482">                                    &amp;listids, &amp;listids_len);</a>
<a name="ln5483">        if (result == NFA_TOO_EXPENSIVE) {</a>
<a name="ln5484">          nfa_match = result;</a>
<a name="ln5485">          goto theend;</a>
<a name="ln5486">        }</a>
<a name="ln5487">        if (result) {</a>
<a name="ln5488">          int bytelen;</a>
<a name="ln5489"> </a>
<a name="ln5490">#ifdef REGEXP_DEBUG</a>
<a name="ln5491">          fprintf(log_fd, &quot;NFA_START_PATTERN matches:\n&quot;);</a>
<a name="ln5492">          log_subsexpr(m);</a>
<a name="ln5493">#endif</a>
<a name="ln5494">          // Copy submatch info from the recursive call</a>
<a name="ln5495">          copy_sub_off(&amp;t-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln5496">          if (rex.nfa_has_zsubexpr) {</a>
<a name="ln5497">            copy_sub_off(&amp;t-&gt;subs.synt, &amp;m-&gt;synt);</a>
<a name="ln5498">          }</a>
<a name="ln5499">          // Now we need to skip over the matched text and then</a>
<a name="ln5500">          // continue with what follows.</a>
<a name="ln5501">          if (REG_MULTI) {</a>
<a name="ln5502">            // TODO(RE): multi-line match</a>
<a name="ln5503">            bytelen = m-&gt;norm.list.multi[0].end_col</a>
<a name="ln5504">                      - (int)(rex.input - rex.line);</a>
<a name="ln5505">          } else {</a>
<a name="ln5506">            bytelen = (int)(m-&gt;norm.list.line[0].end - rex.input);</a>
<a name="ln5507">          }</a>
<a name="ln5508"> </a>
<a name="ln5509">#ifdef REGEXP_DEBUG</a>
<a name="ln5510">          fprintf(log_fd, &quot;NFA_START_PATTERN length: %d\n&quot;, bytelen);</a>
<a name="ln5511">#endif</a>
<a name="ln5512">          if (bytelen == 0) {</a>
<a name="ln5513">            // empty match, output of corresponding</a>
<a name="ln5514">            // NFA_END_PATTERN/NFA_SKIP to be used at current</a>
<a name="ln5515">            // position</a>
<a name="ln5516">            add_here = true;</a>
<a name="ln5517">            add_state = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5518">          } else if (bytelen &lt;= clen) {</a>
<a name="ln5519">            // match current character, output of corresponding</a>
<a name="ln5520">            // NFA_END_PATTERN to be used at next position.</a>
<a name="ln5521">            add_state = t-&gt;state-&gt;out1-&gt;out-&gt;out;</a>
<a name="ln5522">            add_off = clen;</a>
<a name="ln5523">          } else {</a>
<a name="ln5524">            // skip over the matched characters, set character</a>
<a name="ln5525">            // count in NFA_SKIP</a>
<a name="ln5526">            add_state = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5527">            add_off = bytelen;</a>
<a name="ln5528">            add_count = bytelen - clen;</a>
<a name="ln5529">          }</a>
<a name="ln5530">        }</a>
<a name="ln5531">        break;</a>
<a name="ln5532">      }</a>
<a name="ln5533"> </a>
<a name="ln5534">      case NFA_BOL:</a>
<a name="ln5535">        if (rex.input == rex.line) {</a>
<a name="ln5536">          add_here = true;</a>
<a name="ln5537">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5538">        }</a>
<a name="ln5539">        break;</a>
<a name="ln5540"> </a>
<a name="ln5541">      case NFA_EOL:</a>
<a name="ln5542">        if (curc == NUL) {</a>
<a name="ln5543">          add_here = true;</a>
<a name="ln5544">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5545">        }</a>
<a name="ln5546">        break;</a>
<a name="ln5547"> </a>
<a name="ln5548">      case NFA_BOW:</a>
<a name="ln5549">        result = true;</a>
<a name="ln5550"> </a>
<a name="ln5551">        if (curc == NUL) {</a>
<a name="ln5552">          result = false;</a>
<a name="ln5553">        } else {</a>
<a name="ln5554">          int this_class;</a>
<a name="ln5555"> </a>
<a name="ln5556">          // Get class of current and previous char (if it exists).</a>
<a name="ln5557">          this_class = mb_get_class_tab(rex.input, rex.reg_buf-&gt;b_chartab);</a>
<a name="ln5558">          if (this_class &lt;= 1) {</a>
<a name="ln5559">            result = false;</a>
<a name="ln5560">          } else if (reg_prev_class() == this_class) {</a>
<a name="ln5561">            result = false;</a>
<a name="ln5562">          }</a>
<a name="ln5563">        }</a>
<a name="ln5564">        if (result) {</a>
<a name="ln5565">          add_here = true;</a>
<a name="ln5566">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5567">        }</a>
<a name="ln5568">        break;</a>
<a name="ln5569"> </a>
<a name="ln5570">      case NFA_EOW:</a>
<a name="ln5571">        result = true;</a>
<a name="ln5572">        if (rex.input == rex.line) {</a>
<a name="ln5573">          result = false;</a>
<a name="ln5574">        } else {</a>
<a name="ln5575">          int this_class, prev_class;</a>
<a name="ln5576"> </a>
<a name="ln5577">          // Get class of current and previous char (if it exists).</a>
<a name="ln5578">          this_class = mb_get_class_tab(rex.input, rex.reg_buf-&gt;b_chartab);</a>
<a name="ln5579">          prev_class = reg_prev_class();</a>
<a name="ln5580">          if (this_class == prev_class</a>
<a name="ln5581">              || prev_class == 0 || prev_class == 1) {</a>
<a name="ln5582">            result = false;</a>
<a name="ln5583">          }</a>
<a name="ln5584">        }</a>
<a name="ln5585">        if (result) {</a>
<a name="ln5586">          add_here = true;</a>
<a name="ln5587">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5588">        }</a>
<a name="ln5589">        break;</a>
<a name="ln5590"> </a>
<a name="ln5591">      case NFA_BOF:</a>
<a name="ln5592">        if (rex.lnum == 0 &amp;&amp; rex.input == rex.line</a>
<a name="ln5593">            &amp;&amp; (!REG_MULTI || rex.reg_firstlnum == 1)) {</a>
<a name="ln5594">          add_here = true;</a>
<a name="ln5595">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5596">        }</a>
<a name="ln5597">        break;</a>
<a name="ln5598"> </a>
<a name="ln5599">      case NFA_EOF:</a>
<a name="ln5600">        if (rex.lnum == rex.reg_maxline &amp;&amp; curc == NUL) {</a>
<a name="ln5601">          add_here = true;</a>
<a name="ln5602">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5603">        }</a>
<a name="ln5604">        break;</a>
<a name="ln5605"> </a>
<a name="ln5606">      case NFA_COMPOSING:</a>
<a name="ln5607">      {</a>
<a name="ln5608">        int mc = curc;</a>
<a name="ln5609">        int len = 0;</a>
<a name="ln5610">        nfa_state_T *end;</a>
<a name="ln5611">        nfa_state_T *sta;</a>
<a name="ln5612">        int cchars[MAX_MCO];</a>
<a name="ln5613">        int ccount = 0;</a>
<a name="ln5614">        int j;</a>
<a name="ln5615"> </a>
<a name="ln5616">        sta = t-&gt;state-&gt;out;</a>
<a name="ln5617">        len = 0;</a>
<a name="ln5618">        if (utf_iscomposing(sta-&gt;c)) {</a>
<a name="ln5619">          // Only match composing character(s), ignore base</a>
<a name="ln5620">          // character.  Used for &quot;.{composing}&quot; and &quot;{composing}&quot;</a>
<a name="ln5621">          // (no preceding character).</a>
<a name="ln5622">          len += mb_char2len(mc);</a>
<a name="ln5623">        }</a>
<a name="ln5624">        if (rex.reg_icombine &amp;&amp; len == 0) {</a>
<a name="ln5625">          // If \Z was present, then ignore composing characters.</a>
<a name="ln5626">          // When ignoring the base character this always matches.</a>
<a name="ln5627">          if (sta-&gt;c != curc) {</a>
<a name="ln5628">            result = FAIL;</a>
<a name="ln5629">          } else {</a>
<a name="ln5630">            result = OK;</a>
<a name="ln5631">          }</a>
<a name="ln5632">          while (sta-&gt;c != NFA_END_COMPOSING) {</a>
<a name="ln5633">            sta = sta-&gt;out;</a>
<a name="ln5634">          }</a>
<a name="ln5635">        } else if (len &gt; 0 || mc == sta-&gt;c) {</a>
<a name="ln5636">          // Check base character matches first, unless ignored.</a>
<a name="ln5637">          if (len == 0) {</a>
<a name="ln5638">            len += mb_char2len(mc);</a>
<a name="ln5639">            sta = sta-&gt;out;</a>
<a name="ln5640">          }</a>
<a name="ln5641"> </a>
<a name="ln5642">          // We don't care about the order of composing characters.</a>
<a name="ln5643">          // Get them into cchars[] first.</a>
<a name="ln5644">          while (len &lt; clen) {</a>
<a name="ln5645">            mc = utf_ptr2char(rex.input + len);</a>
<a name="ln5646">            cchars[ccount++] = mc;</a>
<a name="ln5647">            len += mb_char2len(mc);</a>
<a name="ln5648">            if (ccount == MAX_MCO)</a>
<a name="ln5649">              break;</a>
<a name="ln5650">          }</a>
<a name="ln5651"> </a>
<a name="ln5652">          // Check that each composing char in the pattern matches a</a>
<a name="ln5653">          // composing char in the text.  We do not check if all</a>
<a name="ln5654">          // composing chars are matched.</a>
<a name="ln5655">          result = OK;</a>
<a name="ln5656">          while (sta-&gt;c != NFA_END_COMPOSING) {</a>
<a name="ln5657">            for (j = 0; j &lt; ccount; ++j)</a>
<a name="ln5658">              if (cchars[j] == sta-&gt;c)</a>
<a name="ln5659">                break;</a>
<a name="ln5660">            if (j == ccount) {</a>
<a name="ln5661">              result = FAIL;</a>
<a name="ln5662">              break;</a>
<a name="ln5663">            }</a>
<a name="ln5664">            sta = sta-&gt;out;</a>
<a name="ln5665">          }</a>
<a name="ln5666">        } else</a>
<a name="ln5667">          result = FAIL;</a>
<a name="ln5668"> </a>
<a name="ln5669">        end = t-&gt;state-&gt;out1;               // NFA_END_COMPOSING</a>
<a name="ln5670">        ADD_STATE_IF_MATCH(end);</a>
<a name="ln5671">        break;</a>
<a name="ln5672">      }</a>
<a name="ln5673"> </a>
<a name="ln5674">      case NFA_NEWL:</a>
<a name="ln5675">        if (curc == NUL &amp;&amp; !rex.reg_line_lbr &amp;&amp; REG_MULTI</a>
<a name="ln5676">            &amp;&amp; rex.lnum &lt;= rex.reg_maxline) {</a>
<a name="ln5677">          go_to_nextline = true;</a>
<a name="ln5678">          // Pass -1 for the offset, which means taking the position</a>
<a name="ln5679">          // at the start of the next line.</a>
<a name="ln5680">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5681">          add_off = -1;</a>
<a name="ln5682">        } else if (curc == '\n' &amp;&amp; rex.reg_line_lbr) {</a>
<a name="ln5683">          // match \n as if it is an ordinary character</a>
<a name="ln5684">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5685">          add_off = 1;</a>
<a name="ln5686">        }</a>
<a name="ln5687">        break;</a>
<a name="ln5688"> </a>
<a name="ln5689">      case NFA_START_COLL:</a>
<a name="ln5690">      case NFA_START_NEG_COLL:</a>
<a name="ln5691">      {</a>
<a name="ln5692">        // What follows is a list of characters, until NFA_END_COLL.</a>
<a name="ln5693">        // One of them must match or none of them must match.</a>
<a name="ln5694">        nfa_state_T     *state;</a>
<a name="ln5695">        int result_if_matched;</a>
<a name="ln5696">        int c1, c2;</a>
<a name="ln5697"> </a>
<a name="ln5698">        // Never match EOL. If it's part of the collection it is added</a>
<a name="ln5699">        // as a separate state with an OR.</a>
<a name="ln5700">        if (curc == NUL) {</a>
<a name="ln5701">          break;</a>
<a name="ln5702">        }</a>
<a name="ln5703"> </a>
<a name="ln5704">        state = t-&gt;state-&gt;out;</a>
<a name="ln5705">        result_if_matched = (t-&gt;state-&gt;c == NFA_START_COLL);</a>
<a name="ln5706">        for (;; ) {</a>
<a name="ln5707">          if (state-&gt;c == NFA_END_COLL) {</a>
<a name="ln5708">            result = !result_if_matched;</a>
<a name="ln5709">            break;</a>
<a name="ln5710">          }</a>
<a name="ln5711">          if (state-&gt;c == NFA_RANGE_MIN) {</a>
<a name="ln5712">            c1 = state-&gt;val;</a>
<a name="ln5713">            state = state-&gt;out;             // advance to NFA_RANGE_MAX</a>
<a name="ln5714">            c2 = state-&gt;val;</a>
<a name="ln5715">#ifdef REGEXP_DEBUG</a>
<a name="ln5716">            fprintf(log_fd, &quot;NFA_RANGE_MIN curc=%d c1=%d c2=%d\n&quot;,</a>
<a name="ln5717">                curc, c1, c2);</a>
<a name="ln5718">#endif</a>
<a name="ln5719">            if (curc &gt;= c1 &amp;&amp; curc &lt;= c2) {</a>
<a name="ln5720">              result = result_if_matched;</a>
<a name="ln5721">              break;</a>
<a name="ln5722">            }</a>
<a name="ln5723">            if (rex.reg_ic) {</a>
<a name="ln5724">              int curc_low = utf_fold(curc);</a>
<a name="ln5725">              int done = false;</a>
<a name="ln5726"> </a>
<a name="ln5727">              for (; c1 &lt;= c2; c1++) {</a>
<a name="ln5728">                if (utf_fold(c1) == curc_low) {</a>
<a name="ln5729">                  result = result_if_matched;</a>
<a name="ln5730">                  done = true;</a>
<a name="ln5731">                  break;</a>
<a name="ln5732">                }</a>
<a name="ln5733">              }</a>
<a name="ln5734">              if (done) {</a>
<a name="ln5735">                break;</a>
<a name="ln5736">              }</a>
<a name="ln5737">            }</a>
<a name="ln5738">          } else if (state-&gt;c &lt; 0 ? check_char_class(state-&gt;c, curc)</a>
<a name="ln5739">                     : (curc == state-&gt;c</a>
<a name="ln5740">                        || (rex.reg_ic</a>
<a name="ln5741">                            &amp;&amp; utf_fold(curc) == utf_fold(state-&gt;c)))) {</a>
<a name="ln5742">            result = result_if_matched;</a>
<a name="ln5743">            break;</a>
<a name="ln5744">          }</a>
<a name="ln5745">          state = state-&gt;out;</a>
<a name="ln5746">        }</a>
<a name="ln5747">        if (result) {</a>
<a name="ln5748">          // next state is in out of the NFA_END_COLL, out1 of</a>
<a name="ln5749">          // START points to the END state</a>
<a name="ln5750">          add_state = t-&gt;state-&gt;out1-&gt;out;</a>
<a name="ln5751">          add_off = clen;</a>
<a name="ln5752">        }</a>
<a name="ln5753">        break;</a>
<a name="ln5754">      }</a>
<a name="ln5755"> </a>
<a name="ln5756">      case NFA_ANY:</a>
<a name="ln5757">        // Any char except '\0', (end of input) does not match.</a>
<a name="ln5758">        if (curc &gt; 0) {</a>
<a name="ln5759">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5760">          add_off = clen;</a>
<a name="ln5761">        }</a>
<a name="ln5762">        break;</a>
<a name="ln5763"> </a>
<a name="ln5764">      case NFA_ANY_COMPOSING:</a>
<a name="ln5765">        // On a composing character skip over it.  Otherwise do</a>
<a name="ln5766">        // nothing.  Always matches.</a>
<a name="ln5767">        if (utf_iscomposing(curc)) {</a>
<a name="ln5768">          add_off = clen;</a>
<a name="ln5769">        } else {</a>
<a name="ln5770">          add_here = true;</a>
<a name="ln5771">          add_off = 0;</a>
<a name="ln5772">        }</a>
<a name="ln5773">        add_state = t-&gt;state-&gt;out;</a>
<a name="ln5774">        break;</a>
<a name="ln5775"> </a>
<a name="ln5776">      // Character classes like \a for alpha, \d for digit etc.</a>
<a name="ln5777">      case NFA_IDENT:           //  \i</a>
<a name="ln5778">        result = vim_isIDc(curc);</a>
<a name="ln5779">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5780">        break;</a>
<a name="ln5781"> </a>
<a name="ln5782">      case NFA_SIDENT:          //  \I</a>
<a name="ln5783">        result = !ascii_isdigit(curc) &amp;&amp; vim_isIDc(curc);</a>
<a name="ln5784">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5785">        break;</a>
<a name="ln5786"> </a>
<a name="ln5787">      case NFA_KWORD:           //  \k</a>
<a name="ln5788">        result = vim_iswordp_buf(rex.input, rex.reg_buf);</a>
<a name="ln5789">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5790">        break;</a>
<a name="ln5791"> </a>
<a name="ln5792">      case NFA_SKWORD:          //  \K</a>
<a name="ln5793">        result = !ascii_isdigit(curc)</a>
<a name="ln5794">                 &amp;&amp; vim_iswordp_buf(rex.input, rex.reg_buf);</a>
<a name="ln5795">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5796">        break;</a>
<a name="ln5797"> </a>
<a name="ln5798">      case NFA_FNAME:           //  \f</a>
<a name="ln5799">        result = vim_isfilec(curc);</a>
<a name="ln5800">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5801">        break;</a>
<a name="ln5802"> </a>
<a name="ln5803">      case NFA_SFNAME:          //  \F</a>
<a name="ln5804">        result = !ascii_isdigit(curc) &amp;&amp; vim_isfilec(curc);</a>
<a name="ln5805">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5806">        break;</a>
<a name="ln5807"> </a>
<a name="ln5808">      case NFA_PRINT:           //  \p</a>
<a name="ln5809">        result = vim_isprintc(PTR2CHAR(rex.input));</a>
<a name="ln5810">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5811">        break;</a>
<a name="ln5812"> </a>
<a name="ln5813">      case NFA_SPRINT:          //  \P</a>
<a name="ln5814">        result = !ascii_isdigit(curc) &amp;&amp; vim_isprintc(PTR2CHAR(rex.input));</a>
<a name="ln5815">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5816">        break;</a>
<a name="ln5817"> </a>
<a name="ln5818">      case NFA_WHITE:           //  \s</a>
<a name="ln5819">        result = ascii_iswhite(curc);</a>
<a name="ln5820">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5821">        break;</a>
<a name="ln5822"> </a>
<a name="ln5823">      case NFA_NWHITE:          //  \S</a>
<a name="ln5824">        result = curc != NUL &amp;&amp; !ascii_iswhite(curc);</a>
<a name="ln5825">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5826">        break;</a>
<a name="ln5827"> </a>
<a name="ln5828">      case NFA_DIGIT:           //  \d</a>
<a name="ln5829">        result = ri_digit(curc);</a>
<a name="ln5830">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5831">        break;</a>
<a name="ln5832"> </a>
<a name="ln5833">      case NFA_NDIGIT:          //  \D</a>
<a name="ln5834">        result = curc != NUL &amp;&amp; !ri_digit(curc);</a>
<a name="ln5835">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5836">        break;</a>
<a name="ln5837"> </a>
<a name="ln5838">      case NFA_HEX:             //  \x</a>
<a name="ln5839">        result = ri_hex(curc);</a>
<a name="ln5840">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5841">        break;</a>
<a name="ln5842"> </a>
<a name="ln5843">      case NFA_NHEX:            //  \X</a>
<a name="ln5844">        result = curc != NUL &amp;&amp; !ri_hex(curc);</a>
<a name="ln5845">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5846">        break;</a>
<a name="ln5847"> </a>
<a name="ln5848">      case NFA_OCTAL:           //  \o</a>
<a name="ln5849">        result = ri_octal(curc);</a>
<a name="ln5850">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5851">        break;</a>
<a name="ln5852"> </a>
<a name="ln5853">      case NFA_NOCTAL:          //  \O</a>
<a name="ln5854">        result = curc != NUL &amp;&amp; !ri_octal(curc);</a>
<a name="ln5855">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5856">        break;</a>
<a name="ln5857"> </a>
<a name="ln5858">      case NFA_WORD:            //  \w</a>
<a name="ln5859">        result = ri_word(curc);</a>
<a name="ln5860">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5861">        break;</a>
<a name="ln5862"> </a>
<a name="ln5863">      case NFA_NWORD:           //  \W</a>
<a name="ln5864">        result = curc != NUL &amp;&amp; !ri_word(curc);</a>
<a name="ln5865">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5866">        break;</a>
<a name="ln5867"> </a>
<a name="ln5868">      case NFA_HEAD:            //  \h</a>
<a name="ln5869">        result = ri_head(curc);</a>
<a name="ln5870">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5871">        break;</a>
<a name="ln5872"> </a>
<a name="ln5873">      case NFA_NHEAD:           //  \H</a>
<a name="ln5874">        result = curc != NUL &amp;&amp; !ri_head(curc);</a>
<a name="ln5875">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5876">        break;</a>
<a name="ln5877"> </a>
<a name="ln5878">      case NFA_ALPHA:           //  \a</a>
<a name="ln5879">        result = ri_alpha(curc);</a>
<a name="ln5880">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5881">        break;</a>
<a name="ln5882"> </a>
<a name="ln5883">      case NFA_NALPHA:          //  \A</a>
<a name="ln5884">        result = curc != NUL &amp;&amp; !ri_alpha(curc);</a>
<a name="ln5885">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5886">        break;</a>
<a name="ln5887"> </a>
<a name="ln5888">      case NFA_LOWER:           //  \l</a>
<a name="ln5889">        result = ri_lower(curc);</a>
<a name="ln5890">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5891">        break;</a>
<a name="ln5892"> </a>
<a name="ln5893">      case NFA_NLOWER:          //  \L</a>
<a name="ln5894">        result = curc != NUL &amp;&amp; !ri_lower(curc);</a>
<a name="ln5895">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5896">        break;</a>
<a name="ln5897"> </a>
<a name="ln5898">      case NFA_UPPER:           //  \u</a>
<a name="ln5899">        result = ri_upper(curc);</a>
<a name="ln5900">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5901">        break;</a>
<a name="ln5902"> </a>
<a name="ln5903">      case NFA_NUPPER:          // \U</a>
<a name="ln5904">        result = curc != NUL &amp;&amp; !ri_upper(curc);</a>
<a name="ln5905">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5906">        break;</a>
<a name="ln5907"> </a>
<a name="ln5908">      case NFA_LOWER_IC:        // [a-z]</a>
<a name="ln5909">        result = ri_lower(curc) || (rex.reg_ic &amp;&amp; ri_upper(curc));</a>
<a name="ln5910">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5911">        break;</a>
<a name="ln5912"> </a>
<a name="ln5913">      case NFA_NLOWER_IC:       // [^a-z]</a>
<a name="ln5914">        result = curc != NUL</a>
<a name="ln5915">                 &amp;&amp; !(ri_lower(curc) || (rex.reg_ic &amp;&amp; ri_upper(curc)));</a>
<a name="ln5916">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5917">        break;</a>
<a name="ln5918"> </a>
<a name="ln5919">      case NFA_UPPER_IC:        // [A-Z]</a>
<a name="ln5920">        result = ri_upper(curc) || (rex.reg_ic &amp;&amp; ri_lower(curc));</a>
<a name="ln5921">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5922">        break;</a>
<a name="ln5923"> </a>
<a name="ln5924">      case NFA_NUPPER_IC:       // [^A-Z]</a>
<a name="ln5925">        result = curc != NUL</a>
<a name="ln5926">                 &amp;&amp; !(ri_upper(curc) || (rex.reg_ic &amp;&amp; ri_lower(curc)));</a>
<a name="ln5927">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln5928">        break;</a>
<a name="ln5929"> </a>
<a name="ln5930">      case NFA_BACKREF1:</a>
<a name="ln5931">      case NFA_BACKREF2:</a>
<a name="ln5932">      case NFA_BACKREF3:</a>
<a name="ln5933">      case NFA_BACKREF4:</a>
<a name="ln5934">      case NFA_BACKREF5:</a>
<a name="ln5935">      case NFA_BACKREF6:</a>
<a name="ln5936">      case NFA_BACKREF7:</a>
<a name="ln5937">      case NFA_BACKREF8:</a>
<a name="ln5938">      case NFA_BACKREF9:</a>
<a name="ln5939">      case NFA_ZREF1:</a>
<a name="ln5940">      case NFA_ZREF2:</a>
<a name="ln5941">      case NFA_ZREF3:</a>
<a name="ln5942">      case NFA_ZREF4:</a>
<a name="ln5943">      case NFA_ZREF5:</a>
<a name="ln5944">      case NFA_ZREF6:</a>
<a name="ln5945">      case NFA_ZREF7:</a>
<a name="ln5946">      case NFA_ZREF8:</a>
<a name="ln5947">      case NFA_ZREF9:</a>
<a name="ln5948">        // \1 .. \9  \z1 .. \z9</a>
<a name="ln5949">      {</a>
<a name="ln5950">        int subidx;</a>
<a name="ln5951">        int bytelen;</a>
<a name="ln5952"> </a>
<a name="ln5953">        if (t-&gt;state-&gt;c &lt;= NFA_BACKREF9) {</a>
<a name="ln5954">          subidx = t-&gt;state-&gt;c - NFA_BACKREF1 + 1;</a>
<a name="ln5955">          result = match_backref(&amp;t-&gt;subs.norm, subidx, &amp;bytelen);</a>
<a name="ln5956">        } else {</a>
<a name="ln5957">          subidx = t-&gt;state-&gt;c - NFA_ZREF1 + 1;</a>
<a name="ln5958">          result = match_zref(subidx, &amp;bytelen);</a>
<a name="ln5959">        }</a>
<a name="ln5960"> </a>
<a name="ln5961">        if (result) {</a>
<a name="ln5962">          if (bytelen == 0) {</a>
<a name="ln5963">            // empty match always works, output of NFA_SKIP to be</a>
<a name="ln5964">            // used next</a>
<a name="ln5965">            add_here = true;</a>
<a name="ln5966">            add_state = t-&gt;state-&gt;out-&gt;out;</a>
<a name="ln5967">          } else if (bytelen &lt;= clen) {</a>
<a name="ln5968">            // match current character, jump ahead to out of</a>
<a name="ln5969">            // NFA_SKIP</a>
<a name="ln5970">            add_state = t-&gt;state-&gt;out-&gt;out;</a>
<a name="ln5971">            add_off = clen;</a>
<a name="ln5972">          } else {</a>
<a name="ln5973">            // skip over the matched characters, set character</a>
<a name="ln5974">            // count in NFA_SKIP</a>
<a name="ln5975">            add_state = t-&gt;state-&gt;out;</a>
<a name="ln5976">            add_off = bytelen;</a>
<a name="ln5977">            add_count = bytelen - clen;</a>
<a name="ln5978">          }</a>
<a name="ln5979">        }</a>
<a name="ln5980">        break;</a>
<a name="ln5981">      }</a>
<a name="ln5982">      case NFA_SKIP:</a>
<a name="ln5983">        // character of previous matching \1 .. \9  or \@&gt;</a>
<a name="ln5984">        if (t-&gt;count - clen &lt;= 0) {</a>
<a name="ln5985">          // end of match, go to what follows</a>
<a name="ln5986">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln5987">          add_off = clen;</a>
<a name="ln5988">        } else {</a>
<a name="ln5989">          // add state again with decremented count</a>
<a name="ln5990">          add_state = t-&gt;state;</a>
<a name="ln5991">          add_off = 0;</a>
<a name="ln5992">          add_count = t-&gt;count - clen;</a>
<a name="ln5993">        }</a>
<a name="ln5994">        break;</a>
<a name="ln5995"> </a>
<a name="ln5996">      case NFA_LNUM:</a>
<a name="ln5997">      case NFA_LNUM_GT:</a>
<a name="ln5998">      case NFA_LNUM_LT:</a>
<a name="ln5999">        assert(t-&gt;state-&gt;val &gt;= 0</a>
<a name="ln6000">               &amp;&amp; !((rex.reg_firstlnum &gt; 0</a>
<a name="ln6001">                     &amp;&amp; rex.lnum &gt; LONG_MAX - rex.reg_firstlnum)</a>
<a name="ln6002">                    || (rex.reg_firstlnum &lt; 0</a>
<a name="ln6003">                        &amp;&amp; rex.lnum &lt; LONG_MIN + rex.reg_firstlnum))</a>
<a name="ln6004">               &amp;&amp; rex.lnum + rex.reg_firstlnum &gt;= 0);</a>
<a name="ln6005">        result = (REG_MULTI</a>
<a name="ln6006">                  &amp;&amp; nfa_re_num_cmp((uintmax_t)t-&gt;state-&gt;val,</a>
<a name="ln6007">                                    t-&gt;state-&gt;c - NFA_LNUM,</a>
<a name="ln6008">                                    (uintmax_t)(rex.lnum + rex.reg_firstlnum)));</a>
<a name="ln6009">        if (result) {</a>
<a name="ln6010">          add_here = true;</a>
<a name="ln6011">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6012">        }</a>
<a name="ln6013">        break;</a>
<a name="ln6014"> </a>
<a name="ln6015">      case NFA_COL:</a>
<a name="ln6016">      case NFA_COL_GT:</a>
<a name="ln6017">      case NFA_COL_LT:</a>
<a name="ln6018">        assert(t-&gt;state-&gt;val &gt;= 0</a>
<a name="ln6019">               &amp;&amp; rex.input &gt;= rex.line</a>
<a name="ln6020">               &amp;&amp; (uintmax_t)(rex.input - rex.line) &lt;= UINTMAX_MAX - 1);</a>
<a name="ln6021">        result = nfa_re_num_cmp((uintmax_t)t-&gt;state-&gt;val,</a>
<a name="ln6022">                                t-&gt;state-&gt;c - NFA_COL,</a>
<a name="ln6023">                                (uintmax_t)(rex.input - rex.line + 1));</a>
<a name="ln6024">        if (result) {</a>
<a name="ln6025">          add_here = true;</a>
<a name="ln6026">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6027">        }</a>
<a name="ln6028">        break;</a>
<a name="ln6029"> </a>
<a name="ln6030">      case NFA_VCOL:</a>
<a name="ln6031">      case NFA_VCOL_GT:</a>
<a name="ln6032">      case NFA_VCOL_LT:</a>
<a name="ln6033">        {</a>
<a name="ln6034">          int op = t-&gt;state-&gt;c - NFA_VCOL;</a>
<a name="ln6035">          colnr_T col = (colnr_T)(rex.input - rex.line);</a>
<a name="ln6036"> </a>
<a name="ln6037">          // Bail out quickly when there can't be a match, avoid the overhead of</a>
<a name="ln6038">          // win_linetabsize() on long lines.</a>
<a name="ln6039">          if (op != 1 &amp;&amp; col &gt; t-&gt;state-&gt;val * MB_MAXBYTES) {</a>
<a name="ln6040">            break;</a>
<a name="ln6041">          }</a>
<a name="ln6042"> </a>
<a name="ln6043">          result = false;</a>
<a name="ln6044">          win_T *wp = rex.reg_win == NULL ? curwin : rex.reg_win;</a>
<a name="ln6045">          if (op == 1 &amp;&amp; col - 1 &gt; t-&gt;state-&gt;val &amp;&amp; col &gt; 100) {</a>
<a name="ln6046">            long ts = wp-&gt;w_buffer-&gt;b_p_ts;</a>
<a name="ln6047"> </a>
<a name="ln6048">            // Guess that a character won't use more columns than 'tabstop',</a>
<a name="ln6049">            // with a minimum of 4.</a>
<a name="ln6050">            if (ts &lt; 4) {</a>
<a name="ln6051">              ts = 4;</a>
<a name="ln6052">            }</a>
<a name="ln6053">            result = col &gt; t-&gt;state-&gt;val * ts;</a>
<a name="ln6054">          }</a>
<a name="ln6055">          if (!result) {</a>
<a name="ln6056">            uintmax_t lts = win_linetabsize(wp, rex.line, col);</a>
<a name="ln6057">            assert(t-&gt;state-&gt;val &gt;= 0);</a>
<a name="ln6058">            result = nfa_re_num_cmp((uintmax_t)t-&gt;state-&gt;val, op, lts + 1);</a>
<a name="ln6059">          }</a>
<a name="ln6060">          if (result) {</a>
<a name="ln6061">            add_here = true;</a>
<a name="ln6062">            add_state = t-&gt;state-&gt;out;</a>
<a name="ln6063">          }</a>
<a name="ln6064">        }</a>
<a name="ln6065">        break;</a>
<a name="ln6066"> </a>
<a name="ln6067">      case NFA_MARK:</a>
<a name="ln6068">      case NFA_MARK_GT:</a>
<a name="ln6069">      case NFA_MARK_LT:</a>
<a name="ln6070">      {</a>
<a name="ln6071">        pos_T *pos = getmark_buf(rex.reg_buf, t-&gt;state-&gt;val, false);</a>
<a name="ln6072"> </a>
<a name="ln6073">        // Compare the mark position to the match position, if the mark</a>
<a name="ln6074">        // exists and mark is set in reg_buf.</a>
<a name="ln6075">        if (pos != NULL &amp;&amp; pos-&gt;lnum &gt; 0) {</a>
<a name="ln6076">          const colnr_T pos_col = pos-&gt;lnum == rex.lnum + rex.reg_firstlnum</a>
<a name="ln6077">            &amp;&amp; pos-&gt;col == MAXCOL</a>
<a name="ln6078">            ? (colnr_T)STRLEN(reg_getline(pos-&gt;lnum - rex.reg_firstlnum))</a>
<a name="ln6079">            : pos-&gt;col;</a>
<a name="ln6080"> </a>
<a name="ln6081">          result = pos-&gt;lnum == rex.lnum + rex.reg_firstlnum</a>
<a name="ln6082">            ? (pos_col == (colnr_T)(rex.input - rex.line)</a>
<a name="ln6083">               ? t-&gt;state-&gt;c == NFA_MARK</a>
<a name="ln6084">               : (pos_col &lt; (colnr_T)(rex.input - rex.line)</a>
<a name="ln6085">                  ? t-&gt;state-&gt;c == NFA_MARK_GT</a>
<a name="ln6086">                  : t-&gt;state-&gt;c == NFA_MARK_LT))</a>
<a name="ln6087">            : (pos-&gt;lnum &lt; rex.lnum + rex.reg_firstlnum</a>
<a name="ln6088">               ? t-&gt;state-&gt;c == NFA_MARK_GT</a>
<a name="ln6089">               : t-&gt;state-&gt;c == NFA_MARK_LT);</a>
<a name="ln6090">          if (result) {</a>
<a name="ln6091">            add_here = true;</a>
<a name="ln6092">            add_state = t-&gt;state-&gt;out;</a>
<a name="ln6093">          }</a>
<a name="ln6094">        }</a>
<a name="ln6095">        break;</a>
<a name="ln6096">      }</a>
<a name="ln6097"> </a>
<a name="ln6098">      case NFA_CURSOR:</a>
<a name="ln6099">        result = rex.reg_win != NULL</a>
<a name="ln6100">          &amp;&amp; (rex.lnum + rex.reg_firstlnum == rex.reg_win-&gt;w_cursor.lnum)</a>
<a name="ln6101">          &amp;&amp; ((colnr_T)(rex.input - rex.line) == rex.reg_win-&gt;w_cursor.col);</a>
<a name="ln6102">        if (result) {</a>
<a name="ln6103">          add_here = true;</a>
<a name="ln6104">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6105">        }</a>
<a name="ln6106">        break;</a>
<a name="ln6107"> </a>
<a name="ln6108">      case NFA_VISUAL:</a>
<a name="ln6109">        result = reg_match_visual();</a>
<a name="ln6110">        if (result) {</a>
<a name="ln6111">          add_here = true;</a>
<a name="ln6112">          add_state = t-&gt;state-&gt;out;</a>
<a name="ln6113">        }</a>
<a name="ln6114">        break;</a>
<a name="ln6115"> </a>
<a name="ln6116">      case NFA_MOPEN1:</a>
<a name="ln6117">      case NFA_MOPEN2:</a>
<a name="ln6118">      case NFA_MOPEN3:</a>
<a name="ln6119">      case NFA_MOPEN4:</a>
<a name="ln6120">      case NFA_MOPEN5:</a>
<a name="ln6121">      case NFA_MOPEN6:</a>
<a name="ln6122">      case NFA_MOPEN7:</a>
<a name="ln6123">      case NFA_MOPEN8:</a>
<a name="ln6124">      case NFA_MOPEN9:</a>
<a name="ln6125">      case NFA_ZOPEN:</a>
<a name="ln6126">      case NFA_ZOPEN1:</a>
<a name="ln6127">      case NFA_ZOPEN2:</a>
<a name="ln6128">      case NFA_ZOPEN3:</a>
<a name="ln6129">      case NFA_ZOPEN4:</a>
<a name="ln6130">      case NFA_ZOPEN5:</a>
<a name="ln6131">      case NFA_ZOPEN6:</a>
<a name="ln6132">      case NFA_ZOPEN7:</a>
<a name="ln6133">      case NFA_ZOPEN8:</a>
<a name="ln6134">      case NFA_ZOPEN9:</a>
<a name="ln6135">      case NFA_NOPEN:</a>
<a name="ln6136">      case NFA_ZSTART:</a>
<a name="ln6137">        // These states are only added to be able to bail out when</a>
<a name="ln6138">        // they are added again, nothing is to be done.</a>
<a name="ln6139">        break;</a>
<a name="ln6140"> </a>
<a name="ln6141">      default:          // regular character</a>
<a name="ln6142">      {</a>
<a name="ln6143">        int c = t-&gt;state-&gt;c;</a>
<a name="ln6144"> </a>
<a name="ln6145">#ifdef REGEXP_DEBUG</a>
<a name="ln6146">        if (c &lt; 0) {</a>
<a name="ln6147">          IEMSGN(&quot;INTERNAL: Negative state char: %&quot; PRId64, c);</a>
<a name="ln6148">        }</a>
<a name="ln6149">#endif</a>
<a name="ln6150">        result = (c == curc);</a>
<a name="ln6151"> </a>
<a name="ln6152">        if (!result &amp;&amp; rex.reg_ic) {</a>
<a name="ln6153">          result = utf_fold(c) == utf_fold(curc);</a>
<a name="ln6154">        }</a>
<a name="ln6155"> </a>
<a name="ln6156">        // If rex.reg_icombine is not set only skip over the character</a>
<a name="ln6157">        // itself.  When it is set skip over composing characters.</a>
<a name="ln6158">        if (result &amp;&amp; !rex.reg_icombine) {</a>
<a name="ln6159">          clen = utf_ptr2len(rex.input);</a>
<a name="ln6160">        }</a>
<a name="ln6161"> </a>
<a name="ln6162">        ADD_STATE_IF_MATCH(t-&gt;state);</a>
<a name="ln6163">        break;</a>
<a name="ln6164">      }</a>
<a name="ln6165">      }       // switch (t-&gt;state-&gt;c)</a>
<a name="ln6166"> </a>
<a name="ln6167">      if (add_state != NULL) {</a>
<a name="ln6168">        nfa_pim_T *pim;</a>
<a name="ln6169">        nfa_pim_T pim_copy;</a>
<a name="ln6170"> </a>
<a name="ln6171">        if (t-&gt;pim.result == NFA_PIM_UNUSED)</a>
<a name="ln6172">          pim = NULL;</a>
<a name="ln6173">        else</a>
<a name="ln6174">          pim = &amp;t-&gt;pim;</a>
<a name="ln6175"> </a>
<a name="ln6176">        // Handle the postponed invisible match if the match might end</a>
<a name="ln6177">        // without advancing and before the end of the line.</a>
<a name="ln6178">        if (pim != NULL &amp;&amp; (clen == 0 || match_follows(add_state, 0))) {</a>
<a name="ln6179">          if (pim-&gt;result == NFA_PIM_TODO) {</a>
<a name="ln6180">#ifdef REGEXP_DEBUG</a>
<a name="ln6181">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6182">            fprintf(log_fd, &quot;==================================\n&quot;);</a>
<a name="ln6183">            fprintf(log_fd, &quot;Postponed recursive nfa_regmatch()\n&quot;);</a>
<a name="ln6184">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6185">#endif</a>
<a name="ln6186">            result = recursive_regmatch(pim-&gt;state, pim, prog, submatch, m,</a>
<a name="ln6187">                                        &amp;listids, &amp;listids_len);</a>
<a name="ln6188">            pim-&gt;result = result ? NFA_PIM_MATCH : NFA_PIM_NOMATCH;</a>
<a name="ln6189">            // for \@! and \@&lt;! it is a match when the result is</a>
<a name="ln6190">            // false</a>
<a name="ln6191">            if (result != (pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG</a>
<a name="ln6192">                           || pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln6193">                           || pim-&gt;state-&gt;c</a>
<a name="ln6194">                           == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln6195">                           || pim-&gt;state-&gt;c</a>
<a name="ln6196">                           == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {</a>
<a name="ln6197">              // Copy submatch info from the recursive call</a>
<a name="ln6198">              copy_sub_off(&amp;pim-&gt;subs.norm, &amp;m-&gt;norm);</a>
<a name="ln6199">              if (rex.nfa_has_zsubexpr) {</a>
<a name="ln6200">                copy_sub_off(&amp;pim-&gt;subs.synt, &amp;m-&gt;synt);</a>
<a name="ln6201">              }</a>
<a name="ln6202">            }</a>
<a name="ln6203">          } else {</a>
<a name="ln6204">            result = (pim-&gt;result == NFA_PIM_MATCH);</a>
<a name="ln6205">#ifdef REGEXP_DEBUG</a>
<a name="ln6206">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6207">            fprintf(</a>
<a name="ln6208">                log_fd,</a>
<a name="ln6209">                &quot;Using previous recursive nfa_regmatch() result, result == %d\n&quot;,</a>
<a name="ln6210">                pim-&gt;result);</a>
<a name="ln6211">            fprintf(log_fd, &quot;MATCH = %s\n&quot;, result ? &quot;OK&quot; : &quot;false&quot;);</a>
<a name="ln6212">            fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6213">#endif</a>
<a name="ln6214">          }</a>
<a name="ln6215"> </a>
<a name="ln6216">          // for \@! and \@&lt;! it is a match when result is false</a>
<a name="ln6217">          if (result != (pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG</a>
<a name="ln6218">                         || pim-&gt;state-&gt;c == NFA_START_INVISIBLE_NEG_FIRST</a>
<a name="ln6219">                         || pim-&gt;state-&gt;c</a>
<a name="ln6220">                         == NFA_START_INVISIBLE_BEFORE_NEG</a>
<a name="ln6221">                         || pim-&gt;state-&gt;c</a>
<a name="ln6222">                         == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {</a>
<a name="ln6223">            // Copy submatch info from the recursive call</a>
<a name="ln6224">            copy_sub_off(&amp;t-&gt;subs.norm, &amp;pim-&gt;subs.norm);</a>
<a name="ln6225">            if (rex.nfa_has_zsubexpr) {</a>
<a name="ln6226">              copy_sub_off(&amp;t-&gt;subs.synt, &amp;pim-&gt;subs.synt);</a>
<a name="ln6227">            }</a>
<a name="ln6228">          } else {</a>
<a name="ln6229">            // look-behind match failed, don't add the state</a>
<a name="ln6230">            continue;</a>
<a name="ln6231">          }</a>
<a name="ln6232"> </a>
<a name="ln6233">          // Postponed invisible match was handled, don't add it to</a>
<a name="ln6234">          // following states.</a>
<a name="ln6235">          pim = NULL;</a>
<a name="ln6236">        }</a>
<a name="ln6237"> </a>
<a name="ln6238">        // If &quot;pim&quot; points into l-&gt;t it will become invalid when</a>
<a name="ln6239">        // adding the state causes the list to be reallocated.  Make a</a>
<a name="ln6240">        // local copy to avoid that.</a>
<a name="ln6241">        if (pim == &amp;t-&gt;pim) {</a>
<a name="ln6242">          copy_pim(&amp;pim_copy, pim);</a>
<a name="ln6243">          pim = &amp;pim_copy;</a>
<a name="ln6244">        }</a>
<a name="ln6245"> </a>
<a name="ln6246">        if (add_here) {</a>
<a name="ln6247">          r = addstate_here(thislist, add_state, &amp;t-&gt;subs, pim, &amp;listidx);</a>
<a name="ln6248">        } else {</a>
<a name="ln6249">          r = addstate(nextlist, add_state, &amp;t-&gt;subs, pim, add_off);</a>
<a name="ln6250">          if (add_count &gt; 0) {</a>
<a name="ln6251">            nextlist-&gt;t[nextlist-&gt;n - 1].count = add_count;</a>
<a name="ln6252">          }</a>
<a name="ln6253">        }</a>
<a name="ln6254">        if (r == NULL) {</a>
<a name="ln6255">          nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln6256">          goto theend;</a>
<a name="ln6257">        }</a>
<a name="ln6258">      }</a>
<a name="ln6259">    }     // for (thislist = thislist; thislist-&gt;state; thislist++)</a>
<a name="ln6260"> </a>
<a name="ln6261">    // Look for the start of a match in the current position by adding the</a>
<a name="ln6262">    // start state to the list of states.</a>
<a name="ln6263">    // The first found match is the leftmost one, thus the order of states</a>
<a name="ln6264">    // matters!</a>
<a name="ln6265">    // Do not add the start state in recursive calls of nfa_regmatch(),</a>
<a name="ln6266">    // because recursive calls should only start in the first position.</a>
<a name="ln6267">    // Unless &quot;nfa_endp&quot; is not NULL, then we match the end position.</a>
<a name="ln6268">    // Also don't start a match past the first line.</a>
<a name="ln6269">    if (!nfa_match</a>
<a name="ln6270">        &amp;&amp; ((toplevel</a>
<a name="ln6271">             &amp;&amp; rex.lnum == 0</a>
<a name="ln6272">             &amp;&amp; clen != 0</a>
<a name="ln6273">             &amp;&amp; (rex.reg_maxcol == 0</a>
<a name="ln6274">                 || (colnr_T)(rex.input - rex.line) &lt; rex.reg_maxcol))</a>
<a name="ln6275">            || (nfa_endp != NULL</a>
<a name="ln6276">                &amp;&amp; (REG_MULTI</a>
<a name="ln6277">                    ? (rex.lnum &lt; nfa_endp-&gt;se_u.pos.lnum</a>
<a name="ln6278">                       || (rex.lnum == nfa_endp-&gt;se_u.pos.lnum</a>
<a name="ln6279">                           &amp;&amp; (int)(rex.input - rex.line)</a>
<a name="ln6280">                           &lt; nfa_endp-&gt;se_u.pos.col))</a>
<a name="ln6281">                    : rex.input &lt; nfa_endp-&gt;se_u.ptr)))) {</a>
<a name="ln6282">#ifdef REGEXP_DEBUG</a>
<a name="ln6283">      fprintf(log_fd, &quot;(---) STARTSTATE\n&quot;);</a>
<a name="ln6284">#endif</a>
<a name="ln6285">      // Inline optimized code for addstate() if we know the state is</a>
<a name="ln6286">      // the first MOPEN.</a>
<a name="ln6287">      if (toplevel) {</a>
<a name="ln6288">        int add = true;</a>
<a name="ln6289"> </a>
<a name="ln6290">        if (prog-&gt;regstart != NUL &amp;&amp; clen != 0) {</a>
<a name="ln6291">          if (nextlist-&gt;n == 0) {</a>
<a name="ln6292">            colnr_T col = (colnr_T)(rex.input - rex.line) + clen;</a>
<a name="ln6293"> </a>
<a name="ln6294">            // Nextlist is empty, we can skip ahead to the</a>
<a name="ln6295">            // character that must appear at the start.</a>
<a name="ln6296">            if (skip_to_start(prog-&gt;regstart, &amp;col) == FAIL) {</a>
<a name="ln6297">              break;</a>
<a name="ln6298">            }</a>
<a name="ln6299">#ifdef REGEXP_DEBUG</a>
<a name="ln6300">            fprintf(log_fd, &quot;  Skipping ahead %d bytes to regstart\n&quot;,</a>
<a name="ln6301">                    col - ((colnr_T)(rex.input - rex.line) + clen));</a>
<a name="ln6302">#endif</a>
<a name="ln6303">            rex.input = rex.line + col - clen;</a>
<a name="ln6304">          } else {</a>
<a name="ln6305">            // Checking if the required start character matches is</a>
<a name="ln6306">            // cheaper than adding a state that won't match.</a>
<a name="ln6307">            const int c = PTR2CHAR(rex.input + clen);</a>
<a name="ln6308">            if (c != prog-&gt;regstart</a>
<a name="ln6309">                &amp;&amp; (!rex.reg_ic</a>
<a name="ln6310">                    || utf_fold(c) != utf_fold(prog-&gt;regstart))) {</a>
<a name="ln6311">#ifdef REGEXP_DEBUG</a>
<a name="ln6312">              fprintf(log_fd,</a>
<a name="ln6313">                  &quot;  Skipping start state, regstart does not match\n&quot;);</a>
<a name="ln6314">#endif</a>
<a name="ln6315">              add = false;</a>
<a name="ln6316">            }</a>
<a name="ln6317">          }</a>
<a name="ln6318">        }</a>
<a name="ln6319"> </a>
<a name="ln6320">        if (add) {</a>
<a name="ln6321">          if (REG_MULTI) {</a>
<a name="ln6322">            m-&gt;norm.list.multi[0].start_col =</a>
<a name="ln6323">              (colnr_T)(rex.input - rex.line) + clen;</a>
<a name="ln6324">          } else {</a>
<a name="ln6325">            m-&gt;norm.list.line[0].start = rex.input + clen;</a>
<a name="ln6326">          }</a>
<a name="ln6327">          if (addstate(nextlist, start-&gt;out, m, NULL, clen) == NULL) {</a>
<a name="ln6328">            nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln6329">            goto theend;</a>
<a name="ln6330">          }</a>
<a name="ln6331">        }</a>
<a name="ln6332">      } else {</a>
<a name="ln6333">        if (addstate(nextlist, start, m, NULL, clen) == NULL) {</a>
<a name="ln6334">          nfa_match = NFA_TOO_EXPENSIVE;</a>
<a name="ln6335">          goto theend;</a>
<a name="ln6336">        }</a>
<a name="ln6337">      }</a>
<a name="ln6338">    }</a>
<a name="ln6339"> </a>
<a name="ln6340">#ifdef REGEXP_DEBUG</a>
<a name="ln6341">    fprintf(log_fd, &quot;&gt;&gt;&gt; Thislist had %d states available: &quot;, thislist-&gt;n);</a>
<a name="ln6342">    {</a>
<a name="ln6343">      int i;</a>
<a name="ln6344"> </a>
<a name="ln6345">      for (i = 0; i &lt; thislist-&gt;n; i++)</a>
<a name="ln6346">        fprintf(log_fd, &quot;%d  &quot;, abs(thislist-&gt;t[i].state-&gt;id));</a>
<a name="ln6347">    }</a>
<a name="ln6348">    fprintf(log_fd, &quot;\n&quot;);</a>
<a name="ln6349">#endif</a>
<a name="ln6350"> </a>
<a name="ln6351">nextchar:</a>
<a name="ln6352">    // Advance to the next character, or advance to the next line, or</a>
<a name="ln6353">    // finish.</a>
<a name="ln6354">    if (clen != 0) {</a>
<a name="ln6355">      rex.input += clen;</a>
<a name="ln6356">    } else if (go_to_nextline || (nfa_endp != NULL &amp;&amp; REG_MULTI</a>
<a name="ln6357">                                  &amp;&amp; rex.lnum &lt; nfa_endp-&gt;se_u.pos.lnum)) {</a>
<a name="ln6358">      reg_nextline();</a>
<a name="ln6359">    } else {</a>
<a name="ln6360">      break;</a>
<a name="ln6361">    }</a>
<a name="ln6362"> </a>
<a name="ln6363">    // Allow interrupting with CTRL-C.</a>
<a name="ln6364">    line_breakcheck();</a>
<a name="ln6365">    if (got_int) {</a>
<a name="ln6366">      break;</a>
<a name="ln6367">    }</a>
<a name="ln6368">    // Check for timeout once every twenty times to avoid overhead.</a>
<a name="ln6369">    if (nfa_time_limit != NULL &amp;&amp; ++nfa_time_count == 20) {</a>
<a name="ln6370">      nfa_time_count = 0;</a>
<a name="ln6371">      if (nfa_did_time_out()) {</a>
<a name="ln6372">        break;</a>
<a name="ln6373">      }</a>
<a name="ln6374">    }</a>
<a name="ln6375">  }</a>
<a name="ln6376"> </a>
<a name="ln6377">#ifdef REGEXP_DEBUG</a>
<a name="ln6378">  if (log_fd != stderr)</a>
<a name="ln6379">    fclose(log_fd);</a>
<a name="ln6380">  log_fd = NULL;</a>
<a name="ln6381">#endif</a>
<a name="ln6382"> </a>
<a name="ln6383">theend:</a>
<a name="ln6384">  // Free memory</a>
<a name="ln6385">  xfree(list[0].t);</a>
<a name="ln6386">  xfree(list[1].t);</a>
<a name="ln6387">  xfree(listids);</a>
<a name="ln6388">#undef ADD_STATE_IF_MATCH</a>
<a name="ln6389">#ifdef NFA_REGEXP_DEBUG_LOG</a>
<a name="ln6390">  fclose(debug);</a>
<a name="ln6391">#endif</a>
<a name="ln6392"> </a>
<a name="ln6393">  return nfa_match;</a>
<a name="ln6394">}</a>
<a name="ln6395"> </a>
<a name="ln6396">// Try match of &quot;prog&quot; with at rex.line[&quot;col&quot;].</a>
<a name="ln6397">// Returns &lt;= 0 for failure, number of lines contained in the match otherwise.</a>
<a name="ln6398">static long nfa_regtry(nfa_regprog_T *prog,</a>
<a name="ln6399">                       colnr_T col,</a>
<a name="ln6400">                       proftime_T *tm,    // timeout limit or NULL</a>
<a name="ln6401">                       int *timed_out)    // flag set on timeout or NULL</a>
<a name="ln6402">{</a>
<a name="ln6403">  int i;</a>
<a name="ln6404">  regsubs_T subs, m;</a>
<a name="ln6405">  nfa_state_T *start = prog-&gt;start;</a>
<a name="ln6406">#ifdef REGEXP_DEBUG</a>
<a name="ln6407">  FILE        *f;</a>
<a name="ln6408">#endif</a>
<a name="ln6409"> </a>
<a name="ln6410">  rex.input = rex.line + col;</a>
<a name="ln6411">  nfa_time_limit = tm;</a>
<a name="ln6412">  nfa_timed_out = timed_out;</a>
<a name="ln6413">  nfa_time_count = 0;</a>
<a name="ln6414"> </a>
<a name="ln6415">#ifdef REGEXP_DEBUG</a>
<a name="ln6416">  f = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln6417">  if (f != NULL) {</a>
<a name="ln6418">    fprintf(f,</a>
<a name="ln6419">        &quot;\n\n\t=======================================================\n&quot;);</a>
<a name="ln6420">#ifdef REGEXP_DEBUG</a>
<a name="ln6421">    fprintf(f, &quot;\tRegexp is \&quot;%s\&quot;\n&quot;, nfa_regengine.expr);</a>
<a name="ln6422">#endif</a>
<a name="ln6423">    fprintf(f, &quot;\tInput text is \&quot;%s\&quot; \n&quot;, rex.input);</a>
<a name="ln6424">    fprintf(f, &quot;\t=======================================================\n\n&quot;);</a>
<a name="ln6425">    nfa_print_state(f, start);</a>
<a name="ln6426">    fprintf(f, &quot;\n\n&quot;);</a>
<a name="ln6427">    fclose(f);</a>
<a name="ln6428">  } else {</a>
<a name="ln6429">    EMSG(&quot;Could not open temporary log file for writing&quot;);</a>
<a name="ln6430">  }</a>
<a name="ln6431">#endif</a>
<a name="ln6432"> </a>
<a name="ln6433">  clear_sub(&amp;subs.norm);</a>
<a name="ln6434">  clear_sub(&amp;m.norm);</a>
<a name="ln6435">  clear_sub(&amp;subs.synt);</a>
<a name="ln6436">  clear_sub(&amp;m.synt);</a>
<a name="ln6437"> </a>
<a name="ln6438">  int result = nfa_regmatch(prog, start, &amp;subs, &amp;m);</a>
<a name="ln6439">  if (!result) {</a>
<a name="ln6440">    return 0;</a>
<a name="ln6441">  } else if (result == NFA_TOO_EXPENSIVE) {</a>
<a name="ln6442">    return result;</a>
<a name="ln6443">  }</a>
<a name="ln6444"> </a>
<a name="ln6445">  cleanup_subexpr();</a>
<a name="ln6446">  if (REG_MULTI) {</a>
<a name="ln6447">    for (i = 0; i &lt; subs.norm.in_use; i++) {</a>
<a name="ln6448">      rex.reg_startpos[i].lnum = subs.norm.list.multi[i].start_lnum;</a>
<a name="ln6449">      rex.reg_startpos[i].col = subs.norm.list.multi[i].start_col;</a>
<a name="ln6450"> </a>
<a name="ln6451">      rex.reg_endpos[i].lnum = subs.norm.list.multi[i].end_lnum;</a>
<a name="ln6452">      rex.reg_endpos[i].col = subs.norm.list.multi[i].end_col;</a>
<a name="ln6453">    }</a>
<a name="ln6454"> </a>
<a name="ln6455">    if (rex.reg_startpos[0].lnum &lt; 0) {</a>
<a name="ln6456">      rex.reg_startpos[0].lnum = 0;</a>
<a name="ln6457">      rex.reg_startpos[0].col = col;</a>
<a name="ln6458">    }</a>
<a name="ln6459">    if (rex.reg_endpos[0].lnum &lt; 0) {</a>
<a name="ln6460">      // pattern has a \ze but it didn't match, use current end</a>
<a name="ln6461">      rex.reg_endpos[0].lnum = rex.lnum;</a>
<a name="ln6462">      rex.reg_endpos[0].col = (int)(rex.input - rex.line);</a>
<a name="ln6463">    } else {</a>
<a name="ln6464">      // Use line number of &quot;\ze&quot;.</a>
<a name="ln6465">      rex.lnum = rex.reg_endpos[0].lnum;</a>
<a name="ln6466">    }</a>
<a name="ln6467">  } else {</a>
<a name="ln6468">    for (i = 0; i &lt; subs.norm.in_use; i++) {</a>
<a name="ln6469">      rex.reg_startp[i] = subs.norm.list.line[i].start;</a>
<a name="ln6470">      rex.reg_endp[i] = subs.norm.list.line[i].end;</a>
<a name="ln6471">    }</a>
<a name="ln6472"> </a>
<a name="ln6473">    if (rex.reg_startp[0] == NULL) {</a>
<a name="ln6474">      rex.reg_startp[0] = rex.line + col;</a>
<a name="ln6475">    }</a>
<a name="ln6476">    if (rex.reg_endp[0] == NULL) {</a>
<a name="ln6477">      rex.reg_endp[0] = rex.input;</a>
<a name="ln6478">    }</a>
<a name="ln6479">  }</a>
<a name="ln6480"> </a>
<a name="ln6481">  /* Package any found \z(...\) matches for export. Default is none. */</a>
<a name="ln6482">  unref_extmatch(re_extmatch_out);</a>
<a name="ln6483">  re_extmatch_out = NULL;</a>
<a name="ln6484"> </a>
<a name="ln6485">  if (prog-&gt;reghasz == REX_SET) {</a>
<a name="ln6486">    cleanup_zsubexpr();</a>
<a name="ln6487">    re_extmatch_out = make_extmatch();</a>
<a name="ln6488">    // Loop over \z1, \z2, etc.  There is no \z0.</a>
<a name="ln6489">    for (i = 1; i &lt; subs.synt.in_use; i++) {</a>
<a name="ln6490">      if (REG_MULTI) {</a>
<a name="ln6491">        struct multipos *mpos = &amp;subs.synt.list.multi[i];</a>
<a name="ln6492"> </a>
<a name="ln6493">        // Only accept single line matches that are valid.</a>
<a name="ln6494">        if (mpos-&gt;start_lnum &gt;= 0</a>
<a name="ln6495">            &amp;&amp; mpos-&gt;start_lnum == mpos-&gt;end_lnum</a>
<a name="ln6496">            &amp;&amp; mpos-&gt;end_col &gt;= mpos-&gt;start_col) {</a>
<a name="ln6497">          re_extmatch_out-&gt;matches[i] =</a>
<a name="ln6498">            vim_strnsave(reg_getline(mpos-&gt;start_lnum) + mpos-&gt;start_col,</a>
<a name="ln6499">                         mpos-&gt;end_col - mpos-&gt;start_col);</a>
<a name="ln6500">        }</a>
<a name="ln6501">      } else {</a>
<a name="ln6502">        struct linepos *lpos = &amp;subs.synt.list.line[i];</a>
<a name="ln6503"> </a>
<a name="ln6504">        if (lpos-&gt;start != NULL &amp;&amp; lpos-&gt;end != NULL)</a>
<a name="ln6505">          re_extmatch_out-&gt;matches[i] =</a>
<a name="ln6506">            vim_strnsave(lpos-&gt;start, lpos-&gt;end - lpos-&gt;start);</a>
<a name="ln6507">      }</a>
<a name="ln6508">    }</a>
<a name="ln6509">  }</a>
<a name="ln6510"> </a>
<a name="ln6511">  return 1 + rex.lnum;</a>
<a name="ln6512">}</a>
<a name="ln6513"> </a>
<a name="ln6514">/// Match a regexp against a string (&quot;line&quot; points to the string) or multiple</a>
<a name="ln6515">/// lines (if &quot;line&quot; is NULL, use reg_getline()).</a>
<a name="ln6516">///</a>
<a name="ln6517">/// @param line String in which to search or NULL</a>
<a name="ln6518">/// @param startcol Column to start looking for match</a>
<a name="ln6519">/// @param tm Timeout limit or NULL</a>
<a name="ln6520">/// @param timed_out Flag set on timeout or NULL</a>
<a name="ln6521">///</a>
<a name="ln6522">/// @return &lt;= 0 if there is no match and number of lines contained in the</a>
<a name="ln6523">/// match otherwise.</a>
<a name="ln6524">static long nfa_regexec_both(char_u *line, colnr_T startcol,</a>
<a name="ln6525">                             proftime_T *tm, int *timed_out)</a>
<a name="ln6526">{</a>
<a name="ln6527">  nfa_regprog_T   *prog;</a>
<a name="ln6528">  long retval = 0L;</a>
<a name="ln6529">  colnr_T col = startcol;</a>
<a name="ln6530"> </a>
<a name="ln6531">  if (REG_MULTI) {</a>
<a name="ln6532">    prog = (nfa_regprog_T *)rex.reg_mmatch-&gt;regprog;</a>
<a name="ln6533">    line = reg_getline((linenr_T)0);  // relative to the cursor</a>
<a name="ln6534">    rex.reg_startpos = rex.reg_mmatch-&gt;startpos;</a>
<a name="ln6535">    rex.reg_endpos = rex.reg_mmatch-&gt;endpos;</a>
<a name="ln6536">  } else {</a>
<a name="ln6537">    prog = (nfa_regprog_T *)rex.reg_match-&gt;regprog;</a>
<a name="ln6538">    rex.reg_startp = rex.reg_match-&gt;startp;</a>
<a name="ln6539">    rex.reg_endp = rex.reg_match-&gt;endp;</a>
<a name="ln6540">  }</a>
<a name="ln6541"> </a>
<a name="ln6542">  /* Be paranoid... */</a>
<a name="ln6543">  if (prog == NULL || line == NULL) {</a>
<a name="ln6544">    IEMSG(_(e_null));</a>
<a name="ln6545">    goto theend;</a>
<a name="ln6546">  }</a>
<a name="ln6547"> </a>
<a name="ln6548">  // If pattern contains &quot;\c&quot; or &quot;\C&quot;: overrule value of rex.reg_ic</a>
<a name="ln6549">  if (prog-&gt;regflags &amp; RF_ICASE) {</a>
<a name="ln6550">    rex.reg_ic = true;</a>
<a name="ln6551">  } else if (prog-&gt;regflags &amp; RF_NOICASE) {</a>
<a name="ln6552">    rex.reg_ic = false;</a>
<a name="ln6553">  }</a>
<a name="ln6554"> </a>
<a name="ln6555">  // If pattern contains &quot;\Z&quot; overrule value of rex.reg_icombine</a>
<a name="ln6556">  if (prog-&gt;regflags &amp; RF_ICOMBINE) {</a>
<a name="ln6557">    rex.reg_icombine = true;</a>
<a name="ln6558">  }</a>
<a name="ln6559"> </a>
<a name="ln6560">  rex.line = line;</a>
<a name="ln6561">  rex.lnum = 0;  // relative to line</a>
<a name="ln6562"> </a>
<a name="ln6563">  rex.nfa_has_zend = prog-&gt;has_zend;</a>
<a name="ln6564">  rex.nfa_has_backref = prog-&gt;has_backref;</a>
<a name="ln6565">  rex.nfa_nsubexpr = prog-&gt;nsubexp;</a>
<a name="ln6566">  rex.nfa_listid = 1;</a>
<a name="ln6567">  rex.nfa_alt_listid = 2;</a>
<a name="ln6568">#ifdef REGEXP_DEBUG</a>
<a name="ln6569">  nfa_regengine.expr = prog-&gt;pattern;</a>
<a name="ln6570">#endif</a>
<a name="ln6571"> </a>
<a name="ln6572">  if (prog-&gt;reganch &amp;&amp; col &gt; 0)</a>
<a name="ln6573">    return 0L;</a>
<a name="ln6574"> </a>
<a name="ln6575">  rex.need_clear_subexpr = true;</a>
<a name="ln6576">  // Clear the external match subpointers if necessary.</a>
<a name="ln6577">  if (prog-&gt;reghasz == REX_SET) {</a>
<a name="ln6578">    rex.nfa_has_zsubexpr = true;</a>
<a name="ln6579">    rex.need_clear_zsubexpr = true;</a>
<a name="ln6580">  } else {</a>
<a name="ln6581">    rex.nfa_has_zsubexpr = false;</a>
<a name="ln6582">    rex.need_clear_zsubexpr = false;</a>
<a name="ln6583">  }</a>
<a name="ln6584"> </a>
<a name="ln6585">  if (prog-&gt;regstart != NUL) {</a>
<a name="ln6586">    /* Skip ahead until a character we know the match must start with.</a>
<a name="ln6587">     * When there is none there is no match. */</a>
<a name="ln6588">    if (skip_to_start(prog-&gt;regstart, &amp;col) == FAIL)</a>
<a name="ln6589">      return 0L;</a>
<a name="ln6590"> </a>
<a name="ln6591">    // If match_text is set it contains the full text that must match.</a>
<a name="ln6592">    // Nothing else to try. Doesn't handle combining chars well.</a>
<a name="ln6593">    if (prog-&gt;match_text != NULL &amp;&amp; !rex.reg_icombine) {</a>
<a name="ln6594">      return find_match_text(col, prog-&gt;regstart, prog-&gt;match_text);</a>
<a name="ln6595">    }</a>
<a name="ln6596">  }</a>
<a name="ln6597"> </a>
<a name="ln6598">  // If the start column is past the maximum column: no need to try.</a>
<a name="ln6599">  if (rex.reg_maxcol &gt; 0 &amp;&amp; col &gt;= rex.reg_maxcol) {</a>
<a name="ln6600">    goto theend;</a>
<a name="ln6601">  }</a>
<a name="ln6602"> </a>
<a name="ln6603">  // Set the &quot;nstate&quot; used by nfa_regcomp() to zero to trigger an error when</a>
<a name="ln6604">  // it's accidentally used during execution.</a>
<a name="ln6605">  nstate = 0;</a>
<a name="ln6606">  for (int i = 0; i &lt; prog-&gt;nstate; i++) {</a>
<a name="ln6607">    prog-&gt;state[i].id = i;</a>
<a name="ln6608">    prog-&gt;state[i].lastlist[0] = 0;</a>
<a name="ln6609">    prog-&gt;state[i].lastlist[1] = 0;</a>
<a name="ln6610">  }</a>
<a name="ln6611"> </a>
<a name="ln6612">  retval = nfa_regtry(prog, col, tm, timed_out);</a>
<a name="ln6613"> </a>
<a name="ln6614">#ifdef REGEXP_DEBUG</a>
<a name="ln6615">  nfa_regengine.expr = NULL;</a>
<a name="ln6616">#endif</a>
<a name="ln6617"> </a>
<a name="ln6618">theend:</a>
<a name="ln6619">  if (retval &gt; 0) {</a>
<a name="ln6620">    // Make sure the end is never before the start.  Can happen when \zs and</a>
<a name="ln6621">    // \ze are used.</a>
<a name="ln6622">    if (REG_MULTI) {</a>
<a name="ln6623">      const lpos_T *const start = &amp;rex.reg_mmatch-&gt;startpos[0];</a>
<a name="ln6624">      const lpos_T *const end = &amp;rex.reg_mmatch-&gt;endpos[0];</a>
<a name="ln6625"> </a>
<a name="ln6626">      if (end-&gt;lnum &lt; start-&gt;lnum</a>
<a name="ln6627">          || (end-&gt;lnum == start-&gt;lnum &amp;&amp; end-&gt;col &lt; start-&gt;col)) {</a>
<a name="ln6628">        rex.reg_mmatch-&gt;endpos[0] = rex.reg_mmatch-&gt;startpos[0];</a>
<a name="ln6629">      }</a>
<a name="ln6630">    } else {</a>
<a name="ln6631">      if (rex.reg_match-&gt;endp[0] &lt; rex.reg_match-&gt;startp[0]) {</a>
<a name="ln6632">        rex.reg_match-&gt;endp[0] = rex.reg_match-&gt;startp[0];</a>
<a name="ln6633">      }</a>
<a name="ln6634">    }</a>
<a name="ln6635">  }</a>
<a name="ln6636"> </a>
<a name="ln6637">  return retval;</a>
<a name="ln6638">}</a>
<a name="ln6639"> </a>
<a name="ln6640">/*</a>
<a name="ln6641"> * Compile a regular expression into internal code for the NFA matcher.</a>
<a name="ln6642"> * Returns the program in allocated space.  Returns NULL for an error.</a>
<a name="ln6643"> */</a>
<a name="ln6644">static regprog_T *nfa_regcomp(char_u *expr, int re_flags)</a>
<a name="ln6645">{</a>
<a name="ln6646">  nfa_regprog_T       *prog = NULL;</a>
<a name="ln6647">  int                 *postfix;</a>
<a name="ln6648"> </a>
<a name="ln6649">  if (expr == NULL)</a>
<a name="ln6650">    return NULL;</a>
<a name="ln6651"> </a>
<a name="ln6652">#ifdef REGEXP_DEBUG</a>
<a name="ln6653">  nfa_regengine.expr = expr;</a>
<a name="ln6654">#endif</a>
<a name="ln6655">  nfa_re_flags = re_flags;</a>
<a name="ln6656"> </a>
<a name="ln6657">  init_class_tab();</a>
<a name="ln6658"> </a>
<a name="ln6659">  nfa_regcomp_start(expr, re_flags);</a>
<a name="ln6660"> </a>
<a name="ln6661">  // Build postfix form of the regexp. Needed to build the NFA</a>
<a name="ln6662">  // (and count its size).</a>
<a name="ln6663">  postfix = re2post();</a>
<a name="ln6664">  if (postfix == NULL) {</a>
<a name="ln6665">    goto fail;              // Cascaded (syntax?) error</a>
<a name="ln6666">  }</a>
<a name="ln6667"> </a>
<a name="ln6668">  /*</a>
<a name="ln6669">   * In order to build the NFA, we parse the input regexp twice:</a>
<a name="ln6670">   * 1. first pass to count size (so we can allocate space)</a>
<a name="ln6671">   * 2. second to emit code</a>
<a name="ln6672">   */</a>
<a name="ln6673">#ifdef REGEXP_DEBUG</a>
<a name="ln6674">  {</a>
<a name="ln6675">    FILE *f = fopen(NFA_REGEXP_RUN_LOG, &quot;a&quot;);</a>
<a name="ln6676"> </a>
<a name="ln6677">    if (f != NULL) {</a>
<a name="ln6678">      fprintf(f,</a>
<a name="ln6679">              &quot;\n*****************************\n\n\n\n\t&quot;</a>
<a name="ln6680">              &quot;Compiling regexp \&quot;%s\&quot;... hold on !\n&quot;,</a>
<a name="ln6681">              expr);</a>
<a name="ln6682">      fclose(f);</a>
<a name="ln6683">    }</a>
<a name="ln6684">  }</a>
<a name="ln6685">#endif</a>
<a name="ln6686"> </a>
<a name="ln6687">  /*</a>
<a name="ln6688">   * PASS 1</a>
<a name="ln6689">   * Count number of NFA states in &quot;nstate&quot;. Do not build the NFA.</a>
<a name="ln6690">   */</a>
<a name="ln6691">  post2nfa(postfix, post_ptr, true);</a>
<a name="ln6692"> </a>
<a name="ln6693">  /* allocate the regprog with space for the compiled regexp */</a>
<a name="ln6694">  size_t prog_size = sizeof(nfa_regprog_T) + sizeof(nfa_state_T) * (nstate - 1);</a>
<a name="ln6695">  prog = xmalloc(prog_size);</a>
<a name="ln6696">  state_ptr = prog-&gt;state;</a>
<a name="ln6697">  prog-&gt;re_in_use = false;</a>
<a name="ln6698"> </a>
<a name="ln6699">  /*</a>
<a name="ln6700">   * PASS 2</a>
<a name="ln6701">   * Build the NFA</a>
<a name="ln6702">   */</a>
<a name="ln6703">  prog-&gt;start = post2nfa(postfix, post_ptr, false);</a>
<a name="ln6704">  if (prog-&gt;start == NULL) {</a>
<a name="ln6705">    goto fail;</a>
<a name="ln6706">  }</a>
<a name="ln6707">  prog-&gt;regflags = regflags;</a>
<a name="ln6708">  prog-&gt;engine = &amp;nfa_regengine;</a>
<a name="ln6709">  prog-&gt;nstate = nstate;</a>
<a name="ln6710">  prog-&gt;has_zend = rex.nfa_has_zend;</a>
<a name="ln6711">  prog-&gt;has_backref = rex.nfa_has_backref;</a>
<a name="ln6712">  prog-&gt;nsubexp = regnpar;</a>
<a name="ln6713"> </a>
<a name="ln6714">  nfa_postprocess(prog);</a>
<a name="ln6715"> </a>
<a name="ln6716">  prog-&gt;reganch = nfa_get_reganch(prog-&gt;start, 0);</a>
<a name="ln6717">  prog-&gt;regstart = nfa_get_regstart(prog-&gt;start, 0);</a>
<a name="ln6718">  prog-&gt;match_text = nfa_get_match_text(prog-&gt;start);</a>
<a name="ln6719"> </a>
<a name="ln6720">#ifdef REGEXP_DEBUG</a>
<a name="ln6721">  nfa_postfix_dump(expr, OK);</a>
<a name="ln6722">  nfa_dump(prog);</a>
<a name="ln6723">#endif</a>
<a name="ln6724">  /* Remember whether this pattern has any \z specials in it. */</a>
<a name="ln6725">  prog-&gt;reghasz = re_has_z;</a>
<a name="ln6726">  prog-&gt;pattern = vim_strsave(expr);</a>
<a name="ln6727">#ifdef REGEXP_DEBUG</a>
<a name="ln6728">  nfa_regengine.expr = NULL;</a>
<a name="ln6729">#endif</a>
<a name="ln6730"> </a>
<a name="ln6731">out:</a>
<a name="ln6732">  xfree(post_start);</a>
<a name="ln6733">  post_start = post_ptr = post_end = NULL;</a>
<a name="ln6734">  state_ptr = NULL;</a>
<a name="ln6735">  return (regprog_T *)prog;</a>
<a name="ln6736"> </a>
<a name="ln6737">fail:</a>
<a name="ln6738">  XFREE_CLEAR(prog);</a>
<a name="ln6739">#ifdef REGEXP_DEBUG</a>
<a name="ln6740">  nfa_postfix_dump(expr, FAIL);</a>
<a name="ln6741">  nfa_regengine.expr = NULL;</a>
<a name="ln6742">#endif</a>
<a name="ln6743">  goto out;</a>
<a name="ln6744">}</a>
<a name="ln6745"> </a>
<a name="ln6746">/*</a>
<a name="ln6747"> * Free a compiled regexp program, returned by nfa_regcomp().</a>
<a name="ln6748"> */</a>
<a name="ln6749">static void nfa_regfree(regprog_T *prog)</a>
<a name="ln6750">{</a>
<a name="ln6751">  if (prog != NULL) {</a>
<a name="ln6752">    xfree(((nfa_regprog_T *)prog)-&gt;match_text);</a>
<a name="ln6753">    xfree(((nfa_regprog_T *)prog)-&gt;pattern);</a>
<a name="ln6754">    xfree(prog);</a>
<a name="ln6755">  }</a>
<a name="ln6756">}</a>
<a name="ln6757"> </a>
<a name="ln6758">/*</a>
<a name="ln6759"> * Match a regexp against a string.</a>
<a name="ln6760"> * &quot;rmp-&gt;regprog&quot; is a compiled regexp as returned by nfa_regcomp().</a>
<a name="ln6761"> * Uses curbuf for line count and 'iskeyword'.</a>
<a name="ln6762"> * If &quot;line_lbr&quot; is true, consider a &quot;\n&quot; in &quot;line&quot; to be a line break.</a>
<a name="ln6763"> *</a>
<a name="ln6764"> * Returns &lt;= 0 for failure, number of lines contained in the match otherwise.</a>
<a name="ln6765"> */</a>
<a name="ln6766">static int </a>
<a name="ln6767">nfa_regexec_nl (</a>
<a name="ln6768">    regmatch_T *rmp,</a>
<a name="ln6769">    char_u *line,      /* string to match against */</a>
<a name="ln6770">    colnr_T col,       /* column to start looking for match */</a>
<a name="ln6771">    bool line_lbr</a>
<a name="ln6772">)</a>
<a name="ln6773">{</a>
<a name="ln6774">  rex.reg_match = rmp;</a>
<a name="ln6775">  rex.reg_mmatch = NULL;</a>
<a name="ln6776">  rex.reg_maxline = 0;</a>
<a name="ln6777">  rex.reg_line_lbr = line_lbr;</a>
<a name="ln6778">  rex.reg_buf = curbuf;</a>
<a name="ln6779">  rex.reg_win = NULL;</a>
<a name="ln6780">  rex.reg_ic = rmp-&gt;rm_ic;</a>
<a name="ln6781">  rex.reg_icombine = false;</a>
<a name="ln6782">  rex.reg_maxcol = 0;</a>
<a name="ln6783">  return nfa_regexec_both(line, col, NULL, NULL);</a>
<a name="ln6784">}</a>
<a name="ln6785"> </a>
<a name="ln6786">/// Matches a regexp against multiple lines.</a>
<a name="ln6787">/// &quot;rmp-&gt;regprog&quot; is a compiled regexp as returned by vim_regcomp().</a>
<a name="ln6788">/// Uses curbuf for line count and 'iskeyword'.</a>
<a name="ln6789">///</a>
<a name="ln6790">/// @param win Window in which to search or NULL</a>
<a name="ln6791">/// @param buf Buffer in which to search</a>
<a name="ln6792">/// @param lnum Number of line to start looking for match</a>
<a name="ln6793">/// @param col Column to start looking for match</a>
<a name="ln6794">/// @param tm Timeout limit or NULL</a>
<a name="ln6795">/// @param timed_out Flag set on timeout or NULL</a>
<a name="ln6796">///</a>
<a name="ln6797">/// @return &lt;= 0 if there is no match and number of lines contained in the match</a>
<a name="ln6798">/// otherwise.</a>
<a name="ln6799">///</a>
<a name="ln6800">/// @note The body is the same as bt_regexec() except for nfa_regexec_both()</a>
<a name="ln6801">///</a>
<a name="ln6802">/// @warning</a>
<a name="ln6803">/// Match may actually be in another line. e.g.:</a>
<a name="ln6804">/// when r.e. is \nc, cursor is at 'a' and the text buffer looks like</a>
<a name="ln6805">///</a>
<a name="ln6806">/// @par</a>
<a name="ln6807">///</a>
<a name="ln6808">///     +-------------------------+</a>
<a name="ln6809">///     |a                        |</a>
<a name="ln6810">///     |b                        |</a>
<a name="ln6811">///     |c                        |</a>
<a name="ln6812">///     |                         |</a>
<a name="ln6813">///     +-------------------------+</a>
<a name="ln6814">///</a>
<a name="ln6815">/// @par</a>
<a name="ln6816">/// then nfa_regexec_multi() returns 3. while the original vim_regexec_multi()</a>
<a name="ln6817">/// returns 0 and a second call at line 2 will return 2.</a>
<a name="ln6818">///</a>
<a name="ln6819">/// @par</a>
<a name="ln6820">/// FIXME if this behavior is not compatible.</a>
<a name="ln6821">static long nfa_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf,</a>
<a name="ln6822">                              linenr_T lnum, colnr_T col,</a>
<a name="ln6823">                              proftime_T *tm, int *timed_out)</a>
<a name="ln6824">{</a>
<a name="ln6825">  rex.reg_match = NULL;</a>
<a name="ln6826">  rex.reg_mmatch = rmp;</a>
<a name="ln6827">  rex.reg_buf = buf;</a>
<a name="ln6828">  rex.reg_win = win;</a>
<a name="ln6829">  rex.reg_firstlnum = lnum;</a>
<a name="ln6830">  rex.reg_maxline = rex.reg_buf-&gt;b_ml.ml_line_count - lnum;</a>
<a name="ln6831">  rex.reg_line_lbr = false;</a>
<a name="ln6832">  rex.reg_ic = rmp-&gt;rmm_ic;</a>
<a name="ln6833">  rex.reg_icombine = false;</a>
<a name="ln6834">  rex.reg_maxcol = rmp-&gt;rmm_maxcol;</a>
<a name="ln6835"> </a>
<a name="ln6836">  return nfa_regexec_both(NULL, col, tm, timed_out);</a>
<a name="ln6837">}</a>

</code></pre>
<div class="balloon" rel="6191"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'pim->result' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
